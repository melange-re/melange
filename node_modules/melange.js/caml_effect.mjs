// Generated by Melange

import * as Caml_exceptions from "melange.js/caml_exceptions.mjs";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.mjs";
import * as Caml_option from "melange.js/caml_option.mjs";
import * as Curry from "melange.js/curry.mjs";

const Perform = /* @__PURE__ */ Caml_exceptions.create("Caml_effect.Perform");

const Reperform = /* @__PURE__ */ Caml_exceptions.create("Caml_effect.Reperform");

const Perform_tail_exn = /* @__PURE__ */ Caml_exceptions.create("Caml_effect.Perform_tail_exn");

const Unhandled_effect = /* @__PURE__ */ Caml_exceptions.create("Caml_effect.Unhandled_effect");

const Unsupported_continuation_resumption = /* @__PURE__ */ Caml_exceptions.create("Caml_effect.Unsupported_continuation_resumption");

const current_stack = {
  contents: undefined
};

const empty_raw_backtrace = [];

const continuation_already_resumed_exn = {
  contents: undefined
};

const unhandled_exn_constructor = {
  contents: undefined
};

function caml_set_continuation_already_resumed(exn) {
  continuation_already_resumed_exn.contents = exn;
}

function caml_set_unhandled_exception_constructor(mk) {
  unhandled_exn_constructor.contents = mk;
}

function raise_continuation_already_resumed(param) {
  const exn = continuation_already_resumed_exn.contents;
  if (exn !== undefined) {
    throw exn;
  }
  throw new Caml_js_exceptions.MelangeError(Unsupported_continuation_resumption, {
      MEL_EXN_ID: Unsupported_continuation_resumption
    });
}

function raise_unhandled_effect(eff) {
  const mk = unhandled_exn_constructor.contents;
  if (mk !== undefined) {
    throw Curry._1(mk, eff);
  }
  throw new Caml_js_exceptions.MelangeError(Unhandled_effect, {
      MEL_EXN_ID: Unhandled_effect,
      _1: eff
    });
}

function caml_alloc_stack(retc, exnc, effc) {
  return {
    retc: retc,
    exnc: exnc,
    effc: effc,
    parent: undefined,
    replay_answers: /* [] */ 0,
    replay_index: 0
  };
}

function make_replay_continuation(stack, comp, arg, answers, used) {
  return [
    stack,
    0,
    {
      contents: false
    },
    {
      TAG: /* Replay_payload */ 0,
      _0: {
        stack: stack,
        comp: comp,
        arg: arg,
        answers: answers,
        used: used
      }
    }
  ];
}

function make_tail_continuation(stack, k) {
  return [
    stack,
    0,
    {
      contents: false
    },
    {
      TAG: /* Tail_payload */ 1,
      stack: stack,
      k: k
    }
  ];
}

function continuation_of_value(k) {
  let size;
  try {
    size = k.length | 0;
  }
  catch (exn){
    size = -1;
  }
  if (size < 1) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Effect: invalid continuation value"
      });
  }
  return k;
}

function continuation_stack(param) {
  return param[0];
}

function continuation_payload(param) {
  return param[3];
}

function mark_continuation_used(param) {
  const used = param[2];
  if (used.contents) {
    return raise_continuation_already_resumed();
  } else {
    used.contents = true;
    return;
  }
}

function dispatch_effect(stack, eff, k, k_tail) {
  try {
    return Curry._3(stack.effc, eff, k, k_tail);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Reperform) {
      return propagate_reperform(stack, exn._1, exn._2, exn._3);
    }
    throw exn;
  }
}

function propagate_reperform(stack, eff, k, k_tail) {
  const parent = stack.parent;
  if (parent !== undefined) {
    return dispatch_effect(parent, eff, k, k_tail);
  } else {
    return raise_unhandled_effect(eff);
  }
}

function caml_perform(eff) {
  const stack = current_stack.contents;
  if (stack === undefined) {
    return raise_unhandled_effect(eff);
  }
  const idx = stack.replay_index;
  const answers = stack.replay_answers;
  const nth = function (_l, _i) {
    while (true) {
      const i = _i;
      const l = _l;
      if (!l) {
        return;
      }
      if (i === 0) {
        return Caml_option.some(l.hd);
      }
      _i = i - 1 | 0;
      _l = l.tl;
      continue;
    };
  };
  const answer = nth(answers, idx);
  if (answer !== undefined) {
    stack.replay_index = idx + 1 | 0;
    if (answer.TAG === /* Replay_value */ 0) {
      return answer._0;
    }
    throw answer._0;
  }
  throw new Caml_js_exceptions.MelangeError(Perform, {
      MEL_EXN_ID: Perform,
      _1: eff
    });
}

function caml_perform_tail(eff, k) {
  const stack = current_stack.contents;
  if (stack === undefined) {
    return raise_unhandled_effect(eff);
  }
  const continuation = make_tail_continuation(stack, k);
  try {
    return dispatch_effect(stack, eff, continuation, 0);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    throw new Caml_js_exceptions.MelangeError(Perform_tail_exn, {
        MEL_EXN_ID: Perform_tail_exn,
        _1: exn
      });
  }
}

function caml_reperform(eff, k, k_tail) {
  throw new Caml_js_exceptions.MelangeError(Reperform, {
      MEL_EXN_ID: Reperform,
      _1: eff,
      _2: continuation_of_value(k),
      _3: k_tail
    });
}

function append_replay_answer(answers, used, answer) {
  const take = function (l, n) {
    if (n <= 0 || !l) {
      return /* [] */ 0;
    } else {
      return {
        hd: l.hd,
        tl: take(l.tl, n - 1 | 0)
      };
    }
  };
  const append = function (l, tail) {
    if (l) {
      return {
        hd: l.hd,
        tl: append(l.tl, tail)
      };
    } else {
      return tail;
    }
  };
  return append(take(answers, used), {
    hd: answer,
    tl: /* [] */ 0
  });
}

function runstack_with_answers(stack, comp, arg, answers) {
  const parent = current_stack.contents;
  stack.parent = parent;
  stack.replay_answers = answers;
  stack.replay_index = 0;
  current_stack.contents = stack;
  try {
    const value = Curry._1(comp, arg);
    const result = Curry._1(stack.retc, value);
    current_stack.contents = parent;
    return result;
  }
  catch (raw_eff){
    const eff = Caml_js_exceptions.internalToOCamlException(raw_eff);
    if (eff.MEL_EXN_ID === Perform) {
      const continuation = make_replay_continuation(stack, comp, arg, answers, stack.replay_index);
      const result$1 = dispatch_effect(stack, eff._1, continuation, 0);
      current_stack.contents = parent;
      return result$1;
    }
    if (eff.MEL_EXN_ID === Perform_tail_exn) {
      throw eff._1;
    }
    if (eff.MEL_EXN_ID === Reperform) {
      const eff$1 = eff._1;
      const result$2 = parent !== undefined ? dispatch_effect(parent, eff$1, eff._2, eff._3) : raise_unhandled_effect(eff$1);
      current_stack.contents = parent;
      return result$2;
    }
    const result$3 = Curry._1(stack.exnc, eff);
    current_stack.contents = parent;
    return result$3;
  }
}

function caml_runstack(stack, comp, arg) {
  return runstack_with_answers(stack, comp, arg, /* [] */ 0);
}

function caml_resume(stack, resume_fun, arg, _last_fiber) {
  if (stack.TAG === /* Replay_payload */ 0) {
    const payload = stack._0;
    let answer;
    try {
      answer = {
        TAG: /* Replay_value */ 0,
        _0: Curry._1(resume_fun, arg)
      };
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      answer = {
        TAG: /* Replay_exn */ 1,
        _0: exn
      };
    }
    const answers = append_replay_answer(payload.answers, payload.used, answer);
    return runstack_with_answers(payload.stack, payload.comp, payload.arg, answers);
  }
  const k = stack.k;
  return runstack_with_answers(stack.stack, (function (arg) {
    return Curry._1(k, Curry._1(resume_fun, arg));
  }), arg, /* [] */ 0);
}

function caml_continuation_use_noexc(k) {
  const continuation = continuation_of_value(k);
  mark_continuation_used(continuation);
  return continuation_payload(continuation);
}

function caml_continuation_use_and_update_handler_noexc(k, retc, exnc, effc) {
  const continuation = continuation_of_value(k);
  mark_continuation_used(continuation);
  const payload = continuation_payload(continuation);
  if (payload.TAG === /* Replay_payload */ 0) {
    const payload$1 = payload._0;
    const stack = payload$1.stack;
    const updated = caml_alloc_stack(retc, exnc, effc);
    updated.parent = stack.parent;
    return {
      TAG: /* Replay_payload */ 0,
      _0: {
        stack: updated,
        comp: payload$1.comp,
        arg: payload$1.arg,
        answers: payload$1.answers,
        used: payload$1.used
      }
    };
  }
  const stack$1 = payload.stack;
  const updated$1 = caml_alloc_stack(retc, exnc, effc);
  updated$1.parent = stack$1.parent;
  return {
    TAG: /* Tail_payload */ 1,
    stack: updated$1,
    k: payload.k
  };
}

function caml_get_continuation_callstack(k, param) {
  continuation_of_value(k);
  return empty_raw_backtrace;
}

const default_last_fiber = 0;

export {
  Perform,
  Reperform,
  Perform_tail_exn,
  Unhandled_effect,
  Unsupported_continuation_resumption,
  current_stack,
  default_last_fiber,
  empty_raw_backtrace,
  continuation_already_resumed_exn,
  unhandled_exn_constructor,
  caml_set_continuation_already_resumed,
  caml_set_unhandled_exception_constructor,
  raise_continuation_already_resumed,
  raise_unhandled_effect,
  caml_alloc_stack,
  make_replay_continuation,
  make_tail_continuation,
  continuation_of_value,
  continuation_stack,
  continuation_payload,
  mark_continuation_used,
  dispatch_effect,
  propagate_reperform,
  caml_perform,
  caml_perform_tail,
  caml_reperform,
  append_replay_answer,
  runstack_with_answers,
  caml_runstack,
  caml_resume,
  caml_continuation_use_noexc,
  caml_continuation_use_and_update_handler_noexc,
  caml_get_continuation_callstack,
}
/* No side effect */
