// Generated by Melange
'use strict';

const Caml_js_exceptions = require("melange.js/caml_js_exceptions.js");
const Caml_obj = require("./caml_obj.js");

function init_mod(loc, shape) {
  const undef_module = function (param) {
    throw new Caml_js_exceptions.MelangeError("Undefined_recursive_module", {
        MEL_EXN_ID: "Undefined_recursive_module",
        _1: loc
      });
  };
  const loop = function (shape, struct_, idx) {
    if (/* tag */ typeof shape !== "object" && typeof shape !== "function") {
      switch (shape) {
        case /* Function */ 0 :
          struct_[idx] = undef_module;
          return;
        case /* Lazy */ 1 :
          struct_[idx] = {
            LAZY_DONE: true,
            VAL: undef_module
          };
          return;
        case /* Class */ 2 :
          struct_[idx] = [
            undef_module,
            undef_module,
            undef_module,
            0
          ];
          return;
      }
    } else {
      if (shape.TAG === /* Module */ 0) {
        const comps = shape._0;
        const v = {};
        struct_[idx] = v;
        const len = comps.length;
        for (let i = 0; i < len; ++i) {
          const match = comps[i];
          loop(match[0], v, match[1]);
        }
        return;
      }
      struct_[idx] = shape._0;
      return;
    }
  };
  const res = {};
  const dummy_name = "dummy";
  loop(shape, res, dummy_name);
  return res[dummy_name];
}

function update_mod(shape, o, n) {
  const aux = function (shape, o, n, parent, i) {
    if (/* tag */ typeof shape !== "object" && typeof shape !== "function") {
      switch (shape) {
        case /* Function */ 0 :
          parent[i] = n;
          return;
        case /* Lazy */ 1 :
        case /* Class */ 2 :
          return Caml_obj.update_dummy(o, n);
      }
    } else {
      if (shape.TAG !== /* Module */ 0) {
        return;
      }
      const comps = shape._0;
      for (let i$1 = 0, i_finish = comps.length; i$1 < i_finish; ++i$1) {
        const match = comps[i$1];
        const name = match[1];
        aux(match[0], o[name], n[name], o, name);
      }
      return;
    }
  };
  if (/* tag */ typeof shape !== "object" && typeof shape !== "function") {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "jscomp/runtime/caml_module.ml",
          95,
          9
        ]
      });
  }
  if (shape.TAG === /* Module */ 0) {
    const comps = shape._0;
    for (let i = 0, i_finish = comps.length; i < i_finish; ++i) {
      const match = comps[i];
      const name = match[1];
      aux(match[0], o[name], n[name], o, name);
    }
    return;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
      MEL_EXN_ID: "Assert_failure",
      _1: [
        "jscomp/runtime/caml_module.ml",
        95,
        9
      ]
    });
}

module.exports = {
  init_mod,
  update_mod,
}
/* No side effect */
