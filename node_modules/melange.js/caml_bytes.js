// Generated by Melange
'use strict';

const Caml_int64 = require("./caml_int64.js");
const Caml_js_exceptions = require("melange.js/caml_js_exceptions.js");

function set(s, i, ch) {
  if (i < 0 || i >= s.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "index out of bounds"
      });
  }
  s[i] = ch;
}

function get(s, i) {
  if (i < 0 || i >= s.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "index out of bounds"
      });
  }
  return s[i];
}

function caml_fill_bytes(s, i, l, c) {
  if (l <= 0) {
    return;
  }
  for (let k = i, k_finish = l + i | 0; k < k_finish; ++k) {
    s[k] = c;
  }
}

function caml_create_bytes(len) {
  if (len < 0) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "String.create"
      });
  }
  const result = new Array(len);
  for (let i = 0; i < len; ++i) {
    result[i] = /* '\000' */0;
  }
  return result;
}

function caml_blit_bytes(s1, i1, s2, i2, len) {
  if (len <= 0) {
    return;
  }
  if (s1 === s2) {
    if (i1 < i2) {
      const range_a = (s1.length - i2 | 0) - 1 | 0;
      const range_b = len - 1 | 0;
      const range = range_a > range_b ? range_b : range_a;
      for (let j = range; j >= 0; --j) {
        s1[i2 + j | 0] = s1[i1 + j | 0];
      }
      return;
    }
    if (i1 <= i2) {
      return;
    }
    const range_a$1 = (s1.length - i1 | 0) - 1 | 0;
    const range_b$1 = len - 1 | 0;
    const range$1 = range_a$1 > range_b$1 ? range_b$1 : range_a$1;
    for (let k = 0; k <= range$1; ++k) {
      s1[i2 + k | 0] = s1[i1 + k | 0];
    }
    return;
  }
  const off1 = s1.length - i1 | 0;
  if (len <= off1) {
    for (let i = 0; i < len; ++i) {
      s2[i2 + i | 0] = s1[i1 + i | 0];
    }
    return;
  }
  for (let i$1 = 0; i$1 < off1; ++i$1) {
    s2[i2 + i$1 | 0] = s1[i1 + i$1 | 0];
  }
  for (let i$2 = off1; i$2 < len; ++i$2) {
    s2[i2 + i$2 | 0] = /* '\000' */0;
  }
}

function bytes_to_string(a) {
  let i = 0;
  let len = a.length;
  let s = "";
  let s_len = len;
  if (i === 0 && len <= 4096 && len === a.length) {
    return String.fromCharCode.apply(null, a);
  }
  let offset = 0;
  while (s_len > 0) {
    const next = s_len < 1024 ? s_len : 1024;
    const tmp_bytes = new Array(next);
    for (let k = 0; k < next; ++k) {
      tmp_bytes[k] = a[k + offset | 0];
    }
    s = s + String.fromCharCode.apply(null, tmp_bytes);
    s_len = s_len - next | 0;
    offset = offset + next | 0;
  };
  return s;
}

function caml_blit_string(s1, i1, s2, i2, len) {
  if (len <= 0) {
    return;
  }
  const off1 = s1.length - i1 | 0;
  if (len <= off1) {
    for (let i = 0; i < len; ++i) {
      s2[i2 + i | 0] = s1.charCodeAt(i1 + i | 0);
    }
    return;
  }
  for (let i$1 = 0; i$1 < off1; ++i$1) {
    s2[i2 + i$1 | 0] = s1.charCodeAt(i1 + i$1 | 0);
  }
  for (let i$2 = off1; i$2 < len; ++i$2) {
    s2[i2 + i$2 | 0] = /* '\000' */0;
  }
}

function bytes_of_string(s) {
  const len = s.length;
  const res = new Array(len);
  for (let i = 0; i < len; ++i) {
    res[i] = s.charCodeAt(i);
  }
  return res;
}

function caml_bytes_compare_aux(s1, s2, _off, len, def) {
  while (true) {
    const off = _off;
    if (off >= len) {
      return def;
    }
    const a = s1[off];
    const b = s2[off];
    if (a > b) {
      return 1;
    }
    if (a < b) {
      return -1;
    }
    _off = off + 1 | 0;
    continue;
  };
}

function caml_bytes_compare(s1, s2) {
  const len1 = s1.length;
  const len2 = s2.length;
  if (len1 === len2) {
    return caml_bytes_compare_aux(s1, s2, 0, len1, 0);
  } else if (len1 < len2) {
    return caml_bytes_compare_aux(s1, s2, 0, len1, -1);
  } else {
    return caml_bytes_compare_aux(s1, s2, 0, len2, 1);
  }
}

function caml_bytes_equal(s1, s2) {
  const len1 = s1.length;
  const len2 = s2.length;
  if (len1 === len2) {
    let _off = 0;
    while (true) {
      const off = _off;
      if (off === len1) {
        return true;
      }
      const a = s1[off];
      const b = s2[off];
      if (a !== b) {
        return false;
      }
      _off = off + 1 | 0;
      continue;
    };
  } else {
    return false;
  }
}

function caml_bytes_greaterthan(s1, s2) {
  return caml_bytes_compare(s1, s2) > 0;
}

function caml_bytes_greaterequal(s1, s2) {
  return caml_bytes_compare(s1, s2) >= 0;
}

function caml_bytes_lessthan(s1, s2) {
  return caml_bytes_compare(s1, s2) < 0;
}

function caml_bytes_lessequal(s1, s2) {
  return caml_bytes_compare(s1, s2) <= 0;
}

function bswap16(x) {
  return ((x & 255) << 8) | ((x & 65280) >>> 8);
}

function bswap32(x) {
  return ((x & 255) << 24) | ((x & 65280) << 8) | ((x & 16711680) >>> 8) | ((x & -16777216) >>> 24);
}

function bswap64(x) {
  return Caml_int64.or_(Caml_int64.or_(Caml_int64.or_(Caml_int64.or_(Caml_int64.or_(Caml_int64.or_(Caml_int64.or_(Caml_int64.lsl_(Caml_int64.and_(x, [
    0,
    255
  ]), 56), Caml_int64.lsl_(Caml_int64.and_(x, [
    0,
    65280
  ]), 40)), Caml_int64.lsl_(Caml_int64.and_(x, [
    0,
    16711680
  ]), 24)), Caml_int64.lsl_(Caml_int64.and_(x, [
    0,
    4278190080
  ]), 8)), Caml_int64.lsr_(Caml_int64.and_(x, [
    255,
    0
  ]), 8)), Caml_int64.lsr_(Caml_int64.and_(x, [
    65280,
    0
  ]), 24)), Caml_int64.lsr_(Caml_int64.and_(x, [
    16711680,
    0
  ]), 40)), Caml_int64.lsr_(Caml_int64.and_(x, [
    -16777216,
    0
  ]), 56));
}

function get16u(str, idx) {
  const b1 = str[idx];
  const b2 = str[idx + 1 | 0];
  return (b2 << 8) | b1;
}

function get16(str, idx) {
  if (idx < 0 || (idx + 1 | 0) >= str.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "index out of bounds"
      });
  }
  return get16u(str, idx);
}

function get32(str, idx) {
  if (idx < 0 || (idx + 3 | 0) >= str.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "index out of bounds"
      });
  }
  const b1 = str[idx];
  const b2 = str[idx + 1 | 0];
  const b3 = str[idx + 2 | 0];
  const b4 = str[idx + 3 | 0];
  return (b4 << 24) | (b3 << 16) | (b2 << 8) | b1;
}

function get64(str, idx) {
  if (idx < 0 || (idx + 7 | 0) >= str.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "index out of bounds"
      });
  }
  const b1 = str[idx];
  const b2 = str[idx + 1 | 0];
  const b3 = str[idx + 2 | 0];
  const b4 = str[idx + 3 | 0];
  const b5 = str[idx + 4 | 0];
  const b6 = str[idx + 5 | 0];
  const b7 = str[idx + 6 | 0];
  const b8 = str[idx + 7 | 0];
  return Caml_int64.or_(Caml_int64.lsl_(Caml_int64.or_(Caml_int64.lsl_(Caml_int64.or_(Caml_int64.lsl_(Caml_int64.or_(Caml_int64.lsl_(Caml_int64.or_(Caml_int64.lsl_(Caml_int64.or_(Caml_int64.lsl_(Caml_int64.or_(Caml_int64.lsl_(Caml_int64.of_int32(b8), 56), Caml_int64.of_int32(b7)), 48), Caml_int64.of_int32(b6)), 40), Caml_int64.of_int32(b5)), 32), Caml_int64.of_int32(b4)), 24), Caml_int64.of_int32(b3)), 16), Caml_int64.of_int32(b2)), 8), Caml_int64.of_int32(b1));
}

function set16u(b, idx, newval) {
  const b2 = 255 & (newval >>> 8);
  const b1 = 255 & newval;
  b[idx] = b1;
  b[idx + 1 | 0] = b2;
}

function set16(b, idx, newval) {
  if (idx < 0 || (idx + 1 | 0) >= b.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "index out of bounds"
      });
  }
  set16u(b, idx, newval);
}

function set32u(str, idx, newval) {
  const b4 = 255 & (newval >>> 24);
  const b3 = 255 & (newval >>> 16);
  const b2 = 255 & (newval >>> 8);
  const b1 = 255 & newval;
  str[idx] = b1;
  str[idx + 1 | 0] = b2;
  str[idx + 2 | 0] = b3;
  str[idx + 3 | 0] = b4;
}

function set32(str, idx, newval) {
  if (idx < 0 || (idx + 3 | 0) >= str.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "index out of bounds"
      });
  }
  set32u(str, idx, newval);
}

function set64u(str, idx, newval) {
  const x = Caml_int64.lsr_(newval, 56);
  const b8 = 255 & (x[1] | 0);
  const x$1 = Caml_int64.lsr_(newval, 48);
  const b7 = 255 & (x$1[1] | 0);
  const x$2 = Caml_int64.lsr_(newval, 40);
  const b6 = 255 & (x$2[1] | 0);
  const x$3 = Caml_int64.lsr_(newval, 32);
  const b5 = 255 & (x$3[1] | 0);
  const x$4 = Caml_int64.lsr_(newval, 24);
  const b4 = 255 & (x$4[1] | 0);
  const x$5 = Caml_int64.lsr_(newval, 16);
  const b3 = 255 & (x$5[1] | 0);
  const x$6 = Caml_int64.lsr_(newval, 8);
  const b2 = 255 & (x$6[1] | 0);
  const b1 = 255 & (newval[1] | 0);
  str[idx] = b1;
  str[idx + 1 | 0] = b2;
  str[idx + 2 | 0] = b3;
  str[idx + 3 | 0] = b4;
  str[idx + 4 | 0] = b5;
  str[idx + 5 | 0] = b6;
  str[idx + 6 | 0] = b7;
  str[idx + 7 | 0] = b8;
}

function set64(str, idx, newval) {
  if (idx < 0 || (idx + 7 | 0) >= str.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "index out of bounds"
      });
  }
  set64u(str, idx, newval);
}

module.exports = {
  caml_create_bytes,
  caml_fill_bytes,
  get,
  set,
  bytes_to_string,
  caml_blit_bytes,
  caml_blit_string,
  bytes_of_string,
  caml_bytes_compare,
  caml_bytes_greaterthan,
  caml_bytes_greaterequal,
  caml_bytes_lessthan,
  caml_bytes_lessequal,
  caml_bytes_equal,
  bswap16,
  bswap32,
  bswap64,
  get16u,
  get16,
  get32,
  get64,
  set16u,
  set16,
  set32u,
  set32,
  set64u,
  set64,
}
/* No side effect */
