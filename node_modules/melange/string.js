// Generated by Melange
'use strict';

const Caml = require("melange.js/caml.js");
const Caml_array = require("melange.js/caml_array.js");
const Caml_bytes = require("melange.js/caml_bytes.js");
const Caml_hash = require("melange.js/caml_hash.js");
const Caml_js_exceptions = require("melange.js/caml_js_exceptions.js");
const Caml_string = require("melange.js/caml_string.js");
const Curry = require("melange.js/curry.js");
const Stdlib = require("./stdlib.js");
const Stdlib__Array = require("./array.js");
const Stdlib__Bytes = require("./bytes.js");
const Stdlib__Int = require("./int.js");
const Stdlib__List = require("./list.js");
const Stdlib__Uchar = require("./uchar.js");

function make(n, c) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.make(n, c));
}

function init(n, f) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.init(n, f));
}

function sub(s, ofs, len) {
  if (ofs === 0 && s.length === len) {
    return s;
  } else {
    return Caml_bytes.bytes_to_string(Stdlib__Bytes.sub(Caml_bytes.bytes_of_string(s), ofs, len));
  }
}

function ensure_ge(x, y) {
  if (x >= y) {
    return x;
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "String.concat"
    });
}

function sum_lengths(_acc, seplen, _param) {
  while (true) {
    const param = _param;
    const acc = _acc;
    if (!param) {
      return acc;
    }
    const hd = param.hd;
    if (!param.tl) {
      return hd.length + acc | 0;
    }
    _param = param.tl;
    _acc = ensure_ge((hd.length + seplen | 0) + acc | 0, acc);
    continue;
  };
}

function unsafe_blits(dst, _pos, sep, seplen, _param) {
  while (true) {
    const param = _param;
    const pos = _pos;
    if (!param) {
      return dst;
    }
    const hd = param.hd;
    if (param.tl) {
      Caml_bytes.caml_blit_string(hd, 0, dst, pos, hd.length);
      Caml_bytes.caml_blit_string(sep, 0, dst, pos + hd.length | 0, seplen);
      _param = param.tl;
      _pos = (pos + hd.length | 0) + seplen | 0;
      continue;
    }
    Caml_bytes.caml_blit_string(hd, 0, dst, pos, hd.length);
    return dst;
  };
}

function concat(sep, l) {
  if (!l) {
    return "";
  }
  if (!l.tl) {
    return l.hd;
  }
  const seplen = sep.length;
  return Caml_bytes.bytes_to_string(unsafe_blits(Caml_bytes.caml_create_bytes(sum_lengths(0, seplen, l)), 0, sep, seplen, l));
}

function cat(prim0, prim1) {
  return prim0 + prim1;
}

function iter(f, s) {
  for (let i = 0, i_finish = s.length; i < i_finish; ++i) {
    Curry._1(f, s.charCodeAt(i));
  }
}

function iteri(f, s) {
  for (let i = 0, i_finish = s.length; i < i_finish; ++i) {
    Curry._2(f, i, s.charCodeAt(i));
  }
}

function map(f, s) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.map(f, Caml_bytes.bytes_of_string(s)));
}

function mapi(f, s) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.mapi(f, Caml_bytes.bytes_of_string(s)));
}

function fold_right(f, x, a) {
  return Stdlib__Bytes.fold_right(f, Caml_bytes.bytes_of_string(x), a);
}

function fold_left(f, a, x) {
  return Stdlib__Bytes.fold_left(f, a, Caml_bytes.bytes_of_string(x));
}

function exists(f, s) {
  return Stdlib__Bytes.exists(f, Caml_bytes.bytes_of_string(s));
}

function for_all(f, s) {
  return Stdlib__Bytes.for_all(f, Caml_bytes.bytes_of_string(s));
}

function is_space(param) {
  if (param > 13 || param < 9) {
    return param === 32;
  } else {
    return param !== 11;
  }
}

function trim(s) {
  if (s === "" || !(is_space(s.charCodeAt(0)) || is_space(s.charCodeAt(s.length - 1 | 0)))) {
    return s;
  } else {
    return Caml_bytes.bytes_to_string(Stdlib__Bytes.trim(Caml_bytes.bytes_of_string(s)));
  }
}

function escaped(s) {
  const b = Caml_bytes.bytes_of_string(s);
  const b$p = Stdlib__Bytes.unsafe_escape(b);
  if (b === b$p) {
    return s;
  } else {
    return Caml_bytes.bytes_to_string(b$p);
  }
}

function index_rec(s, lim, _i, c) {
  while (true) {
    const i = _i;
    if (i >= lim) {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
          MEL_EXN_ID: Stdlib.Not_found
        });
    }
    if (s.charCodeAt(i) === c) {
      return i;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function index(s, c) {
  return index_rec(s, s.length, 0, c);
}

function index_rec_opt(s, lim, _i, c) {
  while (true) {
    const i = _i;
    if (i >= lim) {
      return;
    }
    if (s.charCodeAt(i) === c) {
      return i;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function index_opt(s, c) {
  return index_rec_opt(s, s.length, 0, c);
}

function index_from(s, i, c) {
  const l = s.length;
  if (i < 0 || i > l) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "String.index_from / Bytes.index_from"
      });
  }
  return index_rec(s, l, i, c);
}

function index_from_opt(s, i, c) {
  const l = s.length;
  if (i < 0 || i > l) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "String.index_from_opt / Bytes.index_from_opt"
      });
  }
  return index_rec_opt(s, l, i, c);
}

function rindex_rec(s, _i, c) {
  while (true) {
    const i = _i;
    if (i < 0) {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
          MEL_EXN_ID: Stdlib.Not_found
        });
    }
    if (s.charCodeAt(i) === c) {
      return i;
    }
    _i = i - 1 | 0;
    continue;
  };
}

function rindex(s, c) {
  return rindex_rec(s, s.length - 1 | 0, c);
}

function rindex_from(s, i, c) {
  if (i < -1 || i >= s.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "String.rindex_from / Bytes.rindex_from"
      });
  }
  return rindex_rec(s, i, c);
}

function rindex_rec_opt(s, _i, c) {
  while (true) {
    const i = _i;
    if (i < 0) {
      return;
    }
    if (s.charCodeAt(i) === c) {
      return i;
    }
    _i = i - 1 | 0;
    continue;
  };
}

function rindex_opt(s, c) {
  return rindex_rec_opt(s, s.length - 1 | 0, c);
}

function rindex_from_opt(s, i, c) {
  if (i < -1 || i >= s.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "String.rindex_from_opt / Bytes.rindex_from_opt"
      });
  }
  return rindex_rec_opt(s, i, c);
}

function contains_from(s, i, c) {
  const l = s.length;
  if (i < 0 || i > l) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "String.contains_from / Bytes.contains_from"
      });
  }
  try {
    index_rec(s, l, i, c);
    return true;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return false;
    }
    throw exn;
  }
}

function contains(s, c) {
  return contains_from(s, 0, c);
}

function rcontains_from(s, i, c) {
  if (i < 0 || i >= s.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "String.rcontains_from / Bytes.rcontains_from"
      });
  }
  try {
    rindex_rec(s, i, c);
    return true;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return false;
    }
    throw exn;
  }
}

function uppercase_ascii(s) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.uppercase_ascii(Caml_bytes.bytes_of_string(s)));
}

function lowercase_ascii(s) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.lowercase_ascii(Caml_bytes.bytes_of_string(s)));
}

function capitalize_ascii(s) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.capitalize_ascii(Caml_bytes.bytes_of_string(s)));
}

function uncapitalize_ascii(s) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.uncapitalize_ascii(Caml_bytes.bytes_of_string(s)));
}

function starts_with(prefix, s) {
  const len_s = s.length;
  const len_pre = prefix.length;
  if (len_s >= len_pre) {
    let _i = 0;
    while (true) {
      const i = _i;
      if (i === len_pre) {
        return true;
      }
      if (s.charCodeAt(i) !== prefix.charCodeAt(i)) {
        return false;
      }
      _i = i + 1 | 0;
      continue;
    };
  } else {
    return false;
  }
}

function ends_with(suffix, s) {
  const len_s = s.length;
  const len_suf = suffix.length;
  const diff = len_s - len_suf | 0;
  if (diff >= 0) {
    let _i = 0;
    while (true) {
      const i = _i;
      if (i === len_suf) {
        return true;
      }
      if (s.charCodeAt(diff + i | 0) !== suffix.charCodeAt(i)) {
        return false;
      }
      _i = i + 1 | 0;
      continue;
    };
  } else {
    return false;
  }
}

function hash(x) {
  return Caml_hash.caml_string_hash(0, x);
}

function split_on_char(sep, s) {
  let r = /* [] */ 0;
  let j = s.length;
  for (let i = s.length - 1 | 0; i >= 0; --i) {
    if (s.charCodeAt(i) === sep) {
      r = {
        hd: sub(s, i + 1 | 0, (j - i | 0) - 1 | 0),
        tl: r
      };
      j = i;
    }
    
  }
  return {
    hd: sub(s, 0, j),
    tl: r
  };
}

const compare = Caml.caml_string_compare;

function to_seq(s) {
  return Stdlib__Bytes.to_seq(Caml_bytes.bytes_of_string(s));
}

function to_seqi(s) {
  return Stdlib__Bytes.to_seqi(Caml_bytes.bytes_of_string(s));
}

function of_seq(g) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.of_seq(g));
}

function get_utf_8_uchar(s, i) {
  return Stdlib__Bytes.get_utf_8_uchar(Caml_bytes.bytes_of_string(s), i);
}

function is_valid_utf_8(s) {
  return Stdlib__Bytes.is_valid_utf_8(Caml_bytes.bytes_of_string(s));
}

function get_utf_16be_uchar(s, i) {
  return Stdlib__Bytes.get_utf_16be_uchar(Caml_bytes.bytes_of_string(s), i);
}

function is_valid_utf_16be(s) {
  return Stdlib__Bytes.is_valid_utf_16be(Caml_bytes.bytes_of_string(s));
}

function get_utf_16le_uchar(s, i) {
  return Stdlib__Bytes.get_utf_16le_uchar(Caml_bytes.bytes_of_string(s), i);
}

function is_valid_utf_16le(s) {
  return Stdlib__Bytes.is_valid_utf_16le(Caml_bytes.bytes_of_string(s));
}

function get_int8(s, i) {
  return Stdlib__Bytes.get_int8(Caml_bytes.bytes_of_string(s), i);
}

function get_uint16_le(s, i) {
  return Stdlib__Bytes.get_uint16_le(Caml_bytes.bytes_of_string(s), i);
}

function get_uint16_be(s, i) {
  return Stdlib__Bytes.get_uint16_be(Caml_bytes.bytes_of_string(s), i);
}

function get_int16_ne(s, i) {
  return Stdlib__Bytes.get_int16_ne(Caml_bytes.bytes_of_string(s), i);
}

function get_int16_le(s, i) {
  return Stdlib__Bytes.get_int16_le(Caml_bytes.bytes_of_string(s), i);
}

function get_int16_be(s, i) {
  return Stdlib__Bytes.get_int16_be(Caml_bytes.bytes_of_string(s), i);
}

function get_int32_le(s, i) {
  return Stdlib__Bytes.get_int32_le(Caml_bytes.bytes_of_string(s), i);
}

function get_int32_be(s, i) {
  return Stdlib__Bytes.get_int32_be(Caml_bytes.bytes_of_string(s), i);
}

function get_int64_le(s, i) {
  return Stdlib__Bytes.get_int64_le(Caml_bytes.bytes_of_string(s), i);
}

function get_int64_be(s, i) {
  return Stdlib__Bytes.get_int64_be(Caml_bytes.bytes_of_string(s), i);
}

function utf_8_uchar_length(s) {
  const slen = s.length;
  let i = 0;
  let ulen = 0;
  while (i < slen) {
    const dec_len = Stdlib__Uchar.utf_8_decode_length_of_byte(s.charCodeAt(i));
    i = i + (
      dec_len === 0 ? 1 : dec_len
    ) | 0;
    ulen = ulen + 1 | 0;
  };
  return ulen;
}

function uchar_array_of_utf_8_string(s) {
  const slen = s.length;
  const uchars = Caml_array.make(slen, Stdlib__Uchar.max);
  let k = 0;
  let i = 0;
  while (i < slen) {
    const dec = get_utf_8_uchar(s, i);
    i = i + ((dec >>> 24) & 7) | 0;
    Caml_array.set(uchars, k, dec & 16777215);
    k = k + 1 | 0;
  };
  return [
    uchars,
    k
  ];
}

function edit_distance$p(limitOpt, s, param, s1) {
  const limit = limitOpt !== undefined ? limitOpt : Stdlib__Int.max_int;
  const len0 = param[1];
  const s0 = param[0];
  if (limit <= 1) {
    if (s === s1) {
      return 0;
    } else {
      return limit;
    }
  }
  const match = uchar_array_of_utf_8_string(s1);
  const len1 = match[1];
  const s1$1 = match[0];
  const limit$1 = Stdlib__Int.min(Stdlib__Int.max(len0, len1), limit);
  if (Stdlib__Int.abs(len1 - len0 | 0) >= limit$1) {
    return limit$1;
  }
  const match$1 = len0 > len1 ? [
      s0,
      s1$1
    ] : [
      s1$1,
      s0
    ];
  const match$2 = len0 > len1 ? [
      len0,
      len1
    ] : [
      len1,
      len0
    ];
  const len1$1 = match$2[1];
  const loop = function (_row_minus2, _row_minus1, _row, _i, len0, limit, s0, s1) {
    while (true) {
      const i = _i;
      const row = _row;
      const row_minus1 = _row_minus1;
      const row_minus2 = _row_minus2;
      if (i > len0) {
        return Caml_array.get(row_minus1, row_minus1.length - 1 | 0);
      }
      const len1 = row.length - 1 | 0;
      let row_min = Stdlib__Int.max_int;
      Caml_array.set(row, 0, i);
      const jmax = Stdlib__Int.min(len1, (i + limit | 0) - 1 | 0);
      const jmax$1 = jmax < 0 ? len1 : jmax;
      for (let j = Stdlib__Int.max(1, i - limit | 0); j <= jmax$1; ++j) {
        const cost = Caml_array.get(s0, i - 1 | 0) === Caml_array.get(s1, j - 1 | 0) ? 0 : 1;
        const min = Stdlib__Int.min(Caml_array.get(row_minus1, j - 1 | 0) + cost | 0, Stdlib__Int.min(Caml_array.get(row_minus1, j) + 1 | 0, Caml_array.get(row, j - 1 | 0) + 1 | 0));
        const min$1 = i > 1 && j > 1 && Caml_array.get(s0, i - 1 | 0) === Caml_array.get(s1, j - 2 | 0) && Caml_array.get(s0, i - 2 | 0) === Caml_array.get(s1, j - 1 | 0) ? Stdlib__Int.min(min, Caml_array.get(row_minus2, j - 2 | 0) + cost | 0) : min;
        Caml_array.set(row, j, min$1);
        row_min = Stdlib__Int.min(row_min, min$1);
      }
      if (row_min >= limit) {
        return limit;
      }
      _i = i + 1 | 0;
      _row = row_minus2;
      _row_minus1 = row;
      _row_minus2 = row_minus1;
      continue;
    };
  };
  const ignore = limit$1 + 1 | 0;
  const row_minus2 = Caml_array.make(len1$1 + 1 | 0, ignore);
  const row_minus1 = Stdlib__Array.init(len1$1 + 1 | 0, (function (x) {
    return x;
  }));
  const row = Caml_array.make(len1$1 + 1 | 0, ignore);
  const d = loop(row_minus2, row_minus1, row, 1, match$2[0], limit$1, match$1[0], match$1[1]);
  if (d > limit$1) {
    return limit$1;
  } else {
    return d;
  }
}

function edit_distance(limit, s0, s1) {
  const us0 = uchar_array_of_utf_8_string(s0);
  return edit_distance$p(limit, s0, us0, s1);
}

function default_max_dist(s) {
  const match = utf_8_uchar_length(s);
  if (match >= 3) {
    if (match >= 5) {
      return 2;
    } else {
      return 1;
    }
  } else if (match >= 0) {
    return 0;
  } else {
    return 2;
  }
}

function spellcheck(max_distOpt, iter_dict, s) {
  const max_dist = max_distOpt !== undefined ? max_distOpt : default_max_dist;
  const min = {
    contents: Curry._1(max_dist, s)
  };
  const acc = {
    contents: /* [] */ 0
  };
  const us = uchar_array_of_utf_8_string(s);
  Curry._1(iter_dict, (function (param) {
    const d = edit_distance$p(min.contents + 1 | 0, s, us, param);
    if (d === min.contents) {
      acc.contents = {
        hd: param,
        tl: acc.contents
      };
      return;
    } else if (d < min.contents) {
      min.contents = d;
      acc.contents = {
        hd: param,
        tl: /* [] */ 0
      };
      return;
    } else {
      return;
    }
  }));
  return Stdlib__List.rev(acc.contents);
}

const empty = "";

const of_bytes = Stdlib__Bytes.to_string;

const to_bytes = Stdlib__Bytes.of_string;

const blit = Stdlib__Bytes.blit_string;

function equal(prim0, prim1) {
  return prim0 === prim1;
}

const get_uint8 = Caml_string.get;

const get_uint16_ne = Caml_bytes.get16;

const get_int32_ne = Caml_bytes.get32;

const seeded_hash = Caml_hash.caml_string_hash;

const get_int64_ne = Caml_bytes.get64;

module.exports = {
  make,
  init,
  empty,
  of_bytes,
  to_bytes,
  blit,
  concat,
  cat,
  equal,
  compare,
  starts_with,
  ends_with,
  contains_from,
  rcontains_from,
  contains,
  sub,
  split_on_char,
  map,
  mapi,
  fold_left,
  fold_right,
  for_all,
  exists,
  trim,
  escaped,
  uppercase_ascii,
  lowercase_ascii,
  capitalize_ascii,
  uncapitalize_ascii,
  iter,
  iteri,
  index_from,
  index_from_opt,
  rindex_from,
  rindex_from_opt,
  index,
  index_opt,
  rindex,
  rindex_opt,
  to_seq,
  to_seqi,
  of_seq,
  get_utf_8_uchar,
  is_valid_utf_8,
  get_utf_16be_uchar,
  is_valid_utf_16be,
  get_utf_16le_uchar,
  is_valid_utf_16le,
  edit_distance,
  spellcheck,
  get_uint8,
  get_int8,
  get_uint16_ne,
  get_uint16_be,
  get_uint16_le,
  get_int16_ne,
  get_int16_be,
  get_int16_le,
  get_int32_ne,
  hash,
  seeded_hash,
  get_int32_be,
  get_int32_le,
  get_int64_ne,
  get_int64_be,
  get_int64_le,
}
/* No side effect */
