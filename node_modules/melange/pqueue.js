// Generated by Melange
'use strict';

const Caml_js_exceptions = require("melange.js/caml_js_exceptions.js");
const Caml_option = require("melange.js/caml_option.js");
const Curry = require("melange.js/curry.js");
const Stdlib__Dynarray = require("./dynarray.js");

function MakeMaxPoly(E) {
  const left_child = function (i) {
    return (i << 1) + 1 | 0;
  };
  const right_child = function (i) {
    return (i << 1) + 2 | 0;
  };
  const parent_node = function (i) {
    return (i - 1 | 0) / 2 | 0;
  };
  const add = function (h, x) {
    const i = h.length;
    Stdlib__Dynarray.add_last(h, x);
    if (i > 0) {
      let _i = i;
      while (true) {
        const i$1 = _i;
        if (i$1 === 0) {
          return Stdlib__Dynarray.set(h, 0, x);
        }
        const p = parent_node(i$1);
        const y = Stdlib__Dynarray.get(h, p);
        if (Curry._2(E.compare, y, x) >= 0) {
          return Stdlib__Dynarray.set(h, i$1, x);
        }
        Stdlib__Dynarray.set(h, i$1, y);
        _i = p;
        continue;
      };
    }
    
  };
  const add_iter = function (h, iter, x) {
    return Curry._2(iter, (function (param) {
      return add(h, param);
    }), x);
  };
  const min_elt = function (h) {
    if (h.length === 0) {
      return;
    } else {
      return Caml_option.some(Stdlib__Dynarray.get(h, 0));
    }
  };
  const get_min_elt = function (h) {
    if (h.length === 0) {
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "empty priority queue"
        });
    }
    return Stdlib__Dynarray.get(h, 0);
  };
  const lt = function (h, i, j) {
    const y = Stdlib__Dynarray.get(h, j);
    const x = Stdlib__Dynarray.get(h, i);
    return Curry._2(E.compare, y, x) < 0;
  };
  const sift_down = function (h, len, _i, x) {
    while (true) {
      const i = _i;
      const left = left_child(i);
      if (left >= len) {
        return Stdlib__Dynarray.set(h, i, x);
      }
      const right = right_child(i);
      const smallest = right >= len || lt(h, left, right) ? left : right;
      const y = Stdlib__Dynarray.get(h, smallest);
      if (Curry._2(E.compare, x, y) >= 0) {
        return Stdlib__Dynarray.set(h, i, x);
      }
      Stdlib__Dynarray.set(h, i, y);
      _i = smallest;
      continue;
    };
  };
  const pop_min = function (h) {
    const n = h.length;
    if (n === 0) {
      return;
    }
    const x = Stdlib__Dynarray.pop_last(h);
    if (n === 1) {
      return Caml_option.some(x);
    }
    const r = Stdlib__Dynarray.get(h, 0);
    sift_down(h, n - 1 | 0, 0, x);
    return Caml_option.some(r);
  };
  const remove_min = function (h) {
    const n = h.length;
    if (n <= 0) {
      return;
    }
    const x = Stdlib__Dynarray.pop_last(h);
    if (n > 1) {
      return sift_down(h, n - 1 | 0, 0, x);
    }
    
  };
  const heapify = function (h) {
    const n = h.length;
    for (let i = (n / 2 | 0) - 1 | 0; i >= 0; --i) {
      sift_down(h, n, i, Stdlib__Dynarray.get(h, i));
    }
    return h;
  };
  const of_array = function (a) {
    return heapify(Stdlib__Dynarray.of_array(a));
  };
  const of_list = function (l) {
    return heapify(Stdlib__Dynarray.of_list(l));
  };
  const of_iter = function (iter, x) {
    const a = Stdlib__Dynarray.create();
    Curry._2(iter, (function (param) {
      return Stdlib__Dynarray.add_last(a, param);
    }), x);
    return heapify(a);
  };
  return {
    create: Stdlib__Dynarray.create,
    length: Stdlib__Dynarray.length,
    is_empty: Stdlib__Dynarray.is_empty,
    add: add,
    add_iter: add_iter,
    max_elt: min_elt,
    get_max_elt: get_min_elt,
    pop_max: pop_min,
    remove_max: remove_min,
    clear: Stdlib__Dynarray.clear,
    copy: Stdlib__Dynarray.copy,
    of_array: of_array,
    of_list: of_list,
    of_iter: of_iter,
    iter_unordered: Stdlib__Dynarray.iter,
    fold_unordered: Stdlib__Dynarray.fold_left
  };
}

function MakeMin(funarg) {
  const compare = funarg.compare;
  const left_child = function (i) {
    return (i << 1) + 1 | 0;
  };
  const right_child = function (i) {
    return (i << 1) + 2 | 0;
  };
  const parent_node = function (i) {
    return (i - 1 | 0) / 2 | 0;
  };
  const add = function (h, x) {
    const i = h.length;
    Stdlib__Dynarray.add_last(h, x);
    if (i > 0) {
      let _i = i;
      while (true) {
        const i$1 = _i;
        if (i$1 === 0) {
          return Stdlib__Dynarray.set(h, 0, x);
        }
        const p = parent_node(i$1);
        const y = Stdlib__Dynarray.get(h, p);
        if (Curry._2(compare, x, y) >= 0) {
          return Stdlib__Dynarray.set(h, i$1, x);
        }
        Stdlib__Dynarray.set(h, i$1, y);
        _i = p;
        continue;
      };
    }
    
  };
  const add_iter = function (h, iter, x) {
    return Curry._2(iter, (function (param) {
      return add(h, param);
    }), x);
  };
  const min_elt = function (h) {
    if (h.length === 0) {
      return;
    } else {
      return Caml_option.some(Stdlib__Dynarray.get(h, 0));
    }
  };
  const get_min_elt = function (h) {
    if (h.length === 0) {
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "empty priority queue"
        });
    }
    return Stdlib__Dynarray.get(h, 0);
  };
  const lt = function (h, i, j) {
    return Curry._2(compare, Stdlib__Dynarray.get(h, i), Stdlib__Dynarray.get(h, j)) < 0;
  };
  const sift_down = function (h, len, _i, x) {
    while (true) {
      const i = _i;
      const left = left_child(i);
      if (left >= len) {
        return Stdlib__Dynarray.set(h, i, x);
      }
      const right = right_child(i);
      const smallest = right >= len || lt(h, left, right) ? left : right;
      const y = Stdlib__Dynarray.get(h, smallest);
      if (Curry._2(compare, y, x) >= 0) {
        return Stdlib__Dynarray.set(h, i, x);
      }
      Stdlib__Dynarray.set(h, i, y);
      _i = smallest;
      continue;
    };
  };
  const pop_min = function (h) {
    const n = h.length;
    if (n === 0) {
      return;
    }
    const x = Stdlib__Dynarray.pop_last(h);
    if (n === 1) {
      return Caml_option.some(x);
    }
    const r = Stdlib__Dynarray.get(h, 0);
    sift_down(h, n - 1 | 0, 0, x);
    return Caml_option.some(r);
  };
  const remove_min = function (h) {
    const n = h.length;
    if (n <= 0) {
      return;
    }
    const x = Stdlib__Dynarray.pop_last(h);
    if (n > 1) {
      return sift_down(h, n - 1 | 0, 0, x);
    }
    
  };
  const heapify = function (h) {
    const n = h.length;
    for (let i = (n / 2 | 0) - 1 | 0; i >= 0; --i) {
      sift_down(h, n, i, Stdlib__Dynarray.get(h, i));
    }
    return h;
  };
  const of_array = function (a) {
    return heapify(Stdlib__Dynarray.of_array(a));
  };
  const of_list = function (l) {
    return heapify(Stdlib__Dynarray.of_list(l));
  };
  const of_iter = function (iter, x) {
    const a = Stdlib__Dynarray.create();
    Curry._2(iter, (function (param) {
      return Stdlib__Dynarray.add_last(a, param);
    }), x);
    return heapify(a);
  };
  return {
    create: Stdlib__Dynarray.create,
    length: Stdlib__Dynarray.length,
    is_empty: Stdlib__Dynarray.is_empty,
    add: add,
    add_iter: add_iter,
    min_elt: min_elt,
    get_min_elt: get_min_elt,
    pop_min: pop_min,
    remove_min: remove_min,
    clear: Stdlib__Dynarray.clear,
    copy: Stdlib__Dynarray.copy,
    of_array: of_array,
    of_list: of_list,
    of_iter: of_iter,
    iter_unordered: Stdlib__Dynarray.iter,
    fold_unordered: Stdlib__Dynarray.fold_left
  };
}

function MakeMax(funarg) {
  const left_child = function (i) {
    return (i << 1) + 1 | 0;
  };
  const right_child = function (i) {
    return (i << 1) + 2 | 0;
  };
  const parent_node = function (i) {
    return (i - 1 | 0) / 2 | 0;
  };
  const add = function (h, x) {
    const i = h.length;
    Stdlib__Dynarray.add_last(h, x);
    if (i > 0) {
      let _i = i;
      while (true) {
        const i$1 = _i;
        if (i$1 === 0) {
          return Stdlib__Dynarray.set(h, 0, x);
        }
        const p = parent_node(i$1);
        const y = Stdlib__Dynarray.get(h, p);
        if (Curry._2(funarg.compare, y, x) >= 0) {
          return Stdlib__Dynarray.set(h, i$1, x);
        }
        Stdlib__Dynarray.set(h, i$1, y);
        _i = p;
        continue;
      };
    }
    
  };
  const add_iter = function (h, iter, x) {
    return Curry._2(iter, (function (param) {
      return add(h, param);
    }), x);
  };
  const min_elt = function (h) {
    if (h.length === 0) {
      return;
    } else {
      return Caml_option.some(Stdlib__Dynarray.get(h, 0));
    }
  };
  const get_min_elt = function (h) {
    if (h.length === 0) {
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "empty priority queue"
        });
    }
    return Stdlib__Dynarray.get(h, 0);
  };
  const lt = function (h, i, j) {
    const y = Stdlib__Dynarray.get(h, j);
    const x = Stdlib__Dynarray.get(h, i);
    return Curry._2(funarg.compare, y, x) < 0;
  };
  const sift_down = function (h, len, _i, x) {
    while (true) {
      const i = _i;
      const left = left_child(i);
      if (left >= len) {
        return Stdlib__Dynarray.set(h, i, x);
      }
      const right = right_child(i);
      const smallest = right >= len || lt(h, left, right) ? left : right;
      const y = Stdlib__Dynarray.get(h, smallest);
      if (Curry._2(funarg.compare, x, y) >= 0) {
        return Stdlib__Dynarray.set(h, i, x);
      }
      Stdlib__Dynarray.set(h, i, y);
      _i = smallest;
      continue;
    };
  };
  const pop_min = function (h) {
    const n = h.length;
    if (n === 0) {
      return;
    }
    const x = Stdlib__Dynarray.pop_last(h);
    if (n === 1) {
      return Caml_option.some(x);
    }
    const r = Stdlib__Dynarray.get(h, 0);
    sift_down(h, n - 1 | 0, 0, x);
    return Caml_option.some(r);
  };
  const remove_min = function (h) {
    const n = h.length;
    if (n <= 0) {
      return;
    }
    const x = Stdlib__Dynarray.pop_last(h);
    if (n > 1) {
      return sift_down(h, n - 1 | 0, 0, x);
    }
    
  };
  const heapify = function (h) {
    const n = h.length;
    for (let i = (n / 2 | 0) - 1 | 0; i >= 0; --i) {
      sift_down(h, n, i, Stdlib__Dynarray.get(h, i));
    }
    return h;
  };
  const of_array = function (a) {
    return heapify(Stdlib__Dynarray.of_array(a));
  };
  const of_list = function (l) {
    return heapify(Stdlib__Dynarray.of_list(l));
  };
  const of_iter = function (iter, x) {
    const a = Stdlib__Dynarray.create();
    Curry._2(iter, (function (param) {
      return Stdlib__Dynarray.add_last(a, param);
    }), x);
    return heapify(a);
  };
  return {
    create: Stdlib__Dynarray.create,
    length: Stdlib__Dynarray.length,
    is_empty: Stdlib__Dynarray.is_empty,
    add: add,
    add_iter: add_iter,
    max_elt: min_elt,
    get_max_elt: get_min_elt,
    pop_max: pop_min,
    remove_max: remove_min,
    clear: Stdlib__Dynarray.clear,
    copy: Stdlib__Dynarray.copy,
    of_array: of_array,
    of_list: of_list,
    of_iter: of_iter,
    iter_unordered: Stdlib__Dynarray.iter,
    fold_unordered: Stdlib__Dynarray.fold_left
  };
}

function MakeMinPoly(funarg) {
  const left_child = function (i) {
    return (i << 1) + 1 | 0;
  };
  const right_child = function (i) {
    return (i << 1) + 2 | 0;
  };
  const parent_node = function (i) {
    return (i - 1 | 0) / 2 | 0;
  };
  const add = function (h, x) {
    const i = h.length;
    Stdlib__Dynarray.add_last(h, x);
    if (i > 0) {
      let _i = i;
      while (true) {
        const i$1 = _i;
        if (i$1 === 0) {
          return Stdlib__Dynarray.set(h, 0, x);
        }
        const p = parent_node(i$1);
        const y = Stdlib__Dynarray.get(h, p);
        if (Curry._2(funarg.compare, x, y) >= 0) {
          return Stdlib__Dynarray.set(h, i$1, x);
        }
        Stdlib__Dynarray.set(h, i$1, y);
        _i = p;
        continue;
      };
    }
    
  };
  const add_iter = function (h, iter, x) {
    return Curry._2(iter, (function (param) {
      return add(h, param);
    }), x);
  };
  const min_elt = function (h) {
    if (h.length === 0) {
      return;
    } else {
      return Caml_option.some(Stdlib__Dynarray.get(h, 0));
    }
  };
  const get_min_elt = function (h) {
    if (h.length === 0) {
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "empty priority queue"
        });
    }
    return Stdlib__Dynarray.get(h, 0);
  };
  const lt = function (h, i, j) {
    return Curry._2(funarg.compare, Stdlib__Dynarray.get(h, i), Stdlib__Dynarray.get(h, j)) < 0;
  };
  const sift_down = function (h, len, _i, x) {
    while (true) {
      const i = _i;
      const left = left_child(i);
      if (left >= len) {
        return Stdlib__Dynarray.set(h, i, x);
      }
      const right = right_child(i);
      const smallest = right >= len || lt(h, left, right) ? left : right;
      const y = Stdlib__Dynarray.get(h, smallest);
      if (Curry._2(funarg.compare, y, x) >= 0) {
        return Stdlib__Dynarray.set(h, i, x);
      }
      Stdlib__Dynarray.set(h, i, y);
      _i = smallest;
      continue;
    };
  };
  const pop_min = function (h) {
    const n = h.length;
    if (n === 0) {
      return;
    }
    const x = Stdlib__Dynarray.pop_last(h);
    if (n === 1) {
      return Caml_option.some(x);
    }
    const r = Stdlib__Dynarray.get(h, 0);
    sift_down(h, n - 1 | 0, 0, x);
    return Caml_option.some(r);
  };
  const remove_min = function (h) {
    const n = h.length;
    if (n <= 0) {
      return;
    }
    const x = Stdlib__Dynarray.pop_last(h);
    if (n > 1) {
      return sift_down(h, n - 1 | 0, 0, x);
    }
    
  };
  const heapify = function (h) {
    const n = h.length;
    for (let i = (n / 2 | 0) - 1 | 0; i >= 0; --i) {
      sift_down(h, n, i, Stdlib__Dynarray.get(h, i));
    }
    return h;
  };
  const of_array = function (a) {
    return heapify(Stdlib__Dynarray.of_array(a));
  };
  const of_list = function (l) {
    return heapify(Stdlib__Dynarray.of_list(l));
  };
  const of_iter = function (iter, x) {
    const a = Stdlib__Dynarray.create();
    Curry._2(iter, (function (param) {
      return Stdlib__Dynarray.add_last(a, param);
    }), x);
    return heapify(a);
  };
  return {
    create: Stdlib__Dynarray.create,
    length: Stdlib__Dynarray.length,
    is_empty: Stdlib__Dynarray.is_empty,
    add: add,
    add_iter: add_iter,
    min_elt: min_elt,
    get_min_elt: get_min_elt,
    pop_min: pop_min,
    remove_min: remove_min,
    clear: Stdlib__Dynarray.clear,
    copy: Stdlib__Dynarray.copy,
    of_array: of_array,
    of_list: of_list,
    of_iter: of_iter,
    iter_unordered: Stdlib__Dynarray.iter,
    fold_unordered: Stdlib__Dynarray.fold_left
  };
}

module.exports = {
  MakeMin,
  MakeMax,
  MakeMinPoly,
  MakeMaxPoly,
}
/* Stdlib__Dynarray Not a pure module */
