// Generated by Melange

import * as Caml_array from "melange.js/caml_array.mjs";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.mjs";
import * as Caml_option from "melange.js/caml_option.mjs";
import * as CamlinternalLazy from "./camlinternalLazy.mjs";
import * as Curry from "melange.js/curry.mjs";
import * as Stdlib from "./stdlib.mjs";
import * as Stdlib__Array from "./array.mjs";
import * as Stdlib__Hashtbl from "./hashtbl.mjs";
import * as Stdlib__Int from "./int.mjs";
import * as Stdlib__List from "./list.mjs";
import * as Stdlib__Obj from "./obj.mjs";
import * as Stdlib__Random from "./random.mjs";
import * as Stdlib__Seq from "./seq.mjs";
import * as Stdlib__Sys from "./sys.mjs";

function set_key(t, k) {
  Stdlib__Obj.Ephemeron.set_key(t, 0, k);
}

function check_key(t) {
  return Stdlib__Obj.Ephemeron.check_key(t, 0);
}

function get_data(t) {
  return Stdlib__Obj.Ephemeron.get_data(t);
}

function make(key, data) {
  const eph = Stdlib__Obj.Ephemeron.create(1);
  Stdlib__Obj.Ephemeron.set_data(eph, data);
  set_key(eph, key);
  return eph;
}

function query(eph, key) {
  const k = Stdlib__Obj.Ephemeron.get_key(eph, 0);
  if (k !== undefined && Caml_option.valFromOption(k) === key) {
    return Stdlib__Obj.Ephemeron.get_data(eph);
  }
  
}

function MakeSeeded(H) {
  const create = function (k, d) {
    const c = Stdlib__Obj.Ephemeron.create(1);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    set_key(c, k);
    return c;
  };
  const seeded_hash = H.seeded_hash;
  const equal = function (c, k) {
    const k$p = Stdlib__Obj.Ephemeron.get_key(c, 0);
    if (k$p !== undefined) {
      if (Curry._2(H.equal, k, Caml_option.valFromOption(k$p))) {
        return /* ETrue */ 0;
      } else {
        return /* EFalse */ 1;
      }
    } else {
      return /* EDead */ 2;
    }
  };
  const power_2_above = function (_x, n) {
    while (true) {
      const x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue;
    };
  };
  const prng = {
    LAZY_DONE: false,
    VAL: (function () {
      return Stdlib__Random.State.make_self_init();
    })
  };
  const create$1 = function (randomOpt, initial_size) {
    const random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized();
    const s = power_2_above(16, initial_size);
    const seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
      size: 0,
      data: Caml_array.make(s, /* Empty */ 0),
      seed: seed,
      initial_size: s
    };
  };
  const clear = function (h) {
    h.size = 0;
    const len = h.data.length;
    for (let i = 0; i < len; ++i) {
      Caml_array.set(h.data, i, /* Empty */ 0);
    }
  };
  const reset = function (h) {
    const len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */ 0);
      return;
    }
  };
  const copy = function (h) {
    return {
      size: h.size,
      data: Stdlib__Array.copy(h.data),
      seed: h.seed,
      initial_size: h.initial_size
    };
  };
  const key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  const clean = function (h) {
    const do_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param !== "object" && typeof param !== "function") {
          return /* Empty */ 0;
        }
        if (check_key(param._1)) {
          return {
            TAG: /* Cons */ 0,
            _0: param._0,
            _1: param._1,
            _2: do_bucket(param._2)
          };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue;
      };
    };
    const d = h.data;
    for (let i = 0, i_finish = d.length; i < i_finish; ++i) {
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  const resize = function (h) {
    const odata = h.data;
    const osize = odata.length;
    const nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return;
    }
    const ndata = Caml_array.make(nsize, /* Empty */ 0);
    h.data = ndata;
    const insert_bucket = function (param) {
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        return;
      }
      const hkey = param._0;
      insert_bucket(param._2);
      const nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, {
        TAG: /* Cons */ 0,
        _0: hkey,
        _1: param._1,
        _2: Caml_array.get(ndata, nidx)
      });
    };
    for (let i = 0; i < osize; ++i) {
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  const add = function (h, key, info) {
    const hkey = Curry._2(seeded_hash, h.seed, key);
    const i = key_index(h, hkey);
    const container = create(key, info);
    const bucket_2 = Caml_array.get(h.data, i);
    const bucket = {
      TAG: /* Cons */ 0,
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  const remove = function (h, key) {
    const hkey = Curry._2(seeded_hash, h.seed, key);
    const remove_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param !== "object" && typeof param !== "function") {
          return /* Empty */ 0;
        }
        const hk = param._0;
        if (hkey !== hk) {
          return {
            TAG: /* Cons */ 0,
            _0: hk,
            _1: param._1,
            _2: remove_bucket(param._2)
          };
        }
        const next = param._2;
        const c = param._1;
        const match = equal(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            h.size = h.size - 1 | 0;
            return next;
          case /* EFalse */ 1 :
            return {
              TAG: /* Cons */ 0,
              _0: hk,
              _1: c,
              _2: remove_bucket(next)
            };
          case /* EDead */ 2 :
            h.size = h.size - 1 | 0;
            _param = next;
            continue;
        }
      };
    };
    const i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  const find = function (h, key) {
    const hkey = Curry._2(seeded_hash, h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
      }
      if (hkey === param._0) {
        const rest = param._2;
        const c = param._1;
        const match = equal(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            const d = get_data(c);
            if (d !== undefined) {
              return Caml_option.valFromOption(d);
            }
            _param = rest;
            continue;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const find_opt = function (h, key) {
    const hkey = Curry._2(seeded_hash, h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        return;
      }
      if (hkey === param._0) {
        const rest = param._2;
        const c = param._1;
        const match = equal(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            const d = get_data(c);
            if (d !== undefined) {
              return d;
            }
            _param = rest;
            continue;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const find_all = function (h, key) {
    const hkey = Curry._2(seeded_hash, h.seed, key);
    const find_in_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param !== "object" && typeof param !== "function") {
          return /* [] */ 0;
        }
        if (hkey === param._0) {
          const rest = param._2;
          const c = param._1;
          const match = equal(c, key);
          switch (match) {
            case /* ETrue */ 0 :
              const d = get_data(c);
              if (d !== undefined) {
                return {
                  hd: Caml_option.valFromOption(d),
                  tl: find_in_bucket(rest)
                };
              }
              _param = rest;
              continue;
            case /* EFalse */ 1 :
            case /* EDead */ 2 :
              _param = rest;
              continue;
          }
        } else {
          _param = param._2;
          continue;
        }
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  const replace = function (h, key, info) {
    const hkey = Curry._2(seeded_hash, h.seed, key);
    const i = key_index(h, hkey);
    const l = Caml_array.get(h.data, i);
    try {
      let _param = l;
      while (true) {
        const param = _param;
        if (/* tag */ typeof param !== "object" && typeof param !== "function") {
          throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
        }
        if (hkey === param._0) {
          const next = param._2;
          const c = param._1;
          const match = equal(c, key);
          switch (match) {
            case /* ETrue */ 0 :
              Stdlib__Obj.Ephemeron.unset_data(c);
              set_key(c, key);
              return Stdlib__Obj.Ephemeron.set_data(c, info);
            case /* EFalse */ 1 :
            case /* EDead */ 2 :
              _param = next;
              continue;
          }
        } else {
          _param = param._2;
          continue;
        }
      };
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        const container = create(key, info);
        Caml_array.set(h.data, i, {
          TAG: /* Cons */ 0,
          _0: hkey,
          _1: container,
          _2: l
        });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return;
        }
      }
      throw exn;
    }
  };
  const mem = function (h, key) {
    const hkey = Curry._2(seeded_hash, h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        return false;
      }
      if (param._0 === hkey) {
        const rest = param._2;
        const match = equal(param._1, key);
        switch (match) {
          case /* ETrue */ 0 :
            return true;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const length = function (h) {
    return h.size;
  };
  const bucket_length = function (_accu, _param) {
    while (true) {
      const param = _param;
      const accu = _accu;
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue;
    };
  };
  const stats = function (h) {
    const mbl = Stdlib__Array.fold_left((function (m, b) {
      return Stdlib__Int.max(m, bucket_length(0, b));
    }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
      const l = bucket_length(0, b);
      Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
    }), h.data);
    return {
      num_bindings: h.size,
      num_buckets: h.data.length,
      max_bucket_length: mbl,
      bucket_histogram: histo
    };
  };
  const bucket_length_alive = function (_accu, _param) {
    while (true) {
      const param = _param;
      const accu = _accu;
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue;
      }
      _param = param._2;
      continue;
    };
  };
  const stats_alive = function (h) {
    const size = {
      contents: 0
    };
    const mbl = Stdlib__Array.fold_left((function (m, b) {
      return Stdlib__Int.max(m, bucket_length_alive(0, b));
    }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
      const l = bucket_length_alive(0, b);
      size.contents = size.contents + l | 0;
      Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
    }), h.data);
    return {
      num_bindings: size.contents,
      num_buckets: h.data.length,
      max_bucket_length: mbl,
      bucket_histogram: histo
    };
  };
  const add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
      add(tbl, param[0], param[1]);
    }), i);
  };
  const replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
      replace(tbl, param[0], param[1]);
    }), i);
  };
  const of_seq = function (i) {
    const tbl = create$1(undefined, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
    create: create$1,
    clear: clear,
    reset: reset,
    copy: copy,
    add: add,
    remove: remove,
    find: find,
    find_opt: find_opt,
    find_all: find_all,
    replace: replace,
    mem: mem,
    length: length,
    stats: stats,
    add_seq: add_seq,
    replace_seq: replace_seq,
    of_seq: of_seq,
    clean: clean,
    stats_alive: stats_alive
  };
}

function Make(H) {
  const equal = H.equal;
  const seeded_hash = function (_seed, x) {
    return Curry._1(H.hash, x);
  };
  const create = function (k, d) {
    const c = Stdlib__Obj.Ephemeron.create(1);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    set_key(c, k);
    return c;
  };
  const equal$1 = function (c, k) {
    const k$p = Stdlib__Obj.Ephemeron.get_key(c, 0);
    if (k$p !== undefined) {
      if (Curry._2(equal, k, Caml_option.valFromOption(k$p))) {
        return /* ETrue */ 0;
      } else {
        return /* EFalse */ 1;
      }
    } else {
      return /* EDead */ 2;
    }
  };
  const power_2_above = function (_x, n) {
    while (true) {
      const x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue;
    };
  };
  const prng = {
    LAZY_DONE: false,
    VAL: (function () {
      return Stdlib__Random.State.make_self_init();
    })
  };
  const create$1 = function (randomOpt, initial_size) {
    const random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized();
    const s = power_2_above(16, initial_size);
    const seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
      size: 0,
      data: Caml_array.make(s, /* Empty */ 0),
      seed: seed,
      initial_size: s
    };
  };
  const clear = function (h) {
    h.size = 0;
    const len = h.data.length;
    for (let i = 0; i < len; ++i) {
      Caml_array.set(h.data, i, /* Empty */ 0);
    }
  };
  const reset = function (h) {
    const len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */ 0);
      return;
    }
  };
  const copy = function (h) {
    return {
      size: h.size,
      data: Stdlib__Array.copy(h.data),
      seed: h.seed,
      initial_size: h.initial_size
    };
  };
  const key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  const clean = function (h) {
    const do_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param !== "object" && typeof param !== "function") {
          return /* Empty */ 0;
        }
        if (check_key(param._1)) {
          return {
            TAG: /* Cons */ 0,
            _0: param._0,
            _1: param._1,
            _2: do_bucket(param._2)
          };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue;
      };
    };
    const d = h.data;
    for (let i = 0, i_finish = d.length; i < i_finish; ++i) {
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  const resize = function (h) {
    const odata = h.data;
    const osize = odata.length;
    const nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return;
    }
    const ndata = Caml_array.make(nsize, /* Empty */ 0);
    h.data = ndata;
    const insert_bucket = function (param) {
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        return;
      }
      const hkey = param._0;
      insert_bucket(param._2);
      const nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, {
        TAG: /* Cons */ 0,
        _0: hkey,
        _1: param._1,
        _2: Caml_array.get(ndata, nidx)
      });
    };
    for (let i = 0; i < osize; ++i) {
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  const add = function (h, key, info) {
    const hkey = seeded_hash(h.seed, key);
    const i = key_index(h, hkey);
    const container = create(key, info);
    const bucket_2 = Caml_array.get(h.data, i);
    const bucket = {
      TAG: /* Cons */ 0,
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  const remove = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    const remove_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param !== "object" && typeof param !== "function") {
          return /* Empty */ 0;
        }
        const hk = param._0;
        if (hkey !== hk) {
          return {
            TAG: /* Cons */ 0,
            _0: hk,
            _1: param._1,
            _2: remove_bucket(param._2)
          };
        }
        const next = param._2;
        const c = param._1;
        const match = equal$1(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            h.size = h.size - 1 | 0;
            return next;
          case /* EFalse */ 1 :
            return {
              TAG: /* Cons */ 0,
              _0: hk,
              _1: c,
              _2: remove_bucket(next)
            };
          case /* EDead */ 2 :
            h.size = h.size - 1 | 0;
            _param = next;
            continue;
        }
      };
    };
    const i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  const find = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
      }
      if (hkey === param._0) {
        const rest = param._2;
        const c = param._1;
        const match = equal$1(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            const d = get_data(c);
            if (d !== undefined) {
              return Caml_option.valFromOption(d);
            }
            _param = rest;
            continue;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const find_opt = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        return;
      }
      if (hkey === param._0) {
        const rest = param._2;
        const c = param._1;
        const match = equal$1(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            const d = get_data(c);
            if (d !== undefined) {
              return d;
            }
            _param = rest;
            continue;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const find_all = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    const find_in_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param !== "object" && typeof param !== "function") {
          return /* [] */ 0;
        }
        if (hkey === param._0) {
          const rest = param._2;
          const c = param._1;
          const match = equal$1(c, key);
          switch (match) {
            case /* ETrue */ 0 :
              const d = get_data(c);
              if (d !== undefined) {
                return {
                  hd: Caml_option.valFromOption(d),
                  tl: find_in_bucket(rest)
                };
              }
              _param = rest;
              continue;
            case /* EFalse */ 1 :
            case /* EDead */ 2 :
              _param = rest;
              continue;
          }
        } else {
          _param = param._2;
          continue;
        }
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  const replace = function (h, key, info) {
    const hkey = seeded_hash(h.seed, key);
    const i = key_index(h, hkey);
    const l = Caml_array.get(h.data, i);
    try {
      let _param = l;
      while (true) {
        const param = _param;
        if (/* tag */ typeof param !== "object" && typeof param !== "function") {
          throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
        }
        if (hkey === param._0) {
          const next = param._2;
          const c = param._1;
          const match = equal$1(c, key);
          switch (match) {
            case /* ETrue */ 0 :
              Stdlib__Obj.Ephemeron.unset_data(c);
              set_key(c, key);
              return Stdlib__Obj.Ephemeron.set_data(c, info);
            case /* EFalse */ 1 :
            case /* EDead */ 2 :
              _param = next;
              continue;
          }
        } else {
          _param = param._2;
          continue;
        }
      };
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        const container = create(key, info);
        Caml_array.set(h.data, i, {
          TAG: /* Cons */ 0,
          _0: hkey,
          _1: container,
          _2: l
        });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return;
        }
      }
      throw exn;
    }
  };
  const mem = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        return false;
      }
      if (param._0 === hkey) {
        const rest = param._2;
        const match = equal$1(param._1, key);
        switch (match) {
          case /* ETrue */ 0 :
            return true;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const length = function (h) {
    return h.size;
  };
  const bucket_length = function (_accu, _param) {
    while (true) {
      const param = _param;
      const accu = _accu;
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue;
    };
  };
  const stats = function (h) {
    const mbl = Stdlib__Array.fold_left((function (m, b) {
      return Stdlib__Int.max(m, bucket_length(0, b));
    }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
      const l = bucket_length(0, b);
      Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
    }), h.data);
    return {
      num_bindings: h.size,
      num_buckets: h.data.length,
      max_bucket_length: mbl,
      bucket_histogram: histo
    };
  };
  const bucket_length_alive = function (_accu, _param) {
    while (true) {
      const param = _param;
      const accu = _accu;
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue;
      }
      _param = param._2;
      continue;
    };
  };
  const stats_alive = function (h) {
    const size = {
      contents: 0
    };
    const mbl = Stdlib__Array.fold_left((function (m, b) {
      return Stdlib__Int.max(m, bucket_length_alive(0, b));
    }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
      const l = bucket_length_alive(0, b);
      size.contents = size.contents + l | 0;
      Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
    }), h.data);
    return {
      num_bindings: size.contents,
      num_buckets: h.data.length,
      max_bucket_length: mbl,
      bucket_histogram: histo
    };
  };
  const add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
      add(tbl, param[0], param[1]);
    }), i);
  };
  const replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
      replace(tbl, param[0], param[1]);
    }), i);
  };
  const create$2 = function (sz) {
    return create$1(false, sz);
  };
  const of_seq = function (i) {
    const tbl = create$1(false, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
    create: create$2,
    clear: clear,
    reset: reset,
    copy: copy,
    add: add,
    remove: remove,
    find: find,
    find_opt: find_opt,
    find_all: find_all,
    replace: replace,
    mem: mem,
    length: length,
    stats: stats,
    add_seq: add_seq,
    replace_seq: replace_seq,
    of_seq: of_seq,
    clean: clean,
    stats_alive: stats_alive
  };
}

function make$1(param) {
  return {
    contents: /* [] */ 0
  };
}

function add(b, k, d) {
  b.contents = {
    hd: make(k, d),
    tl: b.contents
  };
}

function test_key(k, e) {
  const x = Stdlib__Obj.Ephemeron.get_key(e, 0);
  if (x !== undefined) {
    return Caml_option.valFromOption(x) === k;
  } else {
    return false;
  }
}

function remove(b, k) {
  let _l = b.contents;
  let _acc = /* [] */ 0;
  while (true) {
    const acc = _acc;
    const l = _l;
    if (!l) {
      return;
    }
    const h = l.hd;
    if (test_key(k, h)) {
      b.contents = Stdlib__List.rev_append(acc, l.tl);
      return;
    }
    _acc = {
      hd: h,
      tl: acc
    };
    _l = l.tl;
    continue;
  };
}

function find(b, k) {
  const e = Stdlib__List.find_opt((function (param) {
    return test_key(k, param);
  }), b.contents);
  if (e !== undefined) {
    return Stdlib__Obj.Ephemeron.get_data(Caml_option.valFromOption(e));
  }
  
}

function length(b) {
  return Stdlib__List.length(b.contents);
}

function clear(b) {
  b.contents = /* [] */ 0;
}

function set_key1(t, k) {
  Stdlib__Obj.Ephemeron.set_key(t, 0, k);
}

function set_key2(t, k) {
  Stdlib__Obj.Ephemeron.set_key(t, 1, k);
}

function get_data$1(t) {
  return Stdlib__Obj.Ephemeron.get_data(t);
}

function make$2(key1, key2, data) {
  const eph = Stdlib__Obj.Ephemeron.create(2);
  Stdlib__Obj.Ephemeron.set_data(eph, data);
  set_key1(eph, key1);
  set_key2(eph, key2);
  return eph;
}

function query$1(eph, key1, key2) {
  const k = Stdlib__Obj.Ephemeron.get_key(eph, 0);
  if (k === undefined) {
    return;
  }
  if (Caml_option.valFromOption(k) !== key1) {
    return;
  }
  const k$1 = Stdlib__Obj.Ephemeron.get_key(eph, 1);
  if (k$1 !== undefined && Caml_option.valFromOption(k$1) === key2) {
    return Stdlib__Obj.Ephemeron.get_data(eph);
  }
  
}

function MakeSeeded$1(H1, H2) {
  const create = function (param, d) {
    const c = Stdlib__Obj.Ephemeron.create(2);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    set_key1(c, param[0]);
    set_key2(c, param[1]);
    return c;
  };
  const seeded_hash = function (seed, param) {
    return Curry._2(H1.seeded_hash, seed, param[0]) + Math.imul(Curry._2(H2.seeded_hash, seed, param[1]), 65599) | 0;
  };
  const equal = function (c, param) {
    const match = Stdlib__Obj.Ephemeron.get_key(c, 0);
    const match$1 = Stdlib__Obj.Ephemeron.get_key(c, 1);
    if (match !== undefined && match$1 !== undefined) {
      if (Curry._2(H1.equal, param[0], Caml_option.valFromOption(match)) && Curry._2(H2.equal, param[1], Caml_option.valFromOption(match$1))) {
        return /* ETrue */ 0;
      } else {
        return /* EFalse */ 1;
      }
    } else {
      return /* EDead */ 2;
    }
  };
  const check_key = function (c) {
    if (Stdlib__Obj.Ephemeron.check_key(c, 0)) {
      return Stdlib__Obj.Ephemeron.check_key(c, 1);
    } else {
      return false;
    }
  };
  const power_2_above = function (_x, n) {
    while (true) {
      const x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue;
    };
  };
  const prng = {
    LAZY_DONE: false,
    VAL: (function () {
      return Stdlib__Random.State.make_self_init();
    })
  };
  const create$1 = function (randomOpt, initial_size) {
    const random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized();
    const s = power_2_above(16, initial_size);
    const seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
      size: 0,
      data: Caml_array.make(s, /* Empty */ 0),
      seed: seed,
      initial_size: s
    };
  };
  const clear = function (h) {
    h.size = 0;
    const len = h.data.length;
    for (let i = 0; i < len; ++i) {
      Caml_array.set(h.data, i, /* Empty */ 0);
    }
  };
  const reset = function (h) {
    const len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */ 0);
      return;
    }
  };
  const copy = function (h) {
    return {
      size: h.size,
      data: Stdlib__Array.copy(h.data),
      seed: h.seed,
      initial_size: h.initial_size
    };
  };
  const key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  const clean = function (h) {
    const do_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param !== "object" && typeof param !== "function") {
          return /* Empty */ 0;
        }
        if (check_key(param._1)) {
          return {
            TAG: /* Cons */ 0,
            _0: param._0,
            _1: param._1,
            _2: do_bucket(param._2)
          };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue;
      };
    };
    const d = h.data;
    for (let i = 0, i_finish = d.length; i < i_finish; ++i) {
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  const resize = function (h) {
    const odata = h.data;
    const osize = odata.length;
    const nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return;
    }
    const ndata = Caml_array.make(nsize, /* Empty */ 0);
    h.data = ndata;
    const insert_bucket = function (param) {
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        return;
      }
      const hkey = param._0;
      insert_bucket(param._2);
      const nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, {
        TAG: /* Cons */ 0,
        _0: hkey,
        _1: param._1,
        _2: Caml_array.get(ndata, nidx)
      });
    };
    for (let i = 0; i < osize; ++i) {
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  const add = function (h, key, info) {
    const hkey = seeded_hash(h.seed, key);
    const i = key_index(h, hkey);
    const container = create(key, info);
    const bucket_2 = Caml_array.get(h.data, i);
    const bucket = {
      TAG: /* Cons */ 0,
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  const remove = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    const remove_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param !== "object" && typeof param !== "function") {
          return /* Empty */ 0;
        }
        const hk = param._0;
        if (hkey !== hk) {
          return {
            TAG: /* Cons */ 0,
            _0: hk,
            _1: param._1,
            _2: remove_bucket(param._2)
          };
        }
        const next = param._2;
        const c = param._1;
        const match = equal(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            h.size = h.size - 1 | 0;
            return next;
          case /* EFalse */ 1 :
            return {
              TAG: /* Cons */ 0,
              _0: hk,
              _1: c,
              _2: remove_bucket(next)
            };
          case /* EDead */ 2 :
            h.size = h.size - 1 | 0;
            _param = next;
            continue;
        }
      };
    };
    const i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  const find = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
      }
      if (hkey === param._0) {
        const rest = param._2;
        const c = param._1;
        const match = equal(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            const d = get_data$1(c);
            if (d !== undefined) {
              return Caml_option.valFromOption(d);
            }
            _param = rest;
            continue;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const find_opt = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        return;
      }
      if (hkey === param._0) {
        const rest = param._2;
        const c = param._1;
        const match = equal(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            const d = get_data$1(c);
            if (d !== undefined) {
              return d;
            }
            _param = rest;
            continue;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const find_all = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    const find_in_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param !== "object" && typeof param !== "function") {
          return /* [] */ 0;
        }
        if (hkey === param._0) {
          const rest = param._2;
          const c = param._1;
          const match = equal(c, key);
          switch (match) {
            case /* ETrue */ 0 :
              const d = get_data$1(c);
              if (d !== undefined) {
                return {
                  hd: Caml_option.valFromOption(d),
                  tl: find_in_bucket(rest)
                };
              }
              _param = rest;
              continue;
            case /* EFalse */ 1 :
            case /* EDead */ 2 :
              _param = rest;
              continue;
          }
        } else {
          _param = param._2;
          continue;
        }
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  const replace = function (h, key, info) {
    const hkey = seeded_hash(h.seed, key);
    const i = key_index(h, hkey);
    const l = Caml_array.get(h.data, i);
    try {
      let _param = l;
      while (true) {
        const param = _param;
        if (/* tag */ typeof param !== "object" && typeof param !== "function") {
          throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
        }
        if (hkey === param._0) {
          const next = param._2;
          const c = param._1;
          const match = equal(c, key);
          switch (match) {
            case /* ETrue */ 0 :
              Stdlib__Obj.Ephemeron.unset_data(c);
              set_key1(c, key[0]);
              set_key2(c, key[1]);
              return Stdlib__Obj.Ephemeron.set_data(c, info);
            case /* EFalse */ 1 :
            case /* EDead */ 2 :
              _param = next;
              continue;
          }
        } else {
          _param = param._2;
          continue;
        }
      };
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        const container = create(key, info);
        Caml_array.set(h.data, i, {
          TAG: /* Cons */ 0,
          _0: hkey,
          _1: container,
          _2: l
        });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return;
        }
      }
      throw exn;
    }
  };
  const mem = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        return false;
      }
      if (param._0 === hkey) {
        const rest = param._2;
        const match = equal(param._1, key);
        switch (match) {
          case /* ETrue */ 0 :
            return true;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const length = function (h) {
    return h.size;
  };
  const bucket_length = function (_accu, _param) {
    while (true) {
      const param = _param;
      const accu = _accu;
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue;
    };
  };
  const stats = function (h) {
    const mbl = Stdlib__Array.fold_left((function (m, b) {
      return Stdlib__Int.max(m, bucket_length(0, b));
    }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
      const l = bucket_length(0, b);
      Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
    }), h.data);
    return {
      num_bindings: h.size,
      num_buckets: h.data.length,
      max_bucket_length: mbl,
      bucket_histogram: histo
    };
  };
  const bucket_length_alive = function (_accu, _param) {
    while (true) {
      const param = _param;
      const accu = _accu;
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue;
      }
      _param = param._2;
      continue;
    };
  };
  const stats_alive = function (h) {
    const size = {
      contents: 0
    };
    const mbl = Stdlib__Array.fold_left((function (m, b) {
      return Stdlib__Int.max(m, bucket_length_alive(0, b));
    }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
      const l = bucket_length_alive(0, b);
      size.contents = size.contents + l | 0;
      Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
    }), h.data);
    return {
      num_bindings: size.contents,
      num_buckets: h.data.length,
      max_bucket_length: mbl,
      bucket_histogram: histo
    };
  };
  const add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
      add(tbl, param[0], param[1]);
    }), i);
  };
  const replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
      replace(tbl, param[0], param[1]);
    }), i);
  };
  const of_seq = function (i) {
    const tbl = create$1(undefined, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
    create: create$1,
    clear: clear,
    reset: reset,
    copy: copy,
    add: add,
    remove: remove,
    find: find,
    find_opt: find_opt,
    find_all: find_all,
    replace: replace,
    mem: mem,
    length: length,
    stats: stats,
    add_seq: add_seq,
    replace_seq: replace_seq,
    of_seq: of_seq,
    clean: clean,
    stats_alive: stats_alive
  };
}

function Make$1(H1, H2) {
  const equal = H2.equal;
  const equal$1 = H1.equal;
  const create = function (param, d) {
    const c = Stdlib__Obj.Ephemeron.create(2);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    set_key1(c, param[0]);
    set_key2(c, param[1]);
    return c;
  };
  const seeded_hash = function (seed, param) {
    return Curry._1(H1.hash, param[0]) + Math.imul(Curry._1(H2.hash, param[1]), 65599) | 0;
  };
  const equal$2 = function (c, param) {
    const match = Stdlib__Obj.Ephemeron.get_key(c, 0);
    const match$1 = Stdlib__Obj.Ephemeron.get_key(c, 1);
    if (match !== undefined && match$1 !== undefined) {
      if (Curry._2(equal$1, param[0], Caml_option.valFromOption(match)) && Curry._2(equal, param[1], Caml_option.valFromOption(match$1))) {
        return /* ETrue */ 0;
      } else {
        return /* EFalse */ 1;
      }
    } else {
      return /* EDead */ 2;
    }
  };
  const check_key = function (c) {
    if (Stdlib__Obj.Ephemeron.check_key(c, 0)) {
      return Stdlib__Obj.Ephemeron.check_key(c, 1);
    } else {
      return false;
    }
  };
  const power_2_above = function (_x, n) {
    while (true) {
      const x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue;
    };
  };
  const prng = {
    LAZY_DONE: false,
    VAL: (function () {
      return Stdlib__Random.State.make_self_init();
    })
  };
  const create$1 = function (randomOpt, initial_size) {
    const random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized();
    const s = power_2_above(16, initial_size);
    const seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
      size: 0,
      data: Caml_array.make(s, /* Empty */ 0),
      seed: seed,
      initial_size: s
    };
  };
  const clear = function (h) {
    h.size = 0;
    const len = h.data.length;
    for (let i = 0; i < len; ++i) {
      Caml_array.set(h.data, i, /* Empty */ 0);
    }
  };
  const reset = function (h) {
    const len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */ 0);
      return;
    }
  };
  const copy = function (h) {
    return {
      size: h.size,
      data: Stdlib__Array.copy(h.data),
      seed: h.seed,
      initial_size: h.initial_size
    };
  };
  const key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  const clean = function (h) {
    const do_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param !== "object" && typeof param !== "function") {
          return /* Empty */ 0;
        }
        if (check_key(param._1)) {
          return {
            TAG: /* Cons */ 0,
            _0: param._0,
            _1: param._1,
            _2: do_bucket(param._2)
          };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue;
      };
    };
    const d = h.data;
    for (let i = 0, i_finish = d.length; i < i_finish; ++i) {
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  const resize = function (h) {
    const odata = h.data;
    const osize = odata.length;
    const nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return;
    }
    const ndata = Caml_array.make(nsize, /* Empty */ 0);
    h.data = ndata;
    const insert_bucket = function (param) {
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        return;
      }
      const hkey = param._0;
      insert_bucket(param._2);
      const nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, {
        TAG: /* Cons */ 0,
        _0: hkey,
        _1: param._1,
        _2: Caml_array.get(ndata, nidx)
      });
    };
    for (let i = 0; i < osize; ++i) {
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  const add = function (h, key, info) {
    const hkey = seeded_hash(h.seed, key);
    const i = key_index(h, hkey);
    const container = create(key, info);
    const bucket_2 = Caml_array.get(h.data, i);
    const bucket = {
      TAG: /* Cons */ 0,
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  const remove = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    const remove_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param !== "object" && typeof param !== "function") {
          return /* Empty */ 0;
        }
        const hk = param._0;
        if (hkey !== hk) {
          return {
            TAG: /* Cons */ 0,
            _0: hk,
            _1: param._1,
            _2: remove_bucket(param._2)
          };
        }
        const next = param._2;
        const c = param._1;
        const match = equal$2(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            h.size = h.size - 1 | 0;
            return next;
          case /* EFalse */ 1 :
            return {
              TAG: /* Cons */ 0,
              _0: hk,
              _1: c,
              _2: remove_bucket(next)
            };
          case /* EDead */ 2 :
            h.size = h.size - 1 | 0;
            _param = next;
            continue;
        }
      };
    };
    const i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  const find = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
      }
      if (hkey === param._0) {
        const rest = param._2;
        const c = param._1;
        const match = equal$2(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            const d = get_data$1(c);
            if (d !== undefined) {
              return Caml_option.valFromOption(d);
            }
            _param = rest;
            continue;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const find_opt = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        return;
      }
      if (hkey === param._0) {
        const rest = param._2;
        const c = param._1;
        const match = equal$2(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            const d = get_data$1(c);
            if (d !== undefined) {
              return d;
            }
            _param = rest;
            continue;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const find_all = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    const find_in_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param !== "object" && typeof param !== "function") {
          return /* [] */ 0;
        }
        if (hkey === param._0) {
          const rest = param._2;
          const c = param._1;
          const match = equal$2(c, key);
          switch (match) {
            case /* ETrue */ 0 :
              const d = get_data$1(c);
              if (d !== undefined) {
                return {
                  hd: Caml_option.valFromOption(d),
                  tl: find_in_bucket(rest)
                };
              }
              _param = rest;
              continue;
            case /* EFalse */ 1 :
            case /* EDead */ 2 :
              _param = rest;
              continue;
          }
        } else {
          _param = param._2;
          continue;
        }
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  const replace = function (h, key, info) {
    const hkey = seeded_hash(h.seed, key);
    const i = key_index(h, hkey);
    const l = Caml_array.get(h.data, i);
    try {
      let _param = l;
      while (true) {
        const param = _param;
        if (/* tag */ typeof param !== "object" && typeof param !== "function") {
          throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
        }
        if (hkey === param._0) {
          const next = param._2;
          const c = param._1;
          const match = equal$2(c, key);
          switch (match) {
            case /* ETrue */ 0 :
              Stdlib__Obj.Ephemeron.unset_data(c);
              set_key1(c, key[0]);
              set_key2(c, key[1]);
              return Stdlib__Obj.Ephemeron.set_data(c, info);
            case /* EFalse */ 1 :
            case /* EDead */ 2 :
              _param = next;
              continue;
          }
        } else {
          _param = param._2;
          continue;
        }
      };
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        const container = create(key, info);
        Caml_array.set(h.data, i, {
          TAG: /* Cons */ 0,
          _0: hkey,
          _1: container,
          _2: l
        });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return;
        }
      }
      throw exn;
    }
  };
  const mem = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        return false;
      }
      if (param._0 === hkey) {
        const rest = param._2;
        const match = equal$2(param._1, key);
        switch (match) {
          case /* ETrue */ 0 :
            return true;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const length = function (h) {
    return h.size;
  };
  const bucket_length = function (_accu, _param) {
    while (true) {
      const param = _param;
      const accu = _accu;
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue;
    };
  };
  const stats = function (h) {
    const mbl = Stdlib__Array.fold_left((function (m, b) {
      return Stdlib__Int.max(m, bucket_length(0, b));
    }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
      const l = bucket_length(0, b);
      Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
    }), h.data);
    return {
      num_bindings: h.size,
      num_buckets: h.data.length,
      max_bucket_length: mbl,
      bucket_histogram: histo
    };
  };
  const bucket_length_alive = function (_accu, _param) {
    while (true) {
      const param = _param;
      const accu = _accu;
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue;
      }
      _param = param._2;
      continue;
    };
  };
  const stats_alive = function (h) {
    const size = {
      contents: 0
    };
    const mbl = Stdlib__Array.fold_left((function (m, b) {
      return Stdlib__Int.max(m, bucket_length_alive(0, b));
    }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
      const l = bucket_length_alive(0, b);
      size.contents = size.contents + l | 0;
      Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
    }), h.data);
    return {
      num_bindings: size.contents,
      num_buckets: h.data.length,
      max_bucket_length: mbl,
      bucket_histogram: histo
    };
  };
  const add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
      add(tbl, param[0], param[1]);
    }), i);
  };
  const replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
      replace(tbl, param[0], param[1]);
    }), i);
  };
  const create$2 = function (sz) {
    return create$1(false, sz);
  };
  const of_seq = function (i) {
    const tbl = create$1(false, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
    create: create$2,
    clear: clear,
    reset: reset,
    copy: copy,
    add: add,
    remove: remove,
    find: find,
    find_opt: find_opt,
    find_all: find_all,
    replace: replace,
    mem: mem,
    length: length,
    stats: stats,
    add_seq: add_seq,
    replace_seq: replace_seq,
    of_seq: of_seq,
    clean: clean,
    stats_alive: stats_alive
  };
}

function make$3(param) {
  return {
    contents: /* [] */ 0
  };
}

function add$1(b, k1, k2, d) {
  b.contents = {
    hd: make$2(k1, k2, d),
    tl: b.contents
  };
}

function test_keys(k1, k2, e) {
  const match = Stdlib__Obj.Ephemeron.get_key(e, 0);
  const match$1 = Stdlib__Obj.Ephemeron.get_key(e, 1);
  if (match !== undefined && match$1 !== undefined && Caml_option.valFromOption(match) === k1) {
    return Caml_option.valFromOption(match$1) === k2;
  } else {
    return false;
  }
}

function remove$1(b, k1, k2) {
  let _l = b.contents;
  let _acc = /* [] */ 0;
  while (true) {
    const acc = _acc;
    const l = _l;
    if (!l) {
      return;
    }
    const h = l.hd;
    if (test_keys(k1, k2, h)) {
      b.contents = Stdlib__List.rev_append(acc, l.tl);
      return;
    }
    _acc = {
      hd: h,
      tl: acc
    };
    _l = l.tl;
    continue;
  };
}

function find$1(b, k1, k2) {
  const e = Stdlib__List.find_opt((function (param) {
    return test_keys(k1, k2, param);
  }), b.contents);
  if (e !== undefined) {
    return Stdlib__Obj.Ephemeron.get_data(Caml_option.valFromOption(e));
  }
  
}

function length$1(b) {
  return Stdlib__List.length(b.contents);
}

function clear$1(b) {
  b.contents = /* [] */ 0;
}

function set_key$1(t, n, k) {
  Stdlib__Obj.Ephemeron.set_key(t, n, k);
}

function get_data$2(t) {
  return Stdlib__Obj.Ephemeron.get_data(t);
}

function make$4(keys, data) {
  const l = keys.length;
  const eph = Stdlib__Obj.Ephemeron.create(l);
  Stdlib__Obj.Ephemeron.set_data(eph, data);
  for (let i = 0; i < l; ++i) {
    set_key$1(eph, i, Caml_array.get(keys, i));
  }
  return eph;
}

function query$2(eph, keys) {
  const l = Stdlib__Obj.Ephemeron.length(eph);
  try {
    if (l !== keys.length) {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
          MEL_EXN_ID: Stdlib.Exit
        });
    }
    for (let i = 0; i < l; ++i) {
      const k = Stdlib__Obj.Ephemeron.get_key(eph, i);
      if (k !== undefined) {
        if (Caml_option.valFromOption(k) !== Caml_array.get(keys, i)) {
          throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
              MEL_EXN_ID: Stdlib.Exit
            });
        }
        
      } else {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
            MEL_EXN_ID: Stdlib.Exit
          });
      }
    }
    return Stdlib__Obj.Ephemeron.get_data(eph);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Exit) {
      return;
    }
    throw exn;
  }
}

function MakeSeeded$2(H) {
  const create = function (k, d) {
    const c = Stdlib__Obj.Ephemeron.create(k.length);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    for (let i = 0, i_finish = k.length; i < i_finish; ++i) {
      set_key$1(c, i, Caml_array.get(k, i));
    }
    return c;
  };
  const seeded_hash = function (seed, k) {
    let h = 0;
    for (let i = 0, i_finish = k.length; i < i_finish; ++i) {
      h = Math.imul(Curry._2(H.seeded_hash, seed, Caml_array.get(k, i)), 65599) + h | 0;
    }
    return h;
  };
  const equal = function (c, k) {
    const len = k.length;
    const len$p = Stdlib__Obj.Ephemeron.length(c);
    if (len !== len$p) {
      return /* EFalse */ 1;
    }
    let _i = len - 1 | 0;
    while (true) {
      const i = _i;
      if (i < 0) {
        return /* ETrue */ 0;
      }
      const ki = Stdlib__Obj.Ephemeron.get_key(c, i);
      if (ki === undefined) {
        return /* EDead */ 2;
      }
      if (!Curry._2(H.equal, Caml_array.get(k, i), Caml_option.valFromOption(ki))) {
        return /* EFalse */ 1;
      }
      _i = i - 1 | 0;
      continue;
    };
  };
  const check_key = function (c) {
    let _i = Stdlib__Obj.Ephemeron.length(c) - 1 | 0;
    while (true) {
      const i = _i;
      if (i < 0) {
        return true;
      }
      if (!Stdlib__Obj.Ephemeron.check_key(c, i)) {
        return false;
      }
      _i = i - 1 | 0;
      continue;
    };
  };
  const power_2_above = function (_x, n) {
    while (true) {
      const x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue;
    };
  };
  const prng = {
    LAZY_DONE: false,
    VAL: (function () {
      return Stdlib__Random.State.make_self_init();
    })
  };
  const create$1 = function (randomOpt, initial_size) {
    const random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized();
    const s = power_2_above(16, initial_size);
    const seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
      size: 0,
      data: Caml_array.make(s, /* Empty */ 0),
      seed: seed,
      initial_size: s
    };
  };
  const clear = function (h) {
    h.size = 0;
    const len = h.data.length;
    for (let i = 0; i < len; ++i) {
      Caml_array.set(h.data, i, /* Empty */ 0);
    }
  };
  const reset = function (h) {
    const len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */ 0);
      return;
    }
  };
  const copy = function (h) {
    return {
      size: h.size,
      data: Stdlib__Array.copy(h.data),
      seed: h.seed,
      initial_size: h.initial_size
    };
  };
  const key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  const clean = function (h) {
    const do_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param !== "object" && typeof param !== "function") {
          return /* Empty */ 0;
        }
        if (check_key(param._1)) {
          return {
            TAG: /* Cons */ 0,
            _0: param._0,
            _1: param._1,
            _2: do_bucket(param._2)
          };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue;
      };
    };
    const d = h.data;
    for (let i = 0, i_finish = d.length; i < i_finish; ++i) {
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  const resize = function (h) {
    const odata = h.data;
    const osize = odata.length;
    const nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return;
    }
    const ndata = Caml_array.make(nsize, /* Empty */ 0);
    h.data = ndata;
    const insert_bucket = function (param) {
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        return;
      }
      const hkey = param._0;
      insert_bucket(param._2);
      const nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, {
        TAG: /* Cons */ 0,
        _0: hkey,
        _1: param._1,
        _2: Caml_array.get(ndata, nidx)
      });
    };
    for (let i = 0; i < osize; ++i) {
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  const add = function (h, key, info) {
    const hkey = seeded_hash(h.seed, key);
    const i = key_index(h, hkey);
    const container = create(key, info);
    const bucket_2 = Caml_array.get(h.data, i);
    const bucket = {
      TAG: /* Cons */ 0,
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  const remove = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    const remove_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param !== "object" && typeof param !== "function") {
          return /* Empty */ 0;
        }
        const hk = param._0;
        if (hkey !== hk) {
          return {
            TAG: /* Cons */ 0,
            _0: hk,
            _1: param._1,
            _2: remove_bucket(param._2)
          };
        }
        const next = param._2;
        const c = param._1;
        const match = equal(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            h.size = h.size - 1 | 0;
            return next;
          case /* EFalse */ 1 :
            return {
              TAG: /* Cons */ 0,
              _0: hk,
              _1: c,
              _2: remove_bucket(next)
            };
          case /* EDead */ 2 :
            h.size = h.size - 1 | 0;
            _param = next;
            continue;
        }
      };
    };
    const i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  const find = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
      }
      if (hkey === param._0) {
        const rest = param._2;
        const c = param._1;
        const match = equal(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            const d = get_data$2(c);
            if (d !== undefined) {
              return Caml_option.valFromOption(d);
            }
            _param = rest;
            continue;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const find_opt = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        return;
      }
      if (hkey === param._0) {
        const rest = param._2;
        const c = param._1;
        const match = equal(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            const d = get_data$2(c);
            if (d !== undefined) {
              return d;
            }
            _param = rest;
            continue;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const find_all = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    const find_in_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param !== "object" && typeof param !== "function") {
          return /* [] */ 0;
        }
        if (hkey === param._0) {
          const rest = param._2;
          const c = param._1;
          const match = equal(c, key);
          switch (match) {
            case /* ETrue */ 0 :
              const d = get_data$2(c);
              if (d !== undefined) {
                return {
                  hd: Caml_option.valFromOption(d),
                  tl: find_in_bucket(rest)
                };
              }
              _param = rest;
              continue;
            case /* EFalse */ 1 :
            case /* EDead */ 2 :
              _param = rest;
              continue;
          }
        } else {
          _param = param._2;
          continue;
        }
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  const replace = function (h, key, info) {
    const hkey = seeded_hash(h.seed, key);
    const i = key_index(h, hkey);
    const l = Caml_array.get(h.data, i);
    try {
      let _param = l;
      while (true) {
        const param = _param;
        if (/* tag */ typeof param !== "object" && typeof param !== "function") {
          throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
        }
        if (hkey === param._0) {
          const next = param._2;
          const c = param._1;
          const match = equal(c, key);
          switch (match) {
            case /* ETrue */ 0 :
              Stdlib__Obj.Ephemeron.unset_data(c);
              for (let i$1 = 0, i_finish = key.length; i$1 < i_finish; ++i$1) {
                set_key$1(c, i$1, Caml_array.get(key, i$1));
              }
              return Stdlib__Obj.Ephemeron.set_data(c, info);
            case /* EFalse */ 1 :
            case /* EDead */ 2 :
              _param = next;
              continue;
          }
        } else {
          _param = param._2;
          continue;
        }
      };
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        const container = create(key, info);
        Caml_array.set(h.data, i, {
          TAG: /* Cons */ 0,
          _0: hkey,
          _1: container,
          _2: l
        });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return;
        }
      }
      throw exn;
    }
  };
  const mem = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        return false;
      }
      if (param._0 === hkey) {
        const rest = param._2;
        const match = equal(param._1, key);
        switch (match) {
          case /* ETrue */ 0 :
            return true;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const length = function (h) {
    return h.size;
  };
  const bucket_length = function (_accu, _param) {
    while (true) {
      const param = _param;
      const accu = _accu;
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue;
    };
  };
  const stats = function (h) {
    const mbl = Stdlib__Array.fold_left((function (m, b) {
      return Stdlib__Int.max(m, bucket_length(0, b));
    }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
      const l = bucket_length(0, b);
      Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
    }), h.data);
    return {
      num_bindings: h.size,
      num_buckets: h.data.length,
      max_bucket_length: mbl,
      bucket_histogram: histo
    };
  };
  const bucket_length_alive = function (_accu, _param) {
    while (true) {
      const param = _param;
      const accu = _accu;
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue;
      }
      _param = param._2;
      continue;
    };
  };
  const stats_alive = function (h) {
    const size = {
      contents: 0
    };
    const mbl = Stdlib__Array.fold_left((function (m, b) {
      return Stdlib__Int.max(m, bucket_length_alive(0, b));
    }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
      const l = bucket_length_alive(0, b);
      size.contents = size.contents + l | 0;
      Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
    }), h.data);
    return {
      num_bindings: size.contents,
      num_buckets: h.data.length,
      max_bucket_length: mbl,
      bucket_histogram: histo
    };
  };
  const add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
      add(tbl, param[0], param[1]);
    }), i);
  };
  const replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
      replace(tbl, param[0], param[1]);
    }), i);
  };
  const of_seq = function (i) {
    const tbl = create$1(undefined, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
    create: create$1,
    clear: clear,
    reset: reset,
    copy: copy,
    add: add,
    remove: remove,
    find: find,
    find_opt: find_opt,
    find_all: find_all,
    replace: replace,
    mem: mem,
    length: length,
    stats: stats,
    add_seq: add_seq,
    replace_seq: replace_seq,
    of_seq: of_seq,
    clean: clean,
    stats_alive: stats_alive
  };
}

function Make$2(H) {
  const equal = H.equal;
  const create = function (k, d) {
    const c = Stdlib__Obj.Ephemeron.create(k.length);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    for (let i = 0, i_finish = k.length; i < i_finish; ++i) {
      set_key$1(c, i, Caml_array.get(k, i));
    }
    return c;
  };
  const seeded_hash = function (seed, k) {
    let h = 0;
    for (let i = 0, i_finish = k.length; i < i_finish; ++i) {
      h = Math.imul(Curry._1(H.hash, Caml_array.get(k, i)), 65599) + h | 0;
    }
    return h;
  };
  const equal$1 = function (c, k) {
    const len = k.length;
    const len$p = Stdlib__Obj.Ephemeron.length(c);
    if (len !== len$p) {
      return /* EFalse */ 1;
    }
    let _i = len - 1 | 0;
    while (true) {
      const i = _i;
      if (i < 0) {
        return /* ETrue */ 0;
      }
      const ki = Stdlib__Obj.Ephemeron.get_key(c, i);
      if (ki === undefined) {
        return /* EDead */ 2;
      }
      if (!Curry._2(equal, Caml_array.get(k, i), Caml_option.valFromOption(ki))) {
        return /* EFalse */ 1;
      }
      _i = i - 1 | 0;
      continue;
    };
  };
  const check_key = function (c) {
    let _i = Stdlib__Obj.Ephemeron.length(c) - 1 | 0;
    while (true) {
      const i = _i;
      if (i < 0) {
        return true;
      }
      if (!Stdlib__Obj.Ephemeron.check_key(c, i)) {
        return false;
      }
      _i = i - 1 | 0;
      continue;
    };
  };
  const power_2_above = function (_x, n) {
    while (true) {
      const x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue;
    };
  };
  const prng = {
    LAZY_DONE: false,
    VAL: (function () {
      return Stdlib__Random.State.make_self_init();
    })
  };
  const create$1 = function (randomOpt, initial_size) {
    const random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized();
    const s = power_2_above(16, initial_size);
    const seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
      size: 0,
      data: Caml_array.make(s, /* Empty */ 0),
      seed: seed,
      initial_size: s
    };
  };
  const clear = function (h) {
    h.size = 0;
    const len = h.data.length;
    for (let i = 0; i < len; ++i) {
      Caml_array.set(h.data, i, /* Empty */ 0);
    }
  };
  const reset = function (h) {
    const len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */ 0);
      return;
    }
  };
  const copy = function (h) {
    return {
      size: h.size,
      data: Stdlib__Array.copy(h.data),
      seed: h.seed,
      initial_size: h.initial_size
    };
  };
  const key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  const clean = function (h) {
    const do_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param !== "object" && typeof param !== "function") {
          return /* Empty */ 0;
        }
        if (check_key(param._1)) {
          return {
            TAG: /* Cons */ 0,
            _0: param._0,
            _1: param._1,
            _2: do_bucket(param._2)
          };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue;
      };
    };
    const d = h.data;
    for (let i = 0, i_finish = d.length; i < i_finish; ++i) {
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  const resize = function (h) {
    const odata = h.data;
    const osize = odata.length;
    const nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return;
    }
    const ndata = Caml_array.make(nsize, /* Empty */ 0);
    h.data = ndata;
    const insert_bucket = function (param) {
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        return;
      }
      const hkey = param._0;
      insert_bucket(param._2);
      const nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, {
        TAG: /* Cons */ 0,
        _0: hkey,
        _1: param._1,
        _2: Caml_array.get(ndata, nidx)
      });
    };
    for (let i = 0; i < osize; ++i) {
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  const add = function (h, key, info) {
    const hkey = seeded_hash(h.seed, key);
    const i = key_index(h, hkey);
    const container = create(key, info);
    const bucket_2 = Caml_array.get(h.data, i);
    const bucket = {
      TAG: /* Cons */ 0,
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  const remove = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    const remove_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param !== "object" && typeof param !== "function") {
          return /* Empty */ 0;
        }
        const hk = param._0;
        if (hkey !== hk) {
          return {
            TAG: /* Cons */ 0,
            _0: hk,
            _1: param._1,
            _2: remove_bucket(param._2)
          };
        }
        const next = param._2;
        const c = param._1;
        const match = equal$1(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            h.size = h.size - 1 | 0;
            return next;
          case /* EFalse */ 1 :
            return {
              TAG: /* Cons */ 0,
              _0: hk,
              _1: c,
              _2: remove_bucket(next)
            };
          case /* EDead */ 2 :
            h.size = h.size - 1 | 0;
            _param = next;
            continue;
        }
      };
    };
    const i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  const find = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
      }
      if (hkey === param._0) {
        const rest = param._2;
        const c = param._1;
        const match = equal$1(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            const d = get_data$2(c);
            if (d !== undefined) {
              return Caml_option.valFromOption(d);
            }
            _param = rest;
            continue;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const find_opt = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        return;
      }
      if (hkey === param._0) {
        const rest = param._2;
        const c = param._1;
        const match = equal$1(c, key);
        switch (match) {
          case /* ETrue */ 0 :
            const d = get_data$2(c);
            if (d !== undefined) {
              return d;
            }
            _param = rest;
            continue;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const find_all = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    const find_in_bucket = function (_param) {
      while (true) {
        const param = _param;
        if (/* tag */ typeof param !== "object" && typeof param !== "function") {
          return /* [] */ 0;
        }
        if (hkey === param._0) {
          const rest = param._2;
          const c = param._1;
          const match = equal$1(c, key);
          switch (match) {
            case /* ETrue */ 0 :
              const d = get_data$2(c);
              if (d !== undefined) {
                return {
                  hd: Caml_option.valFromOption(d),
                  tl: find_in_bucket(rest)
                };
              }
              _param = rest;
              continue;
            case /* EFalse */ 1 :
            case /* EDead */ 2 :
              _param = rest;
              continue;
          }
        } else {
          _param = param._2;
          continue;
        }
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  const replace = function (h, key, info) {
    const hkey = seeded_hash(h.seed, key);
    const i = key_index(h, hkey);
    const l = Caml_array.get(h.data, i);
    try {
      let _param = l;
      while (true) {
        const param = _param;
        if (/* tag */ typeof param !== "object" && typeof param !== "function") {
          throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
        }
        if (hkey === param._0) {
          const next = param._2;
          const c = param._1;
          const match = equal$1(c, key);
          switch (match) {
            case /* ETrue */ 0 :
              Stdlib__Obj.Ephemeron.unset_data(c);
              for (let i$1 = 0, i_finish = key.length; i$1 < i_finish; ++i$1) {
                set_key$1(c, i$1, Caml_array.get(key, i$1));
              }
              return Stdlib__Obj.Ephemeron.set_data(c, info);
            case /* EFalse */ 1 :
            case /* EDead */ 2 :
              _param = next;
              continue;
          }
        } else {
          _param = param._2;
          continue;
        }
      };
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        const container = create(key, info);
        Caml_array.set(h.data, i, {
          TAG: /* Cons */ 0,
          _0: hkey,
          _1: container,
          _2: l
        });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return;
        }
      }
      throw exn;
    }
  };
  const mem = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while (true) {
      const param = _param;
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        return false;
      }
      if (param._0 === hkey) {
        const rest = param._2;
        const match = equal$1(param._1, key);
        switch (match) {
          case /* ETrue */ 0 :
            return true;
          case /* EFalse */ 1 :
          case /* EDead */ 2 :
            _param = rest;
            continue;
        }
      } else {
        _param = param._2;
        continue;
      }
    };
  };
  const length = function (h) {
    return h.size;
  };
  const bucket_length = function (_accu, _param) {
    while (true) {
      const param = _param;
      const accu = _accu;
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue;
    };
  };
  const stats = function (h) {
    const mbl = Stdlib__Array.fold_left((function (m, b) {
      return Stdlib__Int.max(m, bucket_length(0, b));
    }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
      const l = bucket_length(0, b);
      Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
    }), h.data);
    return {
      num_bindings: h.size,
      num_buckets: h.data.length,
      max_bucket_length: mbl,
      bucket_histogram: histo
    };
  };
  const bucket_length_alive = function (_accu, _param) {
    while (true) {
      const param = _param;
      const accu = _accu;
      if (/* tag */ typeof param !== "object" && typeof param !== "function") {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue;
      }
      _param = param._2;
      continue;
    };
  };
  const stats_alive = function (h) {
    const size = {
      contents: 0
    };
    const mbl = Stdlib__Array.fold_left((function (m, b) {
      return Stdlib__Int.max(m, bucket_length_alive(0, b));
    }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
      const l = bucket_length_alive(0, b);
      size.contents = size.contents + l | 0;
      Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
    }), h.data);
    return {
      num_bindings: size.contents,
      num_buckets: h.data.length,
      max_bucket_length: mbl,
      bucket_histogram: histo
    };
  };
  const add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
      add(tbl, param[0], param[1]);
    }), i);
  };
  const replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
      replace(tbl, param[0], param[1]);
    }), i);
  };
  const create$2 = function (sz) {
    return create$1(false, sz);
  };
  const of_seq = function (i) {
    const tbl = create$1(false, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
    create: create$2,
    clear: clear,
    reset: reset,
    copy: copy,
    add: add,
    remove: remove,
    find: find,
    find_opt: find_opt,
    find_all: find_all,
    replace: replace,
    mem: mem,
    length: length,
    stats: stats,
    add_seq: add_seq,
    replace_seq: replace_seq,
    of_seq: of_seq,
    clean: clean,
    stats_alive: stats_alive
  };
}

function make$5(param) {
  return {
    contents: /* [] */ 0
  };
}

function add$2(b, k, d) {
  b.contents = {
    hd: make$4(k, d),
    tl: b.contents
  };
}

function test_keys$1(k, e) {
  try {
    if (Stdlib__Obj.Ephemeron.length(e) !== k.length) {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
          MEL_EXN_ID: Stdlib.Exit
        });
    }
    for (let i = 0, i_finish = k.length; i < i_finish; ++i) {
      const x = Stdlib__Obj.Ephemeron.get_key(e, i);
      if (x !== undefined) {
        if (Caml_option.valFromOption(x) !== Caml_array.get(k, i)) {
          throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
              MEL_EXN_ID: Stdlib.Exit
            });
        }
        
      } else {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
            MEL_EXN_ID: Stdlib.Exit
          });
      }
    }
    return true;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Exit) {
      return false;
    }
    throw exn;
  }
}

function remove$2(b, k) {
  let _l = b.contents;
  let _acc = /* [] */ 0;
  while (true) {
    const acc = _acc;
    const l = _l;
    if (!l) {
      return;
    }
    const h = l.hd;
    if (test_keys$1(k, h)) {
      b.contents = Stdlib__List.rev_append(acc, l.tl);
      return;
    }
    _acc = {
      hd: h,
      tl: acc
    };
    _l = l.tl;
    continue;
  };
}

function find$2(b, k) {
  const e = Stdlib__List.find_opt((function (param) {
    return test_keys$1(k, param);
  }), b.contents);
  if (e !== undefined) {
    return Stdlib__Obj.Ephemeron.get_data(Caml_option.valFromOption(e));
  }
  
}

function length$2(b) {
  return Stdlib__List.length(b.contents);
}

function clear$2(b) {
  b.contents = /* [] */ 0;
}

const K1_Bucket = {
  make: make$1,
  add: add,
  remove: remove,
  find: find,
  length: length,
  clear: clear
};

const K1 = {
  make: make,
  query: query,
  Make: Make,
  MakeSeeded: MakeSeeded,
  Bucket: K1_Bucket
};

const K2_Bucket = {
  make: make$3,
  add: add$1,
  remove: remove$1,
  find: find$1,
  length: length$1,
  clear: clear$1
};

const K2 = {
  make: make$2,
  query: query$1,
  Make: Make$1,
  MakeSeeded: MakeSeeded$1,
  Bucket: K2_Bucket
};

const Kn_Bucket = {
  make: make$5,
  add: add$2,
  remove: remove$2,
  find: find$2,
  length: length$2,
  clear: clear$2
};

const Kn = {
  make: make$4,
  query: query$2,
  Make: Make$2,
  MakeSeeded: MakeSeeded$2,
  Bucket: Kn_Bucket
};

export {
  K1,
  K2,
  Kn,
}
/* Stdlib__Hashtbl Not a pure module */
