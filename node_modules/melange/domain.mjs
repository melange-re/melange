// Generated by Melange

import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.mjs";
import * as Caml_option from "melange.js/caml_option.mjs";
import * as Curry from "melange.js/curry.mjs";
import * as Stdlib__Fun from "./fun.mjs";
import * as Stdlib__List from "./list.mjs";
import * as Stdlib__Printexc from "./printexc.mjs";
import * as Stdlib__Queue from "./queue.mjs";

const atomic_lock = {
  contents: false
};

function atomically(f) {
  atomic_lock.contents = true;
  return Stdlib__Fun.protect((function (param) {
    atomic_lock.contents = false;
  }), f);
}

const first_spawn_queue = {
  length: 0,
  first: /* Nil */ 0,
  last: /* Nil */ 0
};

const first_spawn_occurred = {
  contents: false
};

function before_first_spawn(f) {
  atomically(function (param) {
    if (first_spawn_occurred.contents) {
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Domain.before_first_spawn"
        });
    }
    Stdlib__Queue.push(f, first_spawn_queue);
  });
}

function maybe_first_spawn(param) {
  atomically(function (param) {
    if (first_spawn_occurred.contents) {
      return;
    }
    first_spawn_occurred.contents = true;
    while (first_spawn_queue.length !== 0) {
      const f = Stdlib__Queue.take(first_spawn_queue);
      Curry._1(f, undefined);
    };
  });
}

const at_exit_table = {
  contents: /* [] */ 0
};

function at_exit(f) {
  atomically(function (param) {
    at_exit_table.contents = {
      hd: f,
      tl: at_exit_table.contents
    };
  });
}

function get_id(t) {
  return t.id;
}

function self(param) {
  return 0;
}

function cpu_relax(param) {
  
}

function is_main_domain(param) {
  return true;
}

function self_index(param) {
  return 0;
}

function recommended_domain_count(param) {
  return 1;
}

const all_keys = {
  contents: /* [] */ 0
};

function new_key(split_from_parent, init) {
  const key = {
    table: undefined,
    split_from_parent: split_from_parent,
    init: init
  };
  atomically(function (param) {
    all_keys.contents = {
      hd: {
        TAG: /* Key */ 0,
        _0: key
      },
      tl: all_keys.contents
    };
  });
  return key;
}

function get(key) {
  const v = key.table;
  if (v !== undefined) {
    return Caml_option.valFromOption(v);
  }
  const v$1 = Curry._1(key.init, undefined);
  atomically(function (param) {
    key.table = Caml_option.some(v$1);
  });
  return v$1;
}

function set(key, v) {
  atomically(function (param) {
    key.table = Caml_option.some(v);
  });
}

function prepare_split_keys_before_spawn(param) {
  return Stdlib__List.filter_map((function (key) {
    let key$1 = key._0;
    const split = key$1.split_from_parent;
    if (split === undefined) {
      return;
    }
    const current = get(key$1);
    const child = Curry._1(split, current);
    return {
      TAG: /* Key_value */ 0,
      _0: key$1,
      _1: child
    };
  }), all_keys.contents);
}

function perform_split_after_spawn(split_keys) {
  const perform_split = function (param) {
    set(param._0, param._1);
  };
  Stdlib__List.iter(perform_split, split_keys);
}

const next_id = {
  contents: 0
};

function spawn(f) {
  maybe_first_spawn();
  const status = {
    contents: /* Running */ 0
  };
  const split_keys = prepare_split_keys_before_spawn();
  const handle = new Promise((function (resolve, reject) {
      let param = [
        split_keys,
        status
      ];
      const status$1 = param[1];
      perform_split_after_spawn(param[0]);
      let exit = 0;
      let v;
      try {
        v = Curry._1(f, undefined);
        exit = 1;
      }
      catch (raw_exn){
        const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        let bt;
        status$1.contents = {
          TAG: /* Error */ 1,
          _0: exn,
          _1: bt
        };
        reject(exn);
      }
      if (exit === 1) {
        status$1.contents = {
          TAG: /* Return */ 0,
          _0: v
        };
        resolve(v);
      }
      const at_exit_callbacks = atomically(function (param) {
        return at_exit_table.contents;
      });
      try {
        Stdlib__List.iter((function (f) {
          Curry._1(f, undefined);
        }), at_exit_callbacks);
        return;
      }
      catch (raw_exn$1){
        const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
        const match = status$1.contents;
        if (/* tag */ typeof match !== "object" && typeof match !== "function") {
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/stdlib/domain.ml",
                77,
                19
              ]
            });
        }
        if (match.TAG !== /* Return */ 0) {
          return;
        }
        let bt$1;
        status$1.contents = {
          TAG: /* Error */ 1,
          _0: exn$1,
          _1: bt$1
        };
        return;
      }
    }));
  return {
    id: (next_id.contents = next_id.contents + 1 | 0, next_id.contents),
    handle: handle,
    status: status
  };
}

function join(t) {
  return t.handle.then(function (param) {
    const v = t.status.contents;
    if (/* tag */ typeof v !== "object" && typeof v !== "function") {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "jscomp/stdlib/domain.ml",
            181,
            17
          ]
        });
    }
    if (v.TAG === /* Return */ 0) {
      return Promise.resolve(v._0);
    }
    throw v._0;
  }).catch(function (param) {
    const match = t.status.contents;
    if (/* tag */ typeof match !== "object" && typeof match !== "function") {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "jscomp/stdlib/domain.ml",
            188,
            30
          ]
        });
    }
    if (match.TAG === /* Return */ 0) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "jscomp/stdlib/domain.ml",
            188,
            30
          ]
        });
    }
    throw match._0;
  });
}

const DLS = {
  new_key: new_key,
  get: get,
  set: set
};

export {
  spawn,
  join,
  get_id,
  self,
  before_first_spawn,
  at_exit,
  cpu_relax,
  is_main_domain,
  recommended_domain_count,
  self_index,
  DLS,
}
/* Stdlib__Fun Not a pure module */
