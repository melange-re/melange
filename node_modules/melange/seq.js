// Generated by Melange
'use strict';

const Caml_exceptions = require("melange.js/caml_exceptions.js");
const Caml_js_exceptions = require("melange.js/caml_js_exceptions.js");
const Caml_option = require("melange.js/caml_option.js");
const CamlinternalLazy = require("./camlinternalLazy.js");
const Curry = require("melange.js/curry.js");
const Stdlib__Atomic = require("./atomic.js");

function empty(param) {
  return /* Nil */ 0;
}

function $$return(x, param) {
  return {
    TAG: /* Cons */ 0,
    _0: x,
    _1: empty
  };
}

function cons(x, next, param) {
  return {
    TAG: /* Cons */ 0,
    _0: x,
    _1: next
  };
}

function singleton(x, param) {
  return {
    TAG: /* Cons */ 0,
    _0: x,
    _1: empty
  };
}

function append(seq1, seq2, param) {
  const match = Curry._1(seq1, undefined);
  if (/* tag */ typeof match !== "object" && typeof match !== "function") {
    return Curry._1(seq2, undefined);
  }
  const next = match._1;
  return {
    TAG: /* Cons */ 0,
    _0: match._0,
    _1: (function (param) {
      return append(next, seq2, param);
    })
  };
}

function map(f, seq, param) {
  const match = Curry._1(seq, undefined);
  if (/* tag */ typeof match !== "object" && typeof match !== "function") {
    return /* Nil */ 0;
  }
  const next = match._1;
  return {
    TAG: /* Cons */ 0,
    _0: Curry._1(f, match._0),
    _1: (function (param) {
      return map(f, next, param);
    })
  };
}

function filter_map(f, _seq, _param) {
  while (true) {
    const seq = _seq;
    const match = Curry._1(seq, undefined);
    if (/* tag */ typeof match !== "object" && typeof match !== "function") {
      return /* Nil */ 0;
    }
    const next = match._1;
    const y = Curry._1(f, match._0);
    if (y !== undefined) {
      return {
        TAG: /* Cons */ 0,
        _0: Caml_option.valFromOption(y),
        _1: (function (param) {
          return filter_map(f, next, param);
        })
      };
    }
    _param = undefined;
    _seq = next;
    continue;
  };
}

function filter(f, _seq, _param) {
  while (true) {
    const seq = _seq;
    const match = Curry._1(seq, undefined);
    if (/* tag */ typeof match !== "object" && typeof match !== "function") {
      return /* Nil */ 0;
    }
    const next = match._1;
    const x = match._0;
    if (Curry._1(f, x)) {
      return {
        TAG: /* Cons */ 0,
        _0: x,
        _1: (function (param) {
          return filter(f, next, param);
        })
      };
    }
    _param = undefined;
    _seq = next;
    continue;
  };
}

function filteri_aux(f, _i, _seq, _param) {
  while (true) {
    const seq = _seq;
    const i = _i;
    const match = Curry._1(seq, undefined);
    if (/* tag */ typeof match !== "object" && typeof match !== "function") {
      return /* Nil */ 0;
    }
    const next = match._1;
    const x = match._0;
    const i$p = i + 1 | 0;
    if (Curry._2(f, i, x)) {
      return {
        TAG: /* Cons */ 0,
        _0: x,
        _1: (function (param) {
          return filteri_aux(f, i$p, next, param);
        })
      };
    }
    _param = undefined;
    _seq = next;
    _i = i$p;
    continue;
  };
}

function filteri(f, seq, param) {
  return filteri_aux(f, 0, seq, undefined);
}

function concat(seq, param) {
  const match = Curry._1(seq, undefined);
  if (/* tag */ typeof match !== "object" && typeof match !== "function") {
    return /* Nil */ 0;
  }
  const next = match._1;
  return append(match._0, (function (param) {
    return concat(next, param);
  }), undefined);
}

function flat_map(f, seq, param) {
  const match = Curry._1(seq, undefined);
  if (/* tag */ typeof match !== "object" && typeof match !== "function") {
    return /* Nil */ 0;
  }
  const next = match._1;
  return append(Curry._1(f, match._0), (function (param) {
    return flat_map(f, next, param);
  }), undefined);
}

function fold_left(f, _acc, _seq) {
  while (true) {
    const seq = _seq;
    const acc = _acc;
    const match = Curry._1(seq, undefined);
    if (/* tag */ typeof match !== "object" && typeof match !== "function") {
      return acc;
    }
    const acc$1 = Curry._2(f, acc, match._0);
    _seq = match._1;
    _acc = acc$1;
    continue;
  };
}

function iter(f, _seq) {
  while (true) {
    const seq = _seq;
    const match = Curry._1(seq, undefined);
    if (/* tag */ typeof match !== "object" && typeof match !== "function") {
      return;
    }
    Curry._1(f, match._0);
    _seq = match._1;
    continue;
  };
}

function unfold(f, u, param) {
  const match = Curry._1(f, u);
  if (match === undefined) {
    return /* Nil */ 0;
  }
  const u$p = match[1];
  return {
    TAG: /* Cons */ 0,
    _0: match[0],
    _1: (function (param) {
      return unfold(f, u$p, param);
    })
  };
}

function is_empty(xs) {
  const match = Curry._1(xs, undefined);
  if (/* tag */ typeof match !== "object" && typeof match !== "function") {
    return true;
  } else {
    return false;
  }
}

function uncons(xs) {
  const match = Curry._1(xs, undefined);
  if (/* tag */ typeof match !== "object" && typeof match !== "function") {
    return;
  } else {
    return [
      match._0,
      match._1
    ];
  }
}

function length(xs) {
  let _accu = 0;
  let _xs = xs;
  while (true) {
    const xs$1 = _xs;
    const accu = _accu;
    const match = Curry._1(xs$1, undefined);
    if (/* tag */ typeof match !== "object" && typeof match !== "function") {
      return accu;
    }
    _xs = match._1;
    _accu = accu + 1 | 0;
    continue;
  };
}

function iteri(f, xs) {
  let _i = 0;
  let _xs = xs;
  while (true) {
    const xs$1 = _xs;
    const i = _i;
    const match = Curry._1(xs$1, undefined);
    if (/* tag */ typeof match !== "object" && typeof match !== "function") {
      return;
    }
    Curry._2(f, i, match._0);
    _xs = match._1;
    _i = i + 1 | 0;
    continue;
  };
}

function fold_lefti(f, accu, xs) {
  let _accu = accu;
  let _i = 0;
  let _xs = xs;
  while (true) {
    const xs$1 = _xs;
    const i = _i;
    const accu$1 = _accu;
    const match = Curry._1(xs$1, undefined);
    if (/* tag */ typeof match !== "object" && typeof match !== "function") {
      return accu$1;
    }
    const accu$2 = Curry._3(f, accu$1, i, match._0);
    _xs = match._1;
    _i = i + 1 | 0;
    _accu = accu$2;
    continue;
  };
}

function for_all(p, _xs) {
  while (true) {
    const xs = _xs;
    const match = Curry._1(xs, undefined);
    if (/* tag */ typeof match !== "object" && typeof match !== "function") {
      return true;
    }
    if (!Curry._1(p, match._0)) {
      return false;
    }
    _xs = match._1;
    continue;
  };
}

function exists(p, _xs) {
  while (true) {
    const xs = _xs;
    const match = Curry._1(xs, undefined);
    if (/* tag */ typeof match !== "object" && typeof match !== "function") {
      return false;
    }
    if (Curry._1(p, match._0)) {
      return true;
    }
    _xs = match._1;
    continue;
  };
}

function find(p, _xs) {
  while (true) {
    const xs = _xs;
    const match = Curry._1(xs, undefined);
    if (/* tag */ typeof match !== "object" && typeof match !== "function") {
      return;
    }
    const x = match._0;
    if (Curry._1(p, x)) {
      return Caml_option.some(x);
    }
    _xs = match._1;
    continue;
  };
}

function find_index(p, xs) {
  let _i = 0;
  let _xs = xs;
  while (true) {
    const xs$1 = _xs;
    const i = _i;
    const match = Curry._1(xs$1, undefined);
    if (/* tag */ typeof match !== "object" && typeof match !== "function") {
      return;
    }
    if (Curry._1(p, match._0)) {
      return i;
    }
    _xs = match._1;
    _i = i + 1 | 0;
    continue;
  };
}

function find_map(f, _xs) {
  while (true) {
    const xs = _xs;
    const match = Curry._1(xs, undefined);
    if (/* tag */ typeof match !== "object" && typeof match !== "function") {
      return;
    }
    const result = Curry._1(f, match._0);
    if (result !== undefined) {
      return result;
    }
    _xs = match._1;
    continue;
  };
}

function find_mapi(f, xs) {
  let _i = 0;
  let _xs = xs;
  while (true) {
    const xs$1 = _xs;
    const i = _i;
    const match = Curry._1(xs$1, undefined);
    if (/* tag */ typeof match !== "object" && typeof match !== "function") {
      return;
    }
    const result = Curry._2(f, i, match._0);
    if (result !== undefined) {
      return result;
    }
    _xs = match._1;
    _i = i + 1 | 0;
    continue;
  };
}

function iter2(f, _xs, _ys) {
  while (true) {
    const ys = _ys;
    const xs = _xs;
    const match = Curry._1(xs, undefined);
    if (/* tag */ typeof match !== "object" && typeof match !== "function") {
      return;
    }
    const match$1 = Curry._1(ys, undefined);
    if (/* tag */ typeof match$1 !== "object" && typeof match$1 !== "function") {
      return;
    }
    Curry._2(f, match._0, match$1._0);
    _ys = match$1._1;
    _xs = match._1;
    continue;
  };
}

function fold_left2(f, _accu, _xs, _ys) {
  while (true) {
    const ys = _ys;
    const xs = _xs;
    const accu = _accu;
    const match = Curry._1(xs, undefined);
    if (/* tag */ typeof match !== "object" && typeof match !== "function") {
      return accu;
    }
    const match$1 = Curry._1(ys, undefined);
    if (/* tag */ typeof match$1 !== "object" && typeof match$1 !== "function") {
      return accu;
    }
    const accu$1 = Curry._3(f, accu, match._0, match$1._0);
    _ys = match$1._1;
    _xs = match._1;
    _accu = accu$1;
    continue;
  };
}

function for_all2(f, _xs, _ys) {
  while (true) {
    const ys = _ys;
    const xs = _xs;
    const match = Curry._1(xs, undefined);
    if (/* tag */ typeof match !== "object" && typeof match !== "function") {
      return true;
    }
    const match$1 = Curry._1(ys, undefined);
    if (/* tag */ typeof match$1 !== "object" && typeof match$1 !== "function") {
      return true;
    }
    if (!Curry._2(f, match._0, match$1._0)) {
      return false;
    }
    _ys = match$1._1;
    _xs = match._1;
    continue;
  };
}

function exists2(f, _xs, _ys) {
  while (true) {
    const ys = _ys;
    const xs = _xs;
    const match = Curry._1(xs, undefined);
    if (/* tag */ typeof match !== "object" && typeof match !== "function") {
      return false;
    }
    const match$1 = Curry._1(ys, undefined);
    if (/* tag */ typeof match$1 !== "object" && typeof match$1 !== "function") {
      return false;
    }
    if (Curry._2(f, match._0, match$1._0)) {
      return true;
    }
    _ys = match$1._1;
    _xs = match._1;
    continue;
  };
}

function equal(eq, _xs, _ys) {
  while (true) {
    const ys = _ys;
    const xs = _xs;
    const match = Curry._1(xs, undefined);
    const match$1 = Curry._1(ys, undefined);
    if (/* tag */ typeof match !== "object" && typeof match !== "function") {
      if (/* tag */ typeof match$1 !== "object" && typeof match$1 !== "function") {
        return true;
      } else {
        return false;
      }
    }
    if (/* tag */ typeof match$1 !== "object" && typeof match$1 !== "function") {
      return false;
    }
    if (!Curry._2(eq, match._0, match$1._0)) {
      return false;
    }
    _ys = match$1._1;
    _xs = match._1;
    continue;
  };
}

function compare(cmp, _xs, _ys) {
  while (true) {
    const ys = _ys;
    const xs = _xs;
    const match = Curry._1(xs, undefined);
    const match$1 = Curry._1(ys, undefined);
    if (/* tag */ typeof match !== "object" && typeof match !== "function") {
      if (/* tag */ typeof match$1 !== "object" && typeof match$1 !== "function") {
        return 0;
      } else {
        return -1;
      }
    }
    if (/* tag */ typeof match$1 !== "object" && typeof match$1 !== "function") {
      return 1;
    }
    const c = Curry._2(cmp, match._0, match$1._0);
    if (c !== 0) {
      return c;
    }
    _ys = match$1._1;
    _xs = match._1;
    continue;
  };
}

function init_aux(f, i, j, param) {
  if (i >= j) {
    return /* Nil */ 0;
  }
  const partial_arg = i + 1 | 0;
  return {
    TAG: /* Cons */ 0,
    _0: Curry._1(f, i),
    _1: (function (param) {
      return init_aux(f, partial_arg, j, param);
    })
  };
}

function init(n, f) {
  if (n < 0) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Seq.init"
      });
  }
  return function (param) {
    return init_aux(f, 0, n, param);
  };
}

function repeat(x, param) {
  return {
    TAG: /* Cons */ 0,
    _0: x,
    _1: (function (param) {
      return repeat(x, param);
    })
  };
}

function forever(f, param) {
  return {
    TAG: /* Cons */ 0,
    _0: Curry._1(f, undefined),
    _1: (function (param) {
      return forever(f, param);
    })
  };
}

function cycle_nonempty(xs, param) {
  return append(xs, (function (param) {
    return cycle_nonempty(xs, param);
  }), undefined);
}

function cycle(xs, param) {
  const match = Curry._1(xs, undefined);
  if (/* tag */ typeof match !== "object" && typeof match !== "function") {
    return /* Nil */ 0;
  }
  const xs$p = match._1;
  return {
    TAG: /* Cons */ 0,
    _0: match._0,
    _1: (function (param) {
      return append(xs$p, (function (param) {
        return cycle_nonempty(xs, param);
      }), param);
    })
  };
}

function iterate1(f, x, param) {
  const y = Curry._1(f, x);
  return {
    TAG: /* Cons */ 0,
    _0: y,
    _1: (function (param) {
      return iterate1(f, y, param);
    })
  };
}

function iterate(f, x) {
  return function (param) {
    return {
      TAG: /* Cons */ 0,
      _0: x,
      _1: (function (param) {
        return iterate1(f, x, param);
      })
    };
  };
}

function mapi_aux(f, i, xs, param) {
  const match = Curry._1(xs, undefined);
  if (/* tag */ typeof match !== "object" && typeof match !== "function") {
    return /* Nil */ 0;
  }
  const xs$1 = match._1;
  const partial_arg = i + 1 | 0;
  return {
    TAG: /* Cons */ 0,
    _0: Curry._2(f, i, match._0),
    _1: (function (param) {
      return mapi_aux(f, partial_arg, xs$1, param);
    })
  };
}

function mapi(f, xs) {
  return function (param) {
    return mapi_aux(f, 0, xs, param);
  };
}

function tail_scan(f, s, xs, param) {
  const match = Curry._1(xs, undefined);
  if (/* tag */ typeof match !== "object" && typeof match !== "function") {
    return /* Nil */ 0;
  }
  const xs$1 = match._1;
  const s$1 = Curry._2(f, s, match._0);
  return {
    TAG: /* Cons */ 0,
    _0: s$1,
    _1: (function (param) {
      return tail_scan(f, s$1, xs$1, param);
    })
  };
}

function scan(f, s, xs) {
  return function (param) {
    return {
      TAG: /* Cons */ 0,
      _0: s,
      _1: (function (param) {
        return tail_scan(f, s, xs, param);
      })
    };
  };
}

function take_aux(n, xs) {
  if (n === 0) {
    return empty;
  } else {
    return function (param) {
      const match = Curry._1(xs, undefined);
      if (/* tag */ typeof match !== "object" && typeof match !== "function") {
        return /* Nil */ 0;
      } else {
        return {
          TAG: /* Cons */ 0,
          _0: match._0,
          _1: take_aux(n - 1 | 0, match._1)
        };
      }
    };
  }
}

function take(n, xs) {
  if (n < 0) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Seq.take"
      });
  }
  return take_aux(n, xs);
}

function drop(n, xs) {
  if (n < 0) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Seq.drop"
      });
  }
  if (n === 0) {
    return xs;
  } else {
    return function (param) {
      let _n = n;
      let _xs = xs;
      while (true) {
        const xs$1 = _xs;
        const n$1 = _n;
        const match = Curry._1(xs$1, undefined);
        if (/* tag */ typeof match !== "object" && typeof match !== "function") {
          return /* Nil */ 0;
        }
        const xs$2 = match._1;
        const n$2 = n$1 - 1 | 0;
        if (n$2 === 0) {
          return Curry._1(xs$2, undefined);
        }
        _xs = xs$2;
        _n = n$2;
        continue;
      };
    };
  }
}

function take_while(p, xs, param) {
  const match = Curry._1(xs, undefined);
  if (/* tag */ typeof match !== "object" && typeof match !== "function") {
    return /* Nil */ 0;
  }
  const xs$1 = match._1;
  const x = match._0;
  if (Curry._1(p, x)) {
    return {
      TAG: /* Cons */ 0,
      _0: x,
      _1: (function (param) {
        return take_while(p, xs$1, param);
      })
    };
  } else {
    return /* Nil */ 0;
  }
}

function drop_while(p, _xs, _param) {
  while (true) {
    const xs = _xs;
    const node = Curry._1(xs, undefined);
    if (/* tag */ typeof node !== "object" && typeof node !== "function") {
      return /* Nil */ 0;
    }
    if (!Curry._1(p, node._0)) {
      return node;
    }
    _param = undefined;
    _xs = node._1;
    continue;
  };
}

function group(eq, xs, param) {
  const match = Curry._1(xs, undefined);
  if (/* tag */ typeof match !== "object" && typeof match !== "function") {
    return /* Nil */ 0;
  }
  const xs$1 = match._1;
  const x = match._0;
  const partial_arg = Curry._1(eq, x);
  const partial_arg$1 = function (param) {
    return take_while(partial_arg, xs$1, param);
  };
  const partial_arg$2 = Curry._1(eq, x);
  const partial_arg$3 = function (param) {
    return drop_while(partial_arg$2, xs$1, param);
  };
  return {
    TAG: /* Cons */ 0,
    _0: (function (param) {
      return {
        TAG: /* Cons */ 0,
        _0: x,
        _1: partial_arg$1
      };
    }),
    _1: (function (param) {
      return group(eq, partial_arg$3, param);
    })
  };
}

const Forced_twice = /* @__PURE__ */ Caml_exceptions.create("Stdlib.Seq.Forced_twice");

function failure(param) {
  throw new Caml_js_exceptions.MelangeError(Forced_twice, {
      MEL_EXN_ID: Forced_twice
    });
}

function memoize(xs) {
  const partial_arg = {
    LAZY_DONE: false,
    VAL: (function () {
      const match = Curry._1(xs, undefined);
      if (/* tag */ typeof match !== "object" && typeof match !== "function") {
        return /* Nil */ 0;
      } else {
        return {
          TAG: /* Cons */ 0,
          _0: match._0,
          _1: memoize(match._1)
        };
      }
    })
  };
  return function (param) {
    return CamlinternalLazy.force(partial_arg);
  };
}

function once(xs) {
  let f = function (param) {
    const match = Curry._1(xs, undefined);
    if (/* tag */ typeof match !== "object" && typeof match !== "function") {
      return /* Nil */ 0;
    } else {
      return {
        TAG: /* Cons */ 0,
        _0: match._0,
        _1: once(match._1)
      };
    }
  };
  const action = Stdlib__Atomic.make(f);
  return function (param) {
    const f = Stdlib__Atomic.exchange(action, failure);
    return Curry._1(f, undefined);
  };
}

function zip(xs, ys, param) {
  const match = Curry._1(xs, undefined);
  if (/* tag */ typeof match !== "object" && typeof match !== "function") {
    return /* Nil */ 0;
  }
  const xs$1 = match._1;
  const match$1 = Curry._1(ys, undefined);
  if (/* tag */ typeof match$1 !== "object" && typeof match$1 !== "function") {
    return /* Nil */ 0;
  }
  const ys$1 = match$1._1;
  return {
    TAG: /* Cons */ 0,
    _0: [
      match._0,
      match$1._0
    ],
    _1: (function (param) {
      return zip(xs$1, ys$1, param);
    })
  };
}

function map2(f, xs, ys, param) {
  const match = Curry._1(xs, undefined);
  if (/* tag */ typeof match !== "object" && typeof match !== "function") {
    return /* Nil */ 0;
  }
  const xs$1 = match._1;
  const match$1 = Curry._1(ys, undefined);
  if (/* tag */ typeof match$1 !== "object" && typeof match$1 !== "function") {
    return /* Nil */ 0;
  }
  const ys$1 = match$1._1;
  return {
    TAG: /* Cons */ 0,
    _0: Curry._2(f, match._0, match$1._0),
    _1: (function (param) {
      return map2(f, xs$1, ys$1, param);
    })
  };
}

function interleave(xs, ys, param) {
  const match = Curry._1(xs, undefined);
  if (/* tag */ typeof match !== "object" && typeof match !== "function") {
    return Curry._1(ys, undefined);
  }
  const xs$1 = match._1;
  return {
    TAG: /* Cons */ 0,
    _0: match._0,
    _1: (function (param) {
      return interleave(ys, xs$1, param);
    })
  };
}

function sorted_merge1(cmp, x, xs, y, ys) {
  if (Curry._2(cmp, x, y) <= 0) {
    return {
      TAG: /* Cons */ 0,
      _0: x,
      _1: (function (param) {
        const match = Curry._1(xs, undefined);
        if (/* tag */ typeof match !== "object" && typeof match !== "function") {
          return {
            TAG: /* Cons */ 0,
            _0: y,
            _1: ys
          };
        } else {
          return sorted_merge1(cmp, match._0, match._1, y, ys);
        }
      })
    };
  } else {
    return {
      TAG: /* Cons */ 0,
      _0: y,
      _1: (function (param) {
        const match = Curry._1(ys, undefined);
        if (/* tag */ typeof match !== "object" && typeof match !== "function") {
          return {
            TAG: /* Cons */ 0,
            _0: x,
            _1: xs
          };
        } else {
          return sorted_merge1(cmp, x, xs, match._0, match._1);
        }
      })
    };
  }
}

function sorted_merge(cmp, xs, ys, param) {
  const match = Curry._1(xs, undefined);
  const match$1 = Curry._1(ys, undefined);
  if (/* tag */ typeof match !== "object" && typeof match !== "function") {
    if (/* tag */ typeof match$1 !== "object" && typeof match$1 !== "function") {
      return /* Nil */ 0;
    } else {
      return match$1;
    }
  } else if (/* tag */ typeof match$1 !== "object" && typeof match$1 !== "function") {
    return match;
  } else {
    return sorted_merge1(cmp, match._0, match._1, match$1._0, match$1._1);
  }
}

function map_fst(xys, param) {
  const match = Curry._1(xys, undefined);
  if (/* tag */ typeof match !== "object" && typeof match !== "function") {
    return /* Nil */ 0;
  }
  const xys$1 = match._1;
  return {
    TAG: /* Cons */ 0,
    _0: match._0[0],
    _1: (function (param) {
      return map_fst(xys$1, param);
    })
  };
}

function map_snd(xys, param) {
  const match = Curry._1(xys, undefined);
  if (/* tag */ typeof match !== "object" && typeof match !== "function") {
    return /* Nil */ 0;
  }
  const xys$1 = match._1;
  return {
    TAG: /* Cons */ 0,
    _0: match._0[1],
    _1: (function (param) {
      return map_snd(xys$1, param);
    })
  };
}

function unzip(xys) {
  return [
    (function (param) {
      return map_fst(xys, param);
    }),
    (function (param) {
      return map_snd(xys, param);
    })
  ];
}

function filter_map_find_left_map(f, _xs, _param) {
  while (true) {
    const xs = _xs;
    const match = Curry._1(xs, undefined);
    if (/* tag */ typeof match !== "object" && typeof match !== "function") {
      return /* Nil */ 0;
    }
    const xs$1 = match._1;
    const y = Curry._1(f, match._0);
    if (y.TAG === /* Left */ 0) {
      return {
        TAG: /* Cons */ 0,
        _0: y._0,
        _1: (function (param) {
          return filter_map_find_left_map(f, xs$1, param);
        })
      };
    }
    _param = undefined;
    _xs = xs$1;
    continue;
  };
}

function filter_map_find_right_map(f, _xs, _param) {
  while (true) {
    const xs = _xs;
    const match = Curry._1(xs, undefined);
    if (/* tag */ typeof match !== "object" && typeof match !== "function") {
      return /* Nil */ 0;
    }
    const xs$1 = match._1;
    const z = Curry._1(f, match._0);
    if (z.TAG !== /* Left */ 0) {
      return {
        TAG: /* Cons */ 0,
        _0: z._0,
        _1: (function (param) {
          return filter_map_find_right_map(f, xs$1, param);
        })
      };
    }
    _param = undefined;
    _xs = xs$1;
    continue;
  };
}

function partition_map(f, xs) {
  return [
    (function (param) {
      return filter_map_find_left_map(f, xs, param);
    }),
    (function (param) {
      return filter_map_find_right_map(f, xs, param);
    })
  ];
}

function partition(p, xs) {
  return [
    (function (param) {
      return filter(p, xs, param);
    }),
    (function (param) {
      return filter((function (x) {
        return !Curry._1(p, x);
      }), xs, param);
    })
  ];
}

function transpose(xss, param) {
  const match = unzip(function (param) {
    return filter_map(uncons, xss, param);
  });
  const tails = match[1];
  const heads = match[0];
  if (!is_empty(heads)) {
    return {
      TAG: /* Cons */ 0,
      _0: heads,
      _1: (function (param) {
        return transpose(tails, param);
      })
    };
  }
  if (!is_empty(tails)) {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "jscomp/stdlib/seq.ml",
          629,
          4
        ]
      });
  }
  return /* Nil */ 0;
}

function diagonals(remainders, xss, param) {
  const match = Curry._1(xss, undefined);
  if (/* tag */ typeof match !== "object" && typeof match !== "function") {
    return transpose(remainders, undefined);
  }
  const xss$1 = match._1;
  const match$1 = Curry._1(match._0, undefined);
  if (/* tag */ typeof match$1 !== "object" && typeof match$1 !== "function") {
    const match$2 = unzip(function (param) {
      return filter_map(uncons, remainders, param);
    });
    const tails = match$2[1];
    return {
      TAG: /* Cons */ 0,
      _0: match$2[0],
      _1: (function (param) {
        return diagonals(tails, xss$1, param);
      })
    };
  }
  const xs = match$1._1;
  const x = match$1._0;
  const match$3 = unzip(function (param) {
    return filter_map(uncons, remainders, param);
  });
  const tails$1 = match$3[1];
  const heads = match$3[0];
  return {
    TAG: /* Cons */ 0,
    _0: (function (param) {
      return {
        TAG: /* Cons */ 0,
        _0: x,
        _1: heads
      };
    }),
    _1: (function (param) {
      return diagonals((function (param) {
        return {
          TAG: /* Cons */ 0,
          _0: xs,
          _1: tails$1
        };
      }), xss$1, param);
    })
  };
}

function map_product(f, xs, ys) {
  return function (param) {
    return concat((function (param) {
      return diagonals(empty, (function (param) {
        return map((function (x) {
          return function (param) {
            return map((function (y) {
              return Curry._2(f, x, y);
            }), ys, param);
          };
        }), xs, param);
      }), param);
    }), param);
  };
}

function product(xs, ys) {
  return map_product((function (x, y) {
    return [
      x,
      y
    ];
  }), xs, ys);
}

function of_dispenser(it) {
  const c = function (param) {
    const x = Curry._1(it, undefined);
    if (x !== undefined) {
      return {
        TAG: /* Cons */ 0,
        _0: Caml_option.valFromOption(x),
        _1: c
      };
    } else {
      return /* Nil */ 0;
    }
  };
  return c;
}

function to_dispenser(xs) {
  const s = {
    contents: xs
  };
  return function (param) {
    const match = Curry._1(s.contents, undefined);
    if (/* tag */ typeof match !== "object" && typeof match !== "function") {
      return;
    }
    s.contents = match._1;
    return Caml_option.some(match._0);
  };
}

function ints(i, param) {
  const partial_arg = i + 1 | 0;
  return {
    TAG: /* Cons */ 0,
    _0: i,
    _1: (function (param) {
      return ints(partial_arg, param);
    })
  };
}

const concat_map = flat_map;

const split = unzip;

module.exports = {
  is_empty,
  uncons,
  length,
  iter,
  fold_left,
  iteri,
  fold_lefti,
  for_all,
  exists,
  find,
  find_index,
  find_map,
  find_mapi,
  iter2,
  fold_left2,
  for_all2,
  exists2,
  equal,
  compare,
  empty,
  $$return,
  cons,
  singleton,
  init,
  unfold,
  repeat,
  forever,
  cycle,
  iterate,
  map,
  mapi,
  filter,
  filteri,
  filter_map,
  scan,
  take,
  drop,
  take_while,
  drop_while,
  group,
  memoize,
  Forced_twice,
  once,
  transpose,
  append,
  concat,
  flat_map,
  concat_map,
  zip,
  map2,
  interleave,
  sorted_merge,
  product,
  map_product,
  unzip,
  split,
  partition_map,
  partition,
  of_dispenser,
  to_dispenser,
  ints,
}
/* No side effect */
