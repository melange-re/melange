// Generated by Melange

import * as Caml from "melange.js/caml.mjs";
import * as Caml_array from "melange.js/caml_array.mjs";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.mjs";
import * as Caml_obj from "melange.js/caml_obj.mjs";
import * as Caml_oo from "melange.js/caml_oo.mjs";
import * as Caml_string from "melange.js/caml_string.mjs";
import * as Curry from "melange.js/curry.mjs";
import * as Stdlib from "./stdlib.mjs";
import * as Stdlib__Array from "./array.mjs";
import * as Stdlib__Atomic from "./atomic.mjs";
import * as Stdlib__List from "./list.mjs";

const new_object_tag_block = (function(size){
  var v = new Array(size)
  v.TAG = 248 // tag
  return v
}
);

function copy(o) {
  return Caml_oo.caml_set_oo_id(Caml_obj.caml_obj_dup(o));
}

const params = {
  compact_table: true,
  copy_parent: true,
  clean_when_copying: true,
  retry_count: 3,
  bucket_small_size: 16
};

function public_method_label(s) {
  let accu = 0;
  for (let i = 0, i_finish = s.length; i < i_finish; ++i) {
    accu = Math.imul(223, accu) + Caml_string.get(s, i) | 0;
  }
  accu = accu & 2147483647;
  if (accu > 1073741823) {
    return accu - -2147483648 | 0;
  } else {
    return accu;
  }
}

const compare = Caml.caml_string_compare;

const funarg = {
  compare: compare
};

function height(param) {
  if (/* tag */ typeof param !== "object" && typeof param !== "function") {
    return 0;
  } else {
    return param.h;
  }
}

function create(l, x, d, r) {
  const hl = height(l);
  const hr = height(r);
  return {
    TAG: /* Node */ 0,
    l: l,
    v: x,
    d: d,
    r: r,
    h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
  };
}

function bal(l, x, d, r) {
  let hl;
  hl = /* tag */ typeof l !== "object" && typeof l !== "function" ? 0 : l.h;
  let hr;
  hr = /* tag */ typeof r !== "object" && typeof r !== "function" ? 0 : r.h;
  if (hl > (hr + 2 | 0)) {
    if (/* tag */ typeof l !== "object" && typeof l !== "function") {
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Map.bal"
        });
    }
    const lr = l.r;
    const ld = l.d;
    const lv = l.v;
    const ll = l.l;
    if (height(ll) >= height(lr)) {
      return create(ll, lv, ld, create(lr, x, d, r));
    }
    if (!/* tag */ (typeof lr !== "object" && typeof lr !== "function")) {
      return create(create(ll, lv, ld, lr.l), lr.v, lr.d, create(lr.r, x, d, r));
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Map.bal"
      });
  }
  if (hr <= (hl + 2 | 0)) {
    return {
      TAG: /* Node */ 0,
      l: l,
      v: x,
      d: d,
      r: r,
      h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
    };
  }
  if (/* tag */ typeof r !== "object" && typeof r !== "function") {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Map.bal"
      });
  }
  const rr = r.r;
  const rd = r.d;
  const rv = r.v;
  const rl = r.l;
  if (height(rr) >= height(rl)) {
    return create(create(l, x, d, rl), rv, rd, rr);
  }
  if (!/* tag */ (typeof rl !== "object" && typeof rl !== "function")) {
    return create(create(l, x, d, rl.l), rl.v, rl.d, create(rl.r, rv, rd, rr));
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "Map.bal"
    });
}

function add(x, data, m) {
  if (/* tag */ typeof m !== "object" && typeof m !== "function") {
    return {
      TAG: /* Node */ 0,
      l: /* Empty */ 0,
      v: x,
      d: data,
      r: /* Empty */ 0,
      h: 1
    };
  }
  const r = m.r;
  const d = m.d;
  const v = m.v;
  const l = m.l;
  const c = Curry._2(funarg.compare, x, v);
  if (c === 0) {
    if (d === data) {
      return m;
    } else {
      return {
        TAG: /* Node */ 0,
        l: l,
        v: x,
        d: data,
        r: r,
        h: m.h
      };
    }
  }
  if (c < 0) {
    const ll = add(x, data, l);
    if (l === ll) {
      return m;
    } else {
      return bal(ll, v, d, r);
    }
  }
  const rr = add(x, data, r);
  if (r === rr) {
    return m;
  } else {
    return bal(l, v, d, rr);
  }
}

function find(x, _param) {
  while (true) {
    const param = _param;
    if (/* tag */ typeof param !== "object" && typeof param !== "function") {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
          MEL_EXN_ID: Stdlib.Not_found
        });
    }
    const c = Curry._2(funarg.compare, x, param.v);
    if (c === 0) {
      return param.d;
    }
    _param = c < 0 ? param.l : param.r;
    continue;
  };
}

function fold(f, _m, _accu) {
  while (true) {
    const accu = _accu;
    const m = _m;
    if (/* tag */ typeof m !== "object" && typeof m !== "function") {
      return accu;
    }
    _accu = Curry._3(f, m.v, m.d, fold(f, m.l, accu));
    _m = m.r;
    continue;
  };
}

const compare$1 = Caml.caml_string_compare;

const funarg$1 = {
  compare: compare$1
};

function height$1(param) {
  if (/* tag */ typeof param !== "object" && typeof param !== "function") {
    return 0;
  } else {
    return param.h;
  }
}

function create$1(l, x, d, r) {
  const hl = height$1(l);
  const hr = height$1(r);
  return {
    TAG: /* Node */ 0,
    l: l,
    v: x,
    d: d,
    r: r,
    h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
  };
}

function bal$1(l, x, d, r) {
  let hl;
  hl = /* tag */ typeof l !== "object" && typeof l !== "function" ? 0 : l.h;
  let hr;
  hr = /* tag */ typeof r !== "object" && typeof r !== "function" ? 0 : r.h;
  if (hl > (hr + 2 | 0)) {
    if (/* tag */ typeof l !== "object" && typeof l !== "function") {
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Map.bal"
        });
    }
    const lr = l.r;
    const ld = l.d;
    const lv = l.v;
    const ll = l.l;
    if (height$1(ll) >= height$1(lr)) {
      return create$1(ll, lv, ld, create$1(lr, x, d, r));
    }
    if (!/* tag */ (typeof lr !== "object" && typeof lr !== "function")) {
      return create$1(create$1(ll, lv, ld, lr.l), lr.v, lr.d, create$1(lr.r, x, d, r));
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Map.bal"
      });
  }
  if (hr <= (hl + 2 | 0)) {
    return {
      TAG: /* Node */ 0,
      l: l,
      v: x,
      d: d,
      r: r,
      h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
    };
  }
  if (/* tag */ typeof r !== "object" && typeof r !== "function") {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Map.bal"
      });
  }
  const rr = r.r;
  const rd = r.d;
  const rv = r.v;
  const rl = r.l;
  if (height$1(rr) >= height$1(rl)) {
    return create$1(create$1(l, x, d, rl), rv, rd, rr);
  }
  if (!/* tag */ (typeof rl !== "object" && typeof rl !== "function")) {
    return create$1(create$1(l, x, d, rl.l), rl.v, rl.d, create$1(rl.r, rv, rd, rr));
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "Map.bal"
    });
}

function add$1(x, data, m) {
  if (/* tag */ typeof m !== "object" && typeof m !== "function") {
    return {
      TAG: /* Node */ 0,
      l: /* Empty */ 0,
      v: x,
      d: data,
      r: /* Empty */ 0,
      h: 1
    };
  }
  const r = m.r;
  const d = m.d;
  const v = m.v;
  const l = m.l;
  const c = Curry._2(funarg$1.compare, x, v);
  if (c === 0) {
    if (d === data) {
      return m;
    } else {
      return {
        TAG: /* Node */ 0,
        l: l,
        v: x,
        d: data,
        r: r,
        h: m.h
      };
    }
  }
  if (c < 0) {
    const ll = add$1(x, data, l);
    if (l === ll) {
      return m;
    } else {
      return bal$1(ll, v, d, r);
    }
  }
  const rr = add$1(x, data, r);
  if (r === rr) {
    return m;
  } else {
    return bal$1(l, v, d, rr);
  }
}

function find$1(x, _param) {
  while (true) {
    const param = _param;
    if (/* tag */ typeof param !== "object" && typeof param !== "function") {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
          MEL_EXN_ID: Stdlib.Not_found
        });
    }
    const c = Curry._2(funarg$1.compare, x, param.v);
    if (c === 0) {
      return param.d;
    }
    _param = c < 0 ? param.l : param.r;
    continue;
  };
}

const compare$2 = Caml.caml_int_compare;

const funarg$2 = {
  compare: compare$2
};

function height$2(param) {
  if (/* tag */ typeof param !== "object" && typeof param !== "function") {
    return 0;
  } else {
    return param.h;
  }
}

function create$2(l, x, d, r) {
  const hl = height$2(l);
  const hr = height$2(r);
  return {
    TAG: /* Node */ 0,
    l: l,
    v: x,
    d: d,
    r: r,
    h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
  };
}

function bal$2(l, x, d, r) {
  let hl;
  hl = /* tag */ typeof l !== "object" && typeof l !== "function" ? 0 : l.h;
  let hr;
  hr = /* tag */ typeof r !== "object" && typeof r !== "function" ? 0 : r.h;
  if (hl > (hr + 2 | 0)) {
    if (/* tag */ typeof l !== "object" && typeof l !== "function") {
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Map.bal"
        });
    }
    const lr = l.r;
    const ld = l.d;
    const lv = l.v;
    const ll = l.l;
    if (height$2(ll) >= height$2(lr)) {
      return create$2(ll, lv, ld, create$2(lr, x, d, r));
    }
    if (!/* tag */ (typeof lr !== "object" && typeof lr !== "function")) {
      return create$2(create$2(ll, lv, ld, lr.l), lr.v, lr.d, create$2(lr.r, x, d, r));
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Map.bal"
      });
  }
  if (hr <= (hl + 2 | 0)) {
    return {
      TAG: /* Node */ 0,
      l: l,
      v: x,
      d: d,
      r: r,
      h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
    };
  }
  if (/* tag */ typeof r !== "object" && typeof r !== "function") {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Map.bal"
      });
  }
  const rr = r.r;
  const rd = r.d;
  const rv = r.v;
  const rl = r.l;
  if (height$2(rr) >= height$2(rl)) {
    return create$2(create$2(l, x, d, rl), rv, rd, rr);
  }
  if (!/* tag */ (typeof rl !== "object" && typeof rl !== "function")) {
    return create$2(create$2(l, x, d, rl.l), rl.v, rl.d, create$2(rl.r, rv, rd, rr));
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "Map.bal"
    });
}

function add$2(x, data, m) {
  if (/* tag */ typeof m !== "object" && typeof m !== "function") {
    return {
      TAG: /* Node */ 0,
      l: /* Empty */ 0,
      v: x,
      d: data,
      r: /* Empty */ 0,
      h: 1
    };
  }
  const r = m.r;
  const d = m.d;
  const v = m.v;
  const l = m.l;
  const c = Curry._2(funarg$2.compare, x, v);
  if (c === 0) {
    if (d === data) {
      return m;
    } else {
      return {
        TAG: /* Node */ 0,
        l: l,
        v: x,
        d: data,
        r: r,
        h: m.h
      };
    }
  }
  if (c < 0) {
    const ll = add$2(x, data, l);
    if (l === ll) {
      return m;
    } else {
      return bal$2(ll, v, d, r);
    }
  }
  const rr = add$2(x, data, r);
  if (r === rr) {
    return m;
  } else {
    return bal$2(l, v, d, rr);
  }
}

function find$2(x, _param) {
  while (true) {
    const param = _param;
    if (/* tag */ typeof param !== "object" && typeof param !== "function") {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
          MEL_EXN_ID: Stdlib.Not_found
        });
    }
    const c = Curry._2(funarg$2.compare, x, param.v);
    if (c === 0) {
      return param.d;
    }
    _param = c < 0 ? param.l : param.r;
    continue;
  };
}

const dummy_table = {
  size: 0,
  methods: [undefined],
  methods_by_name: /* Empty */ 0,
  methods_by_label: /* Empty */ 0,
  previous_states: /* [] */ 0,
  hidden_meths: /* [] */ 0,
  vars: /* Empty */ 0,
  initializers: /* [] */ 0
};

const table_count = Stdlib__Atomic.make(0);

function fit_size(n) {
  if (n <= 2) {
    return n;
  } else {
    return (fit_size((n + 1 | 0) / 2 | 0) << 1);
  }
}

function new_table(pub_labels) {
  Stdlib__Atomic.incr(table_count);
  const len = pub_labels.length;
  const methods = Caml_array.make((len << 1) + 2 | 0, /* DummyA */ 0);
  Caml_array.set(methods, 0, len);
  Caml_array.set(methods, 1, ((fit_size(len) << 5) / 8 | 0) - 1 | 0);
  for (let i = 0; i < len; ++i) {
    Caml_array.set(methods, (i << 1) + 3 | 0, Caml_array.get(pub_labels, i));
  }
  return {
    size: 2,
    methods: methods,
    methods_by_name: /* Empty */ 0,
    methods_by_label: /* Empty */ 0,
    previous_states: /* [] */ 0,
    hidden_meths: /* [] */ 0,
    vars: /* Empty */ 0,
    initializers: /* [] */ 0
  };
}

function resize(array, new_size) {
  const old_size = array.methods.length;
  if (new_size <= old_size) {
    return;
  }
  const new_buck = Caml_array.make(new_size, /* DummyA */ 0);
  Stdlib__Array.blit(array.methods, 0, new_buck, 0, old_size);
  array.methods = new_buck;
}

const method_count = Stdlib__Atomic.make(0);

const inst_var_count = Stdlib__Atomic.make(0);

function new_method(table) {
  const index = table.methods.length;
  resize(table, index + 1 | 0);
  return index;
}

function get_method_label(table, name) {
  try {
    return Curry._2(find$1, name, table.methods_by_name);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      const label = new_method(table);
      table.methods_by_name = Curry._3(add$1, name, label, table.methods_by_name);
      table.methods_by_label = Curry._3(add$2, label, true, table.methods_by_label);
      return label;
    }
    throw exn;
  }
}

function get_method_labels(table, names) {
  return Stdlib__Array.map((function (param) {
    return get_method_label(table, param);
  }), names);
}

function set_method(table, label, element) {
  Stdlib__Atomic.incr(method_count);
  if (Curry._2(find$2, label, table.methods_by_label)) {
    resize(table, label + 1 | 0);
    return Caml_array.set(table.methods, label, element);
  } else {
    table.hidden_meths = {
      hd: [
        label,
        element
      ],
      tl: table.hidden_meths
    };
    return;
  }
}

function get_method(table, label) {
  try {
    return Stdlib__List.assoc(label, table.hidden_meths);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return Caml_array.get(table.methods, label);
    }
    throw exn;
  }
}

function to_list(arr) {
  if (arr === 0) {
    return /* [] */ 0;
  } else {
    return Stdlib__Array.to_list(arr);
  }
}

function narrow(table, vars, virt_meths, concr_meths) {
  const vars$1 = to_list(vars);
  const virt_meths$1 = to_list(virt_meths);
  const concr_meths$1 = to_list(concr_meths);
  const virt_meth_labs = Stdlib__List.map((function (param) {
    return get_method_label(table, param);
  }), virt_meths$1);
  const concr_meth_labs = Stdlib__List.map((function (param) {
    return get_method_label(table, param);
  }), concr_meths$1);
  table.previous_states = {
    hd: [
      table.methods_by_name,
      table.methods_by_label,
      table.hidden_meths,
      table.vars,
      virt_meth_labs,
      vars$1
    ],
    tl: table.previous_states
  };
  table.vars = Curry._3(fold, (function (lab, info, tvars) {
    if (Stdlib__List.mem(lab, vars$1)) {
      return Curry._3(add, lab, info, tvars);
    } else {
      return tvars;
    }
  }), table.vars, /* Empty */ 0);
  const by_name = {
    contents: /* Empty */ 0
  };
  const by_label = {
    contents: /* Empty */ 0
  };
  Stdlib__List.iter2((function (met, label) {
    by_name.contents = Curry._3(add$1, met, label, by_name.contents);
    let tmp;
    try {
      tmp = Curry._2(find$2, label, table.methods_by_label);
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        tmp = true;
      } else {
        throw exn;
      }
    }
    by_label.contents = Curry._3(add$2, label, tmp, by_label.contents);
  }), concr_meths$1, concr_meth_labs);
  Stdlib__List.iter2((function (met, label) {
    by_name.contents = Curry._3(add$1, met, label, by_name.contents);
    by_label.contents = Curry._3(add$2, label, false, by_label.contents);
  }), virt_meths$1, virt_meth_labs);
  table.methods_by_name = by_name.contents;
  table.methods_by_label = by_label.contents;
  table.hidden_meths = Stdlib__List.fold_right((function (met, hm) {
    if (Stdlib__List.mem(met[0], virt_meth_labs)) {
      return hm;
    } else {
      return {
        hd: met,
        tl: hm
      };
    }
  }), table.hidden_meths, /* [] */ 0);
}

function widen(table) {
  const match = Stdlib__List.hd(table.previous_states);
  const virt_meths = match[4];
  table.previous_states = Stdlib__List.tl(table.previous_states);
  table.vars = Stdlib__List.fold_left((function (s, v) {
    return Curry._3(add, v, Curry._2(find, v, table.vars), s);
  }), match[3], match[5]);
  table.methods_by_name = match[0];
  table.methods_by_label = match[1];
  table.hidden_meths = Stdlib__List.fold_right((function (met, hm) {
    if (Stdlib__List.mem(met[0], virt_meths)) {
      return hm;
    } else {
      return {
        hd: met,
        tl: hm
      };
    }
  }), table.hidden_meths, match[2]);
}

function new_slot(table) {
  const index = table.size;
  table.size = index + 1 | 0;
  return index;
}

function new_variable(table, name) {
  try {
    return Curry._2(find, name, table.vars);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      const index = new_slot(table);
      if (name !== "") {
        table.vars = Curry._3(add, name, index, table.vars);
      }
      return index;
    }
    throw exn;
  }
}

function to_array(arr) {
  if (Caml_obj.caml_equal(arr, 0)) {
    return [];
  } else {
    return arr;
  }
}

function new_methods_variables(table, meths, vals) {
  const meths$1 = to_array(meths);
  const nmeths = meths$1.length;
  const nvals = vals.length;
  const res = Caml_array.make(nmeths + nvals | 0, 0);
  for (let i = 0; i < nmeths; ++i) {
    Caml_array.set(res, i, get_method_label(table, Caml_array.get(meths$1, i)));
  }
  for (let i$1 = 0; i$1 < nvals; ++i$1) {
    Caml_array.set(res, i$1 + nmeths | 0, new_variable(table, Caml_array.get(vals, i$1)));
  }
  return res;
}

function get_variable(table, name) {
  try {
    return Curry._2(find, name, table.vars);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "camlinternalOO.cppo.ml",
            295,
            50
          ]
        });
    }
    throw exn;
  }
}

function get_variables(table, names) {
  return Stdlib__Array.map((function (param) {
    return get_variable(table, param);
  }), names);
}

function add_initializer(table, f) {
  table.initializers = {
    hd: f,
    tl: table.initializers
  };
}

function create_table(public_methods) {
  if (public_methods === 0) {
    return new_table([]);
  }
  const tags = Stdlib__Array.map(public_method_label, public_methods);
  const table = new_table(tags);
  Stdlib__Array.iteri((function (i, met) {
    const lab = (i << 1) + 2 | 0;
    table.methods_by_name = Curry._3(add$1, met, lab, table.methods_by_name);
    table.methods_by_label = Curry._3(add$2, lab, true, table.methods_by_label);
  }), public_methods);
  return table;
}

function init_class(table) {
  Stdlib__Atomic.fetch_and_add(inst_var_count, table.size - 1 | 0);
  table.initializers = Stdlib__List.rev(table.initializers);
  resize(table, 3 + ((Caml_array.get(table.methods, 1) << 4) / 32 | 0) | 0);
}

function inherits(cla, vals, virt_meths, concr_meths, param, top) {
  const $$super = param[1];
  narrow(cla, vals, virt_meths, concr_meths);
  const init = top ? Curry._2($$super, cla, param[2]) : Curry._1($$super, cla);
  widen(cla);
  return Caml_array.concat({
    hd: [init],
    tl: {
      hd: Stdlib__Array.map((function (param) {
        return get_variable(cla, param);
      }), to_array(vals)),
      tl: {
        hd: Stdlib__Array.map((function (nm) {
          return get_method(cla, get_method_label(cla, nm));
        }), to_array(concr_meths)),
        tl: /* [] */ 0
      }
    }
  });
}

function make_class(pub_meths, class_init) {
  const table = create_table(pub_meths);
  const env_init = Curry._1(class_init, table);
  init_class(table);
  return [
    Curry._1(env_init, 0),
    class_init,
    0
  ];
}

function make_class_store(pub_meths, class_init, init_table) {
  const table = create_table(pub_meths);
  const env_init = Curry._1(class_init, table);
  init_class(table);
  init_table.class_init = class_init;
  init_table.env_init = env_init;
}

function create_object(table) {
  const obj = new_object_tag_block(table.size);
  obj[0] = table.methods;
  return Caml_oo.caml_set_oo_id(obj);
}

function create_object_opt(obj_0, table) {
  if (obj_0) {
    return obj_0;
  }
  const obj = new_object_tag_block(table.size);
  obj[0] = table.methods;
  return Caml_oo.caml_set_oo_id(obj);
}

function iter_f(obj, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return;
    }
    Curry._1(param.hd, obj);
    _param = param.tl;
    continue;
  };
}

function run_initializers(obj, table) {
  const inits = table.initializers;
  if (Caml_obj.caml_notequal(inits, /* [] */ 0)) {
    return iter_f(obj, inits);
  }
  
}

function run_initializers_opt(obj_0, obj, table) {
  if (obj_0) {
    return obj;
  }
  const inits = table.initializers;
  if (Caml_obj.caml_notequal(inits, /* [] */ 0)) {
    iter_f(obj, inits);
  }
  return obj;
}

function create_object_and_run_initializers(obj_0, table) {
  if (obj_0) {
    return obj_0;
  }
  const obj = create_object(table);
  run_initializers(obj, table);
  return obj;
}

function set_data(tables, v) {
  if (!/* tag */ (typeof tables !== "object" && typeof tables !== "function")) {
    tables.data = v;
    return;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
      MEL_EXN_ID: "Assert_failure",
      _1: [
        "camlinternalOO.cppo.ml",
        439,
        13
      ]
    });
}

function set_next(tables, v) {
  if (!/* tag */ (typeof tables !== "object" && typeof tables !== "function")) {
    tables.next = v;
    return;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
      MEL_EXN_ID: "Assert_failure",
      _1: [
        "camlinternalOO.cppo.ml",
        442,
        13
      ]
    });
}

function get_key(tables) {
  if (!/* tag */ (typeof tables !== "object" && typeof tables !== "function")) {
    return tables.key;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
      MEL_EXN_ID: "Assert_failure",
      _1: [
        "camlinternalOO.cppo.ml",
        445,
        13
      ]
    });
}

function get_data(tables) {
  if (!/* tag */ (typeof tables !== "object" && typeof tables !== "function")) {
    return tables.data;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
      MEL_EXN_ID: "Assert_failure",
      _1: [
        "camlinternalOO.cppo.ml",
        448,
        13
      ]
    });
}

function get_next(tables) {
  if (!/* tag */ (typeof tables !== "object" && typeof tables !== "function")) {
    return tables.next;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
      MEL_EXN_ID: "Assert_failure",
      _1: [
        "camlinternalOO.cppo.ml",
        451,
        13
      ]
    });
}

function build_path(n, keys, tables) {
  const res = {
    TAG: /* Cons */ 0,
    key: 0,
    data: /* Empty */ 0,
    next: /* Empty */ 0
  };
  let r = res;
  for (let i = 0; i <= n; ++i) {
    r = {
      TAG: /* Cons */ 0,
      key: Caml_array.get(keys, i),
      data: r,
      next: /* Empty */ 0
    };
  }
  set_data(tables, r);
  return res;
}

function lookup_keys(i, keys, tables) {
  if (i < 0) {
    return tables;
  }
  const key = Caml_array.get(keys, i);
  let _tables = tables;
  while (true) {
    const tables$1 = _tables;
    if (get_key(tables$1) === key) {
      const tables_data = get_data(tables$1);
      if (!/* tag */ (typeof tables_data !== "object" && typeof tables_data !== "function")) {
        return lookup_keys(i - 1 | 0, keys, tables_data);
      }
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "camlinternalOO.cppo.ml",
            469,
            17
          ]
        });
    }
    const next = get_next(tables$1);
    if (/* tag */ typeof next !== "object" && typeof next !== "function") {
      const next$1 = {
        TAG: /* Cons */ 0,
        key: key,
        data: /* Empty */ 0,
        next: /* Empty */ 0
      };
      set_next(tables$1, next$1);
      return build_path(i - 1 | 0, keys, next$1);
    }
    _tables = next;
    continue;
  };
}

function lookup_tables(root, keys) {
  const root_data = get_data(root);
  if (/* tag */ typeof root_data !== "object" && typeof root_data !== "function") {
    return build_path(keys.length - 1 | 0, keys, root);
  } else {
    return lookup_keys(keys.length - 1 | 0, keys, root_data);
  }
}

function new_cache(table) {
  const n = new_method(table);
  const n$1 = n % 2 === 0 || n > (2 + ((Caml_array.get(table.methods, 1) << 4) / 32 | 0) | 0) ? n : new_method(table);
  Caml_array.set(table.methods, n$1, 0);
  return n$1;
}

function method_impl(table, i, arr) {
  const next = function (param) {
    i.contents = i.contents + 1 | 0;
    return Caml_array.get(arr, i.contents);
  };
  const clo = next();
  if (!/* tag */ (typeof clo !== "object" && typeof clo !== "function")) {
    return clo;
  }
  switch (clo) {
    case /* GetConst */ 0 :
      const partial_arg = next();
      return function (param) {
        return partial_arg;
      };
    case /* GetVar */ 1 :
      const partial_arg$1 = next();
      return function (param) {
        return param[partial_arg$1];
      };
    case /* GetEnv */ 2 :
      const e = next();
      const n = next();
      return function (param) {
        return param[e][n];
      };
    case /* GetMeth */ 3 :
      const partial_arg$2 = next();
      return function (param) {
        return Curry._1(param[0][partial_arg$2], param);
      };
    case /* SetVar */ 4 :
      const partial_arg$3 = next();
      return function (param, param$1) {
        param[partial_arg$3] = param$1;
      };
    case /* AppConst */ 5 :
      const f = next();
      const x = next();
      return function (param) {
        return Curry._1(f, x);
      };
    case /* AppVar */ 6 :
      const f$1 = next();
      const n$1 = next();
      return function (param) {
        return Curry._1(f$1, param[n$1]);
      };
    case /* AppEnv */ 7 :
      const f$2 = next();
      const e$1 = next();
      const n$2 = next();
      return function (param) {
        return Curry._1(f$2, param[e$1][n$2]);
      };
    case /* AppMeth */ 8 :
      const f$3 = next();
      const n$3 = next();
      return function (param) {
        return Curry._1(f$3, Curry._1(param[0][n$3], param));
      };
    case /* AppConstConst */ 9 :
      const f$4 = next();
      const x$1 = next();
      const y = next();
      return function (param) {
        return Curry._2(f$4, x$1, y);
      };
    case /* AppConstVar */ 10 :
      const f$5 = next();
      const x$2 = next();
      const n$4 = next();
      return function (param) {
        return Curry._2(f$5, x$2, param[n$4]);
      };
    case /* AppConstEnv */ 11 :
      const f$6 = next();
      const x$3 = next();
      const e$2 = next();
      const n$5 = next();
      return function (param) {
        return Curry._2(f$6, x$3, param[e$2][n$5]);
      };
    case /* AppConstMeth */ 12 :
      const f$7 = next();
      const x$4 = next();
      const n$6 = next();
      return function (param) {
        return Curry._2(f$7, x$4, Curry._1(param[0][n$6], param));
      };
    case /* AppVarConst */ 13 :
      const f$8 = next();
      const n$7 = next();
      const x$5 = next();
      return function (param) {
        return Curry._2(f$8, param[n$7], x$5);
      };
    case /* AppEnvConst */ 14 :
      const f$9 = next();
      const e$3 = next();
      const n$8 = next();
      const x$6 = next();
      return function (param) {
        return Curry._2(f$9, param[e$3][n$8], x$6);
      };
    case /* AppMethConst */ 15 :
      const f$10 = next();
      const n$9 = next();
      const x$7 = next();
      return function (param) {
        return Curry._2(f$10, Curry._1(param[0][n$9], param), x$7);
      };
    case /* MethAppConst */ 16 :
      const n$10 = next();
      const x$8 = next();
      return function (param) {
        return Curry._2(param[0][n$10], param, x$8);
      };
    case /* MethAppVar */ 17 :
      const n$11 = next();
      const m = next();
      return function (param) {
        return Curry._2(param[0][n$11], param, param[m]);
      };
    case /* MethAppEnv */ 18 :
      const n$12 = next();
      const e$4 = next();
      const m$1 = next();
      return function (param) {
        return Curry._2(param[0][n$12], param, param[e$4][m$1]);
      };
    case /* MethAppMeth */ 19 :
      const n$13 = next();
      const m$2 = next();
      return function (param) {
        return Curry._2(param[0][n$13], param, Curry._1(param[0][m$2], param));
      };
    case /* SendConst */ 20 :
      const m$3 = next();
      const x$9 = next();
      const partial_arg$4 = new_cache(table);
      return function (param) {
        return Curry._3(Curry._3(Caml_oo.caml_get_public_method, x$9, m$3, 1), x$9, param[0], partial_arg$4);
      };
    case /* SendVar */ 21 :
      const m$4 = next();
      const n$14 = next();
      const partial_arg$5 = new_cache(table);
      return function (param) {
        const tmp = param[n$14];
        return Curry._3(Curry._3(Caml_oo.caml_get_public_method, tmp, m$4, 2), tmp, param[0], partial_arg$5);
      };
    case /* SendEnv */ 22 :
      const m$5 = next();
      const e$5 = next();
      const n$15 = next();
      const partial_arg$6 = new_cache(table);
      return function (param) {
        const tmp = param[e$5][n$15];
        return Curry._3(Curry._3(Caml_oo.caml_get_public_method, tmp, m$5, 3), tmp, param[0], partial_arg$6);
      };
    case /* SendMeth */ 23 :
      const m$6 = next();
      const n$16 = next();
      const partial_arg$7 = new_cache(table);
      return function (param) {
        const tmp = Curry._1(param[0][n$16], param);
        return Curry._3(Curry._3(Caml_oo.caml_get_public_method, tmp, m$6, 4), tmp, param[0], partial_arg$7);
      };
  }
}

function set_methods(table, methods) {
  const len = methods.length;
  const i = {
    contents: 0
  };
  while (i.contents < len) {
    const label = Caml_array.get(methods, i.contents);
    const clo = method_impl(table, i, methods);
    set_method(table, label, clo);
    i.contents = i.contents + 1 | 0;
  };
}

function stats(param) {
  return {
    classes: Stdlib__Atomic.get(table_count),
    methods: Stdlib__Atomic.get(method_count),
    inst_vars: Stdlib__Atomic.get(inst_var_count)
  };
}

export {
  public_method_label,
  new_method,
  new_variable,
  new_methods_variables,
  get_variable,
  get_variables,
  get_method_label,
  get_method_labels,
  get_method,
  set_method,
  set_methods,
  narrow,
  widen,
  add_initializer,
  dummy_table,
  create_table,
  init_class,
  inherits,
  make_class,
  make_class_store,
  copy,
  create_object,
  create_object_opt,
  run_initializers,
  run_initializers_opt,
  create_object_and_run_initializers,
  lookup_tables,
  params,
  stats,
}
/* Vars Not a pure module */
