// Generated by Melange

import * as Caml from "melange.js/caml.mjs";
import * as Caml_bytes from "melange.js/caml_bytes.mjs";
import * as Caml_exceptions from "melange.js/caml_exceptions.mjs";
import * as Caml_format from "melange.js/caml_format.mjs";
import * as Caml_io from "melange.js/caml_io.mjs";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.mjs";
import * as Caml_obj from "melange.js/caml_obj.mjs";
import * as Caml_option from "melange.js/caml_option.mjs";
import * as Caml_string from "melange.js/caml_string.mjs";
import * as CamlinternalFormat from "./camlinternalFormat.mjs";
import * as CamlinternalFormatBasics from "./camlinternalFormatBasics.mjs";
import * as Curry from "melange.js/curry.mjs";
import * as Stdlib from "./stdlib.mjs";
import * as Stdlib__Array from "./array.mjs";
import * as Stdlib__Buffer from "./buffer.mjs";
import * as Stdlib__Bytes from "./bytes.mjs";
import * as Stdlib__Domain from "./domain.mjs";
import * as Stdlib__Int from "./int.mjs";
import * as Stdlib__List from "./list.mjs";
import * as Stdlib__Queue from "./queue.mjs";
import * as Stdlib__Seq from "./seq.mjs";
import * as Stdlib__Stack from "./stack.mjs";
import * as Stdlib__String from "./string.mjs";

function id(x) {
  return x;
}

const String_tag = /* @__PURE__ */ Caml_exceptions.create("Stdlib.Format.String_tag");

function pp_enqueue(state, token) {
  state.pp_right_total = state.pp_right_total + token.length | 0;
  Stdlib__Queue.add(token, state.pp_queue);
}

function pp_clear_queue(state) {
  state.pp_left_total = 1;
  state.pp_right_total = 1;
  Stdlib__Queue.clear(state.pp_queue);
}

function pp_output_string(state, s) {
  Curry._3(state.pp_out_string, s, 0, s.length);
}

function pp_string_width(state, s) {
  return Curry._3(state.pp_out_width, s, 0, s.length);
}

function pp_output_substring(state, pos, len, s) {
  Curry._3(state.pp_out_string, s, pos, len);
}

function pp_substring_width(state, pos, len, s) {
  return Curry._3(state.pp_out_width, s, pos, len);
}

function format_pp_text(state, size, text) {
  state.pp_space_left = state.pp_space_left - size | 0;
  pp_output_string(state, text);
  state.pp_is_new_line = false;
}

function format_string(state, s) {
  if (s !== "") {
    return format_pp_text(state, pp_string_width(state, s), s);
  }
  
}

function break_new_line(state, param, width) {
  format_string(state, param[0]);
  Curry._1(state.pp_out_newline, undefined);
  state.pp_is_new_line = true;
  const indent = (state.pp_margin - width | 0) + param[1] | 0;
  const real_indent = Stdlib__Int.min(state.pp_max_indent, indent);
  state.pp_current_indent = real_indent;
  state.pp_space_left = state.pp_margin - state.pp_current_indent | 0;
  Curry._1(state.pp_out_indent, state.pp_current_indent);
  format_string(state, param[2]);
}

function break_line(state, width) {
  break_new_line(state, [
    "",
    0,
    ""
  ], width);
}

function break_same_line(state, param) {
  const width = param[1];
  format_string(state, param[0]);
  state.pp_space_left = state.pp_space_left - width | 0;
  Curry._1(state.pp_out_spaces, width);
  format_string(state, param[2]);
}

function pp_force_break_line(state) {
  const match = Stdlib__Stack.top_opt(state.pp_format_stack);
  if (match === undefined) {
    return Curry._1(state.pp_out_newline, undefined);
  }
  const width = match.width;
  if (width <= state.pp_space_left) {
    return;
  }
  switch (match.box_type) {
    case /* Pp_hbox */ 0 :
    case /* Pp_fits */ 5 :
      return;
    default:
      return break_line(state, width);
  }
}

function format_pp_token(state, size, s) {
  if (/* tag */ typeof s !== "object" && typeof s !== "function") {
    switch (s) {
      case /* Pp_stab */ 0 :
        const match = Stdlib__Stack.top_opt(state.pp_tbox_stack);
        if (match === undefined) {
          return;
        }
        const tabs = match._0;
        const add_tab = function (n, ls) {
          if (!ls) {
            return {
              hd: n,
              tl: /* [] */ 0
            };
          }
          const x = ls.hd;
          if (Caml_obj.caml_lessthan(n, x)) {
            return {
              hd: n,
              tl: ls
            };
          } else {
            return {
              hd: x,
              tl: add_tab(n, ls.tl)
            };
          }
        };
        tabs.contents = add_tab(state.pp_margin - state.pp_space_left | 0, tabs.contents);
        return;
      case /* Pp_end */ 1 :
        Stdlib__Stack.pop_opt(state.pp_format_stack);
        return;
      case /* Pp_tend */ 2 :
        Stdlib__Stack.pop_opt(state.pp_tbox_stack);
        return;
      case /* Pp_newline */ 3 :
        const match$1 = Stdlib__Stack.top_opt(state.pp_format_stack);
        if (match$1 !== undefined) {
          return break_line(state, match$1.width);
        } else {
          return Curry._1(state.pp_out_newline, undefined);
        }
      case /* Pp_if_newline */ 4 :
        if (state.pp_current_indent !== (state.pp_margin - state.pp_space_left | 0)) {
          const match$2 = Stdlib__Queue.take_opt(state.pp_queue);
          if (match$2 === undefined) {
            return;
          }
          const size$1 = match$2.size;
          state.pp_left_total = state.pp_left_total - match$2.length | 0;
          state.pp_space_left = state.pp_space_left + size$1 | 0;
          return;
        } else {
          return;
        }
      case /* Pp_close_tag */ 5 :
        const tag_name = Stdlib__Stack.pop_opt(state.pp_mark_stack);
        if (tag_name === undefined) {
          return;
        }
        const marker = Curry._1(state.pp_mark_close_tag, Caml_option.valFromOption(tag_name));
        return pp_output_string(state, marker);
    }
  } else {
    switch (s.TAG) {
      case /* Pp_text */ 0 :
        return format_pp_text(state, size, s._0);
      case /* Pp_substring */ 1 :
        let pos = s.pos;
        let len = s.len;
        let source = s.source;
        state.pp_space_left = state.pp_space_left - size | 0;
        pp_output_substring(state, pos, len, source);
        state.pp_is_new_line = false;
        return;
      case /* Pp_break */ 2 :
        const breaks = s.breaks;
        const before = breaks[0];
        const fits = s.fits;
        const match$3 = Stdlib__Stack.top_opt(state.pp_format_stack);
        if (match$3 === undefined) {
          return;
        }
        const width = match$3.width;
        switch (match$3.box_type) {
          case /* Pp_vbox */ 1 :
          case /* Pp_hvbox */ 2 :
            return break_new_line(state, breaks, width);
          case /* Pp_hovbox */ 3 :
            if ((size + pp_string_width(state, before) | 0) > state.pp_space_left) {
              return break_new_line(state, breaks, width);
            } else {
              return break_same_line(state, fits);
            }
          case /* Pp_box */ 4 :
            if (state.pp_is_new_line || !((size + pp_string_width(state, before) | 0) > state.pp_space_left || state.pp_current_indent > ((state.pp_margin - width | 0) + breaks[1] | 0))) {
              return break_same_line(state, fits);
            } else {
              return break_new_line(state, breaks, width);
            }
          case /* Pp_hbox */ 0 :
          case /* Pp_fits */ 5 :
            return break_same_line(state, fits);
        }
      case /* Pp_tbreak */ 3 :
        const insertion_point = state.pp_margin - state.pp_space_left | 0;
        const match$4 = Stdlib__Stack.top_opt(state.pp_tbox_stack);
        if (match$4 === undefined) {
          return;
        }
        const tabs$1 = match$4._0;
        const match$5 = tabs$1.contents;
        let tab;
        if (match$5) {
          const first = match$5.hd;
          const find = function (_param) {
            while (true) {
              const param = _param;
              if (!param) {
                return first;
              }
              const head = param.hd;
              if (head >= insertion_point) {
                return head;
              }
              _param = param.tl;
              continue;
            };
          };
          tab = find(tabs$1.contents);
        } else {
          tab = insertion_point;
        }
        const offset = tab - insertion_point | 0;
        if (offset >= 0) {
          return break_same_line(state, [
            "",
            offset + s._0 | 0,
            ""
          ]);
        } else {
          return break_new_line(state, [
            "",
            tab + s._1 | 0,
            ""
          ], state.pp_margin);
        }
      case /* Pp_begin */ 4 :
        const ty = s._1;
        const insertion_point$1 = state.pp_margin - state.pp_space_left | 0;
        if (insertion_point$1 > state.pp_max_indent) {
          pp_force_break_line(state);
        }
        const width$1 = state.pp_space_left - s._0 | 0;
        let box_type;
        box_type = ty === /* Pp_vbox */ 1 ? /* Pp_vbox */ 1 : (
            size > state.pp_space_left ? ty : /* Pp_fits */ 5
          );
        return Stdlib__Stack.push({
          box_type: box_type,
          width: width$1
        }, state.pp_format_stack);
      case /* Pp_tbegin */ 5 :
        return Stdlib__Stack.push(s._0, state.pp_tbox_stack);
      case /* Pp_open_tag */ 6 :
        const tag_name$1 = s._0;
        const marker$1 = Curry._1(state.pp_mark_open_tag, tag_name$1);
        pp_output_string(state, marker$1);
        return Stdlib__Stack.push(tag_name$1, state.pp_mark_stack);
    }
  }
}

function advance_left(state) {
  while (true) {
    const match = Stdlib__Queue.peek_opt(state.pp_queue);
    if (match === undefined) {
      return;
    }
    const size = match.size;
    const pending_count = state.pp_right_total - state.pp_left_total | 0;
    if (!(size >= 0 || pending_count >= state.pp_space_left)) {
      return;
    }
    const match$1 = Stdlib__Queue.take_opt(state.pp_queue);
    if (match$1 !== undefined) {
      const size$1 = size >= 0 ? size : 1000000010;
      format_pp_token(state, size$1, match.token);
      state.pp_left_total = match.length + state.pp_left_total | 0;
      continue;
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Format: Unsynchronized access to formatter"
      });
  };
}

function enqueue_advance(state, tok) {
  pp_enqueue(state, tok);
  advance_left(state);
}

function enqueue_string_as(state, size, s) {
  enqueue_advance(state, {
    size: size,
    token: {
      TAG: /* Pp_text */ 0,
      _0: s
    },
    length: size
  });
}

function initialize_scan_stack(stack) {
  Stdlib__Stack.clear(stack);
  const queue_elem = {
    size: -1,
    token: {
      TAG: /* Pp_text */ 0,
      _0: ""
    },
    length: 0
  };
  Stdlib__Stack.push({
    left_total: -1,
    queue_elem: queue_elem
  }, stack);
}

function set_size(state, ty) {
  const match = Stdlib__Stack.top_opt(state.pp_scan_stack);
  if (match === undefined) {
    return;
  }
  const queue_elem = match.queue_elem;
  const size = queue_elem.size;
  if (match.left_total < state.pp_left_total) {
    return initialize_scan_stack(state.pp_scan_stack);
  }
  const match$1 = queue_elem.token;
  if (/* tag */ typeof match$1 !== "object" && typeof match$1 !== "function") {
    return;
  }
  switch (match$1.TAG) {
    case /* Pp_break */ 2 :
    case /* Pp_tbreak */ 3 :
      break;
    case /* Pp_begin */ 4 :
      if (!ty) {
        queue_elem.size = state.pp_right_total + size | 0;
        Stdlib__Stack.pop_opt(state.pp_scan_stack);
        return;
      } else {
        return;
      }
    default:
      return;
  }
  if (ty) {
    queue_elem.size = state.pp_right_total + size | 0;
    Stdlib__Stack.pop_opt(state.pp_scan_stack);
    return;
  }
  
}

function scan_push(state, b, token) {
  pp_enqueue(state, token);
  if (b) {
    set_size(state, true);
  }
  const elem_left_total = state.pp_right_total;
  const elem = {
    left_total: elem_left_total,
    queue_elem: token
  };
  Stdlib__Stack.push(elem, state.pp_scan_stack);
}

function pp_open_box_gen(state, indent, br_ty) {
  state.pp_curr_depth = state.pp_curr_depth + 1 | 0;
  if (state.pp_curr_depth >= state.pp_max_boxes) {
    if (state.pp_curr_depth === state.pp_max_boxes) {
      let s = state.pp_ellipsis;
      const size = pp_string_width(state, s);
      return enqueue_string_as(state, size, s);
    } else {
      return;
    }
  }
  const size$1 = -state.pp_right_total | 0;
  const elem = {
    size: size$1,
    token: {
      TAG: /* Pp_begin */ 4,
      _0: indent,
      _1: br_ty
    },
    length: 0
  };
  scan_push(state, false, elem);
}

function pp_close_box(state, param) {
  if (state.pp_curr_depth > 1) {
    if (state.pp_curr_depth < state.pp_max_boxes) {
      pp_enqueue(state, {
        size: 0,
        token: /* Pp_end */ 1,
        length: 0
      });
      set_size(state, true);
      set_size(state, false);
    }
    state.pp_curr_depth = state.pp_curr_depth - 1 | 0;
    return;
  }
  
}

function pp_open_stag(state, tag_name) {
  if (state.pp_print_tags) {
    Stdlib__Stack.push(tag_name, state.pp_tag_stack);
    Curry._1(state.pp_print_open_tag, tag_name);
  }
  if (!state.pp_mark_tags) {
    return;
  }
  const token = {
    TAG: /* Pp_open_tag */ 6,
    _0: tag_name
  };
  pp_enqueue(state, {
    size: 0,
    token: token,
    length: 0
  });
}

function pp_close_stag(state, param) {
  if (state.pp_mark_tags) {
    pp_enqueue(state, {
      size: 0,
      token: /* Pp_close_tag */ 5,
      length: 0
    });
  }
  if (!state.pp_print_tags) {
    return;
  }
  const tag_name = Stdlib__Stack.pop_opt(state.pp_tag_stack);
  if (tag_name !== undefined) {
    return Curry._1(state.pp_print_close_tag, Caml_option.valFromOption(tag_name));
  }
  
}

function pp_set_print_tags(state, b) {
  state.pp_print_tags = b;
}

function pp_set_mark_tags(state, b) {
  state.pp_mark_tags = b;
}

function pp_get_print_tags(state, param) {
  return state.pp_print_tags;
}

function pp_get_mark_tags(state, param) {
  return state.pp_mark_tags;
}

function pp_set_tags(state, b) {
  state.pp_print_tags = b;
  state.pp_mark_tags = b;
}

function pp_get_formatter_stag_functions(state, param) {
  return {
    mark_open_stag: state.pp_mark_open_tag,
    mark_close_stag: state.pp_mark_close_tag,
    print_open_stag: state.pp_print_open_tag,
    print_close_stag: state.pp_print_close_tag
  };
}

function pp_set_formatter_stag_functions(state, param) {
  state.pp_mark_open_tag = param.mark_open_stag;
  state.pp_mark_close_tag = param.mark_close_stag;
  state.pp_print_open_tag = param.print_open_stag;
  state.pp_print_close_tag = param.print_close_stag;
}

function pp_rinit(state) {
  pp_clear_queue(state);
  initialize_scan_stack(state.pp_scan_stack);
  Stdlib__Stack.clear(state.pp_format_stack);
  Stdlib__Stack.clear(state.pp_tbox_stack);
  Stdlib__Stack.clear(state.pp_tag_stack);
  Stdlib__Stack.clear(state.pp_mark_stack);
  state.pp_current_indent = 0;
  state.pp_curr_depth = 0;
  state.pp_space_left = state.pp_margin;
  pp_open_box_gen(state, 0, /* Pp_hovbox */ 3);
}

function clear_tag_stack(state) {
  const s = state.pp_tag_stack;
  const f = function (param) {
    pp_close_stag(state, undefined);
  };
  Stdlib__List.iter(f, s.c);
}

function pp_flush_queue(state, end_with_newline) {
  clear_tag_stack(state);
  while (state.pp_curr_depth > 1) {
    pp_close_box(state, undefined);
  };
  state.pp_right_total = 1000000010;
  advance_left(state);
  if (end_with_newline) {
    Curry._1(state.pp_out_newline, undefined);
  }
  pp_rinit(state);
}

function pp_print_as_size(state, size, s) {
  if (state.pp_curr_depth < state.pp_max_boxes) {
    return enqueue_string_as(state, size, s);
  }
  
}

const pp_print_as = pp_print_as_size;

function pp_print_string(state, s) {
  pp_print_as(state, pp_string_width(state, s), s);
}

function pp_print_substring_as(pos, len, state, size, s) {
  if (state.pp_curr_depth < state.pp_max_boxes) {
    const token = {
      TAG: /* Pp_substring */ 1,
      source: s,
      pos: pos,
      len: len
    };
    return enqueue_advance(state, {
      size: size,
      token: token,
      length: size
    });
  }
  
}

function pp_print_substring(pos, len, state, s) {
  const width = pp_substring_width(state, pos, len, s);
  pp_print_substring_as(pos, len, state, width, s);
}

function pp_print_bytes(state, s) {
  pp_print_as(state, s.length, Stdlib__Bytes.to_string(s));
}

function pp_print_int(state, i) {
  pp_print_string(state, Caml_format.caml_format_int("%d", i));
}

function pp_print_float(state, f) {
  pp_print_string(state, Stdlib.string_of_float(f));
}

function pp_print_bool(state, b) {
  pp_print_string(state, b ? "true" : "false");
}

function pp_print_char(state, c) {
  pp_print_as(state, 1, Caml_bytes.bytes_to_string(Stdlib__Bytes.make(1, c)));
}

function pp_print_nothing(_state, param) {
  
}

function pp_open_hbox(state, param) {
  pp_open_box_gen(state, 0, /* Pp_hbox */ 0);
}

function pp_open_vbox(state, indent) {
  pp_open_box_gen(state, indent, /* Pp_vbox */ 1);
}

function pp_open_hvbox(state, indent) {
  pp_open_box_gen(state, indent, /* Pp_hvbox */ 2);
}

function pp_open_hovbox(state, indent) {
  pp_open_box_gen(state, indent, /* Pp_hovbox */ 3);
}

function pp_open_box(state, indent) {
  pp_open_box_gen(state, indent, /* Pp_box */ 4);
}

function pp_print_newline(state, param) {
  pp_flush_queue(state, true);
  Curry._1(state.pp_out_flush, undefined);
}

function pp_print_flush(state, param) {
  pp_flush_queue(state, false);
  Curry._1(state.pp_out_flush, undefined);
}

function pp_force_newline(state, param) {
  if (state.pp_curr_depth < state.pp_max_boxes) {
    return enqueue_advance(state, {
      size: 0,
      token: /* Pp_newline */ 3,
      length: 0
    });
  }
  
}

function pp_print_if_newline(state, param) {
  if (state.pp_curr_depth < state.pp_max_boxes) {
    return enqueue_advance(state, {
      size: 0,
      token: /* Pp_if_newline */ 4,
      length: 0
    });
  }
  
}

function pp_print_custom_break(state, fits, breaks) {
  if (state.pp_curr_depth >= state.pp_max_boxes) {
    return;
  }
  const size = -state.pp_right_total | 0;
  const token = {
    TAG: /* Pp_break */ 2,
    fits: fits,
    breaks: breaks
  };
  const length = (pp_string_width(state, fits[0]) + fits[1] | 0) + pp_string_width(state, fits[2]) | 0;
  const elem = {
    size: size,
    token: token,
    length: length
  };
  scan_push(state, true, elem);
}

function pp_print_break(state, width, offset) {
  pp_print_custom_break(state, [
    "",
    width,
    ""
  ], [
    "",
    offset,
    ""
  ]);
}

function pp_print_space(state, param) {
  pp_print_break(state, 1, 0);
}

function pp_print_cut(state, param) {
  pp_print_break(state, 0, 0);
}

function pp_open_tbox(state, param) {
  state.pp_curr_depth = state.pp_curr_depth + 1 | 0;
  if (state.pp_curr_depth >= state.pp_max_boxes) {
    return;
  }
  const elem = {
    size: 0,
    token: {
      TAG: /* Pp_tbegin */ 5,
      _0: {
        TAG: /* Pp_tbox */ 0,
        _0: {
          contents: /* [] */ 0
        }
      }
    },
    length: 0
  };
  enqueue_advance(state, elem);
}

function pp_close_tbox(state, param) {
  if (state.pp_curr_depth <= 1) {
    return;
  }
  if (state.pp_curr_depth >= state.pp_max_boxes) {
    return;
  }
  const elem = {
    size: 0,
    token: /* Pp_tend */ 2,
    length: 0
  };
  enqueue_advance(state, elem);
  state.pp_curr_depth = state.pp_curr_depth - 1 | 0;
}

function pp_print_tbreak(state, width, offset) {
  if (state.pp_curr_depth >= state.pp_max_boxes) {
    return;
  }
  const size = -state.pp_right_total | 0;
  const elem = {
    size: size,
    token: {
      TAG: /* Pp_tbreak */ 3,
      _0: width,
      _1: offset
    },
    length: width
  };
  scan_push(state, true, elem);
}

function pp_print_tab(state, param) {
  pp_print_tbreak(state, 0, 0);
}

function pp_set_tab(state, param) {
  if (state.pp_curr_depth >= state.pp_max_boxes) {
    return;
  }
  const elem = {
    size: 0,
    token: /* Pp_stab */ 0,
    length: 0
  };
  enqueue_advance(state, elem);
}

function pp_set_max_boxes(state, n) {
  if (n > 1) {
    state.pp_max_boxes = n;
    return;
  }
  
}

function pp_get_max_boxes(state, param) {
  return state.pp_max_boxes;
}

function pp_over_max_boxes(state, param) {
  return state.pp_curr_depth === state.pp_max_boxes;
}

function pp_set_ellipsis_text(state, s) {
  state.pp_ellipsis = s;
}

function pp_get_ellipsis_text(state, param) {
  return state.pp_ellipsis;
}

function pp_limit(n) {
  if (n < 1000000010) {
    return n;
  } else {
    return 1000000009;
  }
}

function pp_set_max_indent(state, n) {
  if (n > 1) {
    let n$1 = state.pp_margin - n | 0;
    if (n$1 < 1) {
      return;
    }
    const n$2 = pp_limit(n$1);
    state.pp_min_space_left = n$2;
    state.pp_max_indent = state.pp_margin - state.pp_min_space_left | 0;
    return pp_rinit(state);
  }
  
}

function pp_get_max_indent(state, param) {
  return state.pp_max_indent;
}

function pp_set_margin(state, n) {
  if (n < 1) {
    return;
  }
  const n$1 = pp_limit(n);
  state.pp_margin = n$1;
  const new_max_indent = state.pp_max_indent <= state.pp_margin ? state.pp_max_indent : Stdlib__Int.max(Stdlib__Int.max(state.pp_margin - state.pp_min_space_left | 0, state.pp_margin / 2 | 0), 1);
  pp_set_max_indent(state, new_max_indent);
}

function validate_geometry(param) {
  const max_indent = param.max_indent;
  if (max_indent < 2) {
    return {
      TAG: /* Error */ 1,
      _0: "max_indent < 2"
    };
  }
  const margin = param.margin;
  if (margin <= max_indent) {
    return {
      TAG: /* Error */ 1,
      _0: "margin <= max_indent"
    };
  } else if (margin >= 1000000010) {
    return {
      TAG: /* Error */ 1,
      _0: "margin >= pp_infinity"
    };
  } else {
    return {
      TAG: /* Ok */ 0,
      _0: undefined
    };
  }
}

function check_geometry(geometry) {
  const match = validate_geometry(geometry);
  if (match.TAG === /* Ok */ 0) {
    return true;
  } else {
    return false;
  }
}

function pp_get_margin(state, param) {
  return state.pp_margin;
}

function pp_set_full_geometry(state, param) {
  pp_set_margin(state, param.margin);
  pp_set_max_indent(state, param.max_indent);
}

function pp_set_geometry(state, max_indent, margin) {
  const geometry = {
    max_indent: max_indent,
    margin: margin
  };
  const msg = validate_geometry(geometry);
  if (msg.TAG === /* Ok */ 0) {
    return pp_set_full_geometry(state, geometry);
  }
  throw new Caml_js_exceptions.MelangeError(Stdlib.Invalid_argument, {
      MEL_EXN_ID: Stdlib.Invalid_argument,
      _1: "Format.pp_set_geometry: " + msg._0
    });
}

function pp_safe_set_geometry(state, max_indent, margin) {
  const geometry = {
    max_indent: max_indent,
    margin: margin
  };
  const _msg = validate_geometry(geometry);
  if (_msg.TAG === /* Ok */ 0) {
    return pp_set_full_geometry(state, geometry);
  }
  
}

function pp_get_geometry(state, param) {
  return {
    max_indent: state.pp_max_indent,
    margin: state.pp_margin
  };
}

function pp_update_geometry(state, update) {
  const geometry = pp_get_geometry(state, undefined);
  pp_set_full_geometry(state, Curry._1(update, geometry));
}

function pp_set_formatter_out_functions(state, param) {
  state.pp_out_string = param.out_string;
  state.pp_out_width = param.out_width;
  state.pp_out_flush = param.out_flush;
  state.pp_out_newline = param.out_newline;
  state.pp_out_spaces = param.out_spaces;
  state.pp_out_indent = param.out_indent;
}

function pp_get_formatter_out_functions(state, param) {
  return {
    out_string: state.pp_out_string,
    out_width: state.pp_out_width,
    out_flush: state.pp_out_flush,
    out_newline: state.pp_out_newline,
    out_spaces: state.pp_out_spaces,
    out_indent: state.pp_out_indent
  };
}

function pp_set_formatter_output_functions(state, f, g) {
  state.pp_out_string = f;
  state.pp_out_flush = g;
}

function pp_get_formatter_output_functions(state, param) {
  return [
    state.pp_out_string,
    state.pp_out_flush
  ];
}

function display_newline(state, param) {
  Curry._3(state.pp_out_string, "\n", 0, 1);
}

const blank_line = Caml_bytes.bytes_to_string(Stdlib__Bytes.make(80, /* ' ' */32));

function display_blanks(state, _n) {
  while (true) {
    const n = _n;
    if (n <= 0) {
      return;
    }
    if (n <= 80) {
      return Curry._3(state.pp_out_string, blank_line, 0, n);
    }
    Curry._3(state.pp_out_string, blank_line, 0, 80);
    _n = n - 80 | 0;
    continue;
  };
}

function pp_set_formatter_out_channel(state, oc) {
  state.pp_out_string = (function (param, param$1, param$2) {
    return Stdlib.output_substring(oc, param, param$1, param$2);
  });
  state.pp_out_flush = (function (param) {
    Caml_io.caml_ml_flush(oc);
  });
  state.pp_out_newline = (function (param) {
    return display_newline(state, param);
  });
  state.pp_out_spaces = (function (param) {
    return display_blanks(state, param);
  });
  state.pp_out_indent = (function (param) {
    return display_blanks(state, param);
  });
}

function default_pp_mark_open_tag(s) {
  if (s.MEL_EXN_ID === String_tag) {
    return "<" + (s._1 + ">");
  } else {
    return "";
  }
}

function default_pp_mark_close_tag(s) {
  if (s.MEL_EXN_ID === String_tag) {
    return "</" + (s._1 + ">");
  } else {
    return "";
  }
}

function default_pp_print_open_tag(prim) {
  
}

function default_pp_print_close_tag(prim) {
  
}

function utf_8_scalar_width(s, pos, len) {
  let _count = 0;
  let _current = pos;
  let stop = pos + len | 0;
  while (true) {
    const current = _current;
    const count = _count;
    if (current >= stop) {
      return count;
    }
    const decode = Stdlib__Bytes.get_utf_8_uchar(Caml_bytes.bytes_of_string(s), current);
    const advance = (decode >>> 24) & 7;
    _current = current + advance | 0;
    _count = count + 1 | 0;
    continue;
  };
}

function ascii_width(param, param$1, len) {
  return len;
}

function pp_make_formatter(f, g, h, i, j) {
  const pp_queue = {
    length: 0,
    first: /* Nil */ 0,
    last: /* Nil */ 0
  };
  const sys_tok = {
    size: -1,
    token: {
      TAG: /* Pp_begin */ 4,
      _0: 0,
      _1: /* Pp_hovbox */ 3
    },
    length: 0
  };
  Stdlib__Queue.add(sys_tok, pp_queue);
  const scan_stack = {
    c: /* [] */ 0,
    len: 0
  };
  initialize_scan_stack(scan_stack);
  Stdlib__Stack.push({
    left_total: 1,
    queue_elem: sys_tok
  }, scan_stack);
  return {
    pp_scan_stack: scan_stack,
    pp_format_stack: {
      c: /* [] */ 0,
      len: 0
    },
    pp_tbox_stack: {
      c: /* [] */ 0,
      len: 0
    },
    pp_tag_stack: {
      c: /* [] */ 0,
      len: 0
    },
    pp_mark_stack: {
      c: /* [] */ 0,
      len: 0
    },
    pp_margin: 78,
    pp_min_space_left: 10,
    pp_max_indent: 68,
    pp_space_left: 78,
    pp_current_indent: 0,
    pp_is_new_line: true,
    pp_left_total: 1,
    pp_right_total: 1,
    pp_curr_depth: 1,
    pp_max_boxes: Stdlib.max_int,
    pp_ellipsis: ".",
    pp_out_string: f,
    pp_out_width: utf_8_scalar_width,
    pp_out_flush: g,
    pp_out_newline: h,
    pp_out_spaces: i,
    pp_out_indent: j,
    pp_print_tags: false,
    pp_mark_tags: false,
    pp_mark_open_tag: default_pp_mark_open_tag,
    pp_mark_close_tag: default_pp_mark_close_tag,
    pp_print_open_tag: default_pp_print_open_tag,
    pp_print_close_tag: default_pp_print_close_tag,
    pp_queue: pp_queue
  };
}

function formatter_of_out_functions(out_funs) {
  return pp_make_formatter(out_funs.out_string, out_funs.out_flush, out_funs.out_newline, out_funs.out_spaces, out_funs.out_indent);
}

function make_formatter(output, flush) {
  const ppf = pp_make_formatter(output, flush, (function (prim) {
    
  }), (function (prim) {
    
  }), (function (prim) {
    
  }));
  ppf.pp_out_newline = (function (param) {
    return display_newline(ppf, param);
  });
  ppf.pp_out_spaces = (function (param) {
    return display_blanks(ppf, param);
  });
  ppf.pp_out_indent = (function (param) {
    return display_blanks(ppf, param);
  });
  return ppf;
}

function formatter_of_out_channel(oc) {
  return make_formatter((function (param, param$1, param$2) {
    return Stdlib.output_substring(oc, param, param$1, param$2);
  }), (function (param) {
    Caml_io.caml_ml_flush(oc);
  }));
}

function formatter_of_buffer(b) {
  return make_formatter((function (param, param$1, param$2) {
    return Stdlib__Buffer.add_substring(b, param, param$1, param$2);
  }), (function (prim) {
    
  }));
}

function pp_make_buffer(param) {
  return Stdlib__Buffer.create(512);
}

const stdbuf = Stdlib__Buffer.create(512);

const std_formatter = formatter_of_out_channel(Stdlib.stdout);

const err_formatter = formatter_of_out_channel(Stdlib.stderr);

const str_formatter = formatter_of_buffer(stdbuf);

const stdbuf_key = Stdlib__Domain.DLS.new_key(undefined, pp_make_buffer);

Stdlib__Domain.DLS.set(stdbuf_key, stdbuf);

const str_formatter_key = Stdlib__Domain.DLS.new_key(undefined, (function (param) {
  return formatter_of_buffer(Stdlib__Domain.DLS.get(stdbuf_key));
}));

Stdlib__Domain.DLS.set(str_formatter_key, str_formatter);

function buffered_out_string(key, str, ofs, len) {
  Stdlib__Buffer.add_substring(Stdlib__Domain.DLS.get(key), str, ofs, len);
}

function buffered_out_flush(oc, key, param) {
  const buf = Stdlib__Domain.DLS.get(key);
  const len = buf.position;
  const str = Stdlib__Buffer.contents(buf);
  Stdlib.output_substring(oc, str, 0, len);
  Caml_io.caml_ml_flush(oc);
  buf.position = 0;
}

const std_buf_key = Stdlib__Domain.DLS.new_key(undefined, (function (param) {
  return Stdlib__Buffer.create(512);
}));

const err_buf_key = Stdlib__Domain.DLS.new_key(undefined, (function (param) {
  return Stdlib__Buffer.create(512);
}));

const std_formatter_key = Stdlib__Domain.DLS.new_key(undefined, (function (param) {
  const ppf = pp_make_formatter((function (param, param$1, param$2) {
    return buffered_out_string(std_buf_key, param, param$1, param$2);
  }), (function (param) {
    return buffered_out_flush(Stdlib.stdout, std_buf_key, param);
  }), (function (prim) {
    
  }), (function (prim) {
    
  }), (function (prim) {
    
  }));
  ppf.pp_out_newline = (function (param) {
    return display_newline(ppf, param);
  });
  ppf.pp_out_spaces = (function (param) {
    return display_blanks(ppf, param);
  });
  ppf.pp_out_indent = (function (param) {
    return display_blanks(ppf, param);
  });
  Stdlib__Domain.at_exit(function (param) {
    return pp_print_flush(ppf, param);
  });
  return ppf;
}));

Stdlib__Domain.DLS.set(std_formatter_key, std_formatter);

const err_formatter_key = Stdlib__Domain.DLS.new_key(undefined, (function (param) {
  const ppf = pp_make_formatter((function (param, param$1, param$2) {
    return buffered_out_string(err_buf_key, param, param$1, param$2);
  }), (function (param) {
    return buffered_out_flush(Stdlib.stderr, err_buf_key, param);
  }), (function (prim) {
    
  }), (function (prim) {
    
  }), (function (prim) {
    
  }));
  ppf.pp_out_newline = (function (param) {
    return display_newline(ppf, param);
  });
  ppf.pp_out_spaces = (function (param) {
    return display_blanks(ppf, param);
  });
  ppf.pp_out_indent = (function (param) {
    return display_blanks(ppf, param);
  });
  Stdlib__Domain.at_exit(function (param) {
    return pp_print_flush(ppf, param);
  });
  return ppf;
}));

Stdlib__Domain.DLS.set(err_formatter_key, err_formatter);

function get_std_formatter(param) {
  return Stdlib__Domain.DLS.get(std_formatter_key);
}

function get_err_formatter(param) {
  return Stdlib__Domain.DLS.get(err_formatter_key);
}

function get_str_formatter(param) {
  return Stdlib__Domain.DLS.get(str_formatter_key);
}

function get_stdbuf(param) {
  return Stdlib__Domain.DLS.get(stdbuf_key);
}

function flush_buffer_formatter(buf, ppf) {
  pp_flush_queue(ppf, false);
  const s = Stdlib__Buffer.contents(buf);
  Stdlib__Buffer.reset(buf);
  return s;
}

function flush_str_formatter(param) {
  const stdbuf = Stdlib__Domain.DLS.get(stdbuf_key);
  const str_formatter = Stdlib__Domain.DLS.get(str_formatter_key);
  return flush_buffer_formatter(stdbuf, str_formatter);
}

function make_synchronized_formatter(output, flush) {
  return Stdlib__Domain.DLS.new_key(undefined, (function (param) {
    const buf = Stdlib__Buffer.create(512);
    const output$p = function (param, param$1, param$2) {
      return Stdlib__Buffer.add_substring(buf, param, param$1, param$2);
    };
    const flush$p = function (param) {
      Curry._3(output, Stdlib__Buffer.contents(buf), 0, buf.position);
      buf.position = 0;
      Curry._1(flush, undefined);
    };
    return make_formatter(output$p, flush$p);
  }));
}

function synchronized_formatter_of_out_channel(oc) {
  return make_synchronized_formatter((function (param, param$1, param$2) {
    return Stdlib.output_substring(oc, param, param$1, param$2);
  }), (function (param) {
    Caml_io.caml_ml_flush(oc);
  }));
}

function make_symbolic_output_buffer(param) {
  return {
    symbolic_output_contents: /* [] */ 0
  };
}

function clear_symbolic_output_buffer(sob) {
  sob.symbolic_output_contents = /* [] */ 0;
}

function get_symbolic_output_buffer(sob) {
  return Stdlib__List.rev(sob.symbolic_output_contents);
}

function flush_symbolic_output_buffer(sob) {
  const items = Stdlib__List.rev(sob.symbolic_output_contents);
  sob.symbolic_output_contents = /* [] */ 0;
  return items;
}

function add_symbolic_output_item(sob, item) {
  sob.symbolic_output_contents = {
    hd: item,
    tl: sob.symbolic_output_contents
  };
}

function formatter_of_symbolic_output_buffer(sob) {
  const f = function (param, param$1, param$2) {
    return add_symbolic_output_item(sob, {
      TAG: /* Output_string */ 0,
      _0: Stdlib__String.sub(param, param$1, param$2)
    });
  };
  const g = function (param) {
    return add_symbolic_output_item(sob, /* Output_flush */ 0);
  };
  const h = function (param) {
    return add_symbolic_output_item(sob, /* Output_newline */ 1);
  };
  const i = function (param) {
    return add_symbolic_output_item(sob, {
      TAG: /* Output_spaces */ 1,
      _0: param
    });
  };
  const j = function (param) {
    return add_symbolic_output_item(sob, {
      TAG: /* Output_indent */ 2,
      _0: param
    });
  };
  return pp_make_formatter(f, g, h, i, j);
}

function open_hbox(v) {
  pp_open_hbox(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function open_vbox(v) {
  pp_open_vbox(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function open_hvbox(v) {
  pp_open_hvbox(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function open_hovbox(v) {
  pp_open_hovbox(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function open_box(v) {
  pp_open_box(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function close_box(v) {
  pp_close_box(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function open_stag(v) {
  pp_open_stag(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function close_stag(v) {
  pp_close_stag(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function print_as(v, w) {
  pp_print_as(Stdlib__Domain.DLS.get(std_formatter_key), v, w);
}

function print_string(v) {
  pp_print_string(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function print_substring(pos, len, v) {
  pp_print_substring(pos, len, Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function print_substring_as(pos, len, as_len, v) {
  pp_print_substring_as(pos, len, Stdlib__Domain.DLS.get(std_formatter_key), as_len, v);
}

function print_bytes(v) {
  pp_print_bytes(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function print_int(v) {
  const state = Stdlib__Domain.DLS.get(std_formatter_key);
  pp_print_string(state, Caml_format.caml_format_int("%d", v));
}

function print_float(v) {
  const state = Stdlib__Domain.DLS.get(std_formatter_key);
  pp_print_string(state, Stdlib.string_of_float(v));
}

function print_char(v) {
  pp_print_char(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function print_bool(v) {
  const state = Stdlib__Domain.DLS.get(std_formatter_key);
  pp_print_string(state, v ? "true" : "false");
}

function print_break(v, w) {
  pp_print_break(Stdlib__Domain.DLS.get(std_formatter_key), v, w);
}

function print_cut(v) {
  pp_print_break(Stdlib__Domain.DLS.get(std_formatter_key), 0, 0);
}

function print_space(v) {
  pp_print_break(Stdlib__Domain.DLS.get(std_formatter_key), 1, 0);
}

function force_newline(v) {
  pp_force_newline(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function print_flush(v) {
  pp_print_flush(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function print_newline(v) {
  pp_print_newline(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function print_if_newline(v) {
  pp_print_if_newline(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function open_tbox(v) {
  pp_open_tbox(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function close_tbox(v) {
  pp_close_tbox(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function print_tbreak(v, w) {
  pp_print_tbreak(Stdlib__Domain.DLS.get(std_formatter_key), v, w);
}

function set_tab(v) {
  pp_set_tab(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function print_tab(v) {
  pp_print_tbreak(Stdlib__Domain.DLS.get(std_formatter_key), 0, 0);
}

function set_margin(v) {
  pp_set_margin(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function get_margin(v) {
  return Stdlib__Domain.DLS.get(std_formatter_key).pp_margin;
}

function set_max_indent(v) {
  pp_set_max_indent(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function get_max_indent(v) {
  return Stdlib__Domain.DLS.get(std_formatter_key).pp_max_indent;
}

function set_geometry(max_indent, margin) {
  pp_set_geometry(Stdlib__Domain.DLS.get(std_formatter_key), max_indent, margin);
}

function safe_set_geometry(max_indent, margin) {
  pp_safe_set_geometry(Stdlib__Domain.DLS.get(std_formatter_key), max_indent, margin);
}

function get_geometry(v) {
  return pp_get_geometry(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function update_geometry(v) {
  pp_update_geometry(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function set_max_boxes(v) {
  pp_set_max_boxes(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function get_max_boxes(v) {
  return Stdlib__Domain.DLS.get(std_formatter_key).pp_max_boxes;
}

function over_max_boxes(v) {
  return pp_over_max_boxes(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function set_ellipsis_text(v) {
  Stdlib__Domain.DLS.get(std_formatter_key).pp_ellipsis = v;
}

function get_ellipsis_text(v) {
  return Stdlib__Domain.DLS.get(std_formatter_key).pp_ellipsis;
}

function set_formatter_out_channel(v) {
  pp_set_formatter_out_channel(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function set_formatter_out_functions(v) {
  pp_set_formatter_out_functions(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function get_formatter_out_functions(v) {
  return pp_get_formatter_out_functions(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function set_formatter_output_functions(v, w) {
  pp_set_formatter_output_functions(Stdlib__Domain.DLS.get(std_formatter_key), v, w);
}

function get_formatter_output_functions(v) {
  return pp_get_formatter_output_functions(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function set_formatter_stag_functions(v) {
  pp_set_formatter_stag_functions(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function get_formatter_stag_functions(v) {
  return pp_get_formatter_stag_functions(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function set_print_tags(v) {
  Stdlib__Domain.DLS.get(std_formatter_key).pp_print_tags = v;
}

function get_print_tags(v) {
  return Stdlib__Domain.DLS.get(std_formatter_key).pp_print_tags;
}

function set_mark_tags(v) {
  Stdlib__Domain.DLS.get(std_formatter_key).pp_mark_tags = v;
}

function get_mark_tags(v) {
  return Stdlib__Domain.DLS.get(std_formatter_key).pp_mark_tags;
}

function set_tags(v) {
  pp_set_tags(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function pp_print_iter(pp_sepOpt, iter, pp_v, ppf, v) {
  const pp_sep = pp_sepOpt !== undefined ? pp_sepOpt : pp_print_cut;
  const is_first = {
    contents: true
  };
  const pp_v$1 = function (v) {
    if (is_first.contents) {
      is_first.contents = false;
    } else {
      Curry._2(pp_sep, ppf, undefined);
    }
    return Curry._2(pp_v, ppf, v);
  };
  return Curry._2(iter, pp_v$1, v);
}

function pp_print_list(pp_sepOpt, pp_v, ppf, v) {
  const pp_sep = pp_sepOpt !== undefined ? pp_sepOpt : pp_print_cut;
  pp_print_iter(pp_sep, Stdlib__List.iter, pp_v, ppf, v);
}

function pp_print_array(pp_sepOpt, pp_v, ppf, v) {
  const pp_sep = pp_sepOpt !== undefined ? pp_sepOpt : pp_print_cut;
  pp_print_iter(pp_sep, Stdlib__Array.iter, pp_v, ppf, v);
}

function pp_print_seq(pp_sepOpt, pp_v, ppf, seq) {
  const pp_sep = pp_sepOpt !== undefined ? pp_sepOpt : pp_print_cut;
  pp_print_iter(pp_sep, Stdlib__Seq.iter, pp_v, ppf, seq);
}

function pp_print_text(ppf, s) {
  const len = s.length;
  const left = {
    contents: 0
  };
  const right = {
    contents: 0
  };
  const flush = function (param) {
    pp_print_substring(left.contents, right.contents - left.contents | 0, ppf, s);
    right.contents = right.contents + 1 | 0;
    left.contents = right.contents;
  };
  while (right.contents !== len) {
    const match = Caml_string.get(s, right.contents);
    if (match !== 10) {
      if (match !== 32) {
        right.contents = right.contents + 1 | 0;
      } else {
        flush();
        pp_print_break(ppf, 1, 0);
      }
    } else {
      flush();
      pp_force_newline(ppf, undefined);
    }
  };
  if (left.contents !== len) {
    return flush();
  }
  
}

function format_text(fmt6) {
  const skip_and_count_whites = function (_spaces, _newlines, len, s, _pos) {
    while (true) {
      const pos = _pos;
      const newlines = _newlines;
      const spaces = _spaces;
      if (pos >= len) {
        return [
          pos,
          spaces,
          newlines
        ];
      }
      const match = Caml_string.get(s, pos);
      if (match !== 10) {
        if (match !== 32) {
          return [
            pos,
            spaces,
            newlines
          ];
        }
        _pos = 1 + pos | 0;
        _spaces = 1 + spaces | 0;
        continue;
      }
      _pos = 1 + pos | 0;
      _newlines = 1 + newlines | 0;
      continue;
    };
  };
  const cons_dps = function (_dst, _offset, _repeat, $$break, len, s, pos, fmt) {
    while (true) {
      const dst = _dst;
      const offset = _offset;
      const repeat = _repeat;
      if (repeat === 0) {
        if (pos >= len) {
          dst[offset] = fmt;
          return;
        }
        const space = Stdlib__String.index_from_opt(s, pos, /* ' ' */32);
        const newline = Stdlib__String.index_from_opt(s, pos, /* '\n' */10);
        const first = space !== undefined ? (
            newline !== undefined ? (
                space < newline ? space : newline
              ) : space
          ) : newline;
        if (first === undefined) {
          dst[offset] = {
            TAG: /* String_literal */ 11,
            _0: Stdlib__String.sub(s, pos, len - pos | 0),
            _1: fmt
          };
          return;
        }
        const before = Stdlib__String.sub(s, pos, first - pos | 0);
        const match = skip_and_count_whites(0, 0, len, s, first);
        const newlines = match[2];
        let match$1;
        let exit = 0;
        if (newlines === 0 || newlines === 1) {
          exit = 1;
        } else {
          match$1 = [
            newlines,
            /* Force_newline */ 3
          ];
        }
        if (exit === 1) {
          match$1 = [
            1,
            {
              TAG: /* Break */ 0,
              _0: "",
              _1: Caml.caml_int_max(match[1], 1),
              _2: 0
            }
          ];
        }
        const block = {
          TAG: /* String_literal */ 11,
          _0: before,
          _1: 24029
        };
        dst[offset] = block;
        return cons_dps(block, "_1", match$1[0], match$1[1], len, s, match[0], fmt);
      }
      const block$1 = {
        TAG: /* Formatting_lit */ 17,
        _0: $$break,
        _1: 24029
      };
      dst[offset] = block$1;
      _repeat = repeat - 1 | 0;
      _offset = "_1";
      _dst = block$1;
      continue;
    };
  };
  const concat = function (s, fmt) {
    if (s.NAME === "Char") {
      const c = s.VAL;
      if (c !== 10 && c !== 32) {
        return {
          TAG: /* Char_literal */ 12,
          _0: c,
          _1: fmt
        };
      } else {
        let spaces = 1;
        return {
          TAG: /* Formatting_lit */ 17,
          _0: {
            TAG: /* Break */ 0,
            _0: "",
            _1: spaces,
            _2: 0
          },
          _1: fmt
        };
      }
    }
    const s$1 = s.VAL;
    let len = s$1.length;
    let pos = 0;
    if (pos >= len) {
      return fmt;
    }
    const space = Stdlib__String.index_from_opt(s$1, pos, /* ' ' */32);
    const newline = Stdlib__String.index_from_opt(s$1, pos, /* '\n' */10);
    const first = space !== undefined ? (
        newline !== undefined ? (
            space < newline ? space : newline
          ) : space
      ) : newline;
    if (first === undefined) {
      return {
        TAG: /* String_literal */ 11,
        _0: Stdlib__String.sub(s$1, pos, len - pos | 0),
        _1: fmt
      };
    }
    const before = Stdlib__String.sub(s$1, pos, first - pos | 0);
    const match = skip_and_count_whites(0, 0, len, s$1, first);
    const newlines = match[2];
    let match$1;
    let exit = 0;
    if (newlines === 0 || newlines === 1) {
      exit = 1;
    } else {
      match$1 = [
        newlines,
        /* Force_newline */ 3
      ];
    }
    if (exit === 1) {
      match$1 = [
        1,
        {
          TAG: /* Break */ 0,
          _0: "",
          _1: Caml.caml_int_max(match[1], 1),
          _2: 0
        }
      ];
    }
    const block = {
      TAG: /* String_literal */ 11,
      _0: before,
      _1: 24029
    };
    cons_dps(block, "_1", match$1[0], match$1[1], len, s$1, match[0], fmt);
    return block;
  };
  const fmt = CamlinternalFormatBasics.string_concat_map({
    f: concat
  }, fmt6._0);
  return {
    TAG: /* Format */ 0,
    _0: fmt,
    _1: CamlinternalFormat.string_of_fmt(fmt)
  };
}

function pp_print_option(noneOpt, pp_v, ppf, v) {
  const none = noneOpt !== undefined ? noneOpt : (function (param, param$1) {
      
    });
  if (v !== undefined) {
    return Curry._2(pp_v, ppf, Caml_option.valFromOption(v));
  } else {
    return Curry._2(none, ppf, undefined);
  }
}

function pp_print_result(ok, error, ppf, v) {
  if (v.TAG === /* Ok */ 0) {
    return Curry._2(ok, ppf, v._0);
  } else {
    return Curry._2(error, ppf, v._0);
  }
}

function pp_print_either(left, right, ppf, l) {
  if (l.TAG === /* Left */ 0) {
    return Curry._2(left, ppf, l._0);
  } else {
    return Curry._2(right, ppf, l._0);
  }
}

function compute_tag(output, tag_acc) {
  const buf = Stdlib__Buffer.create(16);
  const ppf = formatter_of_buffer(buf);
  Curry._2(output, ppf, tag_acc);
  pp_print_flush(ppf, undefined);
  const len = buf.position;
  if (len < 2) {
    return Stdlib__Buffer.contents(buf);
  } else {
    return Stdlib__Buffer.sub(buf, 1, len - 2 | 0);
  }
}

function output_formatting_lit(ppf, fmting_lit) {
  if (/* tag */ typeof fmting_lit !== "object" && typeof fmting_lit !== "function") {
    switch (fmting_lit) {
      case /* Close_box */ 0 :
        return pp_close_box(ppf, undefined);
      case /* Close_tag */ 1 :
        return pp_close_stag(ppf, undefined);
      case /* FFlush */ 2 :
        return pp_print_flush(ppf, undefined);
      case /* Force_newline */ 3 :
        return pp_force_newline(ppf, undefined);
      case /* Flush_newline */ 4 :
        return pp_print_newline(ppf, undefined);
      case /* Escaped_at */ 5 :
        return pp_print_char(ppf, /* '@' */64);
      case /* Escaped_percent */ 6 :
        return pp_print_char(ppf, /* '%' */37);
    }
  } else {
    switch (fmting_lit.TAG) {
      case /* Break */ 0 :
        return pp_print_break(ppf, fmting_lit._1, fmting_lit._2);
      case /* Magic_size */ 1 :
        return;
      case /* Scan_indic */ 2 :
        pp_print_char(ppf, /* '@' */64);
        return pp_print_char(ppf, fmting_lit._0);
    }
  }
}

function output_acc(ppf, acc) {
  let exit = 0;
  let p;
  let size;
  let s;
  let p$1;
  let size$1;
  let c;
  if (/* tag */ typeof acc !== "object" && typeof acc !== "function") {
    return;
  }
  switch (acc.TAG) {
    case /* Acc_formatting_lit */ 0 :
      output_acc(ppf, acc._0);
      return output_formatting_lit(ppf, acc._1);
    case /* Acc_formatting_gen */ 1 :
      const acc$p = acc._1;
      const p$2 = acc._0;
      if (acc$p.TAG === /* Acc_open_tag */ 0) {
        output_acc(ppf, p$2);
        return pp_open_stag(ppf, {
          MEL_EXN_ID: String_tag,
          _1: compute_tag(output_acc, acc$p._0)
        });
      }
      output_acc(ppf, p$2);
      const match = CamlinternalFormat.open_box_of_string(compute_tag(output_acc, acc$p._0));
      return pp_open_box_gen(ppf, match[0], match[1]);
    case /* Acc_string_literal */ 2 :
      const p$3 = acc._0;
      let exit$1 = 0;
      if (/* tag */ typeof p$3 !== "object" && typeof p$3 !== "function" || p$3.TAG !== /* Acc_formatting_lit */ 0) {
        exit$1 = 3;
      } else {
        const match$1 = p$3._1;
        if (/* tag */ typeof match$1 !== "object" && typeof match$1 !== "function" || match$1.TAG !== /* Magic_size */ 1) {
          exit$1 = 3;
        } else {
          p = p$3._0;
          size = match$1._1;
          s = acc._1;
          exit = 1;
        }
      }
      if (exit$1 === 3) {
        output_acc(ppf, p$3);
        return pp_print_string(ppf, acc._1);
      }
      break;
    case /* Acc_char_literal */ 3 :
      const p$4 = acc._0;
      let exit$2 = 0;
      if (/* tag */ typeof p$4 !== "object" && typeof p$4 !== "function" || p$4.TAG !== /* Acc_formatting_lit */ 0) {
        exit$2 = 3;
      } else {
        const match$2 = p$4._1;
        if (/* tag */ typeof match$2 !== "object" && typeof match$2 !== "function" || match$2.TAG !== /* Magic_size */ 1) {
          exit$2 = 3;
        } else {
          p$1 = p$4._0;
          size$1 = match$2._1;
          c = acc._1;
          exit = 2;
        }
      }
      if (exit$2 === 3) {
        output_acc(ppf, p$4);
        return pp_print_char(ppf, acc._1);
      }
      break;
    case /* Acc_data_string */ 4 :
      const p$5 = acc._0;
      let exit$3 = 0;
      if (/* tag */ typeof p$5 !== "object" && typeof p$5 !== "function" || p$5.TAG !== /* Acc_formatting_lit */ 0) {
        exit$3 = 3;
      } else {
        const match$3 = p$5._1;
        if (/* tag */ typeof match$3 !== "object" && typeof match$3 !== "function" || match$3.TAG !== /* Magic_size */ 1) {
          exit$3 = 3;
        } else {
          p = p$5._0;
          size = match$3._1;
          s = acc._1;
          exit = 1;
        }
      }
      if (exit$3 === 3) {
        output_acc(ppf, p$5);
        return pp_print_string(ppf, acc._1);
      }
      break;
    case /* Acc_data_char */ 5 :
      const p$6 = acc._0;
      let exit$4 = 0;
      if (/* tag */ typeof p$6 !== "object" && typeof p$6 !== "function" || p$6.TAG !== /* Acc_formatting_lit */ 0) {
        exit$4 = 3;
      } else {
        const match$4 = p$6._1;
        if (/* tag */ typeof match$4 !== "object" && typeof match$4 !== "function" || match$4.TAG !== /* Magic_size */ 1) {
          exit$4 = 3;
        } else {
          p$1 = p$6._0;
          size$1 = match$4._1;
          c = acc._1;
          exit = 2;
        }
      }
      if (exit$4 === 3) {
        output_acc(ppf, p$6);
        return pp_print_char(ppf, acc._1);
      }
      break;
    case /* Acc_delay */ 6 :
      output_acc(ppf, acc._0);
      return Curry._1(acc._1, ppf);
    case /* Acc_flush */ 7 :
      output_acc(ppf, acc._0);
      return pp_print_flush(ppf, undefined);
    case /* Acc_invalid_arg */ 8 :
      output_acc(ppf, acc._0);
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: acc._1
        });
  }
  switch (exit) {
    case 1 :
      output_acc(ppf, p);
      return pp_print_as_size(ppf, size, s);
    case 2 :
      output_acc(ppf, p$1);
      return pp_print_as_size(ppf, size$1, Caml_bytes.bytes_to_string(Stdlib__Bytes.make(1, c)));
  }
}

function strput_acc(ppf, acc) {
  let exit = 0;
  let p;
  let size;
  let s;
  let p$1;
  let size$1;
  let c;
  if (/* tag */ typeof acc !== "object" && typeof acc !== "function") {
    return;
  }
  switch (acc.TAG) {
    case /* Acc_formatting_lit */ 0 :
      strput_acc(ppf, acc._0);
      return output_formatting_lit(ppf, acc._1);
    case /* Acc_formatting_gen */ 1 :
      const acc$p = acc._1;
      const p$2 = acc._0;
      if (acc$p.TAG === /* Acc_open_tag */ 0) {
        strput_acc(ppf, p$2);
        return pp_open_stag(ppf, {
          MEL_EXN_ID: String_tag,
          _1: compute_tag(strput_acc, acc$p._0)
        });
      }
      strput_acc(ppf, p$2);
      const match = CamlinternalFormat.open_box_of_string(compute_tag(strput_acc, acc$p._0));
      return pp_open_box_gen(ppf, match[0], match[1]);
    case /* Acc_string_literal */ 2 :
      const p$3 = acc._0;
      let exit$1 = 0;
      if (/* tag */ typeof p$3 !== "object" && typeof p$3 !== "function" || p$3.TAG !== /* Acc_formatting_lit */ 0) {
        exit$1 = 3;
      } else {
        const match$1 = p$3._1;
        if (/* tag */ typeof match$1 !== "object" && typeof match$1 !== "function" || match$1.TAG !== /* Magic_size */ 1) {
          exit$1 = 3;
        } else {
          p = p$3._0;
          size = match$1._1;
          s = acc._1;
          exit = 1;
        }
      }
      if (exit$1 === 3) {
        strput_acc(ppf, p$3);
        return pp_print_string(ppf, acc._1);
      }
      break;
    case /* Acc_char_literal */ 3 :
      const p$4 = acc._0;
      let exit$2 = 0;
      if (/* tag */ typeof p$4 !== "object" && typeof p$4 !== "function" || p$4.TAG !== /* Acc_formatting_lit */ 0) {
        exit$2 = 3;
      } else {
        const match$2 = p$4._1;
        if (/* tag */ typeof match$2 !== "object" && typeof match$2 !== "function" || match$2.TAG !== /* Magic_size */ 1) {
          exit$2 = 3;
        } else {
          p$1 = p$4._0;
          size$1 = match$2._1;
          c = acc._1;
          exit = 2;
        }
      }
      if (exit$2 === 3) {
        strput_acc(ppf, p$4);
        return pp_print_char(ppf, acc._1);
      }
      break;
    case /* Acc_data_string */ 4 :
      const p$5 = acc._0;
      let exit$3 = 0;
      if (/* tag */ typeof p$5 !== "object" && typeof p$5 !== "function" || p$5.TAG !== /* Acc_formatting_lit */ 0) {
        exit$3 = 3;
      } else {
        const match$3 = p$5._1;
        if (/* tag */ typeof match$3 !== "object" && typeof match$3 !== "function" || match$3.TAG !== /* Magic_size */ 1) {
          exit$3 = 3;
        } else {
          p = p$5._0;
          size = match$3._1;
          s = acc._1;
          exit = 1;
        }
      }
      if (exit$3 === 3) {
        strput_acc(ppf, p$5);
        return pp_print_string(ppf, acc._1);
      }
      break;
    case /* Acc_data_char */ 5 :
      const p$6 = acc._0;
      let exit$4 = 0;
      if (/* tag */ typeof p$6 !== "object" && typeof p$6 !== "function" || p$6.TAG !== /* Acc_formatting_lit */ 0) {
        exit$4 = 3;
      } else {
        const match$4 = p$6._1;
        if (/* tag */ typeof match$4 !== "object" && typeof match$4 !== "function" || match$4.TAG !== /* Magic_size */ 1) {
          exit$4 = 3;
        } else {
          p$1 = p$6._0;
          size$1 = match$4._1;
          c = acc._1;
          exit = 2;
        }
      }
      if (exit$4 === 3) {
        strput_acc(ppf, p$6);
        return pp_print_char(ppf, acc._1);
      }
      break;
    case /* Acc_delay */ 6 :
      const p$7 = acc._0;
      let exit$5 = 0;
      if (/* tag */ typeof p$7 !== "object" && typeof p$7 !== "function" || p$7.TAG !== /* Acc_formatting_lit */ 0) {
        exit$5 = 3;
      } else {
        const match$5 = p$7._1;
        if (/* tag */ typeof match$5 !== "object" && typeof match$5 !== "function") {
          exit$5 = 3;
        } else {
          if (match$5.TAG === /* Magic_size */ 1) {
            strput_acc(ppf, p$7._0);
            return pp_print_as_size(ppf, match$5._1, Curry._1(acc._1, undefined));
          }
          exit$5 = 3;
        }
      }
      if (exit$5 === 3) {
        strput_acc(ppf, p$7);
        return pp_print_string(ppf, Curry._1(acc._1, undefined));
      }
      break;
    case /* Acc_flush */ 7 :
      strput_acc(ppf, acc._0);
      return pp_print_flush(ppf, undefined);
    case /* Acc_invalid_arg */ 8 :
      strput_acc(ppf, acc._0);
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: acc._1
        });
  }
  switch (exit) {
    case 1 :
      strput_acc(ppf, p);
      return pp_print_as_size(ppf, size, s);
    case 2 :
      strput_acc(ppf, p$1);
      return pp_print_as_size(ppf, size$1, Caml_bytes.bytes_to_string(Stdlib__Bytes.make(1, c)));
  }
}

function kfprintf(k, ppf, param) {
  return CamlinternalFormat.make_printf((function (acc) {
    output_acc(ppf, acc);
    return Curry._1(k, ppf);
  }), /* End_of_acc */ 0, param._0);
}

function ikfprintf(k, ppf, param) {
  return CamlinternalFormat.make_iprintf(k, ppf, param._0);
}

function ifprintf(_ppf, param) {
  return CamlinternalFormat.make_iprintf((function (prim) {
    
  }), undefined, param._0);
}

function fprintf(ppf) {
  return function (param) {
    return kfprintf((function (prim) {
      
    }), ppf, param);
  };
}

function printf(param) {
  return CamlinternalFormat.make_printf((function (acc) {
    output_acc(Stdlib__Domain.DLS.get(std_formatter_key), acc);
  }), /* End_of_acc */ 0, param._0);
}

function eprintf(param) {
  return CamlinternalFormat.make_printf((function (acc) {
    output_acc(Stdlib__Domain.DLS.get(err_formatter_key), acc);
  }), /* End_of_acc */ 0, param._0);
}

function kdprintf(k, param) {
  return CamlinternalFormat.make_printf((function (acc) {
    return Curry._1(k, (function (ppf) {
      output_acc(ppf, acc);
    }));
  }), /* End_of_acc */ 0, param._0);
}

function dprintf(fmt) {
  return kdprintf((function (i) {
    return i;
  }), fmt);
}

function ksprintf(k, param) {
  const b = Stdlib__Buffer.create(512);
  const ppf = formatter_of_buffer(b);
  const k$1 = function (acc) {
    strput_acc(ppf, acc);
    return Curry._1(k, flush_buffer_formatter(b, ppf));
  };
  return CamlinternalFormat.make_printf(k$1, /* End_of_acc */ 0, param._0);
}

function sprintf(fmt) {
  return ksprintf(id, fmt);
}

function kasprintf(k, param) {
  const b = Stdlib__Buffer.create(512);
  const ppf = formatter_of_buffer(b);
  const k$1 = function (acc) {
    output_acc(ppf, acc);
    return Curry._1(k, flush_buffer_formatter(b, ppf));
  };
  return CamlinternalFormat.make_printf(k$1, /* End_of_acc */ 0, param._0);
}

function asprintf(fmt) {
  return kasprintf(id, fmt);
}

function flush_standard_formatters(param) {
  pp_print_flush(Stdlib__Domain.DLS.get(std_formatter_key), undefined);
  pp_print_flush(Stdlib__Domain.DLS.get(err_formatter_key), undefined);
}

Stdlib.at_exit(flush_standard_formatters);

Stdlib__Domain.before_first_spawn(function (param) {
  flush_standard_formatters();
  const fs = pp_get_formatter_out_functions(std_formatter, undefined);
  pp_set_formatter_out_functions(std_formatter, {
    out_string: (function (param, param$1, param$2) {
      return buffered_out_string(std_buf_key, param, param$1, param$2);
    }),
    out_width: fs.out_width,
    out_flush: (function (param) {
      return buffered_out_flush(Stdlib.stdout, std_buf_key, param);
    }),
    out_newline: fs.out_newline,
    out_spaces: fs.out_spaces,
    out_indent: fs.out_indent
  });
  const fs$1 = pp_get_formatter_out_functions(err_formatter, undefined);
  pp_set_formatter_out_functions(err_formatter, {
    out_string: (function (param, param$1, param$2) {
      return buffered_out_string(err_buf_key, param, param$1, param$2);
    }),
    out_width: fs$1.out_width,
    out_flush: (function (param) {
      return buffered_out_flush(Stdlib.stderr, err_buf_key, param);
    }),
    out_newline: fs$1.out_newline,
    out_spaces: fs$1.out_spaces,
    out_indent: fs$1.out_indent
  });
});

const pp_infinity = 1000000010;

export {
  pp_open_box,
  open_box,
  pp_close_box,
  close_box,
  pp_open_hbox,
  open_hbox,
  pp_open_vbox,
  open_vbox,
  pp_open_hvbox,
  open_hvbox,
  pp_open_hovbox,
  open_hovbox,
  pp_print_string,
  print_string,
  pp_print_substring,
  print_substring,
  pp_print_bytes,
  print_bytes,
  pp_print_as,
  print_as,
  pp_print_substring_as,
  print_substring_as,
  pp_print_int,
  print_int,
  pp_print_float,
  print_float,
  pp_print_char,
  print_char,
  pp_print_bool,
  print_bool,
  pp_print_nothing,
  pp_print_space,
  print_space,
  pp_print_cut,
  print_cut,
  pp_print_break,
  print_break,
  pp_print_custom_break,
  pp_force_newline,
  force_newline,
  pp_print_if_newline,
  print_if_newline,
  pp_print_flush,
  print_flush,
  pp_print_newline,
  print_newline,
  pp_infinity,
  pp_set_margin,
  set_margin,
  pp_get_margin,
  get_margin,
  pp_set_max_indent,
  set_max_indent,
  pp_get_max_indent,
  get_max_indent,
  check_geometry,
  pp_set_geometry,
  set_geometry,
  pp_safe_set_geometry,
  safe_set_geometry,
  pp_update_geometry,
  update_geometry,
  pp_get_geometry,
  get_geometry,
  pp_set_max_boxes,
  set_max_boxes,
  pp_get_max_boxes,
  get_max_boxes,
  pp_over_max_boxes,
  over_max_boxes,
  pp_open_tbox,
  open_tbox,
  pp_close_tbox,
  close_tbox,
  pp_set_tab,
  set_tab,
  pp_print_tab,
  print_tab,
  pp_print_tbreak,
  print_tbreak,
  pp_set_ellipsis_text,
  set_ellipsis_text,
  pp_get_ellipsis_text,
  get_ellipsis_text,
  String_tag,
  pp_open_stag,
  open_stag,
  pp_close_stag,
  close_stag,
  pp_set_tags,
  set_tags,
  pp_set_print_tags,
  set_print_tags,
  pp_set_mark_tags,
  set_mark_tags,
  pp_get_print_tags,
  get_print_tags,
  pp_get_mark_tags,
  get_mark_tags,
  pp_set_formatter_out_channel,
  set_formatter_out_channel,
  pp_set_formatter_output_functions,
  set_formatter_output_functions,
  pp_get_formatter_output_functions,
  get_formatter_output_functions,
  pp_set_formatter_out_functions,
  set_formatter_out_functions,
  pp_get_formatter_out_functions,
  get_formatter_out_functions,
  utf_8_scalar_width,
  ascii_width,
  pp_set_formatter_stag_functions,
  set_formatter_stag_functions,
  pp_get_formatter_stag_functions,
  get_formatter_stag_functions,
  formatter_of_out_channel,
  synchronized_formatter_of_out_channel,
  std_formatter,
  get_std_formatter,
  err_formatter,
  get_err_formatter,
  formatter_of_buffer,
  stdbuf,
  get_stdbuf,
  str_formatter,
  get_str_formatter,
  flush_str_formatter,
  make_formatter,
  make_synchronized_formatter,
  formatter_of_out_functions,
  make_symbolic_output_buffer,
  clear_symbolic_output_buffer,
  get_symbolic_output_buffer,
  flush_symbolic_output_buffer,
  add_symbolic_output_item,
  formatter_of_symbolic_output_buffer,
  pp_print_iter,
  pp_print_list,
  pp_print_array,
  pp_print_seq,
  pp_print_text,
  format_text,
  pp_print_option,
  pp_print_result,
  pp_print_either,
  fprintf,
  printf,
  eprintf,
  sprintf,
  asprintf,
  dprintf,
  ifprintf,
  kfprintf,
  kdprintf,
  ikfprintf,
  ksprintf,
  kasprintf,
}
/* blank_line Not a pure module */
