// Generated by Melange

import * as Caml from "melange.js/caml.mjs";
import * as Caml_array from "melange.js/caml_array.mjs";
import * as Caml_exceptions from "melange.js/caml_exceptions.mjs";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.mjs";
import * as Caml_obj from "melange.js/caml_obj.mjs";
import * as Caml_option from "melange.js/caml_option.mjs";
import * as CamlinternalOO from "./camlinternalOO.mjs";
import * as Curry from "melange.js/curry.mjs";
import * as Stdlib from "./stdlib.mjs";
import * as Stdlib__Array from "./array.mjs";
import * as Stdlib__Obj from "./obj.mjs";
import * as Stdlib__Printf from "./printf.mjs";
import * as Stdlib__Seq from "./seq.mjs";
import * as Stdlib__Sys from "./sys.mjs";

const object_tables = {
  TAG: /* Cons */ 0,
  key: undefined,
  data: undefined,
  next: undefined
};

function fresh(param) {
  const r = {
    contents: undefined
  };
  if (!object_tables.key) {
    const $$class = CamlinternalOO.create_table(0);
    const x = CamlinternalOO.new_variable($$class, "x");
    const env_init = function (env) {
      const self = CamlinternalOO.create_object_opt(undefined, $$class);
      self[x] = env[1];
      return self;
    };
    CamlinternalOO.init_class($$class);
    object_tables.key = env_init;
  }
  const envs = [
    undefined,
    r
  ];
  const dummy = Curry._1(object_tables.key, envs);
  r.contents = Caml_option.some(dummy);
  return {
    TAG: /* Fresh */ 0,
    _0: dummy
  };
}

function make(n, x, dummy) {
  if (x.TAG !== Stdlib__Obj.double_tag) {
    return Caml_array.make(n, x);
  }
  const arr = Caml_array.make(n, dummy);
  Stdlib__Array.fill(arr, 0, n, x);
  return arr;
}

function copy_from_array(a, dummy) {
  if (a.TAG !== Stdlib__Obj.double_array_tag) {
    return Stdlib__Array.copy(a);
  }
  const n = a.length;
  const arr = Caml_array.make(n, dummy);
  for (let i = 0; i < n; ++i) {
    arr[i] = a[i];
  }
  return arr;
}

function unsafe_nocopy_from_array(a, dummy) {
  if (a.TAG !== Stdlib__Obj.double_array_tag) {
    return a;
  } else {
    return copy_from_array(a, dummy);
  }
}

const Dummy_found = /* @__PURE__ */ Caml_exceptions.create("Stdlib.Dynarray.Dummy.Array.Dummy_found");

function unsafe_nocopy_to_array(a, dummy) {
  let arr;
  if (a.length === 0 || Caml_array.get(a, 0).TAG !== Stdlib__Obj.double_tag) {
    arr = a;
  } else {
    const n = a.length;
    const a$p = Caml_array.make(n, Caml_array.get(a, 0));
    for (let i = 1; i < n; ++i) {
      a$p[i] = a[i];
    }
    arr = a$p;
  }
  Stdlib__Array.iteri((function (i, v) {
    if (v !== dummy) {
      return;
    }
    throw new Caml_js_exceptions.MelangeError(Dummy_found, {
        MEL_EXN_ID: Dummy_found,
        _1: i
      });
  }), arr);
  return arr;
}

function init(n, f, dummy) {
  const arr = Caml_array.make(n, dummy);
  for (let i = 0; i < n; ++i) {
    arr[i] = Curry._1(f, i);
  }
  return arr;
}

function blit_array(src, src_pos, dst, dst_pos, len) {
  if (src.TAG !== Stdlib__Obj.double_array_tag) {
    return Stdlib__Array.blit(src, src_pos, dst, dst_pos, len);
  }
  for (let i = 0; i < len; ++i) {
    Caml_array.set(dst, dst_pos + i | 0, Caml_array.get(src, src_pos + i | 0));
  }
}

function blit(src, src_dummy, src_pos, dst, dst_dummy, dst_pos, len) {
  if (src_dummy === dst_dummy) {
    return Stdlib__Array.blit(src, src_pos, dst, dst_pos, len);
  }
  if (len < 0 || src_pos < 0 || (src_pos + len | 0) < 0 || (src_pos + len | 0) > src.length || dst_pos < 0 || (dst_pos + len | 0) < 0 || (dst_pos + len | 0) > dst.length) {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "dynarray.cppo.ml",
          317,
          13
        ]
      });
  }
  if (src === dst) {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "dynarray.cppo.ml",
          327,
          8
        ]
      });
  }
  for (let i = 0; i < len; ++i) {
    dst[dst_pos + i | 0] = src[src_pos + i | 0];
  }
}

function prefix(arr, n) {
  return Stdlib__Array.sub(arr, 0, n);
}

function extend(arr, length, dummy, new_capacity) {
  const new_arr = Caml_array.make(new_capacity, dummy);
  Stdlib__Array.blit(arr, 0, new_arr, 0, length);
  return new_arr;
}

const Dummy_Array = {
  make: make,
  init: init,
  copy_from_array: copy_from_array,
  unsafe_nocopy_from_array: unsafe_nocopy_from_array,
  Dummy_found: Dummy_found,
  unsafe_nocopy_to_array: unsafe_nocopy_to_array,
  blit_array: blit_array,
  blit: blit,
  prefix: prefix,
  extend: extend
};

const global_dummy = fresh();

function index_out_of_bounds(f, i, length) {
  if (length === 0) {
    return Curry._2(Stdlib__Printf.ksprintf(Stdlib.invalid_arg, {
      TAG: /* Format */ 0,
      _0: {
        TAG: /* String_literal */ 11,
        _0: "Dynarray.",
        _1: {
          TAG: /* String */ 2,
          _0: /* No_padding */ 0,
          _1: {
            TAG: /* String_literal */ 11,
            _0: ": index ",
            _1: {
              TAG: /* Int */ 4,
              _0: /* Int_d */ 0,
              _1: /* No_padding */ 0,
              _2: /* No_precision */ 0,
              _3: {
                TAG: /* String_literal */ 11,
                _0: " out of bounds (empty dynarray)",
                _1: /* End_of_format */ 0
              }
            }
          }
        }
      },
      _1: "Dynarray.%s: index %d out of bounds (empty dynarray)"
    }), f, i);
  } else {
    return Curry._3(Stdlib__Printf.ksprintf(Stdlib.invalid_arg, {
      TAG: /* Format */ 0,
      _0: {
        TAG: /* String_literal */ 11,
        _0: "Dynarray.",
        _1: {
          TAG: /* String */ 2,
          _0: /* No_padding */ 0,
          _1: {
            TAG: /* String_literal */ 11,
            _0: ": index ",
            _1: {
              TAG: /* Int */ 4,
              _0: /* Int_d */ 0,
              _1: /* No_padding */ 0,
              _2: /* No_precision */ 0,
              _3: {
                TAG: /* String_literal */ 11,
                _0: " out of bounds (0..",
                _1: {
                  TAG: /* Int */ 4,
                  _0: /* Int_d */ 0,
                  _1: /* No_padding */ 0,
                  _2: /* No_precision */ 0,
                  _3: {
                    TAG: /* Char_literal */ 12,
                    _0: /* ')' */41,
                    _1: /* End_of_format */ 0
                  }
                }
              }
            }
          }
        }
      },
      _1: "Dynarray.%s: index %d out of bounds (0..%d)"
    }), f, i, length - 1 | 0);
  }
}

function negative_length_requested(f, n) {
  return Curry._2(Stdlib__Printf.ksprintf(Stdlib.invalid_arg, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "Dynarray.",
      _1: {
        TAG: /* String */ 2,
        _0: /* No_padding */ 0,
        _1: {
          TAG: /* String_literal */ 11,
          _0: ": negative length ",
          _1: {
            TAG: /* Int */ 4,
            _0: /* Int_d */ 0,
            _1: /* No_padding */ 0,
            _2: /* No_precision */ 0,
            _3: {
              TAG: /* String_literal */ 11,
              _0: " requested",
              _1: /* End_of_format */ 0
            }
          }
        }
      }
    },
    _1: "Dynarray.%s: negative length %d requested"
  }), f, n);
}

function negative_capacity_requested(f, n) {
  return Curry._2(Stdlib__Printf.ksprintf(Stdlib.invalid_arg, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "Dynarray.",
      _1: {
        TAG: /* String */ 2,
        _0: /* No_padding */ 0,
        _1: {
          TAG: /* String_literal */ 11,
          _0: ": negative capacity ",
          _1: {
            TAG: /* Int */ 4,
            _0: /* Int_d */ 0,
            _1: /* No_padding */ 0,
            _2: /* No_precision */ 0,
            _3: {
              TAG: /* String_literal */ 11,
              _0: " requested",
              _1: /* End_of_format */ 0
            }
          }
        }
      }
    },
    _1: "Dynarray.%s: negative capacity %d requested"
  }), f, n);
}

function requested_length_out_of_bounds(f, requested_length) {
  return Curry._3(Stdlib__Printf.ksprintf(Stdlib.invalid_arg, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "Dynarray.",
      _1: {
        TAG: /* String */ 2,
        _0: /* No_padding */ 0,
        _1: {
          TAG: /* String_literal */ 11,
          _0: ": cannot grow to requested length ",
          _1: {
            TAG: /* Int */ 4,
            _0: /* Int_d */ 0,
            _1: /* No_padding */ 0,
            _2: /* No_precision */ 0,
            _3: {
              TAG: /* String_literal */ 11,
              _0: " (max_array_length is ",
              _1: {
                TAG: /* Int */ 4,
                _0: /* Int_d */ 0,
                _1: /* No_padding */ 0,
                _2: /* No_precision */ 0,
                _3: {
                  TAG: /* Char_literal */ 12,
                  _0: /* ')' */41,
                  _1: /* End_of_format */ 0
                }
              }
            }
          }
        }
      }
    },
    _1: "Dynarray.%s: cannot grow to requested length %d (max_array_length is %d)"
  }), f, requested_length, Stdlib__Sys.max_array_length);
}

const invalid_state_description = "Invalid dynarray (unsynchronized concurrent length change)";

function missing_element(i, length) {
  return Curry._3(Stdlib__Printf.ksprintf(Stdlib.invalid_arg, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String */ 2,
      _0: /* No_padding */ 0,
      _1: {
        TAG: /* String_literal */ 11,
        _0: ": missing element at position ",
        _1: {
          TAG: /* Int */ 4,
          _0: /* Int_d */ 0,
          _1: /* No_padding */ 0,
          _2: /* No_precision */ 0,
          _3: {
            TAG: /* String_literal */ 11,
            _0: " < length ",
            _1: {
              TAG: /* Int */ 4,
              _0: /* Int_d */ 0,
              _1: /* No_padding */ 0,
              _2: /* No_precision */ 0,
              _3: /* End_of_format */ 0
            }
          }
        }
      }
    },
    _1: "%s: missing element at position %d < length %d"
  }), invalid_state_description, i, length);
}

function invalid_length(length, capacity) {
  return Curry._3(Stdlib__Printf.ksprintf(Stdlib.invalid_arg, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String */ 2,
      _0: /* No_padding */ 0,
      _1: {
        TAG: /* String_literal */ 11,
        _0: ": length ",
        _1: {
          TAG: /* Int */ 4,
          _0: /* Int_d */ 0,
          _1: /* No_padding */ 0,
          _2: /* No_precision */ 0,
          _3: {
            TAG: /* String_literal */ 11,
            _0: " > capacity ",
            _1: {
              TAG: /* Int */ 4,
              _0: /* Int_d */ 0,
              _1: /* No_padding */ 0,
              _2: /* No_precision */ 0,
              _3: /* End_of_format */ 0
            }
          }
        }
      }
    },
    _1: "%s: length %d > capacity %d"
  }), invalid_state_description, length, capacity);
}

function length_change_during_iteration(f, expected, observed) {
  return Curry._3(Stdlib__Printf.ksprintf(Stdlib.invalid_arg, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "Dynarray.",
      _1: {
        TAG: /* String */ 2,
        _0: /* No_padding */ 0,
        _1: {
          TAG: /* String_literal */ 11,
          _0: ": a length change from ",
          _1: {
            TAG: /* Int */ 4,
            _0: /* Int_d */ 0,
            _1: /* No_padding */ 0,
            _2: /* No_precision */ 0,
            _3: {
              TAG: /* String_literal */ 11,
              _0: " to ",
              _1: {
                TAG: /* Int */ 4,
                _0: /* Int_d */ 0,
                _1: /* No_padding */ 0,
                _2: /* No_precision */ 0,
                _3: {
                  TAG: /* String_literal */ 11,
                  _0: " occurred during iteration",
                  _1: /* End_of_format */ 0
                }
              }
            }
          }
        }
      }
    },
    _1: "Dynarray.%s: a length change from %d to %d occurred during iteration"
  }), f, expected, observed);
}

function unexpected_empty_element(f, i, length) {
  if (i < length) {
    return missing_element(i, length);
  } else {
    return index_out_of_bounds(f, i, length);
  }
}

function empty_dynarray(f) {
  return Curry._1(Stdlib__Printf.ksprintf(Stdlib.invalid_arg, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "Dynarray.",
      _1: {
        TAG: /* String */ 2,
        _0: /* No_padding */ 0,
        _1: {
          TAG: /* String_literal */ 11,
          _0: ": empty array",
          _1: /* End_of_format */ 0
        }
      }
    },
    _1: "Dynarray.%s: empty array"
  }), f);
}

function different_lengths(f, length1, length2) {
  return Curry._3(Stdlib__Printf.ksprintf(Stdlib.invalid_arg, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "Dynarray.",
      _1: {
        TAG: /* String */ 2,
        _0: /* No_padding */ 0,
        _1: {
          TAG: /* String_literal */ 11,
          _0: ": array length mismatch: ",
          _1: {
            TAG: /* Int */ 4,
            _0: /* Int_d */ 0,
            _1: /* No_padding */ 0,
            _2: /* No_precision */ 0,
            _3: {
              TAG: /* String_literal */ 11,
              _0: " <> ",
              _1: {
                TAG: /* Int */ 4,
                _0: /* Int_d */ 0,
                _1: /* No_padding */ 0,
                _2: /* No_precision */ 0,
                _3: /* End_of_format */ 0
              }
            }
          }
        }
      }
    },
    _1: "Dynarray.%s: array length mismatch: %d <> %d"
  }), f, length1, length2);
}

function check_same_length(f, a, length) {
  const length_a = a.length;
  if (length !== length_a) {
    return length_change_during_iteration(f, length, length_a);
  }
  
}

function create(param) {
  return {
    length: 0,
    arr: [],
    dummy: global_dummy._0
  };
}

function make$1(n, x) {
  if (n < 0) {
    negative_length_requested("make", n);
  }
  const dummy = global_dummy._0;
  const arr = Curry._3(Dummy_Array.make, n, x, dummy);
  return {
    length: n,
    arr: arr,
    dummy: dummy
  };
}

function init$1(n, f) {
  if (n < 0) {
    negative_length_requested("init", n);
  }
  const dummy = global_dummy._0;
  const arr = Curry._3(Dummy_Array.init, n, f, dummy);
  return {
    length: n,
    arr: arr,
    dummy: dummy
  };
}

function get(a, i) {
  const v = Caml_array.get(a.arr, i);
  if (v === a.dummy) {
    return unexpected_empty_element("get", i, a.length);
  } else {
    return v;
  }
}

function set(a, i, x) {
  const length = a.length;
  const arr = a.arr;
  if (i >= length) {
    return index_out_of_bounds("set", i, length);
  } else {
    return Caml_array.set(arr, i, x);
  }
}

function length(a) {
  return a.length;
}

function is_empty(a) {
  return a.length === 0;
}

function copy(param) {
  const length = param.length;
  const arr = param.arr;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const arr$1 = Curry._2(Dummy_Array.prefix, arr, length);
  return {
    length: length,
    arr: arr$1,
    dummy: param.dummy
  };
}

function get_last(a) {
  const length = a.length;
  const arr = a.arr;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  if (length === 0) {
    empty_dynarray("get_last");
  }
  const i = length - 1 | 0;
  const v = arr[i];
  if (v === a.dummy) {
    return missing_element(i, length);
  } else {
    return v;
  }
}

function find_last(a) {
  const length = a.length;
  const arr = a.arr;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  if (length === 0) {
    return;
  }
  const i = length - 1 | 0;
  const v = arr[i];
  return Caml_option.some(v === a.dummy ? missing_element(i, length) : v);
}

function pop_last(a) {
  const length = a.length;
  const arr = a.arr;
  const dummy = a.dummy;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  if (length === 0) {
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
        MEL_EXN_ID: Stdlib.Not_found
      });
  }
  const last = length - 1 | 0;
  const v = arr[last];
  const v$1 = v === dummy ? missing_element(last, length) : v;
  arr[last] = dummy;
  a.length = last;
  return v$1;
}

function pop_last_opt(a) {
  let x;
  try {
    x = pop_last(a);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return;
    }
    throw exn;
  }
  return Caml_option.some(x);
}

function remove_last(a) {
  const last = a.length - 1 | 0;
  if (last >= 0) {
    a.length = last;
    return Caml_array.set(a.arr, last, a.dummy);
  }
  
}

function truncate(a, n) {
  if (n < 0) {
    negative_length_requested("truncate", n);
  }
  const length = a.length;
  const arr = a.arr;
  if (length <= n) {
    return;
  } else {
    a.length = n;
    return Stdlib__Array.fill(arr, n, length - n | 0, a.dummy);
  }
}

function clear(a) {
  truncate(a, 0);
}

function capacity(a) {
  return a.arr.length;
}

function next_capacity(n) {
  const n$p = n <= 512 ? (n << 1) : n + (n / 2 | 0) | 0;
  return Caml.caml_int_min(8 > n$p ? 8 : n$p, Stdlib__Sys.max_array_length);
}

function ensure_capacity(a, capacity_request) {
  const arr = a.arr;
  const cur_capacity = arr.length;
  if (capacity_request < 0) {
    return negative_capacity_requested("ensure_capacity", capacity_request);
  }
  if (cur_capacity >= capacity_request) {
    return;
  }
  if (capacity_request > Stdlib__Sys.max_array_length) {
    requested_length_out_of_bounds("ensure_capacity", capacity_request);
  }
  const new_capacity = Caml.caml_int_max(next_capacity(cur_capacity), capacity_request);
  if (new_capacity <= 0) {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "dynarray.cppo.ml",
          639,
          4
        ]
      });
  }
  const new_arr = Curry._4(Dummy_Array.extend, arr, a.length, a.dummy, new_capacity);
  a.arr = new_arr;
  if (0 > capacity_request) {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "dynarray.cppo.ml",
          644,
          4
        ]
      });
  }
  if (capacity_request <= new_arr.length) {
    return;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
      MEL_EXN_ID: "Assert_failure",
      _1: [
        "dynarray.cppo.ml",
        645,
        4
      ]
    });
}

function ensure_extra_capacity(a, extra_capacity_request) {
  ensure_capacity(a, a.length + extra_capacity_request | 0);
}

function fit_capacity(a) {
  if (a.arr.length === a.length) {
    return;
  } else {
    a.arr = Curry._2(Dummy_Array.prefix, a.arr, a.length);
    return;
  }
}

function set_capacity(a, n) {
  if (n < 0) {
    negative_capacity_requested("set_capacity", n);
  }
  const arr = a.arr;
  const cur_capacity = arr.length;
  if (n < cur_capacity) {
    a.length = a.length < n ? a.length : n;
    a.arr = Curry._2(Dummy_Array.prefix, arr, n);
    return;
  } else if (n > cur_capacity) {
    a.arr = Curry._4(Dummy_Array.extend, arr, a.length, a.dummy, n);
    return;
  } else {
    return;
  }
}

function reset(a) {
  a.length = 0;
  a.arr = [];
}

function add_last(a, x) {
  const length = a.length;
  const arr = a.arr;
  if (length >= arr.length ? false : (a.length = length + 1 | 0, arr[length] = x, true)) {
    return;
  }
  while (true) {
    ensure_extra_capacity(a, 1);
    const length$1 = a.length;
    const arr$1 = a.arr;
    if (length$1 >= arr$1.length ? false : (a.length = length$1 + 1 | 0, arr$1[length$1] = x, true)) {
      return;
    }
    continue;
  };
}

function append_list(a, _li) {
  while (true) {
    const li = _li;
    if (!li) {
      return;
    }
    add_last(a, li.hd);
    _li = li.tl;
    continue;
  };
}

function append_iter(a, iter, b) {
  return Curry._2(iter, (function (x) {
    add_last(a, x);
  }), b);
}

function append_seq(a, seq) {
  Stdlib__Seq.iter((function (x) {
    add_last(a, x);
  }), seq);
}

function blit_assume_room(src, src_pos, src_length, dst, dst_pos, dst_length, blit_length) {
  const src_arr = src.arr;
  const dst_arr = dst.arr;
  check_same_length("blit", src, src_length);
  check_same_length("blit", dst, dst_length);
  if ((dst_pos + blit_length | 0) > dst_length) {
    dst.length = dst_pos + blit_length | 0;
  }
  Curry._7(Dummy_Array.blit, src_arr, src.dummy, src_pos, dst_arr, dst.dummy, dst_pos, blit_length);
}

function blit$1(src, src_pos, dst, dst_pos, len) {
  const src_length = src.length;
  const dst_length = dst.length;
  if (len < 0) {
    Curry._1(Stdlib__Printf.ksprintf(Stdlib.invalid_arg, {
      TAG: /* Format */ 0,
      _0: {
        TAG: /* String_literal */ 11,
        _0: "Dynarray.blit: invalid blit length (",
        _1: {
          TAG: /* Int */ 4,
          _0: /* Int_d */ 0,
          _1: /* No_padding */ 0,
          _2: /* No_precision */ 0,
          _3: {
            TAG: /* Char_literal */ 12,
            _0: /* ')' */41,
            _1: /* End_of_format */ 0
          }
        }
      },
      _1: "Dynarray.blit: invalid blit length (%d)"
    }), len);
  }
  if (src_pos < 0 || (src_pos + len | 0) > src_length) {
    Curry._3(Stdlib__Printf.ksprintf(Stdlib.invalid_arg, {
      TAG: /* Format */ 0,
      _0: {
        TAG: /* String_literal */ 11,
        _0: "Dynarray.blit: invalid source region (",
        _1: {
          TAG: /* Int */ 4,
          _0: /* Int_d */ 0,
          _1: /* No_padding */ 0,
          _2: /* No_precision */ 0,
          _3: {
            TAG: /* String_literal */ 11,
            _0: "..",
            _1: {
              TAG: /* Int */ 4,
              _0: /* Int_d */ 0,
              _1: /* No_padding */ 0,
              _2: /* No_precision */ 0,
              _3: {
                TAG: /* String_literal */ 11,
                _0: ") in source dynarray of length ",
                _1: {
                  TAG: /* Int */ 4,
                  _0: /* Int_d */ 0,
                  _1: /* No_padding */ 0,
                  _2: /* No_precision */ 0,
                  _3: /* End_of_format */ 0
                }
              }
            }
          }
        }
      },
      _1: "Dynarray.blit: invalid source region (%d..%d) in source dynarray of length %d"
    }), src_pos, src_pos + len | 0, src_length);
  }
  if (dst_pos < 0 || dst_pos > dst_length) {
    Curry._3(Stdlib__Printf.ksprintf(Stdlib.invalid_arg, {
      TAG: /* Format */ 0,
      _0: {
        TAG: /* String_literal */ 11,
        _0: "Dynarray.blit: invalid target region (",
        _1: {
          TAG: /* Int */ 4,
          _0: /* Int_d */ 0,
          _1: /* No_padding */ 0,
          _2: /* No_precision */ 0,
          _3: {
            TAG: /* String_literal */ 11,
            _0: "..",
            _1: {
              TAG: /* Int */ 4,
              _0: /* Int_d */ 0,
              _1: /* No_padding */ 0,
              _2: /* No_precision */ 0,
              _3: {
                TAG: /* String_literal */ 11,
                _0: ") in target dynarray of length ",
                _1: {
                  TAG: /* Int */ 4,
                  _0: /* Int_d */ 0,
                  _1: /* No_padding */ 0,
                  _2: /* No_precision */ 0,
                  _3: /* End_of_format */ 0
                }
              }
            }
          }
        }
      },
      _1: "Dynarray.blit: invalid target region (%d..%d) in target dynarray of length %d"
    }), dst_pos, dst_pos + len | 0, dst_length);
  }
  ensure_capacity(dst, dst_pos + len | 0);
  blit_assume_room(src, src_pos, src_length, dst, dst_pos, dst_length, len);
}

function append_array_if_room(a, b) {
  const length_a = a.length;
  const arr = a.arr;
  const length_b = b.length;
  if ((length_a + length_b | 0) > arr.length) {
    return false;
  } else {
    a.length = length_a + length_b | 0;
    Curry._5(Dummy_Array.blit_array, b, 0, arr, length_a, length_b);
    return true;
  }
}

function append_array(a, b) {
  if (append_array_if_room(a, b)) {
    return;
  }
  while (true) {
    ensure_extra_capacity(a, b.length);
    if (append_array_if_room(a, b)) {
      return;
    }
    continue;
  };
}

function append_if_room(a, b, length_b) {
  const length_a = a.length;
  const arr_a = a.arr;
  if ((length_a + length_b | 0) > arr_a.length) {
    return false;
  } else {
    blit_assume_room(b, 0, length_b, a, length_a, length_a, length_b);
    check_same_length("append", b, length_b);
    return true;
  }
}

function append(a, b) {
  const length_b = b.length;
  if (append_if_room(a, b, length_b)) {
    return;
  }
  while (true) {
    ensure_extra_capacity(a, length_b);
    check_same_length("append", b, length_b);
    if (append_if_room(a, b, length_b)) {
      return;
    }
    continue;
  };
}

function iter_(f, k, a) {
  const length = a.length;
  const arr = a.arr;
  const dummy = a.dummy;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  for (let i = 0; i < length; ++i) {
    const v = arr[i];
    Curry._1(k, v === dummy ? missing_element(i, length) : v);
  }
  check_same_length(f, a, length);
}

function iter(k, a) {
  iter_("iter", k, a);
}

function iteri(k, a) {
  const length = a.length;
  const arr = a.arr;
  const dummy = a.dummy;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  for (let i = 0; i < length; ++i) {
    const v = arr[i];
    Curry._2(k, i, v === dummy ? missing_element(i, length) : v);
  }
  check_same_length("iteri", a, length);
}

function map(f, a) {
  const length = a.length;
  const arr_in = a.arr;
  const dummy = a.dummy;
  const capacity = arr_in.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const arr_out = Caml_array.make(length, dummy);
  for (let i = 0; i < length; ++i) {
    const v = arr_in[i];
    arr_out[i] = Curry._1(f, v === dummy ? missing_element(i, length) : v);
  }
  const res = {
    length: length,
    arr: arr_out,
    dummy: dummy
  };
  check_same_length("map", a, length);
  return res;
}

function mapi(f, a) {
  const length = a.length;
  const arr_in = a.arr;
  const dummy = a.dummy;
  const capacity = arr_in.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const arr_out = Caml_array.make(length, dummy);
  for (let i = 0; i < length; ++i) {
    const v = arr_in[i];
    arr_out[i] = Curry._2(f, i, v === dummy ? missing_element(i, length) : v);
  }
  const res = {
    length: length,
    arr: arr_out,
    dummy: dummy
  };
  check_same_length("mapi", a, length);
  return res;
}

function fold_left(f, acc, a) {
  const length = a.length;
  const arr = a.arr;
  const dummy = a.dummy;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  let r = acc;
  for (let i = 0; i < length; ++i) {
    const v = arr[i];
    const v$1 = v === dummy ? missing_element(i, length) : v;
    r = Curry._2(f, r, v$1);
  }
  check_same_length("fold_left", a, length);
  return r;
}

function fold_right(f, a, acc) {
  const length = a.length;
  const arr = a.arr;
  const dummy = a.dummy;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  let r = acc;
  for (let i = length - 1 | 0; i >= 0; --i) {
    const v = arr[i];
    const v$1 = v === dummy ? missing_element(i, length) : v;
    r = Curry._2(f, v$1, r);
  }
  check_same_length("fold_right", a, length);
  return r;
}

function exists(p, a) {
  const length = a.length;
  const arr = a.arr;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const loop = function (p, arr, dummy, _i, length) {
    while (true) {
      const i = _i;
      if (i === length) {
        return false;
      }
      const v = arr[i];
      if (Curry._1(p, v === dummy ? missing_element(i, length) : v)) {
        return true;
      }
      _i = i + 1 | 0;
      continue;
    };
  };
  const res = loop(p, arr, a.dummy, 0, length);
  check_same_length("exists", a, length);
  return res;
}

function for_all(p, a) {
  const length = a.length;
  const arr = a.arr;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const loop = function (p, arr, dummy, _i, length) {
    while (true) {
      const i = _i;
      if (i === length) {
        return true;
      }
      const v = arr[i];
      if (!Curry._1(p, v === dummy ? missing_element(i, length) : v)) {
        return false;
      }
      _i = i + 1 | 0;
      continue;
    };
  };
  const res = loop(p, arr, a.dummy, 0, length);
  check_same_length("for_all", a, length);
  return res;
}

function exists2(p, a1, a2) {
  const length1 = a1.length;
  const arr1 = a1.arr;
  const length2 = a2.length;
  const arr2 = a2.arr;
  const capacity = arr1.length;
  if (length1 > capacity) {
    invalid_length(length1, capacity);
  }
  const capacity$1 = arr2.length;
  if (length2 > capacity$1) {
    invalid_length(length2, capacity$1);
  }
  if (length1 !== length2) {
    different_lengths("exists2", length1, length2);
  }
  const loop = function (p, arr1, dummy1, arr2, dummy2, _i, length) {
    while (true) {
      const i = _i;
      if (i === length) {
        return false;
      }
      const v = arr1[i];
      const v$1 = arr2[i];
      if (Curry._2(p, v === dummy1 ? missing_element(i, length) : v, v$1 === dummy2 ? missing_element(i, length) : v$1)) {
        return true;
      }
      _i = i + 1 | 0;
      continue;
    };
  };
  const res = loop(p, arr1, a1.dummy, arr2, a2.dummy, 0, length1);
  check_same_length("exists2", a1, length1);
  check_same_length("exists2", a2, length2);
  return res;
}

function for_all2(p, a1, a2) {
  const length1 = a1.length;
  const arr1 = a1.arr;
  const length2 = a2.length;
  const arr2 = a2.arr;
  const capacity = arr1.length;
  if (length1 > capacity) {
    invalid_length(length1, capacity);
  }
  const capacity$1 = arr2.length;
  if (length2 > capacity$1) {
    invalid_length(length2, capacity$1);
  }
  if (length1 !== length2) {
    different_lengths("for_all2", length1, length2);
  }
  const loop = function (p, arr1, dummy1, arr2, dummy2, _i, length) {
    while (true) {
      const i = _i;
      if (i === length) {
        return true;
      }
      const v = arr1[i];
      const v$1 = arr2[i];
      if (!Curry._2(p, v === dummy1 ? missing_element(i, length) : v, v$1 === dummy2 ? missing_element(i, length) : v$1)) {
        return false;
      }
      _i = i + 1 | 0;
      continue;
    };
  };
  const res = loop(p, arr1, a1.dummy, arr2, a2.dummy, 0, length1);
  check_same_length("for_all2", a1, length1);
  check_same_length("for_all2", a2, length2);
  return res;
}

function filter(f, a) {
  const b = create();
  iter_("filter", (function (x) {
    if (Curry._1(f, x)) {
      return add_last(b, x);
    }
    
  }), a);
  return b;
}

function filter_map(f, a) {
  const b = create();
  iter_("filter_map", (function (x) {
    const y = Curry._1(f, x);
    if (y !== undefined) {
      return add_last(b, Caml_option.valFromOption(y));
    }
    
  }), a);
  return b;
}

function mem(x, a) {
  const length = a.length;
  const arr = a.arr;
  const dummy = a.dummy;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const loop = function (_i) {
    while (true) {
      const i = _i;
      if (i === length) {
        return false;
      }
      const v = arr[i];
      if (Caml_obj.caml_equal(v === dummy ? missing_element(i, length) : v, x)) {
        return true;
      }
      _i = i + 1 | 0;
      continue;
    };
  };
  const res = loop(0);
  check_same_length("mem", a, length);
  return res;
}

function memq(x, a) {
  const length = a.length;
  const arr = a.arr;
  const dummy = a.dummy;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const loop = function (_i) {
    while (true) {
      const i = _i;
      if (i === length) {
        return false;
      }
      const v = arr[i];
      if ((
          v === dummy ? missing_element(i, length) : v
        ) === x) {
        return true;
      }
      _i = i + 1 | 0;
      continue;
    };
  };
  const res = loop(0);
  check_same_length("memq", a, length);
  return res;
}

function find_opt(p, a) {
  const length = a.length;
  const arr = a.arr;
  const dummy = a.dummy;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const loop = function (_i) {
    while (true) {
      const i = _i;
      if (i === length) {
        return;
      }
      const v = arr[i];
      const x = v === dummy ? missing_element(i, length) : v;
      if (Curry._1(p, x)) {
        return Caml_option.some(x);
      }
      _i = i + 1 | 0;
      continue;
    };
  };
  const res = loop(0);
  check_same_length("find_opt", a, length);
  return res;
}

function find_index(p, a) {
  const length = a.length;
  const arr = a.arr;
  const dummy = a.dummy;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const loop = function (_i) {
    while (true) {
      const i = _i;
      if (i === length) {
        return;
      }
      const v = arr[i];
      const x = v === dummy ? missing_element(i, length) : v;
      if (Curry._1(p, x)) {
        return i;
      }
      _i = i + 1 | 0;
      continue;
    };
  };
  const res = loop(0);
  check_same_length("find_index", a, length);
  return res;
}

function find_map(p, a) {
  const length = a.length;
  const arr = a.arr;
  const dummy = a.dummy;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const loop = function (_i) {
    while (true) {
      const i = _i;
      if (i === length) {
        return;
      }
      const v = arr[i];
      const r = Curry._1(p, v === dummy ? missing_element(i, length) : v);
      if (r !== undefined) {
        return r;
      }
      _i = i + 1 | 0;
      continue;
    };
  };
  const res = loop(0);
  check_same_length("find_map", a, length);
  return res;
}

function find_mapi(p, a) {
  const length = a.length;
  const arr = a.arr;
  const dummy = a.dummy;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const loop = function (_i) {
    while (true) {
      const i = _i;
      if (i === length) {
        return;
      }
      const v = arr[i];
      const r = Curry._2(p, i, v === dummy ? missing_element(i, length) : v);
      if (r !== undefined) {
        return r;
      }
      _i = i + 1 | 0;
      continue;
    };
  };
  const res = loop(0);
  check_same_length("find_mapi", a, length);
  return res;
}

function equal(eq, a1, a2) {
  const length = a1.length;
  const arr1 = a1.arr;
  const dum1 = a1.dummy;
  const len2 = a2.length;
  const arr2 = a2.arr;
  if (length !== len2) {
    return false;
  }
  const dum2 = a2.dummy;
  const capacity = arr1.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const capacity$1 = arr2.length;
  if (length > capacity$1) {
    invalid_length(length, capacity$1);
  }
  const loop = function (_i) {
    while (true) {
      const i = _i;
      if (i === length) {
        return true;
      }
      const v = arr1[i];
      const v$1 = arr2[i];
      if (!Curry._2(eq, v === dum1 ? missing_element(i, length) : v, v$1 === dum2 ? missing_element(i, length) : v$1)) {
        return false;
      }
      _i = i + 1 | 0;
      continue;
    };
  };
  const r = loop(0);
  check_same_length("equal", a1, length);
  check_same_length("equal", a2, length);
  return r;
}

function compare(cmp, a1, a2) {
  const length = a1.length;
  const arr1 = a1.arr;
  const dum1 = a1.dummy;
  const len2 = a2.length;
  const arr2 = a2.arr;
  if (length !== len2) {
    return length - len2 | 0;
  }
  const dum2 = a2.dummy;
  const capacity = arr1.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const capacity$1 = arr2.length;
  if (length > capacity$1) {
    invalid_length(length, capacity$1);
  }
  const loop = function (_i) {
    while (true) {
      const i = _i;
      if (i === length) {
        return 0;
      }
      const v = arr1[i];
      const v$1 = arr2[i];
      const c = Curry._2(cmp, v === dum1 ? missing_element(i, length) : v, v$1 === dum2 ? missing_element(i, length) : v$1);
      if (c !== 0) {
        return c;
      }
      _i = i + 1 | 0;
      continue;
    };
  };
  const r = loop(0);
  check_same_length("compare", a1, length);
  check_same_length("compare", a2, length);
  return r;
}

function of_array(a) {
  const length = a.length;
  const dummy = global_dummy._0;
  const arr = Curry._2(Dummy_Array.copy_from_array, a, dummy);
  return {
    length: length,
    arr: arr,
    dummy: dummy
  };
}

function to_array(a) {
  const length = a.length;
  const arr = a.arr;
  const dummy = a.dummy;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const res = Stdlib__Array.init(length, (function (i) {
    const v = arr[i];
    if (v === dummy) {
      return missing_element(i, length);
    } else {
      return v;
    }
  }));
  check_same_length("to_array", a, length);
  return res;
}

function of_list(li) {
  const a = Stdlib__Array.of_list(li);
  const length = a.length;
  const dummy = global_dummy._0;
  const arr = Curry._2(Dummy_Array.unsafe_nocopy_from_array, a, dummy);
  return {
    length: length,
    arr: arr,
    dummy: dummy
  };
}

function to_list(a) {
  const length = a.length;
  const arr = a.arr;
  const dummy = a.dummy;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  let l = /* [] */ 0;
  for (let i = length - 1 | 0; i >= 0; --i) {
    const v = arr[i];
    l = {
      hd: v === dummy ? missing_element(i, length) : v,
      tl: l
    };
  }
  check_same_length("to_list", a, length);
  return l;
}

function of_seq(seq) {
  const init = create();
  append_seq(init, seq);
  return init;
}

function to_seq(a) {
  const length = a.length;
  const arr = a.arr;
  const dummy = a.dummy;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const aux = function (i, param) {
    check_same_length("to_seq", a, length);
    if (i >= length) {
      return /* Nil */ 0;
    }
    const v = arr[i];
    const v$1 = v === dummy ? missing_element(i, length) : v;
    const partial_arg = i + 1 | 0;
    return {
      TAG: /* Cons */ 0,
      _0: v$1,
      _1: (function (param) {
        return aux(partial_arg, param);
      })
    };
  };
  return function (param) {
    return aux(0, param);
  };
}

function to_seq_reentrant(a) {
  const aux = function (i, param) {
    if (i >= a.length) {
      return /* Nil */ 0;
    }
    const v = get(a, i);
    const partial_arg = i + 1 | 0;
    return {
      TAG: /* Cons */ 0,
      _0: v,
      _1: (function (param) {
        return aux(partial_arg, param);
      })
    };
  };
  return function (param) {
    return aux(0, param);
  };
}

function to_seq_rev(a) {
  const length = a.length;
  const arr = a.arr;
  const dummy = a.dummy;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const aux = function (i, param) {
    check_same_length("to_seq_rev", a, length);
    if (i < 0) {
      return /* Nil */ 0;
    }
    const v = arr[i];
    const v$1 = v === dummy ? missing_element(i, length) : v;
    const partial_arg = i - 1 | 0;
    return {
      TAG: /* Cons */ 0,
      _0: v$1,
      _1: (function (param) {
        return aux(partial_arg, param);
      })
    };
  };
  const partial_arg = length - 1 | 0;
  return function (param) {
    return aux(partial_arg, param);
  };
}

function to_seq_rev_reentrant(a) {
  const aux = function (_i, _param) {
    while (true) {
      const i = _i;
      if (i < 0) {
        return /* Nil */ 0;
      }
      if (i >= a.length) {
        _param = undefined;
        _i = a.length - 1 | 0;
        continue;
      }
      const v = get(a, i);
      const partial_arg = i - 1 | 0;
      return {
        TAG: /* Cons */ 0,
        _0: v,
        _1: (function (param) {
          return aux(partial_arg, param);
        })
      };
    };
  };
  const partial_arg = a.length - 1 | 0;
  return function (param) {
    return aux(partial_arg, param);
  };
}

function unsafe_to_iarray(capacity, f) {
  const a = create();
  set_capacity(a, capacity);
  Curry._1(f, a);
  const length = a.length;
  const arr = a.arr;
  reset(a);
  const capacity$1 = arr.length;
  const capacity$2 = arr.length;
  if (length > capacity$2) {
    invalid_length(length, capacity$2);
  }
  const values = length === capacity$1 ? arr : Curry._2(Dummy_Array.prefix, arr, length);
  let tmp;
  try {
    tmp = Curry._2(Dummy_Array.unsafe_nocopy_to_array, values, a.dummy);
  }
  catch (raw_i){
    const i = Caml_js_exceptions.internalToOCamlException(raw_i);
    if (i.MEL_EXN_ID === Dummy_Array.Dummy_found) {
      tmp = Curry._2(missing_element, i._1, length);
    } else {
      throw i;
    }
  }
  return tmp;
}

export {
  create,
  make$1 as make,
  init$1 as init,
  get,
  set,
  length,
  is_empty,
  get_last,
  find_last,
  copy,
  add_last,
  append_array,
  append_list,
  append,
  append_seq,
  append_iter,
  blit$1 as blit,
  pop_last_opt,
  pop_last,
  remove_last,
  truncate,
  clear,
  iter,
  iteri,
  map,
  mapi,
  fold_left,
  fold_right,
  filter,
  filter_map,
  exists,
  for_all,
  exists2,
  for_all2,
  mem,
  memq,
  find_opt,
  find_index,
  find_map,
  find_mapi,
  equal,
  compare,
  of_array,
  to_array,
  of_list,
  to_list,
  of_seq,
  to_seq,
  to_seq_reentrant,
  to_seq_rev,
  to_seq_rev_reentrant,
  capacity,
  ensure_capacity,
  ensure_extra_capacity,
  fit_capacity,
  set_capacity,
  reset,
  unsafe_to_iarray,
}
/* global_dummy Not a pure module */
