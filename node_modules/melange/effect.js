// Generated by Melange
'use strict';

const Caml_backtrace = require("melange.js/caml_backtrace.js");
const Caml_effect = require("melange.js/caml_effect.js");
const Caml_exceptions = require("melange.js/caml_exceptions.js");
const Caml_js_exceptions = require("melange.js/caml_js_exceptions.js");
const Caml_option = require("melange.js/caml_option.js");
const Curry = require("melange.js/curry.js");
const Stdlib__Printexc = require("./printexc.js");

const Unhandled = /* @__PURE__ */ Caml_exceptions.create("Stdlib.Effect.Unhandled");

const Continuation_already_resumed = /* @__PURE__ */ Caml_exceptions.create("Stdlib.Effect.Continuation_already_resumed");

function printer(x) {
  if (x.MEL_EXN_ID === Unhandled) {
    return "Stdlib.Effect.Unhandled(<opaque effect>)";
  }
  
}

Stdlib__Printexc.register_printer(printer);

Caml_effect.caml_set_continuation_already_resumed(new Caml_js_exceptions.MelangeError(Continuation_already_resumed, {
    MEL_EXN_ID: Continuation_already_resumed
  }));

Caml_effect.caml_set_unhandled_exception_constructor(function (eff) {
  return new Caml_js_exceptions.MelangeError(Unhandled, {
      MEL_EXN_ID: Unhandled,
      _1: eff
    });
});

function $$continue(k, v) {
  return Caml_effect.caml_resume(Caml_effect.caml_continuation_use_noexc(k), (function (x) {
    return x;
  }), v, k[1]);
}

function discontinue(k, e) {
  return Caml_effect.caml_resume(Caml_effect.caml_continuation_use_noexc(k), (function (e) {
    throw e;
  }), e, k[1]);
}

function discontinue_with_backtrace(k, e, bt) {
  return Caml_effect.caml_resume(Caml_effect.caml_continuation_use_noexc(k), (function (e) {
    Caml_backtrace.caml_restore_raw_backtrace(e, bt);
    throw e;
  }), e, k[1]);
}

function match_with(comp, arg, handler) {
  const effc = function (eff, k, last_fiber) {
    const f = Curry._1(handler.effc, eff);
    if (f !== undefined) {
      return Curry._1(f, k);
    } else {
      return Caml_effect.caml_reperform(eff, k, last_fiber);
    }
  };
  const s = Caml_effect.caml_alloc_stack(handler.retc, handler.exnc, effc);
  return Caml_effect.caml_runstack(s, comp, arg);
}

function try_with(comp, arg, handler) {
  const effc$p = function (eff, k, last_fiber) {
    const f = Curry._1(handler.effc, eff);
    if (f !== undefined) {
      return Curry._1(f, k);
    } else {
      return Caml_effect.caml_reperform(eff, k, last_fiber);
    }
  };
  const s = Caml_effect.caml_alloc_stack((function (x) {
    return x;
  }), (function (e) {
    throw e;
  }), effc$p);
  return Caml_effect.caml_runstack(s, comp, arg);
}

const Deep = {
  $$continue: $$continue,
  discontinue: discontinue,
  discontinue_with_backtrace: discontinue_with_backtrace,
  match_with: match_with,
  try_with: try_with
};

function fiber$idk(__x) {
  return __x;
}

function fiber(f) {
  const Initial_setup__ = /* @__PURE__ */ Caml_exceptions.create("Initial_setup__");
  const captured = {
    contents: undefined
  };
  const f$p = function (param) {
    let __k = function (__x) {
      return __x;
    };
    return Caml_effect.caml_perform_tail({
      MEL_EXN_ID: Initial_setup__
    }, (function (__p) {
      return Curry._1(__k, Curry._1(f, __p));
    }));
  };
  const error = function (param) {
    throw new Caml_js_exceptions.MelangeError("Failure", {
        MEL_EXN_ID: "Failure",
        _1: "impossible"
      });
  };
  const effc = function (eff, k, _last_fiber) {
    if (eff.MEL_EXN_ID === Initial_setup__) {
      captured.contents = Caml_option.some(k);
      return 0;
    }
    throw new Caml_js_exceptions.MelangeError("Failure", {
        MEL_EXN_ID: "Failure",
        _1: "impossible"
      });
  };
  const s = Caml_effect.caml_alloc_stack((function (x) {
    return x;
  }), error, effc);
  Caml_effect.caml_runstack(s, f$p, undefined);
  const k = captured.contents;
  if (k !== undefined) {
    return Curry._1(fiber$idk, Caml_option.valFromOption(k));
  }
  throw new Caml_js_exceptions.MelangeError("Failure", {
      MEL_EXN_ID: "Failure",
      _1: "impossible"
    });
  return Curry._1(fiber$idk, undefined);
}

function continue_gen(k, resume_fun, v, handler) {
  const effc = function (eff, k, last_fiber) {
    const f = Curry._1(handler.effc, eff);
    if (f !== undefined) {
      return Curry._1(f, k);
    } else {
      return Caml_effect.caml_reperform(eff, k, last_fiber);
    }
  };
  const last_fiber = k[1];
  const stack = Caml_effect.caml_continuation_use_and_update_handler_noexc(k, handler.retc, handler.exnc, effc);
  return Caml_effect.caml_resume(stack, resume_fun, v, last_fiber);
}

function continue_with(k, v, handler) {
  return continue_gen(k, (function (x) {
    return x;
  }), v, handler);
}

function discontinue_with(k, v, handler) {
  return continue_gen(k, (function (e) {
    throw e;
  }), v, handler);
}

function discontinue_with_backtrace$1(k, v, bt, handler) {
  return continue_gen(k, (function (e) {
    Caml_backtrace.caml_restore_raw_backtrace(e, bt);
    throw e;
  }), v, handler);
}

const Shallow = {
  fiber: fiber,
  continue_with: continue_with,
  discontinue_with: discontinue_with,
  discontinue_with_backtrace: discontinue_with_backtrace$1
};

module.exports = {
  Unhandled,
  Continuation_already_resumed,
  Deep,
  Shallow,
}
/*  Not a pure module */
