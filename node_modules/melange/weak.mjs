// Generated by Melange

import * as Caml from "melange.js/caml.mjs";
import * as Caml_array from "melange.js/caml_array.mjs";
import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.mjs";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.mjs";
import * as Caml_option from "melange.js/caml_option.mjs";
import * as Curry from "melange.js/curry.mjs";
import * as Stdlib from "./stdlib.mjs";
import * as Stdlib__Array from "./array.mjs";
import * as Stdlib__Int from "./int.mjs";
import * as Stdlib__Obj from "./obj.mjs";
import * as Stdlib__Sys from "./sys.mjs";

function create(l) {
  if (!(0 <= l && l <= Stdlib__Obj.Ephemeron.max_ephe_length)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Weak.create"
      });
  }
  return Caml_external_polyfill.resolve("caml_weak_create")(l);
}

function length(x) {
  return (x.length | 0) - 2 | 0;
}

function raise_if_invalid_offset(e, o, msg) {
  if (0 <= o && o < length(e)) {
    return;
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: msg
    });
}

function set(e, o, x) {
  raise_if_invalid_offset(e, o, "Weak.set");
  if (x !== undefined) {
    return Caml_external_polyfill.resolve("caml_ephe_set_key")(e, o, Caml_option.valFromOption(x));
  } else {
    return Caml_external_polyfill.resolve("caml_ephe_unset_key")(e, o);
  }
}

function get(e, o) {
  raise_if_invalid_offset(e, o, "Weak.get");
  return Caml_external_polyfill.resolve("caml_weak_get")(e, o);
}

function get_copy(e, o) {
  raise_if_invalid_offset(e, o, "Weak.get_copy");
  return Caml_external_polyfill.resolve("caml_weak_get_copy")(e, o);
}

function check(e, o) {
  raise_if_invalid_offset(e, o, "Weak.check");
  return Caml_external_polyfill.resolve("caml_weak_check")(e, o);
}

function blit(e1, o1, e2, o2, l) {
  if (l < 0 || o1 < 0 || o1 > (length(e1) - l | 0) || o2 < 0 || o2 > (length(e2) - l | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Weak.blit"
      });
  }
  if (l !== 0) {
    return Caml_external_polyfill.resolve("caml_weak_blit")(e1, o1, e2, o2, l);
  }
  
}

function fill(ar, ofs, len, x) {
  if (ofs < 0 || len < 0 || ofs > (length(ar) - len | 0)) {
    throw new Caml_js_exceptions.MelangeError(Stdlib.Invalid_argument, {
        MEL_EXN_ID: Stdlib.Invalid_argument,
        _1: "Weak.fill"
      });
  }
  for (let i = ofs, i_finish = ofs + len | 0; i < i_finish; ++i) {
    set(ar, i, x);
  }
}

function Make(H) {
  const emptybucket = create(0);
  const get_index = function (t, h) {
    return (h & Stdlib.max_int) % t.table.length;
  };
  const create$1 = function (sz) {
    const sz$1 = sz < 7 ? 7 : sz;
    const sz$2 = sz$1 > Stdlib__Sys.max_array_length ? Stdlib__Sys.max_array_length : sz$1;
    return {
      table: Caml_array.make(sz$2, emptybucket),
      hashes: Caml_array.make(sz$2, []),
      limit: 7,
      oversize: 0,
      rover: 0
    };
  };
  const clear = function (t) {
    for (let i = 0, i_finish = t.table.length; i < i_finish; ++i) {
      Caml_array.set(t.table, i, emptybucket);
      Caml_array.set(t.hashes, i, []);
    }
    t.limit = 7;
    t.oversize = 0;
  };
  const fold = function (f, t, init) {
    return Stdlib__Array.fold_right((function (param, param$1) {
      let _i = 0;
      let _accu = param$1;
      while (true) {
        const accu = _accu;
        const i = _i;
        if (i >= length(param)) {
          return accu;
        }
        const v = get(param, i);
        if (v !== undefined) {
          _accu = Curry._2(f, Caml_option.valFromOption(v), accu);
          _i = i + 1 | 0;
          continue;
        }
        _i = i + 1 | 0;
        continue;
      };
    }), t.table, init);
  };
  const iter = function (f, t) {
    Stdlib__Array.iter((function (param) {
      let _i = 0;
      while (true) {
        const i = _i;
        if (i >= length(param)) {
          return;
        }
        const v = get(param, i);
        if (v !== undefined) {
          Curry._1(f, Caml_option.valFromOption(v));
          _i = i + 1 | 0;
          continue;
        }
        _i = i + 1 | 0;
        continue;
      };
    }), t.table);
  };
  const iter_weak = function (f, t) {
    Stdlib__Array.iteri((function (param, param$1) {
      let _i = 0;
      while (true) {
        const i = _i;
        if (i >= length(param$1)) {
          return;
        }
        if (check(param$1, i)) {
          Curry._3(f, param$1, Caml_array.get(t.hashes, param), i);
          _i = i + 1 | 0;
          continue;
        }
        _i = i + 1 | 0;
        continue;
      };
    }), t.table);
  };
  const count_bucket = function (_i, b, _accu) {
    while (true) {
      const accu = _accu;
      const i = _i;
      if (i >= length(b)) {
        return accu;
      }
      _accu = accu + (
        check(b, i) ? 1 : 0
      ) | 0;
      _i = i + 1 | 0;
      continue;
    };
  };
  const count = function (t) {
    return Stdlib__Array.fold_right((function (param, param$1) {
      return count_bucket(0, param, param$1);
    }), t.table, 0);
  };
  const next_sz = function (n) {
    return Stdlib__Int.min((Math.imul(3, n) / 2 | 0) + 3 | 0, Stdlib__Sys.max_array_length);
  };
  const prev_sz = function (n) {
    return (((n - 3 | 0) << 1) + 2 | 0) / 3 | 0;
  };
  const test_shrink_bucket = function (t) {
    const bucket = Caml_array.get(t.table, t.rover);
    const hbucket = Caml_array.get(t.hashes, t.rover);
    const len = length(bucket);
    const prev_len = prev_sz(len);
    const live = count_bucket(0, bucket, 0);
    if (live <= prev_len) {
      const loop = function (_i, _j) {
        while (true) {
          const j = _j;
          const i = _i;
          if (j < prev_len) {
            return;
          }
          if (check(bucket, i)) {
            _i = i + 1 | 0;
            continue;
          }
          if (check(bucket, j)) {
            blit(bucket, j, bucket, i, 1);
            Caml_array.set(hbucket, i, Caml_array.get(hbucket, j));
            _j = j - 1 | 0;
            _i = i + 1 | 0;
            continue;
          }
          _j = j - 1 | 0;
          continue;
        };
      };
      loop(0, length(bucket) - 1 | 0);
      if (prev_len === 0) {
        Caml_array.set(t.table, t.rover, emptybucket);
        Caml_array.set(t.hashes, t.rover, []);
      } else {
        const newbucket = create(prev_len);
        blit(bucket, 0, newbucket, 0, prev_len);
        Caml_array.set(t.table, t.rover, newbucket);
        Caml_array.set(t.hashes, t.rover, Stdlib__Array.sub(hbucket, 0, prev_len));
      }
      if (len > t.limit && prev_len <= t.limit) {
        t.oversize = t.oversize - 1 | 0;
      }
      
    }
    t.rover = (t.rover + 1 | 0) % t.table.length;
  };
  const add_aux = function (t, setter, d, h, index) {
    const bucket = Caml_array.get(t.table, index);
    const hashes = Caml_array.get(t.hashes, index);
    const sz = length(bucket);
    let i = 0;
    while (i < sz && check(bucket, i)) {
      i = i + 1 | 0;
    };
    if (i < sz) {
      Curry._3(setter, bucket, i, d);
      return Caml_array.set(hashes, i, h);
    }
    const newsz = Stdlib__Int.min((Math.imul(3, sz) / 2 | 0) + 3 | 0, Stdlib__Sys.max_array_length - 2 | 0);
    if (newsz <= sz) {
      throw new Caml_js_exceptions.MelangeError("Failure", {
          MEL_EXN_ID: "Failure",
          _1: "Weak.Make: hash bucket cannot grow more"
        });
    }
    const newbucket = create(newsz);
    const newhashes = Caml_array.make(newsz, 0);
    blit(bucket, 0, newbucket, 0, sz);
    Stdlib__Array.blit(hashes, 0, newhashes, 0, sz);
    Curry._3(setter, newbucket, sz, d);
    Caml_array.set(newhashes, sz, h);
    Caml_array.set(t.table, index, newbucket);
    Caml_array.set(t.hashes, index, newhashes);
    if (sz <= t.limit && newsz > t.limit) {
      t.oversize = t.oversize + 1 | 0;
      for (let _i = 0; _i <= 2; ++_i) {
        test_shrink_bucket(t);
      }
    }
    if (t.oversize > (t.table.length >> 1)) {
      const oldlen = t.table.length;
      const newlen = next_sz(oldlen);
      if (newlen > oldlen) {
        const newt = create$1(newlen);
        const add_weak = function (ob, oh, oi) {
          const setter = function (nb, ni, param) {
            blit(ob, oi, nb, ni, 1);
          };
          const h = Caml_array.get(oh, oi);
          add_aux(newt, setter, undefined, h, get_index(newt, h));
        };
        iter_weak(add_weak, t);
        t.table = newt.table;
        t.hashes = newt.hashes;
        t.limit = newt.limit;
        t.oversize = newt.oversize;
        t.rover = t.rover % newt.table.length;
        return;
      }
      t.limit = Stdlib.max_int;
      t.oversize = 0;
      return;
    }
    
  };
  const add = function (t, d) {
    const h = Curry._1(H.hash, d);
    add_aux(t, set, Caml_option.some(d), h, get_index(t, h));
  };
  const find_aux = function (t, d, k_found, k_notfound) {
    const h = Curry._1(H.hash, d);
    const index = get_index(t, h);
    const bucket = Caml_array.get(t.table, index);
    const hashes = Caml_array.get(t.hashes, index);
    const sz = length(bucket);
    let found;
    let i = 0;
    while ((function () {
        let tmp = false;
        if (i < sz) {
          const param = found;
          tmp = param === undefined;
        }
        return tmp;
      })()) {
      if (h === Caml_array.get(hashes, i)) {
        const opt = get(bucket, i);
        if (opt !== undefined && Curry._2(H.equal, Caml_option.valFromOption(opt), d)) {
          found = opt;
        } else {
          i = i + 1 | 0;
        }
      } else {
        i = i + 1 | 0;
      }
    };
    const opt$1 = found;
    if (opt$1 !== undefined) {
      return Curry._4(k_found, bucket, i, opt$1, Caml_option.valFromOption(opt$1));
    } else {
      return Curry._2(k_notfound, h, index);
    }
  };
  const find_opt = function (t, d) {
    return find_aux(t, d, (function (_b, _i, o, _v) {
      return o;
    }), (function (_h, _i) {
      
    }));
  };
  const merge = function (t, d) {
    return find_aux(t, d, (function (_b, _i, _o, v) {
      return v;
    }), (function (h, i) {
      add_aux(t, set, Caml_option.some(d), h, i);
      return d;
    }));
  };
  const find = function (t, d) {
    return find_aux(t, d, (function (_b, _i, _o, v) {
      return v;
    }), (function (_h, _i) {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
          MEL_EXN_ID: Stdlib.Not_found
        });
    }));
  };
  const remove = function (t, d) {
    find_aux(t, d, (function (b, i, _o, _v) {
      set(b, i, undefined);
    }), (function (_h, _i) {
      
    }));
  };
  const mem = function (t, d) {
    return find_aux(t, d, (function (_b, _i, _o, _v) {
      return true;
    }), (function (_h, _i) {
      return false;
    }));
  };
  const find_all = function (t, d) {
    const h = Curry._1(H.hash, d);
    const index = get_index(t, h);
    const bucket = Caml_array.get(t.table, index);
    const hashes = Caml_array.get(t.hashes, index);
    const sz = length(bucket);
    let _i = 0;
    let _accu = /* [] */ 0;
    while (true) {
      const accu = _accu;
      const i = _i;
      if (i >= sz) {
        return accu;
      }
      if (h === Caml_array.get(hashes, i)) {
        const v = get(bucket, i);
        if (v !== undefined) {
          const v$1 = Caml_option.valFromOption(v);
          if (Curry._2(H.equal, v$1, d)) {
            _accu = {
              hd: v$1,
              tl: accu
            };
            _i = i + 1 | 0;
            continue;
          }
          _i = i + 1 | 0;
          continue;
        }
        _i = i + 1 | 0;
        continue;
      }
      _i = i + 1 | 0;
      continue;
    };
  };
  const stats = function (t) {
    const len = t.table.length;
    const lens = Stdlib__Array.map(length, t.table);
    Stdlib__Array.sort(Caml.caml_int_compare, lens);
    const totlen = Stdlib__Array.fold_left((function (prim0, prim1) {
      return prim0 + prim1 | 0;
    }), 0, lens);
    return [
      len,
      count(t),
      totlen,
      Caml_array.get(lens, 0),
      Caml_array.get(lens, len / 2 | 0),
      Caml_array.get(lens, len - 1 | 0)
    ];
  };
  return {
    create: create$1,
    clear: clear,
    merge: merge,
    add: add,
    remove: remove,
    find: find,
    find_opt: find_opt,
    find_all: find_all,
    mem: mem,
    iter: iter,
    fold: fold,
    count: count,
    stats: stats
  };
}

export {
  create,
  length,
  set,
  get,
  get_copy,
  check,
  fill,
  blit,
  Make,
}
/* No side effect */
