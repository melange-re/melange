// Generated by Melange

import * as Caml_array from "melange.js/caml_array.mjs";
import * as Caml_bytes from "melange.js/caml_bytes.mjs";
import * as Caml_exceptions from "melange.js/caml_exceptions.mjs";
import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.mjs";
import * as Caml_io from "melange.js/caml_io.mjs";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.mjs";
import * as Caml_obj from "melange.js/caml_obj.mjs";
import * as Caml_string from "melange.js/caml_string.mjs";
import * as Caml_sys from "melange.js/caml_sys.mjs";
import * as Curry from "melange.js/curry.mjs";
import * as Stdlib from "./stdlib.mjs";
import * as Stdlib__Array from "./array.mjs";
import * as Stdlib__Buffer from "./buffer.mjs";
import * as Stdlib__Bytes from "./bytes.mjs";
import * as Stdlib__Int from "./int.mjs";
import * as Stdlib__List from "./list.mjs";
import * as Stdlib__Printf from "./printf.mjs";
import * as Stdlib__String from "./string.mjs";

const Bad = /* @__PURE__ */ Caml_exceptions.create("Stdlib.Arg.Bad");

const Help = /* @__PURE__ */ Caml_exceptions.create("Stdlib.Arg.Help");

const Stop = /* @__PURE__ */ Caml_exceptions.create("Stdlib.Arg.Stop");

function assoc3(x, _l) {
  while (true) {
    const l = _l;
    if (l) {
      const match = l.hd;
      if (Caml_obj.caml_equal(match[0], x)) {
        return match[1];
      }
      _l = l.tl;
      continue;
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
        MEL_EXN_ID: Stdlib.Not_found
      });
  };
}

function split(s) {
  const i = Stdlib__String.index(s, /* '=' */61);
  const len = s.length;
  return [
    Stdlib__String.sub(s, 0, i),
    Stdlib__String.sub(s, i + 1 | 0, len - (i + 1 | 0) | 0)
  ];
}

function make_symlist(prefix, sep, suffix, l) {
  if (l) {
    return Stdlib__List.fold_left((function (x, y) {
      return x + (sep + y);
    }), prefix + l.hd, l.tl) + suffix;
  } else {
    return "<none>";
  }
}

function help_action(param) {
  throw new Caml_js_exceptions.MelangeError(Stop, {
      MEL_EXN_ID: Stop,
      _1: {
        TAG: /* Unknown */ 0,
        _0: "-help"
      }
    });
}

function add_help(speclist) {
  let add1;
  try {
    assoc3("-help", speclist);
    add1 = /* [] */ 0;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      add1 = {
        hd: [
          "-help",
          {
            TAG: /* Unit */ 0,
            _0: help_action
          },
          " Display this list of options"
        ],
        tl: /* [] */ 0
      };
    } else {
      throw exn;
    }
  }
  let add2;
  try {
    assoc3("--help", speclist);
    add2 = /* [] */ 0;
  }
  catch (raw_exn$1){
    const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
    if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
      add2 = {
        hd: [
          "--help",
          {
            TAG: /* Unit */ 0,
            _0: help_action
          },
          " Display this list of options"
        ],
        tl: /* [] */ 0
      };
    } else {
      throw exn$1;
    }
  }
  return Stdlib.$at(speclist, Stdlib.$at(add1, add2));
}

function usage_b(buf, speclist, errmsg) {
  Curry._1(Stdlib__Printf.bprintf(buf, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String */ 2,
      _0: /* No_padding */ 0,
      _1: {
        TAG: /* Char_literal */ 12,
        _0: /* '\n' */10,
        _1: /* End_of_format */ 0
      }
    },
    _1: "%s\n"
  }), errmsg);
  Stdlib__List.iter((function (param) {
    const doc = param[2];
    if (doc.length === 0) {
      return;
    }
    const spec = param[1];
    const key = param[0];
    if (spec.TAG === /* Symbol */ 11) {
      return Curry._3(Stdlib__Printf.bprintf(buf, {
        TAG: /* Format */ 0,
        _0: {
          TAG: /* String_literal */ 11,
          _0: "  ",
          _1: {
            TAG: /* String */ 2,
            _0: /* No_padding */ 0,
            _1: {
              TAG: /* Char_literal */ 12,
              _0: /* ' ' */32,
              _1: {
                TAG: /* String */ 2,
                _0: /* No_padding */ 0,
                _1: {
                  TAG: /* String */ 2,
                  _0: /* No_padding */ 0,
                  _1: {
                    TAG: /* Char_literal */ 12,
                    _0: /* '\n' */10,
                    _1: /* End_of_format */ 0
                  }
                }
              }
            }
          }
        },
        _1: "  %s %s%s\n"
      }), key, make_symlist("{", "|", "}", spec._0), doc);
    } else {
      return Curry._2(Stdlib__Printf.bprintf(buf, {
        TAG: /* Format */ 0,
        _0: {
          TAG: /* String_literal */ 11,
          _0: "  ",
          _1: {
            TAG: /* String */ 2,
            _0: /* No_padding */ 0,
            _1: {
              TAG: /* Char_literal */ 12,
              _0: /* ' ' */32,
              _1: {
                TAG: /* String */ 2,
                _0: /* No_padding */ 0,
                _1: {
                  TAG: /* Char_literal */ 12,
                  _0: /* '\n' */10,
                  _1: /* End_of_format */ 0
                }
              }
            }
          }
        },
        _1: "  %s %s\n"
      }), key, doc);
    }
  }), add_help(speclist));
}

function usage_string(speclist, errmsg) {
  const b = Stdlib__Buffer.create(200);
  usage_b(b, speclist, errmsg);
  return Stdlib__Buffer.contents(b);
}

function usage(speclist, errmsg) {
  Curry._1(Stdlib__Printf.eprintf({
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String */ 2,
      _0: /* No_padding */ 0,
      _1: /* End_of_format */ 0
    },
    _1: "%s"
  }), usage_string(speclist, errmsg));
}

const current = {
  contents: 0
};

function parse_and_expand_argv_dynamic_aux(allow_expand, current, argv, speclist, anonfun, errmsg) {
  const initpos = current.contents;
  const convert_error = function (error) {
    const b = Stdlib__Buffer.create(200);
    const progname = initpos < argv.contents.length ? Caml_array.get(argv.contents, initpos) : "(?)";
    switch (error.TAG) {
      case /* Unknown */ 0 :
        const s = error._0;
        switch (s) {
          case "--help" :
          case "-help" :
            break;
          default:
            Curry._2(Stdlib__Printf.bprintf(b, {
              TAG: /* Format */ 0,
              _0: {
                TAG: /* String */ 2,
                _0: /* No_padding */ 0,
                _1: {
                  TAG: /* String_literal */ 11,
                  _0: ": unknown option '",
                  _1: {
                    TAG: /* String */ 2,
                    _0: /* No_padding */ 0,
                    _1: {
                      TAG: /* String_literal */ 11,
                      _0: "'.\n",
                      _1: /* End_of_format */ 0
                    }
                  }
                }
              },
              _1: "%s: unknown option '%s'.\n"
            }), progname, s);
        }
        break;
      case /* Wrong */ 1 :
        Curry._4(Stdlib__Printf.bprintf(b, {
          TAG: /* Format */ 0,
          _0: {
            TAG: /* String */ 2,
            _0: /* No_padding */ 0,
            _1: {
              TAG: /* String_literal */ 11,
              _0: ": wrong argument '",
              _1: {
                TAG: /* String */ 2,
                _0: /* No_padding */ 0,
                _1: {
                  TAG: /* String_literal */ 11,
                  _0: "'; option '",
                  _1: {
                    TAG: /* String */ 2,
                    _0: /* No_padding */ 0,
                    _1: {
                      TAG: /* String_literal */ 11,
                      _0: "' expects ",
                      _1: {
                        TAG: /* String */ 2,
                        _0: /* No_padding */ 0,
                        _1: {
                          TAG: /* String_literal */ 11,
                          _0: ".\n",
                          _1: /* End_of_format */ 0
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          _1: "%s: wrong argument '%s'; option '%s' expects %s.\n"
        }), progname, error._1, error._0, error._2);
        break;
      case /* Missing */ 2 :
        Curry._2(Stdlib__Printf.bprintf(b, {
          TAG: /* Format */ 0,
          _0: {
            TAG: /* String */ 2,
            _0: /* No_padding */ 0,
            _1: {
              TAG: /* String_literal */ 11,
              _0: ": option '",
              _1: {
                TAG: /* String */ 2,
                _0: /* No_padding */ 0,
                _1: {
                  TAG: /* String_literal */ 11,
                  _0: "' needs an argument.\n",
                  _1: /* End_of_format */ 0
                }
              }
            }
          },
          _1: "%s: option '%s' needs an argument.\n"
        }), progname, error._0);
        break;
      case /* Message */ 3 :
        Curry._2(Stdlib__Printf.bprintf(b, {
          TAG: /* Format */ 0,
          _0: {
            TAG: /* String */ 2,
            _0: /* No_padding */ 0,
            _1: {
              TAG: /* String_literal */ 11,
              _0: ": ",
              _1: {
                TAG: /* String */ 2,
                _0: /* No_padding */ 0,
                _1: {
                  TAG: /* String_literal */ 11,
                  _0: ".\n",
                  _1: /* End_of_format */ 0
                }
              }
            }
          },
          _1: "%s: %s.\n"
        }), progname, error._0);
        break;
    }
    usage_b(b, speclist.contents, errmsg);
    if (Caml_obj.caml_equal(error, {
        TAG: /* Unknown */ 0,
        _0: "-help"
      }) || Caml_obj.caml_equal(error, {
        TAG: /* Unknown */ 0,
        _0: "--help"
      })) {
      return new Caml_js_exceptions.MelangeError(Help, {
          MEL_EXN_ID: Help,
          _1: Stdlib__Buffer.contents(b)
        });
    } else {
      return new Caml_js_exceptions.MelangeError(Bad, {
          MEL_EXN_ID: Bad,
          _1: Stdlib__Buffer.contents(b)
        });
    }
  };
  current.contents = current.contents + 1 | 0;
  while (current.contents < argv.contents.length) {
    try {
      const s = Caml_array.get(argv.contents, current.contents);
      if (Stdlib__String.starts_with("-", s)) {
        let match;
        try {
          match = [
            assoc3(s, speclist.contents),
            undefined
          ];
        }
        catch (raw_exn){
          const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.MEL_EXN_ID === Stdlib.Not_found) {
            try {
              const match$1 = split(s);
              match = [
                assoc3(match$1[0], speclist.contents),
                match$1[1]
              ];
            }
            catch (raw_exn$1){
              const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
              if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
                throw new Caml_js_exceptions.MelangeError(Stop, {
                    MEL_EXN_ID: Stop,
                    _1: {
                      TAG: /* Unknown */ 0,
                      _0: s
                    }
                  });
              }
              throw exn$1;
            }
          } else {
            throw exn;
          }
        }
        const follow = match[1];
        const no_arg = function (param) {
          if (follow === undefined) {
            return;
          }
          throw new Caml_js_exceptions.MelangeError(Stop, {
              MEL_EXN_ID: Stop,
              _1: {
                TAG: /* Wrong */ 1,
                _0: s,
                _1: follow,
                _2: "no argument"
              }
            });
        };
        const get_arg = function (param) {
          if (follow !== undefined) {
            return follow;
          }
          if ((current.contents + 1 | 0) < argv.contents.length) {
            return Caml_array.get(argv.contents, current.contents + 1 | 0);
          }
          throw new Caml_js_exceptions.MelangeError(Stop, {
              MEL_EXN_ID: Stop,
              _1: {
                TAG: /* Missing */ 2,
                _0: s
              }
            });
        };
        const consume_arg = function (param) {
          if (follow !== undefined) {
            return;
          } else {
            current.contents = current.contents + 1 | 0;
            return;
          }
        };
        const treat_action = function (f) {
          switch (f.TAG) {
            case /* Unit */ 0 :
              no_arg();
              return Curry._1(f._0, undefined);
            case /* Bool */ 1 :
              const arg = get_arg();
              const s$1 = Stdlib.bool_of_string_opt(arg);
              if (s$1 !== undefined) {
                Curry._1(f._0, s$1);
              } else {
                throw new Caml_js_exceptions.MelangeError(Stop, {
                    MEL_EXN_ID: Stop,
                    _1: {
                      TAG: /* Wrong */ 1,
                      _0: s,
                      _1: arg,
                      _2: "a boolean"
                    }
                  });
              }
              return consume_arg();
            case /* Set */ 2 :
              no_arg();
              f._0.contents = true;
              return;
            case /* Clear */ 3 :
              no_arg();
              f._0.contents = false;
              return;
            case /* String */ 4 :
              const arg$1 = get_arg();
              Curry._1(f._0, arg$1);
              return consume_arg();
            case /* Set_string */ 5 :
              f._0.contents = get_arg();
              return consume_arg();
            case /* Int */ 6 :
              const arg$2 = get_arg();
              const x = Stdlib.int_of_string_opt(arg$2);
              if (x !== undefined) {
                Curry._1(f._0, x);
              } else {
                throw new Caml_js_exceptions.MelangeError(Stop, {
                    MEL_EXN_ID: Stop,
                    _1: {
                      TAG: /* Wrong */ 1,
                      _0: s,
                      _1: arg$2,
                      _2: "an integer"
                    }
                  });
              }
              return consume_arg();
            case /* Set_int */ 7 :
              const arg$3 = get_arg();
              const x$1 = Stdlib.int_of_string_opt(arg$3);
              if (x$1 !== undefined) {
                f._0.contents = x$1;
              } else {
                throw new Caml_js_exceptions.MelangeError(Stop, {
                    MEL_EXN_ID: Stop,
                    _1: {
                      TAG: /* Wrong */ 1,
                      _0: s,
                      _1: arg$3,
                      _2: "an integer"
                    }
                  });
              }
              return consume_arg();
            case /* Float */ 8 :
              const arg$4 = get_arg();
              const x$2 = Stdlib.float_of_string_opt(arg$4);
              if (x$2 !== undefined) {
                Curry._1(f._0, x$2);
              } else {
                throw new Caml_js_exceptions.MelangeError(Stop, {
                    MEL_EXN_ID: Stop,
                    _1: {
                      TAG: /* Wrong */ 1,
                      _0: s,
                      _1: arg$4,
                      _2: "a float"
                    }
                  });
              }
              return consume_arg();
            case /* Set_float */ 9 :
              const arg$5 = get_arg();
              const x$3 = Stdlib.float_of_string_opt(arg$5);
              if (x$3 !== undefined) {
                f._0.contents = x$3;
              } else {
                throw new Caml_js_exceptions.MelangeError(Stop, {
                    MEL_EXN_ID: Stop,
                    _1: {
                      TAG: /* Wrong */ 1,
                      _0: s,
                      _1: arg$5,
                      _2: "a float"
                    }
                  });
              }
              return consume_arg();
            case /* Tuple */ 10 :
              no_arg();
              return Stdlib__List.iter(treat_action, f._0);
            case /* Symbol */ 11 :
              const symb = f._0;
              const arg$6 = get_arg();
              if (Stdlib__List.mem(arg$6, symb)) {
                Curry._1(f._1, arg$6);
                return consume_arg();
              }
              throw new Caml_js_exceptions.MelangeError(Stop, {
                  MEL_EXN_ID: Stop,
                  _1: {
                    TAG: /* Wrong */ 1,
                    _0: s,
                    _1: arg$6,
                    _2: "one of: " + make_symlist("", " ", "", symb)
                  }
                });
            case /* Rest */ 12 :
              const f$1 = f._0;
              no_arg();
              while (current.contents < (argv.contents.length - 1 | 0)) {
                Curry._1(f$1, Caml_array.get(argv.contents, current.contents + 1 | 0));
                consume_arg();
              };
              return;
            case /* Rest_all */ 13 :
              no_arg();
              let acc = /* [] */ 0;
              while (current.contents < (argv.contents.length - 1 | 0)) {
                acc = {
                  hd: Caml_array.get(argv.contents, current.contents + 1 | 0),
                  tl: acc
                };
                consume_arg();
              };
              return Curry._1(f._0, Stdlib__List.rev(acc));
            case /* Expand */ 14 :
              if (!allow_expand) {
                throw new Caml_js_exceptions.MelangeError(Stdlib.Invalid_argument, {
                    MEL_EXN_ID: Stdlib.Invalid_argument,
                    _1: "Arg.Expand is is only allowed with Arg.parse_and_expand_argv_dynamic"
                  });
              }
              const arg$7 = get_arg();
              const newarg = Curry._1(f._0, arg$7);
              consume_arg();
              const before = Stdlib__Array.sub(argv.contents, 0, current.contents + 1 | 0);
              const after = Stdlib__Array.sub(argv.contents, current.contents + 1 | 0, (argv.contents.length - current.contents | 0) - 1 | 0);
              argv.contents = Caml_array.concat({
                hd: before,
                tl: {
                  hd: newarg,
                  tl: {
                    hd: after,
                    tl: /* [] */ 0
                  }
                }
              });
              return;
          }
        };
        treat_action(match[0]);
      } else {
        Curry._1(anonfun, s);
      }
    }
    catch (raw_m){
      const m = Caml_js_exceptions.internalToOCamlException(raw_m);
      if (m.MEL_EXN_ID === Bad) {
        throw convert_error({
          TAG: /* Message */ 3,
          _0: m._1
        });
      }
      if (m.MEL_EXN_ID === Stop) {
        throw convert_error(m._1);
      }
      throw m;
    }
    current.contents = current.contents + 1 | 0;
  };
}

function parse_and_expand_argv_dynamic(current, argv, speclist, anonfun, errmsg) {
  parse_and_expand_argv_dynamic_aux(true, current, argv, speclist, anonfun, errmsg);
}

function parse_argv_dynamic(currentOpt, argv, speclist, anonfun, errmsg) {
  const current$1 = currentOpt !== undefined ? currentOpt : current;
  parse_and_expand_argv_dynamic_aux(false, current$1, {
    contents: argv
  }, speclist, anonfun, errmsg);
}

function parse_argv(currentOpt, argv, speclist, anonfun, errmsg) {
  const current$1 = currentOpt !== undefined ? currentOpt : current;
  parse_argv_dynamic(current$1, argv, {
    contents: speclist
  }, anonfun, errmsg);
}

function parse(l, f, msg) {
  try {
    return parse_argv(undefined, Caml_sys.caml_sys_argv(0), l, f, msg);
  }
  catch (raw_msg){
    const msg$1 = Caml_js_exceptions.internalToOCamlException(raw_msg);
    if (msg$1.MEL_EXN_ID === Bad) {
      Curry._1(Stdlib__Printf.eprintf({
        TAG: /* Format */ 0,
        _0: {
          TAG: /* String */ 2,
          _0: /* No_padding */ 0,
          _1: /* End_of_format */ 0
        },
        _1: "%s"
      }), msg$1._1);
      return Stdlib.exit(2);
    }
    if (msg$1.MEL_EXN_ID === Help) {
      Curry._1(Stdlib__Printf.printf({
        TAG: /* Format */ 0,
        _0: {
          TAG: /* String */ 2,
          _0: /* No_padding */ 0,
          _1: /* End_of_format */ 0
        },
        _1: "%s"
      }), msg$1._1);
      return Stdlib.exit(0);
    }
    throw msg$1;
  }
}

function parse_dynamic(l, f, msg) {
  try {
    return parse_argv_dynamic(undefined, Caml_sys.caml_sys_argv(0), l, f, msg);
  }
  catch (raw_msg){
    const msg$1 = Caml_js_exceptions.internalToOCamlException(raw_msg);
    if (msg$1.MEL_EXN_ID === Bad) {
      Curry._1(Stdlib__Printf.eprintf({
        TAG: /* Format */ 0,
        _0: {
          TAG: /* String */ 2,
          _0: /* No_padding */ 0,
          _1: /* End_of_format */ 0
        },
        _1: "%s"
      }), msg$1._1);
      return Stdlib.exit(2);
    }
    if (msg$1.MEL_EXN_ID === Help) {
      Curry._1(Stdlib__Printf.printf({
        TAG: /* Format */ 0,
        _0: {
          TAG: /* String */ 2,
          _0: /* No_padding */ 0,
          _1: /* End_of_format */ 0
        },
        _1: "%s"
      }), msg$1._1);
      return Stdlib.exit(0);
    }
    throw msg$1;
  }
}

function parse_expand(l, f, msg) {
  try {
    const argv = {
      contents: Caml_sys.caml_sys_argv(0)
    };
    const spec = {
      contents: l
    };
    const current$1 = {
      contents: current.contents
    };
    return parse_and_expand_argv_dynamic(current$1, argv, spec, f, msg);
  }
  catch (raw_msg){
    const msg$1 = Caml_js_exceptions.internalToOCamlException(raw_msg);
    if (msg$1.MEL_EXN_ID === Bad) {
      Curry._1(Stdlib__Printf.eprintf({
        TAG: /* Format */ 0,
        _0: {
          TAG: /* String */ 2,
          _0: /* No_padding */ 0,
          _1: /* End_of_format */ 0
        },
        _1: "%s"
      }), msg$1._1);
      return Stdlib.exit(2);
    }
    if (msg$1.MEL_EXN_ID === Help) {
      Curry._1(Stdlib__Printf.printf({
        TAG: /* Format */ 0,
        _0: {
          TAG: /* String */ 2,
          _0: /* No_padding */ 0,
          _1: /* End_of_format */ 0
        },
        _1: "%s"
      }), msg$1._1);
      return Stdlib.exit(0);
    }
    throw msg$1;
  }
}

function second_word(s) {
  const len = s.length;
  const loop = function (_n) {
    while (true) {
      const n = _n;
      if (n >= len) {
        return len;
      }
      if (Caml_string.get(s, n) !== /* ' ' */32) {
        return n;
      }
      _n = n + 1 | 0;
      continue;
    };
  };
  let n;
  try {
    n = Stdlib__String.index(s, /* '\t' */9);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      let exit = 0;
      let n$1;
      try {
        n$1 = Stdlib__String.index(s, /* ' ' */32);
        exit = 2;
      }
      catch (raw_exn$1){
        const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
        if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
          return len;
        }
        throw exn$1;
      }
      if (exit === 2) {
        return loop(n$1 + 1 | 0);
      }
      
    } else {
      throw exn;
    }
  }
  return loop(n + 1 | 0);
}

function max_arg_len(cur, param) {
  const kwd = param[0];
  if (param[1].TAG === /* Symbol */ 11) {
    return Stdlib__Int.max(cur, kwd.length);
  } else {
    return Stdlib__Int.max(cur, kwd.length + second_word(param[2]) | 0);
  }
}

function replace_leading_tab(s) {
  const seen = {
    contents: false
  };
  return Stdlib__String.map((function (c) {
    if (c !== 9 || seen.contents) {
      return c;
    } else {
      seen.contents = true;
      return /* ' ' */32;
    }
  }), s);
}

function align(limitOpt, speclist) {
  const limit = limitOpt !== undefined ? limitOpt : Stdlib.max_int;
  const completed = add_help(speclist);
  const len = Stdlib__List.fold_left(max_arg_len, 0, completed);
  const len$1 = Stdlib__Int.min(len, limit);
  return Stdlib__List.map((function (param) {
    const kwd = param[0];
    const spec = param[1];
    if (param[2] === "") {
      return param;
    }
    if (spec.TAG === /* Symbol */ 11) {
      const msg = param[2];
      const cutcol = second_word(msg);
      const n = Stdlib__Int.max(0, len$1 - cutcol | 0) + 3 | 0;
      const spaces = Caml_bytes.bytes_to_string(Stdlib__Bytes.make(n, /* ' ' */32));
      return [
        kwd,
        spec,
        "\n" + (spaces + replace_leading_tab(msg))
      ];
    }
    const msg$1 = param[2];
    const spec$1 = param[1];
    const cutcol$1 = second_word(msg$1);
    const kwd_len = kwd.length;
    const diff = (len$1 - kwd_len | 0) - cutcol$1 | 0;
    if (diff <= 0) {
      return [
        kwd,
        spec$1,
        replace_leading_tab(msg$1)
      ];
    }
    const spaces$1 = Caml_bytes.bytes_to_string(Stdlib__Bytes.make(diff, /* ' ' */32));
    const prefix = Stdlib__String.sub(replace_leading_tab(msg$1), 0, cutcol$1);
    const suffix = Stdlib__String.sub(msg$1, cutcol$1, msg$1.length - cutcol$1 | 0);
    return [
      kwd,
      spec$1,
      prefix + (spaces$1 + suffix)
    ];
  }), completed);
}

function trim_cr(s) {
  const len = s.length;
  if (len > 0 && Caml_string.get(s, len - 1 | 0) === /* '\r' */13) {
    return Stdlib__String.sub(s, 0, len - 1 | 0);
  } else {
    return s;
  }
}

function read_aux(trim, sep, file) {
  const ic = Stdlib.open_in_bin(file);
  const buf = Stdlib__Buffer.create(200);
  const words = {
    contents: /* [] */ 0
  };
  const stash = function (param) {
    const word = Stdlib__Buffer.contents(buf);
    const word$1 = trim ? trim_cr(word) : word;
    words.contents = {
      hd: word$1,
      tl: words.contents
    };
    buf.position = 0;
  };
  try {
    while (true) {
      const c = Caml_external_polyfill.resolve("caml_ml_input_char")(ic);
      if (c === sep) {
        stash();
      } else {
        Stdlib__Buffer.add_char(buf, c);
      }
    };
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID !== Stdlib.End_of_file) {
      throw exn;
    }
    
  }
  if (buf.position > 0) {
    stash();
  }
  Caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
  return Stdlib__Array.of_list(Stdlib__List.rev(words.contents));
}

function read_arg(param) {
  return read_aux(true, /* '\n' */10, param);
}

function read_arg0(param) {
  return read_aux(false, /* '\000' */0, param);
}

function write_aux(sep, file, args) {
  const oc = Stdlib.open_out_bin(file);
  Stdlib__Array.iter((function (s) {
    Curry._2(Stdlib__Printf.fprintf(oc, {
      TAG: /* Format */ 0,
      _0: {
        TAG: /* String */ 2,
        _0: /* No_padding */ 0,
        _1: {
          TAG: /* Char */ 0,
          _0: /* End_of_format */ 0
        }
      },
      _1: "%s%c"
    }), s, sep);
  }), args);
  Caml_io.caml_ml_flush(oc);
  Caml_external_polyfill.resolve("caml_ml_close_channel")(oc);
}

function write_arg(param, param$1) {
  return write_aux(/* '\n' */10, param, param$1);
}

function write_arg0(param, param$1) {
  return write_aux(/* '\000' */0, param, param$1);
}

export {
  parse,
  parse_dynamic,
  parse_argv,
  parse_argv_dynamic,
  parse_and_expand_argv_dynamic,
  parse_expand,
  Help,
  Bad,
  usage,
  usage_string,
  align,
  current,
  read_arg,
  read_arg0,
  write_arg,
  write_arg0,
}
/* No side effect */
