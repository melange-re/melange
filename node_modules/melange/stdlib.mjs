// Generated by Melange

import * as Caml_bytes from "melange.js/caml_bytes.mjs";
import * as Caml_exceptions from "melange.js/caml_exceptions.mjs";
import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.mjs";
import * as Caml_format from "melange.js/caml_format.mjs";
import * as Caml_io from "melange.js/caml_io.mjs";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.mjs";
import * as Caml_string from "melange.js/caml_string.mjs";
import * as Caml_sys from "melange.js/caml_sys.mjs";
import * as CamlinternalFormatBasics from "./camlinternalFormatBasics.mjs";
import * as Curry from "melange.js/curry.mjs";

function failwith(s) {
  throw new Caml_js_exceptions.MelangeError("Failure", {
      MEL_EXN_ID: "Failure",
      _1: s
    });
}

function invalid_arg(s) {
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: s
    });
}

const Exit = /* @__PURE__ */ Caml_exceptions.create("Stdlib.Exit");

const Failure = "Failure";

const Sys_error = "Sys_error";

const End_of_file = "End_of_file";

function abs(x) {
  if (x >= 0) {
    return x;
  } else {
    return -x | 0;
  }
}

function lnot(x) {
  return x ^ -1;
}

const min_int = -2147483648;

function classify_float(x) {
  if (isFinite(x)) {
    if (Math.abs(x) >= 2.22507385850720138e-308) {
      return /* FP_normal */ 0;
    } else if (x !== 0) {
      return /* FP_subnormal */ 1;
    } else {
      return /* FP_zero */ 2;
    }
  } else if (isNaN(x)) {
    return /* FP_nan */ 4;
  } else {
    return /* FP_infinite */ 3;
  }
}

function char_of_int(n) {
  if (n < 0 || n > 255) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "char_of_int"
      });
  }
  return n;
}

function string_of_bool(b) {
  if (b) {
    return "true";
  } else {
    return "false";
  }
}

function bool_of_string(param) {
  switch (param) {
    case "false" : {
      return false;
      }
    case "true" : {
      return true;
      }
    default:
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "bool_of_string"
        });
  }
}

function bool_of_string_opt(param) {
  switch (param) {
    case "false" : {
      return false;
      }
    case "true" : {
      return true;
      }
    default:
      return;
  }
}

function int_of_string_opt(s) {
  try {
    return Caml_format.caml_int_of_string(s);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Failure) {
      return;
    }
    throw exn;
  }
}

function valid_float_lexem(s) {
  const l = s.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i >= l) {
      return s + ".";
    }
    const match = Caml_string.get(s, i);
    if (match >= 48) {
      if (match >= 58) {
        return s;
      }
      _i = i + 1 | 0;
      continue;
    }
    if (match !== 45) {
      return s;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function string_of_float(f) {
  return valid_float_lexem(Caml_format.caml_format_float("%.12g", f));
}

function float_of_string_opt(s) {
  try {
    return Caml_format.caml_float_of_string(s);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Failure) {
      return;
    }
    throw exn;
  }
}

function $at_dps(_dst, _offset, _l1, l2) {
  while (true) {
    const dst = _dst;
    const offset = _offset;
    const l1 = _l1;
    if (!l1) {
      dst[offset] = l2;
      return;
    }
    const match = l1.tl;
    const h1 = l1.hd;
    if (!match) {
      dst[offset] = {
        hd: h1,
        tl: l2
      };
      return;
    }
    const match$1 = match.tl;
    const h2 = match.hd;
    if (!match$1) {
      dst[offset] = {
        hd: h1,
        tl: {
          hd: h2,
          tl: l2
        }
      };
      return;
    }
    const block = {
      hd: match$1.hd,
      tl: 24029
    };
    dst[offset] = {
      hd: h1,
      tl: {
        hd: h2,
        tl: block
      }
    };
    _l1 = match$1.tl;
    _offset = "tl";
    _dst = block;
    continue;
  };
}

function $at(l1, l2) {
  if (!l1) {
    return l2;
  }
  const match = l1.tl;
  const h1 = l1.hd;
  if (!match) {
    return {
      hd: h1,
      tl: l2
    };
  }
  const match$1 = match.tl;
  const h2 = match.hd;
  if (!match$1) {
    return {
      hd: h1,
      tl: {
        hd: h2,
        tl: l2
      }
    };
  }
  const block = {
    hd: match$1.hd,
    tl: 24029
  };
  return {
    hd: h1,
    tl: {
      hd: h2,
      tl: ($at_dps(block, "tl", match$1.tl, l2), block)
    }
  };
}

const stdin = Caml_io.stdin;

const stdout = Caml_io.stdout;

const stderr = Caml_io.stderr;

function open_out_gen(mode, perm, name) {
  const c = Caml_external_polyfill.resolve("caml_ml_open_descriptor_out")(Caml_external_polyfill.resolve("caml_sys_open")(name, mode, perm));
  Caml_external_polyfill.resolve("caml_ml_set_channel_name")(c, name);
  return c;
}

function open_out(name) {
  return open_out_gen({
    hd: /* Open_wronly */ 1,
    tl: {
      hd: /* Open_creat */ 3,
      tl: {
        hd: /* Open_trunc */ 4,
        tl: {
          hd: /* Open_text */ 7,
          tl: /* [] */ 0
        }
      }
    }
  }, 438, name);
}

function open_out_bin(name) {
  return open_out_gen({
    hd: /* Open_wronly */ 1,
    tl: {
      hd: /* Open_creat */ 3,
      tl: {
        hd: /* Open_trunc */ 4,
        tl: {
          hd: /* Open_binary */ 6,
          tl: /* [] */ 0
        }
      }
    }
  }, 438, name);
}

function flush_all(param) {
  let _param = Caml_io.caml_ml_out_channels_list();
  while (true) {
    const param$1 = _param;
    if (!param$1) {
      return;
    }
    try {
      Caml_io.caml_ml_flush(param$1.hd);
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID !== Sys_error) {
        throw exn;
      }
      
    }
    _param = param$1.tl;
    continue;
  };
}

function output_bytes(oc, s) {
  Caml_external_polyfill.resolve("caml_ml_output_bytes")(oc, s, 0, s.length);
}

function output_string(oc, s) {
  Caml_io.caml_ml_output(oc, s, 0, s.length);
}

function output(oc, s, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "output"
      });
  }
  Caml_external_polyfill.resolve("caml_ml_output_bytes")(oc, s, ofs, len);
}

function output_substring(oc, s, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "output_substring"
      });
  }
  Caml_io.caml_ml_output(oc, s, ofs, len);
}

function output_value(chan, v) {
  Caml_external_polyfill.resolve("caml_output_value")(chan, v, /* [] */ 0);
}

function close_out(oc) {
  Caml_io.caml_ml_flush(oc);
  Caml_external_polyfill.resolve("caml_ml_close_channel")(oc);
}

function close_out_noerr(oc) {
  try {
    Caml_io.caml_ml_flush(oc);
  }
  catch (exn){
    
  }
  try {
    return Caml_external_polyfill.resolve("caml_ml_close_channel")(oc);
  }
  catch (exn$1){
    return;
  }
}

function open_in_gen(mode, perm, name) {
  const c = Caml_external_polyfill.resolve("caml_ml_open_descriptor_in")(Caml_external_polyfill.resolve("caml_sys_open")(name, mode, perm));
  Caml_external_polyfill.resolve("caml_ml_set_channel_name")(c, name);
  return c;
}

function open_in(name) {
  return open_in_gen({
    hd: /* Open_rdonly */ 0,
    tl: {
      hd: /* Open_text */ 7,
      tl: /* [] */ 0
    }
  }, 0, name);
}

function open_in_bin(name) {
  return open_in_gen({
    hd: /* Open_rdonly */ 0,
    tl: {
      hd: /* Open_binary */ 6,
      tl: /* [] */ 0
    }
  }, 0, name);
}

function input(ic, s, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "input"
      });
  }
  return Caml_external_polyfill.resolve("caml_ml_input")(ic, s, ofs, len);
}

function unsafe_really_input(ic, s, _ofs, _len) {
  while (true) {
    const len = _len;
    const ofs = _ofs;
    if (len <= 0) {
      return;
    }
    const r = Caml_external_polyfill.resolve("caml_ml_input")(ic, s, ofs, len);
    if (r === 0) {
      throw new Caml_js_exceptions.MelangeError(End_of_file, {
          MEL_EXN_ID: End_of_file
        });
    }
    _len = len - r | 0;
    _ofs = ofs + r | 0;
    continue;
  };
}

function really_input(ic, s, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "really_input"
      });
  }
  unsafe_really_input(ic, s, ofs, len);
}

function really_input_string(ic, len) {
  const s = Caml_bytes.caml_create_bytes(len);
  really_input(ic, s, 0, len);
  return Caml_bytes.bytes_to_string(s);
}

function input_line(chan) {
  const build_result = function (buf, _pos, _param) {
    while (true) {
      const param = _param;
      const pos = _pos;
      if (!param) {
        return buf;
      }
      const hd = param.hd;
      const len = hd.length;
      Caml_bytes.caml_blit_bytes(hd, 0, buf, pos - len | 0, len);
      _param = param.tl;
      _pos = pos - len | 0;
      continue;
    };
  };
  const scan = function (_accu, _len) {
    while (true) {
      const len = _len;
      const accu = _accu;
      const n = Caml_external_polyfill.resolve("caml_ml_input_scan_line")(chan);
      if (n === 0) {
        if (accu) {
          return build_result(Caml_bytes.caml_create_bytes(len), len, accu);
        }
        throw new Caml_js_exceptions.MelangeError(End_of_file, {
            MEL_EXN_ID: End_of_file
          });
      }
      if (n > 0) {
        const res = Caml_bytes.caml_create_bytes(n - 1 | 0);
        Caml_external_polyfill.resolve("caml_ml_input")(chan, res, 0, n - 1 | 0);
        Caml_external_polyfill.resolve("caml_ml_input_char")(chan);
        if (!accu) {
          return res;
        }
        const len$1 = (len + n | 0) - 1 | 0;
        return build_result(Caml_bytes.caml_create_bytes(len$1), len$1, {
          hd: res,
          tl: accu
        });
      }
      const beg = Caml_bytes.caml_create_bytes(-n | 0);
      Caml_external_polyfill.resolve("caml_ml_input")(chan, beg, 0, -n | 0);
      _len = len - n | 0;
      _accu = {
        hd: beg,
        tl: accu
      };
      continue;
    };
  };
  return Caml_bytes.bytes_to_string(scan(/* [] */ 0, 0));
}

function close_in_noerr(ic) {
  try {
    return Caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
  }
  catch (exn){
    return;
  }
}

function print_char(c) {
  Caml_io.caml_ml_output_char(stdout, c);
}

function print_string(s) {
  output_string(stdout, s);
}

function print_bytes(s) {
  output_bytes(stdout, s);
}

function print_int(i) {
  output_string(stdout, String(i));
}

function print_float(f) {
  output_string(stdout, valid_float_lexem(Caml_format.caml_format_float("%.12g", f)));
}

function print_newline(param) {
  Caml_io.caml_ml_output_char(stdout, /* '\n' */10);
  Caml_io.caml_ml_flush(stdout);
}

function prerr_char(c) {
  Caml_io.caml_ml_output_char(stderr, c);
}

function prerr_string(s) {
  output_string(stderr, s);
}

function prerr_bytes(s) {
  output_bytes(stderr, s);
}

function prerr_int(i) {
  output_string(stderr, String(i));
}

function prerr_float(f) {
  output_string(stderr, valid_float_lexem(Caml_format.caml_format_float("%.12g", f)));
}

function prerr_newline(param) {
  Caml_io.caml_ml_output_char(stderr, /* '\n' */10);
  Caml_io.caml_ml_flush(stderr);
}

function read_line(param) {
  Caml_io.caml_ml_flush(stdout);
  return input_line(stdin);
}

function read_int(param) {
  return Caml_format.caml_int_of_string((Caml_io.caml_ml_flush(stdout), input_line(stdin)));
}

function read_int_opt(param) {
  return int_of_string_opt((Caml_io.caml_ml_flush(stdout), input_line(stdin)));
}

function read_float(param) {
  return Caml_format.caml_float_of_string((Caml_io.caml_ml_flush(stdout), input_line(stdin)));
}

function read_float_opt(param) {
  return float_of_string_opt((Caml_io.caml_ml_flush(stdout), input_line(stdin)));
}

function string_of_format(param) {
  return param._1;
}

function $caret$caret(param, param$1) {
  return {
    TAG: /* Format */ 0,
    _0: CamlinternalFormatBasics.concat_fmt(param._0, param$1._0),
    _1: param._1 + ("%," + param$1._1)
  };
}

const exit_function = {
  contents: flush_all
};

function at_exit(f) {
  const f_yet_to_run = {
    contents: true
  };
  const old_exit = exit_function.contents;
  const new_exit = function (param) {
    if (!f_yet_to_run.contents) {
      f_yet_to_run.contents = false;
      Curry._1(f, undefined);
    }
    Curry._1(old_exit, undefined);
  };
  exit_function.contents = new_exit;
}

const do_domain_local_at_exit = {
  contents: (function (param) {
    
  })
};

function do_at_exit(param) {
  Curry._1(do_domain_local_at_exit.contents, undefined);
  Curry._1(exit_function.contents, undefined);
}

function exit(retcode) {
  do_at_exit();
  return Caml_sys.caml_sys_exit(retcode);
}

const Match_failure = "Match_failure";

const Assert_failure = "Assert_failure";

const Invalid_argument = "Invalid_argument";

const Not_found = "Not_found";

const Out_of_memory = "Out_of_memory";

const Stack_overflow = "Stack_overflow";

const Division_by_zero = "Division_by_zero";

const Sys_blocked_io = "Sys_blocked_io";

const Undefined_recursive_module = "Undefined_recursive_module";

const max_int = 2147483647;

const infinity = Infinity;

const neg_infinity = -Infinity;

const max_float = 1.79769313486231571e+308;

const min_float = 2.22507385850720138e-308;

const epsilon_float = 2.22044604925031308e-16;

const flush = Caml_io.caml_ml_flush;

const output_char = Caml_io.caml_ml_output_char;

const output_byte = Caml_io.caml_ml_output_char;

function output_binary_int(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_ml_output_int")(prim0, prim1);
}

function seek_out(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_ml_seek_out")(prim0, prim1);
}

function pos_out(prim) {
  return Caml_external_polyfill.resolve("caml_ml_pos_out")(prim);
}

function out_channel_length(prim) {
  return Caml_external_polyfill.resolve("caml_ml_channel_size")(prim);
}

function set_binary_mode_out(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_ml_set_binary_mode")(prim0, prim1);
}

function input_char(prim) {
  return Caml_external_polyfill.resolve("caml_ml_input_char")(prim);
}

function input_byte(prim) {
  return Caml_external_polyfill.resolve("caml_ml_input_char")(prim);
}

function input_binary_int(prim) {
  return Caml_external_polyfill.resolve("caml_ml_input_int")(prim);
}

function input_value(prim) {
  return Caml_external_polyfill.resolve("caml_input_value")(prim);
}

function seek_in(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_ml_seek_in")(prim0, prim1);
}

function pos_in(prim) {
  return Caml_external_polyfill.resolve("caml_ml_pos_in")(prim);
}

function in_channel_length(prim) {
  return Caml_external_polyfill.resolve("caml_ml_channel_size")(prim);
}

function close_in(prim) {
  return Caml_external_polyfill.resolve("caml_ml_close_channel")(prim);
}

function set_binary_mode_in(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_ml_set_binary_mode")(prim0, prim1);
}

function LargeFile_seek_out(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_ml_seek_out_64")(prim0, prim1);
}

function LargeFile_pos_out(prim) {
  return Caml_external_polyfill.resolve("caml_ml_pos_out_64")(prim);
}

function LargeFile_out_channel_length(prim) {
  return Caml_external_polyfill.resolve("caml_ml_channel_size_64")(prim);
}

function LargeFile_seek_in(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_ml_seek_in_64")(prim0, prim1);
}

function LargeFile_pos_in(prim) {
  return Caml_external_polyfill.resolve("caml_ml_pos_in_64")(prim);
}

function LargeFile_in_channel_length(prim) {
  return Caml_external_polyfill.resolve("caml_ml_channel_size_64")(prim);
}

const LargeFile = {
  seek_out: LargeFile_seek_out,
  pos_out: LargeFile_pos_out,
  out_channel_length: LargeFile_out_channel_length,
  seek_in: LargeFile_seek_in,
  pos_in: LargeFile_pos_in,
  in_channel_length: LargeFile_in_channel_length
};

export {
  invalid_arg,
  failwith,
  Exit,
  Match_failure,
  Assert_failure,
  Invalid_argument,
  Failure,
  Not_found,
  Out_of_memory,
  Stack_overflow,
  Sys_error,
  End_of_file,
  Division_by_zero,
  Sys_blocked_io,
  Undefined_recursive_module,
  abs,
  max_int,
  min_int,
  lnot,
  infinity,
  neg_infinity,
  max_float,
  min_float,
  epsilon_float,
  classify_float,
  char_of_int,
  string_of_bool,
  bool_of_string_opt,
  bool_of_string,
  int_of_string_opt,
  string_of_float,
  float_of_string_opt,
  $at,
  stdin,
  stdout,
  stderr,
  print_char,
  print_string,
  print_bytes,
  print_int,
  print_float,
  print_newline,
  prerr_char,
  prerr_string,
  prerr_bytes,
  prerr_int,
  prerr_float,
  prerr_newline,
  read_line,
  read_int_opt,
  read_int,
  read_float_opt,
  read_float,
  open_out,
  open_out_bin,
  open_out_gen,
  flush,
  flush_all,
  output_char,
  output_string,
  output_bytes,
  output,
  output_substring,
  output_byte,
  output_binary_int,
  output_value,
  seek_out,
  pos_out,
  out_channel_length,
  close_out,
  close_out_noerr,
  set_binary_mode_out,
  open_in,
  open_in_bin,
  open_in_gen,
  input_char,
  input_line,
  input,
  really_input,
  really_input_string,
  input_byte,
  input_binary_int,
  input_value,
  seek_in,
  pos_in,
  in_channel_length,
  close_in,
  close_in_noerr,
  set_binary_mode_in,
  LargeFile,
  string_of_format,
  $caret$caret,
  exit,
  at_exit,
  valid_float_lexem,
  unsafe_really_input,
  do_at_exit,
  do_domain_local_at_exit,
}
/* No side effect */
