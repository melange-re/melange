// Generated by Melange
'use strict';

const Caml = require("melange.js/caml.js");
const Caml_format = require("melange.js/caml_format.js");
const Caml_hash = require("melange.js/caml_hash.js");
const Caml_js_exceptions = require("melange.js/caml_js_exceptions.js");

function err_not_sv(i) {
  return Caml_format.caml_format_int("%X", i) + " is not a Unicode scalar value";
}

function err_not_latin1(u) {
  return "U+" + (Caml_format.caml_format_int("%04X", u) + " is not a latin1 character");
}

function succ(u) {
  if (u === 55295) {
    return 57344;
  }
  if (u === 1114111) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "U+10FFFF has no successor"
      });
  }
  return u + 1 | 0;
}

function pred(u) {
  if (u === 57344) {
    return 55295;
  }
  if (u === 0) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "U+0000 has no predecessor"
      });
  }
  return u - 1 | 0;
}

function is_valid(i) {
  if (0 <= i && i <= 55295) {
    return true;
  } else if (57344 <= i) {
    return i <= 1114111;
  } else {
    return false;
  }
}

function of_int(i) {
  if (is_valid(i)) {
    return i;
  }
  const s = err_not_sv(i);
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: s
    });
}

function is_char(u) {
  return u < 256;
}

function of_char(c) {
  return c;
}

function to_char(u) {
  if (u <= 255) {
    return u;
  }
  const s = err_not_latin1(u);
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: s
    });
}

function unsafe_to_char(prim) {
  return prim;
}

function equal(prim0, prim1) {
  return prim0 === prim1;
}

const compare = Caml.caml_int_compare;

function seeded_hash(seed, x) {
  return Caml_hash.caml_hash(10, 100, seed, x);
}

function hash(x) {
  return Caml_hash.caml_hash(10, 100, 0, x);
}

function utf_decode_is_valid(d) {
  return (d >>> 27) === 1;
}

function utf_decode_length(d) {
  return (d >>> 24) & 7;
}

function utf_decode_uchar(d) {
  return d & 16777215;
}

function utf_decode(n, u) {
  return ((8 | n) << 24) | u;
}

function utf_decode_invalid(n) {
  return (n << 24) | 65533;
}

function utf_8_decode_length_of_byte(param) {
  if (param >= 194) {
    if (param >= 240) {
      if (param >= 245) {
        return 0;
      } else {
        return 4;
      }
    } else if (param >= 224) {
      return 3;
    } else {
      return 2;
    }
  } else if (param >= 128) {
    return 0;
  } else {
    return 1;
  }
}

function utf_8_byte_length(u) {
  if (u < 0) {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "jscomp/stdlib/uchar.ml",
          94,
          18
        ]
      });
  }
  if (u <= 127) {
    return 1;
  }
  if (u <= 2047) {
    return 2;
  }
  if (u <= 65535) {
    return 3;
  }
  if (u <= 1114111) {
    return 4;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
      MEL_EXN_ID: "Assert_failure",
      _1: [
        "jscomp/stdlib/uchar.ml",
        99,
        7
      ]
    });
}

function utf_16_byte_length(u) {
  if (u < 0) {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "jscomp/stdlib/uchar.ml",
          102,
          18
        ]
      });
  }
  if (u <= 65535) {
    return 2;
  }
  if (u <= 1114111) {
    return 4;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
      MEL_EXN_ID: "Assert_failure",
      _1: [
        "jscomp/stdlib/uchar.ml",
        105,
        7
      ]
    });
}

const min = 0;

const max = 1114111;

const bom = 65279;

const rep = 65533;

function unsafe_of_int(prim) {
  return prim;
}

function to_int(prim) {
  return prim;
}

const max_utf_8_decode_length = 4;

module.exports = {
  min,
  max,
  bom,
  rep,
  succ,
  pred,
  is_valid,
  of_int,
  unsafe_of_int,
  to_int,
  is_char,
  of_char,
  to_char,
  unsafe_to_char,
  equal,
  compare,
  seeded_hash,
  hash,
  utf_decode_is_valid,
  utf_decode_uchar,
  utf_decode_length,
  utf_decode,
  utf_decode_invalid,
  utf_8_decode_length_of_byte,
  max_utf_8_decode_length,
  utf_8_byte_length,
  utf_16_byte_length,
}
/* No side effect */
