// Generated by Melange
'use strict';

const Caml_array = require("melange.js/caml_array.js");
const Caml_external_polyfill = require("melange.js/caml_external_polyfill.js");
const Caml_js_exceptions = require("melange.js/caml_js_exceptions.js");
const Caml_obj = require("melange.js/caml_obj.js");
const Caml_option = require("melange.js/caml_option.js");
const Curry = require("melange.js/curry.js");
const Stdlib__Array = require("./array.js");

const init = Stdlib__Array.init;

function append(a1, a2) {
  if (a1.length === 0) {
    return a2;
  } else if (a2.length === 0) {
    return a1;
  } else {
    return Caml_external_polyfill.resolve("caml_array_append")(a1, a2);
  }
}

function sub(a, pos, len) {
  if (pos < 0 || len < 0 || pos > (a.length - len | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Iarray.sub"
      });
  }
  return Caml_array.sub(a, pos, len);
}

function iter(f, a) {
  for (let i = 0, i_finish = a.length; i < i_finish; ++i) {
    Curry._1(f, a[i]);
  }
}

function iter2(f, a, b) {
  if (a.length !== b.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Iarray.iter2: arrays must have the same length"
      });
  }
  for (let i = 0, i_finish = a.length; i < i_finish; ++i) {
    Curry._2(f, a[i], b[i]);
  }
}

function map(f, a) {
  const l = a.length;
  let tmp;
  if (l === 0) {
    tmp = [];
  } else {
    const r = Caml_array.make(l, Curry._1(f, a[0]));
    for (let i = 1; i < l; ++i) {
      r[i] = Curry._1(f, a[i]);
    }
    tmp = r;
  }
  return tmp;
}

function map2(f, a, b) {
  const la = a.length;
  const lb = b.length;
  if (la !== lb) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Iarray.map2: arrays must have the same length"
      });
  }
  let tmp;
  if (la === 0) {
    tmp = [];
  } else {
    const r = Caml_array.make(la, Curry._2(f, a[0], b[0]));
    for (let i = 1; i < la; ++i) {
      r[i] = Curry._2(f, a[i], b[i]);
    }
    tmp = r;
  }
  return tmp;
}

function iteri(f, a) {
  for (let i = 0, i_finish = a.length; i < i_finish; ++i) {
    Curry._2(f, i, a[i]);
  }
}

function mapi(f, a) {
  const l = a.length;
  let tmp;
  if (l === 0) {
    tmp = [];
  } else {
    const r = Caml_array.make(l, Curry._2(f, 0, a[0]));
    for (let i = 1; i < l; ++i) {
      r[i] = Curry._2(f, i, a[i]);
    }
    tmp = r;
  }
  return tmp;
}

function to_list(a) {
  let _i = a.length - 1 | 0;
  let _res = /* [] */ 0;
  while (true) {
    const res = _res;
    const i = _i;
    if (i < 0) {
      return res;
    }
    _res = {
      hd: a[i],
      tl: res
    };
    _i = i - 1 | 0;
    continue;
  };
}

const of_list = Stdlib__Array.of_list;

const to_array = Stdlib__Array.copy;

const of_array = Stdlib__Array.copy;

function fold_left(f, x, a) {
  let r = x;
  for (let i = 0, i_finish = a.length; i < i_finish; ++i) {
    r = Curry._2(f, r, a[i]);
  }
  return r;
}

function fold_left_map(f, acc, input_array) {
  const len = input_array.length;
  let match;
  if (len === 0) {
    match = [
      acc,
      []
    ];
  } else {
    const match$1 = Curry._2(f, acc, input_array[0]);
    const output_array = Caml_array.make(len, match$1[1]);
    let acc$1 = match$1[0];
    for (let i = 1; i < len; ++i) {
      const match$2 = Curry._2(f, acc$1, input_array[i]);
      acc$1 = match$2[0];
      output_array[i] = match$2[1];
    }
    match = [
      acc$1,
      output_array
    ];
  }
  return [
    match[0],
    match[1]
  ];
}

function fold_right(f, a, x) {
  let r = x;
  for (let i = a.length - 1 | 0; i >= 0; --i) {
    r = Curry._2(f, a[i], r);
  }
  return r;
}

function exists(p, a) {
  const n = a.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return false;
    }
    if (Curry._1(p, a[i])) {
      return true;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function for_all(p, a) {
  const n = a.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return true;
    }
    if (!Curry._1(p, a[i])) {
      return false;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function for_all2(p, l1, l2) {
  const n1 = l1.length;
  const n2 = l2.length;
  if (n1 !== n2) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Iarray.for_all2"
      });
  }
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n1) {
      return true;
    }
    if (!Curry._2(p, l1[i], l2[i])) {
      return false;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function exists2(p, l1, l2) {
  const n1 = l1.length;
  const n2 = l2.length;
  if (n1 !== n2) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Iarray.exists2"
      });
  }
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n1) {
      return false;
    }
    if (Curry._2(p, l1[i], l2[i])) {
      return true;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function equal(eq, a1, a2) {
  if (a1.length === a2.length) {
    return for_all2(eq, a1, a2);
  } else {
    return false;
  }
}

function compare(cmp, a1, a2) {
  if (a1.length !== a2.length) {
    return a1.length - a2.length | 0;
  }
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === a1.length) {
      return 0;
    }
    const c = Curry._2(cmp, a1[i], a2[i]);
    if (c !== 0) {
      return c;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function mem(x, a) {
  const n = a.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return false;
    }
    if (Caml_obj.caml_equal(a[i], x)) {
      return true;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function memq(x, a) {
  const n = a.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return false;
    }
    if (x === a[i]) {
      return true;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function find_opt(p, a) {
  const n = a.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return;
    }
    const x = a[i];
    if (Curry._1(p, x)) {
      return Caml_option.some(x);
    }
    _i = i + 1 | 0;
    continue;
  };
}

function find_index(p, a) {
  const n = a.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return;
    }
    if (Curry._1(p, a[i])) {
      return i;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function find_map(f, a) {
  const n = a.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return;
    }
    const r = Curry._1(f, a[i]);
    if (r !== undefined) {
      return r;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function find_mapi(f, a) {
  const n = a.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return;
    }
    const r = Curry._2(f, i, a[i]);
    if (r !== undefined) {
      return r;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function split(x) {
  if (equal(Caml_obj.caml_equal, x, [])) {
    return [
      [],
      []
    ];
  }
  const match = x[0];
  const n = x.length;
  const a = Caml_array.make(n, match[0]);
  const b = Caml_array.make(n, match[1]);
  for (let i = 1; i < n; ++i) {
    const match$1 = x[i];
    a[i] = match$1[0];
    b[i] = match$1[1];
  }
  return [
    a,
    b
  ];
}

function combine(a, b) {
  const na = a.length;
  const nb = b.length;
  if (na !== nb) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Iarray.combine"
      });
  }
  let tmp;
  if (na === 0) {
    tmp = [];
  } else {
    const x = Caml_array.make(na, [
      a[0],
      b[0]
    ]);
    for (let i = 1; i < na; ++i) {
      x[i] = [
        a[i],
        b[i]
      ];
    }
    tmp = x;
  }
  return tmp;
}

function lift_sort(sorter, cmp, iarr) {
  const arr = Stdlib__Array.copy(iarr);
  Curry._2(sorter, cmp, arr);
  return arr;
}

function sort(cmp, iarr) {
  return lift_sort(Stdlib__Array.sort, cmp, iarr);
}

function stable_sort(cmp, iarr) {
  return lift_sort(Stdlib__Array.stable_sort, cmp, iarr);
}

function fast_sort(cmp, iarr) {
  return lift_sort(Stdlib__Array.fast_sort, cmp, iarr);
}

function to_seq(a) {
  const aux = function (i, param) {
    if (i >= a.length) {
      return /* Nil */ 0;
    }
    const x = a[i];
    const partial_arg = i + 1 | 0;
    return {
      TAG: /* Cons */ 0,
      _0: x,
      _1: (function (param) {
        return aux(partial_arg, param);
      })
    };
  };
  return function (param) {
    return aux(0, param);
  };
}

function to_seqi(a) {
  const aux = function (i, param) {
    if (i >= a.length) {
      return /* Nil */ 0;
    }
    const x = a[i];
    const partial_arg = i + 1 | 0;
    return {
      TAG: /* Cons */ 0,
      _0: [
        i,
        x
      ],
      _1: (function (param) {
        return aux(partial_arg, param);
      })
    };
  };
  return function (param) {
    return aux(0, param);
  };
}

const of_seq = Stdlib__Array.of_seq;

const concat = Caml_array.concat;

module.exports = {
  init,
  append,
  concat,
  sub,
  to_list,
  of_list,
  to_array,
  of_array,
  equal,
  compare,
  iter,
  iteri,
  map,
  mapi,
  fold_left,
  fold_left_map,
  fold_right,
  iter2,
  map2,
  for_all,
  exists,
  for_all2,
  exists2,
  mem,
  memq,
  find_opt,
  find_index,
  find_map,
  find_mapi,
  split,
  combine,
  sort,
  stable_sort,
  fast_sort,
  to_seq,
  to_seqi,
  of_seq,
}
/* No side effect */
