// Generated by Melange
'use strict';

const Caml_bytes = require("melange.js/caml_bytes.js");
const Caml_js_exceptions = require("melange.js/caml_js_exceptions.js");
const Caml_string = require("melange.js/caml_string.js");
const Curry = require("melange.js/curry.js");
const Stdlib = require("./stdlib.js");
const Stdlib__Bytes = require("./bytes.js");
const Stdlib__Seq = require("./seq.js");
const Stdlib__String = require("./string.js");
const Stdlib__Sys = require("./sys.js");

function create(n) {
  const n$1 = n < 1 ? 1 : n;
  const n$2 = n$1 > Stdlib__Sys.max_string_length ? Stdlib__Sys.max_string_length : n$1;
  const s = Caml_bytes.caml_create_bytes(n$2);
  return {
    inner: {
      buffer: s,
      length: n$2
    },
    position: 0,
    initial_buffer: s
  };
}

function contents(b) {
  return Stdlib__Bytes.sub_string(b.inner.buffer, 0, b.position);
}

function to_bytes(b) {
  return Stdlib__Bytes.sub(b.inner.buffer, 0, b.position);
}

function sub(b, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (b.position - len | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Buffer.sub"
      });
  }
  return Stdlib__Bytes.sub_string(b.inner.buffer, ofs, len);
}

function blit(src, srcoff, dst, dstoff, len) {
  if (len < 0 || srcoff < 0 || srcoff > (src.position - len | 0) || dstoff < 0 || dstoff > (dst.length - len | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Buffer.blit"
      });
  }
  Stdlib__Bytes.blit(src.inner.buffer, srcoff, dst, dstoff, len);
}

function nth(b, ofs) {
  const position = b.position;
  const match = b.inner;
  if (ofs < 0 || ofs >= position || position > match.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Buffer.nth"
      });
  }
  return match.buffer[ofs];
}

function length(b) {
  return b.position;
}

function clear(b) {
  b.position = 0;
}

function reset(b) {
  b.position = 0;
  const inner_buffer = b.initial_buffer;
  const inner_length = b.initial_buffer.length;
  const inner = {
    buffer: inner_buffer,
    length: inner_length
  };
  b.inner = inner;
}

function resize(b, more) {
  const old_pos = b.position;
  const old_len = b.inner.length;
  let new_len = old_len;
  while ((old_pos + more | 0) > new_len) {
    new_len = (new_len << 1);
  };
  if (new_len > Stdlib__Sys.max_string_length) {
    if ((old_pos + more | 0) <= Stdlib__Sys.max_string_length) {
      new_len = Stdlib__Sys.max_string_length;
    } else {
      throw new Caml_js_exceptions.MelangeError("Failure", {
          MEL_EXN_ID: "Failure",
          _1: "Buffer.add: cannot grow buffer"
        });
    }
  }
  const new_buffer = Caml_bytes.caml_create_bytes(new_len);
  Stdlib__Bytes.blit(b.inner.buffer, 0, new_buffer, 0, b.position);
  b.inner = {
    buffer: new_buffer,
    length: new_len
  };
}

function add_char(b, c) {
  const pos = b.position;
  const match = b.inner;
  if (pos >= match.length) {
    resize(b, 1);
    Caml_bytes.set(b.inner.buffer, b.position, c);
  } else {
    match.buffer[pos] = c;
  }
  b.position = pos + 1 | 0;
}

function add_utf_8_uchar(b, u) {
  while (true) {
    const pos = b.position;
    if (pos >= b.inner.length) {
      resize(b, 4);
    }
    const n = Stdlib__Bytes.set_utf_8_uchar(b.inner.buffer, pos, u);
    if (n !== 0) {
      b.position = pos + n | 0;
      return;
    }
    resize(b, 4);
    continue;
  };
}

function add_utf_16be_uchar(b, u) {
  while (true) {
    const pos = b.position;
    if (pos >= b.inner.length) {
      resize(b, 4);
    }
    const n = Stdlib__Bytes.set_utf_16be_uchar(b.inner.buffer, pos, u);
    if (n !== 0) {
      b.position = pos + n | 0;
      return;
    }
    resize(b, 4);
    continue;
  };
}

function add_utf_16le_uchar(b, u) {
  while (true) {
    const pos = b.position;
    if (pos >= b.inner.length) {
      resize(b, 4);
    }
    const n = Stdlib__Bytes.set_utf_16le_uchar(b.inner.buffer, pos, u);
    if (n !== 0) {
      b.position = pos + n | 0;
      return;
    }
    resize(b, 4);
    continue;
  };
}

function add_substring(b, s, offset, len) {
  if (offset < 0 || len < 0 || offset > (s.length - len | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Buffer.add_substring"
      });
  }
  const position = b.position;
  const match = b.inner;
  const new_position = position + len | 0;
  if (new_position > match.length) {
    resize(b, len);
    Stdlib__Bytes.blit_string(s, offset, b.inner.buffer, b.position, len);
  } else {
    Caml_bytes.caml_blit_string(s, offset, match.buffer, position, len);
  }
  b.position = new_position;
}

function add_subbytes(b, bytes, offset, len) {
  if (offset < 0 || len < 0 || offset > (bytes.length - len | 0)) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Buffer.add_subbytes"
      });
  }
  const position = b.position;
  const match = b.inner;
  const new_position = position + len | 0;
  if (new_position > match.length) {
    resize(b, len);
    Stdlib__Bytes.blit(bytes, offset, b.inner.buffer, b.position, len);
  } else {
    Caml_bytes.caml_blit_bytes(bytes, offset, match.buffer, position, len);
  }
  b.position = new_position;
}

function add_string(b, s) {
  add_substring(b, s, 0, s.length);
}

function add_bytes(b, bytes) {
  add_subbytes(b, bytes, 0, bytes.length);
}

function add_buffer(b, bs) {
  add_subbytes(b, bs.inner.buffer, 0, bs.position);
}

function really_input_up_to(ic, buf, ofs, len) {
  let _already_read = 0;
  let _ofs = ofs;
  let _to_read = len;
  while (true) {
    const to_read = _to_read;
    const ofs$1 = _ofs;
    const already_read = _already_read;
    if (to_read === 0) {
      return already_read;
    }
    const r = Stdlib.input(ic, buf, ofs$1, to_read);
    if (r === 0) {
      return already_read;
    }
    const already_read$1 = already_read + r | 0;
    const ofs$2 = ofs$1 + r | 0;
    const to_read$1 = to_read - r | 0;
    _to_read = to_read$1;
    _ofs = ofs$2;
    _already_read = already_read$1;
    continue;
  };
}

function unsafe_add_channel_up_to(b, ic, len) {
  if ((b.position + len | 0) > b.inner.length) {
    resize(b, len);
  }
  const n = really_input_up_to(ic, b.inner.buffer, b.position, len);
  b.position = b.position + n | 0;
  return n;
}

function add_channel(b, ic, len) {
  if (len < 0 || len > Stdlib__Sys.max_string_length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Buffer.add_channel"
      });
  }
  const n = unsafe_add_channel_up_to(b, ic, len);
  if (n < len) {
    throw new Caml_js_exceptions.MelangeError(Stdlib.End_of_file, {
        MEL_EXN_ID: Stdlib.End_of_file
      });
  }
  
}

function output_buffer(oc, b) {
  Stdlib.output(oc, b.inner.buffer, 0, b.position);
}

function closing(param) {
  if (param === 40) {
    return /* ')' */41;
  }
  if (param === 123) {
    return /* '}' */125;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
      MEL_EXN_ID: "Assert_failure",
      _1: [
        "jscomp/stdlib/buffer.ml",
        222,
        9
      ]
    });
}

function advance_to_closing(opening, closing, k, s, start) {
  let _k = k;
  let _i = start;
  let lim = s.length;
  while (true) {
    const i = _i;
    const k$1 = _k;
    if (i >= lim) {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
          MEL_EXN_ID: Stdlib.Not_found
        });
    }
    if (Caml_string.get(s, i) === opening) {
      _i = i + 1 | 0;
      _k = k$1 + 1 | 0;
      continue;
    }
    if (Caml_string.get(s, i) === closing) {
      if (k$1 === 0) {
        return i;
      }
      _i = i + 1 | 0;
      _k = k$1 - 1 | 0;
      continue;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function advance_to_non_alpha(s, start) {
  let _i = start;
  let lim = s.length;
  while (true) {
    const i = _i;
    if (i >= lim) {
      return lim;
    }
    const match = Caml_string.get(s, i);
    if (match >= 91) {
      if (match >= 97) {
        if (match >= 123) {
          return i;
        }
        
      } else if (match !== 95) {
        return i;
      }
      
    } else if (match >= 58) {
      if (match < 65) {
        return i;
      }
      
    } else if (match < 48) {
      return i;
    }
    _i = i + 1 | 0;
    continue;
  };
}

function find_ident(s, start, lim) {
  if (start >= lim) {
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
        MEL_EXN_ID: Stdlib.Not_found
      });
  }
  const c = Caml_string.get(s, start);
  if (c !== 40 && c !== 123) {
    const stop = advance_to_non_alpha(s, start);
    if (stop === start) {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
          MEL_EXN_ID: Stdlib.Not_found
        });
    }
    return [
      Stdlib__String.sub(s, start, stop - start | 0),
      stop
    ];
  }
  const new_start = start + 1 | 0;
  const stop$1 = advance_to_closing(c, closing(c), 0, s, new_start);
  return [
    Stdlib__String.sub(s, new_start, (stop$1 - start | 0) - 1 | 0),
    stop$1 + 1 | 0
  ];
}

function add_substitute(b, f, s) {
  const lim = s.length;
  let _previous = /* ' ' */32;
  let _i = 0;
  while (true) {
    const i = _i;
    const previous = _previous;
    if (i >= lim) {
      if (previous === /* '\\' */92) {
        return add_char(b, previous);
      } else {
        return;
      }
    }
    const current = Caml_string.get(s, i);
    if (current !== 36) {
      if (previous === /* '\\' */92) {
        add_char(b, previous);
      }
      if (current !== /* '\\' */92) {
        add_char(b, current);
      }
      _i = i + 1 | 0;
      _previous = current;
      continue;
    }
    if (previous === /* '\\' */92) {
      add_char(b, current);
      _i = i + 1 | 0;
      _previous = /* ' ' */32;
      continue;
    }
    const j = i + 1 | 0;
    let val;
    try {
      val = find_ident(s, j, lim);
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        add_char(b, /* '$' */36);
        _i = j;
        _previous = /* ' ' */32;
        continue;
      }
      throw exn;
    }
    add_string(b, Curry._1(f, val[0]));
    _i = val[1];
    _previous = /* ' ' */32;
    continue;
  };
}

function truncate(b, len) {
  if (len < 0 || len > b.position) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Buffer.truncate"
      });
  }
  b.position = len;
}

function to_seq(b) {
  const aux = function (i, param) {
    if (i >= b.position) {
      return /* Nil */ 0;
    }
    const x = Caml_bytes.get(b.inner.buffer, i);
    const partial_arg = i + 1 | 0;
    return {
      TAG: /* Cons */ 0,
      _0: x,
      _1: (function (param) {
        return aux(partial_arg, param);
      })
    };
  };
  return function (param) {
    return aux(0, param);
  };
}

function to_seqi(b) {
  const aux = function (i, param) {
    if (i >= b.position) {
      return /* Nil */ 0;
    }
    const x = Caml_bytes.get(b.inner.buffer, i);
    const partial_arg = i + 1 | 0;
    return {
      TAG: /* Cons */ 0,
      _0: [
        i,
        x
      ],
      _1: (function (param) {
        return aux(partial_arg, param);
      })
    };
  };
  return function (param) {
    return aux(0, param);
  };
}

function add_seq(b, seq) {
  Stdlib__Seq.iter((function (param) {
    return add_char(b, param);
  }), seq);
}

function of_seq(i) {
  const b = create(32);
  Stdlib__Seq.iter((function (param) {
    return add_char(b, param);
  }), i);
  return b;
}

function add_int8(b, x) {
  const position = b.position;
  const match = b.inner;
  const new_position = position + 1 | 0;
  if (new_position > match.length) {
    resize(b, 1);
    Caml_bytes.set(b.inner.buffer, b.position, x);
  } else {
    match.buffer[position] = x;
  }
  b.position = new_position;
}

function add_int16_ne(b, x) {
  const position = b.position;
  const match = b.inner;
  const new_position = position + 2 | 0;
  if (new_position > match.length) {
    resize(b, 2);
    Caml_bytes.set16(b.inner.buffer, b.position, x);
  } else {
    Caml_bytes.set16u(match.buffer, position, x);
  }
  b.position = new_position;
}

function add_int32_ne(b, x) {
  const position = b.position;
  const match = b.inner;
  const new_position = position + 4 | 0;
  if (new_position > match.length) {
    resize(b, 4);
    Caml_bytes.set32(b.inner.buffer, b.position, x);
  } else {
    Caml_bytes.set32u(match.buffer, position, x);
  }
  b.position = new_position;
}

function add_int64_ne(b, x) {
  const position = b.position;
  const match = b.inner;
  const new_position = position + 8 | 0;
  if (new_position > match.length) {
    resize(b, 8);
    Caml_bytes.set64(b.inner.buffer, b.position, x);
  } else {
    Caml_bytes.set64u(match.buffer, position, x);
  }
  b.position = new_position;
}

function add_int16_le(b, x) {
  add_int16_ne(b, Stdlib__Sys.big_endian ? Caml_bytes.bswap16(x) : x);
}

function add_int16_be(b, x) {
  add_int16_ne(b, Stdlib__Sys.big_endian ? x : Caml_bytes.bswap16(x));
}

function add_int32_le(b, x) {
  add_int32_ne(b, Stdlib__Sys.big_endian ? Caml_bytes.bswap32(x) : x);
}

function add_int32_be(b, x) {
  add_int32_ne(b, Stdlib__Sys.big_endian ? x : Caml_bytes.bswap32(x));
}

function add_int64_le(b, x) {
  add_int64_ne(b, Stdlib__Sys.big_endian ? Caml_bytes.bswap64(x) : x);
}

function add_int64_be(b, x) {
  add_int64_ne(b, Stdlib__Sys.big_endian ? x : Caml_bytes.bswap64(x));
}

const add_uint8 = add_int8;

const add_uint16_ne = add_int16_ne;

const add_uint16_be = add_int16_be;

const add_uint16_le = add_int16_le;

module.exports = {
  create,
  contents,
  to_bytes,
  sub,
  blit,
  nth,
  length,
  clear,
  reset,
  output_buffer,
  truncate,
  add_char,
  add_utf_8_uchar,
  add_utf_16le_uchar,
  add_utf_16be_uchar,
  add_string,
  add_bytes,
  add_substring,
  add_subbytes,
  add_substitute,
  add_buffer,
  add_channel,
  to_seq,
  to_seqi,
  add_seq,
  of_seq,
  add_uint8,
  add_int8,
  add_uint16_ne,
  add_uint16_be,
  add_uint16_le,
  add_int16_ne,
  add_int16_be,
  add_int16_le,
  add_int32_ne,
  add_int32_be,
  add_int32_le,
  add_int64_ne,
  add_int64_be,
  add_int64_le,
}
/* No side effect */
