(* Generated by ocaml-tree-sitter. *)
(*
   ocaml grammar

   entrypoint: compilation_unit
*)

open! Sexplib.Conv
open Tree_sitter_run

type capitalized_identifier = Token.t (* pattern "[A-Z][a-zA-Z0-9_']*" *)
[@@deriving sexp_of]

type let_operator = Token.t
[@@deriving sexp_of]

type quoted_string = Token.t
[@@deriving sexp_of]

type boolean = [
    `True of Token.t (* "true" *)
  | `False of Token.t (* "false" *)
]
[@@deriving sexp_of]

type match_operator = Token.t
[@@deriving sexp_of]

type pat_21333c0 = Token.t (* pattern \\o[0-3][0-7][0-7] *)
[@@deriving sexp_of]

type and_operator_ = [
    `AMP of Token.t (* "&" *)
  | `AMPAMP of Token.t (* "&&" *)
]
[@@deriving sexp_of]

type ocamlyacc_value = Token.t (* pattern \$[0-9]+ *)
[@@deriving sexp_of]

type null = Token.t
[@@deriving sexp_of]

type anon_choice_EQ_4ccabd6 = [
    `EQ of Token.t (* "=" *)
  | `COLONEQ of Token.t (* ":=" *)
]
[@@deriving sexp_of]

type identifier = Token.t (* pattern "[a-z_][a-zA-Z0-9_']*" *)
[@@deriving sexp_of]

type number = Token.t
[@@deriving sexp_of]

type conversion_specification = Token.t
[@@deriving sexp_of]

type anon_choice_priv_c7cc539 = [
    `Priv of Token.t (* "private" *)
  | `Virt of Token.t (* "virtual" *)
]
[@@deriving sexp_of]

type rel_operator = Token.t
[@@deriving sexp_of]

type pat_3d340f6 = Token.t (* pattern \s+ *)
[@@deriving sexp_of]

type pat_d43393f = Token.t (* pattern "[^\\\\']" *)
[@@deriving sexp_of]

type anon_choice_TILDE_72781e5 = [
    `TILDE of Token.t (* "~" *)
  | `QMARK of Token.t (* "?" *)
]
[@@deriving sexp_of]

type pat_6cdf4be = Token.t (* pattern \\u\{[0-9A-Fa-f]+\} *)
[@@deriving sexp_of]

type pretty_printing_indication =
  Token.t (* pattern @([\[\], ;.{}?]|\\n|<[0-9]+>) *)
[@@deriving sexp_of]

type add_operator = Token.t
[@@deriving sexp_of]

type prefix_operator = Token.t
[@@deriving sexp_of]

type pat_9465c8b = Token.t (* pattern \\\n[\t ]* *)
[@@deriving sexp_of]

type indexing_operator = Token.t
[@@deriving sexp_of]

type pat_60fc52b = Token.t (* pattern "\\\\[\\\\\"'ntbr ]" *)
[@@deriving sexp_of]

type tok_STARSTAR_rep_pat_2ed1ddf = Token.t
[@@deriving sexp_of]

type and_operator = Token.t
[@@deriving sexp_of]

type pat_86b875b = Token.t (* pattern \\[0-9][0-9][0-9] *)
[@@deriving sexp_of]

type hash_operator = Token.t (* pattern #[#!$%&*+\-./:<=>?@^|~]+ *)
[@@deriving sexp_of]

type tok_pat_9ed5fa7_rep_pat_2ed1ddf = Token.t
[@@deriving sexp_of]

type pat_3bf11d1 = Token.t (* pattern \\x[0-9A-Fa-f][0-9A-Fa-f] *)
[@@deriving sexp_of]

type shebang = Token.t (* pattern #!.* *)
[@@deriving sexp_of]

type unit_ = [
    `LPAR_RPAR of (Token.t (* "(" *) * Token.t (* ")" *))
  | `Begin_end of (Token.t (* "begin" *) * Token.t (* "end" *))
]
[@@deriving sexp_of]

type tok_choice_pat_4349e4b = Token.t
[@@deriving sexp_of]

type concat_operator = Token.t
[@@deriving sexp_of]

type anon_choice_muta_d43fe41 = [
    `Muta of Token.t (* "mutable" *)
  | `Virt of Token.t (* "virtual" *)
]
[@@deriving sexp_of]

type assign_operator = [ `COLONEQ of Token.t (* ":=" *) ]
[@@deriving sexp_of]

type or_operator = [
    `Or of Token.t (* "or" *)
  | `BARBAR of Token.t (* "||" *)
]
[@@deriving sexp_of]

type pat_19aaf34 = Token.t (* pattern "[^\\\\\"%@]+|%|@" *)
[@@deriving sexp_of]

type anon_choice_PLUS_da42005 = [
    `PLUS of Token.t (* "+" *)
  | `DASH of Token.t (* "-" *)
]
[@@deriving sexp_of]

type sign_operator = [
    `PLUS of Token.t (* "+" *)
  | `DASH of Token.t (* "-" *)
  | `PLUSDOT of Token.t (* "+." *)
  | `DASHDOT of Token.t (* "-." *)
]
[@@deriving sexp_of]

type pow_operator = [
    `Tok_STARSTAR_rep_pat_2ed1ddf of tok_STARSTAR_rep_pat_2ed1ddf (*tok*)
  | `Lsl of Token.t (* "lsl" *)
  | `Lsr of Token.t (* "lsr" *)
  | `Asr of Token.t (* "asr" *)
]
[@@deriving sexp_of]

type mult_operator = [
    `Tok_pat_9ed5fa7_rep_pat_2ed1ddf of
      tok_pat_9ed5fa7_rep_pat_2ed1ddf (*tok*)
  | `Mod of Token.t (* "mod" *)
  | `Land of Token.t (* "land" *)
  | `Lor of Token.t (* "lor" *)
  | `Lxor of Token.t (* "lxor" *)
]
[@@deriving sexp_of]

type escape_sequence = [
    `Pat_60fc52b of pat_60fc52b (*tok*)
  | `Pat_86b875b of pat_86b875b (*tok*)
  | `Pat_3bf11d1 of pat_3bf11d1 (*tok*)
  | `Pat_21333c0 of pat_21333c0 (*tok*)
]
[@@deriving sexp_of]

type module_path = [
    `Capi_id of capitalized_identifier (*tok*)
  | `Module_path_DOT_capi_id of (
        module_path * Token.t (* "." *) * capitalized_identifier (*tok*)
    )
]
[@@deriving sexp_of]

type extended_module_path = [
    `Choice_capi_id of [
        `Capi_id of capitalized_identifier (*tok*)
      | `Exte_module_path_DOT_capi_id of (
            extended_module_path * Token.t (* "." *)
          * capitalized_identifier (*tok*)
        )
    ]
  | `Exte_module_path_LPAR_exte_module_path_RPAR of (
        extended_module_path * Token.t (* "(" *) * extended_module_path
      * Token.t (* ")" *)
    )
]
[@@deriving sexp_of]

type anon_choice_module_name_7ad5569 = [
    `Capi_id of capitalized_identifier (*tok*)
  | `X__ of Token.t (* "_" *)
]
[@@deriving sexp_of]

type constructor_name = [
    `Capi_id of capitalized_identifier (*tok*)
  | `LPAR_COLONCOLON_RPAR of (
        Token.t (* "(" *) * Token.t (* "::" *) * Token.t (* ")" *)
    )
]
[@@deriving sexp_of]

type module_type_name = [
    `Capi_id of capitalized_identifier (*tok*)
  | `Id of identifier (*tok*)
]
[@@deriving sexp_of]

type label = (anon_choice_TILDE_72781e5 * identifier (*tok*))
[@@deriving sexp_of]

type abstract_type = (
    Token.t (* "type" *)
  * identifier (*tok*) list (* one or more *)
)
[@@deriving sexp_of]

type anon_choice_meth_name_cbd841f = [
    `Id of identifier (*tok*)
  | `Capi_id of capitalized_identifier (*tok*)
]
[@@deriving sexp_of]

type infix_operator = [
    `Hash_op of hash_operator (*tok*)
  | `Pow_op of pow_operator
  | `Mult_op of mult_operator
  | `Add_op of add_operator (*tok*)
  | `Concat_op of concat_operator (*tok*)
  | `Rel_op of rel_operator (*tok*)
  | `And_op_ of and_operator_
  | `Or_op of or_operator
  | `Assign_op of assign_operator
]
[@@deriving sexp_of]

type string_ = (
    Token.t (* "\"" *)
  * [
        `Imm_tok_SPACE of Token.t (* " " *)
      | `Imm_tok_LBRACKAT of Token.t (* "[@" *)
      | `Imm_tok_LBRACKATAT of Token.t (* "[@@" *)
      | `Imm_tok_LBRACKATATAT of Token.t (* "[@@@" *)
      | `Pat_19aaf34 of pat_19aaf34 (*tok*)
      | `Null of null (*tok*)
      | `Esc_seq of escape_sequence
      | `Pat_6cdf4be of pat_6cdf4be (*tok*)
      | `Pat_9465c8b of pat_9465c8b (*tok*)
      | `Conv_spec of conversion_specification (*tok*)
      | `Pretty_prin_indi of pretty_printing_indication (*tok*)
    ]
      list (* zero or more *)
  * Token.t (* "\"" *)
)
[@@deriving sexp_of]

type indexing_operator_path = [
    `Inde_op of indexing_operator (*tok*)
  | `Module_path_DOT_inde_op of (
        module_path * Token.t (* "." *) * indexing_operator (*tok*)
    )
]
[@@deriving sexp_of]

type class_path = [
    `Id of identifier (*tok*)
  | `Module_path_DOT_id of (
        module_path * Token.t (* "." *) * identifier (*tok*)
    )
]
[@@deriving sexp_of]

type field_path = [
    `Id of identifier (*tok*)
  | `Module_path_DOT_id of (
        module_path * Token.t (* "." *) * identifier (*tok*)
    )
]
[@@deriving sexp_of]

type type_constructor_path = [
    `Id of identifier (*tok*)
  | `Exte_module_path_DOT_id of (
        extended_module_path * Token.t (* "." *) * identifier (*tok*)
    )
]
[@@deriving sexp_of]

type class_type_path = [
    `Id of identifier (*tok*)
  | `Exte_module_path_DOT_id of (
        extended_module_path * Token.t (* "." *) * identifier (*tok*)
    )
]
[@@deriving sexp_of]

type constructor_path = [
    `Choice_capi_id of constructor_name
  | `Module_path_DOT_choice_capi_id of (
        module_path * Token.t (* "." *) * constructor_name
    )
]
[@@deriving sexp_of]

type module_type_path = [
    `Choice_capi_id of module_type_name
  | `Exte_module_path_DOT_choice_capi_id of (
        extended_module_path * Token.t (* "." *) * module_type_name
    )
]
[@@deriving sexp_of]

type directive = (Token.t (* "#" *) * anon_choice_meth_name_cbd841f)
[@@deriving sexp_of]

type tag = (Token.t (* "`" *) * anon_choice_meth_name_cbd841f)
[@@deriving sexp_of]

type attribute_id = (
    anon_choice_meth_name_cbd841f
  * (Token.t (* "." *) * anon_choice_meth_name_cbd841f)
      list (* zero or more *)
)
[@@deriving sexp_of]

type type_variable = (Token.t (* "'" *) * anon_choice_meth_name_cbd841f)
[@@deriving sexp_of]

type parenthesized_operator = (
    Token.t (* "(" *)
  * [
        `Prefix_op of prefix_operator (*tok*)
      | `Sign_op of sign_operator
      | `Infix_op of infix_operator
      | `DOT_inde_op_choice_LPAR_opt_SEMI_DOTDOT_RPAR_opt_LTDASH of (
            Token.t (* "." *)
          * indexing_operator (*tok*)
          * [
                `LPAR_opt_SEMI_DOTDOT_RPAR of (
                    Token.t (* "(" *)
                  * (Token.t (* ";" *) * Token.t (* ".." *)) option
                  * Token.t (* ")" *)
                )
              | `LBRACK_opt_SEMI_DOTDOT_RBRACK of (
                    Token.t (* "[" *)
                  * (Token.t (* ";" *) * Token.t (* ".." *)) option
                  * Token.t (* "]" *)
                )
              | `LCURL_opt_SEMI_DOTDOT_RCURL of (
                    Token.t (* "{" *)
                  * (Token.t (* ";" *) * Token.t (* ".." *)) option
                  * Token.t (* "}" *)
                )
            ]
          * Token.t (* "<-" *) option
        )
      | `Let_op of let_operator (*tok*)
      | `And_op of and_operator (*tok*)
      | `Match_op of match_operator (*tok*)
    ]
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type constant = [
    `Num of number (*tok*)
  | `Char of (
        Token.t (* "'" *)
      * [
            `Pat_d43393f of pat_d43393f (*tok*)
          | `Null of null (*tok*)
          | `Esc_seq of escape_sequence
        ]
      * Token.t (* "'" *)
    )
  | `Str of string_
  | `Quoted_str_ of (
        Token.t (* "{" *) * quoted_string (*tok*) * Token.t (* "}" *)
    )
  | `Bool of boolean
  | `Unit of unit_
]
[@@deriving sexp_of]

type polymorphic_variant_pattern = (
    Token.t (* "#" *) * type_constructor_path
)
[@@deriving sexp_of]

type attribute = (Token.t (* "%" *) * attribute_id)
[@@deriving sexp_of]

type type_param = (
    [
        `PLUS_opt_BANG of (Token.t (* "+" *) * Token.t (* "!" *) option)
      | `DASH_opt_BANG of (Token.t (* "-" *) * Token.t (* "!" *) option)
      | `BANG_opt_choice_PLUS of (
            Token.t (* "!" *)
          * anon_choice_PLUS_da42005 option
        )
    ]
      option
  * [ `Type_var of type_variable | `X__ of Token.t (* "_" *) ]
)
[@@deriving sexp_of]

type value_pattern = [
    `Id of identifier (*tok*)
  | `Paren_op of parenthesized_operator
]
[@@deriving sexp_of]

type value_name = [
    `Id of identifier (*tok*)
  | `Paren_op of parenthesized_operator
]
[@@deriving sexp_of]

type signed_constant = [
    `Cst of constant
  | `Signed_num of (
        anon_choice_PLUS_da42005 * tok_choice_pat_4349e4b (*tok*)
    )
]
[@@deriving sexp_of]

type anon_LBRACK_type_param_rep_COMMA_type_param_RBRACK_cea5434 = (
    Token.t (* "[" *)
  * type_param
  * (Token.t (* "," *) * type_param) list (* zero or more *)
  * Token.t (* "]" *)
)
[@@deriving sexp_of]

type type_params = [
    `Type_param of type_param
  | `LPAR_type_param_rep_COMMA_type_param_RPAR of (
        Token.t (* "(" *)
      * type_param
      * (Token.t (* "," *) * type_param) list (* zero or more *)
      * Token.t (* ")" *)
    )
]
[@@deriving sexp_of]

type value_path = [
    `Value_name of value_name
  | `Module_path_DOT_value_name of (
        module_path * Token.t (* "." *) * value_name
    )
]
[@@deriving sexp_of]

type range_pattern = (signed_constant * Token.t (* ".." *) * signed_constant)
[@@deriving sexp_of]

type toplevel_directive = (
    directive
  * [
        `Cst of constant
      | `Value_path of value_path
      | `Module_path of module_path
    ]
      option
)
[@@deriving sexp_of]

type anon_bind_pat_ext_rep_SEMI_bind_pat_ext_opt_SEMI_38caf30 = (
    binding_pattern_ext
  * (Token.t (* ";" *) * binding_pattern_ext) list (* zero or more *)
  * Token.t (* ";" *) option
)

and anon_choice_cons_type_48a9640 = [
    `Cons_type of (
        Token.t (* "type" *)
      * type_params option
      * type_constructor_path
      * type_equation
      * type_constraint list (* zero or more *)
    )
  | `Cons_module of (
        Token.t (* "module" *) * module_path * anon_choice_EQ_4ccabd6
      * extended_module_path
    )
]

and anon_choice_meth_type_345b567 = [
    `Meth_type of (identifier (*tok*) * polymorphic_typed)
  | `Choice_simple_type of simple_type_ext
]

and anon_choice_simple_type_ext_30dd028 = [
    `Choice_simple_type of simple_type_ext
  | `LPAR_type_ext_rep_COMMA_type_ext_RPAR of (
        Token.t (* "(" *)
      * type_ext
      * (Token.t (* "," *) * type_ext) list (* zero or more *)
      * Token.t (* ")" *)
    )
]

and anon_cons_decl_rep_BAR_cons_decl_fc0ccc5 = (
    constructor_declaration
  * (Token.t (* "|" *) * constructor_declaration) list (* zero or more *)
)

and anon_exp_ext_rep_SEMI_exp_ext_opt_SEMI_f0de170 = (
    expression_ext
  * (Token.t (* ";" *) * expression_ext) list (* zero or more *)
  * Token.t (* ";" *) option
)

and anon_pat_ext_rep_SEMI_pat_ext_opt_SEMI_3830e8c = (
    pattern_ext
  * (Token.t (* ";" *) * pattern_ext) list (* zero or more *)
  * Token.t (* ";" *) option
)

and argument = [
    `Choice_simple_exp of simple_expression_ext
  | `Labe_arg of labeled_argument
]

and array_binding_pattern = (
    Token.t (* "[|" *)
  * anon_bind_pat_ext_rep_SEMI_bind_pat_ext_opt_SEMI_38caf30 option
  * Token.t (* "|]" *)
)

and array_expression = (
    Token.t (* "[|" *)
  * anon_exp_ext_rep_SEMI_exp_ext_opt_SEMI_f0de170 option
  * Token.t (* "|]" *)
)

and array_get_expression = (
    simple_expression_ext
  * Token.t (* "." *)
  * indexing_operator_path option
  * Token.t (* "(" *)
  * sequence_expression_ext
  * Token.t (* ")" *)
)

and array_pattern = (
    Token.t (* "[|" *)
  * anon_pat_ext_rep_SEMI_pat_ext_opt_SEMI_3830e8c option
  * Token.t (* "|]" *)
)

and attribute_payload = [
    `Stru of structure
  | `COLON_choice_type_ext of (
        Token.t (* ":" *)
      * [ `Type_ext of type_ext | `Sign of signature ]
    )
  | `QMARK_pat_ext_opt_guard of (
        Token.t (* "?" *)
      * pattern_ext
      * guard option
    )
]

and bigarray_get_expression = (
    simple_expression_ext
  * Token.t (* "." *)
  * indexing_operator_path option
  * Token.t (* "{" *)
  * sequence_expression_ext
  * Token.t (* "}" *)
)

and binding_pattern = [
    `Value_name of value_name
  | `Signed_cst of signed_constant
  | `Typed_bind_pat of (
        Token.t (* "(" *) * binding_pattern_ext * typed * Token.t (* ")" *)
    )
  | `Cons_path of constructor_path
  | `Tag of tag
  | `Poly_vari_pat of polymorphic_variant_pattern
  | `Record_bind_pat of record_binding_pattern
  | `List_bind_pat of list_binding_pattern
  | `Array_bind_pat of array_binding_pattern
  | `Local_open_bind_pat of (
        module_path
      * Token.t (* "." *)
      * [
            `LPAR_opt_bind_pat_ext_RPAR of (
                Token.t (* "(" *)
              * binding_pattern_ext option
              * Token.t (* ")" *)
            )
          | `List_bind_pat of list_binding_pattern
          | `Array_bind_pat of array_binding_pattern
          | `Record_bind_pat of record_binding_pattern
        ]
    )
  | `Pack_pat of package_pattern
  | `Paren_bind_pat of (
        Token.t (* "(" *) * binding_pattern_ext * Token.t (* ")" *)
    )
  | `Alias_bind_pat of (
        binding_pattern_ext * Token.t (* "as" *) * value_name
    )
  | `Or_bind_pat of (
        binding_pattern_ext * Token.t (* "|" *) * binding_pattern_ext
    )
  | `Cons_bind_pat_1ca6430 of (constructor_path * binding_pattern_ext)
  | `Tag_bind_pat of (tag * binding_pattern_ext)
  | `Tuple_bind_pat of (
        binding_pattern_ext * Token.t (* "," *) * binding_pattern_ext
    )
  | `Cons_bind_pat_f2d0ae9 of (
        binding_pattern_ext * Token.t (* "::" *) * binding_pattern_ext
    )
  | `Range_pat of range_pattern
  | `Lazy_bind_pat of (
        Token.t (* "lazy" *)
      * attribute option
      * binding_pattern_ext
    )
]

and binding_pattern_ext = [
    `Bind_pat of binding_pattern
  | `Exte of extension
]

and class_binding = (
    Token.t (* "virtual" *) option
  * anon_LBRACK_type_param_rep_COMMA_type_param_RBRACK_cea5434 option
  * identifier (*tok*)
  * parameter list (* zero or more *)
  * class_typed option
  * (Token.t (* "=" *) * class_expression_ext) option
  * item_attribute list (* zero or more *)
)

and class_definition = (
    Token.t (* "class" *)
  * attribute option
  * class_binding
  * (Token.t (* "and" *) * class_binding) list (* zero or more *)
)

and class_expression = [
    `Simple_class_exp of simple_class_expression
  | `Class_func of (
        Token.t (* "fun" *)
      * parameter list (* one or more *)
      * Token.t (* "->" *)
      * class_expression_ext
    )
  | `Class_app of (simple_class_expression * argument list (* one or more *))
  | `Let_class_exp of (
        value_definition * Token.t (* "in" *) * class_expression_ext
    )
  | `Let_open_class_exp of (
        Token.t (* "let" *) * open_module * Token.t (* "in" *)
      * class_expression_ext
    )
]

and class_expression_ext = [
    `Class_exp of class_expression
  | `Exte of extension
]

and class_field = [
    `Inhe_defi of (
        Token.t (* "inherit" *)
      * Token.t (* "!" *) option
      * class_expression_ext
      * (Token.t (* "as" *) * value_pattern) option
      * item_attribute list (* zero or more *)
    )
  | `Inst_var_defi of (
        Token.t (* "val" *)
      * Token.t (* "!" *) option
      * anon_choice_muta_d43fe41 list (* zero or more *)
      * identifier (*tok*)
      * typed option
      * (Token.t (* ":>" *) * type_ext) option
      * (Token.t (* "=" *) * sequence_expression_ext) option
      * item_attribute list (* zero or more *)
    )
  | `Meth_defi of (
        Token.t (* "method" *)
      * Token.t (* "!" *) option
      * anon_choice_priv_c7cc539 list (* zero or more *)
      * identifier (*tok*)
      * parameter list (* zero or more *)
      * polymorphic_typed option
      * (Token.t (* "=" *) * sequence_expression_ext) option
      * item_attribute list (* zero or more *)
    )
  | `Type_param_cons of type_parameter_constraint
  | `Class_init of (
        Token.t (* "initializer" *)
      * sequence_expression_ext
      * item_attribute list (* zero or more *)
    )
]

and class_field_ext = [
    `Class_field of class_field
  | `Item_exte of item_extension
]

and class_field_specification = [
    `Inhe_spec of (
        Token.t (* "inherit" *)
      * simple_class_type_ext
      * item_attribute list (* zero or more *)
    )
  | `Inst_var_spec of (
        Token.t (* "val" *)
      * anon_choice_muta_d43fe41 list (* zero or more *)
      * identifier (*tok*)
      * typed
      * item_attribute list (* zero or more *)
    )
  | `Meth_spec of (
        Token.t (* "method" *)
      * anon_choice_priv_c7cc539 list (* zero or more *)
      * identifier (*tok*)
      * polymorphic_typed
      * item_attribute list (* zero or more *)
    )
  | `Type_param_cons of type_parameter_constraint
]

and class_field_specification_ext = [
    `Class_field_spec of class_field_specification
  | `Item_exte of item_extension
]

and class_type = [
    `Simple_class_type of simple_class_type
  | `Class_func_type of (
        (Token.t (* "?" *) option * identifier (*tok*) * Token.t (* ":" *))
          option
      * tuple_type_ext
      * Token.t (* "->" *)
      * class_type_ext
    )
]

and class_type_binding = (
    Token.t (* "virtual" *) option
  * anon_LBRACK_type_param_rep_COMMA_type_param_RBRACK_cea5434 option
  * identifier (*tok*)
  * Token.t (* "=" *)
  * simple_class_type_ext
  * item_attribute list (* zero or more *)
)

and class_type_definition = (
    Token.t (* "class" *)
  * Token.t (* "type" *)
  * attribute option
  * class_type_binding
  * (Token.t (* "and" *) * class_type_binding) list (* zero or more *)
)

and class_type_ext = [ `Class_type of class_type | `Exte of extension ]

and class_typed = (Token.t (* ":" *) * class_type_ext)

and constructor_argument = [
    `Choice_simple_type_rep_STAR_choice_simple_type of (
        simple_type_ext
      * (Token.t (* "*" *) * simple_type_ext) list (* zero or more *)
    )
  | `Record_decl of record_declaration
]

and constructor_declaration = (
    [
        `Choice_capi_id of constructor_name
      | `Choice_LBRACK_RBRACK of [
            `LBRACK_RBRACK of (Token.t (* "[" *) * Token.t (* "]" *))
          | `LPAR_RPAR of (Token.t (* "(" *) * Token.t (* ")" *))
          | `True of Token.t (* "true" *)
          | `False of Token.t (* "false" *)
        ]
    ]
  * [
        `Of_cons_arg of (Token.t (* "of" *) * constructor_argument)
      | `Simple_typed of simple_typed
      | `COLON_cons_arg_DASHGT_choice_simple_type of (
            Token.t (* ":" *) * constructor_argument * Token.t (* "->" *)
          * simple_type_ext
        )
      | `EQ_cons_path of (Token.t (* "=" *) * constructor_path)
    ]
      option
)

and do_clause = (
    Token.t (* "do" *)
  * sequence_expression_ext option
  * Token.t (* "done" *)
)

and else_clause = (Token.t (* "else" *) * expression_ext)

and exception_definition = (
    Token.t (* "exception" *)
  * attribute option
  * constructor_declaration
  * item_attribute list (* zero or more *)
)

and expression = [
    `Simple_exp of simple_expression
  | `Prod_exp of (expression_ext * Token.t (* "," *) * expression_ext)
  | `Cons_exp of (expression_ext * Token.t (* "::" *) * expression_ext)
  | `App_exp of (simple_expression_ext * argument list (* one or more *))
  | `Infix_exp of infix_expression
  | `Sign_exp of (sign_operator * expression_ext)
  | `Set_exp of (
        [
            `Field_get_exp of field_get_expression
          | `Array_get_exp of array_get_expression
          | `Str_get_exp of string_get_expression
          | `Biga_get_exp of bigarray_get_expression
          | `Id of identifier (*tok*)
        ]
      * Token.t (* "<-" *)
      * expression_ext
    )
  | `If_exp of (
        Token.t (* "if" *)
      * attribute option
      * sequence_expression_ext
      * then_clause
      * else_clause option
    )
  | `While_exp of (
        Token.t (* "while" *)
      * attribute option
      * sequence_expression_ext
      * do_clause
    )
  | `For_exp of (
        Token.t (* "for" *)
      * attribute option
      * value_pattern
      * Token.t (* "=" *)
      * sequence_expression_ext
      * [ `To of Token.t (* "to" *) | `Downto of Token.t (* "downto" *) ]
      * sequence_expression_ext
      * do_clause
    )
  | `Match_exp of (
        [
            `Match_opt_attr of (Token.t (* "match" *) * attribute option)
          | `Match_op of match_operator (*tok*)
        ]
      * sequence_expression_ext
      * Token.t (* "with" *)
      * match_cases
    )
  | `Func_exp of (Token.t (* "function" *) * attribute option * match_cases)
  | `Fun_exp of (
        Token.t (* "fun" *)
      * attribute option
      * parameter list (* one or more *)
      * simple_typed option
      * Token.t (* "->" *)
      * sequence_expression_ext
    )
  | `Try_exp of (
        Token.t (* "try" *)
      * attribute option
      * sequence_expression_ext
      * Token.t (* "with" *)
      * match_cases
    )
  | `Let_exp of (
        value_definition * Token.t (* "in" *) * sequence_expression_ext
    )
  | `Assert_exp of (
        Token.t (* "assert" *)
      * attribute option
      * simple_expression_ext
    )
  | `Lazy_exp of (
        Token.t (* "lazy" *)
      * attribute option
      * simple_expression_ext
    )
  | `Let_module_exp of (
        Token.t (* "let" *) * module_definition * Token.t (* "in" *)
      * sequence_expression_ext
    )
  | `Let_open_exp of (
        Token.t (* "let" *) * open_module * Token.t (* "in" *)
      * sequence_expression_ext
    )
  | `Let_exc_exp of (
        Token.t (* "let" *) * exception_definition * Token.t (* "in" *)
      * sequence_expression_ext
    )
  | `Obj_exp of object_expression
]

and expression_ext = [ `Exp of expression | `Exte of extension ]

and expression_item = (
    sequence_expression_ext
  * item_attribute list (* zero or more *)
)

and extension = [
    `Exte_ of (
        Token.t (* "[%" *)
      * attribute_id
      * attribute_payload option
      * Token.t (* "]" *)
    )
  | `Quoted_exte of (
        Token.t (* "{%" *)
      * attribute_id
      * pat_3d340f6 (*tok*) option
      * quoted_string (*tok*)
      * Token.t (* "}" *)
    )
]

and external_ = (
    Token.t (* "external" *)
  * attribute option
  * value_name
  * typed
  * Token.t (* "=" *)
  * string_ list (* one or more *)
  * item_attribute list (* zero or more *)
)

and field_binding_pattern = (
    field_path
  * typed option
  * (Token.t (* "=" *) * binding_pattern_ext) option
)

and field_declaration = (
    Token.t (* "mutable" *) option
  * identifier (*tok*)
  * polymorphic_typed
)

and field_expression = (
    field_path
  * typed option
  * (Token.t (* "=" *) * expression_ext) option
)

and field_get_expression = (
    simple_expression_ext * Token.t (* "." *) * field_path
)

and field_pattern = (
    field_path
  * typed option
  * (Token.t (* "=" *) * pattern_ext) option
)

and floating_attribute = (
    Token.t (* "[@@@" *)
  * attribute_id
  * attribute_payload option
  * Token.t (* "]" *)
)

and guard = (Token.t (* "when" *) * sequence_expression_ext)

and infix_expression = [
    `Choice_exp_pow_op_choice_exp of (
        expression_ext * pow_operator * expression_ext
    )
  | `Choice_exp_mult_op_choice_exp of (
        expression_ext * mult_operator * expression_ext
    )
  | `Choice_exp_add_op_choice_exp of (
        expression_ext * add_operator (*tok*) * expression_ext
    )
  | `Choice_exp_concat_op_choice_exp of (
        expression_ext * concat_operator (*tok*) * expression_ext
    )
  | `Choice_exp_rel_op_choice_exp of (
        expression_ext * rel_operator (*tok*) * expression_ext
    )
  | `Choice_exp_and_op__choice_exp of (
        expression_ext * and_operator_ * expression_ext
    )
  | `Choice_exp_or_op_choice_exp of (
        expression_ext * or_operator * expression_ext
    )
  | `Choice_exp_assign_op_choice_exp of (
        expression_ext * assign_operator * expression_ext
    )
]

and instance_variable_expression = (
    identifier (*tok*)
  * (Token.t (* "=" *) * expression_ext) option
)

and item_attribute = (
    Token.t (* "[@@" *)
  * attribute_id
  * attribute_payload option
  * Token.t (* "]" *)
)

and item_extension = [
    `Item_exte_ of (
        Token.t (* "[%%" *)
      * attribute_id
      * attribute_payload option
      * Token.t (* "]" *)
      * item_attribute list (* zero or more *)
    )
  | `Quoted_item_exte of (
        Token.t (* "{%%" *)
      * attribute_id
      * pat_3d340f6 (*tok*) option
      * quoted_string (*tok*)
      * Token.t (* "}" *)
      * item_attribute list (* zero or more *)
    )
]

and labeled_argument = [
    `Label of label
  | `Label_imm_tok_COLON_choice_simple_exp of (
        label * Token.t (* ":" *) * simple_expression_ext
    )
]

and let_binding = (
    binding_pattern_ext
  * parameter list (* zero or more *)
  * polymorphic_typed option
  * (Token.t (* ":>" *) * type_ext) option
  * Token.t (* "=" *)
  * sequence_expression_ext
  * item_attribute list (* zero or more *)
)

and list_binding_pattern = (
    Token.t (* "[" *)
  * anon_bind_pat_ext_rep_SEMI_bind_pat_ext_opt_SEMI_38caf30 option
  * Token.t (* "]" *)
)

and list_expression = (
    Token.t (* "[" *)
  * anon_exp_ext_rep_SEMI_exp_ext_opt_SEMI_f0de170 option
  * Token.t (* "]" *)
)

and list_pattern = (
    Token.t (* "[" *)
  * anon_pat_ext_rep_SEMI_pat_ext_opt_SEMI_3830e8c option
  * Token.t (* "]" *)
)

and match_case = (
    pattern_ext
  * guard option
  * Token.t (* "->" *)
  * [
        `Seq_exp_ext of sequence_expression_ext
      | `Refu_case of Token.t (* "." *)
    ]
)

and match_cases = (
    Token.t (* "|" *) option
  * match_case
  * (Token.t (* "|" *) * match_case) list (* zero or more *)
)

and module_binding = (
    anon_choice_module_name_7ad5569
  * module_parameter list (* zero or more *)
  * module_typed option
  * (Token.t (* "=" *) * module_expression_ext) option
  * item_attribute list (* zero or more *)
)

and module_definition = (
    Token.t (* "module" *)
  * attribute option
  * Token.t (* "rec" *) option
  * module_binding
  * (Token.t (* "and" *) * module_binding) list (* zero or more *)
)

and module_expression = [
    `Simple_module_exp of simple_module_expression
  | `Module_path of module_path
  | `Stru_ of (
        Token.t (* "struct" *)
      * structure option
      * Token.t (* "end" *)
    )
  | `Func of (
        Token.t (* "functor" *)
      * module_parameter list (* one or more *)
      * Token.t (* "->" *)
      * module_expression_ext
    )
  | `Module_app of (
        module_expression_ext
      * [
            `Simple_module_exp_ext of simple_module_expression_ext
          | `LPAR_RPAR of (Token.t (* "(" *) * Token.t (* ")" *))
        ]
    )
]

and module_expression_ext = [
    `Module_exp of module_expression
  | `Exte of extension
]

and module_parameter = (
    Token.t (* "(" *)
  * (anon_choice_module_name_7ad5569 * module_typed) option
  * Token.t (* ")" *)
)

and module_type = [
    `Module_type_path of module_type_path
  | `Sign_ of (Token.t (* "sig" *) * signature option * Token.t (* "end" *))
  | `Module_type_cons of (
        module_type_ext
      * Token.t (* "with" *)
      * anon_choice_cons_type_48a9640
      * (Token.t (* "and" *) * anon_choice_cons_type_48a9640)
          list (* zero or more *)
    )
  | `Module_type_of of (
        Token.t (* "module" *) * Token.t (* "type" *) * Token.t (* "of" *)
      * module_expression_ext
    )
  | `Func_type of (
        [
            `Func_rep_module_param of (
                Token.t (* "functor" *)
              * module_parameter list (* zero or more *)
            )
          | `Choice_module_type of module_type_ext
        ]
      * Token.t (* "->" *)
      * module_type_ext
    )
  | `Paren_module_type of (
        Token.t (* "(" *) * module_type_ext * Token.t (* ")" *)
    )
]

and module_type_definition = (
    Token.t (* "module" *)
  * Token.t (* "type" *)
  * attribute option
  * module_type_name
  * (Token.t (* "=" *) * module_type_ext) option
  * item_attribute list (* zero or more *)
)

and module_type_ext = [ `Module_type of module_type | `Exte of extension ]

and module_typed = (Token.t (* ":" *) * module_type_ext)

and object_copy_expression = (
    Token.t (* "{<" *)
  * (
        instance_variable_expression
      * (Token.t (* ";" *) * instance_variable_expression)
          list (* zero or more *)
    )
      option
  * Token.t (* ";" *) option
  * Token.t (* ">}" *)
)

and object_expression = (
    Token.t (* "object" *)
  * attribute option
  * (Token.t (* "(" *) * pattern_ext * typed option * Token.t (* ")" *))
      option
  * [
        `Class_field_ext of class_field_ext
      | `Floa_attr of floating_attribute
    ]
      list (* zero or more *)
  * Token.t (* "end" *)
)

and open_module = (
    Token.t (* "open" *)
  * Token.t (* "!" *) option
  * attribute option
  * module_expression_ext
  * item_attribute list (* zero or more *)
)

and package_expression = (
    Token.t (* "(" *)
  * Token.t (* "module" *)
  * attribute option
  * module_expression_ext
  * module_typed option
  * Token.t (* ")" *)
)

and package_pattern = (
    Token.t (* "(" *)
  * Token.t (* "module" *)
  * attribute option
  * anon_choice_module_name_7ad5569
  * module_typed option
  * Token.t (* ")" *)
)

and parameter = [
    `Param_ of parameter_
  | `Paren_abst_type of (
        Token.t (* "(" *) * abstract_type * Token.t (* ")" *)
    )
]

and parameter_ = [
    `Simple_pat_ext of simple_pattern_ext
  | `Choice_TILDE_id of label
  | `Label_imm_tok_COLON_simple_pat_ext of (
        label * Token.t (* ":" *) * simple_pattern_ext
    )
  | `Choice_TILDE_LPAR_id_opt_typed_opt_EQ_seq_exp_ext_RPAR of (
        anon_choice_TILDE_72781e5
      * Token.t (* "(" *)
      * identifier (*tok*)
      * typed option
      * (Token.t (* "=" *) * sequence_expression_ext) option
      * Token.t (* ")" *)
    )
  | `Label_imm_tok_COLON_LPAR_pat_ext_opt_typed_EQ_seq_exp_ext_RPAR of (
        label
      * Token.t (* ":" *)
      * Token.t (* "(" *)
      * pattern_ext
      * typed option
      * Token.t (* "=" *)
      * sequence_expression_ext
      * Token.t (* ")" *)
    )
]

and parenthesized_expression = [
    `Begin_opt_attr_seq_exp_ext_end of (
        Token.t (* "begin" *)
      * attribute option
      * sequence_expression_ext
      * Token.t (* "end" *)
    )
  | `LPAR_seq_exp_ext_RPAR of (
        Token.t (* "(" *) * sequence_expression_ext * Token.t (* ")" *)
    )
]

and parenthesized_type = (Token.t (* "(" *) * type_ext * Token.t (* ")" *))

and pattern = [
    `Simple_pat of simple_pattern
  | `Alias_pat of (pattern_ext * Token.t (* "as" *) * value_pattern)
  | `Or_pat of (pattern_ext * Token.t (* "|" *) * pattern_ext)
  | `Cons_pat_4ec55c1 of (constructor_path * pattern_ext)
  | `Tag_pat of (tag * pattern_ext)
  | `Tuple_pat of (pattern_ext * Token.t (* "," *) * pattern_ext)
  | `Cons_pat_9b4e481 of (pattern_ext * Token.t (* "::" *) * pattern_ext)
  | `Range_pat of range_pattern
  | `Lazy_pat of (Token.t (* "lazy" *) * attribute option * pattern_ext)
  | `Exc_pat of (Token.t (* "exception" *) * attribute option * pattern_ext)
]

and pattern_ext = [ `Pat of pattern | `Exte of extension ]

and polymorphic_type = [
    `Poly_type_ of (
        [
            `Rep1_type_var of type_variable list (* one or more *)
          | `Abst_type of abstract_type
        ]
      * Token.t (* "." *)
      * type_ext
    )
  | `Type_ext of type_ext
]

and polymorphic_typed = (Token.t (* ":" *) * polymorphic_type)

and record_binding_pattern = (
    Token.t (* "{" *)
  * field_binding_pattern
  * (Token.t (* ";" *) * field_binding_pattern) list (* zero or more *)
  * (Token.t (* ";" *) * Token.t (* "_" *)) option
  * Token.t (* ";" *) option
  * Token.t (* "}" *)
)

and record_declaration = (
    Token.t (* "{" *)
  * field_declaration
  * (Token.t (* ";" *) * field_declaration) list (* zero or more *)
  * Token.t (* ";" *) option
  * Token.t (* "}" *)
)

and record_expression = (
    Token.t (* "{" *)
  * (simple_expression_ext * Token.t (* "with" *)) option
  * field_expression
  * (Token.t (* ";" *) * field_expression) list (* zero or more *)
  * Token.t (* ";" *) option
  * Token.t (* "}" *)
)

and record_pattern = (
    Token.t (* "{" *)
  * field_pattern
  * (Token.t (* ";" *) * field_pattern) list (* zero or more *)
  * (Token.t (* ";" *) * Token.t (* "_" *)) option
  * Token.t (* ";" *) option
  * Token.t (* "}" *)
)

and sequence_expression_ = [
    `Exp of expression
  | `Seq_exp of (
        expression_ext
      * Token.t (* ";" *)
      * (attribute option * sequence_expression_ext) option
    )
]

and sequence_expression_ext = [
    `Seq_exp_ of sequence_expression_
  | `Exte of extension
]

and signature = [
    `Rep1_SEMISEMI of Token.t (* ";;" *) list (* one or more *)
  | `Rep1_rep_SEMISEMI_sign_item_ext_rep_SEMISEMI of (
        (Token.t (* ";;" *) list (* zero or more *) * signature_item_ext)
          list (* one or more *)
      * Token.t (* ";;" *) list (* zero or more *)
    )
]

and signature_item = [
    `Value_spec of (
        Token.t (* "val" *)
      * attribute option
      * value_name
      * typed
      * item_attribute list (* zero or more *)
    )
  | `Exte of external_
  | `Type_defi of type_definition
  | `Exc_defi of exception_definition
  | `Module_defi of module_definition
  | `Module_type_defi of module_type_definition
  | `Open_module of open_module
  | `Incl_module_type of (
        Token.t (* "include" *)
      * attribute option
      * module_type_ext
      * item_attribute list (* zero or more *)
    )
  | `Class_defi of class_definition
  | `Class_type_defi of class_type_definition
  | `Floa_attr of floating_attribute
]

and signature_item_ext = [
    `Sign_item of signature_item
  | `Item_exte of item_extension
]

and simple_class_expression = [
    `Class_path of class_path
  | `Inst_class of (
        Token.t (* "[" *)
      * type_ext
      * (Token.t (* "," *) * type_ext) list (* zero or more *)
      * Token.t (* "]" *)
      * class_path
    )
  | `Obj_exp of object_expression
  | `Typed_class_exp of (
        Token.t (* "(" *) * class_expression_ext * class_typed
      * Token.t (* ")" *)
    )
  | `Paren_class_exp of (
        Token.t (* "(" *) * class_expression_ext * Token.t (* ")" *)
    )
]

and simple_class_type = [
    `Class_type_path of class_type_path
  | `Inst_class_type of (
        Token.t (* "[" *)
      * type_ext
      * (Token.t (* "," *) * type_ext) list (* zero or more *)
      * Token.t (* "]" *)
      * class_type_path
    )
  | `Class_body_type of (
        Token.t (* "object" *)
      * parenthesized_type option
      * [
            `Class_field_spec_ext of class_field_specification_ext
          | `Floa_attr of floating_attribute
        ]
          list (* zero or more *)
      * Token.t (* "end" *)
    )
  | `Let_open_class_type of (
        Token.t (* "let" *) * open_module * Token.t (* "in" *)
      * simple_class_type_ext
    )
]

and simple_class_type_ext = [
    `Simple_class_type of simple_class_type
  | `Exte of extension
]

and simple_expression = [
    `Value_path of value_path
  | `Cst of constant
  | `Typed_exp of (
        Token.t (* "(" *) * sequence_expression_ext * typed
      * Token.t (* ")" *)
    )
  | `Cons_path of constructor_path
  | `Tag of tag
  | `List_exp of list_expression
  | `Array_exp of array_expression
  | `Record_exp of record_expression
  | `Prefix_exp of (prefix_operator (*tok*) * simple_expression_ext)
  | `Hash_exp of (
        simple_expression_ext * hash_operator (*tok*) * simple_expression_ext
    )
  | `Field_get_exp of field_get_expression
  | `Array_get_exp of array_get_expression
  | `Str_get_exp of string_get_expression
  | `Biga_get_exp of bigarray_get_expression
  | `Coer_exp of (
        Token.t (* "(" *)
      * sequence_expression_ext
      * typed option
      * Token.t (* ":>" *)
      * type_ext
      * Token.t (* ")" *)
    )
  | `Local_open_exp of (
        module_path
      * Token.t (* "." *)
      * [
            `LPAR_opt_seq_exp_ext_RPAR of (
                Token.t (* "(" *)
              * sequence_expression_ext option
              * Token.t (* ")" *)
            )
          | `List_exp of list_expression
          | `Array_exp of array_expression
          | `Record_exp of record_expression
          | `Obj_copy_exp of object_copy_expression
          | `Pack_exp of package_expression
        ]
    )
  | `Pack_exp of package_expression
  | `New_exp of (Token.t (* "new" *) * attribute option * class_path)
  | `Obj_copy_exp of object_copy_expression
  | `Meth_invo of (
        simple_expression_ext * Token.t (* "#" *) * identifier (*tok*)
    )
  | `Paren_exp of parenthesized_expression
  | `Ocam_value of ocamlyacc_value (*tok*)
]

and simple_expression_ext = [
    `Simple_exp of simple_expression
  | `Exte of extension
]

and simple_module_expression = [
    `Typed_module_exp of (
        Token.t (* "(" *) * module_expression_ext * module_typed
      * Token.t (* ")" *)
    )
  | `Paren_module_exp of (
        Token.t (* "(" *) * module_expression_ext * Token.t (* ")" *)
    )
  | `Packed_module of (
        Token.t (* "(" *)
      * Token.t (* "val" *)
      * expression_ext
      * module_typed option
      * (Token.t (* ":>" *) * module_type_ext) option
      * Token.t (* ")" *)
    )
]

and simple_module_expression_ext = [
    `Simple_module_exp of simple_module_expression
  | `Exte of extension
]

and simple_pattern = [
    `Value_pat of value_pattern
  | `Signed_cst of signed_constant
  | `Typed_pat of (
        Token.t (* "(" *) * pattern_ext * typed * Token.t (* ")" *)
    )
  | `Cons_path of constructor_path
  | `Tag of tag
  | `Poly_vari_pat of polymorphic_variant_pattern
  | `Record_pat of record_pattern
  | `List_pat of list_pattern
  | `Array_pat of array_pattern
  | `Local_open_pat of (
        module_path
      * Token.t (* "." *)
      * [
            `LPAR_opt_pat_ext_RPAR of (
                Token.t (* "(" *)
              * pattern_ext option
              * Token.t (* ")" *)
            )
          | `List_pat of list_pattern
          | `Array_pat of array_pattern
          | `Record_pat of record_pattern
        ]
    )
  | `Pack_pat of package_pattern
  | `Paren_pat of (Token.t (* "(" *) * pattern_ext * Token.t (* ")" *))
]

and simple_pattern_ext = [
    `Simple_pat of simple_pattern
  | `Exte of extension
]

and simple_type = [
    `Type_var of type_variable
  | `Type_cons_path of type_constructor_path
  | `Cons_type of (
        anon_choice_simple_type_ext_30dd028 * type_constructor_path
    )
  | `Poly_vari_type of [
        `LBRACK_tag_spec_RBRACK of (
            Token.t (* "[" *) * tag_specification * Token.t (* "]" *)
        )
      | `LBRACK_opt_tag_spec_BAR_tag_spec_rep_BAR_tag_spec_RBRACK of (
            Token.t (* "[" *)
          * tag_spec option
          * Token.t (* "|" *)
          * tag_spec
          * (Token.t (* "|" *) * tag_spec) list (* zero or more *)
          * Token.t (* "]" *)
        )
      | `LBRACKGT_opt_BAR_opt_tag_spec_rep_BAR_tag_spec_RBRACK of (
            Token.t (* "[>" *)
          * Token.t (* "|" *) option
          * (
                tag_spec
              * (Token.t (* "|" *) * tag_spec) list (* zero or more *)
            )
              option
          * Token.t (* "]" *)
        )
      | `LBRACKLT_opt_BAR_tag_spec_rep_BAR_tag_spec_opt_GT_rep1_tag_RBRACK of (
            Token.t (* "[<" *)
          * Token.t (* "|" *) option
          * tag_spec
          * (Token.t (* "|" *) * tag_spec) list (* zero or more *)
          * (Token.t (* ">" *) * tag list (* one or more *)) option
          * Token.t (* "]" *)
        )
    ]
  | `Pack_type of (
        Token.t (* "(" *)
      * Token.t (* "module" *)
      * attribute option
      * module_type_ext
      * Token.t (* ")" *)
    )
  | `Hash_type of (
        anon_choice_simple_type_ext_30dd028 option
      * Token.t (* "#" *)
      * class_type_path
    )
  | `Obj_type of (
        Token.t (* "<" *)
      * [
            `Choice_meth_type_rep_SEMI_choice_meth_type_opt_SEMI_opt_DOTDOT of (
                anon_choice_meth_type_345b567
              * (Token.t (* ";" *) * anon_choice_meth_type_345b567)
                  list (* zero or more *)
              * (Token.t (* ";" *) * Token.t (* ".." *) option) option
            )
          | `DOTDOT of Token.t (* ".." *)
        ]
          option
      * Token.t (* ">" *)
    )
  | `Paren_type of parenthesized_type
]

and simple_type_ext = [ `Simple_type of simple_type | `Exte of extension ]

and simple_typed = (Token.t (* ":" *) * simple_type_ext)

and string_get_expression = (
    simple_expression_ext
  * Token.t (* "." *)
  * indexing_operator_path option
  * Token.t (* "[" *)
  * sequence_expression_ext
  * Token.t (* "]" *)
)

and structure = [
    `Rep1_SEMISEMI of Token.t (* ";;" *) list (* one or more *)
  | `Rep_SEMISEMI_choice_stru_item_ext_rep_choice_rep_SEMISEMI_choice_stru_item_ext_rep_SEMISEMI of (
        Token.t (* ";;" *) list (* zero or more *)
      * [
            `Stru_item_ext of structure_item_ext
          | `Topl_dire of toplevel_directive
          | `Exp_item of expression_item
        ]
      * [
            `Rep_SEMISEMI_choice_stru_item_ext of (
                Token.t (* ";;" *) list (* zero or more *)
              * [
                    `Stru_item_ext of structure_item_ext
                  | `Topl_dire of toplevel_directive
                ]
            )
          | `Rep1_SEMISEMI_exp_item of (
                Token.t (* ";;" *) list (* one or more *)
              * expression_item
            )
        ]
          list (* zero or more *)
      * Token.t (* ";;" *) list (* zero or more *)
    )
]

and structure_item = [
    `Value_defi of value_definition
  | `Exte of external_
  | `Type_defi of type_definition
  | `Exc_defi of exception_definition
  | `Module_defi of module_definition
  | `Module_type_defi of module_type_definition
  | `Open_module of open_module
  | `Incl_module of (
        Token.t (* "include" *)
      * attribute option
      * module_expression_ext
      * item_attribute list (* zero or more *)
    )
  | `Class_defi of class_definition
  | `Class_type_defi of class_type_definition
  | `Floa_attr of floating_attribute
]

and structure_item_ext = [
    `Stru_item of structure_item
  | `Item_exte of item_extension
]

and tag_spec = [ `Type_ext of type_ext | `Tag_spec of tag_specification ]

and tag_specification = (
    tag
  * (
        Token.t (* "of" *)
      * Token.t (* "&" *) option
      * type_ext
      * (Token.t (* "&" *) * type_ext) list (* zero or more *)
    )
      option
)

and then_clause = (Token.t (* "then" *) * expression_ext)

and tuple_type_ = [
    `Simple_type of simple_type
  | `Tuple_type of (tuple_type_ext * Token.t (* "*" *) * simple_type_ext)
]

and tuple_type_ext = [ `Tuple_type_ of tuple_type_ | `Exte of extension ]

and type_ = [
    `Tuple_type_ of tuple_type_
  | `Func_type of (
        [ `Typed_label of typed_label | `Type_ext of type_ext ]
      * Token.t (* "->" *)
      * type_ext
    )
  | `Alia_type of (type_ext * Token.t (* "as" *) * type_variable)
]

and type_binding = (
    type_params option
  * [
        `Id_opt_type_equa_opt_EQ_opt_priv_choice_vari_decl_rep_type_cons of (
            identifier (*tok*)
          * type_equation option
          * (
                Token.t (* "=" *)
              * Token.t (* "private" *) option
              * [
                    `Vari_decl of variant_declaration
                  | `Record_decl of record_declaration
                  | `DOTDOT of Token.t (* ".." *)
                ]
            )
              option
          * type_constraint list (* zero or more *)
        )
      | `Type_cons_path_PLUSEQ_opt_priv_vari_decl of (
            type_constructor_path
          * Token.t (* "+=" *)
          * Token.t (* "private" *) option
          * variant_declaration
        )
    ]
  * item_attribute list (* zero or more *)
)

and type_constraint = (
    Token.t (* "constraint" *) * type_ext * Token.t (* "=" *) * type_ext
)

and type_definition = (
    Token.t (* "type" *)
  * attribute option
  * Token.t (* "nonrec" *) option
  * type_binding
  * (Token.t (* "and" *) * type_binding) list (* zero or more *)
)

and type_equation = (
    anon_choice_EQ_4ccabd6
  * Token.t (* "private" *) option
  * type_ext
)

and type_ext = [ `Type of type_ | `Exte of extension ]

and type_parameter_constraint = (
    Token.t (* "constraint" *)
  * type_ext
  * Token.t (* "=" *)
  * type_ext
  * item_attribute list (* zero or more *)
)

and typed = (Token.t (* ":" *) * type_ext)

and typed_label = (
    Token.t (* "?" *) option
  * identifier (*tok*)
  * Token.t (* ":" *)
  * type_ext
)

and value_definition = (
    [
        `Let_opt_attr_opt_rec of (
            Token.t (* "let" *)
          * attribute option
          * Token.t (* "rec" *) option
        )
      | `Let_op of let_operator (*tok*)
    ]
  * let_binding
  * (
        [ `And of Token.t (* "and" *) | `And_op of and_operator (*tok*) ]
      * let_binding
    )
      list (* zero or more *)
)

and variant_declaration = [
    `BAR_opt_cons_decl_rep_BAR_cons_decl of (
        Token.t (* "|" *)
      * anon_cons_decl_rep_BAR_cons_decl_fc0ccc5 option
    )
  | `Cons_decl_rep_BAR_cons_decl of anon_cons_decl_rep_BAR_cons_decl_fc0ccc5
]
[@@deriving sexp_of]

type compilation_unit = (shebang (*tok*) option * structure option)
[@@deriving sexp_of]

type imm_tok_LBRACKAT (* inlined *) = Token.t (* "[@" *)
[@@deriving sexp_of]

type comment (* inlined *) = Token.t
[@@deriving sexp_of]

type imm_tok_LBRACKATAT (* inlined *) = Token.t (* "[@@" *)
[@@deriving sexp_of]

type imm_tok_LBRACKATATAT (* inlined *) = Token.t (* "[@@@" *)
[@@deriving sexp_of]

type imm_tok_COLON (* inlined *) = Token.t (* ":" *)
[@@deriving sexp_of]

type refutation_case (* inlined *) = Token.t (* "." *)
[@@deriving sexp_of]

type line_number_directive (* inlined *) = Token.t
[@@deriving sexp_of]

type imm_tok_SPACE (* inlined *) = Token.t (* " " *)
[@@deriving sexp_of]

type module_name (* inlined *) = capitalized_identifier (*tok*)
[@@deriving sexp_of]

type quoted_string_ (* inlined *) = (
    Token.t (* "{" *) * quoted_string (*tok*) * Token.t (* "}" *)
)
[@@deriving sexp_of]

type label_name (* inlined *) = identifier (*tok*)
[@@deriving sexp_of]

type class_type_name (* inlined *) = identifier (*tok*)
[@@deriving sexp_of]

type method_name (* inlined *) = identifier (*tok*)
[@@deriving sexp_of]

type instance_variable_name (* inlined *) = identifier (*tok*)
[@@deriving sexp_of]

type type_constructor (* inlined *) = identifier (*tok*)
[@@deriving sexp_of]

type field_name (* inlined *) = identifier (*tok*)
[@@deriving sexp_of]

type class_name (* inlined *) = identifier (*tok*)
[@@deriving sexp_of]

type signed_number (* inlined *) = (
    anon_choice_PLUS_da42005 * tok_choice_pat_4349e4b (*tok*)
)
[@@deriving sexp_of]

type character (* inlined *) = (
    Token.t (* "'" *)
  * [
        `Pat_d43393f of pat_d43393f (*tok*)
      | `Null of null (*tok*)
      | `Esc_seq of escape_sequence
    ]
  * Token.t (* "'" *)
)
[@@deriving sexp_of]

type constrain_module (* inlined *) = (
    Token.t (* "module" *) * module_path * anon_choice_EQ_4ccabd6
  * extended_module_path
)
[@@deriving sexp_of]

type parenthesized_abstract_type (* inlined *) = (
    Token.t (* "(" *) * abstract_type * Token.t (* ")" *)
)
[@@deriving sexp_of]

type quoted_extension (* inlined *) = (
    Token.t (* "{%" *)
  * attribute_id
  * pat_3d340f6 (*tok*) option
  * quoted_string (*tok*)
  * Token.t (* "}" *)
)
[@@deriving sexp_of]

type new_expression (* inlined *) = (
    Token.t (* "new" *)
  * attribute option
  * class_path
)
[@@deriving sexp_of]

type alias_binding_pattern (* inlined *) = (
    binding_pattern_ext * Token.t (* "as" *) * value_name
)
[@@deriving sexp_of]

type alias_pattern (* inlined *) = (
    pattern_ext * Token.t (* "as" *) * value_pattern
)
[@@deriving sexp_of]

type aliased_type (* inlined *) = (
    type_ext * Token.t (* "as" *) * type_variable
)
[@@deriving sexp_of]

type anon_LPAR_type_ext_rep_COMMA_type_ext_RPAR_eb2f7ab (* inlined *) = (
    Token.t (* "(" *)
  * type_ext
  * (Token.t (* "," *) * type_ext) list (* zero or more *)
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type application_expression (* inlined *) = (
    simple_expression_ext
  * argument list (* one or more *)
)
[@@deriving sexp_of]

type assert_expression (* inlined *) = (
    Token.t (* "assert" *)
  * attribute option
  * simple_expression_ext
)
[@@deriving sexp_of]

type class_application (* inlined *) = (
    simple_class_expression
  * argument list (* one or more *)
)
[@@deriving sexp_of]

type class_body_type (* inlined *) = (
    Token.t (* "object" *)
  * parenthesized_type option
  * [
        `Class_field_spec_ext of class_field_specification_ext
      | `Floa_attr of floating_attribute
    ]
      list (* zero or more *)
  * Token.t (* "end" *)
)
[@@deriving sexp_of]

type class_function (* inlined *) = (
    Token.t (* "fun" *)
  * parameter list (* one or more *)
  * Token.t (* "->" *)
  * class_expression_ext
)
[@@deriving sexp_of]

type class_function_type (* inlined *) = (
    (Token.t (* "?" *) option * identifier (*tok*) * Token.t (* ":" *))
      option
  * tuple_type_ext
  * Token.t (* "->" *)
  * class_type_ext
)
[@@deriving sexp_of]

type class_initializer (* inlined *) = (
    Token.t (* "initializer" *)
  * sequence_expression_ext
  * item_attribute list (* zero or more *)
)
[@@deriving sexp_of]

type coercion_expression (* inlined *) = (
    Token.t (* "(" *)
  * sequence_expression_ext
  * typed option
  * Token.t (* ":>" *)
  * type_ext
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type cons_binding_pattern (* inlined *) = (
    binding_pattern_ext * Token.t (* "::" *) * binding_pattern_ext
)
[@@deriving sexp_of]

type cons_expression (* inlined *) = (
    expression_ext * Token.t (* "::" *) * expression_ext
)
[@@deriving sexp_of]

type cons_pattern (* inlined *) = (
    pattern_ext * Token.t (* "::" *) * pattern_ext
)
[@@deriving sexp_of]

type constrain_type (* inlined *) = (
    Token.t (* "type" *)
  * type_params option
  * type_constructor_path
  * type_equation
  * type_constraint list (* zero or more *)
)
[@@deriving sexp_of]

type constructed_type (* inlined *) = (
    anon_choice_simple_type_ext_30dd028 * type_constructor_path
)
[@@deriving sexp_of]

type constructor_binding_pattern (* inlined *) = (
    constructor_path * binding_pattern_ext
)
[@@deriving sexp_of]

type constructor_pattern (* inlined *) = (constructor_path * pattern_ext)
[@@deriving sexp_of]

type exception_pattern (* inlined *) = (
    Token.t (* "exception" *)
  * attribute option
  * pattern_ext
)
[@@deriving sexp_of]

type extension_ (* inlined *) = (
    Token.t (* "[%" *)
  * attribute_id
  * attribute_payload option
  * Token.t (* "]" *)
)
[@@deriving sexp_of]

type for_expression (* inlined *) = (
    Token.t (* "for" *)
  * attribute option
  * value_pattern
  * Token.t (* "=" *)
  * sequence_expression_ext
  * [ `To of Token.t (* "to" *) | `Downto of Token.t (* "downto" *) ]
  * sequence_expression_ext
  * do_clause
)
[@@deriving sexp_of]

type fun_expression (* inlined *) = (
    Token.t (* "fun" *)
  * attribute option
  * parameter list (* one or more *)
  * simple_typed option
  * Token.t (* "->" *)
  * sequence_expression_ext
)
[@@deriving sexp_of]

type function_expression (* inlined *) = (
    Token.t (* "function" *)
  * attribute option
  * match_cases
)
[@@deriving sexp_of]

type function_type (* inlined *) = (
    [ `Typed_label of typed_label | `Type_ext of type_ext ]
  * Token.t (* "->" *)
  * type_ext
)
[@@deriving sexp_of]

type functor_ (* inlined *) = (
    Token.t (* "functor" *)
  * module_parameter list (* one or more *)
  * Token.t (* "->" *)
  * module_expression_ext
)
[@@deriving sexp_of]

type functor_type (* inlined *) = (
    [
        `Func_rep_module_param of (
            Token.t (* "functor" *)
          * module_parameter list (* zero or more *)
        )
      | `Choice_module_type of module_type_ext
    ]
  * Token.t (* "->" *)
  * module_type_ext
)
[@@deriving sexp_of]

type hash_expression (* inlined *) = (
    simple_expression_ext * hash_operator (*tok*) * simple_expression_ext
)
[@@deriving sexp_of]

type hash_type (* inlined *) = (
    anon_choice_simple_type_ext_30dd028 option
  * Token.t (* "#" *)
  * class_type_path
)
[@@deriving sexp_of]

type if_expression (* inlined *) = (
    Token.t (* "if" *)
  * attribute option
  * sequence_expression_ext
  * then_clause
  * else_clause option
)
[@@deriving sexp_of]

type include_module (* inlined *) = (
    Token.t (* "include" *)
  * attribute option
  * module_expression_ext
  * item_attribute list (* zero or more *)
)
[@@deriving sexp_of]

type include_module_type (* inlined *) = (
    Token.t (* "include" *)
  * attribute option
  * module_type_ext
  * item_attribute list (* zero or more *)
)
[@@deriving sexp_of]

type inheritance_definition (* inlined *) = (
    Token.t (* "inherit" *)
  * Token.t (* "!" *) option
  * class_expression_ext
  * (Token.t (* "as" *) * value_pattern) option
  * item_attribute list (* zero or more *)
)
[@@deriving sexp_of]

type inheritance_specification (* inlined *) = (
    Token.t (* "inherit" *)
  * simple_class_type_ext
  * item_attribute list (* zero or more *)
)
[@@deriving sexp_of]

type instance_variable_definition (* inlined *) = (
    Token.t (* "val" *)
  * Token.t (* "!" *) option
  * anon_choice_muta_d43fe41 list (* zero or more *)
  * identifier (*tok*)
  * typed option
  * (Token.t (* ":>" *) * type_ext) option
  * (Token.t (* "=" *) * sequence_expression_ext) option
  * item_attribute list (* zero or more *)
)
[@@deriving sexp_of]

type instance_variable_specification (* inlined *) = (
    Token.t (* "val" *)
  * anon_choice_muta_d43fe41 list (* zero or more *)
  * identifier (*tok*)
  * typed
  * item_attribute list (* zero or more *)
)
[@@deriving sexp_of]

type instantiated_class (* inlined *) = (
    Token.t (* "[" *)
  * type_ext
  * (Token.t (* "," *) * type_ext) list (* zero or more *)
  * Token.t (* "]" *)
  * class_path
)
[@@deriving sexp_of]

type instantiated_class_type (* inlined *) = (
    Token.t (* "[" *)
  * type_ext
  * (Token.t (* "," *) * type_ext) list (* zero or more *)
  * Token.t (* "]" *)
  * class_type_path
)
[@@deriving sexp_of]

type item_extension_ (* inlined *) = (
    Token.t (* "[%%" *)
  * attribute_id
  * attribute_payload option
  * Token.t (* "]" *)
  * item_attribute list (* zero or more *)
)
[@@deriving sexp_of]

type lazy_binding_pattern (* inlined *) = (
    Token.t (* "lazy" *)
  * attribute option
  * binding_pattern_ext
)
[@@deriving sexp_of]

type lazy_expression (* inlined *) = (
    Token.t (* "lazy" *)
  * attribute option
  * simple_expression_ext
)
[@@deriving sexp_of]

type lazy_pattern (* inlined *) = (
    Token.t (* "lazy" *)
  * attribute option
  * pattern_ext
)
[@@deriving sexp_of]

type let_class_expression (* inlined *) = (
    value_definition * Token.t (* "in" *) * class_expression_ext
)
[@@deriving sexp_of]

type let_exception_expression (* inlined *) = (
    Token.t (* "let" *) * exception_definition * Token.t (* "in" *)
  * sequence_expression_ext
)
[@@deriving sexp_of]

type let_expression (* inlined *) = (
    value_definition * Token.t (* "in" *) * sequence_expression_ext
)
[@@deriving sexp_of]

type let_module_expression (* inlined *) = (
    Token.t (* "let" *) * module_definition * Token.t (* "in" *)
  * sequence_expression_ext
)
[@@deriving sexp_of]

type let_open_class_expression (* inlined *) = (
    Token.t (* "let" *) * open_module * Token.t (* "in" *)
  * class_expression_ext
)
[@@deriving sexp_of]

type let_open_class_type (* inlined *) = (
    Token.t (* "let" *) * open_module * Token.t (* "in" *)
  * simple_class_type_ext
)
[@@deriving sexp_of]

type let_open_expression (* inlined *) = (
    Token.t (* "let" *) * open_module * Token.t (* "in" *)
  * sequence_expression_ext
)
[@@deriving sexp_of]

type local_open_binding_pattern (* inlined *) = (
    module_path
  * Token.t (* "." *)
  * [
        `LPAR_opt_bind_pat_ext_RPAR of (
            Token.t (* "(" *)
          * binding_pattern_ext option
          * Token.t (* ")" *)
        )
      | `List_bind_pat of list_binding_pattern
      | `Array_bind_pat of array_binding_pattern
      | `Record_bind_pat of record_binding_pattern
    ]
)
[@@deriving sexp_of]

type local_open_expression (* inlined *) = (
    module_path
  * Token.t (* "." *)
  * [
        `LPAR_opt_seq_exp_ext_RPAR of (
            Token.t (* "(" *)
          * sequence_expression_ext option
          * Token.t (* ")" *)
        )
      | `List_exp of list_expression
      | `Array_exp of array_expression
      | `Record_exp of record_expression
      | `Obj_copy_exp of object_copy_expression
      | `Pack_exp of package_expression
    ]
)
[@@deriving sexp_of]

type local_open_pattern (* inlined *) = (
    module_path
  * Token.t (* "." *)
  * [
        `LPAR_opt_pat_ext_RPAR of (
            Token.t (* "(" *)
          * pattern_ext option
          * Token.t (* ")" *)
        )
      | `List_pat of list_pattern
      | `Array_pat of array_pattern
      | `Record_pat of record_pattern
    ]
)
[@@deriving sexp_of]

type match_expression (* inlined *) = (
    [
        `Match_opt_attr of (Token.t (* "match" *) * attribute option)
      | `Match_op of match_operator (*tok*)
    ]
  * sequence_expression_ext
  * Token.t (* "with" *)
  * match_cases
)
[@@deriving sexp_of]

type method_definition (* inlined *) = (
    Token.t (* "method" *)
  * Token.t (* "!" *) option
  * anon_choice_priv_c7cc539 list (* zero or more *)
  * identifier (*tok*)
  * parameter list (* zero or more *)
  * polymorphic_typed option
  * (Token.t (* "=" *) * sequence_expression_ext) option
  * item_attribute list (* zero or more *)
)
[@@deriving sexp_of]

type method_invocation (* inlined *) = (
    simple_expression_ext * Token.t (* "#" *) * identifier (*tok*)
)
[@@deriving sexp_of]

type method_specification (* inlined *) = (
    Token.t (* "method" *)
  * anon_choice_priv_c7cc539 list (* zero or more *)
  * identifier (*tok*)
  * polymorphic_typed
  * item_attribute list (* zero or more *)
)
[@@deriving sexp_of]

type method_type (* inlined *) = (identifier (*tok*) * polymorphic_typed)
[@@deriving sexp_of]

type module_application (* inlined *) = (
    module_expression_ext
  * [
        `Simple_module_exp_ext of simple_module_expression_ext
      | `LPAR_RPAR of (Token.t (* "(" *) * Token.t (* ")" *))
    ]
)
[@@deriving sexp_of]

type module_type_constraint (* inlined *) = (
    module_type_ext
  * Token.t (* "with" *)
  * anon_choice_cons_type_48a9640
  * (Token.t (* "and" *) * anon_choice_cons_type_48a9640)
      list (* zero or more *)
)
[@@deriving sexp_of]

type module_type_of (* inlined *) = (
    Token.t (* "module" *) * Token.t (* "type" *) * Token.t (* "of" *)
  * module_expression_ext
)
[@@deriving sexp_of]

type object_type (* inlined *) = (
    Token.t (* "<" *)
  * [
        `Choice_meth_type_rep_SEMI_choice_meth_type_opt_SEMI_opt_DOTDOT of (
            anon_choice_meth_type_345b567
          * (Token.t (* ";" *) * anon_choice_meth_type_345b567)
              list (* zero or more *)
          * (Token.t (* ";" *) * Token.t (* ".." *) option) option
        )
      | `DOTDOT of Token.t (* ".." *)
    ]
      option
  * Token.t (* ">" *)
)
[@@deriving sexp_of]

type or_binding_pattern (* inlined *) = (
    binding_pattern_ext * Token.t (* "|" *) * binding_pattern_ext
)
[@@deriving sexp_of]

type or_pattern (* inlined *) = (
    pattern_ext * Token.t (* "|" *) * pattern_ext
)
[@@deriving sexp_of]

type package_type (* inlined *) = (
    Token.t (* "(" *)
  * Token.t (* "module" *)
  * attribute option
  * module_type_ext
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type packed_module (* inlined *) = (
    Token.t (* "(" *)
  * Token.t (* "val" *)
  * expression_ext
  * module_typed option
  * (Token.t (* ":>" *) * module_type_ext) option
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type parenthesized_binding_pattern (* inlined *) = (
    Token.t (* "(" *) * binding_pattern_ext * Token.t (* ")" *)
)
[@@deriving sexp_of]

type parenthesized_class_expression (* inlined *) = (
    Token.t (* "(" *) * class_expression_ext * Token.t (* ")" *)
)
[@@deriving sexp_of]

type parenthesized_module_expression (* inlined *) = (
    Token.t (* "(" *) * module_expression_ext * Token.t (* ")" *)
)
[@@deriving sexp_of]

type parenthesized_module_type (* inlined *) = (
    Token.t (* "(" *) * module_type_ext * Token.t (* ")" *)
)
[@@deriving sexp_of]

type parenthesized_pattern (* inlined *) = (
    Token.t (* "(" *) * pattern_ext * Token.t (* ")" *)
)
[@@deriving sexp_of]

type polymorphic_type_ (* inlined *) = (
    [
        `Rep1_type_var of type_variable list (* one or more *)
      | `Abst_type of abstract_type
    ]
  * Token.t (* "." *)
  * type_ext
)
[@@deriving sexp_of]

type polymorphic_variant_type (* inlined *) = [
    `LBRACK_tag_spec_RBRACK of (
        Token.t (* "[" *) * tag_specification * Token.t (* "]" *)
    )
  | `LBRACK_opt_tag_spec_BAR_tag_spec_rep_BAR_tag_spec_RBRACK of (
        Token.t (* "[" *)
      * tag_spec option
      * Token.t (* "|" *)
      * tag_spec
      * (Token.t (* "|" *) * tag_spec) list (* zero or more *)
      * Token.t (* "]" *)
    )
  | `LBRACKGT_opt_BAR_opt_tag_spec_rep_BAR_tag_spec_RBRACK of (
        Token.t (* "[>" *)
      * Token.t (* "|" *) option
      * (tag_spec * (Token.t (* "|" *) * tag_spec) list (* zero or more *))
          option
      * Token.t (* "]" *)
    )
  | `LBRACKLT_opt_BAR_tag_spec_rep_BAR_tag_spec_opt_GT_rep1_tag_RBRACK of (
        Token.t (* "[<" *)
      * Token.t (* "|" *) option
      * tag_spec
      * (Token.t (* "|" *) * tag_spec) list (* zero or more *)
      * (Token.t (* ">" *) * tag list (* one or more *)) option
      * Token.t (* "]" *)
    )
]
[@@deriving sexp_of]

type prefix_expression (* inlined *) = (
    prefix_operator (*tok*) * simple_expression_ext
)
[@@deriving sexp_of]

type product_expression (* inlined *) = (
    expression_ext * Token.t (* "," *) * expression_ext
)
[@@deriving sexp_of]

type quoted_item_extension (* inlined *) = (
    Token.t (* "{%%" *)
  * attribute_id
  * pat_3d340f6 (*tok*) option
  * quoted_string (*tok*)
  * Token.t (* "}" *)
  * item_attribute list (* zero or more *)
)
[@@deriving sexp_of]

type sequence_expression (* inlined *) = (
    expression_ext
  * Token.t (* ";" *)
  * (attribute option * sequence_expression_ext) option
)
[@@deriving sexp_of]

type set_expression (* inlined *) = (
    [
        `Field_get_exp of field_get_expression
      | `Array_get_exp of array_get_expression
      | `Str_get_exp of string_get_expression
      | `Biga_get_exp of bigarray_get_expression
      | `Id of identifier (*tok*)
    ]
  * Token.t (* "<-" *)
  * expression_ext
)
[@@deriving sexp_of]

type sign_expression (* inlined *) = (sign_operator * expression_ext)
[@@deriving sexp_of]

type signature_ (* inlined *) = (
    Token.t (* "sig" *)
  * signature option
  * Token.t (* "end" *)
)
[@@deriving sexp_of]

type structure_ (* inlined *) = (
    Token.t (* "struct" *)
  * structure option
  * Token.t (* "end" *)
)
[@@deriving sexp_of]

type tag_binding_pattern (* inlined *) = (tag * binding_pattern_ext)
[@@deriving sexp_of]

type tag_pattern (* inlined *) = (tag * pattern_ext)
[@@deriving sexp_of]

type try_expression (* inlined *) = (
    Token.t (* "try" *)
  * attribute option
  * sequence_expression_ext
  * Token.t (* "with" *)
  * match_cases
)
[@@deriving sexp_of]

type tuple_binding_pattern (* inlined *) = (
    binding_pattern_ext * Token.t (* "," *) * binding_pattern_ext
)
[@@deriving sexp_of]

type tuple_pattern (* inlined *) = (
    pattern_ext * Token.t (* "," *) * pattern_ext
)
[@@deriving sexp_of]

type tuple_type (* inlined *) = (
    tuple_type_ext * Token.t (* "*" *) * simple_type_ext
)
[@@deriving sexp_of]

type typed_binding_pattern (* inlined *) = (
    Token.t (* "(" *) * binding_pattern_ext * typed * Token.t (* ")" *)
)
[@@deriving sexp_of]

type typed_class_expression (* inlined *) = (
    Token.t (* "(" *) * class_expression_ext * class_typed
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type typed_expression (* inlined *) = (
    Token.t (* "(" *) * sequence_expression_ext * typed * Token.t (* ")" *)
)
[@@deriving sexp_of]

type typed_module_expression (* inlined *) = (
    Token.t (* "(" *) * module_expression_ext * module_typed
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type typed_pattern (* inlined *) = (
    Token.t (* "(" *) * pattern_ext * typed * Token.t (* ")" *)
)
[@@deriving sexp_of]

type value_specification (* inlined *) = (
    Token.t (* "val" *)
  * attribute option
  * value_name
  * typed
  * item_attribute list (* zero or more *)
)
[@@deriving sexp_of]

type while_expression (* inlined *) = (
    Token.t (* "while" *)
  * attribute option
  * sequence_expression_ext
  * do_clause
)
[@@deriving sexp_of]

type attribute_ (* inlined *) = (
    Token.t (* "[@" *)
  * attribute_id
  * attribute_payload option
  * Token.t (* "]" *)
)
[@@deriving sexp_of]

let dump_tree root =
  sexp_of_compilation_unit root
  |> Print_sexp.to_stdout
