Test uncurried externals and `[@mel.*]` attributes

  $ . ./setup.sh

`[@mel.unwrap]`

  $ cat > x.ml <<EOF
  > external smfn : (([ \`Str of string | \`Int of int ][@mel.unwrap]) -> unit[@u]) = "smfn"
  > let () = (smfn (\`Str "/path") [@u])
  > EOF
  $ melc -ppx melppx x.ml
  // Generated by Melange
  'use strict';
  
  
  smfn("/path");
  /*  Not a pure module */

Pathological case of non-literal type (not visible to `melange.ppx`)

  $ cat > x.ml <<EOF
  > type u = (int -> int[@u])
  > external v : u = "v"
  > let f x = (v x [@u])
  > EOF
  $ melc -ppx melppx x.ml
  // Generated by Melange
  'use strict';
  
  
  function f(x) {
    return v(x);
  }
  
  module.exports = {
    f,
  }
  /* No side effect */

  $ cat > x.ml <<EOF
  > external smfn : (int -> int[@u]) = "smfn"
  > let x = (smfn 3 [@u])
  > EOF
  $ melc -ppx melppx x.ml
  // Generated by Melange
  'use strict';
  
  
  const x = smfn(3);
  
  module.exports = {
    x,
  }
  /* x Not a pure module */

`[@mel.return ...]` and friends

  $ cat > x.ml <<EOF
  > external smfn : (int -> int option[@u])  = "smfn" [@@mel.return nullable]
  > let x = (smfn 3 [@u])
  > EOF
  $ melc -ppx melppx x.ml
  // Generated by Melange
  'use strict';
  
  const Caml_option = require("melange.js/caml_option.js");
  
  const x = Caml_option.nullable_to_opt(smfn(3));
  
  module.exports = {
    x,
  }
  /* x Not a pure module */

  $ cat > x.ml <<EOF
  > external smfn : (int -> int option[@u])  = "smfn" [@@mel.return undefined_to_opt]
  > let x = (smfn 3 [@u])
  > EOF
  $ melc -ppx melppx x.ml
  // Generated by Melange
  'use strict';
  
  const Caml_option = require("melange.js/caml_option.js");
  
  const x = Caml_option.undefined_to_opt(smfn(3));
  
  module.exports = {
    x,
  }
  /* x Not a pure module */

`[@mel.send]`

  $ cat > x.ml <<EOF
  > external len : (int array -> int [@u])  = "length"
  >  [@@mel.send]
  > let x = (len [|3|] [@u])
  > EOF
  $ melc -ppx melppx x.ml
  // Generated by Melange
  'use strict';
  
  
  const x = [3].length();
  
  module.exports = {
    x,
  }
  /* x Not a pure module */

`[@mel.get]`

  $ cat > x.ml <<EOF
  > external length : (int array -> int[@u]) = "length" [@@mel.get]
  > let x = (length [| 3 |] [@u])
  > EOF
  $ melc -ppx melppx x.ml
  // Generated by Melange
  'use strict';
  
  
  const x = [3].length;
  
  module.exports = {
    x,
  }
  /* x Not a pure module */

`[@mel.unwrap]` + non-unit return

  $ cat > x.ml <<EOF
  > external smfn :
  >   (unit -> ([ \`Str of string | \`Int of int ][@mel.unwrap]) -> int[@u]) = "smfn"
  > let _ : int = smfn () (\`Str "/path") [@u]
  > EOF
  $ melc -ppx melppx x.ml
  // Generated by Melange
  'use strict';
  
  
  smfn("/path");
  /*  Not a pure module */
