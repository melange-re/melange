Tests for deriving `jsProperties, getSet`

  $ . ./setup.sh

`[@@deriving jsProperties, getSet]` respects `[@mel.unwrap]`

  $ cat > x.ml <<EOF
  > type t = {
  >   mutable action : [ \`String of string | \`Int of int ] option;
  >       [@mel.unwrap] [@mel.optional]
  >   other : [ \`String of int | \`Int of string ] option; [@mel.optional]
  > }
  > [@@deriving jsProperties, getSet]
  > let () =
  >   let t = t ~action:(\`String "hello") () in
  >   (* Set action and expect the value to be unwrapped in the object too *)
  >   actionSet t (\`String "hello2");
  >   Js.log2 "Action after setting: " t;
  >   (* Expect the value to be what we declared in the type, but it isn't *)
  >   let action: [ \`String of string | \`Int of int ] option = actionGet t in
  >   (* This is, therefore, unsound *)
  >   match action with
  >   | None -> ()
  >   | Some (\`String s) ->
  >     Js.log2 "action in t is string:" s;
  >   | Some (\`Int i) ->
  >     Js.log2 "action in t is int:" i;
  > EOF
  $ melc -ppx melppx -dsource x.ml | tee x.js
  type t =
    {
    mutable action: [ `String of string  | `Int of int ] option
      [@mel.unwrap ][@mel.optional ];
    other: [ `String of int  | `Int of string ] option [@mel.optional ]}
  [@@deriving (jsProperties, getSet)]
  include
    struct
      let _ = fun (_ : t) -> ()
      external t :
        ?action:(([ `String of string  | `Int of int ])[@mel.unwrap ]) ->
          ?other:[ `String of int  | `Int of string ] -> unit -> t = ""
          "\132\149\166\190\000\000\000\029\000\000\000\011\000\000\000 \000\000\000\030\145\160\160C\161&action@\160\160A\161%other@\160\160@@@"
      [@@ocaml.warning "-unboxable-type-in-prim-decl"][@@ocaml.warning
                                                        "-unboxable-type-in-prim-decl"]
      external actionSet :
        t -> (([ `String of string  | `Int of int ])[@mel.unwrap ]) -> unit =
          "action"
          "\132\149\166\190\000\000\000\021\000\000\000\b\000\000\000\024\000\000\000\023\176\144\160\160AA\160\160CA@E\167&action@"
      [@@ocaml.warning "-unboxable-type-in-prim-decl"][@@ocaml.warning
                                                        "-unboxable-type-in-prim-decl"]
      external actionGet :
        t -> [ `String of string  | `Int of int ] option = "action"
          "\132\149\166\190\000\000\000\r\000\000\000\004\000\000\000\012\000\000\000\011\176\145AB\168&action@"
      [@@ocaml.warning "-unboxable-type-in-prim-decl"]
      external otherGet :
        t -> [ `String of int  | `Int of string ] option = "other"
          "\132\149\166\190\000\000\000\012\000\000\000\004\000\000\000\012\000\000\000\011\176\145AB\168%other@"
      [@@ocaml.warning "-unboxable-type-in-prim-decl"]
    end[@@ocaml.doc "@inline"][@@merlin.hide ]
  let () =
    let t = ((t ~action:(`String "hello") ())
      [@ocaml.warning "-ignored-extra-argument"]) in
    ((actionSet t (`String "hello2"))
    [@ocaml.warning "-ignored-extra-argument"]);
    ((Js.log2 "Action after setting: " t)
    [@ocaml.warning "-ignored-extra-argument"]);
    (let action : [ `String of string  | `Int of int ] option = ((actionGet t)
       [@ocaml.warning "-ignored-extra-argument"]) in
     match action with
     | None -> ()
     | Some (`String s) -> ((Js.log2 "action in t is string:" s)
         [@ocaml.warning "-ignored-extra-argument"])
     | Some (`Int i) -> ((Js.log2 "action in t is int:" i)
         [@ocaml.warning "-ignored-extra-argument"]))
  // Generated by Melange
  'use strict';
  
  
  const t = {
    action: "hello"
  };
  
  t.action = "hello2";
  
  console.log("Action after setting: ", t);
  
  const action = t.action;
  
  if (action !== undefined) {
    if (action.NAME === "Int") {
      console.log("action in t is int:", action.VAL);
    } else {
      console.log("action in t is string:", action.VAL);
    }
  }
  
  /*  Not a pure module */

  $ node x.js
  Action after setting:  { action: 'hello2' }
  action in t is string: undefined
