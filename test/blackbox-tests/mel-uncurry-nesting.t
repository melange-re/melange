Test the attribute @mel.uncurry at different level of nesting

  $ . ./setup.sh

Normal uncurry at first level works fine

  $ cat > x.ml <<EOF
  > external foo : ((unit -> unit)[@mel.uncurry]) -> unit
  >   = "foo"
  > EOF

  $ melc -ppx melppx x.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Using `mel.uncurry` at 2nd level of callbacks raises some alerts

  $ cat > x.ml <<EOF
  > external foo :
  >   (((unit -> unit)[@mel.uncurry]) -> (unit -> unit[@mel.uncurry])) -> unit
  >   = "foo"
  > EOF
  $ melc -ppx melppx x.ml
  File "x.ml", line 2, characters 20-31:
  2 |   (((unit -> unit)[@mel.uncurry]) -> (unit -> unit[@mel.uncurry])) -> unit
                          ^^^^^^^^^^^
  Alert unused: Unused attribute [@mel.uncurry]
  This means such annotation is not annotated properly.
  For example, some annotations are only meaningful in externals
  
  
  File "x.ml", line 2, characters 52-63:
  2 |   (((unit -> unit)[@mel.uncurry]) -> (unit -> unit[@mel.uncurry])) -> unit
                                                          ^^^^^^^^^^^
  Alert unused: Unused attribute [@mel.uncurry]
  This means such annotation is not annotated properly.
  For example, some annotations are only meaningful in externals
  
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */


In the case of uncurry nesting, we have to resort to the `[@u]` attribute

  $ cat > x.ml <<EOF
  > external foo : (((unit -> unit)[@u]) -> unit) -> unit = "foo"
  > let () = foo (fun f -> f () [@u])
  > EOF
  $ melc -ppx melppx x.ml
  // Generated by Melange
  'use strict';
  
  
  foo(function (f) {
    f();
  });
  /*  Not a pure module */

