Test `@mel.module` with relative module paths

  $ . ./setup.sh

`@mel.module` on external module generates no code

  $ cat > x.ml <<EOF
  > type nano
  > external nano : int -> nano = "nano" [@@mel.module "nano"]
  > EOF
  $ melc -ppx melppx x.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

`@mel.module` on relative module path generates code, to preserve the relative
path invariant.

  $ cat > x.ml <<EOF
  > type nano
  > external nano : int -> nano = "nano" [@@mel.module "./nano"]
  > EOF
  $ melc -ppx melppx x.ml
  // Generated by Melange
  'use strict';
  
  const Nano = require("./nano");
  
  function nano(prim) {
    return Nano.nano(prim);
  }
  
  exports.nano = nano;
  /* ./nano Not a pure module */

