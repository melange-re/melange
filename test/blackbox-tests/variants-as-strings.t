

  $ . ./setup.sh
  $ cat > dune-project <<EOF
  > (lang dune 3.9)
  > (using melange 0.1)
  > EOF

  $ cat > dune <<EOF
  > (melange.emit
  >  (target js-out)
  >  (preprocess (pps melange.ppx))
  >  (emit_stdlib false))
  > EOF

  $ cat > x.ml <<EOF
  > type a = A | B [@mel.as "as-string"] | C
  > let f x = match x with A -> "a" | _ -> "other"
  > let g x = match x with B -> "as-string" | _ -> "other"
  > EOF

  $ dune build @melange
  $ cat ./_build/default/js-out/x.js
  // Generated by Melange
  'use strict';
  
  
  function f(x) {
    switch (x) {
      case /* A */0 :
          return "a";
      case /* B */"as-string" :
      case /* C */2 :
          return "other";
      
    }
  }
  
  function g(x) {
    switch (x) {
      case /* B */"as-string" :
          return "as-string";
      case /* A */0 :
      case /* C */2 :
          return "other";
      
    }
  }
  
  exports.f = f;
  exports.g = g;
  /* No side effect */

  $ cat > x.ml <<EOF
  > type (_, _) x =
  >   | [] : ('a, 'a) x
  >   | ( :: ) : 'a * ('ty, 'v) x -> ('a -> 'ty, 'v) x
  > let rec f : type a b. (a, string ref) x -> string =
  >  fun x -> match x with [] -> "empty" | _ :: xs -> f xs
  > EOF

  $ dune build @melange
  $ cat ./_build/default/js-out/x.js
  // Generated by Melange
  'use strict';
  
  
  function f(_x) {
    while(true) {
      const x = _x;
      if (!x) {
        return "empty";
      }
      _x = x.tl;
      continue ;
    };
  }
  
  exports.f = f;
  /* No side effect */

  $ cat > x.ml <<EOF
  > type x = A [@mel.as "A"] | B
  > let f x = match x with A -> "a" | B -> "b"
  > EOF

  $ dune build @melange
  $ cat ./_build/default/js-out/x.js
  // Generated by Melange
  'use strict';
  
  
  function f(x) {
    if (x === "A") {
      return "a";
    } else {
      return "b";
    }
  }
  
  exports.f = f;
  /* No side effect */
