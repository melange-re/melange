  $ . ./setup.sh

This external triggers the `redundant` alert

  $ cat > x.ml <<\EOF
  > external foo : ([ `foo ][@mel.string]) -> string = "foo"
  > let _ = foo `foo
  > EOF

  $ melc -ppx melppx x.ml
  File "x.ml", line 1, characters 16-24:
  1 | external foo : ([ `foo ][@mel.string]) -> string = "foo"
                      ^^^^^^^^
  Alert redundant: [@mel.string] is redundant here, you can safely remove it
  // Generated by Melange
  'use strict';
  
  
  foo("foo");
  /*  Not a pure module */

But this does not

  $ cat > x.ml <<\EOF
  > external foo : ([ `foo [@mel.as "bar"] ][@mel.string]) -> unit = "foo"
  > let _ = foo `foo
  > EOF

  $ melc -ppx melppx x.ml
  // Generated by Melange
  'use strict';
  
  
  foo("bar");
  /*  Not a pure module */

This case doesn't warn, but it probably should

  $ cat > x.ml <<\EOF
  > external foo : ([ `foo of string ][@mel.string]) -> string = "foo"
  > let _ = foo (`foo "bar")
  > EOF

  $ melc -ppx melppx x.ml
  // Generated by Melange
  'use strict';
  
  
  foo("foo", "bar");
  /*  Not a pure module */

The analog case with `@mel.int` fails to build

  $ cat > x.ml <<\EOF
  > external foo : ([ `foo of int ][@mel.int]) -> string = "foo"
  > let _ = foo (`foo 2)
  > EOF

  $ melc -ppx melppx x.ml
  File "x.ml", line 1, characters 16-31:
  1 | external foo : ([ `foo of int ][@mel.int]) -> string = "foo"
                      ^^^^^^^^^^^^^^^
  Error: Invalid type for `[@mel.int]'
  [2]

This is wrong, just because there's `[@mel.as]` we shouldn't splice the payload in

  $ cat > x.ml <<\EOF
  > external foo : ([ `foo of int [@mel.as "bar"]]) -> string = "foo"
  > let _ = foo (`foo 2)
  > EOF
  $ melc -ppx melppx x.ml
  // Generated by Melange
  'use strict';
  
  
  foo({
    NAME: "bar",
    VAL: 2
  });
  /*  Not a pure module */

  $ cat > x.ml <<\EOF
  > external foo : ([ `foo [@mel.as "bar"]][@mel.unwrap]) -> string = "foo"
  > let _ = foo `foo
  > EOF
  $ melc -ppx melppx x.ml
  // Generated by Melange
  'use strict';
  
  
  foo("bar");
  /*  Not a pure module */

  $ cat > x.ml <<EOF
  > external join : ?foo:[ | \`foo of int [@mel.as "hi"] ] -> string = "join"
  > let x = join ~foo:(\`foo 42)
  > EOF
  $ melc -ppx melppx x.ml
  // Generated by Melange
  'use strict';
  
  
  const x = join({
    NAME: "hi",
    VAL: 42
  });
  
  module.exports = {
    x,
  }
  /* x Not a pure module */
