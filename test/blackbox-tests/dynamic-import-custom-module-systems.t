Demonstrate dynamic `import()` semantics with custom module systems

  $ . ./setup.sh

  $ cat > y.ml <<EOF
  > let x = 1
  > EOF

  $ cat > x.ml <<EOF
  > module type y = module type of Y
  > let x () = Js.import (module Y : y)
  > EOF

Batch compilation, defaults

  $ melc --mel-module-name y -impl y.ml -o y.js
  $ melc --mel-module-name x -impl x.ml -I . -o x.js
  $ cat x.js
  // Generated by Melange
  'use strict';
  
  
  function x(param) {
    return import("./y.js");
  }
  
  module.exports = {
    x,
  }
  /* No side effect */

Batch compilation, `--mel-package-output`

  $ rm -rf x.*js y.*js y.cm* x.cm*
  $ melc --mel-module-name y \
  >   --mel-package-output es6:.:.mjs --mel-package-output commonjs:.:.bs.js \
  >   -impl y.ml -o y.js
  $ melc --mel-module-name x \
  >   --mel-package-output es6:.:.mjs --mel-package-output commonjs:.:.bs.js \
  >   -impl x.ml -I . -o x.js
  $ cat x.mjs
  // Generated by Melange
  
  
  function x(param) {
    return import("./y.mjs");
  }
  
  export {
    x,
  }
  /* No side effect */
  $ cat x.bs.js
  // Generated by Melange
  'use strict';
  
  
  function x(param) {
    return import("./y.bs.js");
  }
  
  module.exports = {
    x,
  }
  /* No side effect */

  $ rm -rf x.*js y.*js y.cm* x.cm*

Separate compilation (using dune), multiple module systems

  $ cat > dune-project <<EOF
  > (lang dune 3.9)
  > (using melange 0.1)
  > EOF

  $ cat > dune <<EOF
  > (melange.emit
  >  (target out)
  >  (preprocess (pps melange.ppx))
  >  (modules x y)
  >  (module_systems (commonjs cjs) (es6 mjs))
  >  (emit_stdlib false))
  > EOF

  $ dune build @melange

  $ cat _build/default/out/x.cjs
  // Generated by Melange
  'use strict';
  
  
  function x(param) {
    return import("./y.cjs");
  }
  
  module.exports = {
    x,
  }
  /* No side effect */

  $ cat _build/default/out/x.mjs
  // Generated by Melange
  
  
  function x(param) {
    return import("./y.mjs");
  }
  
  export {
    x,
  }
  /* No side effect */
