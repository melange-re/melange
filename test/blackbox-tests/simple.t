Set up a few directories we'll need

  $ mkdir -p lib
  $ mkdir -p app
  $ mkdir -p output/lib
  $ mkdir -p output/app

  $ echo "let t = 1" > lib/a.ml
  $ echo "let t = A.t" > app/b.ml

  $ PKG_NAME="-bs-package-name this"

This example shows that we need to pass `-bs-package-output` both at `.cmj`
generation time, _and_ `.js` generation time. See `no-package-name-in-js.t` for
and example of using just the `-bs-module-type` flag when generating JS

  $ cd lib/
  $ melc $PKG_NAME -bs-package-output commonjs:./lib:.js -bs-stop-after-cmj -nopervasives a.ml
  $ cd -
  $TESTCASE_ROOT

  $ cd app/
  $ melc $PKG_NAME -bs-package-output commonjs:./app:.js -I ../lib b.ml -nopervasives -bs-stop-after-cmj
  $ cd -
  $TESTCASE_ROOT

The linking step shouldn't need package specs.
Melange should just have a flag for module system, and you can define
the extension via `-o `

Just used for the module system and extension in this phase

  $ cd output/lib
  $ melc $PKG_NAME -bs-package-output commonjs:./lib:.js -nopervasives ../../lib/a.cmj -o a.js
  $ cd -
  $TESTCASE_ROOT

  $ cd output/app/
  $ melc $PKG_NAME -bs-package-output commonjs:./app:.js -nopervasives -I ../../lib ../../app/b.cmj -o b.js
  $ cd -
  $TESTCASE_ROOT

B imports A with the correct paths

  $ cat output/app/b.js
  // Generated by Melange
  'use strict';
  
  const A = require("../lib/a.js");
  
  const t = A.t;
  
  module.exports = {
    t,
  }
  /* No side effect */
