
  $ . ./setup.sh
  $ cat > x.ml <<EOF
  > external floatToString: float -> ?radix:int -> string = "toString" [@@mel.send]
  > let x = floatToString 42. ?radix:None
  > external regExpFromString: string -> ?flags:string -> Js.Re.t = "RegExp" [@@mel.new]
  > let y = regExpFromString "ab+c" ?flags:None
  > EOF

  $ melc -ppx melppx x.ml
  // Generated by Melange
  'use strict';
  
  
  const x = (42).toString();
  
  const y = new RegExp("ab+c");
  
  module.exports = {
    x,
    y,
  }
  /* x Not a pure module */

  $ cat > x.ml <<EOF
  > external regExpFromString
  >   : string
  >   -> ?flags:string
  >   -> ?flags2:string
  >   -> Js.Re.t = "RegExp" [@@mel.new]
  > let y = regExpFromString "ab+c" ?flags:None ?flags2:None
  > EOF

  $ melc -ppx melppx x.ml
  // Generated by Melange
  'use strict';
  
  
  const y = new RegExp("ab+c");
  
  module.exports = {
    y,
  }
  /* y Not a pure module */

  $ cat > x.ml <<EOF
  > external regExpFromString
  >   : string
  >   -> ?flags:string
  >   -> ?flags2:string
  >   -> unit
  >   -> Js.Re.t = "RegExp" [@@mel.new]
  > let y = regExpFromString "ab+c" ()
  > EOF

  $ melc -ppx melppx x.ml
  // Generated by Melange
  'use strict';
  
  
  const y = new RegExp("ab+c");
  
  module.exports = {
    y,
  }
  /* y Not a pure module */

It now becomes impossible to pass `~x:()` to a function

  $ cat > x.ml <<EOF
  > external regExpFromString
  >   : string
  >   -> ?flags:unit
  >   -> unit
  >   -> Js.Re.t = "RegExp" [@@mel.new]
  > let y = regExpFromString "ab+c" ~flags:() ()
  > EOF

  $ melc -ppx melppx x.ml
  // Generated by Melange
  'use strict';
  
  
  const y = new RegExp("ab+c", undefined);
  
  module.exports = {
    y,
  }
  /* y Not a pure module */

