
  $ . ./setup.sh
  $ cat > x.ml <<EOF
  > type (_, _) x =
  >   | [] : ('a, 'a) x
  >   | ( :: ) : 'a * ('ty, 'v) x -> ('a -> 'ty, 'v) x
  > let rec f : type a. (a, string ref) x -> string =
  >  fun x -> match x with [] -> "empty" | _ :: xs -> f xs
  > EOF

  $ melc -ppx melppx x.ml
  // Generated by Melange
  'use strict';
  
  
  function f(_x) {
    while (true) {
      const x = _x;
      if (!x) {
        return "empty";
      }
      _x = x.tl;
      continue;
    };
  }
  
  module.exports = {
    f,
  }
  /* No side effect */

  $ cat > x.ml <<EOF
  > type (_, _) x =
  >   | [] : ('a, 'a) x [@mel.as "lol"]
  >   | ( :: ) : 'a * ('ty, 'v) x -> ('a -> 'ty, 'v) x
  > 
  > let x : _ x = []
  > 
  > let rec f : type a. (a, string ref) x -> string =
  >  fun x -> match x with [] -> "empty" | _ :: xs -> f xs
  > EOF

  $ melc -ppx melppx x.ml
  // Generated by Melange
  'use strict';
  
  
  function f(_x) {
    while (true) {
      const x = _x;
      if (!x) {
        return "empty";
      }
      _x = x.tl;
      continue;
    };
  }
  
  const x = /* [] */ 0;
  
  module.exports = {
    x,
    f,
  }
  /* No side effect */

  $ cat > x.ml <<EOF
  > type (_, _) x =
  >   | [] : ('a, 'a) x [@mel.as "lol"]
  >   | ( :: ) : 'a * ('ty, 'v) x -> ('a -> 'ty, 'v) x [@mel.as "different"]
  > 
  > let x : _ x = []
  > let y : _ x = [ 2 ]
  > 
  > let rec f : type a. (a, string ref) x -> string =
  >  fun x -> match x with [] -> "empty" | _ :: xs -> f xs
  > EOF

  $ melc -ppx melppx x.ml
  // Generated by Melange
  'use strict';
  
  
  function f(_x) {
    while (true) {
      const x = _x;
      if (!x) {
        return "empty";
      }
      _x = x.tl;
      continue;
    };
  }
  
  const x = /* [] */ 0;
  
  const y = {
    hd: 2,
    tl: /* [] */ 0
  };
  
  module.exports = {
    x,
    y,
    f,
  }
  /* No side effect */
