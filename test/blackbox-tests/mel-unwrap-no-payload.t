Test `@mel.unwrap` + polyvariants with no payload

  $ . ./setup.sh

  $ cat > x.ml <<EOF
  > external foo : ([ \`foo | \`int of int ][@mel.unwrap]) -> unit = "someFnCall"
  > let () = foo \`foo; foo (\`int 42)
  > EOF
  $ melc -ppx melppx x.ml
  // Generated by Melange
  'use strict';
  
  
  someFnCall("foo");
  
  someFnCall(42);
  /*  Not a pure module */

  $ cat > x.ml <<EOF
  > external foo : ([ \`foo [@mel.as "bar"] | \`int of int ][@mel.unwrap]) -> unit = "someFnCall"
  > let () = foo \`foo
  > EOF
  $ melc -ppx melppx x.ml
  // Generated by Melange
  'use strict';
  
  
  someFnCall("bar");
  /*  Not a pure module */


  $ cat > x.ml <<EOF
  > external foo : ([ \`foo [@mel.as 53] | \`int of int ][@mel.unwrap]) -> unit = "someFnCall"
  > let () = foo \`foo
  > EOF
  $ melc -ppx melppx x.ml
  // Generated by Melange
  'use strict';
  
  
  someFnCall(53);
  /*  Not a pure module */

  $ cat > x.ml <<EOF
  > external foo : ([ \`foo | \`int of int [@mel.as "bar"]][@mel.unwrap]) -> unit = "someFnCall"
  > let () = foo (\`int 42)
  > EOF
  $ melc -ppx melppx x.ml
  File "x.ml", line 1:
  Error: `[@mel.as ..]' can only be used with `[@mel.unwrap]' variants without a payload.
  [2]

`@mel.unwrap` works like before for other data types

  $ cat > x.ml <<EOF
  > external log1 : ([ \`Pair of string * int ][@mel.unwrap]) -> unit = "console.log"
  > let () =
  >   let arg_pair = \`Pair ("hi", 1) in
  >   log1 arg_pair
  > EOF
  $ melc -ppx melppx x.ml
  // Generated by Melange
  'use strict';
  
  
  console.log([
    "hi",
    1
  ]);
  /*  Not a pure module */

