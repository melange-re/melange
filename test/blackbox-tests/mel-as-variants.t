Test `@mel.as` in variant constructors

  $ . ./setup.sh
  $ cat > x.ml <<EOF
  > type t = Not_A [@mel.as "A"] | Not_B [@mel.as "B"] | Not_C
  > let x = Not_A
  > EOF
  $ melc -ppx melppx x.ml
  // Generated by Melange
  'use strict';
  
  
  const x = /* Not_A */ "A";
  
  module.exports = {
    x,
  }
  /* No side effect */

  $ cat > x.ml <<EOF
  > type t =
  >   | No_payload
  >   | Also_no_payload [@mel.as "nopayload"]
  >   | Has_payload of string [@mel.as "payload1"]
  > let x = No_payload
  > let y = Also_no_payload
  > let z = Has_payload "p1"
  > let f = function
  >   | No_payload -> "payload1"
  >   | Also_no_payload -> "nopaylod2"
  >   | Has_payload _ -> "payload2"
  > EOF
  $ melc -ppx melppx x.ml
  // Generated by Melange
  'use strict';
  
  
  function f(param) {
    if (typeof param !== "object") {
      if (param === /* No_payload */ 0) {
        return "payload1";
      } else {
        return "nopaylod2";
      }
    } else {
      return "payload2";
    }
  }
  
  const x = /* No_payload */ 0;
  
  const y = /* Also_no_payload */ "nopayload";
  
  const z = {
    TAG: /* Has_payload */ "payload1",
    _0: "p1"
  };
  
  module.exports = {
    x,
    y,
    z,
    f,
  }
  /* No side effect */

  $ cat > x.ml <<EOF
  > type t =
  >   | No_payload
  >   | Also_no_payload [@mel.as "nopayload"]
  >   | Has_payload of string [@mel.as "payload1"]
  >   | Has_payload2 of int
  > let x = No_payload
  > let y = Also_no_payload
  > let z = Has_payload "p1"
  > let t = Has_payload2 42
  > let f = function
  >   | No_payload -> "nopayload1"
  >   | Also_no_payload -> "nopaylod2"
  >   | Has_payload _ -> "payload1"
  >   | Has_payload2 _ -> "payload2"
  > EOF
  $ melc -ppx melppx x.ml
  // Generated by Melange
  'use strict';
  
  
  function f(param) {
    if (typeof param !== "object") {
      if (param === /* No_payload */ 0) {
        return "nopayload1";
      } else {
        return "nopaylod2";
      }
    } else if (param.TAG === /* Has_payload */ "payload1") {
      return "payload1";
    } else {
      return "payload2";
    }
  }
  
  const x = /* No_payload */ 0;
  
  const y = /* Also_no_payload */ "nopayload";
  
  const z = {
    TAG: /* Has_payload */ "payload1",
    _0: "p1"
  };
  
  const t = {
    TAG: /* Has_payload2 */ 1,
    _0: 42
  };
  
  module.exports = {
    x,
    y,
    z,
    t,
    f,
  }
  /* No side effect */

  $ cat > x.ml <<EOF
  > type t =
  >   | No_payload
  >   | Has_payload of string [@mel.as "payload1"]
  >   | Also_payload of { s: string } [@mel.as "payload2"]
  > let x = No_payload
  > let y = Has_payload "p1"
  > let z = Also_payload { s = "p2" }
  > EOF
  $ melc -ppx melppx x.ml
  // Generated by Melange
  'use strict';
  
  
  const x = /* No_payload */ 0;
  
  const y = {
    TAG: /* Has_payload */ "payload1",
    _0: "p1"
  };
  
  const z = {
    TAG: /* Also_payload */ "payload2",
    s: "p2"
  };
  
  module.exports = {
    x,
    y,
    z,
  }
  /* No side effect */

