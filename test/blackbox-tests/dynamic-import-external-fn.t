Demonstrate dynamic `import()` semantics for `external` arrows that the lambda
translation converts into LFunction stubs

  $ . ./setup.sh
  $ cat > dune-project <<EOF
  > (lang dune 3.9)
  > (using melange 0.1)
  > EOF

  $ cat > dune <<EOF
  > (melange.emit
  >  (target out)
  >  (preprocess (pps melange.ppx))
  >  (emit_stdlib false))
  > EOF

  $ cat > x.ml <<EOF
  > external ext: unit -> string = "default" [@@mel.module "lib"]
  > let _ext: (unit -> string) Js.promise = Js.import(ext)
  > EOF

  $ dune build @melange
  $ cat _build/default/out/x.js
  // Generated by Melange
  'use strict';
  
  
  const _ext = import("lib").then(function (m) {
        return m.default;
      });
  
  exports._ext = _ext;
  /* _ext Not a pure module */

Example where the `return_unit` function attribute is `true` and the lambda
includes `Lsequence (_, Lconst Const_js_undefined)`

  $ rm x.ml
  $ cat > x.re <<EOF
  > [@mel.module "react"]
  > external useEffect:
  >   ([@mel.uncurry] (unit => option(unit => unit))) => unit = "useEffect";
  > 
  > let dynamicallyImportedUseEffect = Js.import(useEffect);
  > EOF

  $ dune build @melange
  $ cat _build/default/out/x.js
  // Generated by Melange
  'use strict';
  
  
  const dynamicallyImportedUseEffect = import("react").then(function (m) {
        return m.useEffect;
      });
  
  exports.dynamicallyImportedUseEffect = dynamicallyImportedUseEffect;
  /* dynamicallyImportedUseEffect Not a pure module */


  $ cat > x.re <<EOF
  > [@mel.module "some-uncurried-module"]
  > external uncurriedFn: (. int, int, int) => unit = "uncurriedFn";
  > 
  > let dynamicallyImportedUncurriedFn = Js.import(uncurriedFn);
  > EOF

  $ dune build @melange
  $ cat _build/default/out/x.js
  // Generated by Melange
  'use strict';
  
  
  const dynamicallyImportedUncurriedFn = import("some-uncurried-module").then(function (m) {
        return m.uncurriedFn;
      });
  
  exports.dynamicallyImportedUncurriedFn = dynamicallyImportedUncurriedFn;
  /* dynamicallyImportedUncurriedFn Not a pure module */

