Showcase usage of escaped and literal unicode text in regular strings

  $ . ./setup.sh

  $ cat > dune-project <<EOF
  > (lang dune 3.15)
  > (using melange 0.1)
  > EOF
  $ cat > dune <<EOF
  > (melange.emit
  >  (target output)
  >  (alias mel)
  >  (libraries melange.node)
  >  (preprocess (pps melange.ppx -alert -fragile)))
  > EOF

  $ cat > x.ml <<EOF
  > let s = "\u{1F42B}"
  > EOF

  $ dune build @mel
  $ cat _build/default/output/x.js
  // Generated by Melange
  'use strict';
  
  
  const s = "\xf0\x9f\x90\xab";
  
  exports.s = s;
  /* No side effect */

  $ cat > x.ml <<EOF
  > let s = "🐫"
  > EOF

  $ dune build @mel
  $ cat _build/default/output/x.js
  // Generated by Melange
  'use strict';
  
  
  const s = "\xf0\x9f\x90\xab";
  
  exports.s = s;
  /* No side effect */

Locations are broken

  $ cat > x.ml <<EOF
  > let q = "💩💩💩💩💩💩💩💩💩💩" ^ ("a" ^ 3 ^ "b")
  > EOF

  $ dune build @mel
  File "x.ml", line 1, characters 60-61:
  1 | let q = "💩💩💩💩💩💩💩💩💩💩" ^ ("a" ^ 3 ^ "b")
                                                                  ^
  Error: This expression has type int but an expression was expected of type
           string
  [1]

Match over unicode strings

  $ cat > x.ml <<EOF
  > let y = "\xf0\x9f\x90\xab"
  > 
  > let t = match y with | "\xf0\x9f\x90\xab" -> "true" | _ -> "false"
  > 
  > let () = print_endline t
  > let u = match y with | "🐫" -> "true" | _ -> "false"
  > 
  > let () = print_endline u
  > let z = "🐫"
  > 
  > let t = match z with | "\xf0\x9f\x90\xab" -> "true" | _ -> "false"
  > 
  > let () = print_endline t
  > let u = match z with | "🐫" -> "true" | _ -> "false"
  > 
  > let () = print_endline u
  > EOF

  $ dune build @mel
  $ cat _build/default/output/x.js
  // Generated by Melange
  'use strict';
  
  
  console.log("true");
  
  console.log("true");
  
  const t = "true";
  
  console.log(t);
  
  const u = "true";
  
  console.log(u);
  
  const y = "\xf0\x9f\x90\xab";
  
  const z = "\xf0\x9f\x90\xab";
  
  exports.y = y;
  exports.z = z;
  exports.t = t;
  exports.u = u;
  /*  Not a pure module */

  $ node _build/default/output/x.js
  true
  true
  true
  true

Matching over bytes read from a binary stream works (this is the main reason
why `j` and `js` quoted strings exist, and using unicode literals like emojis
in regular strings does not produce the expected result in the generated
JavaScript code)

  $ cat > dumpbytes.js <<EOF
  > const fs = require('fs');
  > 
  > // Create a Buffer with the bytes
  > const byteData = Buffer.from([0xf0, 0x9f, 0x90, 0xab]);
  > 
  > // Write the Buffer to a file
  > fs.writeFile('output.bin', byteData, (err) => {
  >   if (err) throw err;
  >   console.log('File saved');
  > });
  > EOF

  $ node dumpbytes.js
  File saved

  $ cat > y.ml <<EOF
  > let s = In_channel.input_all (In_channel.open_bin "output.bin")
  > let () =
  >   Format.eprintf "%B@." (match s with "\xf0\x9f\x90\xab" -> true | _ -> false)
  > let () = Printf.printf "%s" s
  > EOF
  $ ocaml y.ml
  true
  🐫

  $ cat > x.ml <<EOF
  > let () =
  >   let s = Node.Fs.readFileSync "output.bin" \`binary in
  >   Format.eprintf "%B@." (match s with "\xf0\x9f\x90\xab" -> true | _ -> false)
  > EOF
  $ dune build @mel
  $ cat _build/default/output/x.js
  // Generated by Melange
  'use strict';
  
  const Curry = require("melange.js/curry.js");
  const Stdlib__Format = require("melange/format.js");
  const Fs = require("fs");
  
  const s = Fs.readFileSync("output.bin", "binary");
  
  let tmp = s === "\xf0\x9f\x90\xab" ? true : false;
  
  Curry._1(Stdlib__Format.eprintf(/* Format */{
            _0: {
              TAG: /* Bool */9,
              _0: /* No_padding */0,
              _1: {
                TAG: /* Formatting_lit */17,
                _0: /* Flush_newline */4,
                _1: /* End_of_format */0
              }
            },
            _1: "%B@."
          }), tmp);
  
  /* s Not a pure module */

  $ node _build/default/output/x.js
  true
