Test `@@mel.tag` attribute for discriminated unions

  $ . ./setup.sh
  $ cat > x.ml <<EOF
  > type foo = { a : string; b : string }
  > type[@mel.tag "lol"] t = Foo of foo | Bar of { c : string; d : string }
  > let x, y =
  >   let x = Foo { a = "a"; b = "b" } in
  >   let y = Bar { c = "c"; d = "d" } in
  >   (x, y)
  > let s = function Foo { a; b } -> (a, b) | Bar { c; d } -> (c, d)
  > EOF

  $ melc -ppx melppx x.ml
  // Generated by Melange
  'use strict';
  
  
  function s(param) {
    if (param.lol !== /* Foo */0) {
      return [
              param.c,
              param.d
            ];
    }
    const match = param._0;
    return [
            match.a,
            match.b
          ];
  }
  
  const x = {
    lol: /* Foo */0,
    _0: {
      a: "a",
      b: "b"
    }
  };
  
  const y = {
    lol: /* Bar */1,
    c: "c",
    d: "d"
  };
  
  exports.x = x;
  exports.y = y;
  exports.s = s;
  /* No side effect */

`@mel.tag` + `[@mel.as "string"]`

  $ cat > x.ml <<EOF
  > type foo = { a : string; b : string }
  > type[@mel.tag "lol"] t =
  >   | Foo of foo
  >   | Bar of { c : string; d : string } [@mel.as "bar"]
  > let x, y =
  >   let x = Foo { a = "a"; b = "b" } in
  >   let y = Bar { c = "c"; d = "d" } in
  >   (x, y)
  > let s = function Foo { a; b } -> (a, b) | Bar { c; d } -> (c, d)
  > EOF

  $ melc -ppx melppx x.ml
  // Generated by Melange
  'use strict';
  
  
  function s(param) {
    if (param.lol !== /* Foo */0) {
      return [
              param.c,
              param.d
            ];
    }
    const match = param._0;
    return [
            match.a,
            match.b
          ];
  }
  
  const x = {
    lol: /* Foo */0,
    _0: {
      a: "a",
      b: "b"
    }
  };
  
  const y = {
    lol: /* Bar */"bar",
    c: "c",
    d: "d"
  };
  
  exports.x = x;
  exports.y = y;
  exports.s = s;
  /* No side effect */
