Set up a few directories we'll need

  $ . ./setup.sh
  $ mkdir -p lib
  $ mkdir -p app
  $ mkdir -p output/lib
  $ mkdir -p output/app

  $ echo "let t = 1" > lib/a.ml
  $ echo "let t = A.t" > app/b.ml

If we don't have a package name, melc should allow not passing one

  $ cd lib/

Can't `-bs-module-type` and `-bs-package-output`

  $ melc -bs-module-type es6 -bs-package-output lib/ -bs-stop-after-cmj a.ml
  melc: Can't pass both `-bs-package-output` and `-bs-module-type`
  [124]

Now compile for real

  $ melc -bs-package-output lib/ -bs-stop-after-cmj a.ml
  $ cd -
  $TESTCASE_ROOT

  $ cd app/
  $ melc -bs-package-output app/ -I ../lib b.ml -bs-stop-after-cmj
  $ cd -
  $TESTCASE_ROOT

The linking step just needs `-bs-module-type`, it already knows the package
paths

  $ cd output/lib
  $ melc -bs-module-type commonjs ../../lib/a.cmj -o a.js
  $ cd -
  $TESTCASE_ROOT

  $ cd output/app/
  $ melc -bs-module-type commonjs -I ../../lib ../../app/b.cmj -o b.js
  $ cd -
  $TESTCASE_ROOT

B depends on A, so it should import a.js in the right path

  $ cat output/app/b.js
  // Generated by Melange
  'use strict';
  
  var A = require("../lib/a.js");
  
  var t = A.t;
  
  exports.t = t;
  /* No side effect */


Now generate ES6 imports and a `.mjs` extension from the same `.cmj`

  $ mkdir -p es6-output/lib es6-output/app

  $ cd es6-output/lib
  $ melc -bs-module-type es6 ../../lib/a.cmj -o a.mjs
  $ cd -
  $TESTCASE_ROOT

  $ cd es6-output/app/
  $ melc -bs-module-type es6 -I ../../lib ../../app/b.cmj -o b.mjs
  $ cd -
  $TESTCASE_ROOT

  $ ls es6-output/app
  b.mjs
  $ cat es6-output/app/b.mjs
  // Generated by Melange
  
  import * as A from "../lib/a.mjs";
  
  var t = A.t;
  
  export {
    t ,
  }
  /* No side effect */
