[@@@mel.config {flags = [|"-w";"a"|]}]
module Config : sig
(*#1 "config.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* System configuration *)

val version: string
        (* The current version number of the system *)

val standard_library: string
        (* The directory containing the standard libraries *)
val standard_runtime: string
        (* The full path to the standard bytecode interpreter ocamlrun *)
val ccomp_type: string
        (* The "kind" of the C compiler, assembler and linker used: one of
               "cc" (for Unix-style C compilers)
               "msvc" (for Microsoft Visual C++ and MASM) *)
val bytecomp_c_compiler: string
        (* The C compiler to use for compiling C files
           with the bytecode compiler *)
val bytecomp_c_libraries: string
        (* The C libraries to link with custom runtimes *)
val native_c_compiler: string
        (* The C compiler to use for compiling C files
           with the native-code compiler *)
val native_c_libraries: string
        (* The C libraries to link with native-code programs *)
val native_pack_linker: string
        (* The linker to use for packaging (ocamlopt -pack) and for partial
           links (ocamlopt -output-obj). *)
val mkdll: string
        (* The linker command line to build dynamic libraries. *)
val mkexe: string
        (* The linker command line to build executables. *)
val mkmaindll: string
        (* The linker command line to build main programs as dlls. *)
val ranlib: string
        (* Command to randomize a library, or "" if not needed *)
val ar: string
        (* Name of the ar command, or "" if not needed  (MSVC) *)
val cc_profile : string
        (* The command line option to the C compiler to enable profiling. *)

val load_path: string list ref
        (* Directories in the search path for .cmi and .cmo files *)

val interface_suffix: string ref
        (* Suffix for interface file names *)

val exec_magic_number: string
        (* Magic number for bytecode executable files *)
val cmi_magic_number: string
        (* Magic number for compiled interface files *)
val cmo_magic_number: string
        (* Magic number for object bytecode files *)
val cma_magic_number: string
        (* Magic number for archive files *)
val cmx_magic_number: string
        (* Magic number for compilation unit descriptions *)
val cmxa_magic_number: string
        (* Magic number for libraries of compilation unit descriptions *)
val ast_intf_magic_number: string
        (* Magic number for file holding an interface syntax tree *)
val ast_impl_magic_number: string
        (* Magic number for file holding an implementation syntax tree *)
val cmxs_magic_number: string
        (* Magic number for dynamically-loadable plugins *)
val cmt_magic_number: string
        (* Magic number for compiled interface files *)

val max_tag: int
        (* Biggest tag that can be stored in the header of a regular block. *)
val lazy_tag : int
        (* Normally the same as Obj.lazy_tag.  Separate definition because
           of technical reasons for bootstrapping. *)
val max_young_wosize: int
        (* Maximal size of arrays that are directly allocated in the
           minor heap *)
val stack_threshold: int
        (* Size in words of safe area at bottom of VM stack,
           see byterun/config.h *)

val architecture: string
        (* Name of processor type for the native-code compiler *)
val model: string
        (* Name of processor submodel for the native-code compiler *)
val system: string
        (* Name of operating system for the native-code compiler *)

val asm: string
        (* The assembler (and flags) to use for assembling
           ocamlopt-generated code. *)

val asm_cfi_supported: bool
        (* Whether assembler understands CFI directives *)
val with_frame_pointers : bool
        (* Whether assembler should maintain frame pointers *)

val ext_obj: string
        (* Extension for object files, e.g. [.o] under Unix. *)
val ext_asm: string
        (* Extension for assembler files, e.g. [.s] under Unix. *)
val ext_lib: string
        (* Extension for library files, e.g. [.a] under Unix. *)
val ext_dll: string
        (* Extension for dynamically-loaded libraries, e.g. [.so] under Unix.*)

val default_executable_name: string
        (* Name of executable produced by linking if none is given with -o,
           e.g. [a.out] under Unix. *)

val systhread_supported : bool
        (* Whether the system thread library is implemented *)

val host : string
        (* Whether the compiler is a cross-compiler *)

val target : string
        (* Whether the compiler is a cross-compiler *)

val print_config : out_channel -> unit;;

end = struct
(*#1 "config.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(***********************************************************************)
(**                                                                   **)
(**               WARNING WARNING WARNING                             **)
(**                                                                   **)
(** When you change this file, you must make the parallel change      **)
(** in config.mlbuild                                                 **)
(**                                                                   **)
(***********************************************************************)


(* The main OCaml version string has moved to ../VERSION *)
let version = Sys.ocaml_version

let standard_library_default = "/Users/hongbozhang/git/bucklescript/vendor/ocaml/lib/ocaml"

let standard_library =

  try
    Sys.getenv "BSLIB"
  with Not_found ->

    standard_library_default

let standard_runtime = "/Users/hongbozhang/git/bucklescript/vendor/ocaml/bin/ocamlrun"
let ccomp_type = "cc"
let bytecomp_c_compiler = "gcc -O  -Wall -D_FILE_OFFSET_BITS=64 -D_REENTRANT -O "
let bytecomp_c_libraries = "-lcurses -lpthread"
let native_c_compiler = "gcc -O  -D_FILE_OFFSET_BITS=64 -D_REENTRANT"
let native_c_libraries = ""
let native_pack_linker = "ld -r -arch x86_64  -o "
let ranlib = "ranlib"
let ar = "ar"
let cc_profile = "-pg"
let mkdll = "gcc -bundle -flat_namespace -undefined suppress -Wl,-no_compact_unwind"
let mkexe = "gcc -Wl,-no_compact_unwind"
let mkmaindll = "gcc -bundle -flat_namespace -undefined suppress -Wl,-no_compact_unwind"

let exec_magic_number = "Caml1999X011"
and cmi_magic_number = "Caml1999I017"
and cmo_magic_number = "Caml1999O010"
and cma_magic_number = "Caml1999A011"
and cmx_magic_number = "Caml1999Y014"
and cmxa_magic_number = "Caml1999Z013"
and ast_impl_magic_number = "Caml1999M016"
and ast_intf_magic_number = "Caml1999N015"
and cmxs_magic_number = "Caml2007D002"
and cmt_magic_number = "Caml2012T004"

let load_path = ref ([] : string list)

let interface_suffix = ref ".mli"

let max_tag = 245
(* This is normally the same as in obj.ml, but we have to define it
   separately because it can differ when we're in the middle of a
   bootstrapping phase. *)
let lazy_tag = 246

let max_young_wosize = 256
let stack_threshold = 256 (* see byterun/config.h *)

let architecture = "amd64"
let model = "default"
let system = "macosx"

let asm = "clang -arch x86_64 -c"
let asm_cfi_supported = true
let with_frame_pointers = false

let ext_obj = ".o"
let ext_asm = ".s"
let ext_lib = ".a"
let ext_dll = ".so"

let host = "x86_64-apple-darwin17.7.0"
let target = "x86_64-apple-darwin17.7.0"

let default_executable_name =
  match Sys.os_type with
    "Unix" -> "a.out"
  | "Win32" | "Cygwin" -> "camlprog.exe"
  | _ -> "camlprog"

let systhread_supported = true;;

let print_config oc =
  let p name valu = Printf.fprintf oc "%s: %s\n" name valu in
  let p_bool name valu = Printf.fprintf oc "%s: %B\n" name valu in
  p "version" version;
  p "standard_library_default" standard_library_default;
  p "standard_library" standard_library;
  p "standard_runtime" standard_runtime;
  p "ccomp_type" ccomp_type;
  p "bytecomp_c_compiler" bytecomp_c_compiler;
  p "bytecomp_c_libraries" bytecomp_c_libraries;
  p "native_c_compiler" native_c_compiler;
  p "native_c_libraries" native_c_libraries;
  p "native_pack_linker" native_pack_linker;
  p "ranlib" ranlib;
  p "cc_profile" cc_profile;
  p "architecture" architecture;
  p "model" model;
  p "system" system;
  p "asm" asm;
  p_bool "asm_cfi_supported" asm_cfi_supported;
  p_bool "with_frame_pointers" with_frame_pointers;
  p "ext_obj" ext_obj;
  p "ext_asm" ext_asm;
  p "ext_lib" ext_lib;
  p "ext_dll" ext_dll;
  p "os_type" Sys.os_type;
  p "default_executable_name" default_executable_name;
  p_bool "systhread_supported" systhread_supported;
  p "host" host;
  p "target" target;

  (* print the magic number *)
  p "exec_magic_number" exec_magic_number;
  p "cmi_magic_number" cmi_magic_number;
  p "cmo_magic_number" cmo_magic_number;
  p "cma_magic_number" cma_magic_number;
  p "cmx_magic_number" cmx_magic_number;
  p "cmxa_magic_number" cmxa_magic_number;
  p "ast_impl_magic_number" ast_impl_magic_number;
  p "ast_intf_magic_number" ast_intf_magic_number;
  p "cmxs_magic_number" cmxs_magic_number;
  p "cmt_magic_number" cmt_magic_number;

  flush oc;
;;

end
module Clflags : sig
(*#1 "clflags.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 2005 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

val objfiles : string list ref
val ccobjs : string list ref
val dllibs : string list ref
val compile_only : bool ref
val output_name : string option ref
val include_dirs : string list ref
val no_std_include : bool ref
val print_types : bool ref
val make_archive : bool ref
val debug : bool ref
val fast : bool ref
val link_everything : bool ref
val custom_runtime : bool ref
val no_check_prims : bool ref
val bytecode_compatible_32 : bool ref
val output_c_object : bool ref
val output_complete_object : bool ref
val all_ccopts : string list ref
val classic : bool ref
val nopervasives : bool ref
val open_modules : string list ref
val preprocessor : string option ref
val all_ppx : string list ref
val annotations : bool ref
val binary_annotations : bool ref
val use_threads : bool ref
val use_vmthreads : bool ref
val noassert : bool ref
val verbose : bool ref
val noprompt : bool ref
val nopromptcont : bool ref
val init_file : string option ref
val noinit : bool ref
val use_prims : string ref
val use_runtime : string ref
val principal : bool ref
val real_paths : bool ref
val recursive_types : bool ref
val strict_sequence : bool ref
val strict_formats : bool ref
val applicative_functors : bool ref
val make_runtime : bool ref
val gprofile : bool ref
val c_compiler : string option ref
val no_auto_link : bool ref
val dllpaths : string list ref
val make_package : bool ref
val for_package : string option ref
val error_size : int ref
val float_const_prop : bool ref
val transparent_modules : bool ref
val dump_source : bool ref
val dump_parsetree : bool ref
val dump_typedtree : bool ref
val dump_rawlambda : bool ref
val dump_lambda : bool ref
val dump_clambda : bool ref
val dump_instr : bool ref
val keep_asm_file : bool ref
val optimize_for_speed : bool ref
val dump_cmm : bool ref
val dump_selection : bool ref
val dump_cse : bool ref
val dump_live : bool ref
val dump_spill : bool ref
val dump_split : bool ref
val dump_interf : bool ref
val dump_prefer : bool ref
val dump_regalloc : bool ref
val dump_reload : bool ref
val dump_scheduling : bool ref
val dump_linear : bool ref
val keep_startup_file : bool ref
val dump_combine : bool ref
val native_code : bool ref
val inline_threshold : int ref
val dont_write_files : bool ref
val std_include_flag : string -> string
val std_include_dir : unit -> string list
val shared : bool ref
val dlcode : bool ref
val runtime_variant : string ref
val force_slash : bool ref
val keep_docs : bool ref
val keep_locs : bool ref
val unsafe_string : bool ref
val opaque : bool ref



type mli_status = Mli_na | Mli_exists | Mli_non_exists
val no_implicit_current_dir : bool ref
val assume_no_mli : mli_status ref
val record_event_when_debug : bool ref
val bs_vscode : bool
val dont_record_crc_unit : string option ref
val bs_only : bool ref (* set true on bs top*)
val no_assert_false : bool ref


type color_setting = Auto | Always | Never
val parse_color_setting : string -> color_setting option
val color : color_setting option ref


end = struct
(*#1 "clflags.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Command-line parameters *)

let objfiles = ref ([] : string list)   (* .cmo and .cma files *)
and ccobjs = ref ([] : string list)     (* .o, .a, .so and -cclib -lxxx *)
and dllibs = ref ([] : string list)     (* .so and -dllib -lxxx *)

let compile_only = ref false            (* -c *)
and output_name = ref (None : string option) (* -o *)
and include_dirs = ref ([] : string list)(* -I *)
and no_std_include = ref false          (* -nostdlib *)
and print_types = ref false             (* -i *)
and make_archive = ref false            (* -a *)
and debug = ref false                   (* -g *)
and fast = ref false                    (* -unsafe *)
and link_everything = ref false         (* -linkall *)
and custom_runtime = ref false          (* -custom *)
and no_check_prims = ref false          (* -no-check-prims *)
and bytecode_compatible_32 = ref false  (* -compat-32 *)
and output_c_object = ref false         (* -output-obj *)
and output_complete_object = ref false  (* -output-complete-obj *)
and all_ccopts = ref ([] : string list)     (* -ccopt *)
and classic = ref false                 (* -nolabels *)
and nopervasives = ref false            (* -nopervasives *)
and preprocessor = ref(None : string option) (* -pp *)
and all_ppx = ref ([] : string list)        (* -ppx *)
let annotations = ref false             (* -annot *)
let binary_annotations = ref false      (* -annot *)
and use_threads = ref false             (* -thread *)
and use_vmthreads = ref false           (* -vmthread *)
and noassert = ref false                (* -noassert *)
and verbose = ref false                 (* -verbose *)
and noprompt = ref false                (* -noprompt *)
and nopromptcont = ref false            (* -nopromptcont *)
and init_file = ref (None : string option)   (* -init *)
and noinit = ref false                  (* -noinit *)
and open_modules = ref []               (* -open *)
and use_prims = ref ""                  (* -use-prims ... *)
and use_runtime = ref ""                (* -use-runtime ... *)
and principal = ref false               (* -principal *)
and real_paths = ref true               (* -short-paths *)
and recursive_types = ref false         (* -rectypes *)
and strict_sequence = ref false         (* -strict-sequence *)
and strict_formats = ref false          (* -strict-formats *)
and applicative_functors = ref true     (* -no-app-funct *)
and make_runtime = ref false            (* -make-runtime *)
and gprofile = ref false                (* -p *)
and c_compiler = ref (None: string option) (* -cc *)
and no_auto_link = ref false            (* -noautolink *)
and dllpaths = ref ([] : string list)   (* -dllpath *)
and make_package = ref false            (* -pack *)
and for_package = ref (None: string option) (* -for-pack *)
and error_size = ref 500                (* -error-size *)
and float_const_prop = ref true         (* -no-float-const-prop *)
and transparent_modules = ref false     (* -trans-mod *)
let dump_source = ref false             (* -dsource *)
let dump_parsetree = ref false          (* -dparsetree *)
and dump_typedtree = ref false          (* -dtypedtree *)
and dump_rawlambda = ref false          (* -drawlambda *)
and dump_lambda = ref false             (* -dlambda *)
and dump_clambda = ref false            (* -dclambda *)
and dump_instr = ref false              (* -dinstr *)

let keep_asm_file = ref false           (* -S *)
let optimize_for_speed = ref true       (* -compact *)
and opaque = ref false                  (* -opaque *)

and dump_cmm = ref false                (* -dcmm *)
let dump_selection = ref false          (* -dsel *)
let dump_cse = ref false                (* -dcse *)
let dump_live = ref false               (* -dlive *)
let dump_spill = ref false              (* -dspill *)
let dump_split = ref false              (* -dsplit *)
let dump_interf = ref false             (* -dinterf *)
let dump_prefer = ref false             (* -dprefer *)
let dump_regalloc = ref false           (* -dalloc *)
let dump_reload = ref false             (* -dreload *)
let dump_scheduling = ref false         (* -dscheduling *)
let dump_linear = ref false             (* -dlinear *)
let keep_startup_file = ref false       (* -dstartup *)
let dump_combine = ref false            (* -dcombine *)
let native_code = ref false             (* set to true under ocamlopt *)
let inline_threshold = ref 10
let force_slash = ref false             (* for ocamldep *)

let dont_write_files = ref false        (* set to true under ocamldoc *)

let std_include_flag prefix =
  if !no_std_include then ""
  else (prefix ^ (Filename.quote Config.standard_library))
;;

let std_include_dir () =
  if !no_std_include then [] else [Config.standard_library]
;;

let shared = ref false (* -shared *)
let dlcode = ref true (* not -nodynlink *)

let runtime_variant = ref "";;      (* -runtime-variant *)

let keep_docs = ref false              (* -keep-docs *)
let keep_locs = ref false              (* -keep-locs *)
let unsafe_string = ref true;;         (* -safe-string / -unsafe-string *)



type mli_status = Mli_na | Mli_exists | Mli_non_exists
let no_implicit_current_dir = ref false
let assume_no_mli = ref Mli_na
let record_event_when_debug = ref true (* turned off in BuckleScript*)
let bs_vscode =
    try ignore @@ Sys.getenv "BS_VSCODE" ; true with _ -> false
    (* We get it from environment variable mostly due to
       we don't want to rebuild when flip on or off
    *)
let dont_record_crc_unit : string option ref = ref None
let bs_only = ref false
let no_assert_false = ref false


type color_setting = Auto | Always | Never
let parse_color_setting = function
  | "auto" -> Some Auto
  | "always" -> Some Always
  | "never" -> Some Never
  | _ -> None
let color = ref None ;; (* -color *)


end
module Misc : sig
(*#1 "misc.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Miscellaneous useful types and functions *)

val fatal_error: string -> 'a
exception Fatal_error

val try_finally : (unit -> 'a) -> (unit -> unit) -> 'a;;

val map_end: ('a -> 'b) -> 'a list -> 'b list -> 'b list
        (* [map_end f l t] is [map f l @ t], just more efficient. *)
val map_left_right: ('a -> 'b) -> 'a list -> 'b list
        (* Like [List.map], with guaranteed left-to-right evaluation order *)
val for_all2: ('a -> 'b -> bool) -> 'a list -> 'b list -> bool
        (* Same as [List.for_all] but for a binary predicate.
           In addition, this [for_all2] never fails: given two lists
           with different lengths, it returns false. *)
val replicate_list: 'a -> int -> 'a list
        (* [replicate_list elem n] is the list with [n] elements
           all identical to [elem]. *)
val list_remove: 'a -> 'a list -> 'a list
        (* [list_remove x l] returns a copy of [l] with the first
           element equal to [x] removed. *)
val split_last: 'a list -> 'a list * 'a
        (* Return the last element and the other elements of the given list. *)
val samelist: ('a -> 'a -> bool) -> 'a list -> 'a list -> bool
        (* Like [List.for_all2] but returns [false] if the two
           lists have different length. *)

val may: ('a -> unit) -> 'a option -> unit
val may_map: ('a -> 'b) -> 'a option -> 'b option

val find_in_path: string list -> string -> string
        (* Search a file in a list of directories. *)
val find_in_path_rel: string list -> string -> string
        (* Search a relative file in a list of directories. *)
val find_in_path_uncap: string list -> string -> string
        (* Same, but search also for uncapitalized name, i.e.
           if name is Foo.ml, allow /path/Foo.ml and /path/foo.ml
           to match. *)
val remove_file: string -> unit
        (* Delete the given file if it exists. Never raise an error. *)
val expand_directory: string -> string -> string
        (* [expand_directory alt file] eventually expands a [+] at the
           beginning of file into [alt] (an alternate root directory) *)

val create_hashtable: int -> ('a * 'b) list -> ('a, 'b) Hashtbl.t
        (* Create a hashtable of the given size and fills it with the
           given bindings. *)

val copy_file: in_channel -> out_channel -> unit
        (* [copy_file ic oc] reads the contents of file [ic] and copies
           them to [oc]. It stops when encountering EOF on [ic]. *)
val copy_file_chunk: in_channel -> out_channel -> int -> unit
        (* [copy_file_chunk ic oc n] reads [n] bytes from [ic] and copies
           them to [oc]. It raises [End_of_file] when encountering
           EOF on [ic]. *)
val string_of_file: in_channel -> string
        (* [string_of_file ic] reads the contents of file [ic] and copies
           them to a string. It stops when encountering EOF on [ic]. *)
val log2: int -> int
        (* [log2 n] returns [s] such that [n = 1 lsl s]
           if [n] is a power of 2*)
val align: int -> int -> int
        (* [align n a] rounds [n] upwards to a multiple of [a]
           (a power of 2). *)
val no_overflow_add: int -> int -> bool
        (* [no_overflow_add n1 n2] returns [true] if the computation of
           [n1 + n2] does not overflow. *)
val no_overflow_sub: int -> int -> bool
        (* [no_overflow_add n1 n2] returns [true] if the computation of
           [n1 - n2] does not overflow. *)
val no_overflow_lsl: int -> bool
        (* [no_overflow_add n] returns [true] if the computation of
           [n lsl 1] does not overflow. *)

val chop_extension_if_any: string -> string
        (* Like Filename.chop_extension but returns the initial file
           name if it has no extension *)

val chop_extensions: string -> string
        (* Return the given file name without its extensions. The extensions
           is the longest suffix starting with a period and not including
           a directory separator, [.xyz.uvw] for instance.

           Return the given name if it does not contain an extension. *)

val search_substring: string -> string -> int -> int
        (* [search_substring pat str start] returns the position of the first
           occurrence of string [pat] in string [str].  Search starts
           at offset [start] in [str].  Raise [Not_found] if [pat]
           does not occur. *)

val replace_substring: before:string -> after:string -> string -> string
        (* [search_substring ~before ~after str] replaces all occurences
           of [before] with [after] in [str] and returns the resulting string. *)

val rev_split_words: string -> string list
        (* [rev_split_words s] splits [s] in blank-separated words, and return
           the list of words in reverse order. *)

val get_ref: 'a list ref -> 'a list
        (* [get_ref lr] returns the content of the list reference [lr] and reset
           its content to the empty list. *)


val fst3: 'a * 'b * 'c -> 'a
val snd3: 'a * 'b * 'c -> 'b
val thd3: 'a * 'b * 'c -> 'c

val fst4: 'a * 'b * 'c * 'd -> 'a
val snd4: 'a * 'b * 'c * 'd -> 'b
val thd4: 'a * 'b * 'c * 'd -> 'c
val for4: 'a * 'b * 'c * 'd -> 'd

module LongString :
  sig
    type t = bytes array
    val create : int -> t
    val length : t -> int
    val get : t -> int -> char
    val set : t -> int -> char -> unit
    val blit : t -> int -> t -> int -> int -> unit
    val output : out_channel -> t -> int -> int -> unit
    val unsafe_blit_to_bytes : t -> int -> bytes -> int -> int -> unit
    val input_bytes : in_channel -> int -> t
  end

val edit_distance : string -> string -> int -> int option
(** [edit_distance a b cutoff] computes the edit distance between
    strings [a] and [b]. To help efficiency, it uses a cutoff: if the
    distance [d] is smaller than [cutoff], it returns [Some d], else
    [None].

    The distance algorithm currently used is Damerau-Levenshtein: it
    computes the number of insertion, deletion, substitution of
    letters, or swapping of adjacent letters to go from one word to the
    other. The particular algorithm may change in the future.
*)

val split : string -> char -> string list
(** [String.split string char] splits the string [string] at every char
    [char], and returns the list of sub-strings between the chars.
    [String.concat (String.make 1 c) (String.split s c)] is the identity.
    @since 4.01
 *)

val cut_at : string -> char -> string * string
(** [String.cut_at s c] returns a pair containing the sub-string before
   the first occurrence of [c] in [s], and the sub-string after the
   first occurrence of [c] in [s].
   [let (before, after) = String.cut_at s c in
    before ^ String.make 1 c ^ after] is the identity if [s] contains [c].

   Raise [Not_found] if the character does not appear in the string
   @since 4.01
*)





(* Color handling *)
module Color : sig
  type color =
    | Black
    | Red
    | Green
    | Yellow
    | Blue
    | Magenta
    | Cyan
    | White
  ;;

  type style =
    | FG of color (* foreground *)
    | BG of color (* background *)
    | Bold
    | Reset

    | Dim


  val ansi_of_style_l : style list -> string
  (* ANSI escape sequence for the given style *)

  type styles = {
    error: style list;
    warning: style list;
    loc: style list;
  }

  val default_styles: styles
  val get_styles: unit -> styles
  val set_styles: styles -> unit

  val setup : Clflags.color_setting option -> unit
  (* [setup opt] will enable or disable color handling on standard formatters
     according to the value of color setting [opt].
     Only the first call to this function has an effect. *)

  val set_color_tag_handling : Format.formatter -> unit
  (* adds functions to support color tags to the given formatter. *)
end


end = struct
(*#1 "misc.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Errors *)

exception Fatal_error

let fatal_error msg =
  prerr_string ">> Fatal error: "; prerr_endline msg; raise Fatal_error

(* Exceptions *)

let try_finally work cleanup =
  let result = (try work () with e -> cleanup (); raise e) in
  cleanup ();
  result
;;

(* List functions *)

let rec map_end f l1 l2 =
  match l1 with
    [] -> l2
  | hd::tl -> f hd :: map_end f tl l2

let rec map_left_right f = function
    [] -> []
  | hd::tl -> let res = f hd in res :: map_left_right f tl

let rec for_all2 pred l1 l2 =
  match (l1, l2) with
    ([], []) -> true
  | (hd1::tl1, hd2::tl2) -> pred hd1 hd2 && for_all2 pred tl1 tl2
  | (_, _) -> false

let rec replicate_list elem n =
  if n <= 0 then [] else elem :: replicate_list elem (n-1)

let rec list_remove x = function
    [] -> []
  | hd :: tl ->
      if hd = x then tl else hd :: list_remove x tl

let rec split_last = function
    [] -> assert false
  | [x] -> ([], x)
  | hd :: tl ->
      let (lst, last) = split_last tl in
      (hd :: lst, last)

let rec samelist pred l1 l2 =
  match (l1, l2) with
  | ([], []) -> true
  | (hd1 :: tl1, hd2 :: tl2) -> pred hd1 hd2 && samelist pred tl1 tl2
  | (_, _) -> false

(* Options *)

let may f = function
    Some x -> f x
  | None -> ()

let may_map f = function
    Some x -> Some (f x)
  | None -> None

(* File functions *)

let find_in_path path name =
  if not (Filename.is_implicit name) then
    if Sys.file_exists name then name else raise Not_found
  else begin
    let rec try_dir = function
      [] -> raise Not_found
    | dir::rem ->
        let fullname = Filename.concat dir name in
        if Sys.file_exists fullname then fullname else try_dir rem
    in try_dir path
  end

let find_in_path_rel path name =
  let rec simplify s =
    let open Filename in
    let base = basename s in
    let dir = dirname s in
    if dir = s then dir
    else if base = current_dir_name then simplify dir
    else concat (simplify dir) base
  in
  let rec try_dir = function
    [] -> raise Not_found
  | dir::rem ->
      let fullname = simplify (Filename.concat dir name) in
      if Sys.file_exists fullname then fullname else try_dir rem
  in try_dir path

let find_in_path_uncap path name =
  let uname = String.uncapitalize_ascii name in
  let rec try_dir = function
    [] -> raise Not_found
  | dir::rem ->
      let fullname = Filename.concat dir name
      and ufullname = Filename.concat dir uname in
      if Sys.file_exists ufullname then ufullname
      else if Sys.file_exists fullname then fullname
      else try_dir rem
  in try_dir path

let remove_file filename =
  try
    Sys.remove filename
  with Sys_error msg ->
    ()

(* Expand a -I option: if it starts with +, make it relative to the standard
   library directory *)

let expand_directory alt s =
  if String.length s > 0 && s.[0] = '+'
  then Filename.concat alt
                       (String.sub s 1 (String.length s - 1))
  else s

(* Hashtable functions *)

let create_hashtable size init =
  let tbl = Hashtbl.create size in
  List.iter (fun (key, data) -> Hashtbl.add tbl key data) init;
  tbl

(* File copy *)

let copy_file ic oc =
  let buff = Bytes.create 0x1000 in
  let rec copy () =
    let n = input ic buff 0 0x1000 in
    if n = 0 then () else (output oc buff 0 n; copy())
  in copy()

let copy_file_chunk ic oc len =
  let buff = Bytes.create 0x1000 in
  let rec copy n =
    if n <= 0 then () else begin
      let r = input ic buff 0 (min n 0x1000) in
      if r = 0 then raise End_of_file else (output oc buff 0 r; copy(n-r))
    end
  in copy len

let string_of_file ic =
  let b = Buffer.create 0x10000 in
  let buff = Bytes.create 0x1000 in
  let rec copy () =
    let n = input ic buff 0 0x1000 in
    if n = 0 then Buffer.contents b else
      (Buffer.add_subbytes b buff 0 n; copy())
  in copy()

(* Integer operations *)

let rec log2 n =
  if n <= 1 then 0 else 1 + log2(n asr 1)

let align n a =
  if n >= 0 then (n + a - 1) land (-a) else n land (-a)

let no_overflow_add a b = (a lxor b) lor (a lxor (lnot (a+b))) < 0

let no_overflow_sub a b = (a lxor (lnot b)) lor (b lxor (a-b)) < 0

let no_overflow_lsl a = min_int asr 1 <= a && a <= max_int asr 1

(* String operations *)

let chop_extension_if_any fname =
  try Filename.chop_extension fname with Invalid_argument _ -> fname

let chop_extensions file =
  let dirname = Filename.dirname file and basename = Filename.basename file in
  try
    let pos = String.index basename '.' in
    let basename = String.sub basename 0 pos in
    if Filename.is_implicit file && dirname = Filename.current_dir_name then
      basename
    else
      Filename.concat dirname basename
  with Not_found -> file

let search_substring pat str start =
  let rec search i j =
    if j >= String.length pat then i
    else if i + j >= String.length str then raise Not_found
    else if str.[i + j] = pat.[j] then search i (j+1)
    else search (i+1) 0
  in search start 0

let replace_substring ~before ~after str =
  let rec search acc curr =
    match search_substring before str curr with
      | next ->
         let prefix = String.sub str curr (next - curr) in
         search (prefix :: acc) (next + String.length before)
      | exception Not_found ->
        let suffix = String.sub str curr (String.length str - curr) in
        List.rev (suffix :: acc)
  in String.concat after (search [] 0)

let rev_split_words s =
  let rec split1 res i =
    if i >= String.length s then res else begin
      match s.[i] with
        ' ' | '\t' | '\r' | '\n' -> split1 res (i+1)
      | _ -> split2 res i (i+1)
    end
  and split2 res i j =
    if j >= String.length s then String.sub s i (j-i) :: res else begin
      match s.[j] with
        ' ' | '\t' | '\r' | '\n' -> split1 (String.sub s i (j-i) :: res) (j+1)
      | _ -> split2 res i (j+1)
    end
  in split1 [] 0

let get_ref r =
  let v = !r in
  r := []; v

let fst3 (x, _, _) = x
let snd3 (_,x,_) = x
let thd3 (_,_,x) = x

let fst4 (x, _, _, _) = x
let snd4 (_,x,_, _) = x
let thd4 (_,_,x,_) = x
let for4 (_,_,_,x) = x


module LongString = struct
  type t = bytes array

  let create str_size =
    let tbl_size = str_size / Sys.max_string_length + 1 in
    let tbl = Array.make tbl_size Bytes.empty in
    for i = 0 to tbl_size - 2 do
      tbl.(i) <- Bytes.create Sys.max_string_length;
    done;
    tbl.(tbl_size - 1) <- Bytes.create (str_size mod Sys.max_string_length);
    tbl

  let length tbl =
    let tbl_size = Array.length tbl in
    Sys.max_string_length * (tbl_size - 1) + Bytes.length tbl.(tbl_size - 1)

  let get tbl ind =
    Bytes.get tbl.(ind / Sys.max_string_length) (ind mod Sys.max_string_length)

  let set tbl ind c =
    Bytes.set tbl.(ind / Sys.max_string_length) (ind mod Sys.max_string_length)
              c

  let blit src srcoff dst dstoff len =
    for i = 0 to len - 1 do
      set dst (dstoff + i) (get src (srcoff + i))
    done

  let output oc tbl pos len =
    for i = pos to pos + len - 1 do
      output_char oc (get tbl i)
    done

  let unsafe_blit_to_bytes src srcoff dst dstoff len =
    for i = 0 to len - 1 do
      Bytes.unsafe_set dst (dstoff + i) (get src (srcoff + i))
    done

  let input_bytes ic len =
    let tbl = create len in
    Array.iter (fun str -> really_input ic str 0 (Bytes.length str)) tbl;
    tbl
end


let edit_distance a b cutoff =
  let la, lb = String.length a, String.length b in
  let cutoff =
    (* using max_int for cutoff would cause overflows in (i + cutoff + 1);
       we bring it back to the (max la lb) worstcase *)
    min (max la lb) cutoff in
  if abs (la - lb) > cutoff then None
  else begin
    (* initialize with 'cutoff + 1' so that not-yet-written-to cases have
       the worst possible cost; this is useful when computing the cost of
       a case just at the boundary of the cutoff diagonal. *)
    let m = Array.make_matrix (la + 1) (lb + 1) (cutoff + 1) in
    m.(0).(0) <- 0;
    for i = 1 to la do
      m.(i).(0) <- i;
    done;
    for j = 1 to lb do
      m.(0).(j) <- j;
    done;
    for i = 1 to la do
      for j = max 1 (i - cutoff - 1) to min lb (i + cutoff + 1) do
        let cost = if a.[i-1] = b.[j-1] then 0 else 1 in
        let best =
          (* insert, delete or substitute *)
          min (1 + min m.(i-1).(j) m.(i).(j-1)) (m.(i-1).(j-1) + cost)
        in
        let best =
          (* swap two adjacent letters; we use "cost" again in case of
             a swap between two identical letters; this is slightly
             redundant as this is a double-substitution case, but it
             was done this way in most online implementations and
             imitation has its virtues *)
          if not (i > 1 && j > 1 && a.[i-1] = b.[j-2] && a.[i-2] = b.[j-1])
          then best
          else min best (m.(i-2).(j-2) + cost)
        in
        m.(i).(j) <- best
      done;
    done;
    let result = m.(la).(lb) in
    if result > cutoff
    then None
    else Some result
  end


(* split a string [s] at every char [c], and return the list of sub-strings *)
let split s c =
  let len = String.length s in
  let rec iter pos to_rev =
    if pos = len then List.rev ("" :: to_rev) else
      match try
              Some ( String.index_from s pos c )
        with Not_found -> None
      with
          Some pos2 ->
            if pos2 = pos then iter (pos+1) ("" :: to_rev) else
              iter (pos2+1) ((String.sub s pos (pos2-pos)) :: to_rev)
        | None -> List.rev ( String.sub s pos (len-pos) :: to_rev )
  in
  iter 0 []

let cut_at s c =
  let pos = String.index s c in
  String.sub s 0 pos, String.sub s (pos+1) (String.length s - pos - 1)





(* Color handling *)
module Color = struct
  (* use ANSI color codes, see https://en.wikipedia.org/wiki/ANSI_escape_code *)
  type color =
    | Black
    | Red
    | Green
    | Yellow
    | Blue
    | Magenta
    | Cyan
    | White
  ;;

  type style =
    | FG of color (* foreground *)
    | BG of color (* background *)
    | Bold
    | Reset

    | Dim


  let ansi_of_color = function
    | Black -> "0"
    | Red -> "1"
    | Green -> "2"
    | Yellow -> "3"
    | Blue -> "4"
    | Magenta -> "5"
    | Cyan -> "6"
    | White -> "7"

  let code_of_style = function
    | FG c -> "3" ^ ansi_of_color c
    | BG c -> "4" ^ ansi_of_color c
    | Bold -> "1"
    | Reset -> "0"

    | Dim -> "2"


  let ansi_of_style_l l =
    let s = match l with
      | [] -> code_of_style Reset
      | [s] -> code_of_style s
      | _ -> String.concat ";" (List.map code_of_style l)
    in
    "\x1b[" ^ s ^ "m"

  type styles = {
    error: style list;
    warning: style list;
    loc: style list;
  }

  let default_styles = {
    warning = [Bold; FG Magenta];
    error = [Bold; FG Red];
    loc = [Bold];
  }

  let cur_styles = ref default_styles
  let get_styles () = !cur_styles
  let set_styles s = cur_styles := s

  (* map a tag to a style, if the tag is known.
     @raise Not_found otherwise *)
  let style_of_tag (Format.String_tag s) = match s with
    | "error" -> (!cur_styles).error
    | "warning" -> (!cur_styles).warning
    | "loc" -> (!cur_styles).loc

    | "info" -> [Bold; FG Yellow]
    | "dim" -> [Dim]
    | "filename" -> [FG Cyan]

    | _ -> raise Not_found

  let color_enabled = ref true

  (* either prints the tag of [s] or delegate to [or_else] *)
  let mark_open_tag ~or_else s =
    try
      let style = style_of_tag s in
      if !color_enabled then ansi_of_style_l style else ""
    with Not_found -> or_else s

  let mark_close_tag ~or_else s =
    try
      let _ = style_of_tag s in
      if !color_enabled then ansi_of_style_l [Reset] else ""
    with Not_found -> or_else s

  (* add color handling to formatter [ppf] *)
  let set_color_tag_handling ppf =
    let open Format in
    let functions = pp_get_formatter_stag_functions ppf () in
    let functions' = {functions with
      mark_open_stag=(mark_open_tag ~or_else:functions.mark_open_stag);
      mark_close_stag=(mark_close_tag ~or_else:functions.mark_close_stag);
    } in
    pp_set_mark_tags ppf true; (* enable tags *)
    pp_set_formatter_stag_functions ppf functions'

  (* external isatty : out_channel -> bool = "caml_sys_isatty" *)

  (* reasonable heuristic on whether colors should be enabled *)
   let should_enable_color () = false
(*    let term = try Sys.getenv "TERM" with Not_found -> "" in
    term <> "dumb"
    && term <> "" *)
(*    && isatty stderr *)

  let setup =
    let first = ref true in (* initialize only once *)
    let formatter_l = [Format.std_formatter; Format.err_formatter; Format.str_formatter] in
    fun o ->
      if !first then (
        first := false;
        Format.set_mark_tags true;
        List.iter set_color_tag_handling formatter_l;
        color_enabled := (match o with
          | Some Clflags.Always -> true
          | Some Clflags.Auto -> should_enable_color ()
          | Some Clflags.Never -> false
          | None -> should_enable_color ()
        )
      );
      ()
end


end
module Terminfo : sig
(*#1 "terminfo.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Basic interface to the terminfo database *)

type status =
  | Uninitialised
  | Bad_term
  | Good_term of int  (* number of lines of the terminal *)
;;
external setup : out_channel -> status = "caml_terminfo_setup";;
external backup : int -> unit = "caml_terminfo_backup";;
external standout : bool -> unit = "caml_terminfo_standout";;
external resume : int -> unit = "caml_terminfo_resume";;

end = struct
(*#1 "terminfo.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Basic interface to the terminfo database *)

type status =
  | Uninitialised
  | Bad_term
  | Good_term of int
;;
external setup : out_channel -> status = "caml_terminfo_setup";;
external backup : int -> unit = "caml_terminfo_backup";;
external standout : bool -> unit = "caml_terminfo_standout";;
external resume : int -> unit = "caml_terminfo_resume";;

end
module Warnings : sig
(*#1 "warnings.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Pierre Weis && Damien Doligez, INRIA Rocquencourt        *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Format

type t =
  | Comment_start                           (*  1 *)
  | Comment_not_end                         (*  2 *)
  | Deprecated of string                    (*  3 *)
  | Fragile_match of string                 (*  4 *)
  | Partial_application                     (*  5 *)
  | Labels_omitted                          (*  6 *)
  | Method_override of string list          (*  7 *)
  | Partial_match of string                 (*  8 *)
  | Non_closed_record_pattern of string     (*  9 *)
  | Statement_type                          (* 10 *)
  | Unused_match                            (* 11 *)
  | Unused_pat                              (* 12 *)
  | Instance_variable_override of string list (* 13 *)
  | Illegal_backslash                       (* 14 *)
  | Implicit_public_methods of string list  (* 15 *)
  | Unerasable_optional_argument            (* 16 *)
  | Undeclared_virtual_method of string     (* 17 *)
  | Not_principal of string                 (* 18 *)
  | Without_principality of string          (* 19 *)
  | Unused_argument                         (* 20 *)
  | Nonreturning_statement                  (* 21 *)
  | Preprocessor of string                  (* 22 *)
  | Useless_record_with                     (* 23 *)
  | Bad_module_name of string               (* 24 *)
  | All_clauses_guarded                     (* 25 *)
  | Unused_var of string                    (* 26 *)
  | Unused_var_strict of string             (* 27 *)
  | Wildcard_arg_to_constant_constr         (* 28 *)
  | Eol_in_string                           (* 29 *)
  | Duplicate_definitions of string * string * string * string (* 30 *)
  | Multiple_definition of string * string * string (* 31 *)
  | Unused_value_declaration of string      (* 32 *)
  | Unused_open of string                   (* 33 *)
  | Unused_type_declaration of string       (* 34 *)
  | Unused_for_index of string              (* 35 *)
  | Unused_ancestor of string               (* 36 *)
  | Unused_constructor of string * bool * bool (* 37 *)
  | Unused_extension of string * bool * bool   (* 38 *)
  | Unused_rec_flag                         (* 39 *)
  | Name_out_of_scope of string * string list * bool   (* 40 *)
  | Ambiguous_name of string list * string list * bool (* 41 *)
  | Disambiguated_name of string            (* 42 *)
  | Nonoptional_label of string             (* 43 *)
  | Open_shadow_identifier of string * string (* 44 *)
  | Open_shadow_label_constructor of string * string (* 45 *)
  | Bad_env_variable of string * string     (* 46 *)
  | Attribute_payload of string * string    (* 47 *)
  | Eliminated_optional_arguments of string list (* 48 *)
  | No_cmi_file of string                   (* 49 *)
  | Bad_docstring of bool                   (* 50 *)

  | Bs_unused_attribute of string           (* 101 *)
  | Bs_polymorphic_comparison               (* 102 *)
  | Bs_ffi_warning of string                (* 103 *)
  | Bs_derive_warning of string             (* 104 *)
;;

val parse_options : bool -> string -> unit;;

val is_active : t -> bool;;
val is_error : t -> bool;;

val defaults_w : string;;
val defaults_warn_error : string;;

val print : formatter -> t -> unit;;

exception Errors of int;;

val check_fatal : unit -> unit;;

val help_warnings: unit -> unit

type state
val backup: unit -> state
val restore: state -> unit


val message : t -> string
val number: t -> int
val super_print : (t -> string) -> formatter -> t -> unit;;


end = struct
(*#1 "warnings.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Pierre Weis && Damien Doligez, INRIA Rocquencourt        *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* When you change this, you need to update the documentation:
   - man/ocamlc.m   in ocaml
   - man/ocamlopt.m in ocaml
   - manual/cmds/comp.etex   in the doc sources
   - manual/cmds/native.etex in the doc sources
*)

type t =
  | Comment_start                           (*  1 *)
  | Comment_not_end                         (*  2 *)
  | Deprecated of string                    (*  3 *)
  | Fragile_match of string                 (*  4 *)
  | Partial_application                     (*  5 *)
  | Labels_omitted                          (*  6 *)
  | Method_override of string list          (*  7 *)
  | Partial_match of string                 (*  8 *)
  | Non_closed_record_pattern of string     (*  9 *)
  | Statement_type                          (* 10 *)
  | Unused_match                            (* 11 *)
  | Unused_pat                              (* 12 *)
  | Instance_variable_override of string list (* 13 *)
  | Illegal_backslash                       (* 14 *)
  | Implicit_public_methods of string list  (* 15 *)
  | Unerasable_optional_argument            (* 16 *)
  | Undeclared_virtual_method of string     (* 17 *)
  | Not_principal of string                 (* 18 *)
  | Without_principality of string          (* 19 *)
  | Unused_argument                         (* 20 *)
  | Nonreturning_statement                  (* 21 *)
  | Preprocessor of string                  (* 22 *)
  | Useless_record_with                     (* 23 *)
  | Bad_module_name of string               (* 24 *)
  | All_clauses_guarded                     (* 25 *)
  | Unused_var of string                    (* 26 *)
  | Unused_var_strict of string             (* 27 *)
  | Wildcard_arg_to_constant_constr         (* 28 *)
  | Eol_in_string                           (* 29 *)
  | Duplicate_definitions of string * string * string * string (*30 *)
  | Multiple_definition of string * string * string (* 31 *)
  | Unused_value_declaration of string      (* 32 *)
  | Unused_open of string                   (* 33 *)
  | Unused_type_declaration of string       (* 34 *)
  | Unused_for_index of string              (* 35 *)
  | Unused_ancestor of string               (* 36 *)
  | Unused_constructor of string * bool * bool  (* 37 *)
  | Unused_extension of string * bool * bool    (* 38 *)
  | Unused_rec_flag                         (* 39 *)
  | Name_out_of_scope of string * string list * bool (* 40 *)
  | Ambiguous_name of string list * string list *  bool    (* 41 *)
  | Disambiguated_name of string            (* 42 *)
  | Nonoptional_label of string             (* 43 *)
  | Open_shadow_identifier of string * string (* 44 *)
  | Open_shadow_label_constructor of string * string (* 45 *)
  | Bad_env_variable of string * string     (* 46 *)
  | Attribute_payload of string * string    (* 47 *)
  | Eliminated_optional_arguments of string list (* 48 *)
  | No_cmi_file of string                   (* 49 *)
  | Bad_docstring of bool                   (* 50 *)

  | Bs_unused_attribute of string           (* 101 *)
  | Bs_polymorphic_comparison               (* 102 *)
  | Bs_ffi_warning of string                (* 103 *)
  | Bs_derive_warning of string             (* 104 *)
;;

(* If you remove a warning, leave a hole in the numbering.  NEVER change
   the numbers of existing warnings.
   If you add a new warning, add it at the end with a new number;
   do NOT reuse one of the holes.
*)

let number = function
  | Comment_start -> 1
  | Comment_not_end -> 2
  | Deprecated _ -> 3
  | Fragile_match _ -> 4
  | Partial_application -> 5
  | Labels_omitted -> 6
  | Method_override _ -> 7
  | Partial_match _ -> 8
  | Non_closed_record_pattern _ -> 9
  | Statement_type -> 10
  | Unused_match -> 11
  | Unused_pat -> 12
  | Instance_variable_override _ -> 13
  | Illegal_backslash -> 14
  | Implicit_public_methods _ -> 15
  | Unerasable_optional_argument -> 16
  | Undeclared_virtual_method _ -> 17
  | Not_principal _ -> 18
  | Without_principality _ -> 19
  | Unused_argument -> 20
  | Nonreturning_statement -> 21
  | Preprocessor _ -> 22
  | Useless_record_with -> 23
  | Bad_module_name _ -> 24
  | All_clauses_guarded -> 25
  | Unused_var _ -> 26
  | Unused_var_strict _ -> 27
  | Wildcard_arg_to_constant_constr -> 28
  | Eol_in_string -> 29
  | Duplicate_definitions _ -> 30
  | Multiple_definition _ -> 31
  | Unused_value_declaration _ -> 32
  | Unused_open _ -> 33
  | Unused_type_declaration _ -> 34
  | Unused_for_index _ -> 35
  | Unused_ancestor _ -> 36
  | Unused_constructor _ -> 37
  | Unused_extension _ -> 38
  | Unused_rec_flag -> 39
  | Name_out_of_scope _ -> 40
  | Ambiguous_name _ -> 41
  | Disambiguated_name _ -> 42
  | Nonoptional_label _ -> 43
  | Open_shadow_identifier _ -> 44
  | Open_shadow_label_constructor _ -> 45
  | Bad_env_variable _ -> 46
  | Attribute_payload _ -> 47
  | Eliminated_optional_arguments _ -> 48
  | No_cmi_file _ -> 49
  | Bad_docstring _ -> 50

  | Bs_unused_attribute _ -> 101
  | Bs_polymorphic_comparison -> 102
  | Bs_ffi_warning _ -> 103
  | Bs_derive_warning _ -> 104
;;

let last_warning_number = 104
(* Must be the max number returned by the [number] function. *)
let letter_all =
  let rec loop i = if i = 0 then [] else i :: loop (i - 1) in
  loop last_warning_number

let letter = function
  | 'a' ->
    letter_all
  | 'b' -> []
  | 'c' -> [1; 2]
  | 'd' -> [3]
  | 'e' -> [4]
  | 'f' -> [5]
  | 'g' -> []
  | 'h' -> []
  | 'i' -> []
  | 'j' -> []
  | 'k' -> [32; 33; 34; 35; 36; 37; 38; 39]
  | 'l' -> [6]
  | 'm' -> [7]
  | 'n' -> []
  | 'o' -> []
  | 'p' -> [8]
  | 'q' -> []
  | 'r' -> [9]
  | 's' -> [10]
  | 't' -> []
  | 'u' -> [11; 12]
  | 'v' -> [13]
  | 'w' -> []
  | 'x' -> [14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 30]
  | 'y' -> [26]
  | 'z' -> [27]
  | _ -> assert false
;;

type state =
  {
    active: bool array;
    error: bool array;
  }

let current =
  ref
    {
      active = Array.make (last_warning_number + 1) true;
      error = Array.make (last_warning_number + 1) false;
    }

let backup () = !current

let restore x = current := x

let is_active x = (!current).active.(number x);;
let is_error x = (!current).error.(number x);;

let parse_opt error active flags s =
  let set i = flags.(i) <- true in
  let clear i = flags.(i) <- false in
  let set_all i = active.(i) <- true; error.(i) <- true in
  let error () = raise (Arg.Bad "Ill-formed list of warnings") in
  let rec get_num n i =
    if i >= String.length s then i, n
    else match s.[i] with
    | '0'..'9' -> get_num (10 * n + Char.code s.[i] - Char.code '0') (i + 1)
    | _ -> i, n
  in
  let get_range i =
    let i, n1 = get_num 0 i in
    if i + 2 < String.length s && s.[i] = '.' && s.[i + 1] = '.' then
      let i, n2 = get_num 0 (i + 2) in
      if n2 < n1 then error ();
      i, n1, n2
    else
      i, n1, n1
  in
  let rec loop i =
    if i >= String.length s then () else
    match s.[i] with
    | 'A' .. 'Z' ->
       List.iter set (letter (Char.lowercase_ascii s.[i]));
       loop (i+1)
    | 'a' .. 'z' ->
       List.iter clear (letter s.[i]);
       loop (i+1)
    | '+' -> loop_letter_num set (i+1)
    | '-' -> loop_letter_num clear (i+1)
    | '@' -> loop_letter_num set_all (i+1)
    | c -> error ()
  and loop_letter_num myset i =
    if i >= String.length s then error () else
    match s.[i] with
    | '0' .. '9' ->
        let i, n1, n2 = get_range i in
        for n = n1 to min n2 last_warning_number do myset n done;
        loop i
    | 'A' .. 'Z' ->
       List.iter myset (letter (Char.lowercase_ascii s.[i]));
       loop (i+1)
    | 'a' .. 'z' ->
       List.iter myset (letter s.[i]);
       loop (i+1)
    | _ -> error ()
  in
  loop 0
;;

let parse_options errflag s =
  let error = Array.copy (!current).error in
  let active = Array.copy (!current).active in
  parse_opt error active (if errflag then error else active) s;
  current := {error; active}

(* If you change these, don't forget to change them in man/ocamlc.m *)
let defaults_w = "+a-4-6-7-9-27-29-32..39-41..42-44-45-48-50-102";;
let defaults_warn_error = "-a";;

let () = parse_options false defaults_w;;
let () = parse_options true defaults_warn_error;;

let message = function
  | Comment_start -> "this is the start of a comment."
  | Comment_not_end -> "this is not the end of a comment."
  | Deprecated s -> "deprecated: " ^ s
  | Fragile_match "" ->
      "this pattern-matching is fragile."
  | Fragile_match s ->
      "this pattern-matching is fragile.\n\
       It will remain exhaustive when constructors are added to type " ^ s ^ "."
  | Partial_application ->
      "this function application is partial,\n\
       maybe some arguments are missing."
  | Labels_omitted ->
      "labels were omitted in the application of this function."
  | Method_override [lab] ->
      "the method " ^ lab ^ " is overridden."
  | Method_override (cname :: slist) ->
      String.concat " "
        ("the following methods are overridden by the class"
         :: cname  :: ":\n " :: slist)
  | Method_override [] -> assert false
  | Partial_match "" -> "this pattern-matching is not exhaustive."
  | Partial_match s ->
      "this pattern-matching is not exhaustive.\n\
       Here is an example of a value that is not matched:\n" ^ s
  | Non_closed_record_pattern s ->
      "the following labels are not bound in this record pattern:\n" ^ s ^
      "\nEither bind these labels explicitly or add '; _' to the pattern."
  | Statement_type ->
      "this expression should have type unit."
  | Unused_match -> "this match case is unused."
  | Unused_pat   -> "this sub-pattern is unused."
  | Instance_variable_override [lab] ->
      "the instance variable " ^ lab ^ " is overridden.\n" ^
      "The behaviour changed in ocaml 3.10 (previous behaviour was hiding.)"
  | Instance_variable_override (cname :: slist) ->
      String.concat " "
        ("the following instance variables are overridden by the class"
         :: cname  :: ":\n " :: slist) ^
      "\nThe behaviour changed in ocaml 3.10 (previous behaviour was hiding.)"
  | Instance_variable_override [] -> assert false
  | Illegal_backslash -> "illegal backslash escape in string."
  | Implicit_public_methods l ->
      "the following private methods were made public implicitly:\n "
      ^ String.concat " " l ^ "."
  | Unerasable_optional_argument -> "this optional argument cannot be erased."
  | Undeclared_virtual_method m -> "the virtual method "^m^" is not declared."
  | Not_principal s -> s^" is not principal."
  | Without_principality s -> s^" without principality."
  | Unused_argument -> "this argument will not be used by the function."
  | Nonreturning_statement ->
      "this statement never returns (or has an unsound type.)"
  | Preprocessor s -> s
  | Useless_record_with ->
      "all the fields are explicitly listed in this record:\n\
       the 'with' clause is useless."
  | Bad_module_name (modname) ->
      "bad source file name: \"" ^ modname ^ "\" is not a valid module name."
  | All_clauses_guarded ->
      "bad style, all clauses in this pattern-matching are guarded."
  | Unused_var v | Unused_var_strict v -> "unused variable " ^ v ^ "."
  | Wildcard_arg_to_constant_constr ->
     "wildcard pattern given as argument to a constant constructor"
  | Eol_in_string ->
     "unescaped end-of-line in a string constant (non-portable code)"
  | Duplicate_definitions (kind, cname, tc1, tc2) ->
      Printf.sprintf "the %s %s is defined in both types %s and %s."
        kind cname tc1 tc2
  | Multiple_definition(modname, file1, file2) ->
      Printf.sprintf
        "files %s and %s both define a module named %s"
        file1 file2 modname
  | Unused_value_declaration v -> "unused value " ^ v ^ "."
  | Unused_open s -> "unused open " ^ s ^ "."
  | Unused_type_declaration s -> "unused type " ^ s ^ "."
  | Unused_for_index s -> "unused for-loop index " ^ s ^ "."
  | Unused_ancestor s -> "unused ancestor variable " ^ s ^ "."
  | Unused_constructor (s, false, false) -> "unused constructor " ^ s ^ "."
  | Unused_constructor (s, true, _) ->
      "constructor " ^ s ^
      " is never used to build values.\n\
        (However, this constructor appears in patterns.)"
  | Unused_constructor (s, false, true) ->
      "constructor " ^ s ^
      " is never used to build values.\n\
        Its type is exported as a private type."
  | Unused_extension (s, false, false) ->
      "unused extension constructor " ^ s ^ "."
  | Unused_extension (s, true, _) ->
      "extension constructor " ^ s ^
      " is never used to build values.\n\
        (However, this constructor appears in patterns.)"
  | Unused_extension (s, false, true) ->
      "extension constructor " ^ s ^
      " is never used to build values.\n\
        It is exported or rebound as a private extension."
  | Unused_rec_flag ->
      "unused rec flag."
  | Name_out_of_scope (ty, [nm], false) ->
      nm ^ " was selected from type " ^ ty ^
      ".\nIt is not visible in the current scope, and will not \n\
       be selected if the type becomes unknown."
  | Name_out_of_scope (_, _, false) -> assert false
  | Name_out_of_scope (ty, slist, true) ->
      "this record of type "^ ty ^" contains fields that are \n\
       not visible in the current scope: "
      ^ String.concat " " slist ^ ".\n\
       They will not be selected if the type becomes unknown."
  | Ambiguous_name ([s], tl, false) ->
      s ^ " belongs to several types: " ^ String.concat " " tl ^
      "\nThe first one was selected. Please disambiguate if this is wrong."
  | Ambiguous_name (_, _, false) -> assert false
  | Ambiguous_name (slist, tl, true) ->
      "these field labels belong to several types: " ^
      String.concat " " tl ^
      "\nThe first one was selected. Please disambiguate if this is wrong."
  | Disambiguated_name s ->
      "this use of " ^ s ^ " required disambiguation."
  | Nonoptional_label s ->
      "the label " ^ s ^ " is not optional."
  | Open_shadow_identifier (kind, s) ->
      Printf.sprintf
        "this open statement shadows the %s identifier %s (which is later used)"
        kind s
  | Open_shadow_label_constructor (kind, s) ->
      Printf.sprintf
        "this open statement shadows the %s %s (which is later used)"
        kind s
  | Bad_env_variable (var, s) ->
      Printf.sprintf "illegal environment variable %s : %s" var s
  | Attribute_payload (a, s) ->
      Printf.sprintf "illegal payload for attribute '%s'.\n%s" a s
  | Eliminated_optional_arguments sl ->
      Printf.sprintf "implicit elimination of optional argument%s %s"
        (if List.length sl = 1 then "" else "s")
        (String.concat ", " sl)
  | No_cmi_file s ->
      "no cmi file was found in path for module " ^ s
  | Bad_docstring unattached ->
      if unattached then "unattached documentation comment (ignored)"
      else "ambiguous documentation comment"
  | Bs_unused_attribute s ->
      "Unused BuckleScript attribute: " ^ s
  | Bs_polymorphic_comparison ->
      "polymorphic comparison introduced (maybe unsafe)"
  | Bs_ffi_warning s ->
      "BuckleScript FFI warning: " ^ s
  | Bs_derive_warning s ->
      "BuckleScript bs.deriving warning: " ^ s
;;

let nerrors = ref 0;;

let print ppf w =
  let msg = message w in
  let num = number w in
  Format.fprintf ppf "%d: %s" num msg;
  Format.pp_print_flush ppf ();
  if (!current).error.(num) then incr nerrors
;;


(* used by super-errors. Copied from the `print` above *)
let super_print message ppf w =
  let msg = message w in
  let num = number w in
  Format.fprintf ppf "%s" msg;
  Format.pp_print_flush ppf ();
  if (!current).error.(num) then incr nerrors
;;


exception Errors of int;;

let check_fatal () =
  if !nerrors > 0 then begin
    let e = Errors !nerrors in
    nerrors := 0;
    raise e;
  end;
;;

let descriptions =
  [
    1, "Suspicious-looking start-of-comment mark.";
    2, "Suspicious-looking end-of-comment mark.";
    3, "Deprecated feature.";
    4, "Fragile pattern matching: matching that will remain complete even\n\
   \    if additional constructors are added to one of the variant types\n\
   \    matched.";
    5, "Partially applied function: expression whose result has function\n\
   \    type and is ignored.";
    6, "Label omitted in function application.";
    7, "Method overridden.";
    8, "Partial match: missing cases in pattern-matching.";
    9, "Missing fields in a record pattern.";
   10, "Expression on the left-hand side of a sequence that doesn't have type\n\
   \    \"unit\" (and that is not a function, see warning number 5).";
   11, "Redundant case in a pattern matching (unused match case).";
   12, "Redundant sub-pattern in a pattern-matching.";
   13, "Instance variable overridden.";
   14, "Illegal backslash escape in a string constant.";
   15, "Private method made public implicitly.";
   16, "Unerasable optional argument.";
   17, "Undeclared virtual method.";
   18, "Non-principal type.";
   19, "Type without principality.";
   20, "Unused function argument.";
   21, "Non-returning statement.";
   22, "Proprocessor warning.";
   23, "Useless record \"with\" clause.";
   24, "Bad module name: the source file name is not a valid OCaml module \
        name.";
   25, "Pattern-matching with all clauses guarded.  Exhaustiveness cannot be\n\
   \    checked.";
   26, "Suspicious unused variable: unused variable that is bound\n\
   \    with \"let\" or \"as\", and doesn't start with an underscore (\"_\")\n\
   \    character.";
   27, "Innocuous unused variable: unused variable that is not bound with\n\
   \    \"let\" nor \"as\", and doesn't start with an underscore (\"_\")\n\
   \    character.";
   28, "Wildcard pattern given as argument to a constant constructor.";
   29, "Unescaped end-of-line in a string constant (non-portable code).";
   30, "Two labels or constructors of the same name are defined in two\n\
   \    mutually recursive types.";
   31, "A module is linked twice in the same executable.";
   32, "Unused value declaration.";
   33, "Unused open statement.";
   34, "Unused type declaration.";
   35, "Unused for-loop index.";
   36, "Unused ancestor variable.";
   37, "Unused constructor.";
   38, "Unused extension constructor.";
   39, "Unused rec flag.";
   40, "Constructor or label name used out of scope.";
   41, "Ambiguous constructor or label name.";
   42, "Disambiguated constructor or label name.";
   43, "Nonoptional label applied as optional.";
   44, "Open statement shadows an already defined identifier.";
   45, "Open statement shadows an already defined label or constructor.";
   46, "Error in environment variable.";
   47, "Illegal attribute payload.";
   48, "Implicit elimination of optional arguments.";
   49, "Missing cmi file when looking up module alias.";
   50, "Unexpected documentation comment.";
   101,"Unused bs attributes";
  ]
;;

let help_warnings () =
  List.iter (fun (i, s) -> Printf.printf "%3i %s\n" i s) descriptions;
  print_endline "  A all warnings";
  for i = Char.code 'b' to Char.code 'z' do
    let c = Char.chr i in
    match letter c with
    | [] -> ()
    | [n] ->
        Printf.printf "  %c warning %i\n" (Char.uppercase_ascii c) n
    | l ->
        Printf.printf "  %c warnings %s.\n"
          (Char.uppercase_ascii c)
          (String.concat ", " (List.map string_of_int l))
  done;
  exit 0
;;

end
module Location : sig
(*#1 "location.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Source code locations (ranges of positions), used in parsetree. *)

open Format

type t = {
  loc_start: Lexing.position;
  loc_end: Lexing.position;
  loc_ghost: bool;
}

(* Note on the use of Lexing.position in this module.
   If [pos_fname = ""], then use [!input_name] instead.
   If [pos_lnum = -1], then [pos_bol = 0]. Use [pos_cnum] and
     re-parse the file to get the line and character numbers.
   Else all fields are correct.
*)

val none : t
(** An arbitrary value of type [t]; describes an empty ghost range. *)

val in_file : string -> t
(** Return an empty ghost range located in a given file. *)

val init : Lexing.lexbuf -> string -> unit
(** Set the file name and line number of the [lexbuf] to be the start
    of the named file. *)

val curr : Lexing.lexbuf -> t
(** Get the location of the current token from the [lexbuf]. *)

val symbol_rloc: unit -> t
val symbol_gloc: unit -> t

(** [rhs_loc n] returns the location of the symbol at position [n], starting
  at 1, in the current parser rule. *)
val rhs_loc: int -> t

val input_name: string ref
val input_lexbuf: Lexing.lexbuf option ref

val get_pos_info: Lexing.position -> string * int * int (* file, line, char *)
val print_loc: formatter -> t -> unit
val print_error: formatter -> t -> unit
val print_error_cur_file: formatter -> unit -> unit
val print_warning: t -> formatter -> Warnings.t -> unit
val formatter_for_warnings : formatter ref
val prerr_warning: t -> Warnings.t -> unit
val echo_eof: unit -> unit
val reset: unit -> unit

val warning_printer : (t -> formatter -> Warnings.t -> unit) ref
(** Hook for intercepting warnings. *)

val default_warning_printer : t -> formatter -> Warnings.t -> unit
(** Original warning printer for use in hooks. *)

val highlight_locations: formatter -> t list -> bool

type 'a loc = {
  txt : 'a;
  loc : t;
}

val mknoloc : 'a -> 'a loc
val mkloc : 'a -> t -> 'a loc

val print: formatter -> t -> unit
val print_filename: formatter -> string -> unit

val absolute_path: string -> string

val show_filename: string -> string
    (** In -absname mode, return the absolute path for this filename.
        Otherwise, returns the filename unchanged. *)


val absname: bool ref

(* Support for located errors *)

type error =
  {
    loc: t;
    msg: string;
    sub: error list;
    if_highlight: string; (* alternative message if locations are highlighted *)
  }

exception Error of error

val print_error_prefix: formatter -> unit -> unit
  (* print the prefix "Error:" possibly with style *)

val error: ?loc:t -> ?sub:error list -> ?if_highlight:string -> string -> error


val pp_ksprintf : ?before:(formatter -> unit) -> (string -> 'a) -> ('b, formatter, unit, 'a) format4 -> 'b


val errorf: ?loc:t -> ?sub:error list -> ?if_highlight:string
            -> ('a, Format.formatter, unit, error) format4 -> 'a

val raise_errorf: ?loc:t -> ?sub:error list -> ?if_highlight:string
            -> ('a, Format.formatter, unit, 'b) format4 -> 'a

val error_of_printer: t -> (formatter -> 'a -> unit) -> 'a -> error

val error_of_printer_file: (formatter -> 'a -> unit) -> 'a -> error

val error_of_exn: exn -> error option

val register_error_of_exn: (exn -> error option) -> unit
  (* Each compiler module which defines a custom type of exception
     which can surface as a user-visible error should register
     a "printer" for this exception using [register_error_of_exn].
     The result of the printer is an [error] value containing
     a location, a message, and optionally sub-messages (each of them
     being located as well). *)

val report_error: formatter -> error -> unit

val error_reporter : (formatter -> error -> unit) ref
(** Hook for intercepting error reports. *)

val default_error_reporter : formatter -> error -> unit
(** Original error reporter for use in hooks. *)

val report_exception: formatter -> exn -> unit
  (* Reraise the exception if it is unknown. *)

end = struct
(*#1 "location.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Lexing

let absname = ref false
    (* This reference should be in Clflags, but it would create an additional
       dependency and make bootstrapping Camlp4 more difficult. *)

type t = { loc_start: position; loc_end: position; loc_ghost: bool };;

let in_file name =
  let loc = {
    pos_fname = name;
    pos_lnum = 1;
    pos_bol = 0;
    pos_cnum = -1;
  } in
  { loc_start = loc; loc_end = loc; loc_ghost = true }
;;

let none = in_file "_none_";;

let curr lexbuf = {
  loc_start = lexbuf.lex_start_p;
  loc_end = lexbuf.lex_curr_p;
  loc_ghost = false
};;

let init lexbuf fname =
  lexbuf.lex_curr_p <- {
    pos_fname = fname;
    pos_lnum = 1;
    pos_bol = 0;
    pos_cnum = 0;
  }
;;

let symbol_rloc () = {
  loc_start = Parsing.symbol_start_pos ();
  loc_end = Parsing.symbol_end_pos ();
  loc_ghost = false;
};;

let symbol_gloc () = {
  loc_start = Parsing.symbol_start_pos ();
  loc_end = Parsing.symbol_end_pos ();
  loc_ghost = true;
};;

let rhs_loc n = {
  loc_start = Parsing.rhs_start_pos n;
  loc_end = Parsing.rhs_end_pos n;
  loc_ghost = false;
};;

let input_name = ref "_none_"
let input_lexbuf = ref (None : lexbuf option)

(* Terminal info *)

let status = ref Terminfo.Uninitialised

let num_loc_lines = ref 0 (* number of lines already printed after input *)

let print_updating_num_loc_lines ppf f arg =
  let open Format in
  let out_functions = pp_get_formatter_out_functions ppf () in
  let out_string str start len =
    let rec count i c =
      if i = start + len then c
      else if String.get str i = '\n' then count (succ i) (succ c)
      else count (succ i) c in
    num_loc_lines := !num_loc_lines + count start 0 ;
    out_functions.out_string str start len in
  pp_set_formatter_out_functions ppf
    { out_functions with out_string } ;
  f ppf arg ;
  pp_print_flush ppf ();
  pp_set_formatter_out_functions ppf out_functions

(* Highlight the locations using standout mode. *)

let highlight_terminfo ppf num_lines lb locs =
  Format.pp_print_flush ppf ();  (* avoid mixing Format and normal output *)
  (* Char 0 is at offset -lb.lex_abs_pos in lb.lex_buffer. *)
  let pos0 = -lb.lex_abs_pos in
  (* Do nothing if the buffer does not contain the whole phrase. *)
  if pos0 < 0 then raise Exit;
  (* Count number of lines in phrase *)
  let lines = ref !num_loc_lines in
  for i = pos0 to lb.lex_buffer_len - 1 do
    if Bytes.get lb.lex_buffer i = '\n' then incr lines
  done;
  (* If too many lines, give up *)
  if !lines >= num_lines - 2 then raise Exit;
  (* Move cursor up that number of lines *)
  flush stdout; Terminfo.backup !lines;
  (* Print the input, switching to standout for the location *)
  let bol = ref false in
  print_string "# ";
  for pos = 0 to lb.lex_buffer_len - pos0 - 1 do
    if !bol then (print_string "  "; bol := false);
    if List.exists (fun loc -> pos = loc.loc_start.pos_cnum) locs then
      Terminfo.standout true;
    if List.exists (fun loc -> pos = loc.loc_end.pos_cnum) locs then
      Terminfo.standout false;
    let c = Bytes.get lb.lex_buffer (pos + pos0) in
    print_char c;
    bol := (c = '\n')
  done;
  (* Make sure standout mode is over *)
  Terminfo.standout false;
  (* Position cursor back to original location *)
  Terminfo.resume !num_loc_lines;
  flush stdout

(* Highlight the location by printing it again. *)

let highlight_dumb ppf lb loc =
  (* Char 0 is at offset -lb.lex_abs_pos in lb.lex_buffer. *)
  let pos0 = -lb.lex_abs_pos in
  (* Do nothing if the buffer does not contain the whole phrase. *)
  if pos0 < 0 then raise Exit;
  let end_pos = lb.lex_buffer_len - pos0 - 1 in
  (* Determine line numbers for the start and end points *)
  let line_start = ref 0 and line_end = ref 0 in
  for pos = 0 to end_pos do
    if Bytes.get lb.lex_buffer (pos + pos0) = '\n' then begin
      if loc.loc_start.pos_cnum > pos then incr line_start;
      if loc.loc_end.pos_cnum   > pos then incr line_end;
    end
  done;
  (* Print character location (useful for Emacs) *)
  Format.fprintf ppf "Characters %i-%i:@."
                 loc.loc_start.pos_cnum loc.loc_end.pos_cnum;
  (* Print the input, underlining the location *)
  Format.pp_print_string ppf "  ";
  let line = ref 0 in
  let pos_at_bol = ref 0 in
  for pos = 0 to end_pos do
    match Bytes.get lb.lex_buffer (pos + pos0) with
    | '\n' ->
      if !line = !line_start && !line = !line_end then begin
        (* loc is on one line: underline location *)
        Format.fprintf ppf "@.  ";
        for _i = !pos_at_bol to loc.loc_start.pos_cnum - 1 do
          Format.pp_print_char ppf ' '
        done;
        for _i = loc.loc_start.pos_cnum to loc.loc_end.pos_cnum - 1 do
          Format.pp_print_char ppf '^'
        done
      end;
      if !line >= !line_start && !line <= !line_end then begin
        Format.fprintf ppf "@.";
        if pos < loc.loc_end.pos_cnum then Format.pp_print_string ppf "  "
      end;
      incr line;
      pos_at_bol := pos + 1
    | '\r' -> () (* discard *)
    | c ->
      if !line = !line_start && !line = !line_end then
        (* loc is on one line: print whole line *)
        Format.pp_print_char ppf c
      else if !line = !line_start then
        (* first line of multiline loc:
           print a dot for each char before loc_start *)
        if pos < loc.loc_start.pos_cnum then
          Format.pp_print_char ppf '.'
        else
          Format.pp_print_char ppf c
      else if !line = !line_end then
        (* last line of multiline loc: print a dot for each char
           after loc_end, even whitespaces *)
        if pos < loc.loc_end.pos_cnum then
          Format.pp_print_char ppf c
        else
          Format.pp_print_char ppf '.'
      else if !line > !line_start && !line < !line_end then
        (* intermediate line of multiline loc: print whole line *)
        Format.pp_print_char ppf c
  done

(* Highlight the location using one of the supported modes. *)

let rec highlight_locations ppf locs =
  match !status with
    Terminfo.Uninitialised ->
      status := Terminfo.setup stdout; highlight_locations ppf locs
  | Terminfo.Bad_term ->
      begin match !input_lexbuf with
        None -> false
      | Some lb ->
          let norepeat =
            try Sys.getenv "TERM" = "norepeat" with Not_found -> false in
          if norepeat then false else
            let loc1 = List.hd locs in
            try highlight_dumb ppf lb loc1; true
            with Exit -> false
      end
  | Terminfo.Good_term num_lines ->
      begin match !input_lexbuf with
        None -> false
      | Some lb ->
          try highlight_terminfo ppf num_lines lb locs; true
          with Exit -> false
      end

(* Print the location in some way or another *)

open Format

let absolute_path s = (* This function could go into Filename *)
  let open Filename in
  let s = if is_relative s then concat (Sys.getcwd ()) s else s in
  (* Now simplify . and .. components *)
  let rec aux s =
    let base = basename s in
    let dir = dirname s in
    if dir = s then dir
    else if base = current_dir_name then aux dir
    else if base = parent_dir_name then dirname (aux dir)
    else concat (aux dir) base
  in
  aux s

let show_filename file =
  if !absname then absolute_path file else file

let print_filename ppf file =
  Format.fprintf ppf "%s" (show_filename file)

let reset () =
  num_loc_lines := 0

let (msg_file, msg_line, msg_chars, msg_to, msg_colon) =
  ("File \"", "\", line ", ", characters ", "-", ":")

(* return file, line, char from the given position *)
let get_pos_info pos =
  (pos.pos_fname, pos.pos_lnum, pos.pos_cnum - pos.pos_bol)
;;

let setup_colors () =
  Misc.Color.setup !Clflags.color

let print_loc ppf loc =
  setup_colors ();
  let (file, line, startchar) = get_pos_info loc.loc_start in

  let startchar =
    if Clflags.bs_vscode then startchar + 1 else startchar in

  let endchar = loc.loc_end.pos_cnum - loc.loc_start.pos_cnum + startchar in
  if file = "//toplevel//" then begin
    if highlight_locations ppf [loc] then () else
      fprintf ppf "Characters %i-%i"
              loc.loc_start.pos_cnum loc.loc_end.pos_cnum
  end else begin
    fprintf ppf "%s@{<loc>%a%s%i" msg_file print_filename file msg_line line;
    if startchar >= 0 then
      fprintf ppf "%s%i%s%i" msg_chars startchar msg_to endchar;
    fprintf ppf "@}"
  end
;;

let print ppf loc =
  setup_colors ();
  if loc.loc_start.pos_fname = "//toplevel//"
  && highlight_locations ppf [loc] then ()
  else fprintf ppf "@{<loc>%a@}%s@." print_loc loc msg_colon
;;

let error_prefix = "Error"
let warning_prefix = "Warning"

let print_error_prefix ppf () =
  setup_colors ();
  fprintf ppf "@{<error>%s@}:" error_prefix;
  ()
;;

let print_error ppf loc =
  print ppf loc;
  print_error_prefix ppf ()
;;

let print_error_cur_file ppf () = print_error ppf (in_file !input_name);;

let default_warning_printer loc ppf w =
  if Warnings.is_active w then begin
    setup_colors ();
    print ppf loc;
    fprintf ppf "@{<warning>%s@} %a@." warning_prefix Warnings.print w
  end
;;

let warning_printer = ref default_warning_printer ;;

let print_warning loc ppf w =
  print_updating_num_loc_lines ppf (!warning_printer loc) w
;;

let formatter_for_warnings = ref err_formatter;;
let prerr_warning loc w = print_warning loc !formatter_for_warnings w;;

let echo_eof () =
  print_newline ();
  incr num_loc_lines

type 'a loc = {
  txt : 'a;
  loc : t;
}

let mkloc txt loc = { txt ; loc }
let mknoloc txt = mkloc txt none


type error =
  {
    loc: t;
    msg: string;
    sub: error list;
    if_highlight: string; (* alternative message if locations are highlighted *)
  }

let pp_ksprintf ?before k fmt =
  let buf = Buffer.create 64 in
  let ppf = Format.formatter_of_buffer buf in
  Misc.Color.set_color_tag_handling ppf;
  begin match before with
    | None -> ()
    | Some f -> f ppf
  end;
  kfprintf
    (fun _ ->
      pp_print_flush ppf ();
      let msg = Buffer.contents buf in
      k msg)
    ppf fmt

(* Shift the formatter's offset by the length of the error prefix, which
   is always added by the compiler after the message has been formatted *)
let print_phanton_error_prefix ppf =
  Format.pp_print_as ppf (String.length error_prefix + 2 (* ": " *)) ""

let errorf ?(loc = none) ?(sub = []) ?(if_highlight = "") fmt =
  pp_ksprintf
    ~before:print_phanton_error_prefix
    (fun msg -> {loc; msg; sub; if_highlight})
    fmt

let error ?(loc = none) ?(sub = []) ?(if_highlight = "") msg =
  {loc; msg; sub; if_highlight}

let error_of_exn : (exn -> error option) list ref = ref []

let register_error_of_exn f = error_of_exn := f :: !error_of_exn

let error_of_exn exn =
  let rec loop = function
    | [] -> None
    | f :: rest ->
        match f exn with
        | Some _ as r -> r
        | None -> loop rest
  in
  loop !error_of_exn

let rec default_error_reporter ppf ({loc; msg; sub; if_highlight} as err) =
  let highlighted =
    if if_highlight <> "" then
      let rec collect_locs locs {loc; sub; if_highlight; _} =
        List.fold_left collect_locs (loc :: locs) sub
      in
      let locs = collect_locs [] err in
      highlight_locations ppf locs
    else
      false
  in
  if highlighted then
    Format.pp_print_string ppf if_highlight
  else begin
    fprintf ppf "%a%a %s" print loc print_error_prefix () msg;
    List.iter (Format.fprintf ppf "@\n@[<2>%a@]" default_error_reporter) sub
  end

let error_reporter = ref default_error_reporter

let report_error ppf err =
  print_updating_num_loc_lines ppf !error_reporter err
;;

let error_of_printer loc print x =
  errorf ~loc "%a@?" print x

let error_of_printer_file print x =
  error_of_printer (in_file !input_name) print x

let () =
  register_error_of_exn
    (function
      | Sys_error msg ->
          Some (errorf ~loc:(in_file !input_name)
                "I/O error: %s" msg)
      | Warnings.Errors n ->
          Some
            (errorf ~loc:(in_file !input_name)
             "Some fatal warnings were triggered (%d occurrences)" n)
      | _ ->
          None
    )


let rec report_exception_rec n ppf exn =
  try match error_of_exn exn with
  | Some err ->
      fprintf ppf "@[%a@]@." report_error err
  | None -> raise exn
  with exn when n > 0 ->
    report_exception_rec (n-1) ppf exn

let report_exception ppf exn = report_exception_rec 5 ppf exn


exception Error of error

let () =
  register_error_of_exn
    (function
      | Error e -> Some e
      | _ -> None
    )

let raise_errorf ?(loc = none) ?(sub = []) ?(if_highlight = "") =
  pp_ksprintf
    ~before:print_phanton_error_prefix
    (fun msg -> raise (Error ({loc; msg; sub; if_highlight})))

end
(** Interface as module  *)
module Asttypes
= struct
(*#1 "asttypes.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Auxiliary a.s.t. types used by parsetree and typedtree. *)

type constant =
    Const_int of int
  | Const_char of char
  | Const_string of string * string option
  | Const_float of string
  | Const_int32 of int32
  | Const_int64 of int64
  | Const_nativeint of nativeint

type rec_flag = Nonrecursive | Recursive

type direction_flag = Upto | Downto

type private_flag = Private | Public

type mutable_flag = Immutable | Mutable

type virtual_flag = Virtual | Concrete

type override_flag = Override | Fresh

type closed_flag = Closed | Open

type label = string

type 'a loc = 'a Location.loc = {
  txt : 'a;
  loc : Location.t;
}


type variance =
  | Covariant
  | Contravariant
  | Invariant

end
module Ident : sig
(*#1 "ident.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Identifiers (unique names) *)

type t = { stamp: int; name: string; mutable flags: int }

val create: string -> t
val create_persistent: string -> t
val create_predef_exn: string -> t
val rename: t -> t
val name: t -> string
val unique_name: t -> string
val unique_toplevel_name: t -> string
val persistent: t -> bool
val equal: t -> t -> bool
        (* Compare identifiers by name. *)
val same: t -> t -> bool
        (* Compare identifiers by binding location.
           Two identifiers are the same either if they are both
           non-persistent and have been created by the same call to
           [new], or if they are both persistent and have the same
           name. *)
val hide: t -> t
        (* Return an identifier with same name as the given identifier,
           but stamp different from any stamp returned by new.
           When put in a 'a tbl, this identifier can only be looked
           up by name. *)

val make_global: t -> unit
val global: t -> bool
val is_predef_exn: t -> bool

val binding_time: t -> int
val current_time: unit -> int
val set_current_time: int -> unit
val reinit: unit -> unit

val print: Format.formatter -> t -> unit

type 'a tbl
        (* Association tables from identifiers to type 'a. *)

val empty: 'a tbl
val add: t -> 'a -> 'a tbl -> 'a tbl
val find_same: t -> 'a tbl -> 'a
val find_name: string -> 'a tbl -> 'a
val find_all: string -> 'a tbl -> 'a list
val fold_name: (t -> 'a -> 'b -> 'b) -> 'a tbl -> 'b -> 'b
val fold_all: (t -> 'a -> 'b -> 'b) -> 'a tbl -> 'b -> 'b
val iter: (t -> 'a -> unit) -> 'a tbl -> unit


(* Idents for sharing keys *)

val make_key_generator : unit -> (t -> t)

end = struct
(*#1 "ident.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Format

type t = { stamp: int; name: string; mutable flags: int }

let global_flag = 1
let predef_exn_flag = 2

(* A stamp of 0 denotes a persistent identifier *)

let currentstamp = ref 0

let create s =
  incr currentstamp;
  { name = s; stamp = !currentstamp; flags = 0 }

let create_predef_exn s =
  incr currentstamp;
  { name = s; stamp = !currentstamp; flags = predef_exn_flag }

let create_persistent s =
  { name = s; stamp = 0; flags = global_flag }

let rename i =
  incr currentstamp;
  { i with stamp = !currentstamp }

let name i = i.name

let stamp i = i.stamp

let unique_name i = i.name ^ "_" ^ string_of_int i.stamp

let unique_toplevel_name i = i.name ^ "/" ^ string_of_int i.stamp

let persistent i = (i.stamp = 0)

let equal i1 i2 = i1.name = i2.name

let same i1 i2 = i1 = i2
  (* Possibly more efficient version (with a real compiler, at least):
       if i1.stamp <> 0
       then i1.stamp = i2.stamp
       else i2.stamp = 0 && i1.name = i2.name *)

let binding_time i = i.stamp

let current_time() = !currentstamp
let set_current_time t = currentstamp := max !currentstamp t

let reinit_level = ref (-1)

let reinit () =
  if !reinit_level < 0
  then reinit_level := !currentstamp
  else currentstamp := !reinit_level

let hide i =
  { i with stamp = -1 }

let make_global i =
  i.flags <- i.flags lor global_flag

let global i =
  (i.flags land global_flag) <> 0

let is_predef_exn i =
  (i.flags land predef_exn_flag) <> 0

let print ppf i =
  match i.stamp with
  | 0 -> fprintf ppf "%s!" i.name
  | -1 -> fprintf ppf "%s#" i.name
  | n -> fprintf ppf "%s/%i%s" i.name n (if global i then "g" else "")

type 'a tbl =
    Empty
  | Node of 'a tbl * 'a data * 'a tbl * int

and 'a data =
  { ident: t;
    data: 'a;
    previous: 'a data option }

let empty = Empty

(* Inline expansion of height for better speed
 * let height = function
 *     Empty -> 0
 *   | Node(_,_,_,h) -> h
 *)

let mknode l d r =
  let hl = match l with Empty -> 0 | Node(_,_,_,h) -> h
  and hr = match r with Empty -> 0 | Node(_,_,_,h) -> h in
  Node(l, d, r, (if hl >= hr then hl + 1 else hr + 1))

let balance l d r =
  let hl = match l with Empty -> 0 | Node(_,_,_,h) -> h
  and hr = match r with Empty -> 0 | Node(_,_,_,h) -> h in
  if hl > hr + 1 then
    match l with
    | Node (ll, ld, lr, _)
      when (match ll with Empty -> 0 | Node(_,_,_,h) -> h) >=
           (match lr with Empty -> 0 | Node(_,_,_,h) -> h) ->
        mknode ll ld (mknode lr d r)
    | Node (ll, ld, Node(lrl, lrd, lrr, _), _) ->
        mknode (mknode ll ld lrl) lrd (mknode lrr d r)
    | _ -> assert false
  else if hr > hl + 1 then
    match r with
    | Node (rl, rd, rr, _)
      when (match rr with Empty -> 0 | Node(_,_,_,h) -> h) >=
           (match rl with Empty -> 0 | Node(_,_,_,h) -> h) ->
        mknode (mknode l d rl) rd rr
    | Node (Node (rll, rld, rlr, _), rd, rr, _) ->
        mknode (mknode l d rll) rld (mknode rlr rd rr)
    | _ -> assert false
  else
    mknode l d r

let rec add id data = function
    Empty ->
      Node(Empty, {ident = id; data = data; previous = None}, Empty, 1)
  | Node(l, k, r, h) ->
      let c = compare id.name k.ident.name in
      if c = 0 then
        Node(l, {ident = id; data = data; previous = Some k}, r, h)
      else if c < 0 then
        balance (add id data l) k r
      else
        balance l k (add id data r)

let rec find_stamp s = function
    None ->
      raise Not_found
  | Some k ->
      if k.ident.stamp = s then k.data else find_stamp s k.previous

let rec find_same id = function
    Empty ->
      raise Not_found
  | Node(l, k, r, _) ->
      let c = compare id.name k.ident.name in
      if c = 0 then
        if id.stamp = k.ident.stamp
        then k.data
        else find_stamp id.stamp k.previous
      else
        find_same id (if c < 0 then l else r)

let rec find_name name = function
    Empty ->
      raise Not_found
  | Node(l, k, r, _) ->
      let c = compare name k.ident.name in
      if c = 0 then
        k.data
      else
        find_name name (if c < 0 then l else r)

let rec get_all = function
  | None -> []
  | Some k -> k.data :: get_all k.previous

let rec find_all name = function
    Empty ->
      []
  | Node(l, k, r, _) ->
      let c = compare name k.ident.name in
      if c = 0 then
        k.data :: get_all k.previous
      else
        find_all name (if c < 0 then l else r)

let rec fold_aux f stack accu = function
    Empty ->
      begin match stack with
        [] -> accu
      | a :: l -> fold_aux f l accu a
      end
  | Node(l, k, r, _) ->
      fold_aux f (l :: stack) (f k accu) r

let fold_name f tbl accu = fold_aux (fun k -> f k.ident k.data) [] accu tbl

let rec fold_data f d accu =
  match d with
    None -> accu
  | Some k -> f k.ident k.data (fold_data f k.previous accu)

let fold_all f tbl accu =
  fold_aux (fun k -> fold_data f (Some k)) [] accu tbl

(* let keys tbl = fold_name (fun k _ accu -> k::accu) tbl [] *)

let rec iter f = function
    Empty -> ()
  | Node(l, k, r, _) ->
      iter f l; f k.ident k.data; iter f r

(* Idents for sharing keys *)

(* They should be 'totally fresh' -> neg numbers *)
let key_name = ""

let make_key_generator () =
  let c = ref 1 in
  fun id ->
    let stamp = !c in
    decr c ;
    { id with name = key_name; stamp = stamp; }

end
module Path : sig
(*#1 "path.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Access paths *)

type t =
    Pident of Ident.t
  | Pdot of t * string * int
  | Papply of t * t

val same: t -> t -> bool
val isfree: Ident.t -> t -> bool
val binding_time: t -> int

val nopos: int

val name: ?paren:(string -> bool) -> t -> string
    (* [paren] tells whether a path suffix needs parentheses *)
val head: t -> Ident.t

val last: t -> string

end = struct
(*#1 "path.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

type t =
    Pident of Ident.t
  | Pdot of t * string * int
  | Papply of t * t

let nopos = -1

let rec same p1 p2 =
  match (p1, p2) with
    (Pident id1, Pident id2) -> Ident.same id1 id2
  | (Pdot(p1, s1, pos1), Pdot(p2, s2, pos2)) -> s1 = s2 && same p1 p2
  | (Papply(fun1, arg1), Papply(fun2, arg2)) ->
       same fun1 fun2 && same arg1 arg2
  | (_, _) -> false

let rec isfree id = function
    Pident id' -> Ident.same id id'
  | Pdot(p, s, pos) -> isfree id p
  | Papply(p1, p2) -> isfree id p1 || isfree id p2

let rec binding_time = function
    Pident id -> Ident.binding_time id
  | Pdot(p, s, pos) -> binding_time p
  | Papply(p1, p2) -> max (binding_time p1) (binding_time p2)

let kfalse x = false

let rec name ?(paren=kfalse) = function
    Pident id -> Ident.name id
  | Pdot(p, s, pos) ->
      name ~paren p ^ if paren s then ".( " ^ s ^ " )" else "." ^ s
  | Papply(p1, p2) -> name ~paren p1 ^ "(" ^ name ~paren p2 ^ ")"

let rec head = function
    Pident id -> id
  | Pdot(p, s, pos) -> head p
  | Papply(p1, p2) -> assert false

let rec last = function
  | Pident id -> Ident.name id
  | Pdot(_, s, _) -> s
  | Papply(_, p) -> last p

end
module Longident : sig
(*#1 "longident.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Long identifiers, used in parsetree. *)

type t =
    Lident of string
  | Ldot of t * string
  | Lapply of t * t

val flatten: t -> string list
val last: t -> string
val parse: string -> t

end = struct
(*#1 "longident.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

type t =
    Lident of string
  | Ldot of t * string
  | Lapply of t * t

let rec flat accu = function
    Lident s -> s :: accu
  | Ldot(lid, s) -> flat (s :: accu) lid
  | Lapply(_, _) -> Misc.fatal_error "Longident.flat"

let flatten lid = flat [] lid

let last = function
    Lident s -> s
  | Ldot(_, s) -> s
  | Lapply(_, _) -> Misc.fatal_error "Longident.last"

let rec split_at_dots s pos =
  try
    let dot = String.index_from s pos '.' in
    String.sub s pos (dot - pos) :: split_at_dots s (dot + 1)
  with Not_found ->
    [String.sub s pos (String.length s - pos)]

let parse s =
  match split_at_dots s 0 with
    [] -> Lident ""  (* should not happen, but don't put assert false
                        so as not to crash the toplevel (see Genprintval) *)
  | hd :: tl -> List.fold_left (fun p s -> Ldot(p, s)) (Lident hd) tl

end
(** Interface as module  *)
module Parsetree
= struct
(*#1 "parsetree.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(** Abstract syntax tree produced by parsing *)

open Asttypes

(** {2 Extension points} *)

type attribute = string loc * payload
       (* [@id ARG]
          [@@id ARG]

          Metadata containers passed around within the AST.
          The compiler ignores unknown attributes.
       *)

and extension = string loc * payload
      (* [%id ARG]
         [%%id ARG]

         Sub-language placeholder -- rejected by the typechecker.
      *)

and attributes = attribute list

and payload =
  | PStr of structure
  | PTyp of core_type  (* : T *)
  | PPat of pattern * expression option  (* ? P  or  ? P when E *)

(** {2 Core language} *)

(* Type expressions *)

and core_type =
    {
     ptyp_desc: core_type_desc;
     ptyp_loc: Location.t;
     ptyp_attributes: attributes; (* ... [@id1] [@id2] *)
    }

and core_type_desc =
  | Ptyp_any
        (*  _ *)
  | Ptyp_var of string
        (* 'a *)
  | Ptyp_arrow of label * core_type * core_type
        (* T1 -> T2       (label = "")
           ~l:T1 -> T2    (label = "l")
           ?l:T1 -> T2    (label = "?l")
         *)
  | Ptyp_tuple of core_type list
        (* T1 * ... * Tn

           Invariant: n >= 2
        *)
  | Ptyp_constr of Longident.t loc * core_type list
        (* tconstr
           T tconstr
           (T1, ..., Tn) tconstr
         *)
  | Ptyp_object of (string * attributes * core_type) list * closed_flag
        (* < l1:T1; ...; ln:Tn >     (flag = Closed)
           < l1:T1; ...; ln:Tn; .. > (flag = Open)
         *)
  | Ptyp_class of Longident.t loc * core_type list
        (* #tconstr
           T #tconstr
           (T1, ..., Tn) #tconstr
         *)
  | Ptyp_alias of core_type * string
        (* T as 'a *)
  | Ptyp_variant of row_field list * closed_flag * label list option
        (* [ `A|`B ]         (flag = Closed; labels = None)
           [> `A|`B ]        (flag = Open;   labels = None)
           [< `A|`B ]        (flag = Closed; labels = Some [])
           [< `A|`B > `X `Y ](flag = Closed; labels = Some ["X";"Y"])
         *)
  | Ptyp_poly of string list * core_type
        (* 'a1 ... 'an. T

           Can only appear in the following context:

           - As the core_type of a Ppat_constraint node corresponding
             to a constraint on a let-binding: let x : 'a1 ... 'an. T
             = e ...

           - Under Cfk_virtual for methods (not values).

           - As the core_type of a Pctf_method node.

           - As the core_type of a Pexp_poly node.

           - As the pld_type field of a label_declaration.

           - As a core_type of a Ptyp_object node.
         *)

  | Ptyp_package of package_type
        (* (module S) *)
  | Ptyp_extension of extension
        (* [%id] *)

and package_type = Longident.t loc * (Longident.t loc * core_type) list
      (*
        (module S)
        (module S with type t1 = T1 and ... and tn = Tn)
       *)

and row_field =
  | Rtag of label * attributes * bool * core_type list
        (* [`A]                   ( true,  [] )
           [`A of T]              ( false, [T] )
           [`A of T1 & .. & Tn]   ( false, [T1;...Tn] )
           [`A of & T1 & .. & Tn] ( true,  [T1;...Tn] )

          - The 2nd field is true if the tag contains a
            constant (empty) constructor.
          - '&' occurs when several types are used for the same constructor
            (see 4.2 in the manual)

          - TODO: switch to a record representation, and keep location
        *)
  | Rinherit of core_type
        (* [ T ] *)

(* Patterns *)

and pattern =
    {
     ppat_desc: pattern_desc;
     ppat_loc: Location.t;
     ppat_attributes: attributes; (* ... [@id1] [@id2] *)
    }

and pattern_desc =
  | Ppat_any
        (* _ *)
  | Ppat_var of string loc
        (* x *)
  | Ppat_alias of pattern * string loc
        (* P as 'a *)
  | Ppat_constant of constant
        (* 1, 'a', "true", 1.0, 1l, 1L, 1n *)
  | Ppat_interval of constant * constant
        (* 'a'..'z'

           Other forms of interval are recognized by the parser
           but rejected by the type-checker. *)
  | Ppat_tuple of pattern list
        (* (P1, ..., Pn)

           Invariant: n >= 2
        *)
  | Ppat_construct of Longident.t loc * pattern option
        (* C                None
           C P              Some P
           C (P1, ..., Pn)  Some (Ppat_tuple [P1; ...; Pn])
         *)
  | Ppat_variant of label * pattern option
        (* `A             (None)
           `A P           (Some P)
         *)
  | Ppat_record of (Longident.t loc * pattern) list * closed_flag
        (* { l1=P1; ...; ln=Pn }     (flag = Closed)
           { l1=P1; ...; ln=Pn; _}   (flag = Open)

           Invariant: n > 0
         *)
  | Ppat_array of pattern list
        (* [| P1; ...; Pn |] *)
  | Ppat_or of pattern * pattern
        (* P1 | P2 *)
  | Ppat_constraint of pattern * core_type
        (* (P : T) *)
  | Ppat_type of Longident.t loc
        (* #tconst *)
  | Ppat_lazy of pattern
        (* lazy P *)
  | Ppat_unpack of string loc
        (* (module P)
           Note: (module P : S) is represented as
           Ppat_constraint(Ppat_unpack, Ptyp_package)
         *)
  | Ppat_exception of pattern
        (* exception P *)
  | Ppat_extension of extension
        (* [%id] *)

(* Value expressions *)

and expression =
    {
     pexp_desc: expression_desc;
     pexp_loc: Location.t;
     pexp_attributes: attributes; (* ... [@id1] [@id2] *)
    }

and expression_desc =
  | Pexp_ident of Longident.t loc
        (* x
           M.x
         *)
  | Pexp_constant of constant
        (* 1, 'a', "true", 1.0, 1l, 1L, 1n *)
  | Pexp_let of rec_flag * value_binding list * expression
        (* let P1 = E1 and ... and Pn = EN in E       (flag = Nonrecursive)
           let rec P1 = E1 and ... and Pn = EN in E   (flag = Recursive)
         *)
  | Pexp_function of case list
        (* function P1 -> E1 | ... | Pn -> En *)
  | Pexp_fun of label * expression option * pattern * expression
        (* fun P -> E1                          (lab = "", None)
           fun ~l:P -> E1                       (lab = "l", None)
           fun ?l:P -> E1                       (lab = "?l", None)
           fun ?l:(P = E0) -> E1                (lab = "?l", Some E0)

           Notes:
           - If E0 is provided, lab must start with '?'.
           - "fun P1 P2 .. Pn -> E1" is represented as nested Pexp_fun.
           - "let f P = E" is represented using Pexp_fun.
         *)
  | Pexp_apply of expression * (label * expression) list
        (* E0 ~l1:E1 ... ~ln:En
           li can be empty (non labeled argument) or start with '?'
           (optional argument).

           Invariant: n > 0
         *)
  | Pexp_match of expression * case list
        (* match E0 with P1 -> E1 | ... | Pn -> En *)
  | Pexp_try of expression * case list
        (* try E0 with P1 -> E1 | ... | Pn -> En *)
  | Pexp_tuple of expression list
        (* (E1, ..., En)

           Invariant: n >= 2
        *)
  | Pexp_construct of Longident.t loc * expression option
        (* C                None
           C E              Some E
           C (E1, ..., En)  Some (Pexp_tuple[E1;...;En])
        *)
  | Pexp_variant of label * expression option
        (* `A             (None)
           `A E           (Some E)
         *)
  | Pexp_record of (Longident.t loc * expression) list * expression option
        (* { l1=P1; ...; ln=Pn }     (None)
           { E0 with l1=P1; ...; ln=Pn }   (Some E0)

           Invariant: n > 0
         *)
  | Pexp_field of expression * Longident.t loc
        (* E.l *)
  | Pexp_setfield of expression * Longident.t loc * expression
        (* E1.l <- E2 *)
  | Pexp_array of expression list
        (* [| E1; ...; En |] *)
  | Pexp_ifthenelse of expression * expression * expression option
        (* if E1 then E2 else E3 *)
  | Pexp_sequence of expression * expression
        (* E1; E2 *)
  | Pexp_while of expression * expression
        (* while E1 do E2 done *)
  | Pexp_for of
      pattern *  expression * expression * direction_flag * expression
        (* for i = E1 to E2 do E3 done      (flag = Upto)
           for i = E1 downto E2 do E3 done  (flag = Downto)
         *)
  | Pexp_constraint of expression * core_type
        (* (E : T) *)
  | Pexp_coerce of expression * core_type option * core_type
        (* (E :> T)        (None, T)
           (E : T0 :> T)   (Some T0, T)
         *)
  | Pexp_send of expression * string
        (*  E # m *)
  | Pexp_new of Longident.t loc
        (* new M.c *)
  | Pexp_setinstvar of string loc * expression
        (* x <- 2 *)
  | Pexp_override of (string loc * expression) list
        (* {< x1 = E1; ...; Xn = En >} *)
  | Pexp_letmodule of string loc * module_expr * expression
        (* let module M = ME in E *)
  | Pexp_assert of expression
        (* assert E
           Note: "assert false" is treated in a special way by the
           type-checker. *)
  | Pexp_lazy of expression
        (* lazy E *)
  | Pexp_poly of expression * core_type option
        (* Used for method bodies.

           Can only be used as the expression under Cfk_concrete
           for methods (not values). *)
  | Pexp_object of class_structure
        (* object ... end *)
  | Pexp_newtype of string * expression
        (* fun (type t) -> E *)
  | Pexp_pack of module_expr
        (* (module ME)

           (module ME : S) is represented as
           Pexp_constraint(Pexp_pack, Ptyp_package S) *)
  | Pexp_open of override_flag * Longident.t loc * expression
        (* let open M in E
           let! open M in E
        *)
  | Pexp_extension of extension
        (* [%id] *)

and case =   (* (P -> E) or (P when E0 -> E) *)
    {
     pc_lhs: pattern;
     pc_guard: expression option;
     pc_rhs: expression;
    }

(* Value descriptions *)

and value_description =
    {
     pval_name: string loc;
     pval_type: core_type;
     pval_prim: string list;
     pval_attributes: attributes;  (* ... [@@id1] [@@id2] *)
     pval_loc: Location.t;
    }

(*
  val x: T                            (prim = [])
  external x: T = "s1" ... "sn"       (prim = ["s1";..."sn"])

  Note: when used under Pstr_primitive, prim cannot be empty
*)

(* Type declarations *)

and type_declaration =
    {
     ptype_name: string loc;
     ptype_params: (core_type * variance) list;
           (* ('a1,...'an) t; None represents  _*)
     ptype_cstrs: (core_type * core_type * Location.t) list;
           (* ... constraint T1=T1'  ... constraint Tn=Tn' *)
     ptype_kind: type_kind;
     ptype_private: private_flag;   (* = private ... *)
     ptype_manifest: core_type option;  (* = T *)
     ptype_attributes: attributes;   (* ... [@@id1] [@@id2] *)
     ptype_loc: Location.t;
    }

(*
  type t                     (abstract, no manifest)
  type t = T0                (abstract, manifest=T0)
  type t = C of T | ...      (variant,  no manifest)
  type t = T0 = C of T | ... (variant,  manifest=T0)
  type t = {l: T; ...}       (record,   no manifest)
  type t = T0 = {l : T; ...} (record,   manifest=T0)
  type t = ..                (open,     no manifest)
*)

and type_kind =
  | Ptype_abstract
  | Ptype_variant of constructor_declaration list
        (* Invariant: non-empty list *)
  | Ptype_record of label_declaration list
        (* Invariant: non-empty list *)
  | Ptype_open

and label_declaration =
    {
     pld_name: string loc;
     pld_mutable: mutable_flag;
     pld_type: core_type;
     pld_loc: Location.t;
     pld_attributes: attributes; (* l [@id1] [@id2] : T *)
    }

(*  { ...; l: T; ... }            (mutable=Immutable)
    { ...; mutable l: T; ... }    (mutable=Mutable)

    Note: T can be a Ptyp_poly.
*)

and constructor_declaration =
    {
     pcd_name: string loc;
     pcd_args: core_type list;
     pcd_res: core_type option;
     pcd_loc: Location.t;
     pcd_attributes: attributes; (* C [@id1] [@id2] of ... *)
    }
(*
  | C of T1 * ... * Tn     (res = None)
  | C: T0                  (args = [], res = Some T0)
  | C: T1 * ... * Tn -> T0 (res = Some T0)
*)

and type_extension =
    {
     ptyext_path: Longident.t loc;
     ptyext_params: (core_type * variance) list;
     ptyext_constructors: extension_constructor list;
     ptyext_private: private_flag;
     ptyext_attributes: attributes;   (* ... [@@id1] [@@id2] *)
    }
(*
  type t += ...
*)

and extension_constructor =
    {
     pext_name: string loc;
     pext_kind : extension_constructor_kind;
     pext_loc : Location.t;
     pext_attributes: attributes; (* C [@id1] [@id2] of ... *)
    }

and extension_constructor_kind =
    Pext_decl of core_type list * core_type option
      (*
         | C of T1 * ... * Tn     ([T1; ...; Tn], None)
         | C: T0                  ([], Some T0)
         | C: T1 * ... * Tn -> T0 ([T1; ...; Tn], Some T0)
       *)
  | Pext_rebind of Longident.t loc
      (*
         | C = D
       *)

(** {2 Class language} *)

(* Type expressions for the class language *)

and class_type =
    {
     pcty_desc: class_type_desc;
     pcty_loc: Location.t;
     pcty_attributes: attributes; (* ... [@id1] [@id2] *)
    }

and class_type_desc =
  | Pcty_constr of Longident.t loc * core_type list
        (* c
           ['a1, ..., 'an] c *)
  | Pcty_signature of class_signature
        (* object ... end *)
  | Pcty_arrow of label * core_type * class_type
        (* T -> CT       (label = "")
           ~l:T -> CT    (label = "l")
           ?l:T -> CT    (label = "?l")
         *)
  | Pcty_extension of extension
        (* [%id] *)

and class_signature =
    {
     pcsig_self: core_type;
     pcsig_fields: class_type_field list;
    }
(* object('selfpat) ... end
   object ... end             (self = Ptyp_any)
 *)

and class_type_field =
    {
     pctf_desc: class_type_field_desc;
     pctf_loc: Location.t;
     pctf_attributes: attributes; (* ... [@@id1] [@@id2] *)
    }

and class_type_field_desc =
  | Pctf_inherit of class_type
        (* inherit CT *)
  | Pctf_val of (string * mutable_flag * virtual_flag * core_type)
        (* val x: T *)
  | Pctf_method  of (string * private_flag * virtual_flag * core_type)
        (* method x: T

           Note: T can be a Ptyp_poly.
         *)
  | Pctf_constraint  of (core_type * core_type)
        (* constraint T1 = T2 *)
  | Pctf_attribute of attribute
        (* [@@@id] *)
  | Pctf_extension of extension
        (* [%%id] *)

and 'a class_infos =
    {
     pci_virt: virtual_flag;
     pci_params: (core_type * variance) list;
     pci_name: string loc;
     pci_expr: 'a;
     pci_loc: Location.t;
     pci_attributes: attributes;  (* ... [@@id1] [@@id2] *)
    }
(* class c = ...
   class ['a1,...,'an] c = ...
   class virtual c = ...

   Also used for "class type" declaration.
*)

and class_description = class_type class_infos

and class_type_declaration = class_type class_infos

(* Value expressions for the class language *)

and class_expr =
    {
     pcl_desc: class_expr_desc;
     pcl_loc: Location.t;
     pcl_attributes: attributes; (* ... [@id1] [@id2] *)
    }

and class_expr_desc =
  | Pcl_constr of Longident.t loc * core_type list
        (* c
           ['a1, ..., 'an] c *)
  | Pcl_structure of class_structure
        (* object ... end *)
  | Pcl_fun of label * expression option * pattern * class_expr
        (* fun P -> CE                          (lab = "", None)
           fun ~l:P -> CE                       (lab = "l", None)
           fun ?l:P -> CE                       (lab = "?l", None)
           fun ?l:(P = E0) -> CE                (lab = "?l", Some E0)
         *)
  | Pcl_apply of class_expr * (label * expression) list
        (* CE ~l1:E1 ... ~ln:En
           li can be empty (non labeled argument) or start with '?'
           (optional argument).

           Invariant: n > 0
         *)
  | Pcl_let of rec_flag * value_binding list * class_expr
        (* let P1 = E1 and ... and Pn = EN in CE      (flag = Nonrecursive)
           let rec P1 = E1 and ... and Pn = EN in CE  (flag = Recursive)
         *)
  | Pcl_constraint of class_expr * class_type
        (* (CE : CT) *)
  | Pcl_extension of extension
        (* [%id] *)

and class_structure =
    {
     pcstr_self: pattern;
     pcstr_fields: class_field list;
    }
(* object(selfpat) ... end
   object ... end           (self = Ppat_any)
 *)

and class_field =
    {
     pcf_desc: class_field_desc;
     pcf_loc: Location.t;
     pcf_attributes: attributes; (* ... [@@id1] [@@id2] *)
    }

and class_field_desc =
  | Pcf_inherit of override_flag * class_expr * string option
        (* inherit CE
           inherit CE as x
           inherit! CE
           inherit! CE as x
         *)
  | Pcf_val of (string loc * mutable_flag * class_field_kind)
        (* val x = E
           val virtual x: T
         *)
  | Pcf_method of (string loc * private_flag * class_field_kind)
        (* method x = E            (E can be a Pexp_poly)
           method virtual x: T     (T can be a Ptyp_poly)
         *)
  | Pcf_constraint of (core_type * core_type)
        (* constraint T1 = T2 *)
  | Pcf_initializer of expression
        (* initializer E *)
  | Pcf_attribute of attribute
        (* [@@@id] *)
  | Pcf_extension of extension
        (* [%%id] *)

and class_field_kind =
  | Cfk_virtual of core_type
  | Cfk_concrete of override_flag * expression

and class_declaration = class_expr class_infos

(** {2 Module language} *)

(* Type expressions for the module language *)

and module_type =
    {
     pmty_desc: module_type_desc;
     pmty_loc: Location.t;
     pmty_attributes: attributes; (* ... [@id1] [@id2] *)
    }

and module_type_desc =
  | Pmty_ident of Longident.t loc
        (* S *)
  | Pmty_signature of signature
        (* sig ... end *)
  | Pmty_functor of string loc * module_type option * module_type
        (* functor(X : MT1) -> MT2 *)
  | Pmty_with of module_type * with_constraint list
        (* MT with ... *)
  | Pmty_typeof of module_expr
        (* module type of ME *)
  | Pmty_extension of extension
        (* [%id] *)
  | Pmty_alias of Longident.t loc
        (* (module M) *)

and signature = signature_item list

and signature_item =
    {
     psig_desc: signature_item_desc;
     psig_loc: Location.t;
    }

and signature_item_desc =
  | Psig_value of value_description
        (*
          val x: T
          external x: T = "s1" ... "sn"
         *)
  | Psig_type of type_declaration list
        (* type t1 = ... and ... and tn = ... *)
  | Psig_typext of type_extension
        (* type t1 += ... *)
  | Psig_exception of extension_constructor
        (* exception C of T *)
  | Psig_module of module_declaration
        (* module X : MT *)
  | Psig_recmodule of module_declaration list
        (* module rec X1 : MT1 and ... and Xn : MTn *)
  | Psig_modtype of module_type_declaration
        (* module type S = MT
           module type S *)
  | Psig_open of open_description
        (* open X *)
  | Psig_include of include_description
        (* include MT *)
  | Psig_class of class_description list
        (* class c1 : ... and ... and cn : ... *)
  | Psig_class_type of class_type_declaration list
        (* class type ct1 = ... and ... and ctn = ... *)
  | Psig_attribute of attribute
        (* [@@@id] *)
  | Psig_extension of extension * attributes
        (* [%%id] *)

and module_declaration =
    {
     pmd_name: string loc;
     pmd_type: module_type;
     pmd_attributes: attributes; (* ... [@@id1] [@@id2] *)
     pmd_loc: Location.t;
    }
(* S : MT *)

and module_type_declaration =
    {
     pmtd_name: string loc;
     pmtd_type: module_type option;
     pmtd_attributes: attributes; (* ... [@@id1] [@@id2] *)
     pmtd_loc: Location.t;
    }
(* S = MT
   S       (abstract module type declaration, pmtd_type = None)
*)

and open_description =
    {
     popen_lid: Longident.t loc;
     popen_override: override_flag;
     popen_loc: Location.t;
     popen_attributes: attributes;
    }
(* open! X - popen_override = Override (silences the 'used identifier
                              shadowing' warning)
   open  X - popen_override = Fresh
 *)

and 'a include_infos =
    {
     pincl_mod: 'a;
     pincl_loc: Location.t;
     pincl_attributes: attributes;
    }

and include_description = module_type include_infos
(* include MT *)

and include_declaration = module_expr include_infos
(* include ME *)

and with_constraint =
  | Pwith_type of Longident.t loc * type_declaration
        (* with type X.t = ...

           Note: the last component of the longident must match
           the name of the type_declaration. *)
  | Pwith_module of Longident.t loc * Longident.t loc
        (* with module X.Y = Z *)
  | Pwith_typesubst of type_declaration
        (* with type t := ... *)
  | Pwith_modsubst of string loc * Longident.t loc
        (* with module X := Z *)

(* Value expressions for the module language *)

and module_expr =
    {
     pmod_desc: module_expr_desc;
     pmod_loc: Location.t;
     pmod_attributes: attributes; (* ... [@id1] [@id2] *)
    }

and module_expr_desc =
  | Pmod_ident of Longident.t loc
        (* X *)
  | Pmod_structure of structure
        (* struct ... end *)
  | Pmod_functor of string loc * module_type option * module_expr
        (* functor(X : MT1) -> ME *)
  | Pmod_apply of module_expr * module_expr
        (* ME1(ME2) *)
  | Pmod_constraint of module_expr * module_type
        (* (ME : MT) *)
  | Pmod_unpack of expression
        (* (val E) *)
  | Pmod_extension of extension
        (* [%id] *)

and structure = structure_item list

and structure_item =
    {
     pstr_desc: structure_item_desc;
     pstr_loc: Location.t;
    }

and structure_item_desc =
  | Pstr_eval of expression * attributes
        (* E *)
  | Pstr_value of rec_flag * value_binding list
        (* let P1 = E1 and ... and Pn = EN       (flag = Nonrecursive)
           let rec P1 = E1 and ... and Pn = EN   (flag = Recursive)
         *)
  | Pstr_primitive of value_description
        (* external x: T = "s1" ... "sn" *)
  | Pstr_type of type_declaration list
        (* type t1 = ... and ... and tn = ... *)
  | Pstr_typext of type_extension
        (* type t1 += ... *)
  | Pstr_exception of extension_constructor
        (* exception C of T
           exception C = M.X *)
  | Pstr_module of module_binding
        (* module X = ME *)
  | Pstr_recmodule of module_binding list
        (* module rec X1 = ME1 and ... and Xn = MEn *)
  | Pstr_modtype of module_type_declaration
        (* module type S = MT *)
  | Pstr_open of open_description
        (* open X *)
  | Pstr_class of class_declaration list
        (* class c1 = ... and ... and cn = ... *)
  | Pstr_class_type of class_type_declaration list
        (* class type ct1 = ... and ... and ctn = ... *)
  | Pstr_include of include_declaration
        (* include ME *)
  | Pstr_attribute of attribute
        (* [@@@id] *)
  | Pstr_extension of extension * attributes
        (* [%%id] *)

and value_binding =
  {
    pvb_pat: pattern;
    pvb_expr: expression;
    pvb_attributes: attributes;
    pvb_loc: Location.t;
  }

and module_binding =
    {
     pmb_name: string loc;
     pmb_expr: module_expr;
     pmb_attributes: attributes;
     pmb_loc: Location.t;
    }
(* X = ME *)

(** {2 Toplevel} *)

(* Toplevel phrases *)

type toplevel_phrase =
  | Ptop_def of structure
  | Ptop_dir of string * directive_argument
     (* #use, #load ... *)

and directive_argument =
  | Pdir_none
  | Pdir_string of string
  | Pdir_int of int
  | Pdir_ident of Longident.t
  | Pdir_bool of bool

end
module Primitive : sig
(*#1 "primitive.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Description of primitive functions *)

type description =
  { prim_name: string;         (* Name of primitive  or C function *)
    prim_arity: int;           (* Number of arguments *)
    prim_alloc: bool;          (* Does it allocates or raise? *)
    prim_native_name: string;  (* Name of C function for the nat. code gen. *)
    prim_native_float: bool }  (* Does the above operate on unboxed floats? *)

val parse_declaration: int -> string list -> description

val description_list: description -> string list

val native_name: description -> string
val byte_name: description -> string

end = struct
(*#1 "primitive.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Description of primitive functions *)

open Misc

type description =
  { prim_name: string;         (* Name of primitive  or C function *)
    prim_arity: int;           (* Number of arguments *)
    prim_alloc: bool;          (* Does it allocates or raise? *)
    prim_native_name: string;  (* Name of C function for the nat. code gen. *)
    prim_native_float: bool }  (* Does the above operate on unboxed floats? *)

let parse_declaration arity decl =
  match decl with
  | name :: "noalloc" :: name2 :: "float" :: _ ->
      {prim_name = name; prim_arity = arity; prim_alloc = false;
       prim_native_name = name2; prim_native_float = true}
  | name :: "noalloc" :: name2 :: _ ->
      {prim_name = name; prim_arity = arity; prim_alloc = false;
       prim_native_name = name2; prim_native_float = false}
  | name :: name2 :: "float" :: _ ->
      {prim_name = name; prim_arity = arity; prim_alloc = true;
       prim_native_name = name2; prim_native_float = true}
  | name :: "noalloc" :: _ ->
      {prim_name = name; prim_arity = arity; prim_alloc = false;
       prim_native_name = ""; prim_native_float = false}
  | name :: name2 :: _ ->
      {prim_name = name; prim_arity = arity; prim_alloc = true;
       prim_native_name = name2; prim_native_float = false}
  | name :: _ ->
      {prim_name = name; prim_arity = arity; prim_alloc = true;
       prim_native_name = ""; prim_native_float = false}
  | [] ->
      fatal_error "Primitive.parse_declaration"

let description_list p =
  let list = [p.prim_name] in
  let list = if not p.prim_alloc then "noalloc" :: list else list in
  let list =
    if p.prim_native_name <> "" then p.prim_native_name :: list else list
  in
  let list = if p.prim_native_float then "float" :: list else list in
  List.rev list

let native_name p =
  if p.prim_native_name <> ""
  then p.prim_native_name
  else p.prim_name

let byte_name p =
  p.prim_name

end
module Types : sig
(*#1 "types.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Representation of types and declarations *)

open Asttypes

(* Type expressions for the core language *)

type type_expr =
  { mutable desc: type_desc;
    mutable level: int;
    mutable id: int }

and type_desc =
    Tvar of string option
  | Tarrow of label * type_expr * type_expr * commutable
  | Ttuple of type_expr list
  | Tconstr of Path.t * type_expr list * abbrev_memo ref
  | Tobject of type_expr * (Path.t * type_expr list) option ref
  | Tfield of string * field_kind * type_expr * type_expr
  | Tnil
  | Tlink of type_expr
  | Tsubst of type_expr         (* for copying *)
  | Tvariant of row_desc
  | Tunivar of string option
  | Tpoly of type_expr * type_expr list
  | Tpackage of Path.t * Longident.t list * type_expr list

and row_desc =
    { row_fields: (label * row_field) list;
      row_more: type_expr;
      row_bound: unit; (* kept for compatibility *)
      row_closed: bool;
      row_fixed: bool;
      row_name: (Path.t * type_expr list) option }

and row_field =
    Rpresent of type_expr option
  | Reither of bool * type_expr list * bool * row_field option ref
        (* 1st true denotes a constant constructor *)
        (* 2nd true denotes a tag in a pattern matching, and
           is erased later *)
  | Rabsent

and abbrev_memo =
    Mnil
  | Mcons of private_flag * Path.t * type_expr * type_expr * abbrev_memo
  | Mlink of abbrev_memo ref

and field_kind =
    Fvar of field_kind option ref
  | Fpresent
  | Fabsent

and commutable =
    Cok
  | Cunknown
  | Clink of commutable ref

module TypeOps : sig
  type t = type_expr
  val compare : t -> t -> int
  val equal : t -> t -> bool
  val hash : t -> int
end

(* Maps of methods and instance variables *)

module Meths : Map.S with type key = string
module Vars  : Map.S with type key = string

(* Value descriptions *)

type value_description =
  { val_type: type_expr;                (* Type of the value *)
    val_kind: value_kind;
    val_loc: Location.t;
    val_attributes: Parsetree.attributes;
   }

and value_kind =
    Val_reg                             (* Regular value *)
  | Val_prim of Primitive.description   (* Primitive *)
  | Val_ivar of mutable_flag * string   (* Instance variable (mutable ?) *)
  | Val_self of (Ident.t * type_expr) Meths.t ref *
                (Ident.t * mutable_flag * virtual_flag * type_expr) Vars.t ref *
                string * type_expr
                                        (* Self *)
  | Val_anc of (string * Ident.t) list * string
                                        (* Ancestor *)
  | Val_unbound                         (* Unbound variable *)

(* Constructor descriptions *)

type constructor_description =
  { cstr_name: string;                  (* Constructor name *)
    cstr_res: type_expr;                (* Type of the result *)
    cstr_existentials: type_expr list;  (* list of existentials *)
    cstr_args: type_expr list;          (* Type of the arguments *)
    cstr_arity: int;                    (* Number of arguments *)
    cstr_tag: constructor_tag;          (* Tag for heap blocks *)
    cstr_consts: int;                   (* Number of constant constructors *)
    cstr_nonconsts: int;                (* Number of non-const constructors *)
    cstr_normal: int;                   (* Number of non generalized constrs *)
    cstr_generalized: bool;             (* Constrained return type? *)
    cstr_private: private_flag;         (* Read-only constructor? *)
    cstr_loc: Location.t;
    cstr_attributes: Parsetree.attributes;
   }

and constructor_tag =
    Cstr_constant of int                (* Constant constructor (an int) *)
  | Cstr_block of int                   (* Regular constructor (a block) *)
  | Cstr_extension of Path.t * bool     (* Extension constructor
                                           true if a constant false if a block*)

(* Record label descriptions *)

type label_description =
  { lbl_name: string;                   (* Short name *)
    lbl_res: type_expr;                 (* Type of the result *)
    lbl_arg: type_expr;                 (* Type of the argument *)
    lbl_mut: mutable_flag;              (* Is this a mutable field? *)
    lbl_pos: int;                       (* Position in block *)
    lbl_all: label_description array;   (* All the labels in this type *)
    lbl_repres: record_representation;  (* Representation for this record *)
    lbl_private: private_flag;          (* Read-only field? *)
    lbl_loc: Location.t;
    lbl_attributes: Parsetree.attributes;
  }

and record_representation =
    Record_regular                      (* All fields are boxed / tagged *)
  | Record_float                        (* All fields are floats *)

(* Variance *)

module Variance : sig
  type t
  type f = May_pos | May_neg | May_weak | Inj | Pos | Neg | Inv
  val null : t                          (* no occurence *)
  val full : t                          (* strictly invariant *)
  val covariant : t                     (* strictly covariant *)
  val may_inv : t                       (* maybe invariant *)
  val union  : t -> t -> t
  val inter  : t -> t -> t
  val subset : t -> t -> bool
  val set : f -> bool -> t -> t
  val mem : f -> t -> bool
  val conjugate : t -> t                (* exchange positive and negative *)
  val get_upper : t -> bool * bool                  (* may_pos, may_neg   *)
  val get_lower : t -> bool * bool * bool * bool    (* pos, neg, inv, inj *)
end

(* Type definitions *)

type type_declaration =
  { type_params: type_expr list;
    type_arity: int;
    type_kind: type_kind;
    type_private: private_flag;
    type_manifest: type_expr option;
    type_variance: Variance.t list;
    (* covariant, contravariant, weakly contravariant, injective *)
    type_newtype_level: (int * int) option;
    (* definition level * expansion level *)
    type_loc: Location.t;
    type_attributes: Parsetree.attributes;
  }

and type_kind =
    Type_abstract
  | Type_record of label_declaration list  * record_representation
  | Type_variant of constructor_declaration list
  | Type_open

and label_declaration =
  {
    ld_id: Ident.t;
    ld_mutable: mutable_flag;
    ld_type: type_expr;
    ld_loc: Location.t;
    ld_attributes: Parsetree.attributes;
  }

and constructor_declaration =
  {
    cd_id: Ident.t;
    cd_args: type_expr list;
    cd_res: type_expr option;
    cd_loc: Location.t;
    cd_attributes: Parsetree.attributes;
  }

type extension_constructor =
    {
      ext_type_path: Path.t;
      ext_type_params: type_expr list;
      ext_args: type_expr list;
      ext_ret_type: type_expr option;
      ext_private: private_flag;
      ext_loc: Location.t;
      ext_attributes: Parsetree.attributes;
    }

and type_transparence =
    Type_public      (* unrestricted expansion *)
  | Type_new         (* "new" type *)
  | Type_private     (* private type *)

(* Type expressions for the class language *)

module Concr : Set.S with type elt = string

type class_type =
    Cty_constr of Path.t * type_expr list * class_type
  | Cty_signature of class_signature
  | Cty_arrow of label * type_expr * class_type

and class_signature =
  { csig_self: type_expr;
    csig_vars:
      (Asttypes.mutable_flag * Asttypes.virtual_flag * type_expr) Vars.t;
    csig_concr: Concr.t;
    csig_inher: (Path.t * type_expr list) list }

type class_declaration =
  { cty_params: type_expr list;
    mutable cty_type: class_type;
    cty_path: Path.t;
    cty_new: type_expr option;
    cty_variance: Variance.t list;
    cty_loc: Location.t;
    cty_attributes: Parsetree.attributes;
  }

type class_type_declaration =
  { clty_params: type_expr list;
    clty_type: class_type;
    clty_path: Path.t;
    clty_variance: Variance.t list;
    clty_loc: Location.t;
    clty_attributes: Parsetree.attributes;
  }

(* Type expressions for the module language *)

type module_type =
    Mty_ident of Path.t
  | Mty_signature of signature
  | Mty_functor of Ident.t * module_type option * module_type
  | Mty_alias of Path.t

and signature = signature_item list

and signature_item =
    Sig_value of Ident.t * value_description
  | Sig_type of Ident.t * type_declaration * rec_status
  | Sig_typext of Ident.t * extension_constructor * ext_status
  | Sig_module of Ident.t * module_declaration * rec_status
  | Sig_modtype of Ident.t * modtype_declaration
  | Sig_class of Ident.t * class_declaration * rec_status
  | Sig_class_type of Ident.t * class_type_declaration * rec_status

and module_declaration =
  {
    md_type: module_type;
    md_attributes: Parsetree.attributes;
    md_loc: Location.t;
  }

and modtype_declaration =
  {
    mtd_type: module_type option;  (* None: abstract *)
    mtd_attributes: Parsetree.attributes;
    mtd_loc: Location.t;
  }

and rec_status =
    Trec_not                            (* first in a nonrecursive group *)
  | Trec_first                          (* first in a recursive group *)
  | Trec_next                           (* not first in a recursive/nonrecursive group *)

and ext_status =
    Text_first                     (* first constructor in an extension *)
  | Text_next                      (* not first constructor in an extension *)
  | Text_exception

val equal_tag :  constructor_tag -> constructor_tag -> bool
end = struct
(*#1 "types.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Representation of types and declarations *)

open Asttypes

(* Type expressions for the core language *)

type type_expr =
  { mutable desc: type_desc;
    mutable level: int;
    mutable id: int }

and type_desc =
    Tvar of string option
  | Tarrow of label * type_expr * type_expr * commutable
  | Ttuple of type_expr list
  | Tconstr of Path.t * type_expr list * abbrev_memo ref
  | Tobject of type_expr * (Path.t * type_expr list) option ref
  | Tfield of string * field_kind * type_expr * type_expr
  | Tnil
  | Tlink of type_expr
  | Tsubst of type_expr         (* for copying *)
  | Tvariant of row_desc
  | Tunivar of string option
  | Tpoly of type_expr * type_expr list
  | Tpackage of Path.t * Longident.t list * type_expr list

and row_desc =
    { row_fields: (label * row_field) list;
      row_more: type_expr;
      row_bound: unit;
      row_closed: bool;
      row_fixed: bool;
      row_name: (Path.t * type_expr list) option }

and row_field =
    Rpresent of type_expr option
  | Reither of bool * type_expr list * bool * row_field option ref
        (* 1st true denotes a constant constructor *)
        (* 2nd true denotes a tag in a pattern matching, and
           is erased later *)
  | Rabsent

and abbrev_memo =
    Mnil
  | Mcons of private_flag * Path.t * type_expr * type_expr * abbrev_memo
  | Mlink of abbrev_memo ref

and field_kind =
    Fvar of field_kind option ref
  | Fpresent
  | Fabsent

and commutable =
    Cok
  | Cunknown
  | Clink of commutable ref

module TypeOps = struct
  type t = type_expr
  let compare t1 t2 = t1.id - t2.id
  let hash t = t.id
  let equal t1 t2 = t1 == t2
end

(* Maps of methods and instance variables *)

module OrderedString =
  struct type t = string let compare (x:t) y = compare x y end
module Meths = Map.Make(OrderedString)
module Vars = Meths

(* Value descriptions *)

type value_description =
  { val_type: type_expr;                (* Type of the value *)
    val_kind: value_kind;
    val_loc: Location.t;
    val_attributes: Parsetree.attributes;
 }

and value_kind =
    Val_reg                             (* Regular value *)
  | Val_prim of Primitive.description   (* Primitive *)
  | Val_ivar of mutable_flag * string   (* Instance variable (mutable ?) *)
  | Val_self of (Ident.t * type_expr) Meths.t ref *
                (Ident.t * Asttypes.mutable_flag *
                 Asttypes.virtual_flag * type_expr) Vars.t ref *
                string * type_expr
                                        (* Self *)
  | Val_anc of (string * Ident.t) list * string
                                        (* Ancestor *)
  | Val_unbound                         (* Unbound variable *)

(* Constructor descriptions *)

type constructor_description =
  { cstr_name: string;                  (* Constructor name *)
    cstr_res: type_expr;                (* Type of the result *)
    cstr_existentials: type_expr list;  (* list of existentials *)
    cstr_args: type_expr list;          (* Type of the arguments *)
    cstr_arity: int;                    (* Number of arguments *)
    cstr_tag: constructor_tag;          (* Tag for heap blocks *)
    cstr_consts: int;                   (* Number of constant constructors *)
    cstr_nonconsts: int;                (* Number of non-const constructors *)
    cstr_normal: int;                   (* Number of non generalized constrs *)
    cstr_generalized: bool;             (* Constrained return type? *)
    cstr_private: private_flag;         (* Read-only constructor? *)
    cstr_loc: Location.t;
    cstr_attributes: Parsetree.attributes;
   }

and constructor_tag =
    Cstr_constant of int                (* Constant constructor (an int) *)
  | Cstr_block of int                   (* Regular constructor (a block) *)
  | Cstr_extension of Path.t * bool     (* Extension constructor
                                           true if a constant false if a block*)

(* Record label descriptions *)

type label_description =
  { lbl_name: string;                   (* Short name *)
    lbl_res: type_expr;                 (* Type of the result *)
    lbl_arg: type_expr;                 (* Type of the argument *)
    lbl_mut: mutable_flag;              (* Is this a mutable field? *)
    lbl_pos: int;                       (* Position in block *)
    lbl_all: label_description array;   (* All the labels in this type *)
    lbl_repres: record_representation;  (* Representation for this record *)
    lbl_private: private_flag;          (* Read-only field? *)
    lbl_loc: Location.t;
    lbl_attributes: Parsetree.attributes;
   }

and record_representation =
    Record_regular                      (* All fields are boxed / tagged *)
  | Record_float                        (* All fields are floats *)

(* Variance *)

module Variance = struct
  type t = int
  type f = May_pos | May_neg | May_weak | Inj | Pos | Neg | Inv
  let single = function
    | May_pos -> 1
    | May_neg -> 2
    | May_weak -> 4
    | Inj -> 8
    | Pos -> 16
    | Neg -> 32
    | Inv -> 64
  let union v1 v2 = v1 lor v2
  let inter v1 v2 = v1 land v2
  let subset v1 v2 = (v1 land v2 = v1)
  let set x b v =
    if b then v lor single x else  v land (lnot (single x))
  let mem x = subset (single x)
  let null = 0
  let may_inv = 7
  let full = 127
  let covariant = single May_pos lor single Pos lor single Inj
  let swap f1 f2 v =
    let v' = set f1 (mem f2 v) v in set f2 (mem f1 v) v'
  let conjugate v = swap May_pos May_neg (swap Pos Neg v)
  let get_upper v = (mem May_pos v, mem May_neg v)
  let get_lower v = (mem Pos v, mem Neg v, mem Inv v, mem Inj v)
end

(* Type definitions *)

type type_declaration =
  { type_params: type_expr list;
    type_arity: int;
    type_kind: type_kind;
    type_private: private_flag;
    type_manifest: type_expr option;
    type_variance: Variance.t list;
    type_newtype_level: (int * int) option;
    type_loc: Location.t;
    type_attributes: Parsetree.attributes;
 }

and type_kind =
    Type_abstract
  | Type_record of label_declaration list  * record_representation
  | Type_variant of constructor_declaration list
  | Type_open

and label_declaration =
  {
    ld_id: Ident.t;
    ld_mutable: mutable_flag;
    ld_type: type_expr;
    ld_loc: Location.t;
    ld_attributes: Parsetree.attributes;
  }

and constructor_declaration =
  {
    cd_id: Ident.t;
    cd_args: type_expr list;
    cd_res: type_expr option;
    cd_loc: Location.t;
    cd_attributes: Parsetree.attributes;
  }

type extension_constructor =
    { ext_type_path: Path.t;
      ext_type_params: type_expr list;
      ext_args: type_expr list;
      ext_ret_type: type_expr option;
      ext_private: private_flag;
      ext_loc: Location.t;
      ext_attributes: Parsetree.attributes; }

and type_transparence =
    Type_public      (* unrestricted expansion *)
  | Type_new         (* "new" type *)
  | Type_private     (* private type *)

(* Type expressions for the class language *)

module Concr = Set.Make(OrderedString)

type class_type =
    Cty_constr of Path.t * type_expr list * class_type
  | Cty_signature of class_signature
  | Cty_arrow of label * type_expr * class_type

and class_signature =
  { csig_self: type_expr;
    csig_vars:
      (Asttypes.mutable_flag * Asttypes.virtual_flag * type_expr) Vars.t;
    csig_concr: Concr.t;
    csig_inher: (Path.t * type_expr list) list }

type class_declaration =
  { cty_params: type_expr list;
    mutable cty_type: class_type;
    cty_path: Path.t;
    cty_new: type_expr option;
    cty_variance: Variance.t list;
    cty_loc: Location.t;
    cty_attributes: Parsetree.attributes;
 }

type class_type_declaration =
  { clty_params: type_expr list;
    clty_type: class_type;
    clty_path: Path.t;
    clty_variance: Variance.t list;
    clty_loc: Location.t;
    clty_attributes: Parsetree.attributes;
  }

(* Type expressions for the module language *)

type module_type =
    Mty_ident of Path.t
  | Mty_signature of signature
  | Mty_functor of Ident.t * module_type option * module_type
  | Mty_alias of Path.t

and signature = signature_item list

and signature_item =
    Sig_value of Ident.t * value_description
  | Sig_type of Ident.t * type_declaration * rec_status
  | Sig_typext of Ident.t * extension_constructor * ext_status
  | Sig_module of Ident.t * module_declaration * rec_status
  | Sig_modtype of Ident.t * modtype_declaration
  | Sig_class of Ident.t * class_declaration * rec_status
  | Sig_class_type of Ident.t * class_type_declaration * rec_status

and module_declaration =
  {
    md_type: module_type;
    md_attributes: Parsetree.attributes;
    md_loc: Location.t;
  }

and modtype_declaration =
  {
    mtd_type: module_type option;  (* Nonte: abstract *)
    mtd_attributes: Parsetree.attributes;
    mtd_loc: Location.t;
  }

and rec_status =
    Trec_not                            (* first in a nonrecursive group *)
  | Trec_first                          (* first in a recursive group *)
  | Trec_next                           (* not first in a recursive/nonrecursive group *)

and ext_status =
    Text_first                     (* first constructor of an extension *)
  | Text_next                      (* not first constructor of an extension *)
  | Text_exception                 (* an exception *)

let equal_tag t1 t2 =
   match (t1, t2) with
   | Cstr_constant i1, Cstr_constant i2 -> i2 = i1
   | Cstr_block i1, Cstr_block i2 -> i2 = i1
   | Cstr_extension (path1, b1), Cstr_extension (path2, b2) ->
       Path.same path1 path2 && b1 = b2
   | (Cstr_constant _|Cstr_block _|Cstr_extension _), _ -> false


end
module Btype : sig
(*#1 "btype.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Basic operations on core types *)

open Asttypes
open Types

(**** Sets, maps and hashtables of types ****)

module TypeSet  : Set.S with type elt = type_expr
module TypeMap  : Map.S with type key = type_expr
module TypeHash : Hashtbl.S with type key = type_expr

(**** Levels ****)

val generic_level: int

val newty2: int -> type_desc -> type_expr
        (* Create a type *)
val newgenty: type_desc -> type_expr
        (* Create a generic type *)
val newgenvar: ?name:string -> unit -> type_expr
        (* Return a fresh generic variable *)

(* Use Tsubst instead
val newmarkedvar: int -> type_expr
        (* Return a fresh marked variable *)
val newmarkedgenvar: unit -> type_expr
        (* Return a fresh marked generic variable *)
*)

(**** Types ****)

val is_Tvar: type_expr -> bool
val is_Tunivar: type_expr -> bool
val dummy_method: label
val default_mty: module_type option -> module_type

val repr: type_expr -> type_expr
        (* Return the canonical representative of a type. *)

val field_kind_repr: field_kind -> field_kind
        (* Return the canonical representative of an object field
           kind. *)

val commu_repr: commutable -> commutable
        (* Return the canonical representative of a commutation lock *)

(**** polymorphic variants ****)

val row_repr: row_desc -> row_desc
        (* Return the canonical representative of a row description *)
val row_field_repr: row_field -> row_field
val row_field: label -> row_desc -> row_field
        (* Return the canonical representative of a row field *)
val row_more: row_desc -> type_expr
        (* Return the extension variable of the row *)
val row_fixed: row_desc -> bool
        (* Return whether the row should be treated as fixed or not *)
val static_row: row_desc -> bool
        (* Return whether the row is static or not *)
val hash_variant: label -> int
        (* Hash function for variant tags *)

val proxy: type_expr -> type_expr
        (* Return the proxy representative of the type: either itself
           or a row variable *)

(**** Utilities for private abbreviations with fixed rows ****)
val has_constr_row: type_expr -> bool
val is_row_name: string -> bool
val is_constr_row: type_expr -> bool

(**** Utilities for type traversal ****)

val iter_type_expr: (type_expr -> unit) -> type_expr -> unit
        (* Iteration on types *)
val iter_row: (type_expr -> unit) -> row_desc -> unit
        (* Iteration on types in a row *)
val iter_abbrev: (type_expr -> unit) -> abbrev_memo -> unit
        (* Iteration on types in an abbreviation list *)

type type_iterators =
  { it_signature: type_iterators -> signature -> unit;
    it_signature_item: type_iterators -> signature_item -> unit;
    it_value_description: type_iterators -> value_description -> unit;
    it_type_declaration: type_iterators -> type_declaration -> unit;
    it_extension_constructor: type_iterators -> extension_constructor -> unit;
    it_module_declaration: type_iterators -> module_declaration -> unit;
    it_modtype_declaration: type_iterators -> modtype_declaration -> unit;
    it_class_declaration: type_iterators -> class_declaration -> unit;
    it_class_type_declaration: type_iterators -> class_type_declaration -> unit;
    it_module_type: type_iterators -> module_type -> unit;
    it_class_type: type_iterators -> class_type -> unit;
    it_type_kind: type_iterators -> type_kind -> unit;
    it_do_type_expr: type_iterators -> type_expr -> unit;
    it_type_expr: type_iterators -> type_expr -> unit;
    it_path: Path.t -> unit; }
val type_iterators: type_iterators
        (* Iteration on arbitrary type information.
           [it_type_expr] calls [mark_type_node] to avoid loops. *)
val unmark_iterators: type_iterators
        (* Unmark any structure containing types. See [unmark_type] below. *)

val copy_type_desc:
    ?keep_names:bool -> (type_expr -> type_expr) -> type_desc -> type_desc
        (* Copy on types *)
val copy_row:
    (type_expr -> type_expr) ->
    bool -> row_desc -> bool -> type_expr -> row_desc
val copy_kind: field_kind -> field_kind

val save_desc: type_expr -> type_desc -> unit
        (* Save a type description *)
val dup_kind: field_kind option ref -> unit
        (* Save a None field_kind, and make it point to a fresh Fvar *)
val cleanup_types: unit -> unit
        (* Restore type descriptions *)

val lowest_level: int
        (* Marked type: ty.level < lowest_level *)
val pivot_level: int
        (* Type marking: ty.level <- pivot_level - ty.level *)
val mark_type: type_expr -> unit
        (* Mark a type *)
val mark_type_node: type_expr -> unit
        (* Mark a type node (but not its sons) *)
val mark_type_params: type_expr -> unit
        (* Mark the sons of a type node *)
val unmark_type: type_expr -> unit
val unmark_type_decl: type_declaration -> unit
val unmark_extension_constructor: extension_constructor -> unit
val unmark_class_type: class_type -> unit
val unmark_class_signature: class_signature -> unit
        (* Remove marks from a type *)

(**** Memorization of abbreviation expansion ****)

val find_expans: private_flag -> Path.t -> abbrev_memo -> type_expr option
        (* Look up a memorized abbreviation *)
val cleanup_abbrev: unit -> unit
        (* Flush the cache of abbreviation expansions.
           When some types are saved (using [output_value]), this
           function MUST be called just before. *)
val memorize_abbrev:
        abbrev_memo ref ->
        private_flag -> Path.t -> type_expr -> type_expr -> unit
        (* Add an expansion in the cache *)
val forget_abbrev:
        abbrev_memo ref -> Path.t -> unit
        (* Remove an abbreviation from the cache *)

(**** Utilities for labels ****)

val is_optional : label -> bool
val label_name : label -> label

(* Returns the label name with first character '?' or '~' as appropriate. *)
val prefixed_label_name : label -> label

val extract_label :
    label -> (label * 'a) list ->
    label * 'a * (label * 'a) list * (label * 'a) list
    (* actual label, value, before list, after list *)

(**** Utilities for backtracking ****)

type snapshot
        (* A snapshot for backtracking *)
val snapshot: unit -> snapshot
        (* Make a snapshot for later backtracking. Costs nothing *)
val backtrack: snapshot -> unit
        (* Backtrack to a given snapshot. Only possible if you have
           not already backtracked to a previous snapshot.
           Calls [cleanup_abbrev] internally *)

(* Functions to use when modifying a type (only Ctype?) *)
val link_type: type_expr -> type_expr -> unit
        (* Set the desc field of [t1] to [Tlink t2], logging the old
           value if there is an active snapshot *)
val set_level: type_expr -> int -> unit
val set_name:
    (Path.t * type_expr list) option ref ->
    (Path.t * type_expr list) option -> unit
val set_row_field: row_field option ref -> row_field -> unit
val set_univar: type_expr option ref -> type_expr -> unit
val set_kind: field_kind option ref -> field_kind -> unit
val set_commu: commutable ref -> commutable -> unit
val set_typeset: TypeSet.t ref -> TypeSet.t -> unit
        (* Set references, logging the old value *)
val log_type: type_expr -> unit
        (* Log the old value of a type, before modifying it by hand *)

(**** Forward declarations ****)
val print_raw: (Format.formatter -> type_expr -> unit) ref

end = struct
(*#1 "btype.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(* Xavier Leroy and Jerome Vouillon, projet Cristal, INRIA Rocquencourt*)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Basic operations on core types *)

open Misc
open Types

(**** Sets, maps and hashtables of types ****)

module TypeSet = Set.Make(TypeOps)
module TypeMap = Map.Make (TypeOps)
module TypeHash = Hashtbl.Make(TypeOps)

(**** Forward declarations ****)

let print_raw =
  ref (fun _ -> assert false : Format.formatter -> type_expr -> unit)

(**** Type level management ****)

let generic_level = 100000000

(* Used to mark a type during a traversal. *)
let lowest_level = 0
let pivot_level = 2 * lowest_level - 1
    (* pivot_level - lowest_level < lowest_level *)

(**** Some type creators ****)

let new_id = ref (-1)

let newty2 level desc  =
  incr new_id; { desc; level; id = !new_id }
let newgenty desc      = newty2 generic_level desc
let newgenvar ?name () = newgenty (Tvar name)
(*
let newmarkedvar level =
  incr new_id; { desc = Tvar; level = pivot_level - level; id = !new_id }
let newmarkedgenvar () =
  incr new_id;
  { desc = Tvar; level = pivot_level - generic_level; id = !new_id }
*)

(**** Check some types ****)

let is_Tvar = function {desc=Tvar _} -> true | _ -> false
let is_Tunivar = function {desc=Tunivar _} -> true | _ -> false

let dummy_method = "*dummy method*"
let default_mty = function
    Some mty -> mty
  | None -> Mty_signature []

(**** Representative of a type ****)

let rec field_kind_repr =
  function
    Fvar {contents = Some kind} -> field_kind_repr kind
  | kind                        -> kind

let rec repr =
  function
    {desc = Tlink t'} ->
      (*
         We do no path compression. Path compression does not seem to
         improve notably efficiency, and it prevents from changing a
         [Tlink] into another type (for instance, for undoing a
         unification).
      *)
      repr t'
  | {desc = Tfield (_, k, _, t')} when field_kind_repr k = Fabsent ->
      repr t'
  | t -> t

let rec commu_repr = function
    Clink r when !r <> Cunknown -> commu_repr !r
  | c -> c

let rec row_field_repr_aux tl = function
    Reither(_, tl', _, {contents = Some fi}) ->
      row_field_repr_aux (tl@tl') fi
  | Reither(c, tl', m, r) ->
      Reither(c, tl@tl', m, r)
  | Rpresent (Some _) when tl <> [] ->
      Rpresent (Some (List.hd tl))
  | fi -> fi

let row_field_repr fi = row_field_repr_aux [] fi

let rec rev_concat l ll =
  match ll with
    [] -> l
  | l'::ll -> rev_concat (l'@l) ll

let rec row_repr_aux ll row =
  match (repr row.row_more).desc with
  | Tvariant row' ->
      let f = row.row_fields in
      row_repr_aux (if f = [] then ll else f::ll) row'
  | _ ->
      if ll = [] then row else
      {row with row_fields = rev_concat row.row_fields ll}

let row_repr row = row_repr_aux [] row

let rec row_field tag row =
  let rec find = function
    | (tag',f) :: fields ->
        if tag = tag' then row_field_repr f else find fields
    | [] ->
        match repr row.row_more with
        | {desc=Tvariant row'} -> row_field tag row'
        | _ -> Rabsent
  in find row.row_fields

let rec row_more row =
  match repr row.row_more with
  | {desc=Tvariant row'} -> row_more row'
  | ty -> ty

let row_fixed row =
  let row = row_repr row in
  row.row_fixed ||
  match (repr row.row_more).desc with
    Tvar _ | Tnil -> false
  | Tunivar _ | Tconstr _ -> true
  | _ -> assert false

let static_row row =
  let row = row_repr row in
  row.row_closed &&
  List.for_all
    (fun (_,f) -> match row_field_repr f with Reither _ -> false | _ -> true)
    row.row_fields

let hash_variant s =
  let accu = ref 0 in
  for i = 0 to String.length s - 1 do
    accu := 223 * !accu + Char.code s.[i]
  done;
  (* reduce to 31 bits *)
  accu := !accu land (1 lsl 31 - 1);
  (* make it signed for 64 bits architectures *)
  if !accu > 0x3FFFFFFF then !accu - (1 lsl 31) else !accu

let proxy ty =
  let ty0 = repr ty in
  match ty0.desc with
  | Tvariant row when not (static_row row) ->
      row_more row
  | Tobject (ty, _) ->
      let rec proxy_obj ty =
        match ty.desc with
          Tfield (_, _, _, ty) | Tlink ty -> proxy_obj ty
        | Tvar _ | Tunivar _ | Tconstr _ -> ty
        | Tnil -> ty0
        | _ -> assert false
      in proxy_obj ty
  | _ -> ty0

(**** Utilities for fixed row private types ****)

let has_constr_row t =
  match (repr t).desc with
    Tobject(t,_) ->
      let rec check_row t =
        match (repr t).desc with
          Tfield(_,_,_,t) -> check_row t
        | Tconstr _ -> true
        | _ -> false
      in check_row t
  | Tvariant row ->
      (match row_more row with {desc=Tconstr _} -> true | _ -> false)
  | _ ->
      false

let is_row_name s =
  let l = String.length s in
  if l < 4 then false else String.sub s (l-4) 4 = "#row"

let is_constr_row t =
  match t.desc with
    Tconstr (Path.Pident id, _, _) -> is_row_name (Ident.name id)
  | Tconstr (Path.Pdot (_, s, _), _, _) -> is_row_name s
  | _ -> false


                  (**********************************)
                  (*  Utilities for type traversal  *)
                  (**********************************)

let rec iter_row f row =
  List.iter
    (fun (_, fi) ->
      match row_field_repr fi with
      | Rpresent(Some ty) -> f ty
      | Reither(_, tl, _, _) -> List.iter f tl
      | _ -> ())
    row.row_fields;
  match (repr row.row_more).desc with
    Tvariant row -> iter_row f row
  | Tvar _ | Tunivar _ | Tsubst _ | Tconstr _ | Tnil ->
      Misc.may (fun (_,l) -> List.iter f l) row.row_name
  | _ -> assert false

let iter_type_expr f ty =
  match ty.desc with
    Tvar _              -> ()
  | Tarrow (_, ty1, ty2, _) -> f ty1; f ty2
  | Ttuple l            -> List.iter f l
  | Tconstr (_, l, _)   -> List.iter f l
  | Tobject(ty, {contents = Some (_, p)})
                        -> f ty; List.iter f p
  | Tobject (ty, _)     -> f ty
  | Tvariant row        -> iter_row f row; f (row_more row)
  | Tfield (_, _, ty1, ty2) -> f ty1; f ty2
  | Tnil                -> ()
  | Tlink ty            -> f ty
  | Tsubst ty           -> f ty
  | Tunivar _           -> ()
  | Tpoly (ty, tyl)     -> f ty; List.iter f tyl
  | Tpackage (_, _, l)  -> List.iter f l

let rec iter_abbrev f = function
    Mnil                   -> ()
  | Mcons(_, _, ty, ty', rem) -> f ty; f ty'; iter_abbrev f rem
  | Mlink rem              -> iter_abbrev f !rem

type type_iterators =
  { it_signature: type_iterators -> signature -> unit;
    it_signature_item: type_iterators -> signature_item -> unit;
    it_value_description: type_iterators -> value_description -> unit;
    it_type_declaration: type_iterators -> type_declaration -> unit;
    it_extension_constructor: type_iterators -> extension_constructor -> unit;
    it_module_declaration: type_iterators -> module_declaration -> unit;
    it_modtype_declaration: type_iterators -> modtype_declaration -> unit;
    it_class_declaration: type_iterators -> class_declaration -> unit;
    it_class_type_declaration: type_iterators -> class_type_declaration -> unit;
    it_module_type: type_iterators -> module_type -> unit;
    it_class_type: type_iterators -> class_type -> unit;
    it_type_kind: type_iterators -> type_kind -> unit;
    it_do_type_expr: type_iterators -> type_expr -> unit;
    it_type_expr: type_iterators -> type_expr -> unit;
    it_path: Path.t -> unit; }

let type_iterators =
  let it_signature it =
    List.iter (it.it_signature_item it)
  and it_signature_item it = function
      Sig_value (_, vd)     -> it.it_value_description it vd
    | Sig_type (_, td, _)   -> it.it_type_declaration it td
    | Sig_typext (_, td, _) -> it.it_extension_constructor it td
    | Sig_module (_, md, _) -> it.it_module_declaration it md
    | Sig_modtype (_, mtd)  -> it.it_modtype_declaration it mtd
    | Sig_class (_, cd, _)  -> it.it_class_declaration it cd
    | Sig_class_type (_, ctd, _) -> it.it_class_type_declaration it ctd
  and it_value_description it vd =
    it.it_type_expr it vd.val_type
  and it_type_declaration it td =
    List.iter (it.it_type_expr it) td.type_params;
    may (it.it_type_expr it) td.type_manifest;
    it.it_type_kind it td.type_kind
  and it_extension_constructor it td =
    it.it_path td.ext_type_path;
    List.iter (it.it_type_expr it) td.ext_type_params;
    List.iter (it.it_type_expr it) td.ext_args;
    may (it.it_type_expr it) td.ext_ret_type
  and it_module_declaration it md =
    it.it_module_type it md.md_type
  and it_modtype_declaration it mtd =
    may (it.it_module_type it) mtd.mtd_type
  and it_class_declaration it cd =
    List.iter (it.it_type_expr it) cd.cty_params;
    it.it_class_type it cd.cty_type;
    may (it.it_type_expr it) cd.cty_new;
    it.it_path cd.cty_path
  and it_class_type_declaration it ctd =
    List.iter (it.it_type_expr it) ctd.clty_params;
    it.it_class_type it ctd.clty_type;
    it.it_path ctd.clty_path
  and it_module_type it = function
      Mty_ident p
    | Mty_alias p -> it.it_path p
    | Mty_signature sg -> it.it_signature it sg
    | Mty_functor (_, mto, mt) ->
        may (it.it_module_type it) mto;
        it.it_module_type it mt
  and it_class_type it = function
      Cty_constr (p, tyl, cty) ->
        it.it_path p;
        List.iter (it.it_type_expr it) tyl;
        it.it_class_type it cty
    | Cty_signature cs ->
        it.it_type_expr it cs.csig_self;
        Vars.iter (fun _ (_,_,ty) -> it.it_type_expr it ty) cs.csig_vars;
        List.iter
          (fun (p, tl) -> it.it_path p; List.iter (it.it_type_expr it) tl)
          cs.csig_inher
    | Cty_arrow  (_, ty, cty) ->
        it.it_type_expr it ty;
        it.it_class_type it cty
  and it_type_kind it = function
      Type_abstract -> ()
    | Type_record (ll, _) ->
        List.iter (fun ld -> it.it_type_expr it ld.ld_type) ll
    | Type_variant cl ->
        List.iter (fun cd ->
          List.iter (it.it_type_expr it) cd.cd_args;
          may (it.it_type_expr it) cd.cd_res)
          cl
    | Type_open -> ()
  and it_do_type_expr it ty =
    iter_type_expr (it.it_type_expr it) ty;
    match ty.desc with
      Tconstr (p, _, _)
    | Tobject (_, {contents=Some (p, _)})
    | Tpackage (p, _, _) ->
        it.it_path p
    | Tvariant row ->
        may (fun (p,_) -> it.it_path p) (row_repr row).row_name
    | _ -> ()
  and it_path p = ()
  in
  { it_path; it_type_expr = it_do_type_expr; it_do_type_expr;
    it_type_kind; it_class_type; it_module_type;
    it_signature; it_class_type_declaration; it_class_declaration;
    it_modtype_declaration; it_module_declaration; it_extension_constructor;
    it_type_declaration; it_value_description; it_signature_item; }

let copy_row f fixed row keep more =
  let fields = List.map
      (fun (l, fi) -> l,
        match row_field_repr fi with
        | Rpresent(Some ty) -> Rpresent(Some(f ty))
        | Reither(c, tl, m, e) ->
            let e = if keep then e else ref None in
            let m = if row.row_fixed then fixed else m in
            let tl = List.map f tl in
            Reither(c, tl, m, e)
        | _ -> fi)
      row.row_fields in
  let name =
    match row.row_name with None -> None
    | Some (path, tl) -> Some (path, List.map f tl) in
  { row_fields = fields; row_more = more;
    row_bound = (); row_fixed = row.row_fixed && fixed;
    row_closed = row.row_closed; row_name = name; }

let rec copy_kind = function
    Fvar{contents = Some k} -> copy_kind k
  | Fvar _   -> Fvar (ref None)
  | Fpresent -> Fpresent
  | Fabsent  -> assert false

let copy_commu c =
  if commu_repr c = Cok then Cok else Clink (ref Cunknown)

(* Since univars may be used as row variables, we need to do some
   encoding during substitution *)
let rec norm_univar ty =
  match ty.desc with
    Tunivar _ | Tsubst _ -> ty
  | Tlink ty           -> norm_univar ty
  | Ttuple (ty :: _)   -> norm_univar ty
  | _                  -> assert false

let rec copy_type_desc ?(keep_names=false) f = function
    Tvar _ as ty        -> if keep_names then ty else Tvar None
  | Tarrow (p, ty1, ty2, c)-> Tarrow (p, f ty1, f ty2, copy_commu c)
  | Ttuple l            -> Ttuple (List.map f l)
  | Tconstr (p, l, _)   -> Tconstr (p, List.map f l, ref Mnil)
  | Tobject(ty, {contents = Some (p, tl)})
                        -> Tobject (f ty, ref (Some(p, List.map f tl)))
  | Tobject (ty, _)     -> Tobject (f ty, ref None)
  | Tvariant row        -> assert false (* too ambiguous *)
  | Tfield (p, k, ty1, ty2) -> (* the kind is kept shared *)
      Tfield (p, field_kind_repr k, f ty1, f ty2)
  | Tnil                -> Tnil
  | Tlink ty            -> copy_type_desc f ty.desc
  | Tsubst ty           -> assert false
  | Tunivar _ as ty     -> ty (* always keep the name *)
  | Tpoly (ty, tyl)     ->
      let tyl = List.map (fun x -> norm_univar (f x)) tyl in
      Tpoly (f ty, tyl)
  | Tpackage (p, n, l)  -> Tpackage (p, n, List.map f l)

(* Utilities for copying *)

let saved_desc = ref []
  (* Saved association of generic nodes with their description. *)

let save_desc ty desc =
  saved_desc := (ty, desc)::!saved_desc

let saved_kinds = ref [] (* duplicated kind variables *)
let new_kinds = ref []   (* new kind variables *)
let dup_kind r =
  (match !r with None -> () | Some _ -> assert false);
  if not (List.memq r !new_kinds) then begin
    saved_kinds := r :: !saved_kinds;
    let r' = ref None in
    new_kinds := r' :: !new_kinds;
    r := Some (Fvar r')
  end

(* Restored type descriptions. *)
let cleanup_types () =
  List.iter (fun (ty, desc) -> ty.desc <- desc) !saved_desc;
  List.iter (fun r -> r := None) !saved_kinds;
  saved_desc := []; saved_kinds := []; new_kinds := []

(* Mark a type. *)
let rec mark_type ty =
  let ty = repr ty in
  if ty.level >= lowest_level then begin
    ty.level <- pivot_level - ty.level;
    iter_type_expr mark_type ty
  end

let mark_type_node ty =
  let ty = repr ty in
  if ty.level >= lowest_level then begin
    ty.level <- pivot_level - ty.level;
  end

let mark_type_params ty =
  iter_type_expr mark_type ty

let type_iterators =
  let it_type_expr it ty =
    let ty = repr ty in
    if ty.level >= lowest_level then begin
      mark_type_node ty;
      it.it_do_type_expr it ty;
    end
  in
  {type_iterators with it_type_expr}


(* Remove marks from a type. *)
let rec unmark_type ty =
  let ty = repr ty in
  if ty.level < lowest_level then begin
    ty.level <- pivot_level - ty.level;
    iter_type_expr unmark_type ty
  end

let unmark_iterators =
  let it_type_expr it ty = unmark_type ty in
  {type_iterators with it_type_expr}

let unmark_type_decl decl =
  unmark_iterators.it_type_declaration unmark_iterators decl

let unmark_extension_constructor ext =
  List.iter unmark_type ext.ext_type_params;
  List.iter unmark_type ext.ext_args;
  Misc.may unmark_type ext.ext_ret_type

let unmark_class_signature sign =
  unmark_type sign.csig_self;
  Vars.iter (fun l (m, v, t) -> unmark_type t) sign.csig_vars

let unmark_class_type cty =
  unmark_iterators.it_class_type unmark_iterators cty


                  (*******************************************)
                  (*  Memorization of abbreviation expansion *)
                  (*******************************************)

(* Search whether the expansion has been memorized. *)
let rec find_expans priv p1 = function
    Mnil -> None
  | Mcons (priv', p2, ty0, ty, _)
    when priv' >= priv && Path.same p1 p2 -> Some ty
  | Mcons (_, _, _, _, rem)   -> find_expans priv p1 rem
  | Mlink {contents = rem} -> find_expans priv p1 rem

(* debug: check for cycles in abbreviation. only works with -principal
let rec check_expans visited ty =
  let ty = repr ty in
  assert (not (List.memq ty visited));
  match ty.desc with
    Tconstr (path, args, abbrev) ->
      begin match find_expans path !abbrev with
        Some ty' -> check_expans (ty :: visited) ty'
      | None -> ()
      end
  | _ -> ()
*)

let memo = ref []
        (* Contains the list of saved abbreviation expansions. *)

let cleanup_abbrev () =
        (* Remove all memorized abbreviation expansions. *)
  List.iter (fun abbr -> abbr := Mnil) !memo;
  memo := []

let memorize_abbrev mem priv path v v' =
        (* Memorize the expansion of an abbreviation. *)
  mem := Mcons (priv, path, v, v', !mem);
  (* check_expans [] v; *)
  memo := mem :: !memo

let rec forget_abbrev_rec mem path =
  match mem with
    Mnil ->
      assert false
  | Mcons (_, path', _, _, rem) when Path.same path path' ->
      rem
  | Mcons (priv, path', v, v', rem) ->
      Mcons (priv, path', v, v', forget_abbrev_rec rem path)
  | Mlink mem' ->
      mem' := forget_abbrev_rec !mem' path;
      raise Exit

let forget_abbrev mem path =
  try mem := forget_abbrev_rec !mem path with Exit -> ()

(* debug: check for invalid abbreviations
let rec check_abbrev_rec = function
    Mnil -> true
  | Mcons (_, ty1, ty2, rem) ->
      repr ty1 != repr ty2
  | Mlink mem' ->
      check_abbrev_rec !mem'

let check_memorized_abbrevs () =
  List.for_all (fun mem -> check_abbrev_rec !mem) !memo
*)

                  (**********************************)
                  (*  Utilities for labels          *)
                  (**********************************)

let is_optional l =
  String.length l > 0 && l.[0] = '?'

let label_name l =
  if is_optional l then String.sub l 1 (String.length l - 1)
                   else l

let prefixed_label_name l =
  if is_optional l then l else "~" ^ l

let rec extract_label_aux hd l = function
    [] -> raise Not_found
  | (l',t as p) :: ls ->
      if label_name l' = l then (l', t, List.rev hd, ls)
      else extract_label_aux (p::hd) l ls

let extract_label l ls = extract_label_aux [] l ls


                  (**********************************)
                  (*  Utilities for backtracking    *)
                  (**********************************)

type change =
    Ctype of type_expr * type_desc
  | Clevel of type_expr * int
  | Cname of
      (Path.t * type_expr list) option ref * (Path.t * type_expr list) option
  | Crow of row_field option ref * row_field option
  | Ckind of field_kind option ref * field_kind option
  | Ccommu of commutable ref * commutable
  | Cuniv of type_expr option ref * type_expr option
  | Ctypeset of TypeSet.t ref * TypeSet.t

let undo_change = function
    Ctype  (ty, desc) -> ty.desc <- desc
  | Clevel (ty, level) -> ty.level <- level
  | Cname  (r, v) -> r := v
  | Crow   (r, v) -> r := v
  | Ckind  (r, v) -> r := v
  | Ccommu (r, v) -> r := v
  | Cuniv  (r, v) -> r := v
  | Ctypeset (r, v) -> r := v

type changes =
    Change of change * changes ref
  | Unchanged
  | Invalid

type snapshot = changes ref * int
module Weak = Array
let trail = Weak.make 1 None
let last_snapshot = ref 0

let log_change ch =
  match Weak.get trail 0 with None -> ()
  | Some r ->
      let r' = ref Unchanged in
      r := Change (ch, r');
      Weak.set trail 0 (Some r')

let log_type ty =
  if ty.id <= !last_snapshot then log_change (Ctype (ty, ty.desc))
let link_type ty ty' =
  log_type ty;
  let desc = ty.desc in
  ty.desc <- Tlink ty';
  (* Name is a user-supplied name for this unification variable (obtained
   * through a type annotation for instance). *)
  match desc, ty'.desc with
    Tvar name, Tvar name' ->
      begin match name, name' with
      | Some _, None ->  log_type ty'; ty'.desc <- Tvar name
      | None, Some _ ->  ()
      | Some _, Some _ ->
          if ty.level < ty'.level then (log_type ty'; ty'.desc <- Tvar name)
      | None, None   ->  ()
      end
  | _ -> ()
  (* ; assert (check_memorized_abbrevs ()) *)
  (*  ; check_expans [] ty' *)
let set_level ty level =
  if ty.id <= !last_snapshot then log_change (Clevel (ty, ty.level));
  ty.level <- level
let set_univar rty ty =
  log_change (Cuniv (rty, !rty)); rty := Some ty
let set_name nm v =
  log_change (Cname (nm, !nm)); nm := v
let set_row_field e v =
  log_change (Crow (e, !e)); e := Some v
let set_kind rk k =
  log_change (Ckind (rk, !rk)); rk := Some k
let set_commu rc c =
  log_change (Ccommu (rc, !rc)); rc := c
let set_typeset rs s =
  log_change (Ctypeset (rs, !rs)); rs := s

let snapshot () =
  let old = !last_snapshot in
  last_snapshot := !new_id;
  match Weak.get trail 0 with Some r -> (r, old)
  | None ->
      let r = ref Unchanged in
      Weak.set trail 0 (Some r);
      (r, old)

let rec rev_log accu = function
    Unchanged -> accu
  | Invalid -> assert false
  | Change (ch, next) ->
      let d = !next in
      next := Invalid;
      rev_log (ch::accu) d

let backtrack (changes, old) =
  match !changes with
    Unchanged -> last_snapshot := old
  | Invalid -> failwith "Btype.backtrack"
  | Change _ as change ->
      cleanup_abbrev ();
      let backlog = rev_log [] change in
      List.iter undo_change backlog;
      changes := Unchanged;
      last_snapshot := old;
      Weak.set trail 0 (Some changes)

end
module Cmi_format : sig
(*#1 "cmi_format.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*                  Fabrice Le Fessant, INRIA Saclay                   *)
(*                                                                     *)
(*  Copyright 2012 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

type pers_flags = Rectypes

type cmi_infos = {
    cmi_name : string;
    cmi_sign : Types.signature_item list;
    cmi_crcs : (string * Digest.t option) list;
    cmi_flags : pers_flags list;
}

(* write the magic + the cmi information *)
val output_cmi : string -> out_channel -> cmi_infos -> Digest.t

(* read the cmi information (the magic is supposed to have already been read) *)
val input_cmi : in_channel -> cmi_infos

(* read a cmi from a filename, checking the magic *)
val read_cmi : string -> cmi_infos

(* Error report *)

type error =
    Not_an_interface of string
  | Wrong_version_interface of string * string
  | Corrupted_interface of string

exception Error of error

open Format

val report_error: formatter -> error -> unit

end = struct
(*#1 "cmi_format.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*                  Fabrice Le Fessant, INRIA Saclay                   *)
(*                                                                     *)
(*  Copyright 2012 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

type pers_flags = Rectypes

type error =
    Not_an_interface of string
  | Wrong_version_interface of string * string
  | Corrupted_interface of string

exception Error of error

type cmi_infos = {
    cmi_name : string;
    cmi_sign : Types.signature_item list;
    cmi_crcs : (string * Digest.t option) list;
    cmi_flags : pers_flags list;
}

let input_cmi ic =
  let (name, sign) = input_value ic in
  let crcs = input_value ic in
  let flags = input_value ic in
  {
      cmi_name = name;
      cmi_sign = sign;
      cmi_crcs = crcs;
      cmi_flags = flags;
    }

let read_cmi filename =
  let ic = open_in_bin filename in
  try
    let buffer =
      really_input_string ic (String.length Config.cmi_magic_number)
    in
    if buffer <> Config.cmi_magic_number then begin
      close_in ic;
      let pre_len = String.length Config.cmi_magic_number - 3 in
      if String.sub buffer 0 pre_len
          = String.sub Config.cmi_magic_number 0 pre_len then
      begin
        let msg =
          if buffer < Config.cmi_magic_number then "an older" else "a newer" in
        raise (Error (Wrong_version_interface (filename, msg)))
      end else begin
        raise(Error(Not_an_interface filename))
      end
    end;
    let cmi = input_cmi ic in
    close_in ic;
    cmi
  with End_of_file | Failure _ ->
      close_in ic;
      raise(Error(Corrupted_interface(filename)))
    | Error e ->
      close_in ic;
      raise (Error e)

let output_cmi filename oc cmi =
(* beware: the provided signature must have been substituted for saving *)
  output_string oc Config.cmi_magic_number;
  output_value oc (cmi.cmi_name, cmi.cmi_sign);
  flush oc;
  let crc = Digest.file filename in
  let crcs = (cmi.cmi_name, Some crc) :: cmi.cmi_crcs in
  output_value oc crcs;
  output_value oc cmi.cmi_flags;
  crc

(* Error report *)

open Format

let report_error ppf = function
  | Not_an_interface filename ->
      fprintf ppf "%a@ is not a compiled interface"
        Location.print_filename filename
  | Wrong_version_interface (filename, older_newer) ->
      fprintf ppf
        "%a@ is not a compiled interface for this version of OCaml.@.\
         It seems to be for %s version of OCaml."
        Location.print_filename filename older_newer
  | Corrupted_interface filename ->
      fprintf ppf "Corrupted compiled interface@ %a"
        Location.print_filename filename

let () =
  Location.register_error_of_exn
    (function
      | Error err -> Some (Location.error_of_printer_file report_error err)
      | _ -> None
    )

end
module Consistbl : sig
(*#1 "consistbl.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 2002 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Consistency tables: for checking consistency of module CRCs *)

type t

val create: unit -> t

val clear: t -> unit

val check: t -> string -> Digest.t -> string -> unit
      (* [check tbl name crc source]
           checks consistency of ([name], [crc]) with infos previously
           stored in [tbl].  If no CRC was previously associated with
           [name], record ([name], [crc]) in [tbl].
           [source] is the name of the file from which the information
           comes from.  This is used for error reporting. *)

val check_noadd: t -> string -> Digest.t -> string -> unit
      (* Same as [check], but raise [Not_available] if no CRC was previously
           associated with [name]. *)

val set: t -> string -> Digest.t -> string -> unit
      (* [set tbl name crc source] forcefully associates [name] with
         [crc] in [tbl], even if [name] already had a different CRC
         associated with [name] in [tbl]. *)

val source: t -> string -> string
      (* [source tbl name] returns the file name associated with [name]
         if the latter has an associated CRC in [tbl].
         Raise [Not_found] otherwise. *)

val extract: string list -> t -> (string * Digest.t option) list
      (* [extract tbl names] returns an associative list mapping each string
         in [names] to the CRC associated with it in [tbl]. If no CRC is
         associated with a name then it is mapped to [None]. *)

val filter: (string -> bool) -> t -> unit
      (* [filter pred tbl] removes from [tbl] table all (name, CRC) pairs
         such that [pred name] is [false]. *)

exception Inconsistency of string * string * string
      (* Raised by [check] when a CRC mismatch is detected.
         First string is the name of the compilation unit.
         Second string is the source that caused the inconsistency.
         Third string is the source that set the CRC. *)

exception Not_available of string
      (* Raised by [check_noadd] when a name doesn't have an associated CRC. *)

end = struct
(*#1 "consistbl.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 2002 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Consistency tables: for checking consistency of module CRCs *)

type t = (string, Digest.t * string) Hashtbl.t

let create () = Hashtbl.create 13

let clear = Hashtbl.clear

exception Inconsistency of string * string * string

exception Not_available of string

let check tbl name crc source =
  try
    let (old_crc, old_source) = Hashtbl.find tbl name in
    if crc <> old_crc then raise(Inconsistency(name, source, old_source))
  with Not_found ->
    Hashtbl.add tbl name (crc, source)

let check_noadd tbl name crc source =
  try
    let (old_crc, old_source) = Hashtbl.find tbl name in
    if crc <> old_crc then raise(Inconsistency(name, source, old_source))
  with Not_found ->
    raise (Not_available name)

let set tbl name crc source = Hashtbl.add tbl name (crc, source)

let source tbl name = snd (Hashtbl.find tbl name)

let extract l tbl =
  let l = List.sort_uniq String.compare l in
  List.fold_left
    (fun assc name ->
       try
         let (crc, _) = Hashtbl.find tbl name in
           (name, Some crc) :: assc
       with Not_found ->
         (name, None) :: assc)
    [] l

let filter p tbl =
  let to_remove = ref [] in
  Hashtbl.iter
    (fun name (crc, auth) ->
      if not (p name) then to_remove := name :: !to_remove)
    tbl;
  List.iter
    (fun name ->
       while Hashtbl.mem tbl name do Hashtbl.remove tbl name done)
    !to_remove

end
module Datarepr : sig
(*#1 "datarepr.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Compute constructor and label descriptions from type declarations,
   determining their representation. *)

open Asttypes
open Types

val constructor_has_optional_shape:
  Types.constructor_description -> bool



val constructor_descrs:
  type_expr -> constructor_declaration list ->
  private_flag -> (Ident.t * constructor_description) list
val extension_descr:
  Path.t -> extension_constructor -> constructor_description
val label_descrs:
  type_expr -> label_declaration list ->
    record_representation -> private_flag ->
    (Ident.t * label_description) list

exception Constr_not_found

val find_constr_by_tag:
  constructor_tag -> constructor_declaration list ->
    constructor_declaration

end = struct
(*#1 "datarepr.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Compute constructor and label descriptions from type declarations,
   determining their representation. *)

open Asttypes
open Types
open Btype

(* Simplified version of Ctype.free_vars *)
let free_vars ty =
  let ret = ref TypeSet.empty in
  let rec loop ty =
    let ty = repr ty in
    if ty.level >= lowest_level then begin
      ty.level <- pivot_level - ty.level;
      match ty.desc with
      | Tvar _ ->
          ret := TypeSet.add ty !ret
      | Tvariant row ->
          let row = row_repr row in
          iter_row loop row;
          if not (static_row row) then loop row.row_more
      | _ ->
          iter_type_expr loop ty
    end
  in
  loop ty;
  unmark_type ty;
  !ret

let internal_optional = "internal.optional"

let optional_shape : Parsetree.attribute =
  {txt = internal_optional ; loc = Location.none}, PStr []

let constructor_has_optional_shape ({cstr_attributes = attrs} : constructor_description) =
  List.exists (fun (x,_) -> x.txt = internal_optional) attrs



let constructor_descrs ty_res cstrs priv =
  let num_consts = ref 0 and num_nonconsts = ref 0  and num_normal = ref 0 in
  List.iter
    (fun {cd_args; cd_res; _} ->
      if cd_args = [] then incr num_consts else incr num_nonconsts;
      if cd_res = None then incr num_normal)
    cstrs;
  let rec describe_constructors idx_const idx_nonconst = function
      [] -> []
    | {cd_id; cd_args; cd_res; cd_loc; cd_attributes} :: rem ->
        let ty_res =
          match cd_res with
          | Some ty_res' -> ty_res'
          | None -> ty_res
        in
        let (tag, descr_rem) =
          match cd_args with
            [] -> (Cstr_constant idx_const,
                   describe_constructors (idx_const+1) idx_nonconst rem)
          | _  -> (Cstr_block idx_nonconst,
                   describe_constructors idx_const (idx_nonconst+1) rem) in
        let existentials =
          match cd_res with
          | None -> []
          | Some type_ret ->
              let res_vars = free_vars type_ret in
              let arg_vars = free_vars (newgenty (Ttuple cd_args)) in
              TypeSet.elements (TypeSet.diff arg_vars res_vars)
        in
        let cstr =
          { cstr_name = Ident.name cd_id;
            cstr_res = ty_res;
            cstr_existentials = existentials;
            cstr_args = cd_args;
            cstr_arity = List.length cd_args;
            cstr_tag = tag;
            cstr_consts = !num_consts;
            cstr_nonconsts = !num_nonconsts;
            cstr_normal = !num_normal;
            cstr_private = priv;
            cstr_generalized = cd_res <> None;
            cstr_loc = cd_loc;
            cstr_attributes = cd_attributes;
          } in
        (cd_id, cstr) :: descr_rem in
  let result = describe_constructors 0 0 cstrs in
  match result with
  | (
    [ ({name = "None"} as a_id, ({cstr_args = []} as a_descr) )  ;
      ({ name = "Some"} as b_id, ({ cstr_args = [_]} as b_descr))
    ] |
    [ ({name = "Some"} as a_id, ({cstr_args = [_]} as a_descr) )  ;
      ({ name = "None"} as b_id, ({ cstr_args = []} as b_descr))
    ]
   )
    ->
      [
        (a_id, {a_descr with
                   cstr_attributes =
                     optional_shape :: a_descr.cstr_attributes});
        (b_id, {b_descr with
                   cstr_attributes =
                     optional_shape :: b_descr.cstr_attributes
                  })
      ]
  | _ -> result

let extension_descr path_ext ext =
  let ty_res =
    match ext.ext_ret_type with
        Some type_ret -> type_ret
      | None ->
          newgenty (Tconstr(ext.ext_type_path, ext.ext_type_params, ref Mnil))
  in
  let tag = Cstr_extension(path_ext, ext.ext_args = []) in
  let existentials =
    match ext.ext_ret_type with
      | None -> []
      | Some type_ret ->
          let ret_vars = free_vars type_ret in
          let arg_vars = free_vars (newgenty (Ttuple ext.ext_args)) in
            TypeSet.elements (TypeSet.diff arg_vars ret_vars)
  in
    { cstr_name = Path.last path_ext;
      cstr_res = ty_res;
      cstr_existentials = existentials;
      cstr_args = ext.ext_args;
      cstr_arity = List.length ext.ext_args;
      cstr_tag = tag;
      cstr_consts = -1;
      cstr_nonconsts = -1;
      cstr_private = ext.ext_private;
      cstr_normal = -1;
      cstr_generalized = ext.ext_ret_type <> None;
      cstr_loc = ext.ext_loc;
      cstr_attributes = ext.ext_attributes;
    }

let none = {desc = Ttuple []; level = -1; id = -1}
                                        (* Clearly ill-formed type *)
let dummy_label =
  { lbl_name = ""; lbl_res = none; lbl_arg = none; lbl_mut = Immutable;
    lbl_pos = (-1); lbl_all = [||]; lbl_repres = Record_regular;
    lbl_private = Public;
    lbl_loc = Location.none;
    lbl_attributes = [];
  }

let label_descrs ty_res lbls repres priv =
  let all_labels = Array.make (List.length lbls) dummy_label in
  let rec describe_labels num = function
      [] -> []
    | l :: rest ->
        let lbl =
          { lbl_name = Ident.name l.ld_id;
            lbl_res = ty_res;
            lbl_arg = l.ld_type;
            lbl_mut = l.ld_mutable;
            lbl_pos = num;
            lbl_all = all_labels;
            lbl_repres = repres;
            lbl_private = priv;
            lbl_loc = l.ld_loc;
            lbl_attributes = l.ld_attributes;
          } in
        all_labels.(num) <- lbl;
        (l.ld_id, lbl) :: describe_labels (num+1) rest in
  describe_labels 0 lbls

exception Constr_not_found

let rec find_constr tag num_const num_nonconst = function
    [] ->
      raise Constr_not_found
  | {cd_args = []; _} as c  :: rem ->
      if tag = Cstr_constant num_const
      then c
      else find_constr tag (num_const + 1) num_nonconst rem
  | c :: rem ->
      if tag = Cstr_block num_nonconst
      then c
      else find_constr tag num_const (num_nonconst + 1) rem

let find_constr_by_tag tag cstrlist =
  find_constr tag 0 0 cstrlist

end
module Predef : sig
(*#1 "predef.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Predefined type constructors (with special typing rules in typecore) *)

open Types

val type_int: type_expr
val type_char: type_expr
val type_string: type_expr
val type_bytes: type_expr
val type_float: type_expr
val type_bool: type_expr
val type_unit: type_expr
val type_exn: type_expr
val type_array: type_expr -> type_expr
val type_list: type_expr -> type_expr
val type_option: type_expr -> type_expr
val type_nativeint: type_expr
val type_int32: type_expr
val type_int64: type_expr
val type_lazy_t: type_expr -> type_expr

val path_int: Path.t
val path_char: Path.t
val path_string: Path.t
val path_bytes: Path.t
val path_float: Path.t
val path_bool: Path.t
val path_unit: Path.t
val path_exn: Path.t
val path_array: Path.t
val path_list: Path.t
val path_option: Path.t
val path_nativeint: Path.t
val path_int32: Path.t
val path_int64: Path.t
val path_lazy_t: Path.t

val path_match_failure: Path.t
val path_assert_failure : Path.t
val path_undefined_recursive_module : Path.t

(* To build the initial environment. Since there is a nasty mutual
   recursion between predef and env, we break it by parameterizing
   over Env.t, Env.add_type and Env.add_extension. *)

val build_initial_env:
  (Ident.t -> type_declaration -> 'a -> 'a) ->
  (Ident.t -> extension_constructor -> 'a -> 'a) ->
  'a -> 'a * 'a

(* To initialize linker tables *)

val builtin_values: (string * Ident.t) list
val builtin_idents: (string * Ident.t) list


val type_is_builtin_path_but_option : Path.t -> bool

end = struct
(*#1 "predef.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Predefined type constructors (with special typing rules in typecore) *)

open Path
open Types
open Btype

let builtin_idents = ref []

let wrap create s =
  let id = create s in
  builtin_idents := (s, id) :: !builtin_idents;
  id

let ident_create = wrap Ident.create
let ident_create_predef_exn = wrap Ident.create_predef_exn


let ident_int = ident_create "int"
and ident_char = ident_create "char"
and ident_string = ident_create "string"
and ident_float = ident_create "float"
and ident_bool = ident_create "bool"
and ident_unit = ident_create "unit"
and ident_exn = ident_create "exn"
and ident_array = ident_create "array"
and ident_list = ident_create "list"
and ident_option = ident_create "option"
and ident_nativeint = ident_create "nativeint"
and ident_int32 = ident_create "int32"
and ident_int64 = ident_create "int64"
and ident_lazy_t = ident_create "lazy_t"
and ident_bytes = ident_create "bytes"


let type_is_builtin_path_but_option p =
  match p with
  | Pident {stamp} ->
      stamp >= ident_int.stamp
      && stamp  <= ident_bytes.stamp
      && (stamp <> ident_option.stamp)
  | _ -> false

let path_int = Pident ident_int
and path_char = Pident ident_char
and path_string = Pident ident_string
and path_float = Pident ident_float
and path_bool = Pident ident_bool
and path_unit = Pident ident_unit
and path_exn = Pident ident_exn
and path_array = Pident ident_array
and path_list = Pident ident_list
and path_option = Pident ident_option
and path_nativeint = Pident ident_nativeint
and path_int32 = Pident ident_int32
and path_int64 = Pident ident_int64
and path_lazy_t = Pident ident_lazy_t
and path_bytes = Pident ident_bytes

let type_int = newgenty (Tconstr(path_int, [], ref Mnil))
and type_char = newgenty (Tconstr(path_char, [], ref Mnil))
and type_string = newgenty (Tconstr(path_string, [], ref Mnil))
and type_float = newgenty (Tconstr(path_float, [], ref Mnil))
and type_bool = newgenty (Tconstr(path_bool, [], ref Mnil))
and type_unit = newgenty (Tconstr(path_unit, [], ref Mnil))
and type_exn = newgenty (Tconstr(path_exn, [], ref Mnil))
and type_array t = newgenty (Tconstr(path_array, [t], ref Mnil))
and type_list t = newgenty (Tconstr(path_list, [t], ref Mnil))
and type_option t = newgenty (Tconstr(path_option, [t], ref Mnil))
and type_nativeint = newgenty (Tconstr(path_nativeint, [], ref Mnil))
and type_int32 = newgenty (Tconstr(path_int32, [], ref Mnil))
and type_int64 = newgenty (Tconstr(path_int64, [], ref Mnil))
and type_lazy_t t = newgenty (Tconstr(path_lazy_t, [t], ref Mnil))
and type_bytes = newgenty (Tconstr(path_bytes, [], ref Mnil))

let ident_match_failure = ident_create_predef_exn "Match_failure"
and ident_out_of_memory = ident_create_predef_exn "Out_of_memory"
and ident_invalid_argument = ident_create_predef_exn "Invalid_argument"
and ident_failure = ident_create_predef_exn "Failure"
and ident_not_found = ident_create_predef_exn "Not_found"
and ident_sys_error = ident_create_predef_exn "Sys_error"
and ident_end_of_file = ident_create_predef_exn "End_of_file"
and ident_division_by_zero = ident_create_predef_exn "Division_by_zero"
and ident_stack_overflow = ident_create_predef_exn "Stack_overflow"
and ident_sys_blocked_io = ident_create_predef_exn "Sys_blocked_io"
and ident_assert_failure = ident_create_predef_exn "Assert_failure"
and ident_undefined_recursive_module =
        ident_create_predef_exn "Undefined_recursive_module"

let path_match_failure = Pident ident_match_failure
and path_assert_failure = Pident ident_assert_failure
and path_undefined_recursive_module = Pident ident_undefined_recursive_module

let decl_abstr =
  {type_params = [];
   type_arity = 0;
   type_kind = Type_abstract;
   type_loc = Location.none;
   type_private = Asttypes.Public;
   type_manifest = None;
   type_variance = [];
   type_newtype_level = None;
   type_attributes = [];
  }

let cstr id args =
  {
    cd_id = id;
    cd_args = args;
    cd_res = None;
    cd_loc = Location.none;
    cd_attributes = [];
  }

let ident_false = ident_create "false"
and ident_true = ident_create "true"
and ident_void = ident_create "()"
and ident_nil = ident_create "[]"
and ident_cons = ident_create "::"
and ident_none = ident_create "None"
and ident_some = ident_create "Some"
let common_initial_env add_type add_extension empty_env =
  let decl_bool =
    {decl_abstr with
     type_kind = Type_variant([cstr ident_false []; cstr ident_true []])}
  and decl_unit =
    {decl_abstr with
     type_kind = Type_variant([cstr ident_void []])}
  and decl_exn =
    {decl_abstr with
     type_kind = Type_open}
  and decl_array =
    let tvar = newgenvar() in
    {decl_abstr with
     type_params = [tvar];
     type_arity = 1;
     type_variance = [Variance.full]}
  and decl_list =
    let tvar = newgenvar() in
    {decl_abstr with
     type_params = [tvar];
     type_arity = 1;
     type_kind =
     Type_variant([cstr ident_nil []; cstr ident_cons [tvar; type_list tvar]]);
     type_variance = [Variance.covariant]}
  and decl_option =
    let tvar = newgenvar() in
    {decl_abstr with
     type_params = [tvar];
     type_arity = 1;
     type_kind = Type_variant([cstr ident_none []; cstr ident_some [tvar]]);
     type_variance = [Variance.covariant]}
  and decl_lazy_t =
    let tvar = newgenvar() in
    {decl_abstr with
     type_params = [tvar];
     type_arity = 1;
     type_variance = [Variance.covariant]}
  in

  let add_extension id l =
    add_extension id
      { ext_type_path = path_exn;
        ext_type_params = [];
        ext_args = l;
        ext_ret_type = None;
        ext_private = Asttypes.Public;
        ext_loc = Location.none;
        ext_attributes = [] }
  in
  add_extension ident_match_failure
                         [newgenty (Ttuple[type_string; type_int; type_int])] (
  add_extension ident_out_of_memory [] (
  add_extension ident_stack_overflow [] (
  add_extension ident_invalid_argument [type_string] (
  add_extension ident_failure [type_string] (
  add_extension ident_not_found [] (
  add_extension ident_sys_blocked_io [] (
  add_extension ident_sys_error [type_string] (
  add_extension ident_end_of_file [] (
  add_extension ident_division_by_zero [] (
  add_extension ident_assert_failure
                         [newgenty (Ttuple[type_string; type_int; type_int])] (
  add_extension ident_undefined_recursive_module
                         [newgenty (Ttuple[type_string; type_int; type_int])] (
  add_type ident_int64 decl_abstr (
  add_type ident_int32 decl_abstr (
  add_type ident_nativeint decl_abstr (
  add_type ident_lazy_t decl_lazy_t (
  add_type ident_option decl_option (
  add_type ident_list decl_list (
  add_type ident_array decl_array (
  add_type ident_exn decl_exn (
  add_type ident_unit decl_unit (
  add_type ident_bool decl_bool (
  add_type ident_float decl_abstr (
  add_type ident_string decl_abstr (
  add_type ident_char decl_abstr (
  add_type ident_int decl_abstr (
    empty_env))))))))))))))))))))))))))

let build_initial_env add_type add_exception empty_env =
  let common = common_initial_env add_type add_exception empty_env in
  let safe_string = add_type ident_bytes decl_abstr common in
  let decl_bytes_unsafe = {decl_abstr with type_manifest = Some type_string} in
  let unsafe_string = add_type ident_bytes decl_bytes_unsafe common in
  (safe_string, unsafe_string)

let builtin_values =
  List.map (fun id -> Ident.make_global id; (Ident.name id, id))
      [ident_match_failure; ident_out_of_memory; ident_stack_overflow;
       ident_invalid_argument;
       ident_failure; ident_not_found; ident_sys_error; ident_end_of_file;
       ident_division_by_zero; ident_sys_blocked_io;
       ident_assert_failure; ident_undefined_recursive_module ]

(* Start non-predef identifiers at 1000.  This way, more predefs can
   be defined in this file (above!) without breaking .cmi
   compatibility. *)

let _ = Ident.set_current_time 999
let builtin_idents = List.rev !builtin_idents

end
module Docstrings : sig
(*#1 "docstrings.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*                              Leo White                              *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(** (Re)Initialise all docstring state *)
val init : unit -> unit

(** Emit warnings for unattached and ambiguous docstrings *)
val warn_bad_docstrings : unit -> unit

(** {3 Docstrings} *)

(** Documentation comments *)
type docstring

(** Create a docstring *)
val docstring : string -> Location.t -> docstring

(** Get the text of a docstring *)
val docstring_body : docstring -> string

(** Get the location of a docstring *)
val docstring_loc : docstring -> Location.t

(** {3 Set functions}

   These functions are used by the lexer to associate docstrings to
   the locations of tokens. *)

(** Docstrings immediately preceding a token *)
val set_pre_docstrings : Lexing.position -> docstring list -> unit

(** Docstrings immediately following a token *)
val set_post_docstrings : Lexing.position -> docstring list -> unit

(** Docstrings not immediately adjacent to a token *)
val set_floating_docstrings : Lexing.position -> docstring list -> unit

(** Docstrings immediately following the token which precedes this one *)
val set_pre_extra_docstrings : Lexing.position -> docstring list -> unit

(** Docstrings immediately preceding the token which follows this one *)
val set_post_extra_docstrings : Lexing.position -> docstring list -> unit

(** {3 Items}

    The {!docs} type represents documentation attached to an item. *)

type docs =
  { docs_pre: docstring option;
    docs_post: docstring option; }

val empty_docs : docs

val docs_attr : docstring -> Parsetree.attribute

(** Convert item documentation to attributes and add them to an
    attribute list *)
val add_docs_attrs : docs -> Parsetree.attributes -> Parsetree.attributes

(** Fetch the item documentation for the current symbol. This also
    marks this documentation (for ambiguity warnings). *)
val symbol_docs : unit -> docs
val symbol_docs_lazy : unit -> docs Lazy.t

(** Fetch the item documentation for the symbols between two
    positions. This also marks this documentation (for ambiguity
    warnings). *)
val rhs_docs : int -> int -> docs
val rhs_docs_lazy : int -> int -> docs Lazy.t

(** Mark the item documentation for the current symbol (for ambiguity
    warnings). *)
val mark_symbol_docs : unit -> unit

(** Mark as associated the item documentation for the symbols between
    two positions (for ambiguity warnings) *)
val mark_rhs_docs : int -> int -> unit

(** {3 Fields and constructors}

    The {!info} type represents documentation attached to a field or
    constructor. *)

type info = docstring option

val empty_info : info

val info_attr : docstring -> Parsetree.attribute

(** Convert field info to attributes and add them to an
    attribute list *)
val add_info_attrs : info -> Parsetree.attributes -> Parsetree.attributes

(** Fetch the field info for the current symbol. *)
val symbol_info : unit -> info

(** Fetch the field info following the symbol at a given position. *)
val rhs_info : int -> info

(** {3 Unattached comments}

    The {!text} type represents documentation which is not attached to
    anything. *)

type text = docstring list

val empty_text : text

val text_attr : docstring -> Parsetree.attribute

(** Convert text to attributes and add them to an attribute list *)
val add_text_attrs : text -> Parsetree.attributes -> Parsetree.attributes

(** Fetch the text preceding the current symbol. *)
val symbol_text : unit -> text
val symbol_text_lazy : unit -> text Lazy.t

(** Fetch the text preceding the symbol at the given position. *)
val rhs_text : int -> text
val rhs_text_lazy : int -> text Lazy.t

(** {3 Extra text}

    There may be additional text attached to the delimiters of a block
    (e.g. [struct] and [end]). This is fetched by the following
    functions, which are applied to the contents of the block rather
    than the delimiters. *)

(** Fetch additional text preceding the current symbol *)
val symbol_pre_extra_text : unit -> text

(** Fetch additional text following the current symbol *)
val symbol_post_extra_text : unit -> text

(** Fetch additional text preceding the symbol at the given position *)
val rhs_pre_extra_text : int -> text

(** Fetch additional text following the symbol at the given position *)
val rhs_post_extra_text : int -> text

end = struct
(*#1 "docstrings.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*                              Leo White                              *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Location

(* Docstrings *)

(* A docstring is "attached" if it has been inserted in the AST. This
   is used for generating unexpected docstring warnings. *)
type ds_attached =
  | Unattached   (* Not yet attached anything.*)
  | Info         (* Attached to a field or constructor. *)
  | Docs         (* Attached to an item or as floating text. *)

(* A docstring is "associated" with an item if there are no blank lines between
   them. This is used for generating docstring ambiguity warnings. *)
type ds_associated =
  | Zero             (* Not associated with an item *)
  | One              (* Associated with one item *)
  | Many             (* Associated with multiple items (ambiguity) *)

type docstring =
  { ds_body: string;
    ds_loc: Location.t;
    mutable ds_attached: ds_attached;
    mutable ds_associated: ds_associated; }

(* List of docstrings *)

let docstrings : docstring list ref = ref []

(* Warn for unused and ambiguous docstrings *)

let warn_bad_docstrings () =
  if Warnings.is_active (Warnings.Bad_docstring true) then begin
    List.iter
      (fun ds ->
         match ds.ds_attached with
         | Info -> ()
         | Unattached ->
           prerr_warning ds.ds_loc (Warnings.Bad_docstring true)
         | Docs ->
             match ds.ds_associated with
             | Zero | One -> ()
             | Many ->
               prerr_warning ds.ds_loc (Warnings.Bad_docstring false))
      (List.rev !docstrings)
end

(* Docstring constructors and descturctors *)

let docstring body loc =
  let ds =
    { ds_body = body;
      ds_loc = loc;
      ds_attached = Unattached;
      ds_associated = Zero; }
  in
  docstrings := ds :: !docstrings;
  ds

let docstring_body ds = ds.ds_body

let docstring_loc ds = ds.ds_loc

(* Docstrings attached to items *)

type docs =
  { docs_pre: docstring option;
    docs_post: docstring option; }

let empty_docs = { docs_pre = None; docs_post = None }

let doc_loc = {txt = "ocaml.doc"; loc = Location.none}

let docs_attr ds =
  let open Asttypes in
  let open Parsetree in
  let exp =
    { pexp_desc = Pexp_constant (Const_string(ds.ds_body, None));
      pexp_loc = ds.ds_loc;
      pexp_attributes = []; }
  in
  let item =
    { pstr_desc = Pstr_eval (exp, []); pstr_loc = exp.pexp_loc }
  in
    (doc_loc, PStr [item])

let add_docs_attrs docs attrs =
  let attrs =
    match docs.docs_pre with
    | None -> attrs
    | Some ds -> docs_attr ds :: attrs
  in
  let attrs =
    match docs.docs_post with
    | None -> attrs
    | Some ds -> attrs @ [docs_attr ds]
  in
  attrs

(* Docstrings attached to consturctors or fields *)

type info = docstring option

let empty_info = None

let info_attr = docs_attr

let add_info_attrs info attrs =
  let attrs =
    match info with
    | None -> attrs
    | Some ds -> attrs @ [info_attr ds]
  in
  attrs

(* Docstrings not attached to a specifc item *)

type text = docstring list

let empty_text = []

let text_loc = {txt = "ocaml.text"; loc = Location.none}

let text_attr ds =
  let open Asttypes in
  let open Parsetree in
  let exp =
    { pexp_desc = Pexp_constant (Const_string(ds.ds_body, None));
      pexp_loc = ds.ds_loc;
      pexp_attributes = []; }
  in
  let item =
    { pstr_desc = Pstr_eval (exp, []); pstr_loc = exp.pexp_loc }
  in
    (text_loc, PStr [item])

let add_text_attrs dsl attrs =
  (List.map text_attr dsl) @ attrs

(* Find the first non-info docstring in a list, attach it and return it *)
let get_docstring ~info dsl =
  let rec loop = function
    | [] -> None
    | {ds_attached = Info; _} :: rest -> loop rest
    | ds :: rest ->
        ds.ds_attached <- if info then Info else Docs;
        Some ds
  in
  loop dsl

(* Find all the non-info docstrings in a list, attach them and return them *)
let get_docstrings dsl =
  let rec loop acc = function
    | [] -> List.rev acc
    | {ds_attached = Info; _} :: rest -> loop acc rest
    | ds :: rest ->
        ds.ds_attached <- Docs;
        loop (ds :: acc) rest
  in
    loop [] dsl

(* "Associate" all the docstrings in a list *)
let associate_docstrings dsl =
  List.iter
    (fun ds ->
       match ds.ds_associated with
       | Zero -> ds.ds_associated <- One
       | (One | Many) -> ds.ds_associated <- Many)
    dsl

(* Map from positions to pre docstrings *)

let pre_table : (Lexing.position, docstring list) Hashtbl.t =
  Hashtbl.create 50

let set_pre_docstrings pos dsl =
  if dsl <> [] then Hashtbl.add pre_table pos dsl

let get_pre_docs pos =
  try
    let dsl = Hashtbl.find pre_table pos in
      associate_docstrings dsl;
      get_docstring ~info:false dsl
  with Not_found -> None

let mark_pre_docs pos =
  try
    let dsl = Hashtbl.find pre_table pos in
      associate_docstrings dsl
  with Not_found -> ()

(* Map from positions to post docstrings *)

let post_table : (Lexing.position, docstring list) Hashtbl.t =
  Hashtbl.create 50

let set_post_docstrings pos dsl =
  if dsl <> [] then Hashtbl.add post_table pos dsl

let get_post_docs pos =
  try
    let dsl = Hashtbl.find post_table pos in
      associate_docstrings dsl;
      get_docstring ~info:false dsl
  with Not_found -> None

let mark_post_docs pos =
  try
    let dsl = Hashtbl.find post_table pos in
      associate_docstrings dsl
  with Not_found -> ()

let get_info pos =
  try
    let dsl = Hashtbl.find post_table pos in
      get_docstring ~info:true dsl
  with Not_found -> None

(* Map from positions to floating docstrings *)

let floating_table : (Lexing.position, docstring list) Hashtbl.t =
  Hashtbl.create 50

let set_floating_docstrings pos dsl =
  if dsl <> [] then Hashtbl.add floating_table pos dsl

let get_text pos =
  try
    let dsl = Hashtbl.find floating_table pos in
      get_docstrings dsl
  with Not_found -> []

(* Maps from positions to extra docstrings *)

let pre_extra_table : (Lexing.position, docstring list) Hashtbl.t =
  Hashtbl.create 50

let set_pre_extra_docstrings pos dsl =
  if dsl <> [] then Hashtbl.add pre_extra_table pos dsl

let get_pre_extra_text pos =
  try
    let dsl = Hashtbl.find pre_extra_table pos in
      get_docstrings dsl
  with Not_found -> []

let post_extra_table : (Lexing.position, docstring list) Hashtbl.t =
  Hashtbl.create 50

let set_post_extra_docstrings pos dsl =
  if dsl <> [] then Hashtbl.add post_extra_table pos dsl

let get_post_extra_text pos =
  try
    let dsl = Hashtbl.find post_extra_table pos in
      get_docstrings dsl
  with Not_found -> []

(* Docstrings from parser actions *)

let symbol_docs () =
  { docs_pre = get_pre_docs (Parsing.symbol_start_pos ());
    docs_post = get_post_docs (Parsing.symbol_end_pos ()); }

let symbol_docs_lazy () =
  let p1 = Parsing.symbol_start_pos () in
  let p2 = Parsing.symbol_end_pos () in
    lazy { docs_pre = get_pre_docs p1;
           docs_post = get_post_docs p2; }

let rhs_docs pos1 pos2 =
  { docs_pre = get_pre_docs (Parsing.rhs_start_pos pos1);
    docs_post = get_post_docs (Parsing.rhs_end_pos pos2); }

let rhs_docs_lazy pos1 pos2 =
  let p1 = Parsing.rhs_start_pos pos1 in
  let p2 = Parsing.rhs_end_pos pos2 in
    lazy { docs_pre = get_pre_docs p1;
           docs_post = get_post_docs p2; }

let mark_symbol_docs () =
  mark_pre_docs (Parsing.symbol_start_pos ());
  mark_post_docs (Parsing.symbol_end_pos ())

let mark_rhs_docs pos1 pos2 =
  mark_pre_docs (Parsing.rhs_start_pos pos1);
  mark_post_docs (Parsing.rhs_end_pos pos2)

let symbol_info () =
  get_info (Parsing.symbol_end_pos ())

let rhs_info pos =
  get_info (Parsing.rhs_end_pos pos)

let symbol_text () =
  get_text (Parsing.symbol_start_pos ())

let symbol_text_lazy () =
  let pos = Parsing.symbol_start_pos () in
    lazy (get_text pos)

let rhs_text pos =
  get_text (Parsing.rhs_start_pos pos)

let rhs_text_lazy pos =
  let pos = Parsing.rhs_start_pos pos in
    lazy (get_text pos)

let symbol_pre_extra_text () =
  get_pre_extra_text (Parsing.symbol_start_pos ())

let symbol_post_extra_text () =
  get_post_extra_text (Parsing.symbol_end_pos ())

let rhs_pre_extra_text pos =
  get_pre_extra_text (Parsing.rhs_start_pos pos)

let rhs_post_extra_text pos =
  get_post_extra_text (Parsing.rhs_end_pos pos)


(* (Re)Initialise all comment state *)

let init () =
  docstrings := [];
  Hashtbl.reset pre_table;
  Hashtbl.reset post_table;
  Hashtbl.reset floating_table;
  Hashtbl.reset pre_extra_table;
  Hashtbl.reset post_extra_table




end
module Ast_helper : sig
(*#1 "ast_helper.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*                        Alain Frisch, LexiFi                         *)
(*                                                                     *)
(*  Copyright 2012 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(** Helpers to produce Parsetree fragments *)

open Parsetree
open Asttypes
open Docstrings

type lid = Longident.t loc
type str = string loc
type loc = Location.t
type attrs = attribute list

(** {2 Default locations} *)

val default_loc: loc ref
    (** Default value for all optional location arguments. *)

val with_default_loc: loc -> (unit -> 'a) -> 'a
    (** Set the [default_loc] within the scope of the execution
        of the provided function. *)

(** {2 Core language} *)

(** Type expressions *)
module Typ :
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> core_type_desc -> core_type
    val attr: core_type -> attribute -> core_type

    val any: ?loc:loc -> ?attrs:attrs -> unit -> core_type
    val var: ?loc:loc -> ?attrs:attrs -> string -> core_type
    val arrow: ?loc:loc -> ?attrs:attrs -> label -> core_type -> core_type
               -> core_type
    val tuple: ?loc:loc -> ?attrs:attrs -> core_type list -> core_type
    val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type
    val object_: ?loc:loc -> ?attrs:attrs ->
                  (string * attributes * core_type) list -> closed_flag ->
                  core_type
    val class_: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type
    val alias: ?loc:loc -> ?attrs:attrs -> core_type -> string -> core_type
    val variant: ?loc:loc -> ?attrs:attrs -> row_field list -> closed_flag
                 -> label list option -> core_type
    val poly: ?loc:loc -> ?attrs:attrs -> string list -> core_type -> core_type
    val package: ?loc:loc -> ?attrs:attrs -> lid -> (lid * core_type) list
                 -> core_type
    val extension: ?loc:loc -> ?attrs:attrs -> extension -> core_type

    val force_poly: core_type -> core_type
  end

(** Patterns *)
module Pat:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> pattern_desc -> pattern
    val attr:pattern -> attribute -> pattern

    val any: ?loc:loc -> ?attrs:attrs -> unit -> pattern
    val var: ?loc:loc -> ?attrs:attrs -> str -> pattern
    val alias: ?loc:loc -> ?attrs:attrs -> pattern -> str -> pattern
    val constant: ?loc:loc -> ?attrs:attrs -> constant -> pattern
    val interval: ?loc:loc -> ?attrs:attrs -> constant -> constant -> pattern
    val tuple: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern
    val construct: ?loc:loc -> ?attrs:attrs -> lid -> pattern option -> pattern
    val variant: ?loc:loc -> ?attrs:attrs -> label -> pattern option -> pattern
    val record: ?loc:loc -> ?attrs:attrs -> (lid * pattern) list -> closed_flag
                -> pattern
    val array: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern
    val or_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern -> pattern
    val constraint_: ?loc:loc -> ?attrs:attrs -> pattern -> core_type -> pattern
    val type_: ?loc:loc -> ?attrs:attrs -> lid -> pattern
    val lazy_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern
    val unpack: ?loc:loc -> ?attrs:attrs -> str -> pattern
    val exception_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern
    val extension: ?loc:loc -> ?attrs:attrs -> extension -> pattern
  end

(** Expressions *)
module Exp:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> expression_desc -> expression
    val attr: expression -> attribute -> expression

    val ident: ?loc:loc -> ?attrs:attrs -> lid -> expression
    val constant: ?loc:loc -> ?attrs:attrs -> constant -> expression
    val let_: ?loc:loc -> ?attrs:attrs -> rec_flag -> value_binding list
              -> expression -> expression
    val fun_: ?loc:loc -> ?attrs:attrs -> label -> expression option -> pattern
              -> expression -> expression
    val function_: ?loc:loc -> ?attrs:attrs -> case list -> expression
    val apply: ?loc:loc -> ?attrs:attrs -> expression
               -> (label * expression) list -> expression
    val match_: ?loc:loc -> ?attrs:attrs -> expression -> case list
                -> expression
    val try_: ?loc:loc -> ?attrs:attrs -> expression -> case list -> expression
    val tuple: ?loc:loc -> ?attrs:attrs -> expression list -> expression
    val construct: ?loc:loc -> ?attrs:attrs -> lid -> expression option
                   -> expression
    val variant: ?loc:loc -> ?attrs:attrs -> label -> expression option
                 -> expression
    val record: ?loc:loc -> ?attrs:attrs -> (lid * expression) list
                -> expression option -> expression
    val field: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression
    val setfield: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression
                  -> expression
    val array: ?loc:loc -> ?attrs:attrs -> expression list -> expression
    val ifthenelse: ?loc:loc -> ?attrs:attrs -> expression -> expression
                    -> expression option -> expression
    val sequence: ?loc:loc -> ?attrs:attrs -> expression -> expression
                  -> expression
    val while_: ?loc:loc -> ?attrs:attrs -> expression -> expression
                -> expression
    val for_: ?loc:loc -> ?attrs:attrs -> pattern -> expression -> expression
              -> direction_flag -> expression -> expression
    val coerce: ?loc:loc -> ?attrs:attrs -> expression -> core_type option
                -> core_type -> expression
    val constraint_: ?loc:loc -> ?attrs:attrs -> expression -> core_type
                     -> expression
    val send: ?loc:loc -> ?attrs:attrs -> expression -> string -> expression
    val new_: ?loc:loc -> ?attrs:attrs -> lid -> expression
    val setinstvar: ?loc:loc -> ?attrs:attrs -> str -> expression -> expression
    val override: ?loc:loc -> ?attrs:attrs -> (str * expression) list
                  -> expression
    val letmodule: ?loc:loc -> ?attrs:attrs -> str -> module_expr -> expression
                   -> expression
    val assert_: ?loc:loc -> ?attrs:attrs -> expression -> expression
    val lazy_: ?loc:loc -> ?attrs:attrs -> expression -> expression
    val poly: ?loc:loc -> ?attrs:attrs -> expression -> core_type option -> expression
    val object_: ?loc:loc -> ?attrs:attrs -> class_structure -> expression
    val newtype: ?loc:loc -> ?attrs:attrs -> string -> expression -> expression
    val pack: ?loc:loc -> ?attrs:attrs -> module_expr -> expression
    val open_: ?loc:loc -> ?attrs:attrs -> override_flag -> lid -> expression -> expression
    val extension: ?loc:loc -> ?attrs:attrs -> extension -> expression

    val case: pattern -> ?guard:expression -> expression -> case
  end

(** Value declarations *)
module Val:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->
      ?prim:string list -> str -> core_type -> value_description
  end

(** Type declarations *)
module Type:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
      ?params:(core_type * variance) list -> ?cstrs:(core_type * core_type * loc) list ->
      ?kind:type_kind -> ?priv:private_flag -> ?manifest:core_type -> str ->
      type_declaration

    val constructor: ?loc:loc -> ?attrs:attrs -> ?info:info ->
      ?args:core_type list -> ?res:core_type -> str -> constructor_declaration
    val field: ?loc:loc -> ?attrs:attrs -> ?info:info ->
      ?mut:mutable_flag -> str -> core_type -> label_declaration
  end

(** Type extensions *)
module Te:
  sig
    val mk: ?attrs:attrs -> ?docs:docs ->
      ?params:(core_type * variance) list -> ?priv:private_flag ->
      lid -> extension_constructor list -> type_extension

    val constructor: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
      str -> extension_constructor_kind -> extension_constructor

    val decl: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
      ?args:core_type list -> ?res:core_type -> str -> extension_constructor
    val rebind: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
      str -> lid -> extension_constructor
  end

(** {2 Module language} *)

(** Module type expressions *)
module Mty:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> module_type_desc -> module_type
    val attr: module_type -> attribute -> module_type

    val ident: ?loc:loc -> ?attrs:attrs -> lid -> module_type
    val alias: ?loc:loc -> ?attrs:attrs -> lid -> module_type
    val signature: ?loc:loc -> ?attrs:attrs -> signature -> module_type
    val functor_: ?loc:loc -> ?attrs:attrs ->
      str -> module_type option -> module_type -> module_type
    val with_: ?loc:loc -> ?attrs:attrs -> module_type -> with_constraint list -> module_type
    val typeof_: ?loc:loc -> ?attrs:attrs -> module_expr -> module_type
    val extension: ?loc:loc -> ?attrs:attrs -> extension -> module_type
  end

(** Module expressions *)
module Mod:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> module_expr_desc -> module_expr
    val attr: module_expr -> attribute -> module_expr

    val ident: ?loc:loc -> ?attrs:attrs -> lid -> module_expr
    val structure: ?loc:loc -> ?attrs:attrs -> structure -> module_expr
    val functor_: ?loc:loc -> ?attrs:attrs ->
      str -> module_type option -> module_expr -> module_expr
    val apply: ?loc:loc -> ?attrs:attrs -> module_expr -> module_expr -> module_expr
    val constraint_: ?loc:loc -> ?attrs:attrs -> module_expr -> module_type -> module_expr
    val unpack: ?loc:loc -> ?attrs:attrs -> expression -> module_expr
    val extension: ?loc:loc -> ?attrs:attrs -> extension -> module_expr
  end

(** Signature items *)
module Sig:
  sig
    val mk: ?loc:loc -> signature_item_desc -> signature_item

    val value: ?loc:loc -> value_description -> signature_item
    val type_: ?loc:loc -> type_declaration list -> signature_item
    val type_extension: ?loc:loc -> type_extension -> signature_item
    val exception_: ?loc:loc -> extension_constructor -> signature_item
    val module_: ?loc:loc -> module_declaration -> signature_item
    val rec_module: ?loc:loc -> module_declaration list -> signature_item
    val modtype: ?loc:loc -> module_type_declaration -> signature_item
    val open_: ?loc:loc -> open_description -> signature_item
    val include_: ?loc:loc -> include_description -> signature_item
    val class_: ?loc:loc -> class_description list -> signature_item
    val class_type: ?loc:loc -> class_type_declaration list -> signature_item
    val extension: ?loc:loc -> ?attrs:attrs -> extension -> signature_item
    val attribute: ?loc:loc -> attribute -> signature_item
    val text: text -> signature_item list
  end

(** Structure items *)
module Str:
  sig
    val mk: ?loc:loc -> structure_item_desc -> structure_item

    val eval: ?loc:loc -> ?attrs:attributes -> expression -> structure_item
    val value: ?loc:loc -> rec_flag -> value_binding list -> structure_item
    val primitive: ?loc:loc -> value_description -> structure_item
    val type_: ?loc:loc -> type_declaration list -> structure_item
    val type_extension: ?loc:loc -> type_extension -> structure_item
    val exception_: ?loc:loc -> extension_constructor -> structure_item
    val module_: ?loc:loc -> module_binding -> structure_item
    val rec_module: ?loc:loc -> module_binding list -> structure_item
    val modtype: ?loc:loc -> module_type_declaration -> structure_item
    val open_: ?loc:loc -> open_description -> structure_item
    val class_: ?loc:loc -> class_declaration list -> structure_item
    val class_type: ?loc:loc -> class_type_declaration list -> structure_item
    val include_: ?loc:loc -> include_declaration -> structure_item
    val extension: ?loc:loc -> ?attrs:attrs -> extension -> structure_item
    val attribute: ?loc:loc -> attribute -> structure_item
    val text: text -> structure_item list
  end

(** Module declarations *)
module Md:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
      str -> module_type -> module_declaration
  end

(** Module type declarations *)
module Mtd:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
      ?typ:module_type -> str -> module_type_declaration
  end

(** Module bindings *)
module Mb:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
      str -> module_expr -> module_binding
  end

(* Opens *)
module Opn:
  sig
    val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs ->
      ?override:override_flag -> lid -> open_description
  end

(* Includes *)
module Incl:
  sig
    val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs -> 'a -> 'a include_infos
  end

(** Value bindings *)

module Vb:
  sig
    val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
      pattern -> expression -> value_binding
  end


(** {2 Class language} *)

(** Class type expressions *)
module Cty:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> class_type_desc -> class_type
    val attr: class_type -> attribute -> class_type

    val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> class_type
    val signature: ?loc:loc -> ?attrs:attrs -> class_signature -> class_type
    val arrow: ?loc:loc -> ?attrs:attrs -> label -> core_type -> class_type -> class_type
    val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type
  end

(** Class type fields *)
module Ctf:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->
      class_type_field_desc -> class_type_field
    val attr: class_type_field -> attribute -> class_type_field

    val inherit_: ?loc:loc -> ?attrs:attrs -> class_type -> class_type_field
    val val_: ?loc:loc -> ?attrs:attrs -> string -> mutable_flag -> virtual_flag -> core_type -> class_type_field
    val method_: ?loc:loc -> ?attrs:attrs -> string -> private_flag -> virtual_flag -> core_type -> class_type_field
    val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type -> class_type_field
    val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type_field
    val attribute: ?loc:loc -> attribute -> class_type_field
    val text: text -> class_type_field list
  end

(** Class expressions *)
module Cl:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> class_expr_desc -> class_expr
    val attr: class_expr -> attribute -> class_expr

    val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> class_expr
    val structure: ?loc:loc -> ?attrs:attrs -> class_structure -> class_expr
    val fun_: ?loc:loc -> ?attrs:attrs -> label -> expression option -> pattern -> class_expr -> class_expr
    val apply: ?loc:loc -> ?attrs:attrs -> class_expr -> (label * expression) list -> class_expr
    val let_: ?loc:loc -> ?attrs:attrs -> rec_flag -> value_binding list -> class_expr -> class_expr
    val constraint_: ?loc:loc -> ?attrs:attrs -> class_expr -> class_type -> class_expr
    val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_expr
  end

(** Class fields *)
module Cf:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> class_field_desc -> class_field
    val attr: class_field -> attribute -> class_field

    val inherit_: ?loc:loc -> ?attrs:attrs -> override_flag -> class_expr -> string option -> class_field
    val val_: ?loc:loc -> ?attrs:attrs -> str -> mutable_flag -> class_field_kind -> class_field
    val method_: ?loc:loc -> ?attrs:attrs -> str -> private_flag -> class_field_kind -> class_field
    val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type -> class_field
    val initializer_: ?loc:loc -> ?attrs:attrs -> expression -> class_field
    val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_field
    val attribute: ?loc:loc -> attribute -> class_field
    val text: text -> class_field list

    val virtual_: core_type -> class_field_kind
    val concrete: override_flag -> expression -> class_field_kind

  end

(** Classes *)
module Ci:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
      ?virt:virtual_flag -> ?params:(core_type * variance) list ->
      str -> 'a -> 'a class_infos
  end

(** Class signatures *)
module Csig:
  sig
    val mk: core_type -> class_type_field list -> class_signature
  end

(** Class structures *)
module Cstr:
  sig
    val mk: pattern -> class_field list -> class_structure
  end

end = struct
(*#1 "ast_helper.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*                        Alain Frisch, LexiFi                         *)
(*                                                                     *)
(*  Copyright 2012 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(** Helpers to produce Parsetree fragments *)

open Asttypes
open Parsetree
open Docstrings

type lid = Longident.t loc
type str = string loc
type loc = Location.t
type attrs = attribute list

let default_loc = ref Location.none

let with_default_loc l f =
  let old = !default_loc in
  default_loc := l;
  try let r = f () in default_loc := old; r
  with exn -> default_loc := old; raise exn

module Typ = struct
  let mk ?(loc = !default_loc) ?(attrs = []) d =
    {ptyp_desc = d; ptyp_loc = loc; ptyp_attributes = attrs}
  let attr d a = {d with ptyp_attributes = d.ptyp_attributes @ [a]}

  let any ?loc ?attrs () = mk ?loc ?attrs Ptyp_any
  let var ?loc ?attrs a = mk ?loc ?attrs (Ptyp_var a)
  let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_arrow (a, b, c))
  let tuple ?loc ?attrs a = mk ?loc ?attrs (Ptyp_tuple a)
  let constr ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_constr (a, b))
  let object_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_object (a, b))
  let class_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_class (a, b))
  let alias ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_alias (a, b))
  let variant ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_variant (a, b, c))
  let poly ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_poly (a, b))
  let package ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_package (a, b))
  let extension ?loc ?attrs a = mk ?loc ?attrs (Ptyp_extension a)

  let force_poly t =
    match t.ptyp_desc with
    | Ptyp_poly _ -> t
    | _ -> poly ~loc:t.ptyp_loc [] t (* -> ghost? *)
end

module Pat = struct
  let mk ?(loc = !default_loc) ?(attrs = []) d =
    {ppat_desc = d; ppat_loc = loc; ppat_attributes = attrs}
  let attr d a = {d with ppat_attributes = d.ppat_attributes @ [a]}

  let any ?loc ?attrs () = mk ?loc ?attrs Ppat_any
  let var ?loc ?attrs a = mk ?loc ?attrs (Ppat_var a)
  let alias ?loc ?attrs a b = mk ?loc ?attrs (Ppat_alias (a, b))
  let constant ?loc ?attrs a = mk ?loc ?attrs (Ppat_constant a)
  let interval ?loc ?attrs a b = mk ?loc ?attrs (Ppat_interval (a, b))
  let tuple ?loc ?attrs a = mk ?loc ?attrs (Ppat_tuple a)
  let construct ?loc ?attrs a b = mk ?loc ?attrs (Ppat_construct (a, b))
  let variant ?loc ?attrs a b = mk ?loc ?attrs (Ppat_variant (a, b))
  let record ?loc ?attrs a b = mk ?loc ?attrs (Ppat_record (a, b))
  let array ?loc ?attrs a = mk ?loc ?attrs (Ppat_array a)
  let or_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_or (a, b))
  let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_constraint (a, b))
  let type_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_type a)
  let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_lazy a)
  let unpack ?loc ?attrs a = mk ?loc ?attrs (Ppat_unpack a)
  let exception_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_exception a)
  let extension ?loc ?attrs a = mk ?loc ?attrs (Ppat_extension a)
end

module Exp = struct
  let mk ?(loc = !default_loc) ?(attrs = []) d =
    {pexp_desc = d; pexp_loc = loc; pexp_attributes = attrs}
  let attr d a = {d with pexp_attributes = d.pexp_attributes @ [a]}

  let ident ?loc ?attrs a = mk ?loc ?attrs (Pexp_ident a)
  let constant ?loc ?attrs a = mk ?loc ?attrs (Pexp_constant a)
  let let_ ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_let (a, b, c))
  let fun_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pexp_fun (a, b, c, d))
  let function_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_function a)
  let apply ?loc ?attrs a b = mk ?loc ?attrs (Pexp_apply (a, b))
  let match_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_match (a, b))
  let try_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_try (a, b))
  let tuple ?loc ?attrs a = mk ?loc ?attrs (Pexp_tuple a)
  let construct ?loc ?attrs a b = mk ?loc ?attrs (Pexp_construct (a, b))
  let variant ?loc ?attrs a b = mk ?loc ?attrs (Pexp_variant (a, b))
  let record ?loc ?attrs a b = mk ?loc ?attrs (Pexp_record (a, b))
  let field ?loc ?attrs a b = mk ?loc ?attrs (Pexp_field (a, b))
  let setfield ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_setfield (a, b, c))
  let array ?loc ?attrs a = mk ?loc ?attrs (Pexp_array a)
  let ifthenelse ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_ifthenelse (a, b, c))
  let sequence ?loc ?attrs a b = mk ?loc ?attrs (Pexp_sequence (a, b))
  let while_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_while (a, b))
  let for_ ?loc ?attrs a b c d e = mk ?loc ?attrs (Pexp_for (a, b, c, d, e))
  let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_constraint (a, b))
  let coerce ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_coerce (a, b, c))
  let send ?loc ?attrs a b = mk ?loc ?attrs (Pexp_send (a, b))
  let new_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_new a)
  let setinstvar ?loc ?attrs a b = mk ?loc ?attrs (Pexp_setinstvar (a, b))
  let override ?loc ?attrs a = mk ?loc ?attrs (Pexp_override a)
  let letmodule ?loc ?attrs a b c= mk ?loc ?attrs (Pexp_letmodule (a, b, c))
  let assert_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_assert a)
  let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_lazy a)
  let poly ?loc ?attrs a b = mk ?loc ?attrs (Pexp_poly (a, b))
  let object_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_object a)
  let newtype ?loc ?attrs a b = mk ?loc ?attrs (Pexp_newtype (a, b))
  let pack ?loc ?attrs a = mk ?loc ?attrs (Pexp_pack a)
  let open_ ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_open (a, b, c))
  let extension ?loc ?attrs a = mk ?loc ?attrs (Pexp_extension a)

  let case lhs ?guard rhs =
    {
     pc_lhs = lhs;
     pc_guard = guard;
     pc_rhs = rhs;
    }
end

module Mty = struct
  let mk ?(loc = !default_loc) ?(attrs = []) d =
    {pmty_desc = d; pmty_loc = loc; pmty_attributes = attrs}
  let attr d a = {d with pmty_attributes = d.pmty_attributes @ [a]}

  let ident ?loc ?attrs a = mk ?loc ?attrs (Pmty_ident a)
  let alias ?loc ?attrs a = mk ?loc ?attrs (Pmty_alias a)
  let signature ?loc ?attrs a = mk ?loc ?attrs (Pmty_signature a)
  let functor_ ?loc ?attrs a b c = mk ?loc ?attrs (Pmty_functor (a, b, c))
  let with_ ?loc ?attrs a b = mk ?loc ?attrs (Pmty_with (a, b))
  let typeof_ ?loc ?attrs a = mk ?loc ?attrs (Pmty_typeof a)
  let extension ?loc ?attrs a = mk ?loc ?attrs (Pmty_extension a)
end

module Mod = struct
let mk ?(loc = !default_loc) ?(attrs = []) d =
  {pmod_desc = d; pmod_loc = loc; pmod_attributes = attrs}
  let attr d a = {d with pmod_attributes = d.pmod_attributes @ [a]}

  let ident ?loc ?attrs x = mk ?loc ?attrs (Pmod_ident x)
  let structure ?loc ?attrs x = mk ?loc ?attrs (Pmod_structure x)
  let functor_ ?loc ?attrs arg arg_ty body =
    mk ?loc ?attrs (Pmod_functor (arg, arg_ty, body))
  let apply ?loc ?attrs m1 m2 = mk ?loc ?attrs (Pmod_apply (m1, m2))
  let constraint_ ?loc ?attrs m mty = mk ?loc ?attrs (Pmod_constraint (m, mty))
  let unpack ?loc ?attrs e = mk ?loc ?attrs (Pmod_unpack e)
  let extension ?loc ?attrs a = mk ?loc ?attrs (Pmod_extension a)
end

module Sig = struct
  let mk ?(loc = !default_loc) d = {psig_desc = d; psig_loc = loc}

  let value ?loc a = mk ?loc (Psig_value a)
  let type_ ?loc a = mk ?loc (Psig_type a)
  let type_extension ?loc a = mk ?loc (Psig_typext a)
  let exception_ ?loc a = mk ?loc (Psig_exception a)
  let module_ ?loc a = mk ?loc (Psig_module a)
  let rec_module ?loc a = mk ?loc (Psig_recmodule a)
  let modtype ?loc a = mk ?loc (Psig_modtype a)
  let open_ ?loc a = mk ?loc (Psig_open a)
  let include_ ?loc a = mk ?loc (Psig_include a)
  let class_ ?loc a = mk ?loc (Psig_class a)
  let class_type ?loc a = mk ?loc (Psig_class_type a)
  let extension ?loc ?(attrs = []) a = mk ?loc (Psig_extension (a, attrs))
  let attribute ?loc a = mk ?loc (Psig_attribute a)
  let text txt =
    List.map
      (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
      txt
end

module Str = struct
  let mk ?(loc = !default_loc) d = {pstr_desc = d; pstr_loc = loc}

  let eval ?loc ?(attrs = []) a = mk ?loc (Pstr_eval (a, attrs))
  let value ?loc a b = mk ?loc (Pstr_value (a, b))
  let primitive ?loc a = mk ?loc (Pstr_primitive a)
  let type_ ?loc a = mk ?loc (Pstr_type a)
  let type_extension ?loc a = mk ?loc (Pstr_typext a)
  let exception_ ?loc a = mk ?loc (Pstr_exception a)
  let module_ ?loc a = mk ?loc (Pstr_module a)
  let rec_module ?loc a = mk ?loc (Pstr_recmodule a)
  let modtype ?loc a = mk ?loc (Pstr_modtype a)
  let open_ ?loc a = mk ?loc (Pstr_open a)
  let class_ ?loc a = mk ?loc (Pstr_class a)
  let class_type ?loc a = mk ?loc (Pstr_class_type a)
  let include_ ?loc a = mk ?loc (Pstr_include a)
  let extension ?loc ?(attrs = []) a = mk ?loc (Pstr_extension (a, attrs))
  let attribute ?loc a = mk ?loc (Pstr_attribute a)
  let text txt =
    List.map
      (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
      txt
end

module Cl = struct
  let mk ?(loc = !default_loc) ?(attrs = []) d =
    {
     pcl_desc = d;
     pcl_loc = loc;
     pcl_attributes = attrs;
    }
  let attr d a = {d with pcl_attributes = d.pcl_attributes @ [a]}

  let constr ?loc ?attrs a b = mk ?loc ?attrs (Pcl_constr (a, b))
  let structure ?loc ?attrs a = mk ?loc ?attrs (Pcl_structure a)
  let fun_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pcl_fun (a, b, c, d))
  let apply ?loc ?attrs a b = mk ?loc ?attrs (Pcl_apply (a, b))
  let let_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcl_let (a, b, c))
  let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pcl_constraint (a, b))
  let extension ?loc ?attrs a = mk ?loc ?attrs (Pcl_extension a)
end

module Cty = struct
  let mk ?(loc = !default_loc) ?(attrs = []) d =
    {
     pcty_desc = d;
     pcty_loc = loc;
     pcty_attributes = attrs;
    }
  let attr d a = {d with pcty_attributes = d.pcty_attributes @ [a]}

  let constr ?loc ?attrs a b = mk ?loc ?attrs (Pcty_constr (a, b))
  let signature ?loc ?attrs a = mk ?loc ?attrs (Pcty_signature a)
  let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Pcty_arrow (a, b, c))
  let extension ?loc ?attrs a = mk ?loc ?attrs (Pcty_extension a)
end

module Ctf = struct
  let mk ?(loc = !default_loc) ?(attrs = [])
           ?(docs = empty_docs) d =
    {
     pctf_desc = d;
     pctf_loc = loc;
     pctf_attributes = add_docs_attrs docs attrs;
    }

  let inherit_ ?loc ?attrs a = mk ?loc ?attrs (Pctf_inherit a)
  let val_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_val (a, b, c, d))
  let method_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_method (a, b, c, d))
  let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pctf_constraint (a, b))
  let extension ?loc ?attrs a = mk ?loc ?attrs (Pctf_extension a)
  let attribute ?loc a = mk ?loc (Pctf_attribute a)
  let text txt =
    List.map
      (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
      txt

  let attr d a = {d with pctf_attributes = d.pctf_attributes @ [a]}

end

module Cf = struct
  let mk ?(loc = !default_loc) ?(attrs = [])
        ?(docs = empty_docs) d =
    {
     pcf_desc = d;
     pcf_loc = loc;
     pcf_attributes = add_docs_attrs docs attrs;
    }

  let inherit_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_inherit (a, b, c))
  let val_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_val (a, b, c))
  let method_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_method (a, b, c))
  let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pcf_constraint (a, b))
  let initializer_ ?loc ?attrs a = mk ?loc ?attrs (Pcf_initializer a)
  let extension ?loc ?attrs a = mk ?loc ?attrs (Pcf_extension a)
  let attribute ?loc a = mk ?loc (Pcf_attribute a)
  let text txt =
    List.map
      (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
      txt

  let virtual_ ct = Cfk_virtual ct
  let concrete o e = Cfk_concrete (o, e)

  let attr d a = {d with pcf_attributes = d.pcf_attributes @ [a]}

end

module Val = struct
  let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
        ?(prim = []) name typ =
    {
     pval_name = name;
     pval_type = typ;
     pval_attributes = add_docs_attrs docs attrs;
     pval_loc = loc;
     pval_prim = prim;
    }
end

module Md = struct
  let mk ?(loc = !default_loc) ?(attrs = [])
        ?(docs = empty_docs) ?(text = []) name typ =
    {
     pmd_name = name;
     pmd_type = typ;
     pmd_attributes =
       add_text_attrs text (add_docs_attrs docs attrs);
     pmd_loc = loc;
    }
end

module Mtd = struct
  let mk ?(loc = !default_loc) ?(attrs = [])
        ?(docs = empty_docs) ?(text = []) ?typ name =
    {
     pmtd_name = name;
     pmtd_type = typ;
     pmtd_attributes =
       add_text_attrs text (add_docs_attrs docs attrs);
     pmtd_loc = loc;
    }
end

module Mb = struct
  let mk ?(loc = !default_loc) ?(attrs = [])
        ?(docs = empty_docs) ?(text = []) name expr =
    {
     pmb_name = name;
     pmb_expr = expr;
     pmb_attributes =
       add_text_attrs text (add_docs_attrs docs attrs);
     pmb_loc = loc;
    }
end

module Opn = struct
  let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
        ?(override = Fresh) lid =
    {
     popen_lid = lid;
     popen_override = override;
     popen_loc = loc;
     popen_attributes = add_docs_attrs docs attrs;
    }
end

module Incl = struct
  let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs) mexpr =
    {
     pincl_mod = mexpr;
     pincl_loc = loc;
     pincl_attributes = add_docs_attrs docs attrs;
    }

end

module Vb = struct
  let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
        ?(text = []) pat expr =
    {
     pvb_pat = pat;
     pvb_expr = expr;
     pvb_attributes =
       add_text_attrs text (add_docs_attrs docs attrs);
     pvb_loc = loc;
    }
end

module Ci = struct
  let mk ?(loc = !default_loc) ?(attrs = [])
        ?(docs = empty_docs) ?(text = [])
        ?(virt = Concrete) ?(params = []) name expr =
    {
     pci_virt = virt;
     pci_params = params;
     pci_name = name;
     pci_expr = expr;
     pci_attributes =
       add_text_attrs text (add_docs_attrs docs attrs);
     pci_loc = loc;
    }
end

module Type = struct
  let mk ?(loc = !default_loc) ?(attrs = [])
        ?(docs = empty_docs) ?(text = [])
      ?(params = [])
      ?(cstrs = [])
      ?(kind = Ptype_abstract)
      ?(priv = Public)
      ?manifest
      name =
    {
     ptype_name = name;
     ptype_params = params;
     ptype_cstrs = cstrs;
     ptype_kind = kind;
     ptype_private = priv;
     ptype_manifest = manifest;
     ptype_attributes =
       add_text_attrs text (add_docs_attrs docs attrs);
     ptype_loc = loc;
    }

  let constructor ?(loc = !default_loc) ?(attrs = []) ?(info = empty_info)
        ?(args = []) ?res name =
    {
     pcd_name = name;
     pcd_args = args;
     pcd_res = res;
     pcd_loc = loc;
     pcd_attributes = add_info_attrs info attrs;
    }

  let field ?(loc = !default_loc) ?(attrs = []) ?(info = empty_info)
        ?(mut = Immutable) name typ =
    {
     pld_name = name;
     pld_mutable = mut;
     pld_type = typ;
     pld_loc = loc;
     pld_attributes = add_info_attrs info attrs;
    }

end

(** Type extensions *)
module Te = struct
  let mk ?(attrs = []) ?(docs = empty_docs)
        ?(params = []) ?(priv = Public) path constructors =
    {
     ptyext_path = path;
     ptyext_params = params;
     ptyext_constructors = constructors;
     ptyext_private = priv;
     ptyext_attributes = add_docs_attrs docs attrs;
    }

  let constructor ?(loc = !default_loc) ?(attrs = [])
        ?(docs = empty_docs) ?(info = empty_info) name kind =
    {
     pext_name = name;
     pext_kind = kind;
     pext_loc = loc;
     pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
    }

  let decl ?(loc = !default_loc) ?(attrs = [])
        ?(docs = empty_docs) ?(info = empty_info) ?(args = []) ?res name =
    {
     pext_name = name;
     pext_kind = Pext_decl(args, res);
     pext_loc = loc;
     pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
    }

  let rebind ?(loc = !default_loc) ?(attrs = [])
        ?(docs = empty_docs) ?(info = empty_info) name lid =
    {
     pext_name = name;
     pext_kind = Pext_rebind lid;
     pext_loc = loc;
     pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
    }

end

module Csig = struct
  let mk self fields =
    {
     pcsig_self = self;
     pcsig_fields = fields;
    }
end

module Cstr = struct
  let mk self fields =
    {
     pcstr_self = self;
     pcstr_fields = fields;
    }
end


end
module Ast_mapper : sig
(*#1 "ast_mapper.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*                        Alain Frisch, LexiFi                         *)
(*                                                                     *)
(*  Copyright 2012 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(** The interface of a -ppx rewriter

  A -ppx rewriter is a program that accepts a serialized abstract syntax
  tree and outputs another, possibly modified, abstract syntax tree.
  This module encapsulates the interface between the compiler and
  the -ppx rewriters, handling such details as the serialization format,
  forwarding of command-line flags, and storing state.

  {!mapper} allows to implement AST rewriting using open recursion.
  A typical mapper would be based on {!default_mapper}, a deep
  identity mapper, and will fall back on it for handling the syntax it
  does not modify. For example:

  {[
open Asttypes
open Parsetree
open Ast_mapper

let test_mapper argv =
  { default_mapper with
    expr = fun mapper expr ->
      match expr with
      | { pexp_desc = Pexp_extension ({ txt = "test" }, PStr [])} ->
        Ast_helper.Exp.constant (Const_int 42)
      | other -> default_mapper.expr mapper other; }

let () =
  register "ppx_test" test_mapper]}

  This -ppx rewriter, which replaces [[%test]] in expressions with
  the constant [42], can be compiled using
  [ocamlc -o ppx_test -I +compiler-libs ocamlcommon.cma ppx_test.ml].

  *)

open Parsetree

(** {2 A generic Parsetree mapper} *)

type mapper = {
  attribute: mapper -> attribute -> attribute;
  attributes: mapper -> attribute list -> attribute list;
  case: mapper -> case -> case;
  cases: mapper -> case list -> case list;
  class_declaration: mapper -> class_declaration -> class_declaration;
  class_description: mapper -> class_description -> class_description;
  class_expr: mapper -> class_expr -> class_expr;
  class_field: mapper -> class_field -> class_field;
  class_signature: mapper -> class_signature -> class_signature;
  class_structure: mapper -> class_structure -> class_structure;
  class_type: mapper -> class_type -> class_type;
  class_type_declaration: mapper -> class_type_declaration
                          -> class_type_declaration;
  class_type_field: mapper -> class_type_field -> class_type_field;
  constructor_declaration: mapper -> constructor_declaration
                           -> constructor_declaration;
  expr: mapper -> expression -> expression;
  extension: mapper -> extension -> extension;
  extension_constructor: mapper -> extension_constructor
                         -> extension_constructor;
  include_declaration: mapper -> include_declaration -> include_declaration;
  include_description: mapper -> include_description -> include_description;
  label_declaration: mapper -> label_declaration -> label_declaration;
  location: mapper -> Location.t -> Location.t;
  module_binding: mapper -> module_binding -> module_binding;
  module_declaration: mapper -> module_declaration -> module_declaration;
  module_expr: mapper -> module_expr -> module_expr;
  module_type: mapper -> module_type -> module_type;
  module_type_declaration: mapper -> module_type_declaration
                           -> module_type_declaration;
  open_description: mapper -> open_description -> open_description;
  pat: mapper -> pattern -> pattern;
  payload: mapper -> payload -> payload;
  signature: mapper -> signature -> signature;
  signature_item: mapper -> signature_item -> signature_item;
  structure: mapper -> structure -> structure;
  structure_item: mapper -> structure_item -> structure_item;
  typ: mapper -> core_type -> core_type;
  type_declaration: mapper -> type_declaration -> type_declaration;
  type_extension: mapper -> type_extension -> type_extension;
  type_kind: mapper -> type_kind -> type_kind;
  value_binding: mapper -> value_binding -> value_binding;
  value_description: mapper -> value_description -> value_description;
  with_constraint: mapper -> with_constraint -> with_constraint;
}
(** A mapper record implements one "method" per syntactic category,
    using an open recursion style: each method takes as its first
    argument the mapper to be applied to children in the syntax
    tree. *)

val default_mapper: mapper
(** A default mapper, which implements a "deep identity" mapping. *)

(** {2 Apply mappers to compilation units} *)

val tool_name: unit -> string
(** Can be used within a ppx preprocessor to know which tool is
    calling it ["ocamlc"], ["ocamlopt"], ["ocamldoc"], ["ocamldep"],
    ["ocaml"], ...  Some global variables that reflect command-line
    options are automatically synchronized between the calling tool
    and the ppx preprocessor: [Clflags.include_dirs],
    [Config.load_path], [Clflags.open_modules], [Clflags.for_package],
    [Clflags.debug]. *)


val apply: source:string -> target:string -> mapper -> unit
(** Apply a mapper (parametrized by the unit name) to a dumped
    parsetree found in the [source] file and put the result in the
    [target] file. The [structure] or [signature] field of the mapper
    is applied to the implementation or interface.  *)

val run_main: (string list -> mapper) -> unit
(** Entry point to call to implement a standalone -ppx rewriter from a
    mapper, parametrized by the command line arguments.  The current
    unit name can be obtained from [Location.input_name].  This
    function implements proper error reporting for uncaught
    exceptions. *)

(** {2 Registration API} *)

val register_function: (string -> (string list -> mapper) -> unit) ref

val register: string -> (string list -> mapper) -> unit
(** Apply the [register_function].  The default behavior is to run the
    mapper immediately, taking arguments from the process command
    line.  This is to support a scenario where a mapper is linked as a
    stand-alone executable.

    It is possible to overwrite the [register_function] to define
    "-ppx drivers", which combine several mappers in a single process.
    Typically, a driver starts by defining [register_function] to a
    custom implementation, then lets ppx rewriters (linked statically
    or dynamically) register themselves, and then run all or some of
    them.  It is also possible to have -ppx drivers apply rewriters to
    only specific parts of an AST.

    The first argument to [register] is a symbolic name to be used by
    the ppx driver.  *)


(** {2 Convenience functions to write mappers} *)

val map_opt: ('a -> 'b) -> 'a option -> 'b option

val extension_of_error: Location.error -> extension
(** Encode an error into an 'ocaml.error' extension node which can be
    inserted in a generated Parsetree.  The compiler will be
    responsible for reporting the error. *)

val attribute_of_warning: Location.t -> string -> attribute
(** Encode a warning message into an 'ocaml.ppwarning' attribute which can be
    inserted in a generated Parsetree.  The compiler will be
    responsible for reporting the warning. *)

(** {2 Helper functions to call external mappers} *)

val add_ppx_context_str: tool_name:string -> Parsetree.structure -> Parsetree.structure
(** Extract information from the current environment and encode it
    into an attribute which is prepended to the list of structure
    items in order to pass the information to an external
    processor. *)

val add_ppx_context_sig: tool_name:string -> Parsetree.signature -> Parsetree.signature
(** Same as [add_ppx_context_str], but for signatures. *)

val drop_ppx_context_str: restore:bool -> Parsetree.structure -> Parsetree.structure
(** Drop the ocaml.ppx.context attribute from a structure.  If
    [restore] is true, also restore the associated data in the current
    process. *)

val drop_ppx_context_sig: restore:bool -> Parsetree.signature -> Parsetree.signature
(** Same as [drop_ppx_context_str], but for signatures. *)

(** {2 Cookies} *)

(** Cookies are used to pass information from a ppx processor to
    a further invocation of itself, when called from the OCaml
    toplevel (or other tools that support cookies). *)

val set_cookie: string -> Parsetree.expression -> unit
val get_cookie: string -> Parsetree.expression option

end = struct
(*#1 "ast_mapper.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*                        Alain Frisch, LexiFi                         *)
(*                                                                     *)
(*  Copyright 2012 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* A generic Parsetree mapping class *)

(*
[@@@ocaml.warning "+9"]
  (* Ensure that record patterns don't miss any field. *)
*)


open Asttypes
open Parsetree
open Ast_helper
open Location

type mapper = {
  attribute: mapper -> attribute -> attribute;
  attributes: mapper -> attribute list -> attribute list;
  case: mapper -> case -> case;
  cases: mapper -> case list -> case list;
  class_declaration: mapper -> class_declaration -> class_declaration;
  class_description: mapper -> class_description -> class_description;
  class_expr: mapper -> class_expr -> class_expr;
  class_field: mapper -> class_field -> class_field;
  class_signature: mapper -> class_signature -> class_signature;
  class_structure: mapper -> class_structure -> class_structure;
  class_type: mapper -> class_type -> class_type;
  class_type_declaration: mapper -> class_type_declaration
                          -> class_type_declaration;
  class_type_field: mapper -> class_type_field -> class_type_field;
  constructor_declaration: mapper -> constructor_declaration
                           -> constructor_declaration;
  expr: mapper -> expression -> expression;
  extension: mapper -> extension -> extension;
  extension_constructor: mapper -> extension_constructor
                         -> extension_constructor;
  include_declaration: mapper -> include_declaration -> include_declaration;
  include_description: mapper -> include_description -> include_description;
  label_declaration: mapper -> label_declaration -> label_declaration;
  location: mapper -> Location.t -> Location.t;
  module_binding: mapper -> module_binding -> module_binding;
  module_declaration: mapper -> module_declaration -> module_declaration;
  module_expr: mapper -> module_expr -> module_expr;
  module_type: mapper -> module_type -> module_type;
  module_type_declaration: mapper -> module_type_declaration
                           -> module_type_declaration;
  open_description: mapper -> open_description -> open_description;
  pat: mapper -> pattern -> pattern;
  payload: mapper -> payload -> payload;
  signature: mapper -> signature -> signature;
  signature_item: mapper -> signature_item -> signature_item;
  structure: mapper -> structure -> structure;
  structure_item: mapper -> structure_item -> structure_item;
  typ: mapper -> core_type -> core_type;
  type_declaration: mapper -> type_declaration -> type_declaration;
  type_extension: mapper -> type_extension -> type_extension;
  type_kind: mapper -> type_kind -> type_kind;
  value_binding: mapper -> value_binding -> value_binding;
  value_description: mapper -> value_description -> value_description;
  with_constraint: mapper -> with_constraint -> with_constraint;
}

let map_fst f (x, y) = (f x, y)
let map_snd f (x, y) = (x, f y)
let map_tuple f1 f2 (x, y) = (f1 x, f2 y)
let map_tuple3 f1 f2 f3 (x, y, z) = (f1 x, f2 y, f3 z)
let map_opt f = function None -> None | Some x -> Some (f x)

let map_loc sub {loc; txt} = {loc = sub.location sub loc; txt}

module T = struct
  (* Type expressions for the core language *)

  let row_field sub = function
    | Rtag (l, attrs, b, tl) ->
        Rtag (l, sub.attributes sub attrs, b, List.map (sub.typ sub) tl)
    | Rinherit t -> Rinherit (sub.typ sub t)

  let map sub {ptyp_desc = desc; ptyp_loc = loc; ptyp_attributes = attrs} =
    let open Typ in
    let loc = sub.location sub loc in
    let attrs = sub.attributes sub attrs in
    match desc with
    | Ptyp_any -> any ~loc ~attrs ()
    | Ptyp_var s -> var ~loc ~attrs s
    | Ptyp_arrow (lab, t1, t2) ->
        arrow ~loc ~attrs lab (sub.typ sub t1) (sub.typ sub t2)
    | Ptyp_tuple tyl -> tuple ~loc ~attrs (List.map (sub.typ sub) tyl)
    | Ptyp_constr (lid, tl) ->
        constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tl)
    | Ptyp_object (l, o) ->
        let f (s, a, t) = (s, sub.attributes sub a, sub.typ sub t) in
        object_ ~loc ~attrs (List.map f l) o
    | Ptyp_class (lid, tl) ->
        class_ ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tl)
    | Ptyp_alias (t, s) -> alias ~loc ~attrs (sub.typ sub t) s
    | Ptyp_variant (rl, b, ll) ->
        variant ~loc ~attrs (List.map (row_field sub) rl) b ll
    | Ptyp_poly (sl, t) -> poly ~loc ~attrs sl (sub.typ sub t)
    | Ptyp_package (lid, l) ->
        package ~loc ~attrs (map_loc sub lid)
          (List.map (map_tuple (map_loc sub) (sub.typ sub)) l)
    | Ptyp_extension x -> extension ~loc ~attrs (sub.extension sub x)

  let map_type_declaration sub
      {ptype_name; ptype_params; ptype_cstrs;
       ptype_kind;
       ptype_private;
       ptype_manifest;
       ptype_attributes;
       ptype_loc} =
    Type.mk (map_loc sub ptype_name)
      ~params:(List.map (map_fst (sub.typ sub)) ptype_params)
      ~priv:ptype_private
      ~cstrs:(List.map
                (map_tuple3 (sub.typ sub) (sub.typ sub) (sub.location sub))
                ptype_cstrs)
      ~kind:(sub.type_kind sub ptype_kind)
      ?manifest:(map_opt (sub.typ sub) ptype_manifest)
      ~loc:(sub.location sub ptype_loc)
      ~attrs:(sub.attributes sub ptype_attributes)

  let map_type_kind sub = function
    | Ptype_abstract -> Ptype_abstract
    | Ptype_variant l ->
        Ptype_variant (List.map (sub.constructor_declaration sub) l)
    | Ptype_record l -> Ptype_record (List.map (sub.label_declaration sub) l)
    | Ptype_open -> Ptype_open

  let map_type_extension sub
      {ptyext_path; ptyext_params;
       ptyext_constructors;
       ptyext_private;
       ptyext_attributes} =
    Te.mk
      (map_loc sub ptyext_path)
      (List.map (sub.extension_constructor sub) ptyext_constructors)
      ~params:(List.map (map_fst (sub.typ sub)) ptyext_params)
      ~priv:ptyext_private
      ~attrs:(sub.attributes sub ptyext_attributes)

  let map_extension_constructor_kind sub = function
      Pext_decl(ctl, cto) ->
        Pext_decl(List.map (sub.typ sub) ctl, map_opt (sub.typ sub) cto)
    | Pext_rebind li ->
        Pext_rebind (map_loc sub li)

  let map_extension_constructor sub
      {pext_name;
       pext_kind;
       pext_loc;
       pext_attributes} =
    Te.constructor
      (map_loc sub pext_name)
      (map_extension_constructor_kind sub pext_kind)
      ~loc:(sub.location sub pext_loc)
      ~attrs:(sub.attributes sub pext_attributes)

end

module CT = struct
  (* Type expressions for the class language *)

  let map sub {pcty_loc = loc; pcty_desc = desc; pcty_attributes = attrs} =
    let open Cty in
    let loc = sub.location sub loc in
    let attrs = sub.attributes sub attrs in
    match desc with
    | Pcty_constr (lid, tys) ->
        constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tys)
    | Pcty_signature x -> signature ~loc ~attrs (sub.class_signature sub x)
    | Pcty_arrow (lab, t, ct) ->
        arrow ~loc ~attrs lab (sub.typ sub t) (sub.class_type sub ct)
    | Pcty_extension x -> extension ~loc ~attrs (sub.extension sub x)

  let map_field sub {pctf_desc = desc; pctf_loc = loc; pctf_attributes = attrs}
    =
    let open Ctf in
    let loc = sub.location sub loc in
    let attrs = sub.attributes sub attrs in
    match desc with
    | Pctf_inherit ct -> inherit_ ~loc ~attrs (sub.class_type sub ct)
    | Pctf_val (s, m, v, t) -> val_ ~loc ~attrs s m v (sub.typ sub t)
    | Pctf_method (s, p, v, t) -> method_ ~loc ~attrs s p v (sub.typ sub t)
    | Pctf_constraint (t1, t2) ->
        constraint_ ~loc ~attrs (sub.typ sub t1) (sub.typ sub t2)
    | Pctf_attribute x -> attribute ~loc (sub.attribute sub x)
    | Pctf_extension x -> extension ~loc ~attrs (sub.extension sub x)

  let map_signature sub {pcsig_self; pcsig_fields} =
    Csig.mk
      (sub.typ sub pcsig_self)
      (List.map (sub.class_type_field sub) pcsig_fields)
end

module MT = struct
  (* Type expressions for the module language *)

  let map sub {pmty_desc = desc; pmty_loc = loc; pmty_attributes = attrs} =
    let open Mty in
    let loc = sub.location sub loc in
    let attrs = sub.attributes sub attrs in
    match desc with
    | Pmty_ident s -> ident ~loc ~attrs (map_loc sub s)
    | Pmty_alias s -> alias ~loc ~attrs (map_loc sub s)
    | Pmty_signature sg -> signature ~loc ~attrs (sub.signature sub sg)
    | Pmty_functor (s, mt1, mt2) ->
        functor_ ~loc ~attrs (map_loc sub s)
          (Misc.may_map (sub.module_type sub) mt1)
          (sub.module_type sub mt2)
    | Pmty_with (mt, l) ->
        with_ ~loc ~attrs (sub.module_type sub mt)
          (List.map (sub.with_constraint sub) l)
    | Pmty_typeof me -> typeof_ ~loc ~attrs (sub.module_expr sub me)
    | Pmty_extension x -> extension ~loc ~attrs (sub.extension sub x)

  let map_with_constraint sub = function
    | Pwith_type (lid, d) ->
        Pwith_type (map_loc sub lid, sub.type_declaration sub d)
    | Pwith_module (lid, lid2) ->
        Pwith_module (map_loc sub lid, map_loc sub lid2)
    | Pwith_typesubst d -> Pwith_typesubst (sub.type_declaration sub d)
    | Pwith_modsubst (s, lid) ->
        Pwith_modsubst (map_loc sub s, map_loc sub lid)

  let map_signature_item sub {psig_desc = desc; psig_loc = loc} =
    let open Sig in
    let loc = sub.location sub loc in
    match desc with
    | Psig_value vd -> value ~loc (sub.value_description sub vd)
    | Psig_type l -> type_ ~loc (List.map (sub.type_declaration sub) l)
    | Psig_typext te -> type_extension ~loc (sub.type_extension sub te)
    | Psig_exception ed -> exception_ ~loc (sub.extension_constructor sub ed)
    | Psig_module x -> module_ ~loc (sub.module_declaration sub x)
    | Psig_recmodule l ->
        rec_module ~loc (List.map (sub.module_declaration sub) l)
    | Psig_modtype x -> modtype ~loc (sub.module_type_declaration sub x)
    | Psig_open x -> open_ ~loc (sub.open_description sub x)
    | Psig_include x -> include_ ~loc (sub.include_description sub x)
    | Psig_class l -> class_ ~loc (List.map (sub.class_description sub) l)
    | Psig_class_type l ->
        class_type ~loc (List.map (sub.class_type_declaration sub) l)
    | Psig_extension (x, attrs) ->
        extension ~loc (sub.extension sub x) ~attrs:(sub.attributes sub attrs)
    | Psig_attribute x -> attribute ~loc (sub.attribute sub x)
end


module M = struct
  (* Value expressions for the module language *)

  let map sub {pmod_loc = loc; pmod_desc = desc; pmod_attributes = attrs} =
    let open Mod in
    let loc = sub.location sub loc in
    let attrs = sub.attributes sub attrs in
    match desc with
    | Pmod_ident x -> ident ~loc ~attrs (map_loc sub x)
    | Pmod_structure str -> structure ~loc ~attrs (sub.structure sub str)
    | Pmod_functor (arg, arg_ty, body) ->
        functor_ ~loc ~attrs (map_loc sub arg)
          (Misc.may_map (sub.module_type sub) arg_ty)
          (sub.module_expr sub body)
    | Pmod_apply (m1, m2) ->
        apply ~loc ~attrs (sub.module_expr sub m1) (sub.module_expr sub m2)
    | Pmod_constraint (m, mty) ->
        constraint_ ~loc ~attrs (sub.module_expr sub m)
                    (sub.module_type sub mty)
    | Pmod_unpack e -> unpack ~loc ~attrs (sub.expr sub e)
    | Pmod_extension x -> extension ~loc ~attrs (sub.extension sub x)

  let map_structure_item sub {pstr_loc = loc; pstr_desc = desc} =
    let open Str in
    let loc = sub.location sub loc in
    match desc with
    | Pstr_eval (x, attrs) ->
        eval ~loc ~attrs:(sub.attributes sub attrs) (sub.expr sub x)
    | Pstr_value (r, vbs) -> value ~loc r (List.map (sub.value_binding sub) vbs)
    | Pstr_primitive vd -> primitive ~loc (sub.value_description sub vd)
    | Pstr_type l -> type_ ~loc (List.map (sub.type_declaration sub) l)
    | Pstr_typext te -> type_extension ~loc (sub.type_extension sub te)
    | Pstr_exception ed -> exception_ ~loc (sub.extension_constructor sub ed)
    | Pstr_module x -> module_ ~loc (sub.module_binding sub x)
    | Pstr_recmodule l -> rec_module ~loc (List.map (sub.module_binding sub) l)
    | Pstr_modtype x -> modtype ~loc (sub.module_type_declaration sub x)
    | Pstr_open x -> open_ ~loc (sub.open_description sub x)
    | Pstr_class l -> class_ ~loc (List.map (sub.class_declaration sub) l)
    | Pstr_class_type l ->
        class_type ~loc (List.map (sub.class_type_declaration sub) l)
    | Pstr_include x -> include_ ~loc (sub.include_declaration sub x)
    | Pstr_extension (x, attrs) ->
        extension ~loc (sub.extension sub x) ~attrs:(sub.attributes sub attrs)
    | Pstr_attribute x -> attribute ~loc (sub.attribute sub x)
end

module E = struct
  (* Value expressions for the core language *)

  let map sub {pexp_loc = loc; pexp_desc = desc; pexp_attributes = attrs} =
    let open Exp in
    let loc = sub.location sub loc in
    let attrs = sub.attributes sub attrs in
    match desc with
    | Pexp_ident x -> ident ~loc ~attrs (map_loc sub x)
    | Pexp_constant x -> constant ~loc ~attrs x
    | Pexp_let (r, vbs, e) ->
        let_ ~loc ~attrs r (List.map (sub.value_binding sub) vbs)
          (sub.expr sub e)
    | Pexp_fun (lab, def, p, e) ->
        fun_ ~loc ~attrs lab (map_opt (sub.expr sub) def) (sub.pat sub p)
          (sub.expr sub e)
    | Pexp_function pel -> function_ ~loc ~attrs (sub.cases sub pel)
    | Pexp_apply (e, l) ->
        apply ~loc ~attrs (sub.expr sub e) (List.map (map_snd (sub.expr sub)) l)
    | Pexp_match (e, pel) ->
        match_ ~loc ~attrs (sub.expr sub e) (sub.cases sub pel)
    | Pexp_try (e, pel) -> try_ ~loc ~attrs (sub.expr sub e) (sub.cases sub pel)
    | Pexp_tuple el -> tuple ~loc ~attrs (List.map (sub.expr sub) el)
    | Pexp_construct (lid, arg) ->
        construct ~loc ~attrs (map_loc sub lid) (map_opt (sub.expr sub) arg)
    | Pexp_variant (lab, eo) ->
        variant ~loc ~attrs lab (map_opt (sub.expr sub) eo)
    | Pexp_record (l, eo) ->
        record ~loc ~attrs (List.map (map_tuple (map_loc sub) (sub.expr sub)) l)
          (map_opt (sub.expr sub) eo)
    | Pexp_field (e, lid) ->
        field ~loc ~attrs (sub.expr sub e) (map_loc sub lid)
    | Pexp_setfield (e1, lid, e2) ->
        setfield ~loc ~attrs (sub.expr sub e1) (map_loc sub lid)
          (sub.expr sub e2)
    | Pexp_array el -> array ~loc ~attrs (List.map (sub.expr sub) el)
    | Pexp_ifthenelse (e1, e2, e3) ->
        ifthenelse ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
          (map_opt (sub.expr sub) e3)
    | Pexp_sequence (e1, e2) ->
        sequence ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
    | Pexp_while (e1, e2) ->
        while_ ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
    | Pexp_for (p, e1, e2, d, e3) ->
        for_ ~loc ~attrs (sub.pat sub p) (sub.expr sub e1) (sub.expr sub e2) d
          (sub.expr sub e3)
    | Pexp_coerce (e, t1, t2) ->
        coerce ~loc ~attrs (sub.expr sub e) (map_opt (sub.typ sub) t1)
          (sub.typ sub t2)
    | Pexp_constraint (e, t) ->
        constraint_ ~loc ~attrs (sub.expr sub e) (sub.typ sub t)
    | Pexp_send (e, s) -> send ~loc ~attrs (sub.expr sub e) s
    | Pexp_new lid -> new_ ~loc ~attrs (map_loc sub lid)
    | Pexp_setinstvar (s, e) ->
        setinstvar ~loc ~attrs (map_loc sub s) (sub.expr sub e)
    | Pexp_override sel ->
        override ~loc ~attrs
          (List.map (map_tuple (map_loc sub) (sub.expr sub)) sel)
    | Pexp_letmodule (s, me, e) ->
        letmodule ~loc ~attrs (map_loc sub s) (sub.module_expr sub me)
          (sub.expr sub e)
    | Pexp_assert e -> assert_ ~loc ~attrs (sub.expr sub e)
    | Pexp_lazy e -> lazy_ ~loc ~attrs (sub.expr sub e)
    | Pexp_poly (e, t) ->
        poly ~loc ~attrs (sub.expr sub e) (map_opt (sub.typ sub) t)
    | Pexp_object cls -> object_ ~loc ~attrs (sub.class_structure sub cls)
    | Pexp_newtype (s, e) -> newtype ~loc ~attrs s (sub.expr sub e)
    | Pexp_pack me -> pack ~loc ~attrs (sub.module_expr sub me)
    | Pexp_open (ovf, lid, e) ->
        open_ ~loc ~attrs ovf (map_loc sub lid) (sub.expr sub e)
    | Pexp_extension x -> extension ~loc ~attrs (sub.extension sub x)
end

module P = struct
  (* Patterns *)

  let map sub {ppat_desc = desc; ppat_loc = loc; ppat_attributes = attrs} =
    let open Pat in
    let loc = sub.location sub loc in
    let attrs = sub.attributes sub attrs in
    match desc with
    | Ppat_any -> any ~loc ~attrs ()
    | Ppat_var s -> var ~loc ~attrs (map_loc sub s)
    | Ppat_alias (p, s) -> alias ~loc ~attrs (sub.pat sub p) (map_loc sub s)
    | Ppat_constant c -> constant ~loc ~attrs c
    | Ppat_interval (c1, c2) -> interval ~loc ~attrs c1 c2
    | Ppat_tuple pl -> tuple ~loc ~attrs (List.map (sub.pat sub) pl)
    | Ppat_construct (l, p) ->
        construct ~loc ~attrs (map_loc sub l) (map_opt (sub.pat sub) p)
    | Ppat_variant (l, p) -> variant ~loc ~attrs l (map_opt (sub.pat sub) p)
    | Ppat_record (lpl, cf) ->
        record ~loc ~attrs
               (List.map (map_tuple (map_loc sub) (sub.pat sub)) lpl) cf
    | Ppat_array pl -> array ~loc ~attrs (List.map (sub.pat sub) pl)
    | Ppat_or (p1, p2) -> or_ ~loc ~attrs (sub.pat sub p1) (sub.pat sub p2)
    | Ppat_constraint (p, t) ->
        constraint_ ~loc ~attrs (sub.pat sub p) (sub.typ sub t)
    | Ppat_type s -> type_ ~loc ~attrs (map_loc sub s)
    | Ppat_lazy p -> lazy_ ~loc ~attrs (sub.pat sub p)
    | Ppat_unpack s -> unpack ~loc ~attrs (map_loc sub s)
    | Ppat_exception p -> exception_ ~loc ~attrs (sub.pat sub p)
    | Ppat_extension x -> extension ~loc ~attrs (sub.extension sub x)
end

module CE = struct
  (* Value expressions for the class language *)

  let map sub {pcl_loc = loc; pcl_desc = desc; pcl_attributes = attrs} =
    let open Cl in
    let loc = sub.location sub loc in
    let attrs = sub.attributes sub attrs in
    match desc with
    | Pcl_constr (lid, tys) ->
        constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tys)
    | Pcl_structure s ->
        structure ~loc ~attrs (sub.class_structure sub s)
    | Pcl_fun (lab, e, p, ce) ->
        fun_ ~loc ~attrs lab
          (map_opt (sub.expr sub) e)
          (sub.pat sub p)
          (sub.class_expr sub ce)
    | Pcl_apply (ce, l) ->
        apply ~loc ~attrs (sub.class_expr sub ce)
          (List.map (map_snd (sub.expr sub)) l)
    | Pcl_let (r, vbs, ce) ->
        let_ ~loc ~attrs r (List.map (sub.value_binding sub) vbs)
          (sub.class_expr sub ce)
    | Pcl_constraint (ce, ct) ->
        constraint_ ~loc ~attrs (sub.class_expr sub ce) (sub.class_type sub ct)
    | Pcl_extension x -> extension ~loc ~attrs (sub.extension sub x)

  let map_kind sub = function
    | Cfk_concrete (o, e) -> Cfk_concrete (o, sub.expr sub e)
    | Cfk_virtual t -> Cfk_virtual (sub.typ sub t)

  let map_field sub {pcf_desc = desc; pcf_loc = loc; pcf_attributes = attrs} =
    let open Cf in
    let loc = sub.location sub loc in
    let attrs = sub.attributes sub attrs in
    match desc with
    | Pcf_inherit (o, ce, s) -> inherit_ ~loc ~attrs o (sub.class_expr sub ce) s
    | Pcf_val (s, m, k) -> val_ ~loc ~attrs (map_loc sub s) m (map_kind sub k)
    | Pcf_method (s, p, k) ->
        method_ ~loc ~attrs (map_loc sub s) p (map_kind sub k)
    | Pcf_constraint (t1, t2) ->
        constraint_ ~loc ~attrs (sub.typ sub t1) (sub.typ sub t2)
    | Pcf_initializer e -> initializer_ ~loc ~attrs (sub.expr sub e)
    | Pcf_attribute x -> attribute ~loc (sub.attribute sub x)
    | Pcf_extension x -> extension ~loc ~attrs (sub.extension sub x)

  let map_structure sub {pcstr_self; pcstr_fields} =
    {
      pcstr_self = sub.pat sub pcstr_self;
      pcstr_fields = List.map (sub.class_field sub) pcstr_fields;
    }

  let class_infos sub f {pci_virt; pci_params = pl; pci_name; pci_expr;
                         pci_loc; pci_attributes} =
    Ci.mk
     ~virt:pci_virt
     ~params:(List.map (map_fst (sub.typ sub)) pl)
      (map_loc sub pci_name)
      (f pci_expr)
      ~loc:(sub.location sub pci_loc)
      ~attrs:(sub.attributes sub pci_attributes)
end

(* Now, a generic AST mapper, to be extended to cover all kinds and
   cases of the OCaml grammar.  The default behavior of the mapper is
   the identity. *)

let default_mapper =
  {
    structure = (fun this l -> List.map (this.structure_item this) l);
    structure_item = M.map_structure_item;
    module_expr = M.map;
    signature = (fun this l -> List.map (this.signature_item this) l);
    signature_item = MT.map_signature_item;
    module_type = MT.map;
    with_constraint = MT.map_with_constraint;
    class_declaration =
      (fun this -> CE.class_infos this (this.class_expr this));
    class_expr = CE.map;
    class_field = CE.map_field;
    class_structure = CE.map_structure;
    class_type = CT.map;
    class_type_field = CT.map_field;
    class_signature = CT.map_signature;
    class_type_declaration =
      (fun this -> CE.class_infos this (this.class_type this));
    class_description =
      (fun this -> CE.class_infos this (this.class_type this));
    type_declaration = T.map_type_declaration;
    type_kind = T.map_type_kind;
    typ = T.map;
    type_extension = T.map_type_extension;
    extension_constructor = T.map_extension_constructor;
    value_description =
      (fun this {pval_name; pval_type; pval_prim; pval_loc;
                 pval_attributes} ->
        Val.mk
          (map_loc this pval_name)
          (this.typ this pval_type)
          ~attrs:(this.attributes this pval_attributes)
          ~loc:(this.location this pval_loc)
          ~prim:pval_prim
      );

    pat = P.map;
    expr = E.map;

    module_declaration =
      (fun this {pmd_name; pmd_type; pmd_attributes; pmd_loc} ->
         Md.mk
           (map_loc this pmd_name)
           (this.module_type this pmd_type)
           ~attrs:(this.attributes this pmd_attributes)
           ~loc:(this.location this pmd_loc)
      );

    module_type_declaration =
      (fun this {pmtd_name; pmtd_type; pmtd_attributes; pmtd_loc} ->
         Mtd.mk
           (map_loc this pmtd_name)
           ?typ:(map_opt (this.module_type this) pmtd_type)
           ~attrs:(this.attributes this pmtd_attributes)
           ~loc:(this.location this pmtd_loc)
      );

    module_binding =
      (fun this {pmb_name; pmb_expr; pmb_attributes; pmb_loc} ->
         Mb.mk (map_loc this pmb_name) (this.module_expr this pmb_expr)
           ~attrs:(this.attributes this pmb_attributes)
           ~loc:(this.location this pmb_loc)
      );


    open_description =
      (fun this {popen_lid; popen_override; popen_attributes; popen_loc} ->
         Opn.mk (map_loc this popen_lid)
           ~override:popen_override
           ~loc:(this.location this popen_loc)
           ~attrs:(this.attributes this popen_attributes)
      );


    include_description =
      (fun this {pincl_mod; pincl_attributes; pincl_loc} ->
         Incl.mk (this.module_type this pincl_mod)
           ~loc:(this.location this pincl_loc)
           ~attrs:(this.attributes this pincl_attributes)
      );

    include_declaration =
      (fun this {pincl_mod; pincl_attributes; pincl_loc} ->
         Incl.mk (this.module_expr this pincl_mod)
           ~loc:(this.location this pincl_loc)
           ~attrs:(this.attributes this pincl_attributes)
      );


    value_binding =
      (fun this {pvb_pat; pvb_expr; pvb_attributes; pvb_loc} ->
         Vb.mk
           (this.pat this pvb_pat)
           (this.expr this pvb_expr)
           ~loc:(this.location this pvb_loc)
           ~attrs:(this.attributes this pvb_attributes)
      );


    constructor_declaration =
      (fun this {pcd_name; pcd_args; pcd_res; pcd_loc; pcd_attributes} ->
        Type.constructor
          (map_loc this pcd_name)
          ~args:(List.map (this.typ this) pcd_args)
          ?res:(map_opt (this.typ this) pcd_res)
          ~loc:(this.location this pcd_loc)
          ~attrs:(this.attributes this pcd_attributes)
      );

    label_declaration =
      (fun this {pld_name; pld_type; pld_loc; pld_mutable; pld_attributes} ->
         Type.field
           (map_loc this pld_name)
           (this.typ this pld_type)
           ~mut:pld_mutable
           ~loc:(this.location this pld_loc)
           ~attrs:(this.attributes this pld_attributes)
      );

    cases = (fun this l -> List.map (this.case this) l);
    case =
      (fun this {pc_lhs; pc_guard; pc_rhs} ->
         {
           pc_lhs = this.pat this pc_lhs;
           pc_guard = map_opt (this.expr this) pc_guard;
           pc_rhs = this.expr this pc_rhs;
         }
      );



    location = (fun this l -> l);

    extension = (fun this (s, e) -> (map_loc this s, this.payload this e));
    attribute = (fun this (s, e) -> (map_loc this s, this.payload this e));
    attributes = (fun this l -> List.map (this.attribute this) l);
    payload =
      (fun this -> function
         | PStr x -> PStr (this.structure this x)
         | PTyp x -> PTyp (this.typ this x)
         | PPat (x, g) -> PPat (this.pat this x, map_opt (this.expr this) g)
      );
  }

let rec extension_of_error {loc; msg; if_highlight; sub} =
  { loc; txt = "ocaml.error" },
  PStr ([Str.eval (Exp.constant (Const_string (msg, None)));
         Str.eval (Exp.constant (Const_string (if_highlight, None)))] @
        (List.map (fun ext -> Str.extension (extension_of_error ext)) sub))

let attribute_of_warning loc s =
  { loc; txt = "ocaml.ppwarning" },
  PStr ([Str.eval ~loc (Exp.constant (Const_string (s, None)))])

module StringMap = Map.Make(struct
    type t = string
    let compare = compare
end)

let cookies = ref StringMap.empty

let get_cookie k =
  try Some (StringMap.find k !cookies)
  with Not_found -> None

let set_cookie k v =
  cookies := StringMap.add k v !cookies

let tool_name_ref = ref "_none_"

let tool_name () = !tool_name_ref


module PpxContext = struct
  open Longident
  open Asttypes
  open Ast_helper

  let lid name = { txt = Lident name; loc = Location.none }

  let make_string x = Exp.constant (Const_string (x, None))

  let make_bool x =
    if x
    then Exp.construct (lid "true") None
    else Exp.construct (lid "false") None

  let rec make_list f lst =
    match lst with
    | x :: rest ->
      Exp.construct (lid "::") (Some (Exp.tuple [f x; make_list f rest]))
    | [] ->
      Exp.construct (lid "[]") None

  let make_pair f1 f2 (x1, x2) =
    Exp.tuple [f1 x1; f2 x2]

  let make_option f opt =
    match opt with
    | Some x -> Exp.construct (lid "Some") (Some (f x))
    | None   -> Exp.construct (lid "None") None

  let get_cookies () =
    lid "cookies",
    make_list (make_pair make_string (fun x -> x))
      (StringMap.bindings !cookies)

  let mk fields =
    { txt = "ocaml.ppx.context"; loc = Location.none },
    Parsetree.PStr [Str.eval (Exp.record fields None)]

  let make ~tool_name () =
    let fields =
      [
        lid "tool_name",    make_string tool_name;
        lid "include_dirs", make_list make_string !Clflags.include_dirs;
        lid "load_path",    make_list make_string !Config.load_path;
        lid "open_modules", make_list make_string !Clflags.open_modules;
        lid "for_package",  make_option make_string !Clflags.for_package;
        lid "debug",        make_bool !Clflags.debug;
        get_cookies ()
      ]
    in
    mk fields

  let get_fields = function
    | PStr [{pstr_desc = Pstr_eval
                 ({ pexp_desc = Pexp_record (fields, None) }, [])}] ->
        fields
    | _ ->
        raise_errorf "Internal error: invalid [@@@ocaml.ppx.context] syntax"

  let restore fields =
    let field name payload =
      let rec get_string = function
        | { pexp_desc = Pexp_constant (Const_string (str, None)) } -> str
        | _ ->
            raise_errorf
              "Internal error: invalid [@@@ocaml.ppx.context { %s }] string syntax"
              name
      and get_bool pexp =
        match pexp with
        | {pexp_desc = Pexp_construct ({txt = Longident.Lident "true"}, None)} ->
            true
        | {pexp_desc = Pexp_construct ({txt = Longident.Lident "false"}, None)} ->
            false
        | _ ->
            raise_errorf
              "Internal error: invalid [@@@ocaml.ppx.context { %s }] bool syntax"
              name
      and get_list elem = function
        | {pexp_desc =
             Pexp_construct ({txt = Longident.Lident "::"},
                             Some {pexp_desc = Pexp_tuple [exp; rest]}) } ->
            elem exp :: get_list elem rest
        | {pexp_desc =
             Pexp_construct ({txt = Longident.Lident "[]"}, None)} ->
            []
        | _ ->
            raise_errorf
              "Internal error: invalid [@@@ocaml.ppx.context { %s }] list syntax"
              name
      and get_pair f1 f2 = function
        | {pexp_desc = Pexp_tuple [e1; e2]} ->
            (f1 e1, f2 e2)
        | _ ->
            raise_errorf
              "Internal error: invalid [@@@ocaml.ppx.context { %s }] pair syntax"
              name
      and get_option elem = function
        | { pexp_desc =
              Pexp_construct ({ txt = Longident.Lident "Some" }, Some exp) } ->
            Some (elem exp)
        | { pexp_desc =
              Pexp_construct ({ txt = Longident.Lident "None" }, None) } ->
            None
        | _ ->
            raise_errorf
              "Internal error: invalid [@@@ocaml.ppx.context { %s }] option syntax"
              name
      in
      match name with
      | "tool_name" ->
          tool_name_ref := get_string payload
      | "include_dirs" ->
          Clflags.include_dirs := get_list get_string payload
      | "load_path" ->
          Config.load_path := get_list get_string payload
      | "open_modules" ->
          Clflags.open_modules := get_list get_string payload
      | "for_package" ->
          Clflags.for_package := get_option get_string payload
      | "debug" ->
          Clflags.debug := get_bool payload
      | "cookies" ->
          let l = get_list (get_pair get_string (fun x -> x)) payload in
          cookies :=
            List.fold_left
              (fun s (k, v) -> StringMap.add k v s) StringMap.empty
              l
      | _ ->
          ()
    in
    List.iter (function ({txt=Lident name}, x) -> field name x | _ -> ()) fields

  let update_cookies fields =
    let fields =
      List.filter
        (function ({txt=Lident "cookies"}, _) -> false | _ -> true)
        fields
    in
    fields @ [get_cookies ()]
end

let ppx_context = PpxContext.make


let apply_lazy ~source ~target mapper =
  let ic = open_in_bin source in
  let magic =
    really_input_string ic (String.length Config.ast_impl_magic_number)
  in
  if magic <> Config.ast_impl_magic_number
  && magic <> Config.ast_intf_magic_number then
    failwith "Ast_mapper: OCaml version mismatch or malformed input";
  Location.input_name := input_value ic;
  let ast = input_value ic in
  close_in ic;

  let implem ast =
    try
      let fields, ast =
        match ast with
        | {pstr_desc = Pstr_attribute ({txt = "ocaml.ppx.context"}, x)} :: l ->
            PpxContext.get_fields x, l
        | _ -> [], ast
      in
      PpxContext.restore fields;
      let mapper = mapper () in
      let ast = mapper.structure mapper ast in
      let fields = PpxContext.update_cookies fields in
      Str.attribute (PpxContext.mk fields) :: ast
    with exn ->
      match error_of_exn exn with
      | Some error ->
          [{pstr_desc = Pstr_extension (extension_of_error error, []);
            pstr_loc  = Location.none}]
      | None -> raise exn
  in
  let iface ast =
    try
      let fields, ast =
        match ast with
        | {psig_desc = Psig_attribute ({txt = "ocaml.ppx.context"}, x)} :: l ->
            PpxContext.get_fields x, l
        | _ -> [], ast
      in
      PpxContext.restore fields;
      let mapper = mapper () in
      let ast = mapper.signature mapper ast in
      let fields = PpxContext.update_cookies fields in
      Sig.attribute (PpxContext.mk fields) :: ast
    with exn ->
      match error_of_exn exn with
      | Some error ->
          [{psig_desc = Psig_extension (extension_of_error error, []);
            psig_loc  = Location.none}]
      | None -> raise exn
  in
  let ast =
    if magic = Config.ast_impl_magic_number
    then Obj.magic (implem (Obj.magic ast))
    else Obj.magic (iface (Obj.magic ast))
  in
  let oc = open_out_bin target in
  output_string oc magic;
  output_value oc !Location.input_name;
  output_value oc ast;
  close_out oc

let drop_ppx_context_str ~restore = function
  | {pstr_desc = Pstr_attribute({Location.txt = "ocaml.ppx.context"}, a)}
    :: items ->
      if restore then
        PpxContext.restore (PpxContext.get_fields a);
      items
  | items -> items

let drop_ppx_context_sig ~restore = function
  | {psig_desc = Psig_attribute({Location.txt = "ocaml.ppx.context"}, a)}
    :: items ->
      if restore then
        PpxContext.restore (PpxContext.get_fields a);
      items
  | items -> items

let add_ppx_context_str ~tool_name ast =
  Ast_helper.Str.attribute (ppx_context ~tool_name ()) :: ast

let add_ppx_context_sig ~tool_name ast =
  Ast_helper.Sig.attribute (ppx_context ~tool_name ()) :: ast


let apply ~source ~target mapper =
  apply_lazy ~source ~target (fun () -> mapper)

let run_main mapper =
  try
    let a = Sys.argv in
    let n = Array.length a in
    if n > 2 then
      let mapper () =
        try mapper (Array.to_list (Array.sub a 1 (n - 3)))
        with exn ->
          (* PR #6463 *)
          let f _ _ = raise exn in
          {default_mapper with structure = f; signature = f}
      in
      apply_lazy ~source:a.(n - 2) ~target:a.(n - 1) mapper
    else begin
      Printf.eprintf "Usage: %s [extra_args] <infile> <outfile>\n%!"
                     Sys.executable_name;
      exit 2
    end
  with exn ->
    prerr_endline (Printexc.to_string exn);
    exit 2

let register_function = ref (fun _name f -> run_main f)
let register name f = !register_function name f

end
module Tbl : sig
(*#1 "tbl.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Association tables from any ordered type to any type.
   We use the generic ordering to compare keys. *)

type ('a, 'b) t

val empty: ('a, 'b) t
val add: 'a -> 'b -> ('a, 'b) t -> ('a, 'b) t
val find: 'a -> ('a, 'b) t -> 'b
val mem: 'a -> ('a, 'b) t -> bool
val remove: 'a -> ('a,  'b) t -> ('a, 'b) t
val iter: ('a -> 'b -> unit) -> ('a, 'b) t -> unit
val map: ('a -> 'b -> 'c) -> ('a, 'b) t -> ('a, 'c) t
val fold: ('a -> 'b -> 'c -> 'c) -> ('a, 'b) t -> 'c -> 'c

open Format

val print: (formatter -> 'a -> unit) -> (formatter -> 'b -> unit) ->
           formatter -> ('a, 'b) t -> unit

end = struct
(*#1 "tbl.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

type ('a, 'b) t =
    Empty
  | Node of ('a, 'b) t * 'a * 'b * ('a, 'b) t * int

let empty = Empty

let height = function
    Empty -> 0
  | Node(_,_,_,_,h) -> h

let create l x d r =
  let hl = height l and hr = height r in
  Node(l, x, d, r, (if hl >= hr then hl + 1 else hr + 1))

let bal l x d r =
  let hl = height l and hr = height r in
  if hl > hr + 1 then
    match l with
    | Node (ll, lv, ld, lr, _) when height ll >= height lr ->
        create ll lv ld (create lr x d r)
    | Node (ll, lv, ld, Node (lrl, lrv, lrd, lrr, _), _) ->
        create (create ll lv ld lrl) lrv lrd (create lrr x d r)
    | _ -> assert false
  else if hr > hl + 1 then
    match r with
    | Node (rl, rv, rd, rr, _) when height rr >= height rl ->
        create (create l x d rl) rv rd rr
    | Node (Node (rll, rlv, rld, rlr, _), rv, rd, rr, _) ->
        create (create l x d rll) rlv rld (create rlr rv rd rr)
    | _ -> assert false
  else
    create l x d r

let rec add x data = function
    Empty ->
      Node(Empty, x, data, Empty, 1)
  | Node(l, v, d, r, h) ->
      let c = compare x v in
      if c = 0 then
        Node(l, x, data, r, h)
      else if c < 0 then
        bal (add x data l) v d r
      else
        bal l v d (add x data r)

let rec find x = function
    Empty ->
      raise Not_found
  | Node(l, v, d, r, _) ->
      let c = compare x v in
      if c = 0 then d
      else find x (if c < 0 then l else r)

let rec mem x = function
    Empty -> false
  | Node(l, v, d, r, _) ->
      let c = compare x v in
      c = 0 || mem x (if c < 0 then l else r)

let rec merge t1 t2 =
  match (t1, t2) with
    (Empty, t) -> t
  | (t, Empty) -> t
  | (Node(l1, v1, d1, r1, h1), Node(l2, v2, d2, r2, h2)) ->
      bal l1 v1 d1 (bal (merge r1 l2) v2 d2 r2)

let rec remove x = function
    Empty ->
      Empty
  | Node(l, v, d, r, h) ->
      let c = compare x v in
      if c = 0 then
        merge l r
      else if c < 0 then
        bal (remove x l) v d r
      else
        bal l v d (remove x r)

let rec iter f = function
    Empty -> ()
  | Node(l, v, d, r, _) ->
      iter f l; f v d; iter f r

let rec map f = function
    Empty -> Empty
  | Node(l, v, d, r, h) -> Node(map f l, v, f v d, map f r, h)

let rec fold f m accu =
  match m with
  | Empty -> accu
  | Node(l, v, d, r, _) ->
      fold f r (f v d (fold f l accu))

open Format

let print print_key print_data ppf tbl =
  let print_tbl ppf tbl =
    iter (fun k d -> fprintf ppf "@[<2>%a ->@ %a;@]@ " print_key k print_data d)
      tbl in
  fprintf ppf "@[<hv 2>[[%a]]@]" print_tbl tbl

end
module Subst : sig
(*#1 "subst.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Substitutions *)

open Types

type t

(*
   Substitutions are used to translate a type from one context to
   another.  This requires substituing paths for identifiers, and
   possibly also lowering the level of non-generic variables so that
   it be inferior to the maximum level of the new context.

   Substitutions can also be used to create a "clean" copy of a type.
   Indeed, non-variable node of a type are duplicated, with their
   levels set to generic level.  That way, the resulting type is
   well-formed (decreasing levels), even if the original one was not.
*)

val identity: t

val add_type: Ident.t -> Path.t -> t -> t
val add_module: Ident.t -> Path.t -> t -> t
val add_modtype: Ident.t -> module_type -> t -> t
val for_saving: t -> t
val reset_for_saving: unit -> unit

val module_path: t -> Path.t -> Path.t
val type_path: t -> Path.t -> Path.t

val type_expr: t -> type_expr -> type_expr
val class_type: t -> class_type -> class_type
val value_description: t -> value_description -> value_description
val type_declaration: t -> type_declaration -> type_declaration
val extension_constructor:
        t -> extension_constructor -> extension_constructor
val class_declaration: t -> class_declaration -> class_declaration
val cltype_declaration: t -> class_type_declaration -> class_type_declaration
val modtype: t -> module_type -> module_type
val signature: t -> signature -> signature
val modtype_declaration: t -> modtype_declaration -> modtype_declaration
val module_declaration: t -> module_declaration -> module_declaration
val typexp : t -> Types.type_expr -> Types.type_expr
val class_signature: t -> class_signature -> class_signature

(* Composition of substitutions:
     apply (compose s1 s2) x = apply s2 (apply s1 x) *)
val compose: t -> t -> t

end = struct
(*#1 "subst.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Substitutions *)

open Misc
open Path
open Types
open Btype

type t =
  { types: (Ident.t, Path.t) Tbl.t;
    modules: (Ident.t, Path.t) Tbl.t;
    modtypes: (Ident.t, module_type) Tbl.t;
    for_saving: bool }

let identity =
  { types = Tbl.empty; modules = Tbl.empty; modtypes = Tbl.empty;
    for_saving = false }

let add_type id p s = { s with types = Tbl.add id p s.types }

let add_module id p s = { s with modules = Tbl.add id p s.modules }

let add_modtype id ty s = { s with modtypes = Tbl.add id ty s.modtypes }

let for_saving s = { s with for_saving = true }

let loc s x =
  if s.for_saving && not !Clflags.keep_locs then Location.none else x

let remove_loc =
  let open Ast_mapper in
  {default_mapper with location = (fun _this _loc -> Location.none)}

let is_not_doc = function
  | ({Location.txt = "ocaml.doc"}, _) -> false
  | ({Location.txt = "ocaml.text"}, _) -> false
  | ({Location.txt = "doc"}, _) -> false
  | ({Location.txt = "text"}, _) -> false
  | _ -> true

let attrs s x =
  let x =
    if s.for_saving && not !Clflags.keep_docs then
      List.filter is_not_doc x
    else x
  in
    if s.for_saving && not !Clflags.keep_locs
    then remove_loc.Ast_mapper.attributes remove_loc x
    else x

let rec module_path s = function
    Pident id as p ->
      begin try Tbl.find id s.modules with Not_found -> p end
  | Pdot(p, n, pos) ->
      Pdot(module_path s p, n, pos)
  | Papply(p1, p2) ->
      Papply(module_path s p1, module_path s p2)

let modtype_path s = function
    Pident id as p ->
      begin try
        match Tbl.find id s.modtypes with
          | Mty_ident p -> p
          | _ -> fatal_error "Subst.modtype_path"
      with Not_found -> p end
  | Pdot(p, n, pos) ->
      Pdot(module_path s p, n, pos)
  | Papply(p1, p2) ->
      fatal_error "Subst.modtype_path"

let type_path s = function
    Pident id as p ->
      begin try Tbl.find id s.types with Not_found -> p end
  | Pdot(p, n, pos) ->
      Pdot(module_path s p, n, pos)
  | Papply(p1, p2) ->
      fatal_error "Subst.type_path"

(* Special type ids for saved signatures *)

let new_id = ref (-1)
let reset_for_saving () = new_id := -1

let newpersty desc =
  decr new_id;
  { desc = desc; level = generic_level; id = !new_id }

(* ensure that all occurrences of 'Tvar None' are physically shared *)
let tvar_none = Tvar None
let tunivar_none = Tunivar None
let norm = function
  | Tvar None -> tvar_none
  | Tunivar None -> tunivar_none
  | d -> d

(* Similar to [Ctype.nondep_type_rec]. *)
let rec typexp s ty =
  let ty = repr ty in
  match ty.desc with
    Tvar _ | Tunivar _ as desc ->
      if s.for_saving || ty.id < 0 then
        let ty' =
          if s.for_saving then newpersty (norm desc)
          else newty2 ty.level desc
        in
        save_desc ty desc; ty.desc <- Tsubst ty'; ty'
      else ty
  | Tsubst ty ->
      ty
(* cannot do it, since it would omit subsitution
  | Tvariant row when not (static_row row) ->
      ty
*)
  | _ ->
    let desc = ty.desc in
    save_desc ty desc;
    (* Make a stub *)
    let ty' = if s.for_saving then newpersty (Tvar None) else newgenvar () in
    ty.desc <- Tsubst ty';
    ty'.desc <-
      begin match desc with
      | Tconstr(p, tl, abbrev) ->
          Tconstr(type_path s p, List.map (typexp s) tl, ref Mnil)
      | Tpackage(p, n, tl) ->
          Tpackage(modtype_path s p, n, List.map (typexp s) tl)
      | Tobject (t1, name) ->
          Tobject (typexp s t1,
                 ref (match !name with
                        None -> None
                      | Some (p, tl) ->
                          Some (type_path s p, List.map (typexp s) tl)))
      | Tfield (m, k, t1, t2)
        when s == identity && ty.level < generic_level && m = dummy_method ->
          (* not allowed to lower the level of the dummy method *)
          Tfield (m, k, t1, typexp s t2)
      | Tvariant row ->
          let row = row_repr row in
          let more = repr row.row_more in
          (* We must substitute in a subtle way *)
          (* Tsubst takes a tuple containing the row var and the variant *)
          begin match more.desc with
            Tsubst {desc = Ttuple [_;ty2]} ->
              (* This variant type has been already copied *)
              ty.desc <- Tsubst ty2; (* avoid Tlink in the new type *)
              Tlink ty2
          | _ ->
              let dup =
                s.for_saving || more.level = generic_level || static_row row ||
                match more.desc with Tconstr _ -> true | _ -> false in
              (* Various cases for the row variable *)
              let more' =
                match more.desc with
                  Tsubst ty -> ty
                | Tconstr _ | Tnil -> typexp s more
                | Tunivar _ | Tvar _ ->
                    save_desc more more.desc;
                    if s.for_saving then newpersty (norm more.desc) else
                    if dup && is_Tvar more then newgenty more.desc else more
                | _ -> assert false
              in
              (* Register new type first for recursion *)
              more.desc <- Tsubst(newgenty(Ttuple[more';ty']));
              (* Return a new copy *)
              let row =
                copy_row (typexp s) true row (not dup) more' in
              match row.row_name with
                Some (p, tl) ->
                  Tvariant {row with row_name = Some (type_path s p, tl)}
              | None ->
                  Tvariant row
          end
      | Tfield(label, kind, t1, t2) when field_kind_repr kind = Fabsent ->
          Tlink (typexp s t2)
      | _ -> copy_type_desc (typexp s) desc
      end;
    ty'

(*
   Always make a copy of the type. If this is not done, type levels
   might not be correct.
*)
let type_expr s ty =
  let ty' = typexp s ty in
  cleanup_types ();
  ty'

let type_declaration s decl =
  let decl =
    { type_params = List.map (typexp s) decl.type_params;
      type_arity = decl.type_arity;
      type_kind =
        begin match decl.type_kind with
          Type_abstract -> Type_abstract
        | Type_variant cstrs ->
            Type_variant
              (List.map
                 (fun c ->
                    {
                      cd_id = c.cd_id;
                      cd_args = List.map (typexp s) c.cd_args;
                      cd_res = may_map (typexp s) c.cd_res;
                      cd_loc = loc s c.cd_loc;
                      cd_attributes = attrs s c.cd_attributes;
                    }
                 )
                 cstrs)
        | Type_record(lbls, rep) ->
            Type_record
              (List.map (fun l ->
                   {
                     ld_id = l.ld_id;
                     ld_mutable = l.ld_mutable;
                     ld_type = typexp s l.ld_type;
                     ld_loc = loc s l.ld_loc;
                     ld_attributes = attrs s l.ld_attributes;
                   }
                 )
                  lbls,
               rep)
        | Type_open -> Type_open
        end;
      type_manifest =
        begin
          match decl.type_manifest with
            None -> None
          | Some ty -> Some(typexp s ty)
        end;
      type_private = decl.type_private;
      type_variance = decl.type_variance;
      type_newtype_level = None;
      type_loc = loc s decl.type_loc;
      type_attributes = attrs s decl.type_attributes;
    }
  in
  cleanup_types ();
  decl

let class_signature s sign =
  { csig_self = typexp s sign.csig_self;
    csig_vars =
      Vars.map (function (m, v, t) -> (m, v, typexp s t)) sign.csig_vars;
    csig_concr = sign.csig_concr;
    csig_inher =
      List.map (fun (p, tl) -> (type_path s p, List.map (typexp s) tl))
        sign.csig_inher;
  }

let rec class_type s =
  function
    Cty_constr (p, tyl, cty) ->
      Cty_constr (type_path s p, List.map (typexp s) tyl, class_type s cty)
  | Cty_signature sign ->
      Cty_signature (class_signature s sign)
  | Cty_arrow (l, ty, cty) ->
      Cty_arrow (l, typexp s ty, class_type s cty)

let class_declaration s decl =
  let decl =
    { cty_params = List.map (typexp s) decl.cty_params;
      cty_variance = decl.cty_variance;
      cty_type = class_type s decl.cty_type;
      cty_path = type_path s decl.cty_path;
      cty_new =
        begin match decl.cty_new with
          None    -> None
        | Some ty -> Some (typexp s ty)
        end;
      cty_loc = loc s decl.cty_loc;
      cty_attributes = attrs s decl.cty_attributes;
    }
  in
  (* Do not clean up if saving: next is cltype_declaration *)
  if not s.for_saving then cleanup_types ();
  decl

let cltype_declaration s decl =
  let decl =
    { clty_params = List.map (typexp s) decl.clty_params;
      clty_variance = decl.clty_variance;
      clty_type = class_type s decl.clty_type;
      clty_path = type_path s decl.clty_path;
      clty_loc = loc s decl.clty_loc;
      clty_attributes = attrs s decl.clty_attributes;
    }
  in
  (* Do clean up even if saving: type_declaration may be recursive *)
  cleanup_types ();
  decl

let class_type s cty =
  let cty = class_type s cty in
  cleanup_types ();
  cty

let value_description s descr =
  { val_type = type_expr s descr.val_type;
    val_kind = descr.val_kind;
    val_loc = loc s descr.val_loc;
    val_attributes = attrs s descr.val_attributes;
   }

let extension_constructor s ext =
  let ext =
    { ext_type_path = type_path s ext.ext_type_path;
      ext_type_params = List.map (typexp s) ext.ext_type_params;
      ext_args = List.map (typexp s) ext.ext_args;
      ext_ret_type = may_map (typexp s) ext.ext_ret_type;
      ext_private = ext.ext_private;
      ext_attributes = attrs s ext.ext_attributes;
      ext_loc = if s.for_saving then Location.none else ext.ext_loc; }
  in
    cleanup_types ();
    ext

let rec rename_bound_idents s idents = function
    [] -> (List.rev idents, s)
  | Sig_type(id, d, _) :: sg ->
      let id' = Ident.rename id in
      rename_bound_idents (add_type id (Pident id') s) (id' :: idents) sg
  | Sig_module(id, mty, _) :: sg ->
      let id' = Ident.rename id in
      rename_bound_idents (add_module id (Pident id') s) (id' :: idents) sg
  | Sig_modtype(id, d) :: sg ->
      let id' = Ident.rename id in
      rename_bound_idents (add_modtype id (Mty_ident(Pident id')) s)
                          (id' :: idents) sg
  | (Sig_value(id, _) | Sig_typext(id, _, _) |
     Sig_class(id, _, _) | Sig_class_type(id, _, _)) :: sg ->
      let id' = Ident.rename id in
      rename_bound_idents s (id' :: idents) sg

let rec modtype s = function
    Mty_ident p as mty ->
      begin match p with
        Pident id ->
          begin try Tbl.find id s.modtypes with Not_found -> mty end
      | Pdot(p, n, pos) ->
          Mty_ident(Pdot(module_path s p, n, pos))
      | Papply(p1, p2) ->
          fatal_error "Subst.modtype"
      end
  | Mty_signature sg ->
      Mty_signature(signature s sg)
  | Mty_functor(id, arg, res) ->
      let id' = Ident.rename id in
      Mty_functor(id', may_map (modtype s) arg,
                       modtype (add_module id (Pident id') s) res)
  | Mty_alias p ->
      Mty_alias(module_path s p)

and signature s sg =
  (* Components of signature may be mutually recursive (e.g. type declarations
     or class and type declarations), so first build global renaming
     substitution... *)
  let (new_idents, s') = rename_bound_idents s [] sg in
  (* ... then apply it to each signature component in turn *)
  List.map2 (signature_component s') sg new_idents

and signature_component s comp newid =
  match comp with
    Sig_value(id, d) ->
      Sig_value(newid, value_description s d)
  | Sig_type(id, d, rs) ->
      Sig_type(newid, type_declaration s d, rs)
  | Sig_typext(id, ext, es) ->
      Sig_typext(newid, extension_constructor s ext, es)
  | Sig_module(id, d, rs) ->
      Sig_module(newid, module_declaration s d, rs)
  | Sig_modtype(id, d) ->
      Sig_modtype(newid, modtype_declaration s d)
  | Sig_class(id, d, rs) ->
      Sig_class(newid, class_declaration s d, rs)
  | Sig_class_type(id, d, rs) ->
      Sig_class_type(newid, cltype_declaration s d, rs)

and module_declaration s decl =
  {
    md_type = modtype s decl.md_type;
    md_attributes = attrs s decl.md_attributes;
    md_loc = loc s decl.md_loc;
  }

and modtype_declaration s decl  =
  {
    mtd_type = may_map (modtype s) decl.mtd_type;
    mtd_attributes = attrs s decl.mtd_attributes;
    mtd_loc = loc s decl.mtd_loc;
  }

(* For every binding k |-> d of m1, add k |-> f d to m2
   and return resulting merged map. *)

let merge_tbls f m1 m2 =
  Tbl.fold (fun k d accu -> Tbl.add k (f d) accu) m1 m2

(* Composition of substitutions:
     apply (compose s1 s2) x = apply s2 (apply s1 x) *)

let compose s1 s2 =
  { types = merge_tbls (type_path s2) s1.types s2.types;
    modules = merge_tbls (module_path s2) s1.modules s2.modules;
    modtypes = merge_tbls (modtype s2) s1.modtypes s2.modtypes;
    for_saving = false }

end
module Env : sig
(*#1 "env.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Environment handling *)

open Types

type summary =
    Env_empty
  | Env_value of summary * Ident.t * value_description
  | Env_type of summary * Ident.t * type_declaration
  | Env_extension of summary * Ident.t * extension_constructor
  | Env_module of summary * Ident.t * module_declaration
  | Env_modtype of summary * Ident.t * modtype_declaration
  | Env_class of summary * Ident.t * class_declaration
  | Env_cltype of summary * Ident.t * class_type_declaration
  | Env_open of summary * Path.t
  | Env_functor_arg of summary * Ident.t

type t

val empty: t
val initial_safe_string: t
val initial_unsafe_string: t
val diff: t -> t -> Ident.t list

type type_descriptions =
    constructor_description list * label_description list

(* For short-paths *)
type iter_cont
val iter_types:
    (Path.t -> Path.t * (type_declaration * type_descriptions) -> unit) ->
    t -> iter_cont
val run_iter_cont: iter_cont list -> (Path.t * iter_cont) list
val same_types: t -> t -> bool
val used_persistent: unit -> Concr.t
val find_shadowed_types: Path.t -> t -> Path.t list

(* Lookup by paths *)

val find_value: Path.t -> t -> value_description
val find_type: Path.t -> t -> type_declaration
val find_type_descrs: Path.t -> t -> type_descriptions
val find_module: Path.t -> t -> module_declaration
val find_modtype: Path.t -> t -> modtype_declaration
val find_class: Path.t -> t -> class_declaration
val find_cltype: Path.t -> t -> class_type_declaration

val find_type_expansion:
    Path.t -> t -> type_expr list * type_expr * int option
val find_type_expansion_opt:
    Path.t -> t -> type_expr list * type_expr * int option
(* Find the manifest type information associated to a type for the sake
   of the compiler's type-based optimisations. *)
val find_modtype_expansion: Path.t -> t -> module_type
val is_functor_arg: Path.t -> t -> bool
val normalize_path: Location.t option -> t -> Path.t -> Path.t
(* Normalize the path to a concrete value or module.
   If the option is None, allow returning dangling paths.
   Otherwise raise a Missing_module error, and may add forgotten
   head as required global. *)
val reset_required_globals: unit -> unit
val get_required_globals: unit -> Ident.t list
val add_required_global: Ident.t -> unit

val has_local_constraints: t -> bool
val add_gadt_instance_level: int -> t -> t
val gadt_instance_level: t -> type_expr -> int option
val add_gadt_instances: t -> int -> type_expr list -> unit
val add_gadt_instance_chain: t -> int -> type_expr -> unit

(* Lookup by long identifiers *)

val lookup_value: Longident.t -> t -> Path.t * value_description
val lookup_constructor: Longident.t -> t -> constructor_description
val lookup_all_constructors:
  Longident.t -> t -> (constructor_description * (unit -> unit)) list
val lookup_label: Longident.t -> t -> label_description
val lookup_all_labels:
  Longident.t -> t -> (label_description * (unit -> unit)) list
val lookup_type: Longident.t -> t -> Path.t * type_declaration
val lookup_module: load:bool -> Longident.t -> t -> Path.t
val lookup_modtype: Longident.t -> t -> Path.t * modtype_declaration
val lookup_class: Longident.t -> t -> Path.t * class_declaration
val lookup_cltype: Longident.t -> t -> Path.t * class_type_declaration

exception Recmodule
  (* Raise by lookup_module when the identifier refers
     to one of the modules of a recursive definition
     during the computation of its approximation (see #5965). *)

(* Insertion by identifier *)

val add_value:
    ?check:(string -> Warnings.t) -> Ident.t -> value_description -> t -> t
val add_type: check:bool -> Ident.t -> type_declaration -> t -> t
val add_extension: check:bool -> Ident.t -> extension_constructor -> t -> t
val add_module: ?arg:bool -> Ident.t -> module_type -> t -> t
val add_module_declaration: ?arg:bool -> Ident.t -> module_declaration -> t -> t
val add_modtype: Ident.t -> modtype_declaration -> t -> t
val add_class: Ident.t -> class_declaration -> t -> t
val add_cltype: Ident.t -> class_type_declaration -> t -> t
val add_local_constraint: Ident.t -> type_declaration -> int -> t -> t

(* Insertion of all fields of a signature. *)

val add_item: signature_item -> t -> t
val add_signature: signature -> t -> t

(* Insertion of all fields of a signature, relative to the given path.
   Used to implement open. *)

val open_signature:
    ?loc:Location.t -> ?toplevel:bool -> Asttypes.override_flag -> Path.t ->
      signature -> t -> t
val open_pers_signature: string -> t -> t

(* Insertion by name *)

val enter_value:
    ?check:(string -> Warnings.t) ->
    string -> value_description -> t -> Ident.t * t
val enter_type: string -> type_declaration -> t -> Ident.t * t
val enter_extension: string -> extension_constructor -> t -> Ident.t * t
val enter_module: ?arg:bool -> string -> module_type -> t -> Ident.t * t
val enter_module_declaration:
    ?arg:bool -> string -> module_declaration -> t -> Ident.t * t
val enter_modtype: string -> modtype_declaration -> t -> Ident.t * t
val enter_class: string -> class_declaration -> t -> Ident.t * t
val enter_cltype: string -> class_type_declaration -> t -> Ident.t * t

(* Initialize the cache of in-core module interfaces. *)
val reset_cache: unit -> unit

(* To be called before each toplevel phrase. *)
val reset_cache_toplevel: unit -> unit

(* Remember the name of the current compilation unit. *)
val set_unit_name: string -> unit
val get_unit_name: unit -> string

(* Read, save a signature to/from a file *)

val read_signature: string -> string -> signature
        (* Arguments: module name, file name. Results: signature. *)
val save_signature: signature -> string -> string -> signature
        (* Arguments: signature, module name, file name. *)
val save_signature_with_imports:
    signature -> string -> string -> (string * Digest.t option) list -> signature
        (* Arguments: signature, module name, file name,
           imported units with their CRCs. *)

(* Return the CRC of the interface of the given compilation unit *)

val crc_of_unit: string -> Digest.t

(* Return the set of compilation units imported, with their CRC *)

val imports: unit -> (string * Digest.t option) list

(* Direct access to the table of imported compilation units with their CRC *)

val crc_units: Consistbl.t
val add_import: string -> unit

(* Summaries -- compact representation of an environment, to be
   exported in debugging information. *)

val summary: t -> summary

(* Return an equivalent environment where all fields have been reset,
   except the summary. The initial environment can be rebuilt from the
   summary, using Envaux.env_of_only_summary. *)

val keep_only_summary : t -> t
val env_of_only_summary : (summary -> Subst.t -> t) -> t -> t

(* Error report *)

type error =
  | Illegal_renaming of string * string * string
  | Inconsistent_import of string * string * string
  | Need_recursive_types of string * string
  | Missing_module of Location.t * Path.t * Path.t
  | Illegal_value_name of Location.t * string

exception Error of error

open Format

val report_error: formatter -> error -> unit


val mark_value_used: t -> string -> value_description -> unit
val mark_type_used: t -> string -> type_declaration -> unit

type constructor_usage = Positive | Pattern | Privatize
val mark_constructor_used:
    constructor_usage -> t -> string -> type_declaration -> string -> unit
val mark_constructor:
    constructor_usage -> t -> string -> constructor_description -> unit
val mark_extension_used:
    constructor_usage -> t -> extension_constructor -> string -> unit

val in_signature: t -> t
val implicit_coercion: t -> t

val set_value_used_callback:
    string -> value_description -> (unit -> unit) -> unit
val set_type_used_callback:
    string -> type_declaration -> ((unit -> unit) -> unit) -> unit

(* Forward declaration to break mutual recursion with Includemod. *)
val check_modtype_inclusion:
      (t -> module_type -> Path.t -> module_type -> unit) ref
(* Forward declaration to break mutual recursion with Typecore. *)
val add_delayed_check_forward: ((unit -> unit) -> unit) ref
(* Forward declaration to break mutual recursion with Mtype. *)
val strengthen: (t -> module_type -> Path.t -> module_type) ref

(** Folding over all identifiers (for analysis purpose) *)

val fold_values:
  (string -> Path.t -> value_description -> 'a -> 'a) ->
  Longident.t option -> t -> 'a -> 'a
val fold_types:
  (string -> Path.t -> type_declaration * type_descriptions -> 'a -> 'a) ->
  Longident.t option -> t -> 'a -> 'a
val fold_constructors:
  (constructor_description -> 'a -> 'a) ->
  Longident.t option -> t -> 'a -> 'a
val fold_labels:
  (label_description -> 'a -> 'a) ->
  Longident.t option -> t -> 'a -> 'a

(** Persistent structures are only traversed if they are already loaded. *)
val fold_modules:
  (string -> Path.t -> module_declaration -> 'a -> 'a) ->
  Longident.t option -> t -> 'a -> 'a

val fold_modtypes:
  (string -> Path.t -> modtype_declaration -> 'a -> 'a) ->
  Longident.t option -> t -> 'a -> 'a
val fold_classs:
  (string -> Path.t -> class_declaration -> 'a -> 'a) ->
  Longident.t option -> t -> 'a -> 'a
val fold_cltypes:
  (string -> Path.t -> class_type_declaration -> 'a -> 'a) ->
  Longident.t option -> t -> 'a -> 'a

(** Utilities *)
val scrape_alias: t -> module_type -> module_type
val check_value_name: string -> Location.t -> unit

end = struct
(*#1 "env.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Environment handling *)

open Cmi_format
open Config
open Misc
open Asttypes
open Longident
open Path
open Types
open Btype

let add_delayed_check_forward = ref (fun _ -> assert false)

let value_declarations : ((string * Location.t), (unit -> unit)) Hashtbl.t =
  Hashtbl.create 16
    (* This table is used to usage of value declarations.  A declaration is
       identified with its name and location.  The callback attached to a
       declaration is called whenever the value is used explicitly
       (lookup_value) or implicitly (inclusion test between signatures,
       cf Includemod.value_descriptions). *)

let type_declarations = Hashtbl.create 16

type constructor_usage = Positive | Pattern | Privatize
type constructor_usages =
    {
     mutable cu_positive: bool;
     mutable cu_pattern: bool;
     mutable cu_privatize: bool;
    }
let add_constructor_usage cu = function
  | Positive -> cu.cu_positive <- true
  | Pattern -> cu.cu_pattern <- true
  | Privatize -> cu.cu_privatize <- true
let constructor_usages () =
  {cu_positive = false; cu_pattern = false; cu_privatize = false}

let used_constructors :
    (string * Location.t * string, (constructor_usage -> unit)) Hashtbl.t
  = Hashtbl.create 16

let prefixed_sg = Hashtbl.create 113

type error =
  | Illegal_renaming of string * string * string
  | Inconsistent_import of string * string * string
  | Need_recursive_types of string * string
  | Missing_module of Location.t * Path.t * Path.t
  | Illegal_value_name of Location.t * string

exception Error of error

let error err = raise (Error err)

module EnvLazy : sig
  type ('a,'b) t

  val force : ('a -> 'b) -> ('a,'b) t -> 'b
  val create : 'a -> ('a,'b) t
  val is_val : ('a,'b) t -> bool
  val get_arg : ('a,'b) t -> 'a option

end  = struct

  type ('a,'b) t = ('a,'b) eval ref

  and ('a,'b) eval =
      Done of 'b
    | Raise of exn
    | Thunk of 'a

  let force f x =
    match !x with
        Done x -> x
      | Raise e -> raise e
      | Thunk e ->
          try
            let y = f e in
            x := Done y;
            y
          with e ->
            x := Raise e;
            raise e

  let is_val x =
    match !x with Done _ -> true | _ -> false

  let get_arg x =
    match !x with Thunk a -> Some a | _ -> None

  let create x =
    let x = ref (Thunk x) in
    x

end


type summary =
    Env_empty
  | Env_value of summary * Ident.t * value_description
  | Env_type of summary * Ident.t * type_declaration
  | Env_extension of summary * Ident.t * extension_constructor
  | Env_module of summary * Ident.t * module_declaration
  | Env_modtype of summary * Ident.t * modtype_declaration
  | Env_class of summary * Ident.t * class_declaration
  | Env_cltype of summary * Ident.t * class_type_declaration
  | Env_open of summary * Path.t
  | Env_functor_arg of summary * Ident.t

module EnvTbl =
  struct
    (* A table indexed by identifier, with an extra slot to record usage. *)
    type 'a t = ('a * (unit -> unit)) Ident.tbl

    let empty = Ident.empty
    let nothing = fun () -> ()

    let already_defined s tbl =
      try ignore (Ident.find_name s tbl); true
      with Not_found -> false

    let add kind slot id x tbl ref_tbl =
      let slot =
        match slot with
        | None -> nothing
        | Some f ->
          (fun () ->
             let s = Ident.name id in
             f kind s (already_defined s ref_tbl)
          )
      in
      Ident.add id (x, slot) tbl

    let add_dont_track id x tbl =
      Ident.add id (x, nothing) tbl

    let find_same_not_using id tbl =
      fst (Ident.find_same id tbl)

    let find_same id tbl =
      let (x, slot) = Ident.find_same id tbl in
      slot ();
      x

    let find_name s tbl =
      let (x, slot) = Ident.find_name s tbl in
      slot ();
      x

    let find_all s tbl =
      Ident.find_all s tbl

    let fold_name f = Ident.fold_name (fun k (d,_) -> f k d)
    let keys tbl = Ident.fold_all (fun k _ accu -> k::accu) tbl []
  end

type type_descriptions =
    constructor_description list * label_description list

let in_signature_flag = 0x01
let implicit_coercion_flag = 0x02

type t = {
  values: (Path.t * value_description) EnvTbl.t;
  constrs: constructor_description EnvTbl.t;
  labels: label_description EnvTbl.t;
  types: (Path.t * (type_declaration * type_descriptions)) EnvTbl.t;
  modules: (Path.t * module_declaration) EnvTbl.t;
  modtypes: (Path.t * modtype_declaration) EnvTbl.t;
  components: (Path.t * module_components) EnvTbl.t;
  classes: (Path.t * class_declaration) EnvTbl.t;
  cltypes: (Path.t * class_type_declaration) EnvTbl.t;
  functor_args: unit Ident.tbl;
  summary: summary;
  local_constraints: bool;
  gadt_instances: (int * TypeSet.t ref) list;
  flags: int;
}

and module_components =
  (t * Subst.t * Path.t * Types.module_type, module_components_repr) EnvLazy.t

and module_components_repr =
    Structure_comps of structure_components
  | Functor_comps of functor_components

and structure_components = {
  mutable comp_values: (string, (value_description * int)) Tbl.t;
  mutable comp_constrs: (string, (constructor_description * int) list) Tbl.t;
  mutable comp_labels: (string, (label_description * int) list) Tbl.t;
  mutable comp_types:
   (string, ((type_declaration * type_descriptions) * int)) Tbl.t;
  mutable comp_modules:
   (string, ((Subst.t * Types.module_type,module_type) EnvLazy.t * int)) Tbl.t;
  mutable comp_modtypes: (string, (modtype_declaration * int)) Tbl.t;
  mutable comp_components: (string, (module_components * int)) Tbl.t;
  mutable comp_classes: (string, (class_declaration * int)) Tbl.t;
  mutable comp_cltypes: (string, (class_type_declaration * int)) Tbl.t
}

and functor_components = {
  fcomp_param: Ident.t;                 (* Formal parameter *)
  fcomp_arg: module_type option;        (* Argument signature *)
  fcomp_res: module_type;               (* Result signature *)
  fcomp_env: t;     (* Environment in which the result signature makes sense *)
  fcomp_subst: Subst.t;  (* Prefixing substitution for the result signature *)
  fcomp_cache: (Path.t, module_components) Hashtbl.t;  (* For memoization *)
  fcomp_subst_cache: (Path.t, module_type) Hashtbl.t
}

let subst_modtype_maker (subst, mty) = Subst.modtype subst mty

let empty = {
  values = EnvTbl.empty; constrs = EnvTbl.empty;
  labels = EnvTbl.empty; types = EnvTbl.empty;
  modules = EnvTbl.empty; modtypes = EnvTbl.empty;
  components = EnvTbl.empty; classes = EnvTbl.empty;
  cltypes = EnvTbl.empty;
  summary = Env_empty; local_constraints = false; gadt_instances = [];
  flags = 0;
  functor_args = Ident.empty;
 }

let in_signature env =
  {env with flags = env.flags lor in_signature_flag}
let implicit_coercion env =
  {env with flags = env.flags lor implicit_coercion_flag}

let is_in_signature env = env.flags land in_signature_flag <> 0
let is_implicit_coercion env = env.flags land implicit_coercion_flag <> 0

let diff_keys is_local tbl1 tbl2 =
  let keys2 = EnvTbl.keys tbl2 in
  List.filter
    (fun id ->
      is_local (EnvTbl.find_same_not_using id tbl2) &&
      try ignore (EnvTbl.find_same_not_using id tbl1); false
      with Not_found -> true)
    keys2

let is_ident = function
    Pident _ -> true
  | Pdot _ | Papply _ -> false

let is_local (p, _) = is_ident p

let is_local_ext = function
  | {cstr_tag = Cstr_extension(p, _)} -> is_ident p
  | _ -> false

let diff env1 env2 =
  diff_keys is_local env1.values env2.values @
  diff_keys is_local_ext env1.constrs env2.constrs @
  diff_keys is_local env1.modules env2.modules @
  diff_keys is_local env1.classes env2.classes

(* Forward declarations *)

let components_of_module' =
  ref ((fun env sub path mty -> assert false) :
          t -> Subst.t -> Path.t -> module_type -> module_components)
let components_of_module_maker' =
  ref ((fun (env, sub, path, mty) -> assert false) :
          t * Subst.t * Path.t * module_type -> module_components_repr)
let components_of_functor_appl' =
  ref ((fun f p1 p2 -> assert false) :
          functor_components -> Path.t -> Path.t -> module_components)
let check_modtype_inclusion =
  (* to be filled with Includemod.check_modtype_inclusion *)
  ref ((fun env mty1 path1 mty2 -> assert false) :
          t -> module_type -> Path.t -> module_type -> unit)
let strengthen =
  (* to be filled with Mtype.strengthen *)
  ref ((fun env mty path -> assert false) :
         t -> module_type -> Path.t -> module_type)

let md md_type =
  {md_type; md_attributes=[]; md_loc=Location.none}

(* The name of the compilation unit currently compiled.
   "" if outside a compilation unit. *)

let current_unit = ref ""

(* Persistent structure descriptions *)

type pers_struct =
  { ps_name: string;
    ps_sig: signature;
    ps_comps: module_components;
    ps_crcs: (string * Digest.t option) list;
    mutable ps_crcs_checked: bool;
    ps_filename: string;
    ps_flags: pers_flags list }

let persistent_structures =
  (Hashtbl.create 17 : (string, pers_struct option) Hashtbl.t)

(* Consistency between persistent structures *)

let crc_units = Consistbl.create()

module StringSet =
  Set.Make(struct type t = string let compare = String.compare end)

let imported_units = ref StringSet.empty

let add_import s =
  imported_units := StringSet.add s !imported_units

let clear_imports () =
  Consistbl.clear crc_units;
  imported_units := StringSet.empty

let check_consistency ps =
  if not ps.ps_crcs_checked then
  try
    List.iter
      (fun (name, crco) ->
         match crco with
            None -> ()
          | Some crc ->
              add_import name;
              Consistbl.check crc_units name crc ps.ps_filename)
      ps.ps_crcs;
    ps.ps_crcs_checked <- true;
  with Consistbl.Inconsistency(name, source, auth) ->
    error (Inconsistent_import(name, auth, source))

(* Reading persistent structures from .cmi files *)

let save_pers_struct crc ps =
  let modname = ps.ps_name in
  Hashtbl.add persistent_structures modname (Some ps);
  Consistbl.set crc_units modname crc ps.ps_filename;
  add_import modname

let read_pers_struct modname filename =
  let cmi = read_cmi filename in
  let name = cmi.cmi_name in
  let sign = cmi.cmi_sign in
  let crcs = cmi.cmi_crcs in
  let flags = cmi.cmi_flags in
  let comps =
      !components_of_module' empty Subst.identity
                             (Pident(Ident.create_persistent name))
                             (Mty_signature sign)
  in
  let ps = { ps_name = name;
             ps_sig = sign;
             ps_comps = comps;
             ps_crcs = crcs;
             ps_filename = filename;
             ps_flags = flags;
             ps_crcs_checked = false;
           } in
  if ps.ps_name <> modname then
    error (Illegal_renaming(modname, ps.ps_name, filename));
  add_import name;
  List.iter
    (function Rectypes ->
      if not !Clflags.recursive_types then
        error (Need_recursive_types(ps.ps_name, !current_unit)))
    ps.ps_flags;
  Hashtbl.add persistent_structures modname (Some ps);
  ps

let find_pers_struct ?(check=true) name =
  if name = "*predef*" then raise Not_found;
  let r =
    try Some (Hashtbl.find persistent_structures name)
    with Not_found -> None
  in
  let ps =
    match r with
    | Some None -> raise Not_found
    | Some (Some sg) -> sg
    | None ->
       (* PR#6843: record the weak dependency ([add_import]) even if
          the [find_in_path_uncap] call below fails to find the .cmi,
          to help make builds more deterministic. *)
        add_import name;
        let filename =
          try find_in_path_uncap !load_path (name ^ ".cmi")
          with Not_found ->
            Hashtbl.add persistent_structures name None;
            raise Not_found
        in
        read_pers_struct name filename
  in
  if check then check_consistency ps;
  ps

let reset_cache () =
  current_unit := "";
  Hashtbl.clear persistent_structures;
  clear_imports ();
  Hashtbl.clear value_declarations;
  Hashtbl.clear type_declarations;
  Hashtbl.clear used_constructors;
  Hashtbl.clear prefixed_sg

let reset_cache_toplevel () =
  (* Delete 'missing cmi' entries from the cache. *)
  let l =
    Hashtbl.fold
      (fun name r acc -> if r = None then name :: acc else acc)
      persistent_structures []
  in
  List.iter (Hashtbl.remove persistent_structures) l;
  Hashtbl.clear value_declarations;
  Hashtbl.clear type_declarations;
  Hashtbl.clear used_constructors;
  Hashtbl.clear prefixed_sg


let set_unit_name name =
  current_unit := name

let get_unit_name () =
  !current_unit

(* Lookup by identifier *)

let rec find_module_descr path env =
  match path with
    Pident id ->
      begin try
        let (p, desc) = EnvTbl.find_same id env.components
        in desc
      with Not_found ->
        if Ident.persistent id && not (Ident.name id = !current_unit)
        then (find_pers_struct (Ident.name id)).ps_comps
        else raise Not_found
      end
  | Pdot(p, s, pos) ->
      begin match
        EnvLazy.force !components_of_module_maker' (find_module_descr p env)
      with
        Structure_comps c ->
          let (descr, pos) = Tbl.find s c.comp_components in
          descr
      | Functor_comps f ->
         raise Not_found
      end
  | Papply(p1, p2) ->
      begin match
        EnvLazy.force !components_of_module_maker' (find_module_descr p1 env)
      with
        Functor_comps f ->
          !components_of_functor_appl' f p1 p2
      | Structure_comps c ->
          raise Not_found
      end

let find proj1 proj2 path env =
  match path with
    Pident id ->
      let (p, data) = EnvTbl.find_same id (proj1 env)
      in data
  | Pdot(p, s, pos) ->
      begin match
        EnvLazy.force !components_of_module_maker' (find_module_descr p env)
      with
        Structure_comps c ->
          let (data, pos) = Tbl.find s (proj2 c) in data
      | Functor_comps f ->
          raise Not_found
      end
  | Papply(p1, p2) ->
      raise Not_found

let find_value =
  find (fun env -> env.values) (fun sc -> sc.comp_values)
and find_type_full =
  find (fun env -> env.types) (fun sc -> sc.comp_types)
and find_modtype =
  find (fun env -> env.modtypes) (fun sc -> sc.comp_modtypes)
and find_class =
  find (fun env -> env.classes) (fun sc -> sc.comp_classes)
and find_cltype =
  find (fun env -> env.cltypes) (fun sc -> sc.comp_cltypes)

let find_type p env =
  fst (find_type_full p env)
let find_type_descrs p env =
  snd (find_type_full p env)

let find_module ~alias path env =
  match path with
    Pident id ->
      begin try
        let (p, data) = EnvTbl.find_same id env.modules
        in data
      with Not_found ->
        if Ident.persistent id && not (Ident.name id = !current_unit) then
          let ps = find_pers_struct (Ident.name id) in
          md (Mty_signature(ps.ps_sig))
        else raise Not_found
      end
  | Pdot(p, s, pos) ->
      begin match
        EnvLazy.force !components_of_module_maker' (find_module_descr p env)
      with
        Structure_comps c ->
          let (data, pos) = Tbl.find s c.comp_modules in
          md (EnvLazy.force subst_modtype_maker data)
      | Functor_comps f ->
          raise Not_found
      end
  | Papply(p1, p2) ->
      let desc1 = find_module_descr p1 env in
      begin match EnvLazy.force !components_of_module_maker' desc1 with
        Functor_comps f ->
          md begin match f.fcomp_res with
          | Mty_alias p ->
              Mty_alias (Subst.module_path f.fcomp_subst p)
          | mty ->
              if alias then mty else
              try
                Hashtbl.find f.fcomp_subst_cache p2
              with Not_found ->
                let mty =
                  Subst.modtype
                    (Subst.add_module f.fcomp_param p2 f.fcomp_subst)
                    f.fcomp_res in
                Hashtbl.add f.fcomp_subst_cache p2 mty;
                mty
          end
      | Structure_comps c ->
          raise Not_found
      end

let required_globals = ref []
let reset_required_globals () = required_globals := []
let get_required_globals () = !required_globals
let add_required_global id =
  if Ident.global id && not !Clflags.transparent_modules
  && not (List.exists (Ident.same id) !required_globals)
  then required_globals := id :: !required_globals

let rec normalize_path lax env path =
  let path =
    match path with
      Pdot(p, s, pos) ->
        Pdot(normalize_path lax env p, s, pos)
    | Papply(p1, p2) ->
        Papply(normalize_path lax env p1, normalize_path true env p2)
    | _ -> path
  in
  try match find_module ~alias:true path env with
    {md_type=Mty_alias path1} ->
      let path' = normalize_path lax env path1 in
      if lax || !Clflags.transparent_modules then path' else
      let id = Path.head path in
      if Ident.global id && not (Ident.same id (Path.head path'))
      then add_required_global id;
      path'
  | _ -> path
  with Not_found when lax
  || (match path with Pident id -> not (Ident.persistent id) | _ -> true) ->
      path

let normalize_path oloc env path =
  try normalize_path (oloc = None) env path
  with Not_found ->
    match oloc with None -> assert false
    | Some loc ->
        raise (Error(Missing_module(loc, path, normalize_path true env path)))

let find_module = find_module ~alias:false

(* Find the manifest type associated to a type when appropriate:
   - the type should be public or should have a private row,
   - the type should have an associated manifest type. *)
let find_type_expansion path env =
  let decl = find_type path env in
  match decl.type_manifest with
  | Some body when decl.type_private = Public
              || decl.type_kind <> Type_abstract
              || Btype.has_constr_row body ->
                  (decl.type_params, body, may_map snd decl.type_newtype_level)
  (* The manifest type of Private abstract data types without
     private row are still considered unknown to the type system.
     Hence, this case is caught by the following clause that also handles
     purely abstract data types without manifest type definition. *)
  | _ ->
      (* another way to expand is to normalize the path itself *)
      let path' = normalize_path None env path in
      if Path.same path path' then raise Not_found else
      (decl.type_params,
       newgenty (Tconstr (path', decl.type_params, ref Mnil)),
       may_map snd decl.type_newtype_level)

(* Find the manifest type information associated to a type, i.e.
   the necessary information for the compiler's type-based optimisations.
   In particular, the manifest type associated to a private abstract type
   is revealed for the sake of compiler's type-based optimisations. *)
let find_type_expansion_opt path env =
  let decl = find_type path env in
  match decl.type_manifest with
  (* The manifest type of Private abstract data types can still get
     an approximation using their manifest type. *)
  | Some body -> (decl.type_params, body, may_map snd decl.type_newtype_level)
  | _ ->
      let path' = normalize_path None env path in
      if Path.same path path' then raise Not_found else
      (decl.type_params,
       newgenty (Tconstr (path', decl.type_params, ref Mnil)),
       may_map snd decl.type_newtype_level)

let find_modtype_expansion path env =
  match (find_modtype path env).mtd_type with
  | None -> raise Not_found
  | Some mty -> mty

let rec is_functor_arg path env =
  match path with
    Pident id ->
      begin try Ident.find_same id env.functor_args; true
      with Not_found -> false
      end
  | Pdot (p, s, _) -> is_functor_arg p env
  | Papply _ -> true

(* Lookup by name *)

exception Recmodule

let rec lookup_module_descr lid env =
  match lid with
    Lident s ->
      begin try
        EnvTbl.find_name s env.components
      with Not_found ->
        if s = !current_unit then raise Not_found;
        let ps = find_pers_struct s in
        (Pident(Ident.create_persistent s), ps.ps_comps)
      end
  | Ldot(l, s) ->
      let (p, descr) = lookup_module_descr l env in
      begin match EnvLazy.force !components_of_module_maker' descr with
        Structure_comps c ->
          let (descr, pos) = Tbl.find s c.comp_components in
          (Pdot(p, s, pos), descr)
      | Functor_comps f ->
          raise Not_found
      end
  | Lapply(l1, l2) ->
      let (p1, desc1) = lookup_module_descr l1 env in
      let p2 = lookup_module true l2 env in
      let {md_type=mty2} = find_module p2 env in
      begin match EnvLazy.force !components_of_module_maker' desc1 with
        Functor_comps f ->
          Misc.may (!check_modtype_inclusion env mty2 p2) f.fcomp_arg;
          (Papply(p1, p2), !components_of_functor_appl' f p1 p2)
      | Structure_comps c ->
          raise Not_found
      end

and lookup_module ~load lid env : Path.t =
  match lid with
    Lident s ->
      begin try
        let (p, {md_type}) as r = EnvTbl.find_name s env.modules in
        begin match md_type with
        | Mty_ident (Path.Pident id) when Ident.name id = "#recmod#" ->
          (* see #5965 *)
          raise Recmodule
        | _ -> ()
        end;
        p
      with Not_found ->
        if s = !current_unit then raise Not_found;
        if !Clflags.transparent_modules && not load then
          try ignore (find_pers_struct ~check:false s)
          with Not_found ->
	    Location.prerr_warning Location.none (Warnings.No_cmi_file s)
        else ignore (find_pers_struct s);
        Pident(Ident.create_persistent s)
      end
  | Ldot(l, s) ->
      let (p, descr) = lookup_module_descr l env in
      begin match EnvLazy.force !components_of_module_maker' descr with
        Structure_comps c ->
          let (data, pos) = Tbl.find s c.comp_modules in
          Pdot(p, s, pos)
      | Functor_comps f ->
          raise Not_found
      end
  | Lapply(l1, l2) ->
      let (p1, desc1) = lookup_module_descr l1 env in
      let p2 = lookup_module true l2 env in
      let {md_type=mty2} = find_module p2 env in
      let p = Papply(p1, p2) in
      begin match EnvLazy.force !components_of_module_maker' desc1 with
        Functor_comps f ->
          Misc.may (!check_modtype_inclusion env mty2 p2) f.fcomp_arg;
          p
      | Structure_comps c ->
          raise Not_found
      end

let lookup proj1 proj2 lid env =
  match lid with
    Lident s ->
      EnvTbl.find_name s (proj1 env)
  | Ldot(l, s) ->
      let (p, desc) = lookup_module_descr l env in
      begin match EnvLazy.force !components_of_module_maker' desc with
        Structure_comps c ->
          let (data, pos) = Tbl.find s (proj2 c) in
          (Pdot(p, s, pos), data)
      | Functor_comps f ->
          raise Not_found
      end
  | Lapply(l1, l2) ->
      raise Not_found

let lookup_simple proj1 proj2 lid env =
  match lid with
    Lident s ->
      EnvTbl.find_name s (proj1 env)
  | Ldot(l, s) ->
      let (p, desc) = lookup_module_descr l env in
      begin match EnvLazy.force !components_of_module_maker' desc with
        Structure_comps c ->
          let (data, pos) = Tbl.find s (proj2 c) in
          data
      | Functor_comps f ->
          raise Not_found
      end
  | Lapply(l1, l2) ->
      raise Not_found

let lookup_all_simple proj1 proj2 shadow lid env =
  match lid with
    Lident s ->
      let xl = EnvTbl.find_all s (proj1 env) in
      let rec do_shadow =
        function
        | [] -> []
        | ((x, f) :: xs) ->
            (x, f) ::
              (do_shadow (List.filter (fun (y, g) -> not (shadow x y)) xs))
      in
        do_shadow xl
  | Ldot(l, s) ->
      let (p, desc) = lookup_module_descr l env in
      begin match EnvLazy.force !components_of_module_maker' desc with
        Structure_comps c ->
          let comps =
            try Tbl.find s (proj2 c) with Not_found -> []
          in
          List.map
            (fun (data, pos) -> (data, (fun () -> ())))
            comps
      | Functor_comps f ->
          raise Not_found
      end
  | Lapply(l1, l2) ->
      raise Not_found

let has_local_constraints env = env.local_constraints

let cstr_shadow cstr1 cstr2 =
  match cstr1.cstr_tag, cstr2.cstr_tag with
  | Cstr_extension _, Cstr_extension _ -> true
  | _ -> false

let lbl_shadow lbl1 lbl2 = false

let lookup_value =
  lookup (fun env -> env.values) (fun sc -> sc.comp_values)
and lookup_all_constructors =
  lookup_all_simple (fun env -> env.constrs) (fun sc -> sc.comp_constrs)
    cstr_shadow
and lookup_all_labels =
  lookup_all_simple (fun env -> env.labels) (fun sc -> sc.comp_labels)
    lbl_shadow
and lookup_type =
  lookup (fun env -> env.types) (fun sc -> sc.comp_types)
and lookup_modtype =
  lookup (fun env -> env.modtypes) (fun sc -> sc.comp_modtypes)
and lookup_class =
  lookup (fun env -> env.classes) (fun sc -> sc.comp_classes)
and lookup_cltype =
  lookup (fun env -> env.cltypes) (fun sc -> sc.comp_cltypes)

let mark_value_used env name vd =
  if not (is_implicit_coercion env) then
    try Hashtbl.find value_declarations (name, vd.val_loc) ()
    with Not_found -> ()

let mark_type_used env name vd =
  if not (is_implicit_coercion env) then
    try Hashtbl.find type_declarations (name, vd.type_loc) ()
    with Not_found -> ()

let mark_constructor_used usage env name vd constr =
  if not (is_implicit_coercion env) then
    try Hashtbl.find used_constructors (name, vd.type_loc, constr) usage
    with Not_found -> ()

let mark_extension_used usage env ext name =
  if not (is_implicit_coercion env) then
    let ty_name = Path.last ext.ext_type_path in
    try Hashtbl.find used_constructors (ty_name, ext.ext_loc, name) usage
    with Not_found -> ()

let set_value_used_callback name vd callback =
  let key = (name, vd.val_loc) in
  try
    let old = Hashtbl.find value_declarations key in
    Hashtbl.replace value_declarations key (fun () -> old (); callback ())
      (* this is to support cases like:
               let x = let x = 1 in x in x
         where the two declarations have the same location
         (e.g. resulting from Camlp4 expansion of grammar entries) *)
  with Not_found ->
    Hashtbl.add value_declarations key callback

let set_type_used_callback name td callback =
  let loc = td.type_loc in
  if loc.Location.loc_ghost then ()
  else let key = (name, loc) in
  let old =
    try Hashtbl.find type_declarations key
    with Not_found -> assert false
  in
  Hashtbl.replace type_declarations key (fun () -> callback old)

let lookup_value lid env =
  let (_, desc) as r = lookup_value lid env in
  mark_value_used env (Longident.last lid) desc;
  r

let lookup_type lid env =
  let (path, (decl, _)) = lookup_type lid env in
  mark_type_used env (Longident.last lid) decl;
  (path, decl)

(* [path] must be the path to a type, not to a module ! *)
let path_subst_last path id =
  match path with
    Pident _ -> Pident id
  | Pdot (p, name, pos) -> Pdot(p, Ident.name id, pos)
  | Papply (p1, p2) -> assert false

let mark_type_path env path =
  try
    let decl = find_type path env in
    mark_type_used env (Path.last path) decl
  with Not_found -> ()

let ty_path t =
  match repr t with
  | {desc=Tconstr(path, _, _)} -> path
  | _ -> assert false

let lookup_constructor lid env =
  match lookup_all_constructors lid env with
    [] -> raise Not_found
  | (desc, use) :: _ ->
      mark_type_path env (ty_path desc.cstr_res);
      use ();
      desc

let is_lident = function
    Lident _ -> true
  | _ -> false

let lookup_all_constructors lid env =
  try
    let cstrs = lookup_all_constructors lid env in
    let wrap_use desc use () =
      mark_type_path env (ty_path desc.cstr_res);
      use ()
    in
    List.map (fun (cstr, use) -> (cstr, wrap_use cstr use)) cstrs
  with
    Not_found when is_lident lid -> []

let mark_constructor usage env name desc =
  if not (is_implicit_coercion env)
  then match desc.cstr_tag with
  | Cstr_extension _ ->
      begin
        let ty_path = ty_path desc.cstr_res in
        let ty_name = Path.last ty_path in
        try Hashtbl.find used_constructors (ty_name, desc.cstr_loc, name) usage
        with Not_found -> ()
      end
  | _ ->
      let ty_path = ty_path desc.cstr_res in
      let ty_decl = try find_type ty_path env with Not_found -> assert false in
      let ty_name = Path.last ty_path in
      mark_constructor_used usage env ty_name ty_decl name

let lookup_label lid env =
  match lookup_all_labels lid env with
    [] -> raise Not_found
  | (desc, use) :: _ ->
      mark_type_path env (ty_path desc.lbl_res);
      use ();
      desc

let lookup_all_labels lid env =
  try
    let lbls = lookup_all_labels lid env in
    let wrap_use desc use () =
      mark_type_path env (ty_path desc.lbl_res);
      use ()
    in
    List.map (fun (lbl, use) -> (lbl, wrap_use lbl use)) lbls
  with
    Not_found when is_lident lid -> []

let lookup_class lid env =
  let (_, desc) as r = lookup_class lid env in
  (* special support for Typeclass.unbound_class *)
  if Path.name desc.cty_path = "" then ignore (lookup_type lid env)
  else mark_type_path env desc.cty_path;
  r

let lookup_cltype lid env =
  let (_, desc) as r = lookup_cltype lid env in
  if Path.name desc.clty_path = "" then ignore (lookup_type lid env)
  else mark_type_path env desc.clty_path;
  mark_type_path env desc.clty_path;
  r

(* Iter on an environment (ignoring the body of functors and
   not yet evaluated structures) *)

type iter_cont = unit -> unit
let iter_env_cont = ref []

let rec scrape_alias_safe env mty =
  match mty with
  | Mty_alias (Pident id) when Ident.persistent id -> false
  | Mty_alias path -> (* PR#6600: find_module may raise Not_found *)
      scrape_alias_safe env (find_module path env).md_type
  | _ -> true

let iter_env proj1 proj2 f env () =
  Ident.iter (fun id (x,_) -> f (Pident id) x) (proj1 env);
  let rec iter_components path path' mcomps =
    let cont () =
      let safe =
        match EnvLazy.get_arg mcomps with
          None -> true
        | Some (env, sub, path, mty) ->
            try scrape_alias_safe env mty with Not_found -> false
      in
      if not safe then () else
      match EnvLazy.force !components_of_module_maker' mcomps with
        Structure_comps comps ->
          Tbl.iter
            (fun s (d, n) -> f (Pdot (path, s, n)) (Pdot (path', s, n), d))
            (proj2 comps);
          Tbl.iter
            (fun s (c, n) ->
              iter_components (Pdot (path, s, n)) (Pdot (path', s, n)) c)
            comps.comp_components
      | Functor_comps _ -> ()
    in iter_env_cont := (path, cont) :: !iter_env_cont
  in
  Hashtbl.iter
    (fun s pso ->
      match pso with None -> ()
      | Some ps ->
          let id = Pident (Ident.create_persistent s) in
          iter_components id id ps.ps_comps)
    persistent_structures;
  Ident.iter
    (fun id ((path, comps), _) -> iter_components (Pident id) path comps)
    env.components

let run_iter_cont l =
  iter_env_cont := [];
  List.iter (fun c -> c ()) l;
  let cont = List.rev !iter_env_cont in
  iter_env_cont := [];
  cont

let iter_types f = iter_env (fun env -> env.types) (fun sc -> sc.comp_types) f

let same_types env1 env2 =
  env1.types == env2.types && env1.components == env2.components

let used_persistent () =
  let r = ref Concr.empty in
  Hashtbl.iter (fun s pso -> if pso != None then r := Concr.add s !r)
    persistent_structures;
  !r

let find_all_comps proj s (p,mcomps) =
  match EnvLazy.force !components_of_module_maker' mcomps with
    Functor_comps _ -> []
  | Structure_comps comps ->
      try let (c,n) = Tbl.find s (proj comps) in [Pdot(p,s,n), c]
      with Not_found -> []

let rec find_shadowed_comps path env =
  match path with
    Pident id ->
      List.map fst (Ident.find_all (Ident.name id) env.components)
  | Pdot (p, s, _) ->
      let l = find_shadowed_comps p env in
      let l' =
        List.map (find_all_comps (fun comps -> comps.comp_components) s) l in
      List.flatten l'
  | Papply _ -> []

let find_shadowed proj1 proj2 path env =
  match path with
    Pident id ->
      List.map fst (Ident.find_all (Ident.name id) (proj1 env))
  | Pdot (p, s, _) ->
      let l = find_shadowed_comps p env in
      let l' = List.map (find_all_comps proj2 s) l in
      List.flatten l'
  | Papply _ -> []

let find_shadowed_types path env =
  let l =
    find_shadowed
      (fun env -> env.types) (fun comps -> comps.comp_types) path env
  in
  List.map fst l


(* GADT instance tracking *)

let add_gadt_instance_level lv env =
  {env with
   gadt_instances = (lv, ref TypeSet.empty) :: env.gadt_instances}

let is_Tlink = function {desc = Tlink _} -> true | _ -> false

let gadt_instance_level env t =
  let rec find_instance = function
      [] -> None
    | (lv, r) :: rem ->
        if TypeSet.exists is_Tlink !r then
          (* Should we use set_typeset ? *)
          r := TypeSet.fold (fun ty -> TypeSet.add (repr ty)) !r TypeSet.empty;
        if TypeSet.mem t !r then Some lv else find_instance rem
  in find_instance env.gadt_instances

let add_gadt_instances env lv tl =
  let r =
    try List.assoc lv env.gadt_instances with Not_found -> assert false in
  (* Format.eprintf "Added";
  List.iter (fun ty -> Format.eprintf "@ %a" !Btype.print_raw ty) tl;
  Format.eprintf "@."; *)
  set_typeset r (List.fold_right TypeSet.add tl !r)

(* Only use this after expand_head! *)
let add_gadt_instance_chain env lv t =
  let r =
    try List.assoc lv env.gadt_instances with Not_found -> assert false in
  let rec add_instance t =
    let t = repr t in
    if not (TypeSet.mem t !r) then begin
      (* Format.eprintf "@ %a" !Btype.print_raw t; *)
      set_typeset r (TypeSet.add t !r);
      match t.desc with
        Tconstr (p, _, memo) ->
          may add_instance (find_expans Private p !memo)
      | _ -> ()
    end
  in
  (* Format.eprintf "Added chain"; *)
  add_instance t
  (* Format.eprintf "@." *)

(* Expand manifest module type names at the top of the given module type *)

let rec scrape_alias env ?path mty =
  match mty, path with
    Mty_ident p, _ ->
      begin try
        scrape_alias env (find_modtype_expansion p env) ?path
      with Not_found ->
        mty
      end
  | Mty_alias path, _ ->
      begin try
        scrape_alias env (find_module path env).md_type ~path
      with Not_found ->
        (*Location.prerr_warning Location.none
	  (Warnings.No_cmi_file (Path.name path));*)
        mty
      end
  | mty, Some path ->
      !strengthen env mty path
  | _ -> mty

let scrape_alias env mty = scrape_alias env mty

(* Compute constructor descriptions *)

let constructors_of_type ty_path decl =
  let handle_variants cstrs =
    Datarepr.constructor_descrs
      (newgenty (Tconstr(ty_path, decl.type_params, ref Mnil)))
      cstrs decl.type_private
  in
  match decl.type_kind with
  | Type_variant cstrs -> handle_variants cstrs
  | Type_record _ | Type_abstract | Type_open -> []

(* Compute label descriptions *)

let labels_of_type ty_path decl =
  match decl.type_kind with
    Type_record(labels, rep) ->
      Datarepr.label_descrs
        (newgenty (Tconstr(ty_path, decl.type_params, ref Mnil)))
        labels rep decl.type_private
  | Type_variant _ | Type_abstract | Type_open -> []

(* Given a signature and a root path, prefix all idents in the signature
   by the root path and build the corresponding substitution. *)

let rec prefix_idents root pos sub = function
    [] -> ([], sub)
  | Sig_value(id, decl) :: rem ->
      let p = Pdot(root, Ident.name id, pos) in
      let nextpos = match decl.val_kind with Val_prim _ -> pos | _ -> pos+1 in
      let (pl, final_sub) = prefix_idents root nextpos sub rem in
      (p::pl, final_sub)
  | Sig_type(id, decl, _) :: rem ->
      let p = Pdot(root, Ident.name id, nopos) in
      let (pl, final_sub) =
        prefix_idents root pos (Subst.add_type id p sub) rem in
      (p::pl, final_sub)
  | Sig_typext(id, ext, _) :: rem ->
      let p = Pdot(root, Ident.name id, pos) in
      let (pl, final_sub) = prefix_idents root (pos+1) sub rem in
      (p::pl, final_sub)
  | Sig_module(id, mty, _) :: rem ->
      let p = Pdot(root, Ident.name id, pos) in
      let (pl, final_sub) =
        prefix_idents root (pos+1) (Subst.add_module id p sub) rem in
      (p::pl, final_sub)
  | Sig_modtype(id, decl) :: rem ->
      let p = Pdot(root, Ident.name id, nopos) in
      let (pl, final_sub) =
        prefix_idents root pos
                      (Subst.add_modtype id (Mty_ident p) sub) rem in
      (p::pl, final_sub)
  | Sig_class(id, decl, _) :: rem ->
      let p = Pdot(root, Ident.name id, pos) in
      let (pl, final_sub) = prefix_idents root (pos + 1) sub rem in
      (p::pl, final_sub)
  | Sig_class_type(id, decl, _) :: rem ->
      let p = Pdot(root, Ident.name id, nopos) in
      let (pl, final_sub) = prefix_idents root pos sub rem in
      (p::pl, final_sub)

let subst_signature sub sg =
  List.map
    (fun item ->
      match item with
      | Sig_value(id, decl) ->
          Sig_value (id, Subst.value_description sub decl)
      | Sig_type(id, decl, x) ->
          Sig_type(id, Subst.type_declaration sub decl, x)
      | Sig_typext(id, ext, es) ->
          Sig_typext (id, Subst.extension_constructor sub ext, es)
      | Sig_module(id, mty, x) ->
          Sig_module(id, Subst.module_declaration sub mty,x)
      | Sig_modtype(id, decl) ->
          Sig_modtype(id, Subst.modtype_declaration sub decl)
      | Sig_class(id, decl, x) ->
          Sig_class(id, Subst.class_declaration sub decl, x)
      | Sig_class_type(id, decl, x) ->
          Sig_class_type(id, Subst.cltype_declaration sub decl, x)
    )
    sg


let prefix_idents_and_subst root sub sg =
  let (pl, sub) = prefix_idents root 0 sub sg in
  pl, sub, lazy (subst_signature sub sg)

let prefix_idents_and_subst root sub sg =
  if sub = Subst.identity then
    let sgs =
      try
        Hashtbl.find prefixed_sg root
      with Not_found ->
        let sgs = ref [] in
        Hashtbl.add prefixed_sg root sgs;
        sgs
    in
    try
      List.assq sg !sgs
    with Not_found ->
      let r = prefix_idents_and_subst root sub sg in
      sgs := (sg, r) :: !sgs;
      r
  else
    prefix_idents_and_subst root sub sg

(* Compute structure descriptions *)

let add_to_tbl id decl tbl =
  let decls =
    try Tbl.find id tbl with Not_found -> [] in
  Tbl.add id (decl :: decls) tbl

let rec components_of_module env sub path mty =
  EnvLazy.create (env, sub, path, mty)

and components_of_module_maker (env, sub, path, mty) =
  (match scrape_alias env mty with
    Mty_signature sg ->
      let c =
        { comp_values = Tbl.empty;
          comp_constrs = Tbl.empty;
          comp_labels = Tbl.empty; comp_types = Tbl.empty;
          comp_modules = Tbl.empty; comp_modtypes = Tbl.empty;
          comp_components = Tbl.empty; comp_classes = Tbl.empty;
          comp_cltypes = Tbl.empty } in
      let pl, sub, _ = prefix_idents_and_subst path sub sg in
      let env = ref env in
      let pos = ref 0 in
      List.iter2 (fun item path ->
        match item with
          Sig_value(id, decl) ->
            let decl' = Subst.value_description sub decl in
            c.comp_values <-
              Tbl.add (Ident.name id) (decl', !pos) c.comp_values;
            begin match decl.val_kind with
              Val_prim _ -> () | _ -> incr pos
            end
        | Sig_type(id, decl, _) ->
            let decl' = Subst.type_declaration sub decl in
            let constructors = List.map snd (constructors_of_type path decl') in
            let labels = List.map snd (labels_of_type path decl') in
            c.comp_types <-
              Tbl.add (Ident.name id)
                ((decl', (constructors, labels)), nopos)
                  c.comp_types;
            List.iter
              (fun descr ->
                c.comp_constrs <-
                  add_to_tbl descr.cstr_name (descr, nopos) c.comp_constrs)
              constructors;
            List.iter
              (fun descr ->
                c.comp_labels <-
                  add_to_tbl descr.lbl_name (descr, nopos) c.comp_labels)
              labels;
            env := store_type_infos None id (Pident id) decl !env !env
        | Sig_typext(id, ext, _) ->
            let ext' = Subst.extension_constructor sub ext in
            let descr = Datarepr.extension_descr path ext' in
            c.comp_constrs <-
              add_to_tbl (Ident.name id) (descr, !pos) c.comp_constrs;
            incr pos
        | Sig_module(id, md, _) ->
            let mty = md.md_type in
            let mty' = EnvLazy.create (sub, mty) in
            c.comp_modules <-
              Tbl.add (Ident.name id) (mty', !pos) c.comp_modules;
            let comps = components_of_module !env sub path mty in
            c.comp_components <-
              Tbl.add (Ident.name id) (comps, !pos) c.comp_components;
            env := store_module None id (Pident id) md !env !env;
            incr pos
        | Sig_modtype(id, decl) ->
            let decl' = Subst.modtype_declaration sub decl in
            c.comp_modtypes <-
              Tbl.add (Ident.name id) (decl', nopos) c.comp_modtypes;
            env := store_modtype None id (Pident id) decl !env !env
        | Sig_class(id, decl, _) ->
            let decl' = Subst.class_declaration sub decl in
            c.comp_classes <-
              Tbl.add (Ident.name id) (decl', !pos) c.comp_classes;
            incr pos
        | Sig_class_type(id, decl, _) ->
            let decl' = Subst.cltype_declaration sub decl in
            c.comp_cltypes <-
              Tbl.add (Ident.name id) (decl', !pos) c.comp_cltypes)
        sg pl;
        Structure_comps c
  | Mty_functor(param, ty_arg, ty_res) ->
        Functor_comps {
          fcomp_param = param;
          (* fcomp_arg must be prefixed eagerly, because it is interpreted
             in the outer environment, not in env *)
          fcomp_arg = may_map (Subst.modtype sub) ty_arg;
          (* fcomp_res is prefixed lazily, because it is interpreted in env *)
          fcomp_res = ty_res;
          fcomp_env = env;
          fcomp_subst = sub;
          fcomp_cache = Hashtbl.create 17;
          fcomp_subst_cache = Hashtbl.create 17 }
  | Mty_ident _
  | Mty_alias _ ->
        Structure_comps {
          comp_values = Tbl.empty;
          comp_constrs = Tbl.empty;
          comp_labels = Tbl.empty;
          comp_types = Tbl.empty;
          comp_modules = Tbl.empty; comp_modtypes = Tbl.empty;
          comp_components = Tbl.empty; comp_classes = Tbl.empty;
          comp_cltypes = Tbl.empty })

(* Insertion of bindings by identifier + path *)

and check_usage loc id warn tbl =
  if not loc.Location.loc_ghost && Warnings.is_active (warn "") then begin
    let name = Ident.name id in
    let key = (name, loc) in
    if Hashtbl.mem tbl key then ()
    else let used = ref false in
    Hashtbl.add tbl key (fun () -> used := true);
    if not (name = "" || name.[0] = '_' || name.[0] = '#')
    then
      !add_delayed_check_forward
        (fun () -> if not !used then Location.prerr_warning loc (warn name))
  end;

and check_value_name name loc =
  (* Note: we could also check here general validity of the
     identifier, to protect against bad identifiers forged by -pp or
     -ppx preprocessors. *)
  if !Clflags.bs_only && name = "|." then raise (Error(Illegal_value_name(loc, name)))
  else if String.length name > 0 && (name.[0] = '#') then
    for i = 1 to String.length name - 1 do
      if name.[i] = '#' then
        raise (Error(Illegal_value_name(loc, name)))
    done


and store_value ?check slot id path decl env renv =
  check_value_name (Ident.name id) decl.val_loc;
  may (fun f -> check_usage decl.val_loc id f value_declarations) check;
  { env with
    values = EnvTbl.add "value" slot id (path, decl) env.values renv.values;
    summary = Env_value(env.summary, id, decl) }

and store_type ~check slot id path info env renv =
  let loc = info.type_loc in
  if check then
    check_usage loc id (fun s -> Warnings.Unused_type_declaration s)
      type_declarations;
  let constructors = constructors_of_type path info in
  let labels = labels_of_type path info in
  let descrs = (List.map snd constructors, List.map snd labels) in

  if check && not loc.Location.loc_ghost &&
    Warnings.is_active (Warnings.Unused_constructor ("", false, false))
  then begin
    let ty = Ident.name id in
    List.iter
      begin fun (_, {cstr_name = c; _}) ->
        let k = (ty, loc, c) in
        if not (Hashtbl.mem used_constructors k) then
          let used = constructor_usages () in
          Hashtbl.add used_constructors k (add_constructor_usage used);
          if not (ty = "" || ty.[0] = '_')
          then !add_delayed_check_forward
              (fun () ->
                if not (is_in_signature env) && not used.cu_positive then
                  Location.prerr_warning loc
                    (Warnings.Unused_constructor
                       (c, used.cu_pattern, used.cu_privatize)))
      end
      constructors
  end;
  { env with
    constrs =
      List.fold_right
        (fun (id, descr) constrs ->
          EnvTbl.add "constructor" slot id descr constrs renv.constrs)
        constructors
        env.constrs;
    labels =
      List.fold_right
        (fun (id, descr) labels ->
          EnvTbl.add "label" slot id descr labels renv.labels)
        labels
        env.labels;
    types = EnvTbl.add "type" slot id (path, (info, descrs)) env.types
                       renv.types;
    summary = Env_type(env.summary, id, info) }

and store_type_infos slot id path info env renv =
  (* Simplified version of store_type that doesn't compute and store
     constructor and label infos, but simply record the arity and
     manifest-ness of the type.  Used in components_of_module to
     keep track of type abbreviations (e.g. type t = float) in the
     computation of label representations. *)
  { env with
    types = EnvTbl.add "type" slot id (path, (info,([],[]))) env.types
                       renv.types;
    summary = Env_type(env.summary, id, info) }

and store_extension ~check slot id path ext env renv =
  let loc = ext.ext_loc in
  if check && not loc.Location.loc_ghost &&
    Warnings.is_active (Warnings.Unused_extension ("", false, false))
  then begin
    let ty = Path.last ext.ext_type_path in
    let n = Ident.name id in
    let k = (ty, loc, n) in
    if not (Hashtbl.mem used_constructors k) then begin
      let used = constructor_usages () in
      Hashtbl.add used_constructors k (add_constructor_usage used);
      !add_delayed_check_forward
        (fun () ->
          if not (is_in_signature env) && not used.cu_positive then
            Location.prerr_warning loc
              (Warnings.Unused_extension
                 (n, used.cu_pattern, used.cu_privatize)
              )
        )
    end;
  end;
  { env with
    constrs = EnvTbl.add "constructor" slot id
                (Datarepr.extension_descr path ext)
                env.constrs renv.constrs;
    summary = Env_extension(env.summary, id, ext) }

and store_module slot id path md env renv =
  { env with
    modules = EnvTbl.add "module" slot id (path, md) env.modules renv.modules;
    components =
      EnvTbl.add "module" slot id
                 (path, components_of_module env Subst.identity path md.md_type)
                   env.components renv.components;
    summary = Env_module(env.summary, id, md) }

and store_modtype slot id path info env renv =
  { env with
    modtypes = EnvTbl.add "module type" slot id (path, info) env.modtypes
                          renv.modtypes;
    summary = Env_modtype(env.summary, id, info) }

and store_class slot id path desc env renv =
  { env with
    classes = EnvTbl.add "class" slot id (path, desc) env.classes renv.classes;
    summary = Env_class(env.summary, id, desc) }

and store_cltype slot id path desc env renv =
  { env with
    cltypes = EnvTbl.add "class type" slot id (path, desc) env.cltypes
                         renv.cltypes;
    summary = Env_cltype(env.summary, id, desc) }

(* Compute the components of a functor application in a path. *)

let components_of_functor_appl f p1 p2 =
  try
    Hashtbl.find f.fcomp_cache p2
  with Not_found ->
    let p = Papply(p1, p2) in
    let mty =
      Subst.modtype (Subst.add_module f.fcomp_param p2 Subst.identity)
                    f.fcomp_res in
    let comps = components_of_module f.fcomp_env f.fcomp_subst p mty in
    Hashtbl.add f.fcomp_cache p2 comps;
    comps

(* Define forward functions *)

let _ =
  components_of_module' := components_of_module;
  components_of_functor_appl' := components_of_functor_appl;
  components_of_module_maker' := components_of_module_maker

(* Insertion of bindings by identifier *)

let add_functor_arg ?(arg=false) id env =
  if not arg then env else
  {env with
   functor_args = Ident.add id () env.functor_args;
   summary = Env_functor_arg (env.summary, id)}

let add_value ?check id desc env =
  store_value None ?check id (Pident id) desc env env

let add_type ~check id info env =
  store_type ~check None id (Pident id) info env env

and add_extension ~check id ext env =
  store_extension ~check None id (Pident id) ext env env

and add_module_declaration ?arg id md env =
  let path =
    (*match md.md_type with
      Mty_alias path -> normalize_path env path
    | _ ->*) Pident id
  in
  let env = store_module None id path md env env in
  add_functor_arg ?arg id env

and add_modtype id info env =
  store_modtype None id (Pident id) info env env

and add_class id ty env =
  store_class None id (Pident id) ty env env

and add_cltype id ty env =
  store_cltype None id (Pident id) ty env env

let add_module ?arg id mty env =
  add_module_declaration ?arg id (md mty) env

let add_local_constraint id info elv env =
  match info with
    {type_manifest = Some ty; type_newtype_level = Some (lv, _)} ->
      (* elv is the expansion level, lv is the definition level *)
      let env =
        add_type ~check:false
          id {info with type_newtype_level = Some (lv, elv)} env in
      { env with local_constraints = true }
  | _ -> assert false

(* Insertion of bindings by name *)

let enter store_fun name data env =
  let id = Ident.create name in (id, store_fun None id (Pident id) data env env)

let enter_value ?check = enter (store_value ?check)
and enter_type = enter (store_type ~check:true)
and enter_extension = enter (store_extension ~check:true)
and enter_module_declaration ?arg name md env =
  let id = Ident.create name in
  (id, add_module_declaration ?arg id md env)
  (* let (id, env) = enter store_module name md env in
  (id, add_functor_arg ?arg id env) *)
and enter_modtype = enter store_modtype
and enter_class = enter store_class
and enter_cltype = enter store_cltype

let enter_module ?arg s mty env =
  enter_module_declaration ?arg s (md mty) env

(* Insertion of all components of a signature *)

let add_item comp env =
  match comp with
    Sig_value(id, decl)     -> add_value id decl env
  | Sig_type(id, decl, _)   -> add_type ~check:false id decl env
  | Sig_typext(id, ext, _)  -> add_extension ~check:false id ext env
  | Sig_module(id, md, _)  -> add_module_declaration id md env
  | Sig_modtype(id, decl)   -> add_modtype id decl env
  | Sig_class(id, decl, _)  -> add_class id decl env
  | Sig_class_type(id, decl, _) -> add_cltype id decl env

let rec add_signature sg env =
  match sg with
    [] -> env
  | comp :: rem -> add_signature rem (add_item comp env)

(* Open a signature path *)

let open_signature slot root sg env0 =
  (* First build the paths and substitution *)
  let (pl, sub, sg) = prefix_idents_and_subst root Subst.identity sg in
  let sg = Lazy.force sg in

  (* Then enter the components in the environment after substitution *)

  let newenv =
    List.fold_left2
      (fun env item p ->
        match item with
          Sig_value(id, decl) ->
            store_value slot (Ident.hide id) p decl env env0
        | Sig_type(id, decl, _) ->
            store_type ~check:false slot (Ident.hide id) p decl env env0
        | Sig_typext(id, ext, _) ->
            store_extension ~check:false slot (Ident.hide id) p ext env env0
        | Sig_module(id, mty, _) ->
            store_module slot (Ident.hide id) p mty env env0
        | Sig_modtype(id, decl) ->
            store_modtype slot (Ident.hide id) p decl env env0
        | Sig_class(id, decl, _) ->
            store_class slot (Ident.hide id) p decl env env0
        | Sig_class_type(id, decl, _) ->
            store_cltype slot (Ident.hide id) p decl env env0
      )
      env0 sg pl in
  { newenv with summary = Env_open(env0.summary, root) }

(* Open a signature from a file *)

let open_pers_signature name env =
  let ps = find_pers_struct name in
  open_signature None (Pident(Ident.create_persistent name)) ps.ps_sig env

let open_signature ?(loc = Location.none) ?(toplevel = false) ovf root sg env =
  if not toplevel && ovf = Asttypes.Fresh && not loc.Location.loc_ghost
     && (Warnings.is_active (Warnings.Unused_open "")
         || Warnings.is_active (Warnings.Open_shadow_identifier ("", ""))
         || Warnings.is_active (Warnings.Open_shadow_label_constructor ("","")))
  then begin
    let used = ref false in
    !add_delayed_check_forward
      (fun () ->
        if not !used then
          Location.prerr_warning loc (Warnings.Unused_open (Path.name root))
      );
    let shadowed = ref [] in
    let slot kind s b =
      if b && not (List.mem (kind, s) !shadowed) then begin
        shadowed := (kind, s) :: !shadowed;
        let w =
          match kind with
          | "label" | "constructor" ->
              Warnings.Open_shadow_label_constructor (kind, s)
          | _ -> Warnings.Open_shadow_identifier (kind, s)
        in
        Location.prerr_warning loc w
      end;
      used := true
    in
    open_signature (Some slot) root sg env
  end
  else open_signature None root sg env

(* Read a signature from a file *)

let read_signature modname filename =
  let ps = read_pers_struct modname filename in
  check_consistency ps;
  ps.ps_sig

(* Return the CRC of the interface of the given compilation unit *)

let crc_of_unit name =
  let ps = find_pers_struct name in
  let crco =
    try
      List.assoc name ps.ps_crcs
    with Not_found ->
      assert false
  in
    match crco with
      None -> assert false
    | Some crc -> crc

(* Return the list of imported interfaces with their CRCs *)

let imports() =

  let dont_record_crc_unit = !Clflags.dont_record_crc_unit in
  match dont_record_crc_unit with
  | None -> Consistbl.extract (StringSet.elements !imported_units) crc_units
  | Some x ->
    Consistbl.extract
      (StringSet.fold
      (fun m acc -> if m = x then acc else m::acc)
      !imported_units []) crc_units


(* Save a signature to a file *)

let save_signature_with_imports sg modname filename imports =
  (*prerr_endline filename;
  List.iter (fun (name, crc) -> prerr_endline name) imports;*)
  Btype.cleanup_abbrev ();
  Subst.reset_for_saving ();
  let sg = Subst.signature (Subst.for_saving Subst.identity) sg in
  let oc = open_out_bin filename in
  try
    let cmi = {
      cmi_name = modname;
      cmi_sign = sg;
      cmi_crcs = imports;
      cmi_flags = if !Clflags.recursive_types then [Rectypes] else [];
    } in
    let crc = output_cmi filename oc cmi in
    close_out oc;
    (* Enter signature in persistent table so that imported_unit()
       will also return its crc *)
    let comps =
      components_of_module empty Subst.identity
        (Pident(Ident.create_persistent modname)) (Mty_signature sg) in
    let ps =
      { ps_name = modname;
        ps_sig = sg;
        ps_comps = comps;
        ps_crcs = (cmi.cmi_name, Some crc) :: imports;
        ps_filename = filename;
        ps_flags = cmi.cmi_flags;
        ps_crcs_checked = false;
      } in
    save_pers_struct crc ps;
    sg
  with exn ->
    close_out oc;
    remove_file filename;
    raise exn

let save_signature sg modname filename =
  save_signature_with_imports sg modname filename (imports())

(* Folding on environments *)

let find_all proj1 proj2 f lid env acc =
  match lid with
    | None ->
      EnvTbl.fold_name
        (fun id (p, data) acc -> f (Ident.name id) p data acc)
        (proj1 env) acc
    | Some l ->
      let p, desc = lookup_module_descr l env in
      begin match EnvLazy.force components_of_module_maker desc with
          Structure_comps c ->
            Tbl.fold
              (fun s (data, pos) acc -> f s (Pdot (p, s, pos)) data acc)
              (proj2 c) acc
        | Functor_comps _ ->
            acc
      end

let find_all_simple_list proj1 proj2 f lid env acc =
  match lid with
    | None ->
      EnvTbl.fold_name
        (fun id data acc -> f data acc)
        (proj1 env) acc
    | Some l ->
      let p, desc = lookup_module_descr l env in
      begin match EnvLazy.force components_of_module_maker desc with
          Structure_comps c ->
            Tbl.fold
              (fun s comps acc ->
                match comps with
                  [] -> acc
                | (data, pos) :: _ ->
                  f data acc)
              (proj2 c) acc
        | Functor_comps _ ->
            acc
      end

let fold_modules f lid env acc =
  match lid with
    | None ->
      let acc =
        EnvTbl.fold_name
          (fun id (p, data) acc -> f (Ident.name id) p data acc)
          env.modules
          acc
      in
      Hashtbl.fold
        (fun name ps acc ->
          match ps with
              None -> acc
            | Some ps ->
              f name (Pident(Ident.create_persistent name))
                     (md (Mty_signature ps.ps_sig)) acc)
        persistent_structures
        acc
    | Some l ->
      let p, desc = lookup_module_descr l env in
      begin match EnvLazy.force components_of_module_maker desc with
          Structure_comps c ->
            Tbl.fold
              (fun s (data, pos) acc ->
                f s (Pdot (p, s, pos))
                    (md (EnvLazy.force subst_modtype_maker data)) acc)
              c.comp_modules
              acc
        | Functor_comps _ ->
            acc
      end

let fold_values f =
  find_all (fun env -> env.values) (fun sc -> sc.comp_values) f
and fold_constructors f =
  find_all_simple_list (fun env -> env.constrs) (fun sc -> sc.comp_constrs) f
and fold_labels f =
  find_all_simple_list (fun env -> env.labels) (fun sc -> sc.comp_labels) f
and fold_types f =
  find_all (fun env -> env.types) (fun sc -> sc.comp_types) f
and fold_modtypes f =
  find_all (fun env -> env.modtypes) (fun sc -> sc.comp_modtypes) f
and fold_classs f =
  find_all (fun env -> env.classes) (fun sc -> sc.comp_classes) f
and fold_cltypes f =
  find_all (fun env -> env.cltypes) (fun sc -> sc.comp_cltypes) f


(* Make the initial environment *)
let (initial_safe_string, initial_unsafe_string) =
  Predef.build_initial_env
    (add_type ~check:false)
    (add_extension ~check:false)
    empty

(* Return the environment summary *)

let summary env = env.summary

let last_env = ref empty
let last_reduced_env = ref empty

let keep_only_summary env =
  if !last_env == env then !last_reduced_env
  else begin
    let new_env =
      {
       empty with
       summary = env.summary;
       local_constraints = env.local_constraints;
       flags = env.flags;
      }
    in
    last_env := env;
    last_reduced_env := new_env;
    new_env
  end


let env_of_only_summary env_from_summary env =
  let new_env = env_from_summary env.summary Subst.identity in
  { new_env with
    local_constraints = env.local_constraints;
    flags = env.flags;
  }

(* Error report *)

open Format

let report_error ppf = function
  | Illegal_renaming(name, modname, filename) -> fprintf ppf
      "Wrong file naming: %a@ contains the compiled interface for @ \
       %s when %s was expected"
      Location.print_filename filename name modname
  | Inconsistent_import(name, source1, source2) -> fprintf ppf
      "@[<hov>The files %a@ and %a@ \
              make inconsistent assumptions@ over interface %s@]"
      Location.print_filename source1 Location.print_filename source2 name
  | Need_recursive_types(import, export) ->
      fprintf ppf
        "@[<hov>Unit %s imports from %s, which uses recursive types.@ %s@]"
        export import "The compilation flag -rectypes is required"
  | Missing_module(_, path1, path2) ->
      fprintf ppf "@[@[<hov>";
      if Path.same path1 path2 then
        fprintf ppf "Internal path@ %s@ is dangling." (Path.name path1)
      else
        fprintf ppf "Internal path@ %s@ expands to@ %s@ which is dangling."
          (Path.name path1) (Path.name path2);
      fprintf ppf "@]@ @[%s@ %s@ %s.@]@]"
        "The compiled interface for module" (Ident.name (Path.head path2))
        "was not found"
  | Illegal_value_name(_loc, name) ->
      fprintf ppf "'%s' is not a valid value identifier."
        name

let () =
  Location.register_error_of_exn
    (function
      | Error (Missing_module (loc, _, _)
              | Illegal_value_name (loc, _)
               as err) when loc <> Location.none ->
          Some (Location.error_of_printer loc report_error err)
      | Error err -> Some (Location.error_of_printer_file report_error err)
      | _ -> None
    )

end
module Mt : sig
(*#1 "mt.mli"*)
type  eq =
  | Eq :  'a *'a  ->  eq
  | Neq : 'a * 'a ->  eq
  | StrictEq :  'a *'a  ->  eq
  | StrictNeq : 'a * 'a ->  eq
  | Ok : bool -> eq
  | Approx : float * float ->  eq
  | ApproxThreshold : float * float * float ->  eq
  | ThrowAny : (unit -> unit) -> eq
  | Fail : unit -> eq
  | FailWith : string -> eq
type  pair_suites = (string * (unit ->  eq)) list

val from_suites : string -> (string * (unit -> unit)) list -> unit
val from_pair_suites : string ->  pair_suites -> unit

type promise_suites = (string * eq Js.Promise.t) list

val from_promise_suites :
  string ->
  promise_suites ->
  unit

val eq_suites :
  test_id:int ref ->
  suites:pair_suites ref -> string -> 'b -> 'b -> unit

val bool_suites :
  test_id:int ref ->
  suites: pair_suites ref -> string -> bool -> unit

val throw_suites :
  test_id:int ref ->
  suites: pair_suites ref -> string -> (unit -> unit) -> unit
end = struct
(*#1 "mt.ml"*)



external describe : string -> (unit -> unit[@u]) -> unit = "describe"


external it : string -> (unit -> unit[@mel.uncurry]) -> unit = "it"


external it_promise : string -> (unit -> _ Js.Promise.t [@mel.uncurry]) -> unit = "it"


external eq : 'a -> 'a -> unit = "deepEqual"
[@@mel.module "assert"]

external neq : 'a -> 'a -> unit = "notDeepEqual"
[@@mel.module "assert"]

external strict_eq : 'a -> 'a -> unit = "strictEqual"
[@@mel.module "assert"]

external strict_neq : 'a -> 'a -> unit = "notStrictEqual"
[@@mel.module "assert"]

external ok : bool -> unit = "ok"
[@@mel.module "assert"]

external fail : 'a -> 'a -> string Js.undefined -> string -> unit = "fail"
[@@mel.module "assert"]


external dump : 'a array -> unit = "console.log"
[@@mel.variadic]

external throws : (unit -> unit) -> unit = "throws"
[@@mel.module "assert"]
(** There is a problem --
    it does not return [unit]
*)

let assert_equal = eq
let assert_notequal = neq
let assert_strict_equal = strict_eq
let assert_strict_notequal = strict_neq
let assert_ok = fun a -> ok a
let assert_fail = fun msg -> fail () () (Js.Undefined.return msg) ""

let is_mocha () =
  match Array.to_list Node.Process.process##argv with
  | _node :: mocha ::  _ ->
    let exec = Node.Path.basename mocha in
    exec = "mocha" || exec = "_mocha"
  | _ -> false
(* assert -- raises an AssertionError which mocha handls better
*)
let from_suites name (suite :  (string * ('a -> unit)) list) =
  match Array.to_list Node.Process.process##argv with
  | cmd :: _ ->
    if is_mocha () then
      describe name (fun [@u] () ->
          List.iter (fun (name, code) -> it name code) suite)

  | _ -> ()

type eq =
  | Eq :  'a *'a  -> eq
  | Neq : 'a * 'a -> eq
  | StrictEq :  'a *'a  -> eq
  | StrictNeq : 'a * 'a -> eq
  | Ok : bool -> eq
  | Approx : float * float -> eq
  | ApproxThreshold : float * float * float -> eq
  | ThrowAny : (unit -> unit) -> eq
  | Fail : unit -> eq
  | FailWith : string -> eq
  (* TODO: | Exception : exn -> (unit -> unit) -> _ eq  *)

type  pair_suites = (string * (unit ->  eq)) list
type promise_suites = (string * eq Js.Promise.t) list
let close_enough ?(threshold=0.0000001 (* epsilon_float *)) a b =
  abs_float (a -. b) < threshold

let node_from_pair_suites (name : string) (suites :  pair_suites) =
  Js.log (name, "testing");
  List.iter (fun (name, code) ->
      match code () with
      | Eq(a,b) -> Js.log (name , a, "eq?", b )
      | Neq(a,b) -> Js.log (name, a, "neq?",   b )
      | StrictEq(a,b) -> Js.log (name , a, "strict_eq?", b )
      | StrictNeq(a,b) -> Js.log (name, a, "strict_neq?",   b )
      | Approx(a,b) -> Js.log (name, a, "~",  b)
      | ApproxThreshold(t, a, b) -> Js.log (name, a, "~", b, " (", t, ")")
      | ThrowAny fn -> ()
      | Fail _ -> Js.log "failed"
      | FailWith msg -> Js.log ("failed: " ^ msg)
      | Ok a -> Js.log (name, a, "ok?")
    ) suites

let handleCode spec =

  match spec with
  | Eq(a,b) -> assert_equal a b
  | Neq(a,b) -> assert_notequal a b
  | StrictEq(a,b) -> assert_strict_equal a b
  | StrictNeq(a,b) -> assert_strict_notequal a b
  | Ok(a) -> assert_ok a
  | Approx(a, b) ->
    if not (close_enough a b) then assert_equal a b (* assert_equal gives better ouput *)
  | ApproxThreshold(t, a, b) ->
    if not (close_enough ~threshold:t a b) then assert_equal a b (* assert_equal gives better ouput *)
  | ThrowAny fn -> throws fn
  | Fail _ -> assert_fail "failed"
  | FailWith msg -> assert_fail msg

let from_pair_suites name (suites :  pair_suites) =
  match Array.to_list Node.Process.process##argv with
  | cmd :: _ ->
    if is_mocha () then
      describe name (fun [@u] () ->
          suites |>
          List.iter (fun (name, code) ->
              it name (fun _ ->
                  handleCode (code ())
                )
            )
        )
    else node_from_pair_suites name suites
  | _ -> ()
let val_unit = Js.Promise.resolve ()
let from_promise_suites name (suites : (string * _ Js.Promise.t ) list) =
  match Array.to_list Node.Process.process##argv with
  | cmd :: _ ->
    if is_mocha () then
      describe name (fun [@u] () ->
          suites |>
          List.iter (fun (name, code) ->
              it_promise name (fun _ ->
                  code |> Js.Promise.then_ (fun x -> handleCode x; val_unit)

                )
            )
        )
    else Js.log "promise suites" (* TODO*)
  | _ -> ()

(*
Note that [require] is a file local value,
we need type [require]

let is_top : unit -> bool = [%mel.raw{|
function (_){
console.log('hi');
if (typeof require === "undefined"){
  return false
} else {
  console.log("hey",require.main.filename);
  return require.main === module;
}
}
|}]

let from_pair_suites_non_top name suites =
    if not @@ is_top () then
      from_pair_suites name suites
*)

let eq_suites ~test_id ~suites loc x y  =
  incr test_id ;
  suites :=
    (loc ^" id " ^ (string_of_int !test_id), (fun _ -> Eq(x,y))) :: !suites

let bool_suites  ~test_id ~suites loc x   =
  incr test_id ;
  suites :=
    (loc ^" id " ^ (string_of_int !test_id), (fun _ -> Ok(x))) :: !suites

let throw_suites ~test_id ~suites loc x =
  incr test_id ;
  suites :=
    (loc ^" id " ^ (string_of_int !test_id), (fun _ -> ThrowAny(x))) :: !suites
end
module Syntaxerr : sig
(*#1 "syntaxerr.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1997 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Auxiliary type for reporting syntax errors *)

open Format

type error =
    Unclosed of Location.t * string * Location.t * string
  | Expecting of Location.t * string
  | Not_expecting of Location.t * string
  | Applicative_path of Location.t
  | Variable_in_scope of Location.t * string
  | Other of Location.t
  | Ill_formed_ast of Location.t * string

exception Error of error
exception Escape_error

val report_error: formatter -> error -> unit
 (* Deprecated.  Use Location.{error_of_exn, report_error}. *)

val location_of_error: error -> Location.t
val ill_formed_ast: Location.t -> string -> 'a

end = struct
(*#1 "syntaxerr.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1997 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Auxiliary type for reporting syntax errors *)

type error =
    Unclosed of Location.t * string * Location.t * string
  | Expecting of Location.t * string
  | Not_expecting of Location.t * string
  | Applicative_path of Location.t
  | Variable_in_scope of Location.t * string
  | Other of Location.t
  | Ill_formed_ast of Location.t * string

exception Error of error
exception Escape_error

let prepare_error = function
  | Unclosed(opening_loc, opening, closing_loc, closing) ->
      Location.errorf ~loc:closing_loc
        ~sub:[
          Location.errorf ~loc:opening_loc
            "This '%s' might be unmatched" opening
        ]
        ~if_highlight:
          (Printf.sprintf "Syntax error: '%s' expected, \
                           the highlighted '%s' might be unmatched"
             closing opening)
        "Syntax error: '%s' expected" closing

  | Expecting (loc, nonterm) ->
      Location.errorf ~loc "Syntax error: %s expected." nonterm
  | Not_expecting (loc, nonterm) ->
      Location.errorf ~loc "Syntax error: %s not expected." nonterm
  | Applicative_path loc ->
      Location.errorf ~loc
        "Syntax error: applicative paths of the form F(X).t \
         are not supported when the option -no-app-func is set."
  | Variable_in_scope (loc, var) ->
      Location.errorf ~loc
        "In this scoped type, variable '%s \
         is reserved for the local type %s."
         var var
  | Other loc ->
      Location.errorf ~loc "Syntax error"
  | Ill_formed_ast (loc, s) ->
      Location.errorf ~loc "broken invariant in parsetree: %s" s

let () =
  Location.register_error_of_exn
    (function
      | Error err -> Some (prepare_error err)
      | _ -> None
    )


let report_error ppf err =
  Location.report_error ppf (prepare_error err)

let location_of_error = function
  | Unclosed(l,_,_,_)
  | Applicative_path l
  | Variable_in_scope(l,_)
  | Other l
  | Not_expecting (l, _)
  | Ill_formed_ast (l, _)
  | Expecting (l, _) -> l


let ill_formed_ast loc s =
  raise (Error (Ill_formed_ast (loc, s)))

end
module Parser : sig
(*#1 "parser.mli"*)
type token =
  | AMPERAMPER
  | AMPERSAND
  | AND
  | AS
  | ASSERT
  | BACKQUOTE
  | BANG
  | BAR
  | BARBAR
  | BARRBRACKET
  | BEGIN
  | CHAR of (char)
  | CLASS
  | COLON
  | COLONCOLON
  | COLONEQUAL
  | COLONGREATER
  | COMMA
  | CONSTRAINT
  | DO
  | DONE
  | DOT
  | DOTDOT
  | DOWNTO
  | ELSE
  | END
  | EOF
  | EQUAL
  | EXCEPTION
  | EXTERNAL
  | FALSE
  | FLOAT of (string)
  | FOR
  | FUN
  | FUNCTION
  | FUNCTOR
  | GREATER
  | GREATERRBRACE
  | GREATERRBRACKET
  | IF
  | IN
  | INCLUDE
  | INFIXOP0 of (string)
  | INFIXOP1 of (string)
  | INFIXOP2 of (string)
  | INFIXOP3 of (string)
  | INFIXOP4 of (string)
  | INHERIT
  | INITIALIZER
  | INT of (int)
  | INT32 of (int32)
  | INT64 of (int64)
  | LABEL of (string)
  | LAZY
  | LBRACE
  | LBRACELESS
  | LBRACKET
  | LBRACKETBAR
  | LBRACKETLESS
  | LBRACKETGREATER
  | LBRACKETPERCENT
  | LBRACKETPERCENTPERCENT
  | LESS
  | LESSMINUS
  | LET
  | LIDENT of (string)
  | LPAREN
  | LBRACKETAT
  | LBRACKETATAT
  | LBRACKETATATAT
  | MATCH
  | METHOD
  | MINUS
  | MINUSDOT
  | MINUSGREATER
  | MODULE
  | MUTABLE
  | NATIVEINT of (nativeint)
  | NEW
  | NONREC
  | OBJECT
  | OF
  | OPEN
  | OPTLABEL of (string)
  | OR
  | PERCENT
  | PLUS
  | PLUSDOT
  | PLUSEQ
  | PREFIXOP of (string)
  | PRIVATE
  | QUESTION
  | QUOTE
  | RBRACE
  | RBRACKET
  | REC
  | RPAREN
  | SEMI
  | SEMISEMI
  | SHARP
  | SHARPOP of (string)
  | SIG
  | STAR
  | STRING of (string * string option)
  | STRUCT
  | THEN
  | TILDE
  | TO
  | TRUE
  | TRY
  | TYPE
  | UIDENT of (string)
  | UNDERSCORE
  | VAL
  | VIRTUAL
  | WHEN
  | WHILE
  | WITH
  | COMMENT of (string * Location.t)
  | DOCSTRING of (Docstrings.docstring)
  | EOL

val implementation :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Parsetree.structure
val interface :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Parsetree.signature
val toplevel_phrase :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Parsetree.toplevel_phrase
val use_file :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Parsetree.toplevel_phrase list
val parse_core_type :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Parsetree.core_type
val parse_expression :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Parsetree.expression
val parse_pattern :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Parsetree.pattern

end = struct
(*#1 "parser.ml"*)
type token =
  | AMPERAMPER
  | AMPERSAND
  | AND
  | AS
  | ASSERT
  | BACKQUOTE
  | BANG
  | BAR
  | BARBAR
  | BARRBRACKET
  | BEGIN
  | CHAR of (char)
  | CLASS
  | COLON
  | COLONCOLON
  | COLONEQUAL
  | COLONGREATER
  | COMMA
  | CONSTRAINT
  | DO
  | DONE
  | DOT
  | DOTDOT
  | DOWNTO
  | ELSE
  | END
  | EOF
  | EQUAL
  | EXCEPTION
  | EXTERNAL
  | FALSE
  | FLOAT of (string)
  | FOR
  | FUN
  | FUNCTION
  | FUNCTOR
  | GREATER
  | GREATERRBRACE
  | GREATERRBRACKET
  | IF
  | IN
  | INCLUDE
  | INFIXOP0 of (string)
  | INFIXOP1 of (string)
  | INFIXOP2 of (string)
  | INFIXOP3 of (string)
  | INFIXOP4 of (string)
  | INHERIT
  | INITIALIZER
  | INT of (int)
  | INT32 of (int32)
  | INT64 of (int64)
  | LABEL of (string)
  | LAZY
  | LBRACE
  | LBRACELESS
  | LBRACKET
  | LBRACKETBAR
  | LBRACKETLESS
  | LBRACKETGREATER
  | LBRACKETPERCENT
  | LBRACKETPERCENTPERCENT
  | LESS
  | LESSMINUS
  | LET
  | LIDENT of (string)
  | LPAREN
  | LBRACKETAT
  | LBRACKETATAT
  | LBRACKETATATAT
  | MATCH
  | METHOD
  | MINUS
  | MINUSDOT
  | MINUSGREATER
  | MODULE
  | MUTABLE
  | NATIVEINT of (nativeint)
  | NEW
  | NONREC
  | OBJECT
  | OF
  | OPEN
  | OPTLABEL of (string)
  | OR
  | PERCENT
  | PLUS
  | PLUSDOT
  | PLUSEQ
  | PREFIXOP of (string)
  | PRIVATE
  | QUESTION
  | QUOTE
  | RBRACE
  | RBRACKET
  | REC
  | RPAREN
  | SEMI
  | SEMISEMI
  | SHARP
  | SHARPOP of (string)
  | SIG
  | STAR
  | STRING of (string * string option)
  | STRUCT
  | THEN
  | TILDE
  | TO
  | TRUE
  | TRY
  | TYPE
  | UIDENT of (string)
  | UNDERSCORE
  | VAL
  | VIRTUAL
  | WHEN
  | WHILE
  | WITH
  | COMMENT of (string * Location.t)
  | DOCSTRING of (Docstrings.docstring)
  | EOL

open Parsing;;
let _ = parse_error;;
(*# 16 "parsing/parser.mly"*)
open Location
open Asttypes
open Longident
open Parsetree
open Ast_helper
open Docstrings

let mktyp d = Typ.mk ~loc:(symbol_rloc()) d
let mkpat d = Pat.mk ~loc:(symbol_rloc()) d
let mkexp d = Exp.mk ~loc:(symbol_rloc()) d
let mkmty d = Mty.mk ~loc:(symbol_rloc()) d
let mksig d = Sig.mk ~loc:(symbol_rloc()) d
let mkmod d = Mod.mk ~loc:(symbol_rloc()) d
let mkstr d = Str.mk ~loc:(symbol_rloc()) d
let mkclass d = Cl.mk ~loc:(symbol_rloc()) d
let mkcty d = Cty.mk ~loc:(symbol_rloc()) d
let mkctf ?attrs ?docs d =
  Ctf.mk ~loc:(symbol_rloc()) ?attrs ?docs d
let mkcf ?attrs ?docs d =
  Cf.mk ~loc:(symbol_rloc()) ?attrs ?docs d

let mkrhs rhs pos = mkloc rhs (rhs_loc pos)
let mkoption d =
  let loc = {d.ptyp_loc with loc_ghost = true} in
  Typ.mk ~loc (Ptyp_constr(mkloc (Ldot (Lident "*predef*", "option")) loc,[d]))

let reloc_pat x = { x with ppat_loc = symbol_rloc () };;
let reloc_exp x = { x with pexp_loc = symbol_rloc () };;

let mkoperator name pos =
  let loc = rhs_loc pos in
  Exp.mk ~loc (Pexp_ident(mkloc (Lident name) loc))

let mkpatvar name pos =
  Pat.mk ~loc:(rhs_loc pos) (Ppat_var (mkrhs name pos))

(*
  Ghost expressions and patterns:
  expressions and patterns that do not appear explicitly in the
  source file they have the loc_ghost flag set to true.
  Then the profiler will not try to instrument them and the
  -annot option will not try to display their type.

  Every grammar rule that generates an element with a location must
  make at most one non-ghost element, the topmost one.

  How to tell whether your location must be ghost:
  A location corresponds to a range of characters in the source file.
  If the location contains a piece of code that is syntactically
  valid (according to the documentation), and corresponds to the
  AST node, then the location must be real; in all other cases,
  it must be ghost.
*)
let ghexp d = Exp.mk ~loc:(symbol_gloc ()) d
let ghpat d = Pat.mk ~loc:(symbol_gloc ()) d
let ghtyp d = Typ.mk ~loc:(symbol_gloc ()) d
let ghloc d = { txt = d; loc = symbol_gloc () }
let ghstr d = Str.mk ~loc:(symbol_gloc()) d

let ghunit () =
  ghexp (Pexp_construct (mknoloc (Lident "()"), None))

let mkinfix arg1 name arg2 =
  mkexp(Pexp_apply(mkoperator name 2, ["", arg1; "", arg2]))

let neg_float_string f =
  if String.length f > 0 && f.[0] = '-'
  then String.sub f 1 (String.length f - 1)
  else "-" ^ f

let mkuminus name arg =
  match name, arg.pexp_desc with
  | "-", Pexp_constant(Const_int n) ->
      mkexp(Pexp_constant(Const_int(-n)))
  | "-", Pexp_constant(Const_int32 n) ->
      mkexp(Pexp_constant(Const_int32(Int32.neg n)))
  | "-", Pexp_constant(Const_int64 n) ->
      mkexp(Pexp_constant(Const_int64(Int64.neg n)))
  | "-", Pexp_constant(Const_nativeint n) ->
      mkexp(Pexp_constant(Const_nativeint(Nativeint.neg n)))
  | ("-" | "-."), Pexp_constant(Const_float f) ->
      mkexp(Pexp_constant(Const_float(neg_float_string f)))
  | _ ->
      mkexp(Pexp_apply(mkoperator ("~" ^ name) 1, ["", arg]))

let mkuplus name arg =
  let desc = arg.pexp_desc in
  match name, desc with
  | "+", Pexp_constant(Const_int _)
  | "+", Pexp_constant(Const_int32 _)
  | "+", Pexp_constant(Const_int64 _)
  | "+", Pexp_constant(Const_nativeint _)
  | ("+" | "+."), Pexp_constant(Const_float _) -> mkexp desc
  | _ ->
      mkexp(Pexp_apply(mkoperator ("~" ^ name) 1, ["", arg]))

let mkexp_cons consloc args loc =
  Exp.mk ~loc (Pexp_construct(mkloc (Lident "::") consloc, Some args))

let mkpat_cons consloc args loc =
  Pat.mk ~loc (Ppat_construct(mkloc (Lident "::") consloc, Some args))

let rec mktailexp nilloc = function
    [] ->
      let loc = { nilloc with loc_ghost = true } in
      let nil = { txt = Lident "[]"; loc = loc } in
      Exp.mk ~loc (Pexp_construct (nil, None))
  | e1 :: el ->
      let exp_el = mktailexp nilloc el in
      let loc = {loc_start = e1.pexp_loc.loc_start;
               loc_end = exp_el.pexp_loc.loc_end;
               loc_ghost = true}
      in
      let arg = Exp.mk ~loc (Pexp_tuple [e1; exp_el]) in
      mkexp_cons {loc with loc_ghost = true} arg loc

let rec mktailpat nilloc = function
    [] ->
      let loc = { nilloc with loc_ghost = true } in
      let nil = { txt = Lident "[]"; loc = loc } in
      Pat.mk ~loc (Ppat_construct (nil, None))
  | p1 :: pl ->
      let pat_pl = mktailpat nilloc pl in
      let loc = {loc_start = p1.ppat_loc.loc_start;
               loc_end = pat_pl.ppat_loc.loc_end;
               loc_ghost = true}
      in
      let arg = Pat.mk ~loc (Ppat_tuple [p1; pat_pl]) in
      mkpat_cons {loc with loc_ghost = true} arg loc

let mkstrexp e attrs =
  { pstr_desc = Pstr_eval (e, attrs); pstr_loc = e.pexp_loc }

let mkexp_constraint e (t1, t2) =
  match t1, t2 with
  | Some t, None -> ghexp(Pexp_constraint(e, t))
  | _, Some t -> ghexp(Pexp_coerce(e, t1, t))
  | None, None -> assert false

let array_function str name =
  ghloc (Ldot(Lident str, (if !Clflags.fast then "unsafe_" ^ name else name)))

let syntax_error () =
  raise Syntaxerr.Escape_error

let unclosed opening_name opening_num closing_name closing_num =
  raise(Syntaxerr.Error(Syntaxerr.Unclosed(rhs_loc opening_num, opening_name,
                                           rhs_loc closing_num, closing_name)))

let expecting pos nonterm =
    raise Syntaxerr.(Error(Expecting(rhs_loc pos, nonterm)))

let not_expecting pos nonterm =
    raise Syntaxerr.(Error(Not_expecting(rhs_loc pos, nonterm)))

let bigarray_function str name =
  ghloc (Ldot(Ldot(Lident "Bigarray", str), name))

let bigarray_untuplify = function
    { pexp_desc = Pexp_tuple explist; pexp_loc = _ } -> explist
  | exp -> [exp]

let bigarray_get arr arg =
  let get = if !Clflags.fast then "unsafe_get" else "get" in
  match bigarray_untuplify arg with
    [c1] ->
      mkexp(Pexp_apply(ghexp(Pexp_ident(bigarray_function "Array1" get)),
                       ["", arr; "", c1]))
  | [c1;c2] ->
      mkexp(Pexp_apply(ghexp(Pexp_ident(bigarray_function "Array2" get)),
                       ["", arr; "", c1; "", c2]))
  | [c1;c2;c3] ->
      mkexp(Pexp_apply(ghexp(Pexp_ident(bigarray_function "Array3" get)),
                       ["", arr; "", c1; "", c2; "", c3]))
  | coords ->
      mkexp(Pexp_apply(ghexp(Pexp_ident(bigarray_function "Genarray" "get")),
                       ["", arr; "", ghexp(Pexp_array coords)]))

let bigarray_set arr arg newval =
  let set = if !Clflags.fast then "unsafe_set" else "set" in
  match bigarray_untuplify arg with
    [c1] ->
      mkexp(Pexp_apply(ghexp(Pexp_ident(bigarray_function "Array1" set)),
                       ["", arr; "", c1; "", newval]))
  | [c1;c2] ->
      mkexp(Pexp_apply(ghexp(Pexp_ident(bigarray_function "Array2" set)),
                       ["", arr; "", c1; "", c2; "", newval]))
  | [c1;c2;c3] ->
      mkexp(Pexp_apply(ghexp(Pexp_ident(bigarray_function "Array3" set)),
                       ["", arr; "", c1; "", c2; "", c3; "", newval]))
  | coords ->
      mkexp(Pexp_apply(ghexp(Pexp_ident(bigarray_function "Genarray" "set")),
                       ["", arr;
                        "", ghexp(Pexp_array coords);
                        "", newval]))

let lapply p1 p2 =
  if !Clflags.applicative_functors
  then Lapply(p1, p2)
  else raise (Syntaxerr.Error(Syntaxerr.Applicative_path (symbol_rloc())))

let exp_of_label lbl pos =
  mkexp (Pexp_ident(mkrhs (Lident(Longident.last lbl)) pos))

let pat_of_label lbl pos =
  mkpat (Ppat_var (mkrhs (Longident.last lbl) pos))

let check_variable vl loc v =
  if List.mem v vl then
    raise Syntaxerr.(Error(Variable_in_scope(loc,v)))

let varify_constructors var_names t =
  let rec loop t =
    let desc =
      match t.ptyp_desc with
      | Ptyp_any -> Ptyp_any
      | Ptyp_var x ->
          check_variable var_names t.ptyp_loc x;
          Ptyp_var x
      | Ptyp_arrow (label,core_type,core_type') ->
          Ptyp_arrow(label, loop core_type, loop core_type')
      | Ptyp_tuple lst -> Ptyp_tuple (List.map loop lst)
      | Ptyp_constr( { txt = Lident s }, []) when List.mem s var_names ->
          Ptyp_var s
      | Ptyp_constr(longident, lst) ->
          Ptyp_constr(longident, List.map loop lst)
      | Ptyp_object (lst, o) ->
          Ptyp_object
            (List.map (fun (s, attrs, t) -> (s, attrs, loop t)) lst, o)
      | Ptyp_class (longident, lst) ->
          Ptyp_class (longident, List.map loop lst)
      | Ptyp_alias(core_type, string) ->
          check_variable var_names t.ptyp_loc string;
          Ptyp_alias(loop core_type, string)
      | Ptyp_variant(row_field_list, flag, lbl_lst_option) ->
          Ptyp_variant(List.map loop_row_field row_field_list,
                       flag, lbl_lst_option)
      | Ptyp_poly(string_lst, core_type) ->
          List.iter (check_variable var_names t.ptyp_loc) string_lst;
          Ptyp_poly(string_lst, loop core_type)
      | Ptyp_package(longident,lst) ->
          Ptyp_package(longident,List.map (fun (n,typ) -> (n,loop typ) ) lst)
      | Ptyp_extension (s, arg) ->
          Ptyp_extension (s, arg)
    in
    {t with ptyp_desc = desc}
  and loop_row_field  =
    function
      | Rtag(label,attrs,flag,lst) ->
          Rtag(label,attrs,flag,List.map loop lst)
      | Rinherit t ->
          Rinherit (loop t)
  in
  loop t

let wrap_type_annotation newtypes core_type body =
  let exp = mkexp(Pexp_constraint(body,core_type)) in
  let exp =
    List.fold_right (fun newtype exp -> mkexp (Pexp_newtype (newtype, exp)))
      newtypes exp
  in
  (exp, ghtyp(Ptyp_poly(newtypes,varify_constructors newtypes core_type)))

let wrap_exp_attrs body (ext, attrs) =
  (* todo: keep exact location for the entire attribute *)
  let body = {body with pexp_attributes = attrs @ body.pexp_attributes} in
  match ext with
  | None -> body
  | Some id -> ghexp(Pexp_extension (id, PStr [mkstrexp body []]))

let mkexp_attrs d attrs =
  wrap_exp_attrs (mkexp d) attrs

let text_str pos = Str.text (rhs_text pos)
let text_sig pos = Sig.text (rhs_text pos)
let text_cstr pos = Cf.text (rhs_text pos)
let text_csig pos = Ctf.text (rhs_text pos)
let text_def pos = [Ptop_def (Str.text (rhs_text pos))]

let extra_text text pos items =
  let pre_extras = rhs_pre_extra_text pos in
  let post_extras = rhs_post_extra_text pos in
    text pre_extras @ items @ text post_extras

let extra_str pos items = extra_text Str.text pos items
let extra_sig pos items = extra_text Sig.text pos items
let extra_cstr pos items = extra_text Cf.text pos items
let extra_csig pos items = extra_text Ctf.text pos items
let extra_def pos items =
  extra_text (fun txt -> [Ptop_def (Str.text txt)]) pos items

let add_nonrec rf attrs pos =
  match rf with
  | Recursive -> attrs
  | Nonrecursive ->
      let name = { txt = "nonrec"; loc = rhs_loc pos } in
        (name, PStr []) :: attrs

type let_binding =
  { lb_pattern: pattern;
    lb_expression: expression;
    lb_attributes: attributes;
    lb_docs: docs Lazy.t;
    lb_text: text Lazy.t;
    lb_loc: Location.t; }

type let_bindings =
  { lbs_bindings: let_binding list;
    lbs_rec: rec_flag;
    lbs_extension: string Asttypes.loc option;
    lbs_attributes: attributes;
    lbs_loc: Location.t }

let mklb (p, e) attrs =
  { lb_pattern = p;
    lb_expression = e;
    lb_attributes = attrs;
    lb_docs = symbol_docs_lazy ();
    lb_text = symbol_text_lazy ();
    lb_loc = symbol_rloc (); }

let mklbs (ext, attrs) rf lb =
  { lbs_bindings = [lb];
    lbs_rec = rf;
    lbs_extension = ext ;
    lbs_attributes = attrs;
    lbs_loc = symbol_rloc (); }

let addlb lbs lb =
  { lbs with lbs_bindings = lb :: lbs.lbs_bindings }

let val_of_let_bindings lbs =
  let str =
    match lbs.lbs_bindings with
    | [ {lb_pattern = { ppat_desc = Ppat_any; ppat_loc = _ }; _} as lb ] ->
        let exp = wrap_exp_attrs lb.lb_expression
                    (None, lbs.lbs_attributes) in
        mkstr (Pstr_eval (exp, lb.lb_attributes))
    | bindings ->
        if lbs.lbs_attributes <> [] then
          raise Syntaxerr.(Error(Not_expecting(lbs.lbs_loc, "attributes")));
        let bindings =
          List.map
            (fun lb ->
               Vb.mk ~loc:lb.lb_loc ~attrs:lb.lb_attributes
                 ~docs:(Lazy.force lb.lb_docs)
                 ~text:(Lazy.force lb.lb_text)
                 lb.lb_pattern lb.lb_expression)
            bindings
        in
        mkstr(Pstr_value(lbs.lbs_rec, List.rev bindings))
  in
  match lbs.lbs_extension with
  | None -> str
  | Some id -> ghstr (Pstr_extension((id, PStr [str]), []))

let expr_of_let_bindings lbs body =
  let bindings =
    List.map
      (fun lb ->
         if lb.lb_attributes <> [] then
           raise Syntaxerr.(Error(Not_expecting(lb.lb_loc, "item attribute")));
         Vb.mk ~loc:lb.lb_loc lb.lb_pattern lb.lb_expression)
      lbs.lbs_bindings
  in
    mkexp_attrs (Pexp_let(lbs.lbs_rec, List.rev bindings, body))
      (lbs.lbs_extension, lbs.lbs_attributes)

let class_of_let_bindings lbs body =
  let bindings =
    List.map
      (fun lb ->
         if lb.lb_attributes <> [] then
           raise Syntaxerr.(Error(Not_expecting(lb.lb_loc, "item attribute")));
         Vb.mk ~loc:lb.lb_loc lb.lb_pattern lb.lb_expression)
      lbs.lbs_bindings
  in
    if lbs.lbs_extension <> None then
      raise Syntaxerr.(Error(Not_expecting(lbs.lbs_loc, "extension")));
    if lbs.lbs_attributes <> [] then
      raise Syntaxerr.(Error(Not_expecting(lbs.lbs_loc, "attributes")));
    mkclass(Pcl_let (lbs.lbs_rec, List.rev bindings, body))

(*# 511 "parsing/parser.ml"*)
let yytransl_const = [|
  257 (* AMPERAMPER *);
  258 (* AMPERSAND *);
  259 (* AND *);
  260 (* AS *);
  261 (* ASSERT *);
  262 (* BACKQUOTE *);
  263 (* BANG *);
  264 (* BAR *);
  265 (* BARBAR *);
  266 (* BARRBRACKET *);
  267 (* BEGIN *);
  269 (* CLASS *);
  270 (* COLON *);
  271 (* COLONCOLON *);
  272 (* COLONEQUAL *);
  273 (* COLONGREATER *);
  274 (* COMMA *);
  275 (* CONSTRAINT *);
  276 (* DO *);
  277 (* DONE *);
  278 (* DOT *);
  279 (* DOTDOT *);
  280 (* DOWNTO *);
  281 (* ELSE *);
  282 (* END *);
    0 (* EOF *);
  283 (* EQUAL *);
  284 (* EXCEPTION *);
  285 (* EXTERNAL *);
  286 (* FALSE *);
  288 (* FOR *);
  289 (* FUN *);
  290 (* FUNCTION *);
  291 (* FUNCTOR *);
  292 (* GREATER *);
  293 (* GREATERRBRACE *);
  294 (* GREATERRBRACKET *);
  295 (* IF *);
  296 (* IN *);
  297 (* INCLUDE *);
  303 (* INHERIT *);
  304 (* INITIALIZER *);
  309 (* LAZY *);
  310 (* LBRACE *);
  311 (* LBRACELESS *);
  312 (* LBRACKET *);
  313 (* LBRACKETBAR *);
  314 (* LBRACKETLESS *);
  315 (* LBRACKETGREATER *);
  316 (* LBRACKETPERCENT *);
  317 (* LBRACKETPERCENTPERCENT *);
  318 (* LESS *);
  319 (* LESSMINUS *);
  320 (* LET *);
  322 (* LPAREN *);
  323 (* LBRACKETAT *);
  324 (* LBRACKETATAT *);
  325 (* LBRACKETATATAT *);
  326 (* MATCH *);
  327 (* METHOD *);
  328 (* MINUS *);
  329 (* MINUSDOT *);
  330 (* MINUSGREATER *);
  331 (* MODULE *);
  332 (* MUTABLE *);
  334 (* NEW *);
  335 (* NONREC *);
  336 (* OBJECT *);
  337 (* OF *);
  338 (* OPEN *);
  340 (* OR *);
  341 (* PERCENT *);
  342 (* PLUS *);
  343 (* PLUSDOT *);
  344 (* PLUSEQ *);
  346 (* PRIVATE *);
  347 (* QUESTION *);
  348 (* QUOTE *);
  349 (* RBRACE *);
  350 (* RBRACKET *);
  351 (* REC *);
  352 (* RPAREN *);
  353 (* SEMI *);
  354 (* SEMISEMI *);
  355 (* SHARP *);
  357 (* SIG *);
  358 (* STAR *);
  360 (* STRUCT *);
  361 (* THEN *);
  362 (* TILDE *);
  363 (* TO *);
  364 (* TRUE *);
  365 (* TRY *);
  366 (* TYPE *);
  368 (* UNDERSCORE *);
  369 (* VAL *);
  370 (* VIRTUAL *);
  371 (* WHEN *);
  372 (* WHILE *);
  373 (* WITH *);
  376 (* EOL *);
    0|]

let yytransl_block = [|
  268 (* CHAR *);
  287 (* FLOAT *);
  298 (* INFIXOP0 *);
  299 (* INFIXOP1 *);
  300 (* INFIXOP2 *);
  301 (* INFIXOP3 *);
  302 (* INFIXOP4 *);
  305 (* INT *);
  306 (* INT32 *);
  307 (* INT64 *);
  308 (* LABEL *);
  321 (* LIDENT *);
  333 (* NATIVEINT *);
  339 (* OPTLABEL *);
  345 (* PREFIXOP *);
  356 (* SHARPOP *);
  359 (* STRING *);
  367 (* UIDENT *);
  374 (* COMMENT *);
  375 (* DOCSTRING *);
    0|]

let yylhs = "\255\255\
\001\000\002\000\003\000\003\000\003\000\010\000\010\000\014\000\
\014\000\004\000\016\000\016\000\017\000\017\000\017\000\017\000\
\017\000\017\000\017\000\005\000\006\000\007\000\020\000\020\000\
\021\000\021\000\023\000\023\000\024\000\024\000\024\000\024\000\
\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
\008\000\008\000\030\000\030\000\030\000\015\000\015\000\015\000\
\015\000\015\000\015\000\015\000\015\000\015\000\015\000\015\000\
\015\000\015\000\015\000\042\000\045\000\045\000\045\000\036\000\
\037\000\037\000\046\000\047\000\022\000\022\000\022\000\022\000\
\022\000\022\000\022\000\022\000\022\000\022\000\009\000\009\000\
\009\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
\050\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
\039\000\057\000\060\000\060\000\060\000\054\000\055\000\056\000\
\056\000\061\000\062\000\063\000\063\000\038\000\040\000\040\000\
\065\000\066\000\069\000\069\000\069\000\068\000\068\000\074\000\
\074\000\070\000\070\000\070\000\070\000\070\000\070\000\075\000\
\075\000\075\000\075\000\075\000\075\000\075\000\075\000\079\000\
\080\000\080\000\080\000\081\000\081\000\082\000\082\000\082\000\
\082\000\082\000\082\000\082\000\083\000\083\000\084\000\084\000\
\084\000\084\000\085\000\085\000\085\000\085\000\085\000\071\000\
\071\000\071\000\071\000\071\000\094\000\094\000\094\000\094\000\
\094\000\094\000\097\000\098\000\098\000\099\000\099\000\100\000\
\100\000\100\000\100\000\100\000\100\000\101\000\101\000\101\000\
\103\000\086\000\058\000\058\000\104\000\105\000\041\000\041\000\
\106\000\107\000\012\000\012\000\012\000\072\000\072\000\072\000\
\072\000\072\000\072\000\072\000\072\000\112\000\112\000\109\000\
\109\000\108\000\108\000\110\000\111\000\111\000\026\000\026\000\
\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
\026\000\026\000\114\000\114\000\114\000\114\000\114\000\114\000\
\114\000\114\000\114\000\114\000\114\000\114\000\114\000\114\000\
\114\000\114\000\114\000\114\000\114\000\114\000\114\000\114\000\
\114\000\114\000\114\000\114\000\114\000\114\000\114\000\114\000\
\114\000\114\000\114\000\114\000\114\000\114\000\114\000\114\000\
\114\000\114\000\114\000\114\000\114\000\114\000\114\000\114\000\
\114\000\114\000\076\000\076\000\132\000\132\000\133\000\133\000\
\133\000\133\000\134\000\093\000\093\000\135\000\135\000\135\000\
\135\000\135\000\031\000\031\000\140\000\141\000\137\000\137\000\
\092\000\092\000\092\000\117\000\117\000\143\000\143\000\118\000\
\118\000\118\000\119\000\119\000\128\000\128\000\144\000\144\000\
\144\000\145\000\145\000\131\000\131\000\129\000\129\000\089\000\
\089\000\089\000\089\000\089\000\019\000\019\000\019\000\019\000\
\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\
\019\000\019\000\019\000\113\000\113\000\139\000\139\000\139\000\
\139\000\139\000\139\000\139\000\139\000\139\000\139\000\139\000\
\139\000\139\000\139\000\139\000\139\000\139\000\139\000\139\000\
\139\000\139\000\139\000\146\000\146\000\146\000\150\000\150\000\
\149\000\149\000\149\000\149\000\151\000\151\000\051\000\152\000\
\152\000\032\000\033\000\033\000\153\000\154\000\158\000\158\000\
\157\000\157\000\157\000\157\000\157\000\157\000\157\000\157\000\
\157\000\157\000\156\000\156\000\156\000\161\000\162\000\162\000\
\164\000\164\000\165\000\165\000\165\000\166\000\163\000\163\000\
\163\000\167\000\073\000\073\000\159\000\159\000\159\000\168\000\
\169\000\035\000\035\000\053\000\171\000\171\000\171\000\171\000\
\160\000\160\000\160\000\175\000\176\000\034\000\052\000\178\000\
\178\000\178\000\178\000\178\000\178\000\179\000\179\000\179\000\
\180\000\181\000\182\000\183\000\049\000\049\000\184\000\184\000\
\184\000\184\000\185\000\185\000\138\000\138\000\090\000\090\000\
\177\000\177\000\018\000\018\000\186\000\186\000\188\000\188\000\
\188\000\188\000\188\000\190\000\190\000\174\000\174\000\191\000\
\191\000\191\000\191\000\191\000\191\000\191\000\191\000\191\000\
\191\000\191\000\191\000\191\000\191\000\191\000\191\000\191\000\
\191\000\191\000\027\000\027\000\198\000\197\000\197\000\194\000\
\194\000\195\000\195\000\193\000\193\000\199\000\199\000\200\000\
\200\000\196\000\196\000\189\000\189\000\095\000\095\000\077\000\
\077\000\201\000\201\000\173\000\173\000\192\000\192\000\192\000\
\202\000\087\000\127\000\127\000\127\000\127\000\127\000\127\000\
\127\000\147\000\147\000\147\000\147\000\147\000\147\000\147\000\
\147\000\147\000\147\000\147\000\064\000\064\000\136\000\136\000\
\136\000\136\000\136\000\203\000\203\000\203\000\203\000\203\000\
\203\000\203\000\203\000\203\000\203\000\203\000\203\000\203\000\
\203\000\203\000\203\000\203\000\203\000\203\000\203\000\203\000\
\203\000\203\000\170\000\170\000\170\000\170\000\170\000\126\000\
\126\000\120\000\120\000\120\000\120\000\120\000\125\000\125\000\
\148\000\148\000\025\000\025\000\187\000\187\000\187\000\048\000\
\048\000\096\000\096\000\078\000\078\000\011\000\011\000\011\000\
\011\000\011\000\011\000\011\000\121\000\142\000\142\000\155\000\
\155\000\122\000\122\000\091\000\091\000\088\000\088\000\067\000\
\067\000\102\000\102\000\102\000\102\000\102\000\059\000\059\000\
\116\000\116\000\130\000\130\000\123\000\123\000\124\000\124\000\
\204\000\204\000\204\000\204\000\204\000\204\000\204\000\204\000\
\204\000\204\000\204\000\204\000\204\000\204\000\204\000\204\000\
\204\000\204\000\204\000\204\000\204\000\204\000\204\000\204\000\
\204\000\204\000\204\000\204\000\204\000\204\000\204\000\204\000\
\204\000\204\000\204\000\204\000\204\000\204\000\204\000\204\000\
\204\000\204\000\204\000\204\000\204\000\204\000\204\000\204\000\
\204\000\204\000\205\000\205\000\028\000\207\000\044\000\013\000\
\013\000\172\000\172\000\115\000\115\000\115\000\029\000\043\000\
\206\000\206\000\206\000\206\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000"

let yylen = "\002\000\
\002\000\002\000\002\000\002\000\001\000\002\000\001\000\000\000\
\002\000\001\000\001\000\003\000\001\000\002\000\004\000\003\000\
\003\000\002\000\002\000\002\000\002\000\002\000\002\000\005\000\
\001\000\001\000\002\000\001\000\001\000\003\000\003\000\004\000\
\004\000\003\000\004\000\005\000\005\000\003\000\003\000\004\000\
\006\000\008\000\006\000\005\000\005\000\004\000\002\000\001\000\
\003\000\001\000\000\000\002\000\002\000\001\000\001\000\001\000\
\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
\001\000\002\000\001\000\003\000\002\000\004\000\002\000\004\000\
\001\000\002\000\005\000\004\000\001\000\003\000\003\000\004\000\
\003\000\004\000\003\000\003\000\001\000\002\000\000\000\002\000\
\002\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\001\000\001\000\001\000\002\000\001\000\
\004\000\003\000\002\000\006\000\003\000\004\000\005\000\001\000\
\002\000\006\000\005\000\000\000\002\000\005\000\001\000\002\000\
\006\000\006\000\002\000\004\000\002\000\000\000\003\000\003\000\
\002\000\001\000\002\000\002\000\003\000\002\000\001\000\004\000\
\001\000\003\000\003\000\005\000\005\000\003\000\003\000\002\000\
\003\000\005\000\000\000\000\000\002\000\005\000\003\000\003\000\
\003\000\003\000\002\000\001\000\002\000\000\000\006\000\005\000\
\005\000\006\000\006\000\006\000\004\000\007\000\010\000\001\000\
\006\000\004\000\005\000\003\000\004\000\001\000\003\000\003\000\
\002\000\001\000\002\000\003\000\000\000\000\000\002\000\003\000\
\003\000\006\000\003\000\002\000\001\000\005\000\005\000\003\000\
\003\000\003\000\001\000\002\000\007\000\007\000\001\000\002\000\
\008\000\007\000\001\000\002\000\003\000\005\000\002\000\005\000\
\002\000\004\000\002\000\002\000\001\000\001\000\001\000\000\000\
\002\000\001\000\003\000\001\000\001\000\003\000\001\000\002\000\
\003\000\007\000\007\000\004\000\004\000\007\000\006\000\006\000\
\005\000\001\000\002\000\002\000\007\000\005\000\006\000\010\000\
\003\000\008\000\003\000\003\000\003\000\003\000\003\000\003\000\
\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
\003\000\003\000\003\000\003\000\003\000\003\000\002\000\002\000\
\005\000\007\000\007\000\007\000\003\000\003\000\003\000\004\000\
\004\000\002\000\001\000\001\000\001\000\001\000\003\000\003\000\
\004\000\003\000\004\000\004\000\003\000\005\000\005\000\005\000\
\005\000\005\000\005\000\005\000\005\000\003\000\003\000\005\000\
\005\000\004\000\004\000\002\000\006\000\006\000\004\000\004\000\
\006\000\006\000\002\000\002\000\003\000\004\000\004\000\002\000\
\006\000\006\000\003\000\003\000\004\000\006\000\005\000\008\000\
\007\000\001\000\001\000\002\000\001\000\001\000\002\000\002\000\
\002\000\002\000\001\000\001\000\002\000\002\000\007\000\008\000\
\003\000\005\000\001\000\002\000\005\000\003\000\001\000\003\000\
\002\000\002\000\005\000\001\000\003\000\003\000\005\000\002\000\
\002\000\005\000\003\000\003\000\003\000\001\000\001\000\003\000\
\002\000\003\000\001\000\003\000\005\000\001\000\003\000\002\000\
\004\000\002\000\002\000\002\000\001\000\003\000\003\000\001\000\
\002\000\002\000\003\000\003\000\008\000\008\000\003\000\003\000\
\002\000\002\000\002\000\001\000\001\000\001\000\001\000\003\000\
\001\000\001\000\002\000\003\000\003\000\004\000\004\000\004\000\
\002\000\004\000\003\000\003\000\005\000\005\000\004\000\004\000\
\006\000\006\000\001\000\003\000\003\000\003\000\001\000\003\000\
\001\000\002\000\004\000\003\000\003\000\001\000\005\000\001\000\
\002\000\007\000\001\000\002\000\007\000\006\000\003\000\000\000\
\000\000\002\000\003\000\002\000\003\000\002\000\005\000\005\000\
\004\000\007\000\000\000\001\000\003\000\002\000\001\000\003\000\
\002\000\001\000\000\000\001\000\003\000\002\000\000\000\001\000\
\001\000\002\000\001\000\003\000\001\000\001\000\002\000\003\000\
\004\000\001\000\006\000\005\000\000\000\002\000\004\000\002\000\
\001\000\001\000\002\000\005\000\007\000\008\000\008\000\001\000\
\001\000\001\000\001\000\002\000\002\000\001\000\001\000\002\000\
\003\000\004\000\004\000\005\000\001\000\003\000\006\000\005\000\
\004\000\004\000\001\000\002\000\002\000\003\000\001\000\003\000\
\001\000\003\000\001\000\002\000\001\000\004\000\001\000\006\000\
\004\000\005\000\003\000\001\000\003\000\001\000\003\000\002\000\
\001\000\001\000\002\000\004\000\003\000\002\000\002\000\003\000\
\005\000\003\000\004\000\005\000\004\000\002\000\004\000\006\000\
\004\000\001\000\001\000\003\000\004\000\001\000\003\000\001\000\
\003\000\001\000\001\000\005\000\002\000\001\000\000\000\001\000\
\003\000\001\000\002\000\001\000\003\000\001\000\003\000\001\000\
\003\000\001\000\003\000\001\000\003\000\003\000\002\000\001\000\
\004\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\002\000\002\000\002\000\002\000\002\000\002\000\
\002\000\002\000\002\000\002\000\001\000\001\000\001\000\003\000\
\003\000\002\000\003\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\002\000\001\000\001\000\001\000\001\000\
\003\000\001\000\002\000\002\000\001\000\001\000\001\000\003\000\
\001\000\003\000\001\000\003\000\001\000\003\000\004\000\001\000\
\003\000\001\000\003\000\001\000\003\000\002\000\003\000\003\000\
\003\000\003\000\003\000\003\000\002\000\000\000\001\000\000\000\
\001\000\001\000\001\000\000\000\001\000\000\000\001\000\000\000\
\001\000\000\000\001\000\001\000\002\000\002\000\000\000\001\000\
\000\000\001\000\000\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\003\000\004\000\004\000\004\000\000\000\
\002\000\000\000\002\000\000\000\002\000\003\000\004\000\004\000\
\001\000\002\000\002\000\004\000\002\000\002\000\002\000\002\000\
\002\000\002\000\002\000"

let yydefred = "\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\060\002\000\000\000\000\000\000\
\117\002\062\002\000\000\000\000\000\000\000\000\000\000\059\002\
\063\002\064\002\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\165\002\166\002\
\000\000\065\002\000\000\000\000\000\000\167\002\168\002\000\000\
\000\000\061\002\118\002\000\000\000\000\123\002\000\000\237\002\
\000\000\000\000\000\000\000\000\000\000\066\001\050\000\000\000\
\055\000\000\000\057\000\058\000\059\000\000\000\061\000\062\000\
\000\000\000\000\065\000\000\000\067\000\073\000\210\001\119\000\
\000\000\199\000\000\000\000\000\000\000\000\000\000\000\000\000\
\019\001\020\001\112\002\083\001\171\001\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\238\002\000\000\091\000\000\000\
\098\000\099\000\000\000\000\000\104\000\000\000\090\000\093\000\
\094\000\095\000\096\000\000\000\100\000\000\000\112\000\195\000\
\005\000\000\000\239\002\000\000\000\000\000\000\007\000\000\000\
\013\000\000\000\240\002\000\000\000\000\000\000\010\000\011\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\125\002\009\002\241\002\000\000\026\002\010\002\
\251\001\000\000\000\000\255\001\000\000\000\000\242\002\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\079\002\000\000\
\000\000\000\000\000\000\134\001\243\002\000\000\000\000\155\001\
\117\001\000\000\000\000\066\002\132\001\133\001\000\000\000\000\
\000\000\000\000\000\000\000\000\078\002\077\002\141\002\000\000\
\052\001\021\001\022\001\000\000\000\000\153\002\000\000\109\002\
\110\002\000\000\111\002\107\002\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\048\000\000\000\000\000\000\000\000\000\000\000\000\000\102\001\
\000\000\056\001\058\002\000\000\000\000\115\002\000\000\000\000\
\044\001\000\000\171\002\172\002\173\002\174\002\175\002\176\002\
\177\002\178\002\179\002\180\002\181\002\182\002\183\002\184\002\
\185\002\186\002\187\002\188\002\189\002\190\002\191\002\192\002\
\193\002\194\002\195\002\169\002\196\002\197\002\198\002\199\002\
\200\002\201\002\202\002\203\002\204\002\205\002\206\002\207\002\
\208\002\209\002\210\002\211\002\212\002\213\002\170\002\214\002\
\215\002\216\002\217\002\218\002\000\000\000\000\000\000\000\000\
\000\000\000\000\082\002\103\002\102\002\000\000\101\002\000\000\
\104\002\097\002\099\002\085\002\086\002\087\002\088\002\089\002\
\098\002\000\000\000\000\000\000\100\002\106\002\000\000\000\000\
\105\002\000\000\116\002\090\002\096\002\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\160\002\000\000\
\051\001\052\000\000\000\145\002\000\000\000\000\001\000\000\000\
\000\000\000\000\000\000\053\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\018\001\000\000\000\000\
\084\001\000\000\172\001\000\000\074\000\000\000\120\000\000\000\
\200\000\066\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\067\001\070\001\000\000\000\000\
\000\000\007\001\008\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\085\000\077\000\128\002\000\000\000\000\
\000\000\088\000\000\000\000\000\002\000\103\000\089\000\000\000\
\113\000\000\000\196\000\000\000\003\000\004\000\006\000\009\000\
\014\000\000\000\000\000\000\000\019\000\000\000\018\000\000\000\
\121\002\000\000\035\002\000\000\000\000\162\002\000\000\022\002\
\000\000\056\002\014\002\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\008\002\132\002\000\000\015\002\
\020\000\252\001\000\000\000\000\000\000\000\000\000\000\000\000\
\011\002\021\000\130\001\000\000\129\001\137\001\138\001\119\002\
\000\000\000\000\000\000\000\000\000\000\000\000\145\001\000\000\
\091\002\000\000\000\000\095\002\000\000\000\000\093\002\084\002\
\000\000\068\002\067\002\069\002\070\002\071\002\073\002\072\002\
\074\002\075\002\076\002\139\001\000\000\000\000\000\000\000\000\
\022\000\131\001\000\000\121\001\122\001\000\000\000\000\000\000\
\000\000\000\000\229\002\000\000\000\000\026\001\000\000\000\000\
\000\000\000\000\108\002\000\000\000\000\000\000\000\000\094\002\
\000\000\092\002\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\213\000\000\000\000\000\000\000\028\000\000\000\
\000\000\000\000\000\000\000\000\068\000\047\000\000\000\000\000\
\000\000\000\000\039\001\038\001\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\233\002\000\000\
\000\000\000\000\000\000\143\002\000\000\000\000\083\002\000\000\
\024\001\000\000\000\000\023\001\000\000\081\002\080\002\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\053\001\
\000\000\000\000\148\000\000\000\000\000\000\000\201\001\200\001\
\000\000\188\001\000\000\000\000\000\000\049\000\225\002\000\000\
\000\000\000\000\000\000\000\000\124\002\113\002\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\205\000\000\000\000\000\000\000\000\000\
\000\000\225\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\075\001\073\001\059\001\
\000\000\072\001\068\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\106\000\086\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\139\002\136\002\
\135\002\140\002\000\000\137\002\017\000\000\000\016\000\012\000\
\034\002\000\000\032\002\000\000\037\002\018\002\000\000\000\000\
\000\000\000\000\013\002\000\000\055\002\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\122\002\126\002\000\000\
\000\000\000\000\050\002\000\000\016\002\000\000\000\000\141\001\
\140\001\000\000\000\000\000\000\000\000\000\000\000\000\148\001\
\000\000\147\001\119\001\118\001\128\001\000\000\124\001\000\000\
\158\001\000\000\000\000\136\001\000\000\230\002\227\002\000\000\
\000\000\000\000\029\001\027\001\025\001\000\000\000\000\000\000\
\203\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\214\001\052\002\000\000\000\000\000\000\212\000\
\000\000\214\000\000\000\215\000\209\000\220\000\000\000\207\000\
\000\000\211\000\000\000\000\000\000\000\229\000\000\000\000\000\
\092\001\000\000\023\000\025\000\026\000\000\000\000\000\027\000\
\000\000\039\000\000\000\038\000\031\000\030\000\034\000\000\000\
\000\000\101\001\000\000\104\001\000\000\000\000\055\001\054\001\
\000\000\048\001\047\001\043\001\042\001\220\002\000\000\000\000\
\231\002\232\002\000\000\000\000\000\000\000\000\000\000\061\001\
\115\001\000\000\116\001\000\000\028\001\223\002\000\000\000\000\
\000\000\000\000\000\000\000\000\071\000\072\000\000\000\017\001\
\016\001\000\000\105\000\000\000\191\001\000\000\000\000\000\000\
\000\000\194\001\190\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\086\001\000\000\000\000\000\000\
\000\000\000\000\087\001\078\001\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\084\000\083\000\000\000\079\000\078\000\000\000\000\000\000\000\
\237\001\000\000\129\002\000\000\000\000\000\000\000\000\000\000\
\110\000\000\000\000\000\000\000\000\000\000\000\015\000\000\000\
\019\002\038\002\000\000\000\000\000\000\023\002\021\002\000\000\
\000\000\000\000\249\001\054\002\000\000\025\002\000\000\000\000\
\000\000\012\002\000\000\000\000\133\002\000\000\127\002\254\001\
\000\000\120\002\000\000\000\000\164\001\000\000\143\001\142\001\
\146\001\144\001\000\000\000\000\152\001\151\001\000\000\221\002\
\000\000\000\000\000\000\000\000\000\000\127\000\000\000\198\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\212\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\096\001\097\001\000\000\000\000\000\000\000\000\
\000\000\000\000\046\000\000\000\000\000\040\000\000\000\035\000\
\033\000\000\000\000\000\000\000\000\000\085\001\000\000\063\001\
\000\000\000\000\000\000\075\000\000\000\118\000\000\000\000\000\
\145\000\000\000\000\000\000\000\000\000\000\000\000\000\156\000\
\149\000\233\000\000\000\000\000\189\001\000\000\176\001\000\000\
\193\001\000\000\222\002\041\001\040\001\000\000\000\000\000\000\
\000\000\031\001\030\001\081\001\000\000\000\000\089\001\000\000\
\090\001\000\000\000\000\176\001\076\000\000\000\000\000\000\000\
\037\001\035\001\000\000\033\001\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\196\001\000\000\000\000\
\111\000\109\000\000\000\000\000\167\001\000\000\000\000\033\002\
\040\002\000\000\020\002\042\002\000\000\000\000\000\000\000\000\
\057\002\000\000\000\000\028\002\000\000\017\002\000\000\051\002\
\164\002\163\001\000\000\000\000\150\001\149\001\036\001\034\001\
\032\001\000\000\204\001\202\001\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\174\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\135\000\000\000\
\000\000\000\000\137\000\121\000\125\000\000\000\215\001\053\002\
\211\001\000\000\000\000\147\002\146\002\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\210\000\000\000\094\001\000\000\
\093\001\000\000\000\000\044\000\000\000\045\000\000\000\037\000\
\036\000\000\000\236\002\000\000\000\000\000\000\062\001\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\155\000\000\000\192\001\000\000\
\182\001\000\000\000\000\000\000\000\000\000\000\000\000\205\001\
\206\001\000\000\000\000\149\002\000\000\239\000\058\001\057\001\
\050\001\049\001\046\001\045\001\000\000\000\000\000\000\000\000\
\000\000\088\001\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\238\001\114\000\000\000\000\000\115\000\000\000\000\000\036\002\
\024\002\043\002\250\001\246\001\000\000\000\000\000\000\000\000\
\154\001\153\001\000\000\130\002\178\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\182\000\000\000\000\000\
\000\000\177\000\000\000\000\000\000\000\000\000\131\000\000\000\
\000\000\000\000\000\000\134\000\000\000\169\001\170\001\000\000\
\230\000\000\000\217\000\208\000\206\000\000\000\000\000\000\000\
\000\000\024\000\000\000\041\000\043\000\226\000\227\000\000\000\
\146\000\000\000\153\000\000\000\154\000\000\000\000\000\000\000\
\152\000\151\002\000\000\000\000\000\000\151\000\000\000\000\000\
\000\000\000\000\000\000\207\001\000\000\000\000\173\001\000\000\
\000\000\000\000\224\001\225\001\226\001\227\001\065\001\000\000\
\077\001\000\000\000\000\000\000\082\001\174\001\122\000\000\000\
\000\000\000\000\000\000\197\000\000\000\000\000\197\001\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\230\001\231\001\
\000\000\041\002\000\000\031\002\000\000\201\000\000\000\000\000\
\000\000\000\000\000\000\176\000\175\000\000\000\000\000\000\000\
\000\000\172\000\047\002\000\000\000\000\129\000\000\000\143\000\
\000\000\142\000\139\000\138\000\000\000\000\000\098\001\095\001\
\000\000\242\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\185\001\000\000\000\000\000\000\
\217\001\000\000\208\001\000\000\175\001\000\000\000\000\000\000\
\222\001\228\001\229\001\064\001\000\000\000\000\091\001\202\000\
\240\001\244\001\176\001\108\000\000\000\223\001\232\001\198\000\
\000\000\126\001\125\001\131\002\173\000\000\000\180\000\000\000\
\000\000\000\000\000\000\000\000\189\000\183\000\170\000\000\000\
\000\000\136\000\000\000\000\000\042\000\157\000\150\000\000\000\
\000\000\000\000\165\000\000\000\000\000\000\000\000\000\209\001\
\000\000\000\000\000\000\183\001\219\001\000\000\000\000\000\000\
\000\000\233\001\000\000\079\001\000\000\171\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\188\000\
\000\000\141\000\140\000\240\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\161\000\000\000\000\000\000\000\
\000\000\000\000\234\001\235\001\080\001\187\000\184\000\157\002\
\158\002\000\000\000\000\000\000\000\000\185\000\169\000\163\000\
\164\000\000\000\000\000\000\000\000\000\162\000\186\001\000\000\
\236\001\000\000\000\000\000\000\000\000\000\000\166\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\186\000\000\000\
\000\000\000\000\221\001\167\000"

let yydgoto = "\008\000\
\056\000\101\000\123\000\131\000\149\000\159\000\173\000\055\002\
\102\000\124\000\132\000\058\000\081\001\127\000\059\000\135\000\
\136\000\193\001\233\001\078\002\022\003\147\001\032\002\215\000\
\060\000\061\000\191\002\110\001\062\000\063\000\161\000\065\000\
\066\000\067\000\068\000\069\000\070\000\071\000\072\000\073\000\
\074\000\075\000\076\000\077\000\079\002\078\000\117\001\149\001\
\120\003\110\000\111\000\112\000\079\000\114\000\115\000\116\000\
\117\000\118\000\072\001\162\002\119\000\161\001\066\003\150\001\
\080\000\119\001\199\000\010\002\187\003\089\004\076\004\013\003\
\239\002\223\004\090\004\131\001\194\001\091\004\082\002\083\002\
\074\003\241\003\085\005\140\004\137\004\133\004\081\000\095\005\
\098\003\185\005\150\004\099\003\167\004\077\004\078\004\079\004\
\213\004\214\004\062\005\134\005\175\005\171\005\101\005\120\000\
\163\001\082\000\121\001\199\003\106\004\200\003\198\003\005\003\
\177\000\083\000\034\001\183\001\016\003\014\003\084\000\085\000\
\086\000\102\004\087\000\088\000\222\000\089\000\090\000\223\000\
\232\000\048\002\229\000\133\001\134\001\143\002\127\002\091\000\
\100\003\186\005\182\000\092\000\113\001\061\002\017\003\224\000\
\225\000\183\000\184\000\152\000\219\001\222\001\220\001\099\004\
\093\000\115\001\077\001\089\002\247\003\155\004\151\004\096\005\
\090\002\078\003\091\002\083\003\029\004\241\002\184\003\152\004\
\153\004\154\004\015\002\003\002\244\002\080\004\097\005\098\005\
\146\003\018\005\046\005\019\005\020\005\021\005\022\005\121\003\
\042\005\153\000\154\000\155\000\156\000\157\000\158\000\189\001\
\177\002\178\002\179\002\045\004\052\004\053\004\139\003\042\004\
\247\002\190\001\063\001\029\001\030\001\056\002\082\001"

let yysindex = "\020\008\
\217\062\157\006\112\044\005\044\107\015\144\064\150\068\000\000\
\132\004\108\002\087\070\132\004\000\000\202\001\101\000\017\001\
\000\000\000\000\132\004\132\004\132\004\132\004\025\003\000\000\
\000\000\000\000\132\004\150\070\082\255\049\063\139\063\219\058\
\219\058\029\005\000\000\184\055\219\058\132\004\000\000\000\000\
\232\004\000\000\132\004\132\004\142\255\000\000\000\000\087\070\
\217\062\000\000\000\000\132\004\185\255\000\000\132\004\000\000\
\040\001\047\000\155\011\024\000\217\071\000\000\000\000\246\002\
\000\000\056\000\000\000\000\000\000\000\222\001\000\000\000\000\
\034\002\055\002\000\000\047\000\000\000\000\000\000\000\000\000\
\048\002\000\000\217\069\155\000\087\070\087\070\144\064\144\064\
\000\000\000\000\000\000\000\000\000\000\202\001\101\000\024\004\
\066\005\157\006\185\255\017\001\000\000\136\003\000\000\056\000\
\000\000\000\000\055\002\047\000\000\000\157\006\000\000\000\000\
\000\000\000\000\000\000\135\002\000\000\158\002\000\000\000\000\
\000\000\108\002\000\000\060\002\096\002\047\000\000\000\227\002\
\000\000\228\044\000\000\082\004\047\000\082\004\000\000\000\000\
\011\009\213\002\172\255\135\004\010\003\133\073\107\015\140\003\
\108\002\243\002\000\000\000\000\000\000\076\000\000\000\000\000\
\000\000\212\001\019\000\000\000\144\003\182\002\000\000\043\005\
\246\002\150\068\150\069\024\003\135\067\205\067\000\000\144\059\
\102\003\183\003\028\003\000\000\000\000\074\000\036\004\000\000\
\000\000\150\068\150\068\000\000\000\000\000\000\085\004\152\004\
\219\058\219\058\083\004\087\070\000\000\000\000\000\000\040\056\
\000\000\000\000\000\000\226\063\207\003\000\000\126\004\000\000\
\000\000\088\004\000\000\000\000\079\002\152\071\189\004\150\068\
\199\066\213\002\144\064\149\004\111\002\217\062\091\005\036\004\
\000\000\087\070\000\000\217\004\014\001\229\004\145\255\000\000\
\147\004\000\000\000\000\234\004\161\004\000\000\149\072\190\004\
\000\000\190\004\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\016\005\128\062\128\062\132\004\
\142\255\213\004\000\000\000\000\000\000\087\070\000\000\225\004\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\179\000\000\000\000\000\000\000\000\000\
\000\000\087\070\000\000\000\000\000\000\041\000\118\255\128\062\
\144\064\204\004\108\002\193\002\243\002\008\005\000\000\226\004\
\000\000\000\000\144\064\000\000\185\004\144\064\000\000\219\058\
\155\011\047\000\132\004\000\000\087\005\009\006\144\064\144\064\
\144\064\144\064\144\064\144\064\144\064\144\064\144\064\144\064\
\144\064\144\064\144\064\144\064\144\064\144\064\144\064\144\064\
\144\064\144\064\144\064\144\064\144\064\000\000\150\068\144\064\
\000\000\185\004\000\000\250\004\000\000\207\003\000\000\207\003\
\000\000\000\000\144\064\031\004\087\070\087\070\054\005\059\005\
\087\070\054\005\024\070\098\001\000\000\000\000\144\064\098\001\
\098\001\000\000\000\000\126\004\152\001\149\004\024\004\002\005\
\157\006\000\000\059\002\000\000\000\000\000\000\173\002\027\005\
\074\003\000\000\185\004\128\005\000\000\000\000\000\000\051\005\
\000\000\207\003\000\000\066\006\000\000\000\000\000\000\000\000\
\000\000\082\004\047\000\082\004\000\000\082\004\000\000\073\012\
\000\000\025\004\000\000\077\005\165\005\000\000\073\012\000\000\
\073\012\000\000\000\000\171\005\151\005\093\005\107\015\059\003\
\083\004\029\001\123\005\186\005\000\000\000\000\182\005\000\000\
\000\000\000\000\061\003\096\005\120\005\107\015\095\007\243\002\
\000\000\000\000\000\000\084\061\000\000\000\000\000\000\000\000\
\191\005\187\005\064\000\122\005\249\003\125\005\000\000\125\005\
\000\000\134\005\102\003\000\000\135\255\183\003\000\000\000\000\
\129\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\044\002\148\061\212\061\020\062\
\000\000\000\000\139\005\000\000\000\000\150\068\192\002\128\062\
\083\004\083\004\000\000\098\001\208\004\000\000\245\002\126\004\
\042\004\173\005\000\000\003\039\116\001\003\039\083\004\000\000\
\236\005\000\000\107\015\043\003\150\069\001\060\100\002\068\005\
\100\005\071\066\000\000\150\068\149\005\014\005\000\000\011\001\
\144\064\139\001\167\003\214\003\000\000\000\000\098\001\124\006\
\024\003\144\064\000\000\000\000\024\003\144\064\059\005\199\003\
\144\064\187\255\122\255\219\058\107\015\150\068\000\000\164\005\
\166\005\148\005\132\004\000\000\150\068\195\005\000\000\118\001\
\000\000\152\011\214\012\000\000\170\005\000\000\000\000\168\005\
\150\005\193\002\241\005\024\004\025\003\193\002\047\000\000\000\
\150\068\053\004\000\000\108\003\156\005\042\004\000\000\000\000\
\098\003\000\000\239\000\254\005\128\062\000\000\000\000\150\070\
\059\005\144\064\144\064\152\056\000\000\000\000\134\073\134\073\
\081\073\026\007\149\072\081\073\143\012\143\012\143\012\143\012\
\165\002\229\005\229\005\143\012\165\002\165\002\081\073\229\005\
\165\002\165\002\165\002\000\000\229\005\015\005\047\000\062\065\
\006\006\000\000\213\005\193\002\126\004\126\004\149\072\144\064\
\144\064\144\064\217\005\098\001\098\001\000\000\000\000\000\000\
\001\006\000\000\000\000\081\073\221\005\019\005\143\255\201\005\
\072\004\254\003\000\000\000\000\109\003\020\006\024\004\226\004\
\216\002\047\000\098\003\107\015\024\006\126\004\000\000\000\000\
\000\000\000\000\017\006\000\000\000\000\082\004\000\000\000\000\
\000\000\218\000\000\000\041\006\000\000\000\000\073\012\191\000\
\025\001\029\016\000\000\236\001\000\000\226\005\218\005\196\005\
\107\015\047\003\107\015\107\015\117\003\000\000\000\000\187\001\
\108\002\242\005\000\000\215\005\000\000\129\003\150\068\000\000\
\000\000\032\003\150\068\032\000\063\003\004\006\034\001\000\000\
\156\013\000\000\000\000\000\000\000\000\170\002\000\000\052\006\
\000\000\096\255\096\255\000\000\233\005\000\000\000\000\144\064\
\144\064\144\064\000\000\000\000\000\000\007\006\187\000\240\005\
\000\000\196\065\133\073\003\006\000\000\182\002\232\005\244\005\
\239\005\083\004\000\000\000\000\047\000\194\001\144\064\000\000\
\015\006\000\000\150\068\000\000\000\000\000\000\023\006\000\000\
\023\006\000\000\114\060\144\064\071\066\000\000\029\000\081\006\
\000\000\144\064\000\000\000\000\000\000\076\006\025\003\000\000\
\105\071\000\000\024\004\000\000\000\000\000\000\000\000\253\000\
\000\000\000\000\149\072\000\000\149\072\065\006\000\000\000\000\
\149\072\000\000\000\000\000\000\000\000\000\000\083\004\121\255\
\000\000\000\000\193\002\226\004\047\000\144\064\148\255\000\000\
\000\000\016\002\000\000\083\004\000\000\000\000\213\002\047\000\
\024\004\047\000\043\001\112\005\000\000\000\000\053\002\000\000\
\000\000\043\002\000\000\131\005\000\000\056\001\067\006\005\006\
\108\002\000\000\000\000\144\064\011\006\083\000\161\004\190\004\
\190\004\179\000\166\255\144\064\000\000\036\011\144\064\227\060\
\129\065\068\006\000\000\000\000\107\015\067\006\047\000\033\006\
\036\006\249\071\003\005\069\000\174\255\144\064\089\006\024\004\
\000\000\000\000\025\003\000\000\000\000\252\005\194\004\105\006\
\000\000\000\000\000\000\024\004\036\002\108\003\118\002\099\006\
\000\000\026\006\115\005\024\004\056\006\226\255\000\000\073\012\
\000\000\000\000\107\015\064\001\116\006\000\000\000\000\108\002\
\043\000\083\004\000\000\000\000\107\015\000\000\014\006\083\004\
\243\002\000\000\242\005\053\006\000\000\019\006\000\000\000\000\
\095\007\000\000\249\003\038\006\000\000\249\003\000\000\000\000\
\000\000\000\000\150\068\059\003\000\000\000\000\205\255\000\000\
\055\072\182\000\217\255\106\006\042\004\000\000\108\002\000\000\
\097\010\156\004\047\000\196\065\094\001\141\046\003\039\047\000\
\000\000\037\006\007\000\040\006\203\003\114\006\114\006\128\006\
\047\006\079\006\000\000\000\000\144\064\144\064\150\068\087\072\
\024\004\112\005\000\000\156\255\157\255\000\000\160\255\000\000\
\000\000\144\064\144\064\108\006\024\005\000\000\181\072\000\000\
\049\006\107\015\150\068\000\000\036\002\000\000\025\003\107\015\
\000\000\107\015\142\255\144\064\142\255\117\255\047\000\000\000\
\000\000\000\000\150\068\042\004\000\000\227\070\000\000\060\006\
\000\000\130\006\000\000\000\000\000\000\051\004\235\000\062\005\
\085\002\000\000\000\000\000\000\090\006\084\001\000\000\100\006\
\000\000\144\064\163\002\000\000\000\000\196\065\129\006\103\006\
\000\000\000\000\104\006\000\000\109\006\149\072\097\010\036\002\
\112\005\152\006\144\000\042\004\150\003\000\000\254\003\059\002\
\000\000\000\000\024\004\060\006\000\000\059\002\159\006\000\000\
\000\000\046\002\000\000\000\000\065\001\000\000\107\015\108\002\
\000\000\242\005\024\003\000\000\172\006\000\000\107\015\000\000\
\000\000\000\000\037\004\090\000\000\000\000\000\000\000\000\000\
\000\000\012\003\000\000\000\000\114\014\168\006\133\073\118\006\
\141\046\122\006\000\000\161\006\083\004\120\006\000\000\093\006\
\042\003\182\002\007\067\107\015\156\004\008\005\000\000\080\004\
\083\004\024\070\000\000\000\000\000\000\047\003\000\000\000\000\
\000\000\037\006\047\000\000\000\000\000\144\064\071\066\107\015\
\144\064\096\006\101\006\107\015\000\000\107\006\000\000\125\006\
\000\000\144\064\037\255\000\000\079\255\000\000\110\006\000\000\
\000\000\149\072\000\000\144\064\144\064\144\064\000\000\083\004\
\081\006\112\005\059\255\255\002\047\000\156\004\047\000\000\003\
\047\000\133\006\135\006\047\000\000\000\081\006\000\000\101\000\
\000\000\219\048\034\071\000\000\111\003\142\006\192\006\000\000\
\000\000\152\001\001\002\000\000\037\001\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\169\255\090\006\179\006\107\015\
\119\006\000\000\144\064\001\002\047\000\012\003\144\064\144\064\
\144\064\047\000\096\005\096\005\149\001\000\000\189\006\187\006\
\000\000\000\000\222\002\121\001\000\000\097\010\107\015\000\000\
\000\000\000\000\000\000\000\000\193\006\014\006\242\005\020\062\
\000\000\000\000\107\015\000\000\000\000\115\005\153\003\087\001\
\144\003\141\046\159\001\107\015\137\004\000\000\145\006\207\006\
\156\004\000\000\097\010\003\039\179\003\135\066\000\000\097\001\
\223\255\144\004\156\004\000\000\024\070\000\000\000\000\202\006\
\000\000\083\004\000\000\000\000\000\000\083\004\071\066\144\064\
\149\072\000\000\059\003\000\000\000\000\000\000\000\000\019\073\
\000\000\107\015\000\000\195\001\000\000\113\006\060\006\059\005\
\000\000\000\000\059\005\123\006\059\005\000\000\152\001\083\004\
\192\006\192\001\133\006\000\000\083\004\107\015\000\000\101\000\
\094\002\032\002\000\000\000\000\000\000\000\000\000\000\132\006\
\000\000\107\015\146\003\129\065\000\000\000\000\000\000\115\005\
\149\072\149\072\149\072\000\000\240\003\240\003\000\000\107\015\
\134\006\107\015\118\002\101\000\152\001\071\002\000\000\000\000\
\047\000\000\000\107\015\000\000\031\001\000\000\206\003\208\003\
\156\006\047\003\087\000\000\000\000\000\109\001\097\010\141\046\
\083\004\000\000\000\000\000\000\156\004\000\000\243\002\000\000\
\097\010\000\000\000\000\000\000\083\004\144\064\000\000\000\000\
\138\006\000\000\083\004\171\006\047\000\059\005\059\005\007\066\
\226\006\059\005\012\005\083\004\000\000\207\000\059\005\148\006\
\000\000\133\006\000\000\221\003\000\000\127\002\116\001\083\004\
\000\000\000\000\000\000\000\000\229\003\144\064\000\000\000\000\
\000\000\000\000\000\000\000\000\152\001\000\000\000\000\000\000\
\083\004\000\000\000\000\000\000\000\000\097\010\000\000\107\015\
\012\003\058\004\186\002\047\000\000\000\000\000\000\000\178\006\
\083\004\000\000\108\000\236\006\000\000\000\000\000\000\244\006\
\245\006\189\070\000\000\107\015\248\006\144\064\239\006\000\000\
\133\006\192\006\249\006\000\000\000\000\107\015\116\001\083\004\
\083\004\000\000\144\064\000\000\250\006\000\000\047\000\115\005\
\170\006\181\006\059\005\207\003\133\006\015\007\047\000\000\000\
\097\010\000\000\000\000\000\000\029\016\029\016\090\006\083\004\
\006\007\172\001\083\004\107\015\000\000\144\064\197\006\029\016\
\083\004\083\004\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\021\007\059\005\059\005\107\015\000\000\000\000\000\000\
\000\000\017\007\144\064\107\015\083\004\000\000\000\000\083\004\
\000\000\029\016\028\007\030\007\083\004\107\015\000\000\083\004\
\205\006\047\000\107\015\107\015\004\004\083\004\000\000\083\004\
\083\004\144\064\000\000\000\000"

let yyrindex = "\000\000\
\047\008\048\008\208\006\000\000\000\000\000\000\000\000\000\000\
\213\070\000\000\000\000\057\064\000\000\115\003\000\000\000\000\
\000\000\000\000\214\068\071\067\016\068\231\064\000\000\000\000\
\000\000\000\000\213\070\000\000\000\000\000\000\000\000\000\000\
\000\000\080\068\234\016\000\000\000\000\231\064\000\000\000\000\
\000\000\000\000\247\003\237\001\194\006\000\000\000\000\000\000\
\071\000\000\000\000\000\231\064\212\003\000\000\231\064\000\000\
\000\000\226\009\071\000\102\017\154\038\000\000\000\000\064\054\
\000\000\103\054\000\000\000\000\000\000\147\054\000\000\000\000\
\192\054\214\054\000\000\223\054\000\000\000\000\000\000\000\000\
\000\000\000\000\251\022\115\023\014\022\132\022\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\115\003\000\000\000\000\
\000\000\110\000\212\003\000\000\000\000\000\000\000\000\121\014\
\000\000\000\000\063\049\181\049\000\000\110\000\000\000\000\000\
\000\000\000\000\000\000\240\050\000\000\089\051\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\209\006\000\000\208\006\
\000\000\000\000\000\000\000\000\127\004\000\000\000\000\000\000\
\000\000\060\013\060\013\000\000\010\039\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\037\015\000\000\237\039\082\040\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\086\045\000\000\
\000\000\164\002\032\006\000\000\000\000\000\000\149\006\200\045\
\000\000\000\000\003\057\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\115\003\000\000\252\006\000\000\
\000\000\000\000\000\000\000\000\248\052\000\000\000\000\000\000\
\000\000\022\069\000\000\000\000\000\000\197\004\223\054\243\005\
\000\000\000\000\096\001\155\004\000\000\201\255\000\000\000\000\
\091\000\000\000\000\000\000\000\130\004\000\000\094\000\254\000\
\000\000\092\005\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\067\055\215\006\215\006\199\006\
\034\004\086\069\000\000\000\000\000\000\151\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\117\057\205\057\000\000\000\000\000\000\037\058\125\058\
\000\000\153\000\000\000\000\000\000\000\000\000\000\000\215\006\
\000\000\000\000\000\000\000\000\000\000\091\006\000\000\000\000\
\000\000\000\000\000\000\000\000\248\002\000\000\000\000\000\000\
\071\000\247\047\080\068\000\000\064\054\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\202\031\000\000\000\000\000\000\000\000\
\000\000\050\003\000\000\000\000\000\000\115\003\000\000\115\003\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\224\017\169\020\000\000\000\000\000\000\233\023\
\095\024\000\000\000\000\252\006\138\010\000\000\000\000\000\000\
\214\004\202\007\181\049\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\248\002\000\000\000\000\000\000\000\000\000\000\
\000\000\115\003\000\000\111\007\000\000\000\000\000\000\000\000\
\000\000\000\000\127\004\000\000\000\000\000\000\000\000\000\000\
\000\000\071\001\000\000\048\007\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\027\007\000\000\000\000\
\144\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\202\255\000\000\150\000\168\000\254\000\000\000\092\005\
\000\000\000\000\201\000\000\000\000\000\202\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\215\006\
\003\057\149\043\000\000\215\024\000\000\000\000\000\000\252\006\
\228\006\000\000\000\000\000\000\000\000\000\000\172\011\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\077\025\000\000\
\000\000\000\000\000\000\000\000\015\001\000\000\169\004\000\000\
\161\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\199\006\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\019\039\000\000\000\000\000\000\223\054\000\000\
\000\000\000\000\000\000\122\052\000\000\047\004\000\000\000\000\
\000\000\000\000\000\000\000\000\215\006\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\133\034\244\034\
\080\009\127\005\207\015\094\035\064\032\183\032\046\033\164\033\
\002\029\195\025\058\026\027\034\120\029\239\029\200\035\176\026\
\102\030\220\030\083\031\000\000\039\027\000\000\070\053\175\004\
\105\005\000\000\000\000\000\000\252\006\252\006\090\016\000\000\
\000\000\000\000\087\018\033\021\152\021\000\000\000\000\000\000\
\206\018\000\000\000\000\050\036\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\181\049\000\000\000\000\000\000\252\006\000\000\000\000\
\000\000\000\000\017\012\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\003\054\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\029\007\000\000\000\000\000\000\153\255\
\000\000\183\040\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\131\041\000\000\030\041\000\000\000\000\000\000\000\000\
\000\000\028\001\161\255\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\019\004\000\000\009\010\
\000\000\198\003\043\008\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\046\048\122\048\000\000\000\000\
\000\000\203\053\000\000\000\000\122\052\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\158\027\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\111\001\000\000\219\255\000\000\169\000\000\000\000\000\000\000\
\170\000\000\000\000\000\000\000\000\000\000\000\224\006\229\006\
\000\000\000\000\000\000\000\000\070\053\000\000\000\000\000\000\
\000\000\053\001\000\000\185\001\000\000\000\000\022\069\014\054\
\000\000\122\052\000\000\144\052\000\000\000\000\000\000\000\000\
\000\000\219\004\000\000\022\069\000\000\000\000\205\049\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\130\004\254\000\
\092\005\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\118\050\014\054\000\000\
\000\000\000\000\243\072\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\161\002\128\003\
\000\000\243\010\000\000\000\000\068\013\181\049\000\000\000\000\
\000\000\000\000\181\049\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\027\002\000\000\000\000\000\000\000\000\000\000\153\001\
\000\000\000\000\232\041\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\005\000\044\001\000\000\246\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\228\006\000\000\000\000\000\000\
\000\000\000\000\014\054\000\000\000\000\000\000\000\000\223\054\
\000\000\000\000\000\000\000\000\199\001\234\006\234\006\215\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\125\039\
\000\000\247\006\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\224\051\000\000\000\000\000\000\
\000\000\000\000\245\004\000\000\044\255\231\004\058\008\000\000\
\000\000\000\000\000\000\047\004\000\000\024\007\000\000\008\002\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\068\019\
\000\000\000\000\188\019\000\000\051\020\151\036\000\000\255\049\
\033\043\114\004\000\000\228\006\000\000\000\000\000\000\233\013\
\000\000\000\000\000\000\008\002\000\000\233\013\000\000\000\000\
\000\000\071\001\000\000\000\000\000\000\065\059\000\000\000\000\
\000\000\079\042\000\000\000\000\172\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\069\047\000\000\216\005\
\000\000\000\000\128\047\000\000\192\008\000\000\000\000\001\007\
\000\000\139\048\000\000\000\000\000\000\091\006\000\000\000\000\
\092\053\020\046\000\000\000\000\000\000\231\048\000\000\000\000\
\000\000\018\052\122\052\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\181\000\000\000\000\000\000\000\000\000\000\000\219\001\
\020\028\189\052\000\000\000\000\058\008\000\000\058\008\014\007\
\058\008\018\007\018\007\058\008\000\000\139\028\000\000\000\000\
\000\000\000\000\032\007\157\046\177\050\000\000\236\050\000\000\
\000\000\131\049\077\052\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\058\007\000\000\000\000\
\000\000\000\000\000\000\077\052\014\054\000\000\000\000\000\000\
\000\000\233\013\000\000\000\000\000\000\052\005\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\180\042\000\000\
\000\000\000\000\000\000\000\000\000\000\077\052\000\000\000\000\
\013\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\079\046\000\000\000\000\000\000\
\000\000\242\001\000\000\000\000\000\000\009\002\000\000\000\000\
\252\036\000\000\000\000\000\000\000\000\000\000\000\000\086\001\
\000\000\000\000\000\000\054\002\000\000\019\007\014\007\000\000\
\000\000\000\000\000\000\037\007\000\000\000\000\131\049\039\051\
\106\051\243\001\018\007\000\000\058\050\000\000\000\000\000\000\
\239\052\223\054\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\077\052\
\102\037\203\037\048\038\000\000\080\012\221\012\000\000\000\000\
\038\065\000\000\000\000\000\000\068\007\181\049\000\000\000\000\
\233\013\000\000\000\000\000\000\250\003\000\000\000\000\000\000\
\000\000\053\049\000\000\000\000\000\000\227\004\000\000\000\000\
\114\053\000\000\000\000\187\047\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\216\046\000\000\000\000\000\000\
\000\000\000\000\009\005\000\000\058\008\000\000\000\000\000\000\
\000\000\000\000\000\000\058\050\000\000\000\000\000\000\000\000\
\000\000\069\002\000\000\000\000\000\000\239\052\000\000\215\051\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\068\007\000\000\000\000\000\000\
\190\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\038\007\000\000\227\009\000\000\000\000\000\000\000\000\
\019\047\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\018\007\165\051\000\000\000\000\000\000\000\000\000\000\215\051\
\193\053\000\000\000\000\000\000\044\014\000\000\227\009\227\009\
\045\007\050\007\000\000\056\007\018\007\000\000\227\009\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\048\003\
\000\000\000\000\047\005\000\000\000\000\000\000\000\000\000\000\
\239\042\193\053\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\180\005\000\000\000\000\155\002\
\000\000\000\000\000\000\000\000\184\005\000\000\000\000\105\004\
\255\006\227\009\000\000\000\000\000\000\159\004\000\000\225\006\
\211\008\000\000\000\000\000\000"

let yygindex = "\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\092\000\
\243\255\000\000\086\000\253\255\232\006\255\007\062\000\000\000\
\204\255\135\000\063\000\091\255\000\000\148\254\000\007\071\255\
\210\007\163\014\243\252\017\000\022\004\014\000\049\000\052\000\
\066\000\000\000\000\000\000\000\000\000\075\000\088\000\000\000\
\097\000\000\000\002\000\004\000\094\254\000\000\000\000\083\254\
\000\000\000\000\000\000\000\000\099\000\000\000\000\000\000\000\
\000\000\000\000\238\254\160\252\000\000\000\000\000\000\006\000\
\000\000\000\000\164\255\207\254\136\254\018\252\114\252\072\255\
\103\004\168\003\000\000\048\004\056\253\115\255\055\004\000\000\
\000\000\000\000\000\000\000\000\000\000\016\003\247\255\204\251\
\201\254\036\254\129\252\057\003\139\251\029\252\010\252\090\003\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\140\005\205\004\168\004\000\000\000\000\
\103\255\030\000\231\000\140\255\005\002\009\253\093\255\190\008\
\049\011\000\000\000\000\000\000\106\255\251\006\142\012\062\006\
\001\000\086\255\073\006\134\254\000\000\034\007\112\006\214\011\
\189\252\088\253\212\254\000\000\000\000\000\000\220\004\076\004\
\000\000\000\000\166\006\119\255\220\005\010\008\000\000\079\004\
\000\000\000\000\080\008\073\002\080\005\045\252\184\251\244\252\
\210\253\000\000\015\254\000\000\000\000\234\255\000\000\000\000\
\235\251\249\255\240\251\105\254\254\253\034\254\000\000\000\000\
\247\002\000\000\000\000\252\003\160\251\000\000\170\003\154\004\
\000\000\115\253\003\012\126\255\000\000\009\000\067\254\010\006\
\136\255\215\254\130\255\000\000\253\003\000\000\000\000\000\000\
\238\006\000\000\000\000\000\000\026\000\053\255\000\000"

let yytablesize = 19189
let yytable = "\126\000\
\133\000\140\001\160\000\108\000\200\001\109\000\069\002\205\000\
\147\002\213\001\181\001\251\002\195\001\218\001\059\002\191\000\
\180\001\145\003\192\002\228\000\209\001\204\003\185\001\240\002\
\026\002\187\000\181\002\034\002\187\000\009\004\034\004\234\000\
\062\001\244\001\151\002\187\000\187\000\187\000\187\000\077\003\
\193\000\225\003\189\003\187\000\147\003\245\002\031\002\252\002\
\025\005\064\000\187\000\064\000\064\000\103\000\187\000\027\002\
\172\004\221\000\031\001\187\000\187\000\050\002\064\001\051\002\
\128\000\134\000\129\002\104\000\187\000\174\000\051\000\187\000\
\084\001\249\001\009\005\201\001\105\000\073\001\246\002\173\001\
\246\002\175\001\215\004\057\002\154\001\003\005\005\005\141\001\
\125\000\106\000\149\002\048\005\057\000\028\002\206\004\243\004\
\159\001\064\000\107\000\108\000\113\000\109\000\225\004\185\000\
\008\002\230\002\231\002\085\001\159\002\087\000\247\001\108\000\
\132\001\109\000\136\001\137\001\072\002\070\002\226\000\253\002\
\157\004\044\003\064\002\071\001\245\001\185\000\171\001\164\001\
\246\001\012\005\188\001\045\003\242\004\159\002\063\002\247\001\
\178\004\013\005\248\001\150\000\074\001\184\002\113\003\185\002\
\043\002\179\001\227\000\224\003\071\001\103\000\197\001\252\004\
\027\002\154\002\249\004\116\004\118\004\159\002\060\004\120\004\
\164\002\103\000\185\000\104\000\188\004\002\004\202\001\064\003\
\023\005\027\002\164\002\069\003\105\000\020\004\244\004\104\000\
\085\001\106\005\064\000\182\001\085\001\006\004\085\001\080\002\
\105\000\106\000\042\003\185\000\062\001\128\000\250\001\172\001\
\007\002\134\000\107\000\134\000\113\000\106\000\117\004\119\004\
\107\001\166\001\032\005\002\002\061\004\119\005\107\000\029\002\
\113\000\185\000\000\002\001\002\189\000\071\002\238\002\170\001\
\020\004\004\002\106\001\057\005\189\000\189\000\072\005\067\003\
\211\001\103\003\185\000\221\001\221\001\139\002\138\004\038\002\
\031\002\189\000\065\005\219\003\073\005\044\002\114\003\188\000\
\252\001\253\001\196\000\012\005\077\005\215\002\092\005\039\002\
\027\002\208\000\209\000\210\000\211\000\041\004\164\002\121\004\
\104\005\218\000\146\001\154\002\165\001\003\004\064\000\076\001\
\000\005\184\001\146\001\146\001\065\001\021\004\020\002\185\000\
\129\002\069\001\070\001\189\002\154\002\154\005\205\001\146\001\
\043\003\133\002\075\001\134\002\104\005\078\001\100\004\167\003\
\245\001\185\000\167\000\206\000\246\001\107\001\166\001\079\001\
\065\002\107\001\166\001\247\001\062\004\086\001\248\001\049\005\
\187\000\035\002\125\003\212\002\229\002\213\002\066\002\106\001\
\065\004\067\002\114\001\106\001\190\002\073\002\074\005\208\002\
\047\004\210\005\205\002\193\000\018\004\166\002\051\000\085\002\
\075\002\136\005\092\002\202\002\066\005\245\001\064\000\064\000\
\101\002\246\001\252\003\104\003\105\003\160\005\137\005\073\001\
\247\001\201\004\103\001\248\001\206\001\110\001\094\002\185\000\
\051\000\165\001\192\003\187\000\160\005\165\001\205\003\110\001\
\124\002\093\002\032\003\178\005\130\002\087\000\235\002\233\004\
\064\000\101\004\080\001\200\000\133\003\173\002\144\002\175\002\
\204\005\176\002\024\003\000\003\208\004\168\003\211\004\087\005\
\027\002\085\001\201\000\153\002\012\005\240\002\048\004\087\000\
\068\002\192\002\094\005\224\004\185\000\140\003\185\000\206\003\
\220\003\085\003\108\000\068\003\109\000\161\001\091\002\024\005\
\084\002\185\000\140\002\141\002\209\002\168\005\145\002\165\005\
\132\001\195\004\019\004\156\002\051\000\251\001\202\000\159\001\
\108\001\111\001\180\004\030\002\135\001\126\002\215\003\253\003\
\135\005\159\001\063\002\111\001\109\001\018\004\127\005\103\001\
\179\001\202\004\139\005\110\001\030\002\029\002\110\001\179\001\
\029\002\179\001\002\002\240\002\103\000\143\004\136\003\097\003\
\094\002\092\002\116\005\179\005\181\003\108\001\029\002\080\003\
\203\000\202\001\104\000\204\000\229\003\212\000\144\004\203\002\
\111\005\109\001\085\001\105\000\085\001\200\000\085\001\095\004\
\096\004\136\003\141\003\250\001\107\003\081\005\027\002\134\000\
\106\000\134\000\161\004\134\000\201\000\250\001\032\000\166\005\
\024\003\107\000\161\001\113\000\213\000\160\001\091\002\079\005\
\084\002\250\001\049\004\082\004\216\003\163\002\192\002\160\001\
\082\004\246\002\208\004\024\004\153\005\159\001\058\002\111\001\
\159\001\108\001\111\001\030\002\250\001\250\001\105\001\032\004\
\202\000\002\002\002\002\064\004\203\002\109\001\203\002\038\004\
\182\003\130\003\214\000\162\001\142\003\029\002\122\005\002\002\
\136\003\054\000\207\005\005\002\250\001\038\003\192\002\192\002\
\094\002\092\002\240\002\163\002\016\005\247\001\193\002\172\003\
\064\000\050\005\038\002\200\000\222\002\224\002\226\002\137\003\
\154\003\188\003\203\000\218\001\227\002\204\000\036\002\185\000\
\155\003\156\003\201\000\093\004\107\003\231\003\010\000\136\003\
\162\004\244\003\081\003\187\000\030\002\046\003\226\002\112\001\
\038\002\167\000\206\000\160\001\023\003\157\005\160\001\228\000\
\027\002\082\004\015\003\163\002\217\003\210\003\082\003\119\002\
\091\003\185\000\088\003\089\003\115\004\100\001\202\000\100\001\
\193\002\168\004\226\002\105\001\209\001\185\000\120\002\193\002\
\128\001\129\001\193\002\027\002\048\003\079\002\143\003\005\002\
\162\001\135\003\119\002\126\002\194\002\221\000\123\005\128\005\
\044\005\173\003\041\002\055\003\079\002\108\003\109\003\200\000\
\163\002\120\002\026\003\082\004\191\005\064\000\250\001\071\003\
\203\000\017\000\192\004\204\000\112\001\173\004\201\000\245\003\
\027\003\254\002\113\005\129\005\115\005\043\004\193\004\154\002\
\001\004\048\002\123\003\137\001\226\002\012\002\181\003\156\002\
\097\003\033\000\049\002\248\002\254\003\255\003\000\004\048\004\
\193\002\037\000\188\001\130\005\056\005\249\002\187\004\036\002\
\185\000\025\004\202\000\047\003\119\002\094\004\071\005\179\001\
\119\002\212\005\079\002\079\002\128\001\129\001\084\005\027\002\
\058\003\060\003\227\003\120\002\036\002\185\000\160\003\120\002\
\158\003\079\002\079\002\114\001\079\002\056\003\093\005\243\003\
\134\004\067\005\136\004\139\004\194\003\131\005\085\001\051\000\
\116\001\221\000\054\000\079\002\203\000\178\003\179\003\204\000\
\014\002\203\001\028\003\134\000\228\002\048\002\250\001\048\002\
\250\001\218\000\250\001\250\001\039\005\113\001\049\002\192\002\
\049\002\058\004\148\002\195\003\204\001\252\002\058\005\228\002\
\082\004\148\002\186\001\188\003\185\000\185\000\228\002\048\004\
\203\003\040\004\002\002\054\004\222\000\163\003\202\001\148\002\
\148\002\166\003\050\004\014\005\082\004\204\001\148\002\145\003\
\114\001\156\004\159\003\228\002\228\002\082\004\246\002\250\001\
\226\003\052\003\027\002\219\000\118\001\148\002\221\000\016\005\
\148\002\228\002\131\003\219\002\227\000\130\004\228\002\191\004\
\038\002\228\002\147\003\228\002\148\002\158\000\218\000\197\000\
\245\001\120\001\113\001\198\000\246\001\234\003\226\002\202\001\
\250\001\197\003\232\003\247\001\080\001\192\002\248\001\152\003\
\158\000\148\002\202\001\239\003\202\001\240\003\044\005\158\000\
\250\003\222\000\185\000\156\002\038\002\188\003\249\003\250\001\
\004\004\235\003\236\003\007\004\012\002\228\002\148\002\175\003\
\030\004\148\002\165\004\080\001\158\000\158\000\185\000\033\000\
\219\000\013\002\147\002\012\002\167\000\206\000\123\001\037\000\
\185\000\237\003\158\000\148\002\027\002\099\005\148\002\185\000\
\103\005\158\000\158\000\226\002\158\000\185\000\080\001\081\000\
\216\002\082\004\082\004\159\002\245\001\150\002\184\004\157\001\
\246\001\160\001\080\001\082\004\012\002\156\002\217\002\247\001\
\179\001\212\000\248\001\202\001\233\003\046\004\036\002\185\000\
\154\002\159\005\222\004\238\003\197\004\165\001\067\004\014\002\
\162\001\218\001\002\002\137\001\002\003\003\003\158\000\137\001\
\202\001\056\004\032\000\137\001\189\000\137\001\014\002\154\002\
\213\000\137\001\137\001\250\001\199\004\137\001\250\001\161\002\
\247\001\027\002\131\002\248\001\068\004\171\004\137\001\202\001\
\082\004\166\001\157\002\185\000\152\005\157\001\181\001\056\004\
\209\001\111\004\112\004\013\000\180\001\027\002\076\002\014\002\
\162\005\098\001\099\001\004\003\154\003\250\001\214\000\123\004\
\208\005\209\005\190\000\077\002\182\001\054\000\018\000\033\002\
\218\002\195\001\038\002\163\002\058\003\185\000\137\001\156\002\
\135\004\059\004\088\004\011\004\185\000\137\001\204\001\014\000\
\024\000\025\000\026\000\082\004\236\002\156\002\177\001\226\002\
\111\001\104\001\227\000\226\002\199\001\226\005\015\000\016\000\
\137\001\137\001\030\002\137\001\137\001\172\005\170\004\169\000\
\195\005\196\005\109\001\023\000\042\000\015\003\237\002\195\001\
\044\002\038\002\127\001\183\004\035\002\170\000\137\001\191\001\
\208\001\250\004\151\000\202\001\176\000\112\001\044\002\033\000\
\185\000\015\003\083\001\151\005\147\000\222\004\050\000\037\000\
\156\002\038\002\217\005\173\005\217\000\041\000\245\001\247\001\
\156\002\015\003\246\001\198\001\045\000\196\004\156\002\127\003\
\187\001\247\001\002\002\212\000\248\001\043\005\169\003\221\004\
\225\005\185\000\247\001\203\004\027\002\255\002\128\003\032\000\
\170\003\247\001\247\001\250\001\204\004\209\004\235\005\044\002\
\053\000\129\000\154\002\199\001\032\000\027\002\044\002\159\002\
\216\001\254\004\213\000\072\004\177\001\218\004\247\001\247\001\
\216\001\054\000\232\004\097\003\160\002\235\004\187\001\199\001\
\128\004\228\004\044\002\204\001\247\001\185\000\131\004\177\001\
\132\004\255\004\187\001\247\001\247\001\148\001\247\001\132\001\
\246\004\247\004\147\000\189\000\149\004\198\002\224\002\081\000\
\214\000\251\001\027\002\156\002\234\001\088\004\054\000\054\000\
\007\005\010\005\147\000\161\002\081\000\199\001\054\000\164\003\
\202\001\153\003\038\002\202\001\202\001\017\005\235\001\236\001\
\237\001\081\000\081\000\081\000\081\000\147\000\151\000\097\003\
\247\001\199\001\079\003\151\000\151\000\202\001\029\003\029\005\
\081\000\146\001\152\002\199\002\110\005\189\000\055\005\080\001\
\154\003\185\000\238\001\152\002\045\005\157\003\088\004\176\000\
\176\000\138\005\176\000\176\000\081\000\176\000\027\002\081\000\
\030\003\162\003\081\000\081\000\081\000\157\001\039\003\176\000\
\176\000\157\001\081\000\156\002\196\001\157\001\245\001\157\001\
\147\000\081\000\246\001\157\001\185\000\239\001\182\004\157\001\
\104\004\247\001\204\001\122\003\248\001\081\000\218\004\081\000\
\157\001\081\000\081\000\101\002\203\002\176\000\176\000\240\001\
\241\001\242\001\217\000\040\003\080\005\081\000\234\004\101\002\
\081\000\228\004\238\004\068\005\081\000\207\001\088\005\158\005\
\212\000\089\005\202\001\091\005\245\001\157\001\202\001\163\005\
\246\001\157\001\132\001\243\001\054\000\158\003\053\005\247\001\
\102\005\088\004\248\001\157\001\228\004\185\000\124\005\157\001\
\204\004\032\000\127\001\088\004\144\002\144\002\127\001\213\000\
\202\001\008\005\127\001\144\002\127\001\002\002\234\005\185\000\
\127\001\199\002\157\001\157\001\117\005\157\001\157\001\185\000\
\245\001\144\002\210\001\202\001\246\001\127\001\027\005\144\002\
\218\004\204\001\159\004\247\001\072\003\031\003\200\004\228\002\
\157\001\251\001\142\001\185\000\199\002\214\000\147\000\132\005\
\198\000\133\005\144\002\144\002\054\000\250\001\185\000\116\003\
\118\003\217\000\140\005\202\001\144\005\145\005\073\003\203\005\
\149\005\228\004\111\001\032\000\136\002\155\005\137\002\160\004\
\189\000\143\001\059\005\185\000\127\001\228\004\014\000\216\001\
\138\002\117\003\144\001\202\001\159\002\228\002\254\001\185\000\
\248\001\180\002\164\005\119\003\002\002\015\000\016\000\127\001\
\127\001\087\002\127\001\127\001\202\001\088\004\159\002\227\004\
\002\002\174\005\023\000\248\001\145\001\202\001\241\000\088\002\
\083\005\163\002\248\001\248\001\176\000\127\001\146\001\123\002\
\060\005\202\001\199\001\224\002\123\002\054\000\033\000\075\005\
\159\002\083\001\189\005\169\005\100\005\185\000\037\000\248\001\
\248\001\228\004\224\002\224\002\041\000\186\001\199\001\197\005\
\109\005\202\005\061\005\045\000\148\001\248\001\163\002\224\002\
\164\002\076\005\187\001\170\005\248\001\248\001\255\001\248\001\
\002\002\002\002\132\001\130\000\122\000\009\002\132\001\011\002\
\218\004\121\005\214\005\224\002\083\004\132\001\224\002\053\000\
\132\001\219\005\220\005\224\002\051\000\151\000\185\000\227\000\
\202\001\224\002\019\002\202\001\151\000\164\002\151\000\223\005\
\224\002\202\001\002\002\084\004\151\000\087\000\030\002\032\000\
\186\000\248\001\144\000\083\001\198\001\085\004\051\000\226\002\
\224\002\224\002\179\000\151\000\151\000\202\001\236\005\129\004\
\002\002\176\000\226\002\086\004\224\002\202\001\040\002\087\000\
\202\001\132\001\029\000\045\002\144\000\202\001\002\002\142\004\
\202\001\202\001\086\002\226\002\179\000\114\002\114\002\042\002\
\087\002\047\002\017\004\028\004\046\002\232\002\132\004\233\002\
\194\000\087\002\054\000\176\000\176\000\176\000\088\002\114\002\
\216\001\234\002\245\001\176\000\135\001\159\002\246\001\088\002\
\184\005\066\002\187\005\194\000\067\002\247\001\049\002\138\001\
\248\001\151\000\194\000\151\000\193\005\052\002\150\005\159\002\
\151\000\092\003\176\000\176\000\159\002\251\001\160\000\176\000\
\159\002\176\000\159\002\060\002\159\002\159\002\159\002\194\000\
\194\000\217\000\074\002\184\005\184\005\163\004\054\000\125\004\
\062\002\160\000\213\005\058\002\159\002\194\000\066\001\164\004\
\160\000\081\002\151\000\176\000\194\000\194\000\119\002\194\000\
\054\000\185\000\176\000\221\005\030\002\067\001\068\001\151\000\
\151\000\111\001\224\005\163\002\112\003\160\000\160\000\185\000\
\184\005\148\001\217\000\159\002\229\005\163\002\176\000\032\001\
\132\002\232\005\233\005\160\000\133\001\019\003\033\001\152\002\
\133\001\186\000\160\000\160\000\034\003\160\000\142\002\133\001\
\036\003\194\000\133\001\227\000\020\003\021\003\241\000\241\000\
\241\000\241\000\242\003\133\001\006\003\007\003\241\000\241\000\
\241\000\158\002\182\001\241\000\241\000\164\002\241\000\241\000\
\241\000\241\000\241\000\241\000\120\001\176\000\241\000\241\000\
\241\000\241\000\241\000\241\000\036\002\185\000\080\001\160\000\
\152\001\165\002\241\000\241\000\006\003\009\003\241\000\241\000\
\241\000\241\000\182\002\133\001\183\002\241\000\241\000\067\001\
\153\001\036\002\185\000\159\000\148\001\185\000\080\001\192\000\
\186\002\151\000\187\002\241\000\241\000\188\002\241\000\008\003\
\010\003\241\000\241\000\241\000\195\002\241\000\159\000\196\002\
\241\000\241\000\192\000\197\002\151\000\159\000\147\000\151\000\
\241\000\192\000\241\000\201\002\206\002\207\002\151\000\181\000\
\151\000\151\000\210\002\241\000\241\000\211\002\241\000\241\000\
\241\000\241\000\159\000\159\000\176\000\214\002\192\000\241\000\
\176\000\241\000\181\000\063\002\241\000\242\002\151\000\241\000\
\159\000\181\000\029\000\241\000\192\000\029\000\032\000\159\000\
\159\000\101\002\159\000\192\000\192\000\018\003\192\000\029\000\
\029\000\049\003\051\003\050\003\054\003\062\003\181\000\176\000\
\151\000\061\003\063\003\065\003\029\000\029\000\029\000\029\000\
\076\003\084\003\099\001\101\003\181\000\102\003\005\002\110\003\
\176\000\115\003\029\000\029\000\181\000\111\003\181\000\138\001\
\176\000\124\003\176\000\138\001\159\000\132\003\134\003\138\001\
\192\000\138\001\138\003\149\003\217\000\138\001\138\001\029\000\
\148\001\138\001\029\000\122\001\029\000\029\000\029\000\029\000\
\151\003\150\003\138\001\206\001\161\003\029\000\096\002\097\002\
\098\002\099\002\247\001\213\001\029\000\171\003\176\003\180\003\
\181\000\167\000\100\002\183\003\190\003\191\003\059\001\196\003\
\029\000\230\000\029\000\158\001\029\000\029\000\148\001\006\003\
\207\003\209\003\147\000\218\003\248\003\246\003\010\004\167\002\
\029\000\014\004\138\001\029\000\015\004\167\001\023\004\029\000\
\251\003\138\001\026\004\031\004\174\001\147\000\134\002\217\000\
\035\004\036\004\168\002\151\000\147\000\176\000\176\000\101\002\
\039\004\010\000\151\000\051\004\138\001\138\001\055\004\138\001\
\138\001\199\002\167\000\206\000\066\004\148\001\057\004\103\004\
\217\000\147\000\147\000\098\004\105\004\108\004\109\004\110\004\
\127\004\148\001\138\001\124\004\120\001\156\004\158\004\147\000\
\120\001\148\001\166\004\174\004\120\001\151\000\120\001\147\000\
\151\000\147\000\120\001\120\001\169\004\175\004\176\004\179\004\
\169\002\094\000\151\000\177\004\190\004\170\002\198\004\120\001\
\054\000\096\002\097\002\098\002\099\002\210\004\151\000\212\004\
\095\000\016\000\216\004\217\004\033\003\100\002\037\002\236\004\
\176\000\219\004\220\004\011\005\237\004\096\000\240\004\144\004\
\026\005\077\002\239\004\147\000\040\005\245\004\075\004\087\004\
\002\005\176\000\004\005\151\000\151\000\041\005\028\005\120\001\
\175\000\033\000\063\005\051\005\064\005\078\005\120\001\114\005\
\191\000\037\000\086\005\108\005\176\000\126\005\148\001\097\000\
\216\000\141\005\101\002\142\005\090\005\220\000\045\000\148\005\
\156\005\120\001\120\001\191\000\120\001\120\001\032\000\151\000\
\176\000\032\000\191\000\177\005\217\000\151\000\098\000\151\000\
\180\005\181\005\182\005\032\000\032\000\188\005\192\005\120\001\
\176\000\190\005\099\000\151\000\014\005\100\000\201\005\191\000\
\032\000\032\000\032\000\032\000\001\000\002\000\003\000\004\000\
\005\000\006\000\007\000\200\005\205\005\191\000\032\000\032\000\
\211\005\215\005\218\005\176\000\191\000\191\000\222\005\191\000\
\090\001\227\005\156\001\228\005\075\004\230\005\051\000\087\000\
\159\002\008\000\224\002\032\000\051\000\228\002\032\000\034\002\
\148\001\095\002\032\000\032\000\126\000\234\002\163\002\199\001\
\164\002\032\000\235\002\213\001\151\000\097\001\098\001\099\001\
\032\000\216\000\046\002\213\001\151\000\148\002\148\002\076\001\
\213\001\191\000\150\002\149\002\032\000\149\002\032\000\205\004\
\032\000\032\000\151\000\220\001\151\000\213\001\151\000\213\001\
\213\001\101\001\102\001\199\001\032\000\151\002\154\002\032\000\
\176\000\151\000\087\004\032\000\213\001\155\002\104\001\105\001\
\106\001\107\001\156\002\175\000\175\000\217\001\175\000\175\000\
\152\002\175\000\155\002\134\002\176\000\151\000\168\001\109\001\
\213\001\151\000\181\004\175\000\175\000\070\005\213\001\213\001\
\213\001\229\004\134\002\134\002\226\004\150\002\213\001\167\005\
\147\005\125\005\174\002\107\004\201\003\213\001\137\000\134\002\
\138\000\139\000\032\000\087\004\140\000\086\003\172\002\177\001\
\142\000\175\000\175\000\146\002\228\002\213\001\216\000\151\000\
\151\000\087\003\113\004\134\002\053\003\165\003\134\002\224\001\
\230\004\213\001\155\001\134\002\213\001\012\004\216\005\047\005\
\185\004\134\002\145\000\107\005\204\002\151\000\000\000\168\000\
\134\002\146\000\052\005\205\004\178\000\148\003\000\000\000\000\
\194\000\077\002\000\000\000\000\077\002\147\000\148\000\000\000\
\134\002\134\002\000\000\075\004\151\000\000\000\077\002\000\000\
\000\000\194\000\077\002\000\000\134\002\176\000\000\000\125\002\
\151\000\000\000\000\000\077\002\077\002\077\002\077\002\151\000\
\000\000\151\000\000\000\000\000\000\000\194\000\087\004\000\000\
\075\004\151\000\077\002\176\000\000\000\000\000\000\000\000\000\
\087\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\176\000\216\000\077\002\000\000\
\000\000\077\002\000\000\125\002\077\002\077\002\077\002\151\000\
\194\000\000\000\194\000\194\000\077\002\000\000\199\001\000\000\
\000\000\084\002\000\000\077\002\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\151\000\000\000\000\000\000\000\077\002\
\000\000\077\002\156\001\077\002\077\002\000\000\156\001\151\000\
\000\000\176\000\156\001\000\000\156\001\000\000\070\003\077\002\
\156\001\224\002\077\002\075\003\156\001\151\000\077\002\151\000\
\175\000\000\000\000\000\000\000\000\000\156\001\000\000\000\000\
\151\000\000\000\000\000\000\000\224\002\217\001\000\000\003\001\
\000\000\000\000\000\000\224\002\075\004\151\000\000\000\000\000\
\000\000\000\000\087\004\000\000\000\000\000\000\075\004\178\000\
\214\001\000\000\178\000\178\000\000\000\178\000\093\003\000\000\
\224\002\224\002\000\000\000\000\000\000\176\000\000\000\178\000\
\178\000\000\000\000\000\000\000\156\001\171\002\224\002\000\000\
\000\000\194\000\000\000\000\000\000\000\000\000\224\002\000\000\
\224\002\000\000\000\000\000\000\000\000\000\000\000\000\156\001\
\156\001\129\003\156\001\156\001\000\000\178\000\214\001\000\000\
\000\000\000\000\000\000\075\004\000\000\151\000\205\004\194\000\
\000\000\000\000\000\000\000\000\000\000\156\001\000\000\000\000\
\000\000\199\001\000\000\000\000\000\000\175\000\000\000\151\000\
\000\000\151\000\224\002\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\151\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\168\000\
\000\000\000\000\168\000\000\000\000\000\000\000\075\004\175\000\
\175\000\175\000\151\000\151\000\168\000\000\000\000\000\175\000\
\000\000\151\000\190\000\000\000\000\000\151\000\217\001\000\000\
\000\000\168\000\168\000\168\000\168\000\000\000\175\000\000\000\
\000\000\224\002\151\000\194\000\193\003\190\000\175\000\175\000\
\168\000\151\000\000\000\175\000\190\000\175\000\000\000\151\000\
\000\000\000\000\000\000\151\000\000\000\216\000\000\000\194\000\
\151\000\151\000\217\001\000\000\168\000\000\000\217\001\000\000\
\000\000\190\000\000\000\168\000\168\000\000\000\000\000\175\000\
\123\001\000\000\168\000\000\000\000\000\000\000\175\000\190\000\
\010\000\168\000\176\001\000\000\000\000\000\000\190\000\190\000\
\000\000\190\000\000\000\000\000\222\003\000\000\216\000\168\000\
\000\000\168\000\175\000\000\000\000\000\000\000\000\000\228\003\
\000\000\230\003\000\000\000\000\178\000\168\000\000\000\000\000\
\168\000\220\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\194\000\194\000\000\000\000\000\194\000\000\000\
\194\000\000\000\137\000\190\000\138\000\139\000\032\000\000\000\
\140\000\000\000\000\000\177\001\142\000\000\000\013\004\003\001\
\000\000\175\000\003\001\000\000\000\000\000\000\000\000\003\001\
\000\000\003\001\000\000\000\000\003\001\003\001\000\000\003\001\
\003\001\003\001\003\001\003\001\003\001\033\004\145\000\003\001\
\003\001\003\001\037\004\003\001\003\001\146\000\000\000\000\000\
\000\000\126\003\000\000\000\000\003\001\000\000\000\000\003\001\
\003\001\147\000\148\000\000\000\000\000\000\000\003\001\003\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\213\001\000\000\000\000\003\001\000\000\000\000\003\001\
\000\000\178\000\000\000\003\001\003\001\000\000\003\001\000\000\
\000\000\003\001\003\001\000\000\000\000\000\000\000\000\000\000\
\175\000\003\001\092\004\217\001\175\000\000\000\000\000\097\004\
\000\000\000\000\000\000\000\000\003\001\003\001\000\000\003\001\
\003\001\003\001\003\001\178\000\178\000\178\000\000\000\000\000\
\003\001\000\000\003\001\178\000\000\000\003\001\000\000\000\000\
\003\001\000\000\000\000\175\000\003\001\000\000\000\000\000\000\
\000\000\000\000\250\002\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\214\001\178\000\175\000\000\000\141\004\214\001\
\000\000\178\000\000\000\000\000\175\000\000\000\175\000\000\000\
\000\000\224\002\224\002\000\000\000\000\000\000\000\000\000\000\
\216\000\000\000\000\000\000\000\000\000\000\000\224\002\000\000\
\000\000\000\000\077\002\178\000\000\000\224\002\000\000\000\000\
\000\000\000\000\178\000\224\002\224\002\224\002\224\002\000\000\
\000\000\000\000\000\000\000\000\000\000\221\003\000\000\186\004\
\123\001\000\000\224\002\000\000\123\001\189\004\178\000\000\000\
\123\001\224\002\123\001\000\000\000\000\000\000\123\001\000\000\
\000\000\000\000\123\001\000\000\000\000\194\000\224\002\224\002\
\000\000\224\002\000\000\123\001\000\000\000\000\224\002\224\002\
\000\000\224\002\000\000\216\000\224\002\000\000\000\000\000\000\
\000\000\175\000\175\000\224\002\000\000\000\000\000\000\179\000\
\000\000\000\000\000\000\195\000\000\000\214\001\000\000\224\002\
\000\000\000\000\000\000\224\002\216\000\000\000\000\000\027\004\
\000\000\000\000\231\004\123\001\195\000\000\000\000\000\224\002\
\000\000\000\000\123\001\224\002\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\195\000\000\000\000\000\000\000\000\000\123\001\123\001\000\000\
\123\001\123\001\199\001\000\000\251\004\000\000\253\004\000\000\
\001\005\000\000\000\000\006\005\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\123\001\175\000\000\000\000\000\000\000\
\000\000\000\000\015\005\195\000\000\000\195\000\195\000\000\000\
\000\000\213\001\000\000\199\001\178\000\175\000\000\000\000\000\
\178\000\000\000\000\000\030\005\031\005\000\000\213\001\000\000\
\069\004\036\005\138\000\139\000\032\000\000\000\140\000\000\000\
\175\000\070\004\071\004\213\001\000\000\213\001\213\001\000\000\
\000\000\000\000\000\000\226\002\000\000\000\000\000\000\214\001\
\072\004\000\000\213\001\073\004\175\000\054\005\000\000\000\000\
\216\000\178\001\000\000\074\004\145\000\000\000\000\000\000\000\
\178\000\000\000\000\000\146\000\175\000\000\000\213\001\000\000\
\178\000\000\000\214\001\000\000\213\001\213\001\213\001\147\000\
\148\000\000\000\179\000\215\001\213\001\179\000\179\000\000\000\
\179\000\000\000\000\000\213\001\181\000\000\000\000\000\175\000\
\000\000\000\000\179\000\179\000\000\000\207\000\000\000\000\000\
\000\000\000\000\000\000\213\001\195\000\000\000\217\001\000\000\
\000\000\000\000\077\002\000\000\000\000\077\002\000\000\213\001\
\000\000\105\005\213\001\000\000\000\000\000\000\000\000\077\002\
\179\000\215\001\000\000\077\002\217\001\000\000\000\000\112\005\
\126\002\000\000\195\000\000\000\077\002\077\002\077\002\077\002\
\138\002\000\000\000\000\000\000\000\000\118\005\000\000\000\000\
\120\005\000\000\000\000\077\002\000\000\178\000\214\001\000\000\
\000\000\000\000\000\000\057\003\175\000\000\000\199\001\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\077\002\
\000\000\000\000\077\002\000\000\126\002\077\002\077\002\077\002\
\175\000\156\001\000\000\000\000\143\005\077\002\000\000\000\000\
\000\000\000\000\000\000\000\000\077\002\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\242\001\
\077\002\000\000\077\002\000\000\077\002\077\002\195\000\199\001\
\000\000\000\000\000\000\137\000\000\000\138\000\139\000\032\000\
\077\002\140\000\151\001\077\002\141\000\142\000\000\000\077\002\
\178\000\000\000\195\000\176\005\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\143\000\181\000\
\181\000\214\001\181\000\181\000\000\000\181\000\144\000\144\003\
\000\000\000\000\000\000\000\000\000\000\000\000\146\000\181\000\
\181\000\000\000\000\000\000\000\178\000\000\000\198\005\199\005\
\000\000\005\004\147\000\148\000\180\000\000\000\206\005\057\003\
\000\000\175\000\000\000\000\000\000\000\000\000\000\000\179\000\
\178\000\000\000\000\000\000\000\000\000\181\000\181\000\014\000\
\000\000\000\000\199\001\226\002\000\000\195\000\195\000\175\000\
\178\000\195\000\000\000\195\000\199\001\000\000\015\000\016\000\
\226\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\175\000\000\000\000\000\023\000\000\000\226\002\000\000\226\002\
\226\002\231\005\000\000\214\001\000\000\000\000\000\000\137\000\
\000\000\138\000\139\000\032\000\226\002\140\000\000\000\033\000\
\141\000\142\000\083\001\000\000\241\001\000\000\000\000\037\000\
\178\001\000\000\000\000\000\000\000\000\041\000\000\000\178\001\
\226\002\178\001\143\000\226\002\045\000\175\000\000\000\226\002\
\226\002\000\000\144\000\145\000\000\000\000\000\226\002\000\000\
\000\000\000\000\146\000\000\000\049\000\226\002\000\000\000\000\
\000\000\000\000\000\000\000\000\179\000\000\000\147\000\148\000\
\053\000\226\002\000\000\000\000\000\000\226\002\226\002\000\000\
\214\001\000\000\000\000\000\000\000\000\000\000\199\001\194\000\
\199\001\226\002\000\000\000\000\226\002\138\002\000\000\000\000\
\000\000\000\000\000\000\000\000\214\001\000\000\179\000\179\000\
\179\000\175\000\000\000\102\002\138\002\138\002\179\000\180\000\
\180\000\000\000\180\000\180\000\000\000\180\000\000\000\000\000\
\175\000\138\002\000\000\000\000\000\000\000\000\000\000\180\000\
\180\000\000\000\000\000\107\000\128\002\215\001\179\000\000\000\
\000\000\000\000\215\001\000\000\179\000\138\002\010\000\242\001\
\138\002\000\000\242\001\000\000\000\000\138\002\000\000\000\000\
\000\000\000\000\000\000\138\002\242\001\180\000\180\000\000\000\
\000\000\000\000\138\002\000\000\000\000\000\000\179\000\000\000\
\000\000\242\001\242\001\242\001\242\001\179\000\000\000\000\000\
\175\000\000\000\138\002\138\002\000\000\000\000\000\000\000\000\
\242\001\000\000\000\000\000\000\000\000\000\000\138\002\000\000\
\137\000\179\000\138\000\139\000\032\000\178\000\140\000\000\000\
\000\000\177\001\142\000\000\000\242\001\000\000\000\000\242\001\
\195\000\151\001\242\001\242\001\242\001\000\000\000\000\000\000\
\000\000\000\000\242\001\214\001\000\000\090\001\000\000\000\000\
\000\000\242\001\194\000\000\000\145\000\000\000\000\000\000\000\
\000\000\181\000\000\000\146\000\214\001\242\001\000\000\242\001\
\215\001\242\001\242\001\000\000\000\000\000\000\000\000\147\000\
\148\000\096\001\097\001\098\001\099\001\242\001\000\000\000\000\
\242\001\000\000\151\001\000\000\242\001\000\000\000\000\000\000\
\000\000\000\000\220\002\181\000\181\000\181\000\200\002\000\000\
\000\000\185\000\000\000\181\000\000\000\059\003\101\001\102\001\
\000\000\214\001\000\000\000\000\241\001\000\000\000\000\241\001\
\000\000\000\000\000\000\104\001\105\001\106\001\107\001\178\001\
\224\002\241\001\181\000\181\000\000\000\000\000\000\000\181\000\
\000\000\181\000\000\000\000\000\109\001\000\000\241\001\241\001\
\241\001\241\001\000\000\000\000\180\000\102\002\000\000\179\000\
\000\000\000\000\000\000\179\000\000\000\241\001\000\000\000\000\
\000\000\000\000\000\000\181\000\000\000\137\000\000\000\138\000\
\139\000\032\000\128\002\140\000\000\000\214\001\141\000\142\000\
\000\000\241\001\000\000\000\000\241\001\000\000\000\000\241\001\
\241\001\241\001\215\001\000\000\161\005\000\000\181\000\241\001\
\143\000\000\000\000\000\239\001\000\000\000\000\241\001\000\000\
\144\000\145\000\000\000\179\000\000\000\000\000\000\000\000\000\
\146\000\000\000\241\001\179\000\241\001\215\001\241\001\241\001\
\000\000\161\002\000\000\107\000\147\000\148\000\000\000\000\000\
\000\000\000\000\241\001\000\000\000\000\241\001\151\001\000\000\
\107\000\241\001\000\000\000\000\000\000\181\000\000\000\000\000\
\000\000\000\000\000\000\000\000\194\005\107\000\000\000\107\000\
\107\000\180\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\107\000\000\000\000\000\000\000\
\000\000\000\000\000\000\161\002\000\000\161\002\161\002\161\002\
\092\000\161\002\000\000\000\000\161\002\161\002\000\000\000\000\
\107\000\000\000\000\000\180\000\180\000\180\000\000\000\107\000\
\107\000\000\000\000\000\180\000\180\000\000\000\107\000\000\000\
\179\000\215\001\000\000\000\000\000\000\107\000\000\000\161\002\
\000\000\000\000\000\000\174\003\000\000\000\000\161\002\000\000\
\000\000\151\001\180\000\180\000\181\000\107\000\000\000\180\000\
\181\000\180\000\161\002\161\002\000\000\000\000\000\000\000\000\
\000\000\107\000\000\000\000\000\107\000\000\000\000\000\000\000\
\178\001\000\000\000\000\000\000\000\000\044\004\000\000\000\000\
\231\000\231\000\000\000\180\000\000\000\000\000\000\000\181\000\
\000\000\000\000\180\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\137\000\000\000\138\000\139\000\032\000\
\181\000\140\000\000\000\179\000\141\000\142\000\180\000\000\000\
\181\000\000\000\181\000\000\000\000\000\000\000\000\000\000\000\
\224\002\000\000\000\000\224\002\215\001\000\000\143\000\000\000\
\000\000\000\000\000\000\000\000\000\000\224\002\144\000\145\000\
\000\000\138\001\139\001\000\000\000\000\000\000\146\000\179\000\
\000\000\000\000\224\002\000\000\224\002\224\002\000\000\000\000\
\000\000\000\000\147\000\148\000\000\000\180\000\000\000\000\000\
\000\000\224\002\000\000\179\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\151\001\000\000\000\000\
\000\000\000\000\000\000\179\000\253\001\224\002\000\000\000\000\
\000\000\000\000\000\000\239\001\000\000\224\002\239\001\000\000\
\000\000\000\000\000\000\224\002\000\000\181\000\181\000\000\000\
\239\001\151\001\224\002\000\000\000\000\000\000\215\001\000\000\
\000\000\000\000\000\000\151\001\000\000\239\001\239\001\239\001\
\239\001\000\000\224\002\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\239\001\000\000\224\002\000\000\
\000\000\224\002\000\000\102\002\180\000\194\004\000\000\000\000\
\180\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\239\001\000\000\000\000\239\001\000\000\000\000\239\001\239\001\
\239\001\000\000\151\001\000\000\000\000\178\001\239\001\010\000\
\092\000\176\001\000\000\000\000\000\000\239\001\151\001\180\000\
\181\000\000\000\000\000\215\001\000\000\092\000\151\001\000\000\
\000\000\239\001\195\000\239\001\000\000\239\001\239\001\000\000\
\180\000\181\000\092\000\000\000\092\000\092\000\000\000\215\001\
\180\000\239\001\180\000\000\000\239\001\000\000\000\000\000\000\
\239\001\092\000\000\000\000\000\181\000\000\000\000\000\000\000\
\000\000\137\000\000\000\138\000\139\000\032\000\151\001\140\000\
\000\000\000\000\141\000\142\000\000\000\092\000\000\000\000\000\
\181\000\000\000\000\000\081\004\000\000\092\000\000\000\000\000\
\000\000\000\000\000\000\092\000\143\000\000\000\000\000\000\000\
\181\000\000\000\092\000\000\000\144\000\145\000\006\001\000\000\
\000\000\000\000\000\000\151\001\146\000\000\000\151\001\151\001\
\000\000\000\000\092\000\000\000\000\000\000\000\000\000\000\000\
\147\000\148\000\000\000\181\000\000\000\000\000\092\000\000\000\
\000\000\092\000\000\000\000\000\000\000\180\000\180\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\179\000\103\002\104\002\105\002\106\002\107\002\108\002\109\002\
\110\002\111\002\112\002\113\002\114\002\115\002\116\002\117\002\
\118\002\119\002\120\002\121\002\122\002\123\002\215\001\125\002\
\000\000\000\000\000\000\000\000\000\000\195\000\000\000\000\000\
\000\000\081\004\000\000\000\000\000\000\135\002\000\000\215\001\
\000\000\000\000\000\000\000\000\253\001\151\001\253\001\253\001\
\181\000\148\002\000\000\000\000\253\001\000\000\000\000\000\000\
\000\000\253\001\000\000\000\000\000\000\253\001\253\001\253\001\
\180\000\000\000\000\000\000\000\181\000\000\000\253\001\253\001\
\253\001\253\001\000\000\000\000\207\004\000\000\000\000\000\000\
\253\001\180\000\000\000\000\000\215\001\253\001\000\000\000\000\
\000\000\000\000\000\000\253\001\253\001\000\000\000\000\000\000\
\000\000\013\001\000\000\000\000\180\000\000\000\000\000\000\000\
\000\000\253\001\000\000\000\000\253\001\000\000\000\000\253\001\
\253\001\253\001\000\000\253\001\000\000\000\000\000\000\253\001\
\180\000\000\000\000\000\000\000\000\000\000\000\253\001\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\180\000\253\001\253\001\000\000\253\001\253\001\253\001\253\001\
\215\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\253\001\000\000\000\000\253\001\000\000\000\000\
\000\000\253\001\000\000\180\000\000\000\181\000\000\000\000\000\
\000\000\000\000\137\000\000\000\138\000\139\000\032\000\151\001\
\140\000\000\000\000\000\141\000\142\000\000\000\000\000\000\000\
\207\004\000\000\000\000\181\000\000\000\037\005\038\005\000\000\
\000\000\000\000\000\000\000\000\000\000\143\000\000\000\000\000\
\081\004\000\000\000\000\025\003\181\000\144\000\145\000\000\000\
\000\000\000\000\000\000\000\000\035\003\146\000\006\001\000\000\
\037\003\006\001\000\000\041\003\000\000\000\000\006\001\000\000\
\006\001\147\000\148\000\006\001\006\001\081\004\000\000\006\001\
\180\000\006\001\006\001\006\001\000\000\000\000\006\001\006\001\
\006\001\079\002\006\001\006\001\000\000\000\000\000\000\000\000\
\000\000\181\000\000\000\006\001\180\000\151\001\006\001\006\001\
\000\000\000\000\000\000\000\000\000\000\006\001\006\001\000\000\
\000\000\000\000\000\000\000\000\231\000\231\000\000\000\000\000\
\000\000\000\000\000\000\006\001\000\000\000\000\006\001\000\000\
\000\000\000\000\006\001\006\001\000\000\006\001\000\000\000\000\
\006\001\006\001\000\000\000\000\000\000\000\000\000\000\000\000\
\006\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\106\003\006\001\006\001\181\000\006\001\006\001\
\006\001\006\001\000\000\000\000\000\000\000\000\000\000\006\001\
\000\000\006\001\207\004\000\000\006\001\000\000\000\000\006\001\
\000\000\081\004\000\000\006\001\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\081\004\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\137\000\180\000\138\000\139\000\
\032\000\013\001\140\000\000\000\013\001\141\000\142\000\000\000\
\000\000\013\001\000\000\013\001\000\000\114\002\013\001\013\001\
\000\000\000\000\013\001\180\000\013\001\013\001\013\001\143\000\
\000\000\013\001\013\001\013\001\000\000\013\001\013\001\144\000\
\144\003\000\000\000\000\000\000\180\000\000\000\013\001\146\000\
\081\004\013\001\013\001\207\004\000\000\000\000\000\000\000\000\
\013\001\013\001\177\003\147\000\148\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\013\001\000\000\
\000\000\013\001\000\000\000\000\000\000\013\001\013\001\000\000\
\013\001\000\000\000\000\013\001\013\001\000\000\000\000\000\000\
\000\000\180\000\000\000\013\001\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\081\004\208\003\000\000\013\001\013\001\
\000\000\013\001\013\001\013\001\013\001\000\000\000\000\000\000\
\000\000\000\000\013\001\000\000\013\001\000\000\000\000\013\001\
\000\000\000\000\013\001\000\000\000\000\000\000\013\001\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\223\003\000\000\000\000\000\000\000\000\000\000\000\000\224\000\
\000\000\000\000\000\000\000\000\000\000\180\000\000\000\000\000\
\000\000\079\002\079\002\079\002\079\002\000\000\000\000\079\002\
\079\002\079\002\079\002\079\002\079\002\079\002\079\002\079\002\
\079\002\079\002\079\002\079\002\079\002\079\002\079\002\079\002\
\000\000\079\002\079\002\079\002\079\002\079\002\079\002\079\002\
\079\002\000\000\000\000\000\000\000\000\079\002\079\002\000\000\
\022\004\079\002\079\002\079\002\079\002\079\002\079\002\079\002\
\079\002\079\002\079\002\079\002\079\002\079\002\000\000\079\002\
\079\002\079\002\079\002\000\000\000\000\079\002\079\002\079\002\
\058\002\079\002\079\002\079\002\079\002\079\002\079\002\000\000\
\079\002\079\002\079\002\079\002\079\002\000\000\079\002\079\002\
\000\000\000\000\000\000\079\002\079\002\079\002\079\002\079\002\
\079\002\079\002\079\002\000\000\079\002\000\000\079\002\079\002\
\000\000\079\002\079\002\079\002\079\002\079\002\000\000\079\002\
\079\002\000\000\079\002\079\002\079\002\079\002\029\001\079\002\
\079\002\000\000\079\002\000\000\000\000\000\000\079\002\000\000\
\000\000\000\000\000\000\000\000\000\000\114\002\114\002\114\002\
\114\002\114\002\000\000\114\002\114\002\114\002\114\002\114\002\
\114\002\114\002\114\002\114\002\114\002\114\002\114\002\114\002\
\114\002\114\002\114\002\000\000\122\004\114\002\114\002\114\002\
\114\002\114\002\114\002\114\002\114\002\000\000\000\000\000\000\
\000\000\114\002\114\002\000\000\000\000\114\002\114\002\114\002\
\114\002\114\002\114\002\114\002\114\002\114\002\114\002\114\002\
\114\002\114\002\000\000\114\002\114\002\114\002\114\002\000\000\
\000\000\114\002\114\002\114\002\000\000\114\002\114\002\114\002\
\114\002\114\002\114\002\000\000\114\002\114\002\114\002\114\002\
\114\002\000\000\114\002\114\002\000\000\000\000\000\000\114\002\
\114\002\114\002\114\002\114\002\114\002\114\002\114\002\000\000\
\114\002\000\000\114\002\114\002\000\000\114\002\114\002\114\002\
\114\002\114\002\000\000\114\002\114\002\060\001\114\002\114\002\
\114\002\114\002\000\000\114\002\114\002\000\000\114\002\000\000\
\000\000\000\000\114\002\000\000\000\000\000\000\000\000\224\000\
\224\000\224\000\224\000\000\000\000\000\000\000\000\000\224\000\
\224\000\224\000\000\000\000\000\224\000\224\000\224\000\224\000\
\224\000\224\000\224\000\224\000\224\000\000\000\000\000\224\000\
\224\000\224\000\224\000\224\000\224\000\000\000\000\000\000\000\
\000\000\000\000\000\000\224\000\224\000\000\000\000\000\224\000\
\224\000\224\000\224\000\224\000\224\000\224\000\224\000\224\000\
\000\000\000\000\000\000\000\000\241\004\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\224\000\224\000\000\000\224\000\
\248\004\000\000\224\000\224\000\224\000\000\000\224\000\224\000\
\224\000\224\000\224\000\000\000\000\000\000\000\000\000\000\000\
\000\000\224\000\000\000\224\000\224\000\224\000\224\000\224\000\
\000\000\000\000\000\000\000\000\224\000\224\000\000\000\224\000\
\224\000\224\000\224\000\036\001\000\000\224\000\000\000\000\000\
\224\000\000\000\224\000\000\000\000\000\224\000\000\000\000\000\
\224\000\033\005\034\005\035\005\224\000\000\000\029\001\029\001\
\029\001\029\001\000\000\000\000\029\001\029\001\029\001\029\001\
\029\001\029\001\029\001\029\001\029\001\029\001\029\001\029\001\
\029\001\029\001\029\001\029\001\029\001\000\000\029\001\029\001\
\029\001\029\001\029\001\029\001\029\001\029\001\000\000\000\000\
\000\000\000\000\029\001\029\001\000\000\000\000\029\001\029\001\
\029\001\029\001\029\001\029\001\029\001\029\001\029\001\029\001\
\029\001\029\001\029\001\000\000\029\001\029\001\029\001\029\001\
\000\000\000\000\029\001\029\001\029\001\000\000\029\001\029\001\
\029\001\029\001\029\001\029\001\000\000\029\001\029\001\029\001\
\029\001\029\001\000\000\029\001\029\001\000\000\000\000\000\000\
\029\001\029\001\029\001\029\001\029\001\029\001\029\001\029\001\
\000\000\029\001\000\000\029\001\029\001\000\000\029\001\029\001\
\029\001\029\001\029\001\034\001\029\001\029\001\000\000\029\001\
\029\001\029\001\029\001\000\000\029\001\029\001\000\000\029\001\
\000\000\000\000\000\000\029\001\000\000\060\001\060\001\060\001\
\060\001\060\001\000\000\060\001\060\001\060\001\060\001\060\001\
\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\
\060\001\060\001\060\001\000\000\000\000\060\001\060\001\060\001\
\060\001\060\001\060\001\060\001\060\001\000\000\000\000\000\000\
\000\000\060\001\060\001\000\000\000\000\060\001\060\001\060\001\
\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\
\060\001\060\001\000\000\060\001\060\001\060\001\060\001\000\000\
\000\000\060\001\060\001\060\001\000\000\060\001\060\001\060\001\
\060\001\060\001\060\001\000\000\060\001\060\001\060\001\060\001\
\060\001\000\000\060\001\060\001\000\000\000\000\000\000\060\001\
\060\001\060\001\060\001\060\001\060\001\060\001\060\001\000\000\
\060\001\000\000\060\001\060\001\000\000\060\001\060\001\060\001\
\060\001\060\001\032\001\060\001\060\001\000\000\060\001\060\001\
\060\001\060\001\000\000\060\001\060\001\000\000\060\001\000\000\
\000\000\000\000\060\001\036\001\036\001\036\001\036\001\000\000\
\000\000\036\001\036\001\036\001\036\001\036\001\036\001\036\001\
\036\001\036\001\036\001\036\001\036\001\036\001\036\001\036\001\
\036\001\036\001\000\000\036\001\036\001\036\001\036\001\036\001\
\036\001\036\001\036\001\000\000\000\000\000\000\000\000\036\001\
\036\001\000\000\000\000\036\001\036\001\036\001\036\001\036\001\
\036\001\036\001\036\001\036\001\036\001\036\001\036\001\036\001\
\000\000\036\001\036\001\036\001\036\001\000\000\000\000\036\001\
\036\001\036\001\000\000\036\001\036\001\036\001\036\001\036\001\
\036\001\000\000\036\001\036\001\036\001\036\001\036\001\000\000\
\036\001\036\001\000\000\000\000\000\000\036\001\036\001\036\001\
\036\001\036\001\036\001\036\001\036\001\000\000\036\001\000\000\
\036\001\036\001\000\000\036\001\036\001\036\001\036\001\036\001\
\069\001\036\001\036\001\000\000\036\001\036\001\036\001\036\001\
\000\000\036\001\036\001\000\000\036\001\000\000\000\000\000\000\
\036\001\000\000\000\000\034\001\034\001\034\001\034\001\000\000\
\000\000\034\001\034\001\034\001\034\001\034\001\034\001\034\001\
\034\001\034\001\034\001\034\001\034\001\034\001\034\001\034\001\
\034\001\034\001\000\000\034\001\034\001\034\001\034\001\034\001\
\034\001\034\001\034\001\000\000\000\000\000\000\000\000\034\001\
\034\001\000\000\000\000\034\001\034\001\034\001\034\001\034\001\
\034\001\034\001\034\001\034\001\034\001\034\001\034\001\034\001\
\000\000\034\001\034\001\034\001\034\001\000\000\000\000\034\001\
\034\001\034\001\000\000\034\001\034\001\034\001\034\001\034\001\
\034\001\000\000\034\001\034\001\034\001\034\001\034\001\000\000\
\034\001\034\001\000\000\000\000\000\000\034\001\034\001\034\001\
\034\001\034\001\034\001\034\001\034\001\000\000\034\001\000\000\
\034\001\034\001\000\000\034\001\034\001\034\001\034\001\034\001\
\071\001\034\001\034\001\000\000\034\001\034\001\034\001\034\001\
\000\000\034\001\034\001\000\000\034\001\000\000\000\000\000\000\
\034\001\000\000\032\001\032\001\032\001\032\001\000\000\000\000\
\032\001\032\001\032\001\032\001\032\001\032\001\032\001\032\001\
\032\001\032\001\032\001\032\001\032\001\032\001\032\001\032\001\
\032\001\000\000\032\001\032\001\032\001\032\001\032\001\032\001\
\032\001\032\001\000\000\000\000\000\000\000\000\032\001\032\001\
\000\000\000\000\032\001\032\001\032\001\032\001\032\001\032\001\
\032\001\032\001\032\001\032\001\032\001\032\001\032\001\000\000\
\032\001\032\001\032\001\032\001\000\000\000\000\032\001\032\001\
\032\001\000\000\032\001\032\001\032\001\032\001\032\001\032\001\
\000\000\032\001\032\001\032\001\032\001\032\001\000\000\032\001\
\032\001\000\000\000\000\000\000\032\001\032\001\032\001\032\001\
\032\001\032\001\032\001\032\001\000\000\032\001\000\000\032\001\
\032\001\000\000\032\001\032\001\032\001\032\001\032\001\074\001\
\032\001\032\001\000\000\032\001\032\001\032\001\032\001\000\000\
\032\001\032\001\000\000\032\001\000\000\000\000\000\000\032\001\
\069\001\069\001\069\001\069\001\069\001\000\000\069\001\069\001\
\069\001\069\001\069\001\069\001\069\001\069\001\069\001\069\001\
\069\001\069\001\069\001\069\001\069\001\069\001\000\000\000\000\
\069\001\069\001\069\001\069\001\069\001\069\001\069\001\069\001\
\000\000\000\000\000\000\000\000\069\001\069\001\000\000\000\000\
\069\001\069\001\069\001\069\001\069\001\069\001\069\001\069\001\
\069\001\069\001\069\001\069\001\069\001\000\000\069\001\069\001\
\069\001\069\001\000\000\000\000\069\001\069\001\069\001\000\000\
\069\001\069\001\069\001\069\001\069\001\069\001\000\000\069\001\
\069\001\069\001\069\001\069\001\000\000\069\001\069\001\000\000\
\000\000\000\000\069\001\069\001\069\001\069\001\069\001\069\001\
\069\001\069\001\000\000\069\001\000\000\069\001\069\001\000\000\
\069\001\069\001\069\001\000\000\000\000\021\001\069\001\069\001\
\000\000\069\001\069\001\069\001\069\001\000\000\069\001\069\001\
\000\000\069\001\000\000\000\000\000\000\069\001\000\000\000\000\
\071\001\071\001\071\001\071\001\071\001\000\000\071\001\071\001\
\071\001\071\001\071\001\071\001\071\001\071\001\071\001\071\001\
\071\001\071\001\071\001\071\001\071\001\071\001\000\000\000\000\
\071\001\071\001\071\001\071\001\071\001\071\001\071\001\071\001\
\000\000\000\000\000\000\000\000\071\001\071\001\000\000\000\000\
\071\001\071\001\071\001\071\001\071\001\071\001\071\001\071\001\
\071\001\071\001\071\001\071\001\071\001\000\000\071\001\071\001\
\071\001\071\001\000\000\000\000\071\001\071\001\071\001\000\000\
\071\001\071\001\071\001\071\001\071\001\071\001\000\000\071\001\
\071\001\071\001\071\001\071\001\000\000\071\001\071\001\000\000\
\000\000\000\000\071\001\071\001\071\001\071\001\071\001\071\001\
\071\001\071\001\000\000\071\001\000\000\071\001\071\001\000\000\
\071\001\071\001\071\001\022\001\000\000\000\000\071\001\071\001\
\000\000\071\001\071\001\071\001\071\001\000\000\071\001\071\001\
\000\000\071\001\000\000\000\000\000\000\071\001\000\000\074\001\
\074\001\074\001\074\001\074\001\000\000\074\001\074\001\074\001\
\074\001\074\001\074\001\074\001\074\001\074\001\074\001\074\001\
\074\001\074\001\074\001\074\001\074\001\000\000\000\000\074\001\
\074\001\074\001\074\001\074\001\074\001\074\001\074\001\000\000\
\000\000\000\000\000\000\074\001\074\001\000\000\000\000\074\001\
\074\001\074\001\074\001\074\001\074\001\074\001\074\001\074\001\
\074\001\074\001\074\001\074\001\000\000\074\001\074\001\074\001\
\074\001\000\000\000\000\074\001\074\001\074\001\000\000\074\001\
\074\001\074\001\074\001\074\001\074\001\000\000\074\001\074\001\
\074\001\074\001\074\001\000\000\074\001\074\001\000\000\000\000\
\000\000\074\001\074\001\074\001\074\001\074\001\074\001\074\001\
\074\001\000\000\074\001\000\000\074\001\074\001\000\000\074\001\
\074\001\074\001\223\000\000\000\000\000\074\001\074\001\000\000\
\074\001\074\001\074\001\074\001\000\000\074\001\074\001\000\000\
\074\001\000\000\000\000\000\000\074\001\021\001\021\001\021\001\
\021\001\000\000\000\000\000\000\000\000\021\001\021\001\021\001\
\000\000\000\000\021\001\021\001\021\001\021\001\021\001\021\001\
\021\001\021\001\021\001\021\001\000\000\021\001\021\001\021\001\
\021\001\021\001\021\001\000\000\000\000\000\000\000\000\000\000\
\000\000\021\001\021\001\000\000\000\000\021\001\021\001\021\001\
\021\001\021\001\021\001\021\001\021\001\021\001\000\000\000\000\
\000\000\021\001\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\021\001\021\001\000\000\021\001\000\000\000\000\
\021\001\021\001\021\001\000\000\021\001\021\001\021\001\021\001\
\021\001\000\000\000\000\000\000\000\000\000\000\000\000\021\001\
\021\001\021\001\021\001\021\001\021\001\021\001\000\000\000\000\
\021\001\000\000\021\001\021\001\000\000\021\001\021\001\021\001\
\021\001\021\001\234\000\021\001\000\000\000\000\021\001\021\001\
\021\001\000\000\000\000\021\001\000\000\000\000\021\001\000\000\
\000\000\000\000\021\001\022\001\022\001\022\001\022\001\000\000\
\000\000\000\000\000\000\022\001\022\001\022\001\000\000\000\000\
\022\001\022\001\022\001\022\001\022\001\022\001\022\001\022\001\
\022\001\022\001\000\000\022\001\022\001\022\001\022\001\022\001\
\022\001\000\000\000\000\000\000\000\000\000\000\000\000\022\001\
\022\001\000\000\000\000\022\001\022\001\022\001\022\001\022\001\
\022\001\022\001\022\001\022\001\000\000\000\000\000\000\022\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\022\001\022\001\000\000\022\001\000\000\000\000\022\001\022\001\
\022\001\000\000\022\001\022\001\022\001\022\001\022\001\000\000\
\000\000\000\000\000\000\000\000\000\000\022\001\022\001\022\001\
\022\001\022\001\022\001\022\001\000\000\000\000\022\001\000\000\
\022\001\022\001\000\000\022\001\022\001\022\001\022\001\022\001\
\235\000\022\001\000\000\000\000\022\001\022\001\022\001\000\000\
\000\000\022\001\000\000\000\000\022\001\000\000\000\000\000\000\
\022\001\000\000\223\000\223\000\223\000\223\000\000\000\000\000\
\000\000\000\000\223\000\223\000\223\000\000\000\000\000\223\000\
\223\000\223\000\223\000\223\000\223\000\223\000\223\000\223\000\
\000\000\000\000\223\000\223\000\223\000\223\000\223\000\223\000\
\000\000\000\000\000\000\000\000\000\000\000\000\223\000\223\000\
\000\000\000\000\223\000\223\000\223\000\223\000\223\000\223\000\
\223\000\223\000\223\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\223\000\
\223\000\000\000\223\000\000\000\000\000\223\000\223\000\223\000\
\000\000\223\000\223\000\223\000\223\000\223\000\000\000\000\000\
\000\000\000\000\000\000\000\000\223\000\000\000\223\000\223\000\
\223\000\223\000\223\000\000\000\000\000\000\000\000\000\223\000\
\223\000\000\000\223\000\223\000\223\000\000\000\236\000\000\000\
\223\000\000\000\000\000\223\000\000\000\223\000\000\000\000\000\
\223\000\000\000\000\000\223\000\000\000\000\000\000\000\223\000\
\000\000\000\000\234\000\234\000\234\000\234\000\000\000\000\000\
\000\000\000\000\234\000\234\000\234\000\000\000\000\000\234\000\
\234\000\234\000\234\000\234\000\000\000\234\000\234\000\234\000\
\000\000\000\000\234\000\234\000\234\000\234\000\234\000\234\000\
\000\000\000\000\000\000\000\000\000\000\000\000\234\000\234\000\
\000\000\000\000\234\000\234\000\234\000\234\000\234\000\234\000\
\234\000\234\000\234\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\234\000\
\234\000\000\000\234\000\000\000\000\000\234\000\234\000\234\000\
\000\000\234\000\234\000\234\000\234\000\234\000\000\000\000\000\
\000\000\000\000\000\000\000\000\234\000\000\000\234\000\234\000\
\234\000\234\000\234\000\000\000\000\000\000\000\000\000\234\000\
\234\000\000\000\234\000\234\000\234\000\234\000\014\001\000\000\
\234\000\000\000\000\000\234\000\000\000\234\000\000\000\000\000\
\234\000\000\000\000\000\234\000\000\000\000\000\000\000\234\000\
\235\000\235\000\235\000\235\000\000\000\000\000\000\000\000\000\
\235\000\235\000\235\000\000\000\000\000\235\000\235\000\235\000\
\235\000\235\000\235\000\235\000\235\000\235\000\000\000\000\000\
\235\000\235\000\235\000\235\000\235\000\235\000\000\000\000\000\
\000\000\000\000\000\000\000\000\235\000\235\000\000\000\000\000\
\235\000\235\000\235\000\235\000\235\000\235\000\235\000\235\000\
\235\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\235\000\235\000\000\000\
\235\000\000\000\000\000\235\000\235\000\235\000\000\000\235\000\
\235\000\235\000\235\000\235\000\000\000\000\000\000\000\000\000\
\000\000\000\000\235\000\000\000\235\000\235\000\235\000\235\000\
\235\000\000\000\000\000\000\000\000\000\235\000\235\000\000\000\
\235\000\235\000\235\000\000\000\015\001\000\000\235\000\000\000\
\000\000\235\000\000\000\235\000\000\000\000\000\235\000\000\000\
\000\000\235\000\000\000\000\000\000\000\235\000\236\000\236\000\
\236\000\236\000\000\000\000\000\000\000\000\000\236\000\236\000\
\236\000\000\000\000\000\236\000\236\000\236\000\236\000\236\000\
\236\000\236\000\236\000\236\000\000\000\000\000\236\000\236\000\
\236\000\236\000\236\000\236\000\000\000\000\000\000\000\000\000\
\000\000\000\000\236\000\236\000\000\000\000\000\236\000\236\000\
\236\000\236\000\236\000\236\000\236\000\236\000\236\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\236\000\236\000\000\000\236\000\000\000\
\000\000\236\000\236\000\236\000\000\000\236\000\236\000\236\000\
\236\000\236\000\000\000\000\000\000\000\000\000\000\000\000\000\
\236\000\000\000\236\000\236\000\236\000\236\000\236\000\000\000\
\000\000\000\000\000\000\236\000\236\000\000\000\236\000\236\000\
\236\000\000\000\246\000\000\000\236\000\000\000\000\000\236\000\
\000\000\236\000\000\000\000\000\236\000\000\000\000\000\236\000\
\000\000\000\000\000\000\236\000\000\000\000\000\014\001\014\001\
\014\001\014\001\000\000\000\000\000\000\000\000\014\001\014\001\
\014\001\000\000\000\000\014\001\014\001\014\001\014\001\014\001\
\014\001\014\001\014\001\014\001\000\000\000\000\014\001\014\001\
\014\001\014\001\014\001\014\001\000\000\000\000\000\000\000\000\
\000\000\000\000\014\001\014\001\000\000\000\000\014\001\014\001\
\014\001\014\001\014\001\014\001\014\001\014\001\014\001\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\014\001\014\001\000\000\014\001\000\000\
\000\000\014\001\014\001\014\001\000\000\014\001\014\001\014\001\
\014\001\014\001\000\000\000\000\000\000\000\000\000\000\000\000\
\014\001\000\000\014\001\014\001\014\001\014\001\014\001\000\000\
\000\000\000\000\000\000\014\001\014\001\000\000\014\001\014\001\
\014\001\247\000\000\000\000\000\014\001\000\000\000\000\014\001\
\000\000\014\001\000\000\000\000\014\001\000\000\000\000\014\001\
\000\000\000\000\000\000\014\001\015\001\015\001\015\001\015\001\
\000\000\000\000\000\000\000\000\015\001\015\001\015\001\000\000\
\000\000\015\001\015\001\015\001\015\001\015\001\015\001\015\001\
\015\001\015\001\000\000\000\000\015\001\015\001\015\001\015\001\
\015\001\015\001\000\000\000\000\000\000\000\000\000\000\000\000\
\015\001\015\001\000\000\000\000\015\001\015\001\015\001\015\001\
\015\001\015\001\015\001\015\001\015\001\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\015\001\015\001\000\000\015\001\000\000\000\000\015\001\
\015\001\015\001\000\000\015\001\015\001\015\001\015\001\015\001\
\000\000\000\000\000\000\000\000\000\000\000\000\015\001\000\000\
\015\001\015\001\015\001\015\001\015\001\000\000\000\000\000\000\
\000\000\015\001\015\001\000\000\015\001\015\001\015\001\254\000\
\000\000\000\000\015\001\000\000\000\000\015\001\000\000\015\001\
\000\000\000\000\015\001\000\000\000\000\015\001\000\000\000\000\
\000\000\015\001\246\000\246\000\246\000\246\000\000\000\000\000\
\000\000\000\000\246\000\246\000\246\000\000\000\000\000\246\000\
\246\000\246\000\246\000\246\000\246\000\246\000\246\000\246\000\
\000\000\000\000\246\000\246\000\246\000\246\000\246\000\246\000\
\000\000\000\000\000\000\000\000\000\000\000\000\246\000\246\000\
\000\000\000\000\246\000\246\000\246\000\246\000\246\000\246\000\
\000\000\246\000\246\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\246\000\
\246\000\000\000\246\000\000\000\000\000\246\000\246\000\246\000\
\000\000\246\000\246\000\246\000\246\000\246\000\000\000\000\000\
\000\000\000\000\000\000\000\000\246\000\000\000\246\000\246\000\
\246\000\246\000\246\000\000\000\000\000\000\000\000\000\246\000\
\246\000\000\000\246\000\246\000\246\000\246\000\253\000\000\000\
\246\000\000\000\000\000\246\000\000\000\246\000\000\000\000\000\
\246\000\000\000\000\000\246\000\000\000\000\000\000\000\246\000\
\000\000\247\000\247\000\247\000\247\000\000\000\000\000\000\000\
\000\000\247\000\247\000\247\000\000\000\000\000\247\000\247\000\
\247\000\247\000\247\000\247\000\247\000\247\000\247\000\000\000\
\000\000\247\000\247\000\247\000\247\000\247\000\247\000\000\000\
\000\000\000\000\000\000\000\000\000\000\247\000\247\000\000\000\
\000\000\247\000\247\000\247\000\247\000\247\000\247\000\000\000\
\247\000\247\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\247\000\247\000\
\000\000\247\000\000\000\000\000\247\000\247\000\247\000\000\000\
\247\000\247\000\247\000\247\000\247\000\000\000\000\000\000\000\
\000\000\000\000\000\000\247\000\000\000\247\000\247\000\247\000\
\247\000\247\000\000\000\000\000\000\000\000\000\247\000\247\000\
\000\000\247\000\247\000\247\000\247\000\228\000\000\000\247\000\
\000\000\000\000\247\000\000\000\247\000\000\000\000\000\247\000\
\000\000\000\000\247\000\000\000\000\000\000\000\247\000\254\000\
\254\000\254\000\254\000\000\000\000\000\000\000\000\000\254\000\
\254\000\254\000\000\000\000\000\254\000\254\000\254\000\254\000\
\254\000\254\000\254\000\254\000\254\000\000\000\000\000\254\000\
\254\000\254\000\254\000\254\000\254\000\000\000\000\000\000\000\
\000\000\000\000\000\000\254\000\254\000\000\000\000\000\254\000\
\254\000\254\000\254\000\254\000\254\000\000\000\254\000\254\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\254\000\254\000\000\000\254\000\
\000\000\000\000\254\000\254\000\254\000\000\000\254\000\254\000\
\254\000\254\000\254\000\000\000\000\000\000\000\000\000\000\000\
\000\000\254\000\000\000\254\000\254\000\254\000\254\000\254\000\
\000\000\000\000\000\000\000\000\254\000\254\000\000\000\254\000\
\254\000\254\000\254\000\231\000\000\000\254\000\000\000\000\000\
\254\000\000\000\254\000\000\000\000\000\254\000\000\000\000\000\
\254\000\000\000\000\000\000\000\254\000\000\000\253\000\253\000\
\253\000\253\000\000\000\000\000\000\000\000\000\253\000\253\000\
\253\000\000\000\000\000\253\000\253\000\253\000\253\000\253\000\
\253\000\253\000\253\000\253\000\000\000\000\000\253\000\253\000\
\253\000\253\000\253\000\253\000\000\000\000\000\000\000\000\000\
\000\000\000\000\253\000\253\000\000\000\000\000\253\000\253\000\
\253\000\253\000\253\000\253\000\000\000\253\000\253\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\253\000\253\000\000\000\253\000\000\000\
\000\000\253\000\253\000\253\000\000\000\253\000\253\000\253\000\
\253\000\253\000\000\000\000\000\000\000\000\000\000\000\000\000\
\253\000\000\000\253\000\253\000\253\000\253\000\253\000\000\000\
\000\000\000\000\000\000\253\000\253\000\000\000\253\000\253\000\
\253\000\253\000\232\000\000\000\253\000\000\000\000\000\253\000\
\000\000\253\000\000\000\000\000\253\000\000\000\000\000\253\000\
\000\000\000\000\000\000\253\000\000\000\228\000\228\000\228\000\
\228\000\000\000\000\000\000\000\000\000\000\000\228\000\228\000\
\000\000\000\000\228\000\228\000\228\000\228\000\228\000\228\000\
\228\000\228\000\228\000\000\000\000\000\228\000\228\000\228\000\
\228\000\228\000\228\000\000\000\000\000\000\000\000\000\000\000\
\000\000\228\000\228\000\000\000\000\000\228\000\228\000\228\000\
\228\000\228\000\228\000\228\000\228\000\228\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\228\000\228\000\000\000\228\000\000\000\000\000\
\228\000\228\000\228\000\000\000\228\000\228\000\228\000\228\000\
\228\000\000\000\000\000\000\000\000\000\000\000\000\000\228\000\
\000\000\228\000\228\000\228\000\228\000\228\000\000\000\000\000\
\000\000\000\000\228\000\228\000\000\000\228\000\228\000\228\000\
\228\000\245\000\000\000\228\000\000\000\000\000\228\000\000\000\
\228\000\000\000\000\000\228\000\000\000\000\000\228\000\000\000\
\000\000\000\000\228\000\231\000\231\000\231\000\231\000\000\000\
\000\000\000\000\000\000\000\000\231\000\231\000\000\000\000\000\
\231\000\231\000\231\000\231\000\231\000\231\000\231\000\231\000\
\231\000\000\000\000\000\231\000\231\000\231\000\231\000\231\000\
\231\000\000\000\000\000\000\000\000\000\000\000\000\000\231\000\
\231\000\000\000\000\000\231\000\231\000\231\000\231\000\231\000\
\231\000\231\000\231\000\231\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\231\000\231\000\000\000\231\000\000\000\000\000\231\000\231\000\
\231\000\000\000\231\000\231\000\231\000\231\000\231\000\000\000\
\000\000\000\000\000\000\000\000\000\000\231\000\000\000\231\000\
\231\000\231\000\231\000\231\000\000\000\000\000\000\000\000\000\
\231\000\231\000\000\000\231\000\231\000\231\000\231\000\251\000\
\000\000\231\000\000\000\000\000\231\000\000\000\231\000\000\000\
\000\000\231\000\000\000\000\000\231\000\000\000\000\000\000\000\
\231\000\000\000\232\000\232\000\232\000\232\000\000\000\000\000\
\000\000\000\000\000\000\232\000\232\000\000\000\000\000\232\000\
\232\000\232\000\232\000\232\000\232\000\232\000\232\000\232\000\
\000\000\000\000\232\000\232\000\232\000\232\000\232\000\232\000\
\000\000\000\000\000\000\000\000\000\000\000\000\232\000\232\000\
\000\000\000\000\232\000\232\000\232\000\232\000\232\000\232\000\
\232\000\232\000\232\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\232\000\
\232\000\000\000\232\000\000\000\000\000\232\000\232\000\232\000\
\000\000\232\000\232\000\232\000\232\000\232\000\000\000\000\000\
\000\000\000\000\000\000\000\000\232\000\000\000\232\000\232\000\
\232\000\232\000\232\000\000\000\000\000\000\000\000\000\232\000\
\232\000\000\000\232\000\232\000\232\000\232\000\252\000\000\000\
\232\000\000\000\000\000\232\000\000\000\232\000\000\000\000\000\
\232\000\000\000\000\000\232\000\000\000\000\000\000\000\232\000\
\000\000\245\000\245\000\245\000\245\000\000\000\000\000\000\000\
\000\000\245\000\245\000\245\000\000\000\000\000\245\000\245\000\
\245\000\245\000\245\000\245\000\245\000\245\000\245\000\000\000\
\000\000\245\000\245\000\245\000\245\000\245\000\245\000\000\000\
\000\000\000\000\000\000\000\000\000\000\245\000\245\000\000\000\
\000\000\245\000\245\000\245\000\245\000\245\000\000\000\000\000\
\245\000\245\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\245\000\245\000\
\000\000\245\000\000\000\000\000\245\000\245\000\245\000\000\000\
\245\000\245\000\245\000\245\000\245\000\000\000\000\000\000\000\
\000\000\000\000\000\000\245\000\000\000\245\000\000\000\245\000\
\245\000\245\000\000\000\000\000\000\000\000\000\245\000\245\000\
\000\000\245\000\245\000\245\000\245\000\248\000\000\000\000\000\
\000\000\000\000\245\000\000\000\245\000\000\000\000\000\245\000\
\000\000\000\000\245\000\000\000\000\000\000\000\245\000\251\000\
\251\000\251\000\251\000\000\000\000\000\000\000\000\000\251\000\
\251\000\251\000\000\000\000\000\251\000\251\000\251\000\251\000\
\251\000\251\000\251\000\251\000\251\000\000\000\000\000\251\000\
\251\000\251\000\251\000\251\000\251\000\000\000\000\000\000\000\
\000\000\000\000\000\000\251\000\251\000\000\000\000\000\251\000\
\251\000\251\000\251\000\251\000\000\000\000\000\251\000\251\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\251\000\251\000\000\000\251\000\
\000\000\000\000\251\000\251\000\251\000\000\000\251\000\251\000\
\251\000\251\000\251\000\000\000\000\000\000\000\000\000\000\000\
\000\000\251\000\000\000\251\000\000\000\251\000\251\000\251\000\
\000\000\000\000\000\000\000\000\251\000\251\000\000\000\251\000\
\251\000\251\000\251\000\249\000\000\000\000\000\000\000\000\000\
\251\000\000\000\251\000\000\000\000\000\251\000\000\000\000\000\
\251\000\000\000\000\000\000\000\251\000\000\000\252\000\252\000\
\252\000\252\000\000\000\000\000\000\000\000\000\252\000\252\000\
\252\000\000\000\000\000\252\000\252\000\252\000\252\000\252\000\
\252\000\252\000\252\000\252\000\000\000\000\000\252\000\252\000\
\252\000\252\000\252\000\252\000\000\000\000\000\000\000\000\000\
\000\000\000\000\252\000\252\000\000\000\000\000\252\000\252\000\
\252\000\252\000\252\000\000\000\000\000\252\000\252\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\252\000\252\000\000\000\252\000\000\000\
\000\000\252\000\252\000\252\000\000\000\252\000\252\000\252\000\
\252\000\252\000\000\000\000\000\000\000\000\000\000\000\000\000\
\252\000\000\000\252\000\000\000\252\000\252\000\252\000\000\000\
\000\000\000\000\000\000\252\000\252\000\000\000\252\000\252\000\
\252\000\252\000\250\000\000\000\000\000\000\000\000\000\252\000\
\000\000\252\000\000\000\000\000\252\000\000\000\000\000\252\000\
\000\000\000\000\000\000\252\000\000\000\248\000\248\000\248\000\
\248\000\000\000\000\000\000\000\000\000\248\000\248\000\248\000\
\000\000\000\000\248\000\248\000\248\000\248\000\248\000\248\000\
\248\000\248\000\248\000\000\000\000\000\248\000\248\000\248\000\
\248\000\248\000\248\000\000\000\000\000\000\000\000\000\000\000\
\000\000\248\000\248\000\000\000\000\000\248\000\248\000\248\000\
\248\000\248\000\000\000\000\000\248\000\248\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\248\000\248\000\000\000\248\000\000\000\000\000\
\248\000\248\000\248\000\000\000\248\000\248\000\248\000\248\000\
\248\000\000\000\000\000\000\000\000\000\000\000\000\000\248\000\
\000\000\248\000\000\000\248\000\248\000\248\000\000\000\000\000\
\000\000\000\000\248\000\248\000\000\000\248\000\248\000\248\000\
\248\000\204\000\000\000\000\000\000\000\000\000\248\000\000\000\
\248\000\000\000\000\000\248\000\000\000\000\000\248\000\000\000\
\000\000\000\000\248\000\249\000\249\000\249\000\249\000\000\000\
\000\000\000\000\000\000\249\000\249\000\249\000\000\000\000\000\
\249\000\249\000\249\000\249\000\249\000\249\000\249\000\249\000\
\249\000\000\000\000\000\249\000\249\000\249\000\249\000\249\000\
\249\000\000\000\000\000\000\000\000\000\000\000\000\000\249\000\
\249\000\000\000\000\000\249\000\249\000\249\000\249\000\249\000\
\000\000\000\000\249\000\249\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\249\000\249\000\000\000\249\000\000\000\000\000\249\000\249\000\
\249\000\000\000\249\000\249\000\249\000\249\000\249\000\000\000\
\000\000\000\000\000\000\000\000\000\000\249\000\000\000\249\000\
\000\000\249\000\249\000\249\000\000\000\000\000\000\000\000\000\
\249\000\249\000\000\000\249\000\249\000\249\000\249\000\255\000\
\000\000\000\000\000\000\000\000\249\000\000\000\249\000\000\000\
\000\000\249\000\000\000\000\000\249\000\000\000\000\000\000\000\
\249\000\000\000\250\000\250\000\250\000\250\000\000\000\000\000\
\000\000\000\000\250\000\250\000\250\000\000\000\000\000\250\000\
\250\000\250\000\250\000\250\000\250\000\250\000\250\000\250\000\
\000\000\000\000\250\000\250\000\250\000\250\000\250\000\250\000\
\000\000\000\000\000\000\000\000\000\000\000\000\250\000\250\000\
\000\000\000\000\250\000\250\000\250\000\250\000\250\000\000\000\
\000\000\250\000\250\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\250\000\
\250\000\000\000\250\000\000\000\000\000\250\000\250\000\250\000\
\000\000\250\000\250\000\250\000\250\000\250\000\000\000\000\000\
\000\000\000\000\000\000\000\000\250\000\000\000\250\000\000\000\
\250\000\250\000\250\000\000\000\000\000\000\000\000\000\250\000\
\250\000\000\000\250\000\250\000\250\000\250\000\001\001\000\000\
\000\000\000\000\000\000\250\000\000\000\250\000\000\000\000\000\
\250\000\000\000\000\000\250\000\000\000\000\000\000\000\250\000\
\000\000\204\000\204\000\204\000\204\000\000\000\000\000\000\000\
\000\000\204\000\204\000\204\000\000\000\000\000\204\000\204\000\
\204\000\204\000\204\000\204\000\204\000\204\000\204\000\000\000\
\000\000\204\000\204\000\204\000\204\000\204\000\204\000\000\000\
\000\000\000\000\000\000\000\000\000\000\204\000\204\000\000\000\
\000\000\204\000\204\000\204\000\204\000\204\000\204\000\204\000\
\204\000\204\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\204\000\204\000\
\000\000\000\000\000\000\000\000\204\000\204\000\204\000\000\000\
\204\000\000\000\000\000\204\000\204\000\000\000\000\000\000\000\
\000\000\000\000\000\000\204\000\000\000\204\000\204\000\000\000\
\000\000\204\000\000\000\000\000\000\000\000\000\204\000\204\000\
\000\000\204\000\204\000\204\000\204\000\243\000\000\000\204\000\
\000\000\000\000\204\000\000\000\204\000\000\000\000\000\204\000\
\000\000\000\000\204\000\000\000\000\000\000\000\204\000\255\000\
\255\000\255\000\255\000\000\000\000\000\000\000\000\000\255\000\
\255\000\255\000\000\000\000\000\255\000\255\000\000\000\255\000\
\255\000\255\000\255\000\255\000\255\000\000\000\000\000\255\000\
\255\000\255\000\255\000\255\000\255\000\000\000\000\000\000\000\
\000\000\000\000\000\000\255\000\255\000\000\000\000\000\255\000\
\255\000\255\000\000\000\000\000\000\000\000\000\255\000\255\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\255\000\255\000\000\000\255\000\
\000\000\000\000\000\000\255\000\255\000\000\000\255\000\000\000\
\000\000\255\000\255\000\000\000\000\000\000\000\000\000\000\000\
\000\000\255\000\000\000\255\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\255\000\255\000\000\000\255\000\
\255\000\255\000\255\000\244\000\000\000\000\000\000\000\000\000\
\255\000\000\000\255\000\000\000\000\000\255\000\000\000\000\000\
\255\000\000\000\000\000\000\000\255\000\000\000\001\001\001\001\
\001\001\001\001\000\000\000\000\000\000\000\000\001\001\001\001\
\001\001\000\000\000\000\001\001\001\001\000\000\001\001\001\001\
\001\001\001\001\001\001\001\001\000\000\000\000\001\001\001\001\
\001\001\001\001\001\001\001\001\000\000\000\000\000\000\000\000\
\000\000\000\000\001\001\001\001\000\000\000\000\001\001\001\001\
\001\001\000\000\000\000\000\000\000\000\001\001\001\001\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\001\001\001\001\000\000\001\001\000\000\
\000\000\000\000\001\001\001\001\000\000\001\001\000\000\000\000\
\001\001\001\001\000\000\000\000\000\000\000\000\000\000\000\000\
\001\001\000\000\001\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\001\001\001\001\000\000\001\001\001\001\
\001\001\001\001\000\001\000\000\000\000\000\000\000\000\001\001\
\000\000\001\001\000\000\000\000\001\001\000\000\000\000\001\001\
\000\000\000\000\000\000\001\001\000\000\243\000\243\000\243\000\
\243\000\000\000\000\000\000\000\000\000\243\000\243\000\243\000\
\000\000\000\000\243\000\243\000\000\000\243\000\243\000\243\000\
\243\000\243\000\243\000\000\000\000\000\243\000\243\000\243\000\
\243\000\243\000\243\000\000\000\000\000\000\000\000\000\000\000\
\000\000\243\000\243\000\000\000\000\000\243\000\243\000\243\000\
\000\000\000\000\000\000\000\000\243\000\243\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\243\000\243\000\000\000\243\000\000\000\000\000\
\000\000\243\000\243\000\000\000\243\000\000\000\000\000\243\000\
\243\000\000\000\000\000\000\000\000\000\000\000\000\000\243\000\
\000\000\243\000\000\000\000\000\005\001\000\000\000\000\000\000\
\000\000\000\000\243\000\243\000\000\000\243\000\243\000\243\000\
\243\000\000\000\000\000\000\000\000\000\000\000\243\000\000\000\
\243\000\000\000\000\000\243\000\000\000\000\000\243\000\000\000\
\000\000\000\000\243\000\244\000\244\000\244\000\244\000\000\000\
\000\000\000\000\000\000\244\000\244\000\244\000\000\000\000\000\
\244\000\244\000\000\000\244\000\244\000\244\000\244\000\244\000\
\244\000\000\000\000\000\244\000\244\000\244\000\244\000\244\000\
\244\000\000\000\000\000\000\000\000\000\000\000\000\000\244\000\
\244\000\000\000\000\000\244\000\244\000\244\000\000\000\000\000\
\000\000\000\000\244\000\244\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\244\000\244\000\000\000\244\000\000\000\000\000\000\000\244\000\
\244\000\000\000\244\000\000\000\000\000\244\000\244\000\000\000\
\000\000\000\000\000\000\004\001\000\000\244\000\000\000\244\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\244\000\244\000\000\000\244\000\244\000\244\000\244\000\000\000\
\000\000\000\000\000\000\000\000\244\000\000\000\244\000\000\000\
\000\000\244\000\000\000\000\000\244\000\000\000\000\000\000\000\
\244\000\000\000\000\001\000\001\000\001\000\001\000\000\000\000\
\000\000\000\000\000\001\000\001\000\001\000\000\000\000\000\001\
\000\001\000\000\000\001\000\001\000\001\000\001\000\001\000\001\
\000\000\000\000\000\001\000\001\000\001\000\001\000\001\000\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\001\
\000\000\000\000\000\001\000\001\000\001\000\000\000\000\000\000\
\000\000\000\001\000\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\
\000\001\000\000\000\001\000\000\000\000\100\001\000\001\000\001\
\000\000\000\001\000\000\000\000\000\001\000\001\000\000\000\000\
\000\000\000\000\000\000\000\000\000\001\000\000\000\001\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\
\000\001\000\000\000\001\000\001\000\001\000\001\000\000\000\000\
\000\000\000\000\000\000\000\001\005\001\000\001\000\000\005\001\
\000\001\000\000\000\000\000\001\005\001\005\001\005\001\000\001\
\000\000\005\001\005\001\000\000\005\001\005\001\005\001\005\001\
\005\001\005\001\000\000\000\000\005\001\005\001\005\001\000\000\
\005\001\005\001\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\005\001\000\000\000\000\005\001\005\001\000\000\000\000\
\000\000\000\000\000\000\005\001\005\001\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\005\001\000\000\000\000\005\001\000\000\000\000\002\001\
\005\001\005\001\000\000\005\001\000\000\000\000\005\001\005\001\
\000\000\000\000\000\000\000\000\000\000\000\000\005\001\000\000\
\005\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\005\001\005\001\000\000\005\001\005\001\005\001\005\001\
\000\000\000\000\000\000\000\000\000\000\005\001\000\000\005\001\
\000\000\000\000\005\001\004\001\000\000\005\001\004\001\000\000\
\000\000\005\001\000\000\004\001\004\001\004\001\000\000\000\000\
\004\001\004\001\000\000\004\001\004\001\004\001\004\001\004\001\
\004\001\000\000\000\000\004\001\004\001\004\001\000\000\004\001\
\004\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\004\001\000\000\000\000\004\001\004\001\000\000\000\000\000\000\
\000\000\000\000\004\001\004\001\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\004\001\099\001\000\000\004\001\000\000\000\000\000\000\004\001\
\004\001\000\000\004\001\000\000\000\000\004\001\004\001\000\000\
\000\000\000\000\000\000\000\000\000\000\004\001\000\000\004\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\004\001\004\001\000\000\004\001\004\001\004\001\004\001\000\000\
\000\000\000\000\000\000\000\000\004\001\100\001\004\001\000\000\
\100\001\004\001\000\000\000\000\004\001\100\001\000\000\100\001\
\004\001\000\000\100\001\100\001\000\000\100\001\100\001\100\001\
\100\001\100\001\100\001\000\000\000\000\100\001\100\001\100\001\
\000\000\100\001\100\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\100\001\000\000\000\000\100\001\100\001\000\000\
\000\000\000\000\000\000\000\000\100\001\100\001\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\009\001\000\000\
\000\000\000\000\100\001\000\000\000\000\100\001\000\000\000\000\
\000\000\100\001\100\001\000\000\100\001\000\000\000\000\100\001\
\100\001\000\000\000\000\000\000\000\000\000\000\000\000\100\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\100\001\100\001\000\000\100\001\100\001\100\001\
\100\001\000\000\000\000\000\000\000\000\000\000\100\001\002\001\
\100\001\000\000\002\001\100\001\000\000\000\000\100\001\002\001\
\000\000\002\001\100\001\000\000\002\001\002\001\000\000\002\001\
\002\001\002\001\002\001\002\001\002\001\000\000\000\000\002\001\
\002\001\002\001\000\000\002\001\002\001\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\002\001\000\000\000\000\002\001\
\002\001\000\000\000\000\000\000\000\000\000\000\002\001\002\001\
\000\000\000\000\000\000\237\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\002\001\000\000\000\000\002\001\
\000\000\000\000\000\000\002\001\002\001\000\000\002\001\000\000\
\000\000\002\001\002\001\000\000\000\000\000\000\000\000\000\000\
\000\000\002\001\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\002\001\002\001\000\000\002\001\
\002\001\002\001\002\001\000\000\000\000\000\000\000\000\000\000\
\002\001\099\001\002\001\000\000\099\001\002\001\000\000\000\000\
\002\001\099\001\000\000\099\001\002\001\000\000\099\001\099\001\
\000\000\099\001\099\001\099\001\099\001\099\001\099\001\000\000\
\000\000\099\001\099\001\099\001\000\000\099\001\099\001\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\099\001\000\000\
\000\000\099\001\099\001\000\000\000\000\000\000\000\000\000\000\
\099\001\099\001\000\000\000\000\000\000\012\001\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\099\001\000\000\
\000\000\099\001\000\000\000\000\000\000\099\001\099\001\000\000\
\099\001\000\000\000\000\099\001\099\001\000\000\000\000\000\000\
\000\000\000\000\000\000\099\001\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\099\001\099\001\
\000\000\099\001\099\001\099\001\099\001\000\000\009\001\000\000\
\000\000\009\001\099\001\000\000\099\001\000\000\009\001\099\001\
\009\001\000\000\099\001\009\001\009\001\000\000\099\001\009\001\
\000\000\009\001\009\001\009\001\000\000\000\000\009\001\009\001\
\009\001\000\000\009\001\009\001\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\009\001\000\000\000\000\009\001\009\001\
\000\000\000\000\000\000\000\000\000\000\009\001\009\001\000\000\
\000\000\000\000\011\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\009\001\000\000\000\000\009\001\000\000\
\000\000\000\000\009\001\009\001\000\000\009\001\000\000\000\000\
\009\001\009\001\000\000\000\000\000\000\000\000\000\000\000\000\
\009\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\009\001\009\001\000\000\009\001\009\001\
\009\001\009\001\000\000\237\000\000\000\000\000\237\000\009\001\
\000\000\009\001\000\000\237\000\009\001\237\000\000\000\009\001\
\237\000\237\000\000\000\009\001\237\000\000\000\237\000\237\000\
\237\000\000\000\000\000\237\000\237\000\237\000\000\000\237\000\
\237\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\237\000\000\000\000\000\237\000\237\000\000\000\000\000\000\000\
\000\000\000\000\237\000\237\000\000\000\000\000\000\000\010\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\237\000\000\000\000\000\237\000\000\000\000\000\000\000\237\000\
\237\000\000\000\237\000\000\000\000\000\237\000\237\000\000\000\
\000\000\000\000\000\000\000\000\000\000\237\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\237\000\237\000\000\000\237\000\237\000\237\000\237\000\000\000\
\000\000\000\000\000\000\000\000\237\000\012\001\237\000\000\000\
\012\001\237\000\000\000\000\000\237\000\012\001\000\000\012\001\
\237\000\000\000\012\001\012\001\000\000\000\000\012\001\000\000\
\012\001\012\001\012\001\000\000\000\000\012\001\012\001\012\001\
\000\000\012\001\012\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\012\001\000\000\000\000\012\001\012\001\000\000\
\000\000\000\000\000\000\000\000\012\001\012\001\000\000\000\000\
\000\000\203\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\012\001\000\000\000\000\012\001\000\000\000\000\
\000\000\012\001\012\001\000\000\012\001\000\000\000\000\012\001\
\012\001\000\000\000\000\000\000\000\000\000\000\000\000\012\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\012\001\012\001\000\000\012\001\012\001\012\001\
\012\001\000\000\011\001\000\000\000\000\011\001\012\001\000\000\
\012\001\000\000\011\001\012\001\011\001\000\000\012\001\011\001\
\011\001\000\000\012\001\011\001\000\000\011\001\011\001\011\001\
\000\000\000\000\011\001\011\001\011\001\000\000\011\001\011\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\011\001\
\000\000\000\000\011\001\011\001\000\000\000\000\000\000\000\000\
\000\000\011\001\011\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\011\001\
\000\000\121\002\011\001\000\000\000\000\000\000\011\001\011\001\
\000\000\011\001\116\000\000\000\011\001\011\001\000\000\000\000\
\000\000\000\000\000\000\000\000\011\001\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\011\001\
\011\001\000\000\011\001\011\001\011\001\011\001\000\000\010\001\
\000\000\000\000\010\001\011\001\000\000\011\001\000\000\010\001\
\011\001\010\001\000\000\011\001\010\001\010\001\000\000\011\001\
\010\001\000\000\010\001\010\001\010\001\000\000\000\000\010\001\
\010\001\010\001\000\000\010\001\010\001\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\010\001\000\000\000\000\010\001\
\010\001\000\000\000\000\000\000\000\000\000\000\010\001\010\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\010\001\000\000\000\000\010\001\
\000\000\000\000\000\000\010\001\010\001\000\000\010\001\000\000\
\000\000\010\001\010\001\000\000\238\000\000\000\000\000\000\000\
\000\000\010\001\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\010\001\010\001\000\000\010\001\
\010\001\010\001\010\001\000\000\000\000\000\000\000\000\000\000\
\010\001\203\000\010\001\000\000\203\000\010\001\000\000\000\000\
\010\001\203\000\000\000\203\000\010\001\000\000\203\000\203\000\
\000\000\000\000\203\000\000\000\203\000\203\000\203\000\000\000\
\000\000\203\000\203\000\203\000\000\000\203\000\203\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\203\000\000\000\
\000\000\203\000\203\000\000\000\000\000\000\000\000\000\000\000\
\203\000\203\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\203\000\000\000\
\000\000\203\000\000\000\000\000\000\000\203\000\203\000\000\000\
\203\000\000\000\000\000\203\000\203\000\000\000\000\000\000\000\
\000\000\000\000\000\000\203\000\044\002\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\203\000\203\000\
\000\000\203\000\000\000\203\000\203\000\000\000\000\000\000\000\
\000\000\000\000\203\000\000\000\203\000\000\000\000\000\203\000\
\000\000\121\002\203\000\121\002\121\002\121\002\203\000\000\000\
\000\000\121\002\116\000\000\000\000\000\000\000\121\002\000\000\
\000\000\000\000\121\002\121\002\121\002\000\000\000\000\116\000\
\000\000\000\000\000\000\121\002\121\002\121\002\121\002\000\000\
\000\000\000\000\000\000\000\000\116\000\121\002\116\000\116\000\
\000\000\000\000\121\002\000\000\000\000\000\000\000\000\000\000\
\121\002\121\002\137\000\116\000\138\000\139\000\032\000\000\000\
\140\000\000\000\000\000\177\001\243\002\000\000\121\002\000\000\
\000\000\121\002\121\002\000\000\121\002\121\002\121\002\116\000\
\121\002\004\002\116\000\121\002\121\002\000\000\116\000\116\000\
\000\000\000\000\000\000\121\002\000\000\116\000\145\000\000\000\
\000\000\000\000\000\000\000\000\116\000\146\000\121\002\121\002\
\000\000\121\002\121\002\121\002\121\002\000\000\000\000\121\002\
\116\000\147\000\148\000\000\000\116\000\116\000\000\000\121\002\
\121\002\000\000\121\002\000\000\238\000\000\000\121\002\238\000\
\116\000\000\000\000\000\116\000\238\000\000\000\238\000\000\000\
\000\000\238\000\238\000\000\000\000\000\238\000\000\000\238\000\
\238\000\238\000\000\000\000\000\238\000\000\000\238\000\000\000\
\238\000\238\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\238\000\000\000\000\000\238\000\238\000\000\000\000\000\
\000\000\000\000\000\000\238\000\238\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\005\002\000\000\
\000\000\238\000\000\000\000\000\238\000\000\000\000\000\000\000\
\238\000\238\000\000\000\238\000\000\000\000\000\238\000\238\000\
\000\000\000\000\000\000\000\000\000\000\000\000\238\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\238\000\238\000\000\000\238\000\238\000\238\000\238\000\
\000\000\000\000\000\000\000\000\000\000\238\000\000\000\238\000\
\000\000\000\000\238\000\000\000\044\002\238\000\044\002\044\002\
\044\002\238\000\000\000\000\000\044\002\000\000\000\000\000\000\
\000\000\044\002\000\000\000\000\000\000\044\002\044\002\044\002\
\000\000\000\000\000\000\000\000\000\000\000\000\044\002\044\002\
\044\002\044\002\000\000\000\000\000\000\000\000\000\000\000\000\
\044\002\000\000\000\000\000\000\000\000\044\002\000\000\000\000\
\000\000\000\000\000\000\044\002\044\002\045\002\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\044\002\000\000\000\000\044\002\000\000\000\000\044\002\
\044\002\044\002\000\000\044\002\000\000\000\000\044\002\044\002\
\000\000\000\000\000\000\000\000\000\000\000\000\044\002\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\044\002\044\002\000\000\044\002\044\002\044\002\044\002\
\000\000\004\002\000\000\004\002\004\002\004\002\000\000\000\000\
\000\000\004\002\044\002\000\000\000\000\044\002\004\002\000\000\
\000\000\044\002\004\002\004\002\004\002\000\000\000\000\000\000\
\000\000\000\000\000\000\004\002\004\002\004\002\004\002\000\000\
\000\000\000\000\000\000\000\000\000\000\004\002\000\000\000\000\
\000\000\000\000\004\002\000\000\000\000\000\000\000\000\000\000\
\004\002\004\002\003\002\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\004\002\000\000\
\000\000\004\002\000\000\000\000\004\002\004\002\004\002\000\000\
\004\002\000\000\000\000\004\002\004\002\000\000\000\000\000\000\
\000\000\000\000\000\000\004\002\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\004\002\004\002\
\000\000\004\002\004\002\004\002\000\000\000\000\005\002\004\002\
\005\002\005\002\005\002\000\000\000\000\000\000\005\002\004\002\
\000\000\000\000\004\002\005\002\000\000\000\000\004\002\005\002\
\005\002\005\002\000\000\000\000\000\000\000\000\000\000\000\000\
\005\002\005\002\005\002\005\002\000\000\000\000\000\000\000\000\
\000\000\000\000\005\002\000\000\000\000\000\000\000\000\005\002\
\000\000\000\000\000\000\000\000\000\000\005\002\005\002\001\002\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\005\002\000\000\000\000\005\002\000\000\
\000\000\005\002\005\002\005\002\000\000\005\002\000\000\000\000\
\005\002\005\002\000\000\000\000\000\000\000\000\000\000\000\000\
\005\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\005\002\005\002\000\000\005\002\005\002\
\005\002\000\000\000\000\000\000\005\002\045\002\000\000\045\002\
\045\002\045\002\000\000\000\000\005\002\045\002\000\000\005\002\
\000\000\000\000\045\002\005\002\000\000\000\000\045\002\045\002\
\045\002\000\000\000\000\000\000\000\000\000\000\000\000\045\002\
\045\002\045\002\045\002\000\000\000\000\000\000\000\000\000\000\
\000\000\045\002\000\000\000\000\000\000\000\000\045\002\000\000\
\000\000\000\000\000\000\000\000\045\002\045\002\002\002\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\045\002\000\000\000\000\045\002\000\000\000\000\
\045\002\045\002\045\002\000\000\045\002\000\000\000\000\045\002\
\045\002\000\000\000\000\000\000\000\000\000\000\000\000\045\002\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\045\002\045\002\000\000\045\002\045\002\045\002\
\045\002\000\000\003\002\000\000\003\002\003\002\003\002\000\000\
\000\000\000\000\003\002\045\002\000\000\000\000\045\002\003\002\
\000\000\000\000\045\002\003\002\003\002\003\002\000\000\000\000\
\000\000\000\000\000\000\000\000\003\002\003\002\003\002\003\002\
\000\000\000\000\000\000\000\000\000\000\000\000\003\002\000\000\
\000\000\000\000\000\000\003\002\000\000\000\000\000\000\000\000\
\000\000\003\002\003\002\000\002\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\002\
\000\000\000\000\003\002\000\000\000\000\003\002\003\002\003\002\
\000\000\003\002\000\000\000\000\000\000\003\002\000\000\000\000\
\000\000\000\000\000\000\000\000\003\002\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\002\
\003\002\000\000\003\002\003\002\003\002\003\002\000\000\001\002\
\000\000\001\002\001\002\001\002\000\000\000\000\193\000\001\002\
\003\002\000\000\000\000\003\002\001\002\000\000\000\000\003\002\
\001\002\001\002\001\002\000\000\000\000\000\000\000\000\000\000\
\000\000\001\002\001\002\001\002\001\002\000\000\000\000\000\000\
\000\000\000\000\000\000\001\002\000\000\000\000\000\000\000\000\
\001\002\000\000\000\000\000\000\000\000\000\000\001\002\001\002\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\082\000\000\000\000\000\000\000\001\002\000\000\000\000\001\002\
\000\000\000\000\001\002\001\002\001\002\000\000\001\002\000\000\
\000\000\000\000\001\002\000\000\000\000\000\000\000\000\000\000\
\000\000\001\002\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\001\002\001\002\000\000\001\002\
\001\002\001\002\001\002\000\000\000\000\000\000\002\002\000\000\
\002\002\002\002\002\002\000\000\000\000\001\002\002\002\000\000\
\001\002\000\000\000\000\002\002\001\002\000\000\000\000\002\002\
\002\002\002\002\000\000\000\000\000\000\000\000\000\000\000\000\
\002\002\002\002\002\002\002\002\000\000\000\000\000\000\000\000\
\000\000\000\000\002\002\000\000\000\000\000\000\000\000\002\002\
\000\000\000\000\000\000\000\000\000\000\002\002\002\002\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\002\002\000\000\000\000\002\002\000\000\
\000\000\002\002\002\002\002\002\226\002\002\002\000\000\000\000\
\000\000\002\002\000\000\000\000\000\000\000\000\000\000\000\000\
\002\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\002\002\002\002\000\000\002\002\002\002\
\002\002\002\002\000\000\000\002\000\000\000\002\000\002\000\002\
\000\000\000\000\000\000\000\002\002\002\000\000\000\000\002\002\
\000\002\000\000\000\000\002\002\000\002\000\002\000\002\000\000\
\000\000\000\000\000\000\000\000\000\000\000\002\000\002\000\002\
\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\002\
\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\
\000\000\000\000\000\002\000\002\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\193\000\000\000\
\000\002\193\000\000\000\000\002\000\000\000\000\000\002\000\002\
\000\002\000\000\000\002\193\000\000\000\000\000\000\002\000\000\
\000\000\193\000\000\000\000\000\129\000\000\002\000\000\000\000\
\193\000\193\000\193\000\193\000\000\000\000\000\000\000\000\000\
\000\002\000\002\000\000\000\002\000\002\000\002\000\002\193\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\082\000\000\002\000\000\082\000\000\002\000\000\000\000\000\000\
\000\002\000\000\000\000\193\000\000\000\082\000\193\000\000\000\
\000\000\000\000\193\000\193\000\000\000\000\000\000\000\000\000\
\000\000\193\000\082\000\082\000\082\000\082\000\000\000\000\000\
\193\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\082\000\000\000\000\000\193\000\000\000\193\000\000\000\
\193\000\193\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\193\000\082\000\000\000\193\000\
\082\000\000\000\000\000\193\000\082\000\082\000\000\000\000\000\
\000\000\000\000\000\000\082\000\000\000\000\000\000\000\121\000\
\000\000\000\000\082\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\082\000\000\000\
\082\000\000\000\082\000\082\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\082\000\000\000\
\000\000\082\000\000\000\000\000\226\002\082\000\000\000\226\002\
\000\000\226\002\226\002\226\002\226\002\000\000\000\000\226\002\
\226\002\226\002\000\000\000\000\000\000\000\000\000\000\226\002\
\000\000\000\000\000\000\000\000\000\000\000\000\226\002\000\000\
\226\002\226\002\226\002\226\002\226\002\226\002\226\002\000\000\
\226\002\000\000\000\000\226\002\000\000\226\002\000\000\000\000\
\000\000\000\000\000\000\226\002\226\002\226\002\226\002\226\002\
\226\002\226\002\226\002\226\002\226\002\226\002\000\000\000\000\
\226\002\226\002\000\000\000\000\226\002\226\002\226\002\000\000\
\226\002\226\002\226\002\226\002\226\002\226\002\000\000\226\002\
\226\002\226\002\226\002\169\001\226\002\000\000\226\002\226\002\
\000\000\000\000\226\002\226\002\000\000\226\002\000\000\226\002\
\000\000\226\002\226\002\226\002\000\000\226\002\226\002\226\002\
\000\000\000\000\000\000\226\002\000\000\000\000\226\002\000\000\
\226\002\226\002\226\002\226\002\226\002\226\002\000\000\000\000\
\226\002\009\000\010\000\011\000\000\000\000\000\000\000\012\000\
\013\000\014\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\015\000\016\000\017\000\018\000\019\000\020\000\021\000\000\000\
\000\000\000\000\000\000\022\000\000\000\023\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\024\000\025\000\026\000\
\000\000\027\000\028\000\029\000\030\000\031\000\000\000\000\000\
\032\000\033\000\000\000\000\000\034\000\035\000\036\000\000\000\
\000\000\037\000\038\000\000\000\039\000\040\000\000\000\041\000\
\000\000\042\000\043\000\000\000\044\000\114\002\045\000\000\000\
\000\000\000\000\046\000\047\000\000\000\048\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\130\000\122\000\
\000\000\000\000\000\000\050\000\000\000\000\000\000\000\000\000\
\051\000\052\000\053\000\054\000\009\000\010\000\011\000\000\000\
\055\000\000\000\012\000\013\000\014\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\015\000\016\000\017\000\018\000\019\000\
\020\000\021\000\000\000\000\000\000\000\000\000\022\000\000\000\
\023\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\024\000\025\000\026\000\000\000\027\000\028\000\029\000\030\000\
\031\000\000\000\000\000\032\000\033\000\000\000\000\000\034\000\
\035\000\036\000\000\000\000\000\037\000\038\000\000\000\039\000\
\040\000\000\000\041\000\000\000\042\000\043\000\000\000\044\000\
\000\000\045\000\000\000\000\000\000\000\046\000\047\000\135\001\
\048\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\122\000\000\000\000\000\000\000\050\000\000\000\
\000\000\000\000\000\000\051\000\052\000\053\000\054\000\000\000\
\000\000\000\000\000\000\055\000\000\000\000\000\000\000\000\000\
\009\000\010\000\011\000\000\000\000\000\000\000\012\000\013\000\
\014\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\000\
\016\000\017\000\018\000\019\000\020\000\021\000\000\000\000\000\
\000\000\000\000\022\000\000\000\023\000\000\000\000\000\000\000\
\000\000\000\000\000\000\130\000\024\000\025\000\026\000\000\000\
\027\000\028\000\029\000\030\000\031\000\000\000\000\000\032\000\
\033\000\000\000\000\000\034\000\035\000\036\000\000\000\000\000\
\037\000\038\000\000\000\039\000\040\000\000\000\041\000\000\000\
\042\000\043\000\000\000\044\000\000\000\045\000\000\000\000\000\
\000\000\046\000\047\000\000\000\048\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\122\000\000\000\
\000\000\000\000\050\000\000\000\000\000\000\000\132\000\051\000\
\052\000\053\000\054\000\000\000\000\000\114\002\000\000\055\000\
\000\000\114\002\000\000\114\002\000\000\114\002\000\000\114\002\
\000\000\114\002\114\002\114\002\114\002\000\000\114\002\114\002\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\114\002\
\114\002\114\002\114\002\114\002\114\002\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\114\002\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\114\002\114\002\
\114\002\114\002\114\002\114\002\000\000\114\002\114\002\000\000\
\000\000\114\002\114\002\000\000\000\000\114\002\114\002\114\002\
\114\002\114\002\114\002\000\000\107\002\114\002\000\000\114\002\
\114\002\000\000\114\002\000\000\000\000\000\000\000\000\114\002\
\114\002\000\000\000\000\114\002\000\000\000\000\000\000\000\000\
\114\002\000\000\114\002\114\002\000\000\114\002\114\002\114\002\
\114\002\000\000\000\000\000\000\114\002\000\000\000\000\114\002\
\000\000\114\002\000\000\114\002\114\002\114\002\000\000\135\001\
\114\002\000\000\000\000\135\001\000\000\135\001\000\000\135\001\
\000\000\135\001\000\000\135\001\000\000\135\001\135\001\133\000\
\135\001\135\001\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\135\001\000\000\000\000\135\001\135\001\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\135\001\135\001\135\001\135\001\000\000\135\001\000\000\135\001\
\135\001\000\000\000\000\135\001\000\000\000\000\000\000\000\000\
\135\001\135\001\135\001\000\000\000\000\000\000\000\000\135\001\
\000\000\135\001\128\000\130\000\135\001\000\000\130\000\130\000\
\000\000\000\000\135\001\000\000\000\000\135\001\000\000\000\000\
\130\000\130\000\135\001\000\000\135\001\135\001\130\000\135\001\
\135\001\000\000\135\001\000\000\000\000\130\000\135\001\130\000\
\130\000\135\001\000\000\135\001\000\000\000\000\135\001\135\001\
\000\000\000\000\135\001\000\000\130\000\000\000\000\000\000\000\
\000\000\000\000\130\000\130\000\130\002\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\132\000\000\000\
\130\000\132\000\132\000\130\000\000\000\000\000\130\000\130\000\
\130\000\000\000\130\000\132\000\132\000\000\000\130\000\000\000\
\000\000\132\000\000\000\000\000\000\000\130\000\000\000\000\000\
\132\000\000\000\132\000\132\000\000\000\000\000\000\000\000\000\
\000\000\130\000\000\000\130\000\000\000\130\000\130\000\132\000\
\000\000\000\000\000\000\000\000\000\000\132\000\132\000\178\000\
\000\000\130\000\000\000\000\000\130\000\000\000\000\000\000\000\
\000\000\000\000\000\000\132\000\000\000\000\000\132\000\000\000\
\000\000\132\000\132\000\132\000\000\000\132\000\000\000\000\000\
\000\000\132\000\000\000\000\000\107\002\000\000\000\000\107\002\
\132\000\000\000\000\000\000\000\107\002\000\000\000\000\000\000\
\000\000\107\002\107\002\000\000\132\000\000\000\132\000\107\002\
\132\000\132\000\125\002\000\000\000\000\000\000\107\002\000\000\
\107\002\107\002\131\002\000\000\132\000\000\000\000\000\132\000\
\000\000\000\000\000\000\000\000\137\000\107\002\138\000\139\000\
\032\000\000\000\140\000\000\000\000\000\177\001\071\004\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\133\000\
\000\000\107\002\133\000\133\000\107\002\000\000\125\002\107\002\
\107\002\107\002\000\000\000\000\133\000\133\000\000\000\107\002\
\145\000\000\000\133\000\000\000\000\000\107\002\107\002\146\000\
\000\000\133\000\000\000\133\000\133\000\000\000\224\002\000\000\
\000\000\000\000\107\002\147\000\148\000\000\000\107\002\107\002\
\133\000\000\000\000\000\000\000\000\000\000\000\133\000\133\000\
\000\000\000\000\107\002\000\000\000\000\107\002\000\000\000\000\
\000\000\000\000\128\000\000\000\133\000\128\000\128\000\133\000\
\000\000\000\000\000\000\133\000\133\000\000\000\133\000\128\000\
\128\000\000\000\133\000\000\000\000\000\128\000\000\000\000\000\
\000\000\133\000\000\000\000\000\128\000\216\001\128\000\128\000\
\000\000\000\000\000\000\000\000\000\000\133\000\000\000\133\000\
\000\000\133\000\133\000\128\000\000\000\000\000\000\000\000\000\
\000\000\128\000\128\000\000\000\130\002\133\000\000\000\130\002\
\133\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\
\000\000\130\002\128\000\000\000\000\000\000\000\128\000\128\000\
\000\000\128\000\000\000\000\000\000\000\128\000\130\002\130\002\
\130\002\130\002\000\000\000\000\128\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\130\002\000\000\000\000\
\128\000\000\000\128\000\000\000\128\000\128\000\000\000\000\000\
\000\000\006\002\000\000\000\000\000\000\000\000\000\000\178\000\
\128\000\130\002\178\000\128\000\000\000\121\002\000\000\130\002\
\130\002\130\002\006\002\000\000\178\000\000\000\121\002\130\002\
\000\000\000\000\000\000\000\000\000\000\000\000\130\002\000\000\
\000\000\178\000\178\000\178\000\178\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\130\002\000\000\130\002\121\002\
\178\000\000\000\121\002\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\130\002\121\002\000\000\130\002\000\000\000\000\
\000\000\000\000\131\002\000\000\178\000\131\002\000\000\000\000\
\026\002\000\000\178\000\178\000\178\000\000\000\000\000\131\002\
\000\000\026\002\178\000\000\000\000\000\000\000\000\000\000\000\
\000\000\178\000\000\000\000\000\131\002\131\002\131\002\131\002\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\178\000\
\000\000\178\000\026\002\131\002\000\000\026\002\007\002\000\000\
\000\000\000\000\000\000\000\000\000\000\178\000\026\002\000\000\
\178\000\000\000\000\000\000\000\000\000\000\000\224\002\131\002\
\000\000\224\002\000\000\122\002\000\000\131\002\131\002\131\002\
\000\000\000\000\000\000\224\002\122\002\131\002\000\000\000\000\
\000\000\224\002\000\000\000\000\131\002\000\000\000\000\000\000\
\224\002\000\000\224\002\224\002\000\000\000\000\000\000\000\000\
\000\000\000\000\131\002\000\000\131\002\122\002\224\002\224\002\
\122\002\000\000\000\000\000\000\000\000\224\002\224\002\000\000\
\131\002\122\002\000\000\131\002\000\000\216\001\000\000\000\000\
\216\001\000\000\000\000\224\002\007\002\216\001\224\002\000\000\
\000\000\000\000\216\001\224\002\000\000\224\002\102\000\000\000\
\216\001\224\002\000\000\000\000\000\000\000\000\000\000\216\001\
\224\002\216\001\216\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\224\002\000\000\216\001\000\000\
\224\002\224\002\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\224\002\000\000\000\000\224\002\
\000\000\000\000\216\001\000\000\000\000\216\001\000\000\000\000\
\216\001\216\001\216\001\000\000\000\000\000\000\000\000\052\002\
\216\001\006\002\000\000\000\000\006\002\000\000\000\000\216\001\
\000\000\006\002\213\001\000\000\000\000\000\000\006\002\000\000\
\000\000\000\000\006\002\216\001\006\002\006\002\000\000\216\001\
\216\001\000\000\006\002\006\002\000\000\006\002\006\002\006\002\
\000\000\000\000\000\000\216\001\000\000\006\002\216\001\000\000\
\000\000\000\000\006\002\000\000\006\002\000\000\006\002\006\002\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\006\002\224\002\000\000\006\002\000\000\
\000\000\006\002\000\000\000\000\006\002\006\002\006\002\000\000\
\000\000\000\000\000\000\006\002\006\002\000\000\000\000\006\002\
\000\000\000\000\006\002\006\002\177\001\006\002\006\002\006\002\
\000\000\000\000\000\000\000\000\006\002\006\002\000\000\006\002\
\000\000\000\000\000\000\006\002\006\002\000\000\000\000\004\002\
\000\000\000\000\000\000\000\000\000\000\000\000\007\002\006\002\
\006\002\007\002\006\002\000\000\006\002\000\000\007\002\000\000\
\006\002\000\000\000\000\007\002\000\000\000\000\000\000\000\000\
\006\002\007\002\000\000\006\002\000\000\000\000\080\000\000\000\
\007\002\000\000\007\002\007\002\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007\002\
\000\000\000\000\137\000\000\000\138\000\139\000\032\000\000\000\
\140\000\000\000\000\000\141\000\142\000\000\000\000\000\000\000\
\000\000\000\000\000\000\007\002\000\000\192\001\007\002\000\000\
\000\000\007\002\007\002\007\002\000\000\143\000\000\000\000\000\
\007\002\007\002\000\000\000\000\007\002\144\000\145\000\007\002\
\007\002\226\002\011\002\000\000\007\002\146\000\102\000\000\000\
\000\000\007\002\000\000\000\000\007\002\000\000\000\000\007\002\
\007\002\147\000\148\000\102\000\005\002\000\000\007\002\000\000\
\007\002\007\002\000\000\000\000\007\002\000\000\000\000\007\002\
\102\000\000\000\102\000\102\000\000\000\007\002\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\102\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\007\002\000\000\000\000\007\002\177\001\000\000\007\002\
\007\002\007\002\000\000\102\000\000\000\000\000\007\002\007\002\
\000\000\000\000\213\001\102\000\000\000\213\001\007\002\000\000\
\000\000\102\000\213\001\000\000\000\000\000\000\000\000\213\001\
\102\000\000\000\007\002\000\000\000\000\213\001\007\002\000\000\
\000\000\000\000\007\002\000\000\213\001\000\000\213\001\213\001\
\102\000\000\000\007\002\000\000\000\000\007\002\000\000\000\000\
\000\000\000\000\000\000\213\001\102\000\000\000\000\000\102\000\
\178\001\000\000\000\000\000\000\224\002\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\213\001\
\000\000\224\002\213\001\000\000\000\000\213\001\213\001\213\001\
\000\000\000\000\000\000\000\000\177\001\213\001\224\002\177\001\
\224\002\224\002\000\000\000\000\213\001\000\000\000\000\000\000\
\000\000\177\001\000\000\000\000\000\000\224\002\000\000\177\001\
\213\001\000\000\000\000\000\000\213\001\213\001\177\001\000\000\
\177\001\177\001\000\000\180\001\000\000\000\000\000\000\097\000\
\213\001\224\002\000\000\213\001\000\000\177\001\000\000\000\000\
\000\000\224\002\000\000\000\000\000\000\000\000\080\000\224\002\
\000\000\080\000\000\000\000\000\000\000\000\000\224\002\000\000\
\000\000\177\001\000\000\080\000\177\001\000\000\000\000\000\000\
\177\001\177\001\000\000\000\000\000\000\000\000\224\002\177\001\
\080\000\080\000\080\000\080\000\000\000\000\000\177\001\000\000\
\000\000\000\000\224\002\000\000\121\002\224\002\179\001\080\000\
\000\000\000\000\177\001\000\000\000\000\000\000\177\001\177\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\226\002\177\001\080\000\226\002\177\001\080\000\000\000\
\000\000\226\002\080\000\080\000\000\000\000\000\226\002\000\000\
\000\000\080\000\000\000\000\000\226\002\000\000\000\000\000\000\
\080\000\000\000\000\000\226\002\000\000\226\002\226\002\000\000\
\101\000\000\000\000\000\000\000\080\000\000\000\080\000\000\000\
\080\000\080\000\226\002\000\000\000\000\000\000\000\000\000\000\
\000\000\181\001\000\000\000\000\080\000\000\000\000\000\080\000\
\000\000\000\000\000\000\000\000\000\000\177\001\226\002\000\000\
\177\001\226\002\000\000\000\000\000\000\226\002\226\002\000\000\
\000\000\000\000\177\001\000\000\226\002\000\000\000\000\000\000\
\177\001\000\000\000\000\226\002\000\000\000\000\000\000\177\001\
\000\000\177\001\177\001\000\000\000\000\000\000\000\000\226\002\
\000\000\000\000\000\000\226\002\226\002\000\000\177\001\000\000\
\000\000\000\000\000\000\000\000\184\001\000\000\000\000\226\002\
\000\000\000\000\226\002\000\000\000\000\000\000\000\000\000\000\
\178\001\000\000\177\001\178\001\000\000\177\001\000\000\000\000\
\000\000\177\001\177\001\000\000\000\000\178\001\000\000\000\000\
\177\001\000\000\000\000\178\001\000\000\000\000\000\000\177\001\
\000\000\000\000\178\001\000\000\178\001\178\001\000\000\000\000\
\000\000\000\000\000\000\177\001\000\000\000\000\226\002\177\001\
\177\001\178\001\000\000\000\000\000\000\000\000\000\000\117\000\
\000\000\000\000\000\000\177\001\000\000\000\000\177\001\000\000\
\000\000\000\000\000\000\180\001\000\000\178\001\180\001\097\000\
\178\001\000\000\000\000\000\000\178\001\178\001\000\000\000\000\
\180\001\000\000\000\000\178\001\097\000\000\000\180\001\000\000\
\000\000\000\000\178\001\000\000\000\000\180\001\000\000\180\001\
\180\001\097\000\000\000\097\000\097\000\000\000\178\001\000\000\
\000\000\168\001\178\001\178\001\180\001\000\000\000\000\000\000\
\097\000\000\000\000\000\000\000\000\000\000\000\178\001\000\000\
\000\000\178\001\000\000\000\000\000\000\000\000\179\001\000\000\
\180\001\179\001\000\000\180\001\097\000\000\000\000\000\180\001\
\180\001\000\000\000\000\179\001\097\000\000\000\180\001\000\000\
\000\000\179\001\097\000\000\000\000\000\180\001\000\000\000\000\
\179\001\097\000\179\001\179\001\000\000\000\000\000\000\000\000\
\000\000\180\001\000\000\000\000\224\002\180\001\180\001\179\001\
\000\000\097\000\000\000\000\000\000\000\000\000\000\000\000\000\
\101\000\180\001\000\000\000\000\180\001\097\000\000\000\000\000\
\097\000\000\000\000\000\179\001\000\000\101\000\179\001\000\000\
\000\000\181\001\179\001\179\001\181\001\000\000\000\000\000\000\
\000\000\179\001\101\000\000\000\101\000\101\000\181\001\000\000\
\179\001\224\002\000\000\000\000\181\001\000\000\000\000\000\000\
\000\000\101\000\000\000\181\001\179\001\181\001\181\001\000\000\
\179\001\179\001\000\000\000\000\000\000\000\000\000\000\069\000\
\000\000\000\000\181\001\000\000\179\001\101\000\000\000\179\001\
\000\000\000\000\000\000\000\000\000\000\101\000\000\000\000\000\
\000\000\000\000\000\000\101\000\184\001\000\000\181\001\184\001\
\000\000\181\001\101\000\000\000\000\000\181\001\181\001\000\000\
\000\000\184\001\000\000\000\000\181\001\000\000\000\000\184\001\
\000\000\000\000\101\000\181\001\070\000\000\000\184\001\000\000\
\184\001\184\001\000\000\000\000\000\000\000\000\101\000\181\001\
\000\000\101\000\000\000\181\001\181\001\184\001\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\226\002\181\001\
\000\000\000\000\181\001\000\000\000\000\000\000\226\002\117\000\
\000\000\184\001\000\000\226\002\184\001\000\000\000\000\000\000\
\184\001\184\001\000\000\000\000\117\000\000\000\213\001\184\001\
\226\002\000\000\226\002\226\002\000\000\000\000\184\001\213\001\
\000\000\117\000\000\000\117\000\117\000\000\000\000\000\226\002\
\000\000\000\000\184\001\000\000\000\000\000\000\184\001\184\001\
\117\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\168\001\184\001\226\002\000\000\184\001\226\002\000\000\
\000\000\000\000\226\002\226\002\117\000\000\000\168\001\117\000\
\000\000\226\002\000\000\117\000\117\000\000\000\000\000\000\000\
\226\002\000\000\117\000\168\001\000\000\168\001\168\001\000\000\
\000\000\117\000\000\000\000\000\226\002\000\000\000\000\000\000\
\226\002\226\002\168\001\000\000\000\000\117\000\000\000\000\000\
\000\000\117\000\117\000\000\000\226\002\224\002\000\000\226\002\
\000\000\000\000\000\000\000\000\224\002\117\000\168\001\224\002\
\117\000\168\001\000\000\000\000\000\000\168\001\168\001\000\000\
\000\000\224\002\000\000\123\000\168\001\000\000\000\000\000\000\
\000\000\000\000\000\000\168\001\000\000\000\000\224\002\000\000\
\224\002\224\002\000\000\000\000\000\000\000\000\000\000\168\001\
\000\000\124\000\000\000\168\001\168\001\224\002\000\000\000\000\
\000\000\224\002\000\000\000\000\000\000\000\000\000\000\168\001\
\000\000\000\000\168\001\000\000\000\000\000\000\224\002\000\000\
\000\000\224\002\000\000\000\000\224\002\000\000\000\000\069\000\
\000\000\224\002\069\000\224\002\000\000\224\002\224\002\224\002\
\000\000\000\000\000\000\000\000\069\000\000\000\224\002\000\000\
\000\000\000\000\224\002\000\000\000\000\000\000\000\000\000\000\
\000\000\069\000\224\002\069\000\069\000\000\000\224\002\224\002\
\000\000\000\000\000\000\000\000\000\000\000\000\224\002\069\000\
\069\000\224\002\224\002\000\000\070\000\224\002\224\002\070\000\
\226\002\000\000\000\000\000\000\224\002\000\000\000\000\000\000\
\000\000\070\000\226\002\224\002\069\000\000\000\000\000\069\000\
\000\000\000\000\000\000\069\000\069\000\000\000\070\000\224\002\
\070\000\070\000\069\000\224\002\224\002\000\000\000\000\000\000\
\000\000\069\000\000\000\000\000\070\000\070\000\000\000\224\002\
\000\000\000\000\224\002\000\000\000\000\069\000\213\001\000\000\
\000\000\069\000\069\000\000\000\000\000\000\000\213\001\213\001\
\000\000\070\000\000\000\213\001\070\000\069\000\000\000\000\000\
\070\000\070\000\000\000\000\000\213\001\000\000\000\000\070\000\
\213\001\000\000\213\001\213\001\000\000\224\002\070\000\000\000\
\000\000\213\001\000\000\213\001\213\001\000\000\000\000\213\001\
\000\000\000\000\070\000\000\000\000\000\000\000\070\000\070\000\
\213\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\070\000\213\001\000\000\000\000\213\001\000\000\
\000\000\213\001\213\001\213\001\213\001\000\000\000\000\213\001\
\000\000\213\001\213\001\213\001\213\001\000\000\000\000\054\000\
\213\001\000\000\213\001\000\000\000\000\224\002\000\000\000\000\
\224\002\213\001\000\000\000\000\213\001\000\000\000\000\000\000\
\213\001\213\001\224\002\000\000\000\000\213\001\000\000\000\000\
\000\000\213\001\213\001\123\000\213\001\000\000\123\000\224\002\
\000\000\224\002\224\002\000\000\000\000\213\001\056\000\000\000\
\123\000\000\000\000\000\000\000\000\000\224\002\224\002\000\000\
\000\000\124\000\000\000\000\000\124\000\123\000\000\000\123\000\
\123\000\000\000\000\000\000\000\000\000\000\000\124\000\000\000\
\000\000\000\000\224\002\000\000\123\000\224\002\000\000\000\000\
\000\000\000\000\224\002\124\000\000\000\124\000\124\000\000\000\
\224\002\000\000\060\000\000\000\000\000\000\000\000\000\224\002\
\123\000\000\000\124\000\123\000\000\000\000\000\000\000\123\000\
\123\000\000\000\000\000\224\002\000\000\000\000\123\000\224\002\
\224\002\000\000\000\000\000\000\000\000\123\000\124\000\000\000\
\000\000\124\000\000\000\224\002\000\000\124\000\124\000\000\000\
\000\000\123\000\000\000\000\000\124\000\123\000\123\000\063\000\
\226\002\000\000\000\000\124\000\000\000\000\000\000\000\000\000\
\226\002\123\000\226\002\000\000\000\000\226\002\000\000\124\000\
\000\000\000\000\000\000\124\000\124\000\064\000\000\000\226\002\
\000\000\000\000\226\002\000\000\226\002\226\002\224\002\124\000\
\000\000\000\000\000\000\000\000\226\002\000\000\226\002\226\002\
\000\000\226\002\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\226\002\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\226\002\000\000\000\000\
\226\002\000\000\000\000\000\000\226\002\226\002\000\000\226\002\
\000\000\000\000\226\002\226\002\000\000\224\002\226\002\226\002\
\224\002\000\000\226\002\000\000\000\000\226\002\000\000\000\000\
\000\000\000\000\224\002\000\000\226\002\000\000\226\002\000\000\
\000\000\000\000\226\002\226\002\000\000\000\000\000\000\224\002\
\226\002\224\002\224\002\000\000\226\002\226\002\226\002\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\224\002\000\000\
\226\002\000\000\039\002\000\000\039\002\039\002\039\002\054\000\
\039\002\000\000\000\000\039\002\039\002\000\000\000\000\000\000\
\000\000\000\000\224\002\000\000\054\000\224\002\000\000\000\000\
\000\000\000\000\224\002\000\000\000\000\039\002\000\000\000\000\
\224\002\054\000\000\000\054\000\054\000\039\002\039\002\224\002\
\000\000\000\000\000\000\000\000\000\000\039\002\056\000\000\000\
\054\000\000\000\000\000\224\002\000\000\000\000\000\000\224\002\
\224\002\039\002\039\002\056\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\224\002\054\000\000\000\000\000\054\000\
\056\000\000\000\056\000\056\000\054\000\000\000\000\000\000\000\
\000\000\000\000\054\000\000\000\000\000\000\000\000\000\056\000\
\000\000\054\000\060\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\054\000\000\000\060\000\
\000\000\054\000\054\000\056\000\000\000\000\000\056\000\000\000\
\000\000\000\000\000\000\056\000\060\000\054\000\060\000\060\000\
\000\000\056\000\000\000\000\000\000\000\000\000\000\000\000\000\
\056\000\000\000\000\000\060\000\000\000\000\000\000\000\063\000\
\000\000\000\000\000\000\000\000\056\000\000\000\000\000\000\000\
\056\000\056\000\000\000\000\000\063\000\000\000\000\000\060\000\
\000\000\000\000\060\000\000\000\056\000\064\000\000\000\060\000\
\000\000\063\000\000\000\063\000\063\000\060\000\224\002\000\000\
\000\000\000\000\064\000\000\000\060\000\000\000\000\000\000\000\
\063\000\000\000\000\000\224\002\000\000\000\000\000\000\064\000\
\060\000\064\000\064\000\000\000\060\000\060\000\000\000\000\000\
\224\002\000\000\224\002\224\002\063\000\000\000\064\000\063\000\
\060\000\000\000\000\000\000\000\063\000\000\000\000\000\224\002\
\000\000\000\000\063\000\000\000\000\000\000\000\000\000\000\000\
\000\000\063\000\064\000\000\000\000\000\064\000\000\000\000\000\
\000\000\000\000\064\000\224\002\000\000\063\000\224\002\000\000\
\064\000\063\000\063\000\224\002\000\000\000\000\000\000\064\000\
\000\000\224\002\000\000\000\000\000\000\063\000\000\000\000\000\
\224\002\000\000\000\000\064\000\000\000\000\000\000\000\064\000\
\064\000\000\000\000\000\000\000\224\002\000\000\000\000\000\000\
\224\002\224\002\219\002\064\000\000\000\000\000\000\000\219\002\
\219\002\219\002\219\002\000\000\224\002\219\002\219\002\219\002\
\219\002\000\000\000\000\000\000\000\000\219\002\000\000\000\000\
\000\000\000\000\000\000\000\000\219\002\000\000\219\002\219\002\
\219\002\219\002\219\002\219\002\219\002\000\000\000\000\000\000\
\000\000\219\002\000\000\219\002\000\000\000\000\000\000\000\000\
\000\000\219\002\219\002\219\002\219\002\219\002\219\002\219\002\
\219\002\219\002\219\002\219\002\000\000\000\000\219\002\219\002\
\000\000\000\000\219\002\219\002\219\002\219\002\000\000\219\002\
\219\002\219\002\219\002\219\002\000\000\219\002\000\000\219\002\
\219\002\000\000\219\002\000\000\219\002\219\002\000\000\000\000\
\219\002\219\002\000\000\219\002\000\000\219\002\000\000\000\000\
\219\002\219\002\000\000\000\000\219\002\219\002\000\000\000\000\
\000\000\219\002\000\000\000\000\219\002\000\000\219\002\219\002\
\219\002\219\002\219\002\219\002\000\000\000\000\219\002\035\001\
\036\001\037\001\000\000\000\000\009\000\010\000\038\001\000\000\
\039\001\000\000\012\000\013\000\000\000\000\000\040\001\041\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\042\001\000\000\000\000\017\000\018\000\019\000\
\020\000\021\000\000\000\043\001\000\000\000\000\022\000\000\000\
\000\000\044\001\045\001\046\001\047\001\048\001\000\000\000\000\
\024\000\025\000\026\000\000\000\027\000\028\000\029\000\030\000\
\031\000\000\000\000\000\032\000\000\000\049\001\000\000\034\000\
\035\000\036\000\000\000\000\000\000\000\038\000\000\000\050\001\
\051\001\000\000\052\001\000\000\042\000\043\000\000\000\044\000\
\000\000\000\000\000\000\053\001\054\001\055\001\056\001\057\001\
\058\001\000\000\000\000\000\000\000\000\000\000\000\000\059\001\
\000\000\000\000\000\000\060\001\000\000\061\001\050\000\000\000\
\000\000\000\000\000\000\051\000\052\000\000\000\054\000\035\001\
\036\001\037\001\000\000\055\000\009\000\010\000\038\001\000\000\
\039\001\000\000\012\000\013\000\000\000\000\000\000\000\041\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\042\001\000\000\000\000\017\000\018\000\019\000\
\020\000\021\000\000\000\043\001\000\000\000\000\022\000\000\000\
\000\000\044\001\045\001\046\001\047\001\048\001\000\000\000\000\
\024\000\025\000\026\000\000\000\027\000\028\000\029\000\030\000\
\031\000\000\000\000\000\032\000\000\000\049\001\000\000\034\000\
\035\000\036\000\000\000\000\000\000\000\038\000\000\000\050\001\
\051\001\000\000\052\001\000\000\042\000\043\000\000\000\044\000\
\000\000\000\000\000\000\053\001\054\001\055\001\056\001\057\001\
\058\001\000\000\000\000\000\000\000\000\000\000\000\000\059\001\
\000\000\000\000\000\000\060\001\000\000\061\001\050\000\000\000\
\000\000\000\000\000\000\051\000\052\000\000\000\054\000\035\001\
\036\001\037\001\000\000\055\000\009\000\010\000\038\001\000\000\
\039\001\000\000\012\000\013\000\000\000\000\000\000\000\041\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\042\001\000\000\000\000\017\000\018\000\019\000\
\020\000\021\000\000\000\043\001\000\000\000\000\022\000\000\000\
\000\000\044\001\045\001\046\001\047\001\048\001\000\000\000\000\
\024\000\025\000\026\000\000\000\027\000\028\000\029\000\030\000\
\031\000\000\000\000\000\032\000\000\000\049\001\000\000\034\000\
\035\000\036\000\000\000\000\000\000\000\038\000\000\000\050\001\
\051\001\000\000\090\003\000\000\042\000\043\000\000\000\044\000\
\000\000\000\000\000\000\053\001\054\001\055\001\056\001\057\001\
\058\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\060\001\000\000\061\001\050\000\000\000\
\000\000\000\000\226\002\051\000\052\000\000\000\054\000\226\002\
\226\002\226\002\226\002\055\000\000\000\226\002\226\002\000\000\
\000\000\000\000\000\000\000\000\000\000\226\002\000\000\000\000\
\000\000\000\000\000\000\000\000\226\002\000\000\226\002\000\000\
\226\002\226\002\226\002\226\002\226\002\000\000\000\000\000\000\
\000\000\226\002\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\226\002\226\002\226\002\226\002\226\002\226\002\226\002\
\226\002\226\002\226\002\226\002\000\000\000\000\226\002\226\002\
\000\000\000\000\226\002\226\002\226\002\000\000\000\000\226\002\
\226\002\226\002\226\002\226\002\000\000\000\000\000\000\226\002\
\226\002\000\000\226\002\000\000\000\000\226\002\000\000\000\000\
\226\002\226\002\000\000\226\002\000\000\226\002\000\000\000\000\
\000\000\226\002\000\000\000\000\000\000\226\002\000\000\000\000\
\000\000\226\002\000\000\000\000\226\002\000\000\226\002\226\002\
\000\000\226\002\226\002\226\002\094\002\000\000\226\002\000\000\
\000\000\165\002\165\002\165\002\000\000\000\000\000\000\165\002\
\165\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\165\002\165\002\165\002\165\002\165\002\000\000\
\000\000\000\000\000\000\165\002\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\165\002\165\002\165\002\
\000\000\165\002\165\002\165\002\165\002\165\002\000\000\000\000\
\165\002\000\000\000\000\000\000\165\002\165\002\165\002\000\000\
\000\000\000\000\165\002\000\000\165\002\165\002\000\000\000\000\
\000\000\165\002\165\002\000\000\165\002\000\000\000\000\000\000\
\000\000\000\000\165\002\165\002\095\002\165\002\000\000\000\000\
\000\000\166\002\166\002\166\002\094\002\000\000\000\000\166\002\
\166\002\000\000\000\000\165\002\000\000\000\000\000\000\000\000\
\165\002\165\002\000\000\165\002\000\000\000\000\000\000\000\000\
\165\002\000\000\166\002\166\002\166\002\166\002\166\002\000\000\
\000\000\000\000\000\000\166\002\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\166\002\166\002\166\002\
\000\000\166\002\166\002\166\002\166\002\166\002\000\000\000\000\
\166\002\000\000\000\000\000\000\166\002\166\002\166\002\000\000\
\000\000\000\000\166\002\000\000\166\002\166\002\000\000\000\000\
\000\000\166\002\166\002\000\000\166\002\000\000\000\000\000\000\
\000\000\000\000\166\002\166\002\092\002\166\002\000\000\000\000\
\000\000\167\002\167\002\167\002\095\002\000\000\000\000\167\002\
\167\002\000\000\000\000\166\002\000\000\000\000\000\000\000\000\
\166\002\166\002\000\000\166\002\000\000\000\000\000\000\000\000\
\166\002\000\000\167\002\167\002\167\002\167\002\167\002\000\000\
\000\000\000\000\000\000\167\002\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\167\002\167\002\167\002\
\000\000\167\002\167\002\167\002\167\002\167\002\000\000\000\000\
\167\002\000\000\000\000\000\000\167\002\167\002\167\002\000\000\
\000\000\000\000\167\002\000\000\167\002\167\002\000\000\000\000\
\000\000\167\002\167\002\000\000\167\002\000\000\000\000\000\000\
\000\000\000\000\167\002\167\002\093\002\167\002\000\000\000\000\
\000\000\168\002\168\002\168\002\092\002\000\000\000\000\168\002\
\168\002\000\000\000\000\167\002\000\000\000\000\000\000\000\000\
\167\002\167\002\000\000\167\002\000\000\000\000\000\000\000\000\
\167\002\000\000\168\002\168\002\168\002\168\002\168\002\000\000\
\000\000\000\000\000\000\168\002\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\168\002\168\002\168\002\
\000\000\168\002\168\002\168\002\168\002\168\002\000\000\000\000\
\168\002\000\000\000\000\000\000\168\002\168\002\168\002\000\000\
\000\000\000\000\168\002\000\000\168\002\168\002\000\000\000\000\
\000\000\168\002\168\002\000\000\168\002\000\000\000\000\000\000\
\000\000\000\000\168\002\168\002\000\000\168\002\000\000\000\000\
\000\000\000\000\000\000\000\000\093\002\235\000\236\000\237\000\
\000\000\000\000\000\000\168\002\000\000\238\000\000\000\239\000\
\168\002\168\002\000\000\168\002\000\000\240\000\241\000\242\000\
\168\002\000\000\243\000\244\000\245\000\000\000\246\000\247\000\
\248\000\000\000\249\000\250\000\251\000\252\000\000\000\000\000\
\000\000\253\000\254\000\255\000\000\000\000\000\000\000\000\000\
\000\000\000\001\001\001\000\000\000\000\000\000\000\000\002\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\003\001\004\001\000\000\000\000\000\000\000\000\
\005\001\006\001\000\000\000\000\000\000\007\001\008\001\000\000\
\009\001\000\000\010\001\011\001\012\001\000\000\013\001\000\000\
\000\000\000\000\000\000\000\000\014\001\000\000\000\000\000\000\
\000\000\015\001\000\000\000\000\000\000\000\000\000\000\016\001\
\008\002\000\000\017\001\018\001\008\002\019\001\020\001\021\001\
\022\001\023\001\000\000\024\001\025\001\026\001\027\001\028\001\
\000\000\008\002\000\000\008\002\000\000\000\000\245\001\000\000\
\000\000\000\000\008\002\008\002\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\008\002\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\008\002\
\008\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\008\002\000\000\000\000\
\000\000\008\002\000\000\008\002\008\002\008\002\000\000\008\002\
\000\000\000\000\008\002\000\000\000\000\000\000\000\000\035\001\
\036\001\037\001\000\000\000\000\000\000\010\000\225\001\000\000\
\039\001\000\000\000\000\013\000\245\001\008\002\226\001\041\001\
\000\000\008\002\000\000\008\002\000\000\000\000\008\002\000\000\
\000\000\000\000\042\001\162\000\000\000\017\000\018\000\008\002\
\000\000\008\002\000\000\043\001\000\000\000\000\000\000\000\000\
\000\000\044\001\045\001\046\001\047\001\048\001\000\000\000\000\
\024\000\025\000\026\000\000\000\163\000\164\000\000\000\165\000\
\166\000\000\000\000\000\032\000\000\000\049\001\000\000\000\000\
\167\000\168\000\000\000\000\000\000\000\000\000\000\000\227\001\
\228\001\000\000\229\001\000\000\042\000\000\000\000\000\000\000\
\000\000\000\000\000\000\053\001\054\001\230\001\231\001\057\001\
\232\001\000\000\000\000\000\000\000\000\000\000\000\000\059\001\
\000\000\000\000\171\000\060\001\000\000\061\001\050\000\000\000\
\000\000\000\000\000\000\051\000\000\000\000\000\054\000\172\000\
\035\001\036\001\037\001\000\000\000\000\000\000\010\000\225\001\
\000\000\039\001\000\000\000\000\013\000\000\000\000\000\000\000\
\041\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\042\001\162\000\000\000\017\000\018\000\
\000\000\000\000\000\000\000\000\043\001\000\000\000\000\000\000\
\000\000\000\000\044\001\045\001\046\001\047\001\048\001\000\000\
\000\000\024\000\025\000\026\000\000\000\163\000\164\000\000\000\
\165\000\166\000\000\000\000\000\032\000\000\000\049\001\000\000\
\000\000\167\000\168\000\000\000\000\000\000\000\000\000\000\000\
\227\001\228\001\000\000\229\001\000\000\042\000\000\000\000\000\
\000\000\000\000\000\000\000\000\053\001\054\001\230\001\231\001\
\057\001\232\001\000\000\000\000\000\000\000\000\000\000\000\000\
\059\001\000\000\000\000\171\000\060\001\000\000\061\001\050\000\
\000\000\000\000\000\000\000\000\051\000\000\000\001\003\054\000\
\172\000\035\001\036\001\037\001\000\000\000\000\000\000\010\000\
\225\001\000\000\039\001\000\000\000\000\013\000\000\000\000\000\
\000\000\041\001\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\042\001\162\000\000\000\017\000\
\018\000\000\000\000\000\000\000\000\000\043\001\000\000\000\000\
\000\000\000\000\000\000\044\001\045\001\046\001\047\001\048\001\
\000\000\000\000\024\000\025\000\026\000\000\000\163\000\164\000\
\000\000\165\000\166\000\000\000\000\000\032\000\000\000\049\001\
\000\000\000\000\167\000\168\000\000\000\000\000\000\000\000\000\
\000\000\227\001\228\001\000\000\229\001\000\000\042\000\000\000\
\000\000\000\000\000\000\000\000\000\000\053\001\054\001\230\001\
\231\001\057\001\232\001\000\000\000\000\000\000\000\000\000\000\
\000\000\059\001\000\000\000\000\171\000\060\001\000\000\061\001\
\050\000\000\000\000\000\000\000\000\000\051\000\000\000\202\003\
\054\000\172\000\035\001\036\001\037\001\000\000\000\000\000\000\
\010\000\225\001\000\000\039\001\000\000\000\000\013\000\000\000\
\000\000\000\000\041\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\042\001\162\000\000\000\
\017\000\018\000\000\000\000\000\000\000\000\000\043\001\000\000\
\000\000\000\000\000\000\000\000\044\001\045\001\046\001\047\001\
\048\001\000\000\000\000\024\000\025\000\026\000\000\000\163\000\
\164\000\000\000\165\000\166\000\000\000\000\000\032\000\000\000\
\049\001\000\000\000\000\167\000\168\000\000\000\000\000\000\000\
\000\000\000\000\227\001\228\001\000\000\229\001\000\000\042\000\
\000\000\000\000\000\000\000\000\000\000\000\000\053\001\054\001\
\230\001\231\001\057\001\232\001\000\000\000\000\000\000\000\000\
\000\000\000\000\059\001\000\000\000\000\171\000\060\001\000\000\
\061\001\050\000\000\000\000\000\000\000\000\000\051\000\000\000\
\008\004\054\000\172\000\035\001\036\001\037\001\000\000\000\000\
\000\000\010\000\225\001\000\000\039\001\000\000\000\000\013\000\
\000\000\000\000\000\000\041\001\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\042\001\162\000\
\000\000\017\000\018\000\000\000\000\000\000\000\000\000\043\001\
\000\000\000\000\000\000\000\000\000\000\044\001\045\001\046\001\
\047\001\048\001\000\000\000\000\024\000\025\000\026\000\000\000\
\163\000\164\000\000\000\165\000\166\000\000\000\000\000\032\000\
\000\000\049\001\000\000\221\002\167\000\168\000\000\000\000\000\
\000\000\010\000\000\000\227\001\228\001\000\000\229\001\013\000\
\042\000\000\000\000\000\000\000\000\000\000\000\000\000\053\001\
\054\001\230\001\231\001\057\001\232\001\000\000\000\000\162\000\
\000\000\017\000\018\000\059\001\000\000\000\000\171\000\060\001\
\000\000\061\001\050\000\000\000\000\000\000\000\000\000\051\000\
\000\000\000\000\054\000\172\000\024\000\025\000\026\000\000\000\
\163\000\164\000\000\000\165\000\166\000\000\000\000\000\032\000\
\000\000\000\000\000\000\223\002\167\000\168\000\000\000\000\000\
\000\000\010\000\000\000\169\000\000\000\000\000\000\000\013\000\
\042\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\170\000\000\000\000\000\000\000\000\000\000\000\162\000\
\000\000\017\000\018\000\000\000\000\000\000\000\171\000\000\000\
\000\000\000\000\050\000\000\000\000\000\000\000\000\000\051\000\
\000\000\000\000\054\000\172\000\024\000\025\000\026\000\000\000\
\163\000\164\000\000\000\165\000\166\000\000\000\000\000\032\000\
\000\000\000\000\000\000\225\002\167\000\168\000\000\000\000\000\
\000\000\010\000\000\000\169\000\000\000\000\000\000\000\013\000\
\042\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\170\000\000\000\000\000\000\000\000\000\000\000\162\000\
\000\000\017\000\018\000\000\000\000\000\000\000\171\000\000\000\
\000\000\000\000\050\000\000\000\000\000\000\000\000\000\051\000\
\000\000\000\000\054\000\172\000\024\000\025\000\026\000\000\000\
\163\000\164\000\000\000\165\000\166\000\000\000\000\000\032\000\
\000\000\000\000\000\000\000\000\167\000\168\000\000\000\000\000\
\000\000\000\000\000\000\169\000\000\000\000\000\000\000\000\000\
\042\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\170\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\171\000\000\000\
\000\000\000\000\050\000\000\000\000\000\000\000\000\000\051\000\
\000\000\000\000\054\000\172\000\009\000\010\000\011\000\000\000\
\000\000\000\000\012\000\013\000\014\000\053\002\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\015\000\016\000\017\000\018\000\019\000\
\020\000\021\000\000\000\000\000\000\000\000\000\022\000\000\000\
\023\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\024\000\025\000\026\000\000\000\027\000\028\000\029\000\030\000\
\031\000\000\000\000\000\032\000\033\000\000\000\000\000\034\000\
\035\000\036\000\000\000\000\000\037\000\038\000\000\000\039\000\
\040\000\000\000\041\000\000\000\042\000\043\000\000\000\044\000\
\000\000\045\000\000\000\000\000\000\000\046\000\047\000\000\000\
\048\000\000\000\054\002\000\000\000\000\009\000\010\000\011\000\
\000\000\049\000\000\000\012\000\013\000\014\000\050\000\000\000\
\000\000\000\000\000\000\051\000\052\000\053\000\054\000\000\000\
\000\000\000\000\000\000\055\000\015\000\016\000\017\000\018\000\
\019\000\020\000\021\000\000\000\000\000\000\000\000\000\022\000\
\000\000\023\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\024\000\025\000\026\000\000\000\027\000\028\000\029\000\
\030\000\031\000\000\000\000\000\032\000\033\000\000\000\000\000\
\034\000\035\000\036\000\000\000\000\000\037\000\038\000\000\000\
\039\000\040\000\000\000\041\000\000\000\042\000\043\000\000\000\
\044\000\000\000\045\000\000\000\000\000\000\000\046\000\047\000\
\000\000\048\000\000\000\000\000\000\000\009\000\010\000\011\000\
\000\000\000\000\049\000\012\000\013\000\000\000\000\000\050\000\
\000\000\000\000\000\000\000\000\051\000\052\000\053\000\054\000\
\000\000\000\000\000\000\000\000\055\000\000\000\017\000\018\000\
\019\000\020\000\021\000\000\000\000\000\000\000\000\000\022\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\024\000\025\000\026\000\000\000\027\000\028\000\029\000\
\030\000\031\000\000\000\000\000\032\000\000\000\000\000\000\000\
\034\000\035\000\036\000\000\000\000\000\000\000\038\000\000\000\
\039\000\040\000\000\000\000\000\000\000\042\000\043\000\000\000\
\044\000\000\000\000\000\000\000\000\000\000\000\046\000\047\000\
\000\000\048\000\000\000\000\000\000\000\000\000\230\000\009\000\
\010\000\011\000\000\000\000\000\233\000\012\000\013\000\050\000\
\000\000\000\000\000\000\000\000\051\000\052\000\000\000\054\000\
\000\000\000\000\000\000\000\000\055\000\000\000\000\000\000\000\
\017\000\018\000\019\000\020\000\021\000\000\000\000\000\000\000\
\000\000\022\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\024\000\025\000\026\000\000\000\027\000\
\028\000\029\000\030\000\031\000\000\000\000\000\032\000\000\000\
\000\000\000\000\034\000\035\000\036\000\000\000\000\000\000\000\
\038\000\000\000\039\000\040\000\000\000\000\000\000\000\042\000\
\043\000\000\000\044\000\000\000\000\000\000\000\000\000\000\000\
\046\000\047\000\000\000\048\000\000\000\000\000\009\000\010\000\
\011\000\000\000\000\000\000\000\012\000\013\000\000\000\000\000\
\000\000\050\000\000\000\000\000\000\000\000\000\051\000\052\000\
\000\000\054\000\000\000\006\002\000\000\000\000\055\000\017\000\
\018\000\019\000\020\000\021\000\000\000\000\000\000\000\000\000\
\022\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\024\000\025\000\026\000\000\000\027\000\028\000\
\029\000\030\000\031\000\000\000\000\000\032\000\000\000\000\000\
\000\000\034\000\035\000\036\000\000\000\000\000\000\000\038\000\
\000\000\039\000\040\000\000\000\000\000\000\000\042\000\043\000\
\000\000\044\000\000\000\000\000\000\000\000\000\000\000\046\000\
\047\000\000\000\048\000\000\000\000\000\228\002\228\002\228\002\
\000\000\000\000\000\000\228\002\228\002\000\000\000\000\000\000\
\050\000\000\000\000\000\000\000\000\000\051\000\052\000\000\000\
\054\000\000\000\228\002\000\000\000\000\055\000\228\002\228\002\
\228\002\228\002\228\002\000\000\000\000\000\000\000\000\228\002\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\228\002\228\002\228\002\000\000\228\002\228\002\228\002\
\228\002\228\002\000\000\000\000\228\002\000\000\000\000\000\000\
\228\002\228\002\228\002\000\000\000\000\000\000\228\002\000\000\
\228\002\228\002\000\000\000\000\000\000\228\002\228\002\000\000\
\228\002\000\000\000\000\000\000\000\000\000\000\228\002\228\002\
\000\000\228\002\000\000\000\000\009\000\010\000\011\000\000\000\
\000\000\000\000\012\000\013\000\000\000\000\000\000\000\228\002\
\000\000\000\000\000\000\000\000\228\002\228\002\000\000\228\002\
\000\000\000\000\000\000\000\000\228\002\017\000\018\000\019\000\
\020\000\021\000\000\000\000\000\000\000\000\000\022\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\024\000\025\000\026\000\000\000\027\000\028\000\029\000\030\000\
\031\000\000\000\000\000\032\000\000\000\000\000\000\000\034\000\
\035\000\036\000\000\000\000\000\000\000\038\000\000\000\039\000\
\040\000\000\000\000\000\000\000\042\000\043\000\000\000\044\000\
\000\000\000\000\000\000\000\000\000\000\046\000\047\000\000\000\
\048\000\000\000\000\000\228\002\228\002\228\002\000\000\000\000\
\000\000\228\002\228\002\000\000\000\000\000\000\050\000\000\000\
\000\000\000\000\000\000\051\000\052\000\000\000\054\000\000\000\
\000\000\000\000\000\000\055\000\228\002\228\002\228\002\228\002\
\228\002\000\000\000\000\000\000\000\000\228\002\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\228\002\
\228\002\228\002\000\000\228\002\228\002\228\002\228\002\228\002\
\000\000\000\000\228\002\000\000\000\000\000\000\228\002\228\002\
\228\002\000\000\000\000\000\000\228\002\000\000\228\002\228\002\
\000\000\000\000\000\000\228\002\228\002\000\000\228\002\000\000\
\000\000\000\000\000\000\000\000\228\002\228\002\000\000\228\002\
\000\000\000\000\000\000\010\000\000\000\000\000\000\000\000\000\
\000\000\013\000\000\000\094\003\000\000\228\002\067\002\000\000\
\000\000\000\000\228\002\228\002\000\000\228\002\000\000\000\000\
\095\003\000\000\228\002\017\000\018\000\243\001\000\000\243\001\
\243\001\243\001\000\000\243\001\000\000\000\000\243\001\243\001\
\000\000\000\000\000\000\000\000\000\000\000\000\024\000\025\000\
\026\000\021\002\000\000\164\000\000\000\165\000\166\000\000\000\
\243\001\032\000\000\000\000\000\000\000\000\000\167\000\096\003\
\243\001\243\001\000\000\000\000\000\000\169\000\010\000\000\000\
\243\001\000\000\042\000\000\000\013\000\000\000\066\002\000\000\
\023\002\067\002\000\000\170\000\243\001\243\001\000\000\000\000\
\024\002\000\000\000\000\095\003\000\000\000\000\017\000\018\000\
\171\000\000\000\000\000\000\000\050\000\000\000\000\000\025\002\
\000\000\051\000\000\000\000\000\054\000\172\000\000\000\000\000\
\000\000\024\000\025\000\026\000\021\002\000\000\164\000\000\000\
\165\000\166\000\000\000\000\000\032\000\000\000\000\000\000\000\
\000\000\167\000\096\003\000\000\000\000\000\000\000\000\000\000\
\169\000\010\000\000\000\000\000\000\000\042\000\000\000\013\000\
\000\000\185\003\000\000\023\002\000\000\000\000\170\000\000\000\
\000\000\000\000\000\000\024\002\000\000\000\000\186\003\000\000\
\000\000\017\000\018\000\171\000\000\000\000\000\000\000\050\000\
\000\000\000\000\025\002\000\000\051\000\000\000\000\000\054\000\
\172\000\000\000\000\000\000\000\024\000\025\000\026\000\021\002\
\000\000\164\000\000\000\165\000\166\000\000\000\000\000\032\000\
\000\000\000\000\000\000\000\000\167\000\212\001\000\000\000\000\
\000\000\000\000\000\000\169\000\010\000\000\000\000\000\000\000\
\042\000\000\000\013\000\000\000\146\005\000\000\023\002\000\000\
\000\000\170\000\000\000\000\000\000\000\000\000\024\002\000\000\
\000\000\095\003\000\000\000\000\017\000\018\000\171\000\000\000\
\000\000\000\000\050\000\000\000\000\000\025\002\000\000\051\000\
\000\000\000\000\054\000\172\000\000\000\000\000\000\000\024\000\
\025\000\026\000\021\002\000\000\164\000\000\000\165\000\166\000\
\000\000\000\000\032\000\000\000\000\000\000\000\000\000\167\000\
\096\003\000\000\000\000\000\000\010\000\000\000\169\000\000\000\
\000\000\000\000\013\000\042\000\000\000\000\000\000\000\000\000\
\000\000\023\002\000\000\000\000\170\000\000\000\000\000\000\000\
\000\000\024\002\000\000\000\000\017\000\018\000\000\000\000\000\
\000\000\171\000\000\000\000\000\000\000\050\000\000\000\000\000\
\025\002\000\000\051\000\000\000\000\000\054\000\172\000\024\000\
\025\000\026\000\021\002\000\000\164\000\000\000\165\000\166\000\
\000\000\000\000\032\000\000\000\000\000\000\000\000\000\167\000\
\011\003\000\000\000\000\000\000\010\000\000\000\169\000\000\000\
\012\003\000\000\013\000\042\000\000\000\000\000\000\000\000\000\
\000\000\023\002\000\000\000\000\170\000\000\000\000\000\000\000\
\000\000\024\002\000\000\000\000\017\000\018\000\000\000\000\000\
\000\000\171\000\000\000\000\000\000\000\050\000\000\000\000\000\
\025\002\000\000\051\000\000\000\000\000\054\000\172\000\024\000\
\025\000\026\000\021\002\000\000\164\000\000\000\165\000\166\000\
\000\000\000\000\032\000\000\000\000\000\000\000\000\000\167\000\
\212\001\000\000\000\000\000\000\010\000\000\000\169\000\000\000\
\069\005\000\000\013\000\042\000\000\000\000\000\000\000\000\000\
\000\000\023\002\000\000\000\000\170\000\000\000\000\000\000\000\
\000\000\024\002\000\000\000\000\017\000\018\000\000\000\000\000\
\000\000\171\000\000\000\000\000\000\000\050\000\000\000\000\000\
\025\002\000\000\051\000\000\000\000\000\054\000\172\000\024\000\
\025\000\026\000\021\002\000\000\164\000\000\000\165\000\166\000\
\000\000\000\000\032\000\000\000\000\000\000\000\000\000\167\000\
\022\002\000\000\000\000\000\000\010\000\000\000\169\000\000\000\
\000\000\000\000\013\000\042\000\000\000\000\000\000\000\000\000\
\000\000\023\002\000\000\000\000\170\000\000\000\000\000\000\000\
\000\000\024\002\000\000\000\000\017\000\018\000\000\000\000\000\
\000\000\171\000\000\000\000\000\000\000\050\000\000\000\000\000\
\025\002\000\000\051\000\000\000\000\000\054\000\172\000\024\000\
\025\000\026\000\021\002\000\000\164\000\000\000\165\000\166\000\
\000\000\000\000\032\000\000\000\000\000\000\000\000\000\167\000\
\212\001\000\000\000\000\000\000\228\002\000\000\169\000\000\000\
\000\000\000\000\228\002\042\000\000\000\000\000\000\000\000\000\
\000\000\023\002\000\000\000\000\170\000\000\000\000\000\000\000\
\000\000\024\002\000\000\000\000\228\002\228\002\000\000\000\000\
\000\000\171\000\000\000\000\000\000\000\050\000\000\000\000\000\
\025\002\000\000\051\000\000\000\000\000\054\000\172\000\228\002\
\228\002\228\002\228\002\000\000\228\002\000\000\228\002\228\002\
\000\000\000\000\228\002\000\000\000\000\000\000\000\000\228\002\
\228\002\000\000\000\000\000\000\010\000\000\000\228\002\000\000\
\000\000\000\000\013\000\228\002\000\000\000\000\000\000\000\000\
\000\000\228\002\000\000\000\000\228\002\000\000\000\000\000\000\
\000\000\228\002\162\000\000\000\017\000\018\000\000\000\000\000\
\000\000\228\002\000\000\000\000\000\000\228\002\000\000\000\000\
\228\002\000\000\228\002\000\000\000\000\228\002\228\002\024\000\
\025\000\026\000\000\000\163\000\164\000\000\000\165\000\166\000\
\000\000\000\000\032\000\000\000\000\000\000\000\000\000\167\000\
\168\000\000\000\000\000\000\000\000\000\000\000\169\000\000\000\
\000\000\000\000\010\000\042\000\000\000\000\000\223\001\000\000\
\013\000\000\000\000\000\000\000\170\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\230\000\000\000\000\000\000\000\
\162\000\171\000\017\000\018\000\000\000\050\000\000\000\000\000\
\000\000\000\000\051\000\000\000\000\000\054\000\172\000\000\000\
\000\000\000\000\000\000\000\000\000\000\024\000\025\000\026\000\
\000\000\163\000\164\000\000\000\165\000\166\000\000\000\000\000\
\032\000\000\000\000\000\000\000\000\000\167\000\168\000\000\000\
\000\000\000\000\000\000\000\000\169\000\228\002\000\000\228\002\
\000\000\042\000\000\000\228\002\000\000\000\000\000\000\000\000\
\000\000\000\000\170\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\228\002\000\000\228\002\228\002\171\000\
\000\000\000\000\000\000\050\000\000\000\000\000\000\000\000\000\
\051\000\000\000\000\000\054\000\172\000\000\000\000\000\000\000\
\228\002\228\002\228\002\000\000\228\002\228\002\000\000\228\002\
\228\002\000\000\000\000\228\002\000\000\000\000\000\000\000\000\
\228\002\228\002\000\000\000\000\000\000\228\002\000\000\228\002\
\000\000\000\000\000\000\228\002\228\002\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\228\002\000\000\000\000\
\000\000\000\000\000\000\228\002\000\000\228\002\228\002\000\000\
\000\000\000\000\228\002\000\000\000\000\000\000\228\002\000\000\
\000\000\000\000\000\000\228\002\000\000\000\000\228\002\228\002\
\228\002\228\002\228\002\000\000\228\002\228\002\000\000\228\002\
\228\002\000\000\000\000\228\002\000\000\000\000\000\000\000\000\
\228\002\228\002\000\000\000\000\000\000\000\000\000\000\228\002\
\000\000\000\000\000\000\010\000\228\002\000\000\000\000\000\000\
\000\000\013\000\000\000\000\000\000\000\228\002\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\228\002\000\000\
\000\000\162\000\228\002\017\000\018\000\000\000\228\002\000\000\
\000\000\000\000\000\000\228\002\000\000\000\000\228\002\228\002\
\000\000\000\000\000\000\000\000\000\000\000\000\024\000\025\000\
\026\000\000\000\163\000\164\000\000\000\165\000\166\000\000\000\
\000\000\032\000\000\000\000\000\000\000\000\000\167\000\168\000\
\000\000\000\000\000\000\228\002\000\000\169\000\000\000\000\000\
\000\000\228\002\042\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\170\000\000\000\000\000\000\000\000\000\
\000\000\228\002\000\000\228\002\228\002\000\000\000\000\000\000\
\171\000\000\000\000\000\000\000\050\000\000\000\000\000\000\000\
\000\000\051\000\000\000\000\000\054\000\172\000\228\002\228\002\
\228\002\000\000\228\002\228\002\000\000\228\002\228\002\000\000\
\000\000\228\002\000\000\000\000\000\000\000\000\228\002\228\002\
\000\000\000\000\000\000\161\002\000\000\228\002\000\000\000\000\
\000\000\161\002\228\002\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\228\002\000\000\000\000\000\000\000\000\
\000\000\161\002\000\000\161\002\161\002\000\000\000\000\000\000\
\228\002\000\000\000\000\000\000\228\002\000\000\000\000\000\000\
\000\000\228\002\000\000\000\000\228\002\228\002\161\002\161\002\
\161\002\000\000\161\002\161\002\000\000\161\002\161\002\000\000\
\000\000\161\002\000\000\000\000\000\000\000\000\161\002\161\002\
\000\000\000\000\000\000\142\002\000\000\161\002\000\000\000\000\
\000\000\142\002\161\002\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\161\002\000\000\000\000\000\000\000\000\
\000\000\142\002\000\000\142\002\142\002\000\000\000\000\000\000\
\161\002\000\000\000\000\000\000\161\002\000\000\000\000\000\000\
\000\000\161\002\000\000\000\000\161\002\161\002\142\002\142\002\
\142\002\000\000\142\002\142\002\000\000\142\002\142\002\000\000\
\000\000\142\002\000\000\000\000\000\000\000\000\142\002\142\002\
\000\000\000\000\000\000\010\000\000\000\142\002\000\000\000\000\
\000\000\013\000\142\002\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\142\002\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\017\000\018\000\000\000\000\000\000\000\
\142\002\000\000\000\000\000\000\142\002\000\000\000\000\000\000\
\000\000\142\002\000\000\000\000\142\002\142\002\024\000\025\000\
\026\000\000\000\000\000\164\000\000\000\165\000\166\000\000\000\
\000\000\032\000\000\000\000\000\000\000\000\000\167\000\212\001\
\000\000\000\000\000\000\000\000\000\000\169\000\010\000\011\000\
\000\000\000\000\042\000\012\000\013\000\000\000\000\000\000\000\
\000\000\000\000\000\000\170\000\000\000\000\000\124\001\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\017\000\018\000\
\171\000\000\000\000\000\000\000\050\000\000\000\000\000\000\000\
\000\000\051\000\000\000\000\000\054\000\172\000\000\000\000\000\
\000\000\024\000\025\000\026\000\125\001\000\000\028\000\029\000\
\030\000\031\000\000\000\000\000\032\000\000\000\000\000\000\000\
\000\000\167\000\192\000\000\000\000\000\010\000\011\000\000\000\
\000\000\000\000\012\000\013\000\000\000\042\000\043\000\000\000\
\000\000\000\000\000\000\126\001\000\000\000\000\000\000\000\000\
\000\000\048\000\000\000\127\001\000\000\017\000\018\000\000\000\
\000\000\000\000\000\000\128\001\129\001\000\000\000\000\050\000\
\000\000\000\000\130\001\000\000\051\000\000\000\000\000\054\000\
\024\000\025\000\026\000\125\001\000\000\028\000\029\000\030\000\
\031\000\000\000\000\000\032\000\000\000\000\000\000\000\000\000\
\167\000\192\000\000\000\000\000\010\000\011\000\000\000\000\000\
\000\000\012\000\013\000\000\000\042\000\043\000\000\000\000\000\
\000\000\000\000\126\001\000\000\000\000\000\000\000\000\000\000\
\048\000\000\000\127\001\000\000\017\000\018\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\050\000\000\000\
\000\000\130\001\000\000\051\000\000\000\000\000\054\000\024\000\
\025\000\026\000\000\000\000\000\028\000\029\000\030\000\031\000\
\000\000\000\000\032\000\000\000\000\000\000\000\000\000\167\000\
\192\000\000\000\000\000\010\000\011\000\000\000\000\000\000\000\
\012\000\013\000\000\000\042\000\043\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\048\000\
\000\000\000\000\000\000\017\000\018\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\050\000\000\000\000\000\
\000\000\000\000\051\000\000\000\000\000\054\000\024\000\025\000\
\026\000\000\000\000\000\028\000\029\000\030\000\031\000\000\000\
\000\000\032\000\000\000\000\000\000\000\000\000\219\000\192\000\
\000\000\000\000\228\002\228\002\000\000\000\000\000\000\228\002\
\228\002\000\000\042\000\043\000\000\000\000\000\000\000\000\000\
\000\000\000\000\144\004\000\000\000\000\000\000\048\000\000\000\
\000\000\200\000\228\002\228\002\137\000\000\000\138\000\139\000\
\032\000\145\004\140\000\000\000\050\000\141\000\142\000\000\000\
\201\000\051\000\000\000\000\000\054\000\228\002\228\002\228\002\
\000\000\000\000\228\002\228\002\228\002\228\002\000\000\143\000\
\228\002\000\000\000\000\000\000\000\000\228\002\228\002\144\000\
\144\003\000\000\137\000\000\000\138\000\139\000\032\000\146\000\
\140\000\228\002\228\002\141\000\146\004\000\000\000\000\000\000\
\000\000\144\004\183\005\147\000\148\000\228\002\000\000\000\000\
\200\000\000\000\000\000\000\000\000\000\143\000\000\000\000\000\
\000\000\000\000\000\000\228\002\147\004\144\000\145\000\201\000\
\228\002\000\000\000\000\228\002\000\000\146\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\203\000\000\000\
\000\000\148\004\148\000\000\000\000\000\000\000\000\000\000\000\
\000\000\137\000\000\000\138\000\139\000\032\000\000\000\140\000\
\000\000\000\000\141\000\146\004\000\000\000\000\000\000\000\000\
\211\003\087\001\088\001\000\000\000\000\000\000\000\000\000\000\
\000\000\089\001\000\000\000\000\143\000\000\000\212\003\090\001\
\091\001\213\003\092\001\000\000\144\000\145\000\000\000\000\000\
\000\000\000\000\000\000\093\001\146\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\094\001\203\000\000\000\000\000\
\148\004\148\000\095\001\096\001\097\001\098\001\099\001\035\001\
\036\001\037\001\000\000\000\000\000\000\000\000\225\001\000\000\
\039\001\000\000\000\000\000\000\000\000\000\000\100\001\041\001\
\000\000\000\000\000\000\185\000\000\000\000\000\000\000\000\000\
\101\001\102\001\042\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\043\001\103\001\104\001\105\001\106\001\
\107\001\044\001\045\001\046\001\047\001\048\001\000\000\000\000\
\214\003\000\000\000\000\000\000\000\000\000\000\109\001\000\000\
\000\000\000\000\000\000\000\000\000\000\049\001\000\000\000\000\
\000\000\087\001\088\001\000\000\000\000\000\000\000\000\016\002\
\228\001\089\001\017\002\000\000\000\000\000\000\000\000\090\001\
\091\001\000\000\092\001\053\001\054\001\018\002\231\001\057\001\
\232\001\000\000\000\000\093\001\000\000\000\000\000\000\000\000\
\000\000\087\001\088\001\060\001\094\001\061\001\000\000\000\000\
\000\000\089\001\095\001\096\001\097\001\098\001\099\001\090\001\
\091\001\000\000\092\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\093\001\000\000\000\000\100\001\000\000\
\000\000\000\000\000\000\185\000\094\001\000\000\000\000\000\000\
\101\001\102\001\095\001\096\001\097\001\098\001\099\001\000\000\
\000\000\000\000\000\000\000\000\103\001\104\001\105\001\106\001\
\107\001\000\000\000\000\000\000\000\000\000\000\100\001\087\001\
\088\001\108\001\000\000\185\000\000\000\000\000\109\001\089\001\
\101\001\102\001\000\000\000\000\000\000\090\001\091\001\000\000\
\092\001\000\000\000\000\000\000\103\001\104\001\105\001\106\001\
\107\001\093\001\000\000\000\000\000\000\016\004\000\000\087\001\
\088\001\000\000\094\001\000\000\000\000\000\000\109\001\089\001\
\095\001\096\001\097\001\098\001\099\001\090\001\091\001\000\000\
\092\001\000\000\000\000\000\000\000\000\000\000\000\000\114\004\
\000\000\093\001\000\000\000\000\100\001\000\000\000\000\000\000\
\000\000\185\000\094\001\000\000\000\000\000\000\101\001\102\001\
\095\001\096\001\097\001\098\001\099\001\000\000\000\000\000\000\
\000\000\000\000\103\001\104\001\105\001\106\001\107\001\000\000\
\000\000\000\000\000\000\063\004\100\001\087\001\088\001\000\000\
\000\000\185\000\000\000\000\000\109\001\089\001\101\001\102\001\
\000\000\000\000\000\000\090\001\091\001\000\000\092\001\000\000\
\000\000\000\000\103\001\104\001\105\001\106\001\107\001\093\001\
\000\000\000\000\000\000\000\000\000\000\087\001\088\001\000\000\
\094\001\000\000\000\000\000\000\109\001\089\001\095\001\096\001\
\097\001\098\001\099\001\090\001\091\001\000\000\126\004\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\093\001\
\000\000\000\000\100\001\000\000\000\000\000\000\000\000\185\000\
\094\001\000\000\000\000\000\000\101\001\102\001\095\001\096\001\
\097\001\098\001\099\001\000\000\000\000\000\000\000\000\000\000\
\103\001\104\001\105\001\106\001\107\001\000\000\000\000\000\000\
\000\000\000\000\100\001\234\000\234\000\000\000\000\000\185\000\
\000\000\000\000\109\001\234\000\101\001\102\001\000\000\000\000\
\000\000\234\000\234\000\000\000\000\000\000\000\000\000\000\000\
\103\001\104\001\105\001\106\001\107\001\234\000\000\000\000\000\
\000\000\000\000\000\000\087\001\088\001\000\000\234\000\000\000\
\000\000\000\000\109\001\089\001\234\000\234\000\234\000\234\000\
\234\000\090\001\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\093\001\000\000\000\000\
\234\000\000\000\000\000\000\000\000\000\234\000\094\001\000\000\
\000\000\000\000\234\000\234\000\095\001\096\001\097\001\098\001\
\099\001\000\000\000\000\000\000\000\000\000\000\234\000\234\000\
\234\000\234\000\234\000\000\000\000\000\000\000\000\000\234\000\
\100\001\087\001\088\001\000\000\000\000\185\000\000\000\000\000\
\234\000\089\001\101\001\102\001\000\000\000\000\000\000\090\001\
\000\000\000\000\000\000\000\000\000\000\000\000\103\001\104\001\
\105\001\106\001\107\001\093\001\000\000\000\000\000\000\000\000\
\000\000\000\000\082\005\000\000\094\001\000\000\000\000\000\000\
\109\001\000\000\095\001\096\001\097\001\098\001\099\001\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\087\001\088\001\
\000\000\000\000\000\000\000\000\000\000\000\000\100\001\000\000\
\000\000\000\000\000\000\185\000\090\001\000\000\000\000\000\000\
\101\001\102\001\000\000\000\000\000\000\000\000\000\000\000\000\
\093\001\000\000\000\000\000\000\103\001\104\001\105\001\106\001\
\107\001\094\001\000\000\000\000\000\000\000\000\000\000\095\001\
\096\001\097\001\098\001\099\001\000\000\000\000\109\001\000\000\
\000\000\000\000\000\000\000\000\137\000\000\000\138\000\139\000\
\032\000\000\000\140\000\100\001\000\000\141\000\142\000\000\000\
\185\000\000\000\000\000\000\000\000\000\101\001\102\001\192\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\143\000\
\000\000\000\000\104\001\105\001\106\001\107\001\000\000\144\000\
\145\000\000\000\000\000\000\000\000\000\000\000\000\000\146\000\
\000\000\000\000\000\000\109\001\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\147\000\148\000"

let yycheck = "\003\000\
\004\000\094\000\006\000\002\000\146\000\002\000\062\001\015\000\
\131\001\163\000\137\000\014\002\143\000\164\000\033\001\010\000\
\137\000\186\002\192\001\029\000\158\000\013\003\139\000\009\002\
\209\000\009\000\178\001\213\000\012\000\097\003\127\003\031\000\
\036\000\171\000\143\001\019\000\020\000\021\000\022\000\086\002\
\011\000\055\003\243\002\027\000\186\002\012\002\212\000\014\002\
\166\004\001\000\034\000\003\000\004\000\002\000\038\000\209\000\
\012\004\028\000\033\000\043\000\044\000\232\000\037\000\234\000\
\003\000\004\000\111\001\002\000\052\000\007\000\000\000\055\000\
\059\000\000\000\147\004\000\000\002\000\048\000\012\002\132\000\
\014\002\134\000\073\004\031\001\098\000\138\004\139\004\095\000\
\003\000\002\000\140\001\188\004\001\000\210\000\066\004\017\001\
\110\000\049\000\002\000\098\000\002\000\098\000\085\004\067\001\
\197\000\001\002\002\002\059\000\065\001\000\000\015\001\110\000\
\083\000\110\000\085\000\086\000\064\001\000\001\037\001\015\002\
\248\003\000\001\052\001\007\001\004\001\067\001\130\000\122\000\
\008\001\151\004\140\000\010\001\096\001\090\001\000\001\015\001\
\023\004\154\004\018\001\005\000\049\000\183\001\000\001\185\001\
\000\001\137\000\065\001\000\001\007\001\098\000\145\000\134\004\
\000\001\117\001\096\001\000\001\000\001\114\001\172\003\000\001\
\000\001\110\000\067\001\098\000\036\004\000\001\150\000\074\002\
\000\001\017\001\010\001\078\002\098\000\000\001\096\001\110\000\
\128\000\018\005\130\000\008\001\132\000\094\003\134\000\069\001\
\110\000\098\000\000\001\067\001\192\000\128\000\174\000\130\000\
\196\000\132\000\098\000\134\000\098\000\110\000\212\003\213\003\
\000\001\000\001\174\004\187\000\000\001\046\005\110\000\211\000\
\110\000\067\001\185\000\186\000\065\001\096\001\008\002\130\000\
\000\001\188\000\000\001\210\004\065\001\065\001\000\001\076\002\
\162\000\132\002\067\001\165\000\166\000\124\001\114\001\215\000\
\142\001\065\001\217\004\115\001\014\001\093\001\096\001\009\000\
\178\000\179\000\012\000\009\005\227\004\111\001\007\005\218\000\
\096\001\019\000\020\000\021\000\022\000\139\003\094\001\096\001\
\017\005\027\000\111\001\117\001\000\001\096\001\214\000\079\001\
\136\004\094\001\111\001\111\001\038\000\096\001\208\000\067\001\
\061\002\043\000\044\000\190\001\117\001\094\005\004\001\111\001\
\094\001\118\001\052\000\120\001\045\005\055\000\024\001\000\001\
\004\001\067\001\065\001\066\001\008\001\093\001\093\001\000\000\
\000\001\097\001\097\001\015\001\096\001\022\001\018\001\190\004\
\032\001\214\000\159\002\222\001\000\002\224\001\014\001\093\001\
\096\001\017\001\003\001\097\001\191\001\065\001\096\001\000\001\
\022\001\183\005\208\001\038\001\000\001\162\001\000\001\075\001\
\067\001\064\005\078\001\206\001\219\004\004\001\030\001\031\001\
\111\001\008\001\000\001\133\002\134\002\102\005\069\005\058\001\
\015\001\000\001\000\001\018\001\074\001\000\001\081\001\067\001\
\026\001\093\001\250\002\083\001\117\005\097\001\074\001\010\001\
\108\001\080\001\036\002\000\001\112\001\000\001\005\002\103\004\
\064\001\107\001\068\001\015\001\166\002\170\001\128\001\172\001\
\173\005\174\001\032\002\021\002\069\004\094\001\071\004\255\004\
\026\002\081\001\030\001\145\001\154\005\119\003\092\001\026\001\
\096\001\055\003\010\005\084\004\067\001\183\002\067\001\115\001\
\051\003\093\002\145\001\077\002\145\001\000\001\000\001\165\004\
\000\001\067\001\125\001\126\001\093\001\129\005\129\001\115\005\
\131\001\047\004\094\001\147\001\094\001\022\001\066\001\000\001\
\000\001\000\001\027\001\000\001\018\001\111\001\027\003\093\001\
\063\005\010\001\000\001\010\001\000\001\000\001\096\001\093\001\
\176\001\096\001\073\005\094\001\017\001\000\001\097\001\183\001\
\003\001\185\001\178\001\181\003\145\001\244\003\008\001\128\002\
\000\001\000\001\043\005\096\001\018\001\037\001\017\001\089\002\
\108\001\193\001\145\001\111\001\065\003\035\001\008\001\207\001\
\028\005\037\001\170\001\145\001\172\001\015\001\174\001\190\003\
\191\003\008\001\036\001\211\001\136\002\243\004\128\002\170\001\
\145\001\172\001\000\001\174\001\030\001\221\001\060\001\126\005\
\150\002\145\001\093\001\145\001\066\001\000\001\096\001\239\004\
\096\001\233\001\146\003\185\003\000\001\000\001\172\003\010\001\
\190\003\191\003\203\004\112\003\054\001\094\001\032\001\094\001\
\097\001\097\001\097\001\096\001\252\001\253\001\000\001\124\003\
\066\001\001\002\002\002\094\001\012\002\097\001\014\002\132\003\
\094\001\163\002\104\001\000\001\094\001\096\001\000\001\015\002\
\008\001\111\001\177\005\022\001\020\002\047\002\212\003\213\003\
\096\001\096\001\028\004\000\001\008\001\015\001\018\001\014\001\
\000\002\191\004\034\002\015\001\246\001\247\001\248\001\094\001\
\194\002\242\002\108\001\210\002\254\001\111\001\066\001\067\001\
\195\002\196\002\030\001\188\003\232\002\027\001\006\001\008\001\
\094\001\018\001\092\001\059\002\066\001\052\002\008\001\027\001\
\064\002\065\001\066\001\094\001\074\001\098\005\097\001\097\002\
\242\002\023\004\028\002\094\001\096\001\023\003\112\001\000\001\
\100\002\067\001\098\002\099\002\209\003\016\001\066\001\018\001\
\018\001\022\001\036\001\093\001\246\002\067\001\000\001\018\001\
\099\001\100\001\018\001\013\003\054\002\022\001\094\001\022\001\
\093\001\174\002\027\001\061\002\096\001\096\002\096\001\019\001\
\008\001\096\001\117\001\014\001\022\001\137\002\138\002\015\001\
\093\001\027\001\000\001\073\004\153\005\093\002\126\002\081\002\
\108\001\030\001\042\004\111\001\096\001\014\004\030\001\096\001\
\014\001\019\002\040\005\047\001\042\005\094\001\094\001\117\001\
\090\003\018\001\157\002\000\000\094\001\014\001\018\001\151\002\
\097\003\061\001\018\001\056\001\087\003\088\003\089\003\092\001\
\018\001\069\001\188\002\071\001\094\001\066\001\035\004\066\001\
\067\001\115\003\066\001\053\002\093\001\096\001\094\001\183\002\
\097\001\022\001\099\001\100\001\099\001\100\001\004\001\097\003\
\066\002\067\002\063\003\093\001\066\001\067\001\201\002\097\001\
\022\001\099\001\100\001\027\001\117\001\096\001\023\001\076\003\
\235\003\220\004\237\003\238\003\027\001\113\001\174\002\108\001\
\003\001\027\001\111\001\117\001\108\001\233\002\234\002\111\001\
\081\001\022\001\096\001\174\002\000\001\094\001\222\002\096\001\
\224\002\027\001\226\002\227\002\096\001\027\001\094\001\165\004\
\096\001\164\003\008\001\255\002\066\001\220\004\096\001\019\001\
\190\004\015\001\023\001\188\003\067\001\067\001\026\001\092\001\
\012\003\136\003\250\002\153\003\027\001\207\002\254\002\008\001\
\030\001\211\002\149\003\019\001\210\004\066\001\015\001\192\005\
\096\001\090\001\096\001\047\001\048\001\219\004\220\004\015\003\
\017\001\059\002\188\003\027\001\003\001\030\001\096\001\008\001\
\054\001\061\001\164\002\000\001\065\001\231\003\066\001\002\001\
\032\003\069\001\192\005\071\001\066\001\000\001\096\001\110\001\
\004\001\003\001\096\001\114\001\008\001\019\001\036\001\047\003\
\048\003\003\003\014\001\015\001\068\001\243\004\018\001\193\002\
\019\001\066\001\058\003\074\003\060\003\074\003\008\001\026\001\
\084\003\096\001\067\001\067\003\068\003\014\004\081\003\071\003\
\092\003\047\001\048\001\095\003\014\001\113\001\108\001\217\002\
\119\003\111\001\014\001\068\001\047\001\048\001\067\001\061\001\
\096\001\027\001\229\004\014\001\065\001\066\001\063\001\069\001\
\067\001\071\001\061\001\108\001\014\004\013\005\111\001\067\001\
\027\001\068\001\069\001\097\001\071\001\067\001\068\001\000\000\
\000\001\063\005\064\005\014\001\004\001\065\001\029\004\000\000\
\008\001\003\001\068\001\073\005\014\001\125\003\014\001\015\001\
\136\003\035\001\018\001\131\003\096\001\144\003\066\001\067\001\
\117\001\027\001\083\004\113\001\051\004\098\001\181\003\081\001\
\003\001\093\001\146\003\000\001\065\001\066\001\113\001\004\001\
\152\003\161\003\060\001\008\001\065\001\010\001\081\001\117\001\
\066\001\014\001\015\001\163\003\055\004\018\001\166\003\066\001\
\015\001\083\004\114\001\018\001\183\003\027\001\027\001\175\003\
\126\005\098\001\022\001\067\001\092\005\000\000\069\004\191\003\
\082\004\205\003\206\003\012\001\069\004\103\004\014\001\081\001\
\104\005\045\001\046\001\112\001\094\004\197\003\104\001\219\003\
\181\005\182\005\111\001\027\001\008\001\111\001\031\001\113\001\
\096\001\065\001\210\003\155\001\094\003\067\001\067\001\215\003\
\236\003\171\003\186\003\101\003\067\001\074\001\066\001\013\001\
\049\001\050\001\051\001\177\005\000\001\229\003\065\001\093\001\
\003\001\085\001\065\001\097\001\092\001\218\005\028\001\029\001\
\093\001\094\001\066\001\096\001\097\001\076\001\010\004\072\001\
\160\005\161\005\102\001\041\001\077\001\207\003\026\001\111\001\
\004\001\001\004\000\000\029\004\008\001\086\001\115\001\014\001\
\099\001\027\001\005\000\011\004\007\000\040\001\018\001\061\001\
\067\001\227\003\064\001\091\005\111\001\222\004\103\001\069\001\
\024\004\025\004\194\005\114\001\023\000\075\001\004\001\000\001\
\032\004\243\003\008\001\065\001\082\001\048\004\038\004\096\001\
\065\001\015\001\042\004\035\001\018\001\096\001\000\001\022\001\
\216\005\067\001\019\001\056\001\222\004\027\001\111\001\060\001\
\010\001\026\001\027\001\059\004\065\001\069\004\230\005\067\001\
\110\001\000\000\117\001\092\001\060\001\239\004\074\001\014\001\
\065\001\090\001\066\001\080\001\065\001\077\004\047\001\048\001\
\065\001\111\001\102\004\028\005\027\001\105\004\111\001\112\001\
\226\003\089\004\094\001\066\001\061\001\067\001\232\003\065\001\
\234\003\114\001\065\001\068\001\069\001\096\000\071\001\090\004\
\124\004\125\004\111\001\065\001\246\003\065\001\000\000\000\001\
\104\001\022\001\028\005\115\004\031\001\085\004\111\001\111\001\
\144\004\027\001\111\001\066\001\013\001\092\001\111\001\112\001\
\128\004\099\001\130\004\131\004\132\004\157\004\049\001\050\001\
\051\001\026\001\027\001\028\001\029\001\111\001\137\000\088\005\
\113\001\112\001\065\001\142\000\143\000\149\004\000\001\171\004\
\041\001\111\001\056\001\111\001\027\001\065\001\022\001\068\001\
\058\005\067\001\077\001\065\001\188\004\065\001\134\004\162\000\
\163\000\071\005\165\000\166\000\061\001\168\000\088\005\064\001\
\026\001\065\001\067\001\068\001\069\001\000\001\000\001\178\000\
\179\000\004\001\075\001\187\004\065\001\008\001\004\001\010\001\
\111\001\082\001\008\001\014\001\067\001\031\001\065\001\018\001\
\014\001\015\001\066\001\111\001\018\001\094\001\206\004\096\001\
\027\001\098\001\099\001\111\001\220\004\208\000\209\000\049\001\
\050\001\051\001\213\000\037\001\240\004\110\001\104\004\111\001\
\113\001\225\004\108\004\065\001\117\001\102\001\000\005\027\001\
\035\001\003\005\234\004\005\005\004\001\004\001\238\004\027\001\
\008\001\008\001\229\004\077\001\111\001\022\001\200\004\015\001\
\016\005\217\004\018\001\018\001\252\004\067\001\065\001\074\001\
\065\001\060\001\000\001\227\004\065\001\066\001\004\001\066\001\
\008\005\147\004\008\001\072\001\010\001\013\005\027\001\067\001\
\014\001\111\001\093\001\094\001\044\005\096\001\097\001\067\001\
\004\001\086\001\000\000\027\005\008\001\027\001\168\004\092\001\
\032\005\066\001\000\001\015\001\000\001\096\001\018\001\065\001\
\115\001\022\001\035\001\067\001\111\001\104\001\111\001\062\005\
\114\001\062\005\111\001\112\001\111\001\053\005\067\001\000\001\
\075\001\052\001\078\005\059\005\086\005\087\005\026\001\172\005\
\090\005\065\005\003\001\060\001\054\001\095\005\056\001\037\001\
\065\001\066\001\212\004\067\001\074\001\077\005\013\001\065\001\
\066\001\026\001\075\001\083\005\067\001\111\001\018\001\067\001\
\000\001\081\001\110\005\110\001\092\005\028\001\029\001\093\001\
\094\001\072\001\096\001\097\001\100\005\069\005\085\001\040\001\
\104\005\131\005\041\001\019\001\101\001\109\005\000\000\086\001\
\250\004\000\001\026\001\027\001\111\001\115\001\111\001\022\001\
\000\001\121\005\092\001\013\001\027\001\111\001\061\001\000\001\
\111\001\064\001\150\005\090\001\014\005\067\001\069\001\047\001\
\048\001\137\005\028\001\029\001\075\001\023\001\112\001\163\005\
\026\005\171\005\026\001\082\001\143\001\061\001\037\001\041\001\
\000\001\026\001\036\001\114\001\068\001\069\001\023\001\071\001\
\160\005\161\005\004\001\098\001\099\001\056\001\008\001\096\001\
\168\005\051\005\190\005\061\001\033\001\015\001\064\001\110\001\
\018\001\203\005\204\005\069\001\000\001\176\001\067\001\065\001\
\184\005\075\001\014\001\187\005\183\001\037\001\185\001\211\005\
\082\001\193\005\194\005\056\001\191\001\000\001\066\001\060\001\
\085\001\113\001\000\001\064\001\065\001\066\001\026\001\065\001\
\098\001\099\001\000\001\206\001\207\001\213\005\234\005\227\003\
\216\005\212\001\076\001\080\001\110\001\221\005\022\001\026\001\
\224\005\067\001\000\000\097\001\026\001\229\005\230\005\243\003\
\232\005\233\005\066\001\093\001\026\001\099\001\100\001\027\001\
\072\001\097\001\000\001\066\001\027\001\054\001\128\005\056\001\
\000\001\072\001\111\001\246\001\247\001\248\001\086\001\117\001\
\065\001\066\001\004\001\254\001\018\001\033\001\008\001\086\001\
\146\005\014\001\148\005\019\001\017\001\015\001\097\001\000\000\
\018\001\012\002\026\001\014\002\158\005\022\001\027\001\065\001\
\019\002\027\001\021\002\022\002\056\001\022\001\000\001\026\002\
\060\001\028\002\076\001\095\001\064\001\065\001\066\001\047\001\
\048\001\036\002\111\001\181\005\182\005\000\001\111\001\040\001\
\096\001\019\001\188\005\016\001\080\001\061\001\095\001\010\001\
\026\001\066\001\053\002\054\002\068\001\069\001\027\001\071\001\
\111\001\067\001\061\002\205\005\066\001\110\001\111\001\066\002\
\067\002\003\001\212\005\000\001\074\001\047\001\048\001\067\001\
\218\005\076\002\077\002\111\001\222\005\010\001\081\002\075\001\
\111\001\227\005\228\005\061\001\004\001\096\001\082\001\110\001\
\008\001\085\001\068\001\069\001\041\002\071\001\065\001\015\001\
\045\002\113\001\018\001\065\001\111\001\112\001\000\001\001\001\
\002\001\003\001\000\001\027\001\065\001\066\001\008\001\009\001\
\010\001\111\001\008\001\013\001\014\001\014\001\016\001\017\001\
\018\001\019\001\020\001\021\001\000\000\128\002\024\001\025\001\
\026\001\027\001\028\001\029\001\066\001\067\001\068\001\113\001\
\095\001\111\001\036\001\037\001\065\001\066\001\040\001\041\001\
\042\001\043\001\094\001\067\001\008\001\047\001\048\001\110\001\
\111\001\066\001\067\001\000\001\159\002\067\001\068\001\000\001\
\014\001\164\002\036\001\061\001\062\001\097\001\064\001\024\002\
\025\002\067\001\068\001\069\001\074\001\071\001\019\001\014\001\
\074\001\075\001\019\001\022\001\183\002\026\001\111\001\186\002\
\082\001\026\001\084\001\092\001\022\001\027\001\193\002\000\001\
\195\002\196\002\097\001\093\001\094\001\097\001\096\001\097\001\
\098\001\099\001\047\001\048\001\207\002\096\001\047\001\105\001\
\211\002\107\001\019\001\000\001\110\001\065\001\217\002\113\001\
\061\001\026\001\000\001\117\001\061\001\003\001\000\000\068\001\
\069\001\111\001\071\001\068\001\069\001\105\001\071\001\013\001\
\014\001\094\001\111\001\094\001\066\001\094\001\047\001\242\002\
\243\002\096\001\117\001\027\001\026\001\027\001\028\001\029\001\
\117\001\020\001\046\001\014\001\061\001\065\001\022\001\063\001\
\003\003\081\001\040\001\041\001\069\001\065\001\071\001\000\001\
\011\003\014\001\013\003\004\001\113\001\014\001\022\001\008\001\
\113\001\010\001\002\001\074\001\023\003\014\001\015\001\061\001\
\027\003\018\001\064\001\076\000\066\001\067\001\068\001\069\001\
\117\001\096\001\027\001\074\001\102\001\075\001\054\001\055\001\
\056\001\057\001\015\001\000\000\082\001\066\001\094\001\065\001\
\113\001\065\001\066\001\092\001\074\001\102\001\096\001\065\001\
\094\001\094\001\096\001\108\000\098\001\099\001\065\003\065\001\
\008\001\014\001\000\001\027\001\088\001\027\001\027\001\030\001\
\110\001\065\001\067\001\113\001\065\001\126\000\014\001\117\001\
\094\001\074\001\111\001\003\001\133\000\019\001\000\000\090\003\
\014\001\088\001\049\001\094\003\026\001\096\003\097\003\111\001\
\065\001\006\001\101\003\110\001\093\001\094\001\074\001\096\001\
\097\001\111\001\065\001\066\001\027\001\112\003\097\001\096\001\
\115\003\047\001\048\001\103\001\027\001\014\001\096\001\065\001\
\096\001\124\003\115\001\040\001\000\001\090\001\021\001\061\001\
\004\001\132\003\065\001\027\001\008\001\136\003\010\001\069\001\
\139\003\071\001\014\001\015\001\065\001\063\001\063\001\016\001\
\103\001\013\001\149\003\063\001\014\001\108\001\003\001\027\001\
\111\001\054\001\055\001\056\001\057\001\014\001\161\003\066\001\
\028\001\029\001\065\001\027\001\065\001\066\001\215\000\096\001\
\171\003\074\001\102\001\054\001\096\001\041\001\074\001\008\001\
\022\001\000\000\096\001\113\001\016\001\096\001\185\003\186\003\
\076\001\188\003\076\001\190\003\191\003\027\001\096\001\067\001\
\007\000\061\001\074\001\027\001\014\001\020\001\074\001\090\001\
\000\001\069\001\114\001\096\001\207\003\074\001\209\003\075\001\
\023\000\096\001\111\001\065\001\114\001\028\000\082\001\014\001\
\093\001\093\001\094\001\019\001\096\001\097\001\000\001\226\003\
\227\003\003\001\026\001\074\001\231\003\232\003\098\001\234\003\
\021\001\014\001\014\001\013\001\014\001\014\001\014\001\115\001\
\243\003\027\001\110\001\246\003\019\001\113\001\090\001\047\001\
\026\001\027\001\028\001\029\001\001\000\002\000\003\000\004\000\
\005\000\006\000\007\000\114\001\014\001\061\001\040\001\041\001\
\027\001\093\001\014\001\014\004\068\001\069\001\022\001\071\001\
\015\001\014\001\000\000\014\001\023\004\097\001\000\000\000\000\
\111\001\098\001\098\001\061\001\094\001\111\001\064\001\008\001\
\035\004\082\001\068\001\069\001\065\001\094\001\036\001\092\001\
\036\001\075\001\094\001\000\001\047\004\044\001\045\001\046\001\
\082\001\096\001\074\001\008\001\055\004\054\001\065\001\022\001\
\013\001\113\001\065\001\065\001\094\001\054\001\096\001\066\004\
\098\001\099\001\069\004\093\001\071\004\026\001\073\004\028\001\
\029\001\072\001\073\001\146\000\110\001\065\001\065\001\113\001\
\083\004\084\004\085\004\117\001\041\001\065\001\085\001\086\001\
\087\001\088\001\065\001\162\000\163\000\164\000\165\000\166\000\
\065\001\168\000\147\001\013\001\103\004\104\004\128\000\102\001\
\061\001\108\004\028\004\178\000\179\000\222\004\067\001\068\001\
\069\001\090\004\028\001\029\001\086\004\142\001\075\001\128\005\
\088\005\056\005\171\001\199\003\009\003\082\001\056\001\041\001\
\058\001\059\001\060\001\134\004\062\001\096\002\164\001\065\001\
\066\001\208\000\209\000\130\001\255\001\098\001\213\000\146\004\
\147\004\097\002\207\003\061\001\061\002\210\002\064\001\166\000\
\098\004\110\001\099\000\069\001\113\001\102\003\192\005\188\004\
\031\004\075\001\092\001\018\005\207\001\168\004\255\255\000\000\
\082\001\099\001\198\004\174\004\007\000\188\002\255\255\255\255\
\011\000\000\001\255\255\255\255\003\001\111\001\112\001\255\255\
\098\001\099\001\255\255\190\004\191\004\255\255\013\001\255\255\
\255\255\028\000\017\001\255\255\110\001\200\004\255\255\022\001\
\203\004\255\255\255\255\026\001\027\001\028\001\029\001\210\004\
\255\255\212\004\255\255\255\255\255\255\048\000\217\004\255\255\
\219\004\220\004\041\001\222\004\255\255\255\255\255\255\255\255\
\227\004\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\239\004\052\001\061\001\255\255\
\255\255\064\001\255\255\066\001\067\001\068\001\069\001\250\004\
\083\000\255\255\085\000\086\000\075\001\255\255\069\001\255\255\
\255\255\072\001\255\255\082\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\014\005\255\255\255\255\255\255\094\001\
\255\255\096\001\000\001\098\001\099\001\255\255\004\001\026\005\
\255\255\028\005\008\001\255\255\010\001\255\255\079\002\110\001\
\014\001\000\001\113\001\084\002\018\001\040\005\117\001\042\005\
\111\001\255\255\255\255\255\255\255\255\027\001\255\255\255\255\
\051\005\255\255\255\255\255\255\019\001\124\001\255\255\000\000\
\255\255\255\255\255\255\026\001\063\005\064\005\255\255\255\255\
\255\255\255\255\069\005\255\255\255\255\255\255\073\005\162\000\
\163\000\255\255\165\000\166\000\255\255\168\000\127\002\255\255\
\047\001\048\001\255\255\255\255\255\255\088\005\255\255\178\000\
\179\000\255\255\255\255\255\255\074\001\164\001\061\001\255\255\
\255\255\188\000\255\255\255\255\255\255\255\255\069\001\255\255\
\071\001\255\255\255\255\255\255\255\255\255\255\255\255\093\001\
\094\001\162\002\096\001\097\001\255\255\208\000\209\000\255\255\
\255\255\255\255\255\255\126\005\255\255\128\005\129\005\218\000\
\255\255\255\255\255\255\255\255\255\255\115\001\255\255\255\255\
\255\255\208\001\255\255\255\255\255\255\212\001\255\255\146\005\
\255\255\148\005\113\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\158\005\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\000\001\
\255\255\255\255\003\001\255\255\255\255\255\255\177\005\246\001\
\247\001\248\001\181\005\182\005\013\001\255\255\255\255\254\001\
\255\255\188\005\000\001\255\255\255\255\192\005\005\002\255\255\
\255\255\026\001\027\001\028\001\029\001\255\255\013\002\255\255\
\255\255\000\000\205\005\038\001\253\002\019\001\021\002\022\002\
\041\001\212\005\255\255\026\002\026\001\028\002\255\255\218\005\
\255\255\255\255\255\255\222\005\255\255\036\002\255\255\058\001\
\227\005\228\005\041\002\255\255\061\001\255\255\045\002\255\255\
\255\255\047\001\255\255\068\001\069\001\255\255\255\255\054\002\
\000\000\255\255\075\001\255\255\255\255\255\255\061\002\061\001\
\006\001\082\001\008\001\255\255\255\255\255\255\068\001\069\001\
\255\255\071\001\255\255\255\255\053\003\255\255\077\002\096\001\
\255\255\098\001\081\002\255\255\255\255\255\255\255\255\064\003\
\255\255\066\003\255\255\255\255\111\001\110\001\255\255\255\255\
\113\001\096\002\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\125\001\126\001\255\255\255\255\129\001\255\255\
\131\001\255\255\056\001\113\001\058\001\059\001\060\001\255\255\
\062\001\255\255\255\255\065\001\066\001\255\255\103\003\000\001\
\255\255\128\002\003\001\255\255\255\255\255\255\255\255\008\001\
\255\255\010\001\255\255\255\255\013\001\014\001\255\255\016\001\
\017\001\018\001\019\001\020\001\021\001\126\003\092\001\024\001\
\025\001\026\001\131\003\028\001\029\001\099\001\255\255\255\255\
\255\255\160\002\255\255\255\255\037\001\255\255\255\255\040\001\
\041\001\111\001\112\001\255\255\255\255\255\255\047\001\048\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\000\000\255\255\255\255\061\001\255\255\255\255\064\001\
\255\255\212\001\255\255\068\001\069\001\255\255\071\001\255\255\
\255\255\074\001\075\001\255\255\255\255\255\255\255\255\255\255\
\207\002\082\001\187\003\210\002\211\002\255\255\255\255\192\003\
\255\255\255\255\255\255\255\255\093\001\094\001\255\255\096\001\
\097\001\098\001\099\001\246\001\247\001\248\001\255\255\255\255\
\105\001\255\255\107\001\254\001\255\255\110\001\255\255\255\255\
\113\001\255\255\255\255\242\002\117\001\255\255\255\255\255\255\
\255\255\255\255\013\002\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\021\002\022\002\003\003\255\255\239\003\026\002\
\255\255\028\002\255\255\255\255\011\003\255\255\013\003\255\255\
\255\255\000\001\000\001\255\255\255\255\255\255\255\255\255\255\
\023\003\255\255\255\255\255\255\255\255\255\255\013\001\255\255\
\255\255\255\255\000\000\054\002\255\255\019\001\255\255\255\255\
\255\255\255\255\061\002\026\001\026\001\028\001\029\001\255\255\
\255\255\255\255\255\255\255\255\255\255\052\003\255\255\032\004\
\000\001\255\255\041\001\255\255\004\001\038\004\081\002\255\255\
\008\001\047\001\010\001\255\255\255\255\255\255\014\001\255\255\
\255\255\255\255\018\001\255\255\255\255\096\002\061\001\061\001\
\255\255\064\001\255\255\027\001\255\255\255\255\069\001\069\001\
\255\255\071\001\255\255\090\003\075\001\255\255\255\255\255\255\
\255\255\096\003\097\003\082\001\255\255\255\255\255\255\007\000\
\255\255\255\255\255\255\011\000\255\255\128\002\255\255\094\001\
\255\255\255\255\255\255\098\001\115\003\255\255\255\255\118\003\
\255\255\255\255\099\004\067\001\028\000\255\255\255\255\110\001\
\255\255\255\255\074\001\113\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\048\000\255\255\255\255\255\255\255\255\093\001\094\001\255\255\
\096\001\097\001\153\003\255\255\133\004\255\255\135\004\255\255\
\137\004\255\255\255\255\140\004\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\115\001\171\003\255\255\255\255\255\255\
\255\255\255\255\155\004\083\000\255\255\085\000\086\000\255\255\
\255\255\000\001\255\255\186\003\207\002\188\003\255\255\255\255\
\211\002\255\255\255\255\172\004\173\004\255\255\013\001\255\255\
\056\001\178\004\058\001\059\001\060\001\255\255\062\001\255\255\
\207\003\065\001\066\001\026\001\255\255\028\001\029\001\255\255\
\255\255\255\255\255\255\000\000\255\255\255\255\255\255\242\002\
\080\001\255\255\041\001\083\001\227\003\206\004\255\255\255\255\
\231\003\137\000\255\255\091\001\092\001\255\255\255\255\255\255\
\003\003\255\255\255\255\099\001\243\003\255\255\061\001\255\255\
\011\003\255\255\013\003\255\255\067\001\068\001\069\001\111\001\
\112\001\255\255\162\000\163\000\075\001\165\000\166\000\255\255\
\168\000\255\255\255\255\082\001\007\000\255\255\255\255\014\004\
\255\255\255\255\178\000\179\000\255\255\016\000\255\255\255\255\
\255\255\255\255\255\255\098\001\188\000\255\255\029\004\255\255\
\255\255\255\255\000\001\255\255\255\255\003\001\255\255\110\001\
\255\255\018\005\113\001\255\255\255\255\255\255\255\255\013\001\
\208\000\209\000\255\255\017\001\051\004\255\255\255\255\032\005\
\022\001\255\255\218\000\255\255\026\001\027\001\028\001\029\001\
\000\000\255\255\255\255\255\255\255\255\046\005\255\255\255\255\
\049\005\255\255\255\255\041\001\255\255\096\003\097\003\255\255\
\255\255\255\255\255\255\000\001\083\004\255\255\085\004\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\061\001\
\255\255\255\255\064\001\255\255\066\001\067\001\068\001\069\001\
\103\004\100\000\255\255\255\255\085\005\075\001\255\255\255\255\
\255\255\255\255\255\255\255\255\082\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\000\000\
\094\001\255\255\096\001\255\255\098\001\099\001\038\001\134\004\
\255\255\255\255\255\255\056\001\255\255\058\001\059\001\060\001\
\110\001\062\001\096\000\113\001\065\001\066\001\255\255\117\001\
\171\003\255\255\058\001\132\005\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\083\001\162\000\
\163\000\188\003\165\000\166\000\255\255\168\000\091\001\092\001\
\255\255\255\255\255\255\255\255\255\255\255\255\099\001\178\000\
\179\000\255\255\255\255\255\255\207\003\255\255\167\005\168\005\
\255\255\110\001\111\001\112\001\007\000\255\255\175\005\000\001\
\255\255\200\004\255\255\255\255\255\255\255\255\255\255\111\001\
\227\003\255\255\255\255\255\255\255\255\208\000\209\000\013\001\
\255\255\255\255\217\004\000\001\255\255\125\001\126\001\222\004\
\243\003\129\001\255\255\131\001\227\004\255\255\028\001\029\001\
\013\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\239\004\255\255\255\255\041\001\255\255\026\001\255\255\028\001\
\029\001\226\005\255\255\014\004\255\255\255\255\255\255\056\001\
\255\255\058\001\059\001\060\001\041\001\062\001\255\255\061\001\
\065\001\066\001\064\001\255\255\000\000\255\255\255\255\069\001\
\176\001\255\255\255\255\255\255\255\255\075\001\255\255\183\001\
\061\001\185\001\083\001\064\001\082\001\028\005\255\255\068\001\
\069\001\255\255\091\001\092\001\255\255\255\255\075\001\255\255\
\255\255\255\255\099\001\255\255\098\001\082\001\255\255\255\255\
\255\255\255\255\255\255\255\255\212\001\255\255\111\001\112\001\
\110\001\094\001\255\255\255\255\255\255\098\001\099\001\255\255\
\083\004\255\255\255\255\255\255\255\255\255\255\069\005\090\004\
\071\005\110\001\255\255\255\255\113\001\013\001\255\255\255\255\
\255\255\255\255\255\255\255\255\103\004\255\255\246\001\247\001\
\248\001\088\005\255\255\086\001\028\001\029\001\254\001\162\000\
\163\000\255\255\165\000\166\000\255\255\168\000\255\255\255\255\
\103\005\041\001\255\255\255\255\255\255\255\255\255\255\178\000\
\179\000\255\255\255\255\000\000\111\001\021\002\022\002\255\255\
\255\255\255\255\026\002\255\255\028\002\061\001\006\001\000\001\
\064\001\255\255\003\001\255\255\255\255\069\001\255\255\255\255\
\255\255\255\255\255\255\075\001\013\001\208\000\209\000\255\255\
\255\255\255\255\082\001\255\255\255\255\255\255\054\002\255\255\
\255\255\026\001\027\001\028\001\029\001\061\002\255\255\255\255\
\159\005\255\255\098\001\099\001\255\255\255\255\255\255\255\255\
\041\001\255\255\255\255\255\255\255\255\255\255\110\001\255\255\
\056\001\081\002\058\001\059\001\060\001\200\004\062\001\255\255\
\255\255\065\001\066\001\255\255\061\001\255\255\255\255\064\001\
\096\002\143\001\067\001\068\001\069\001\255\255\255\255\255\255\
\255\255\255\255\075\001\222\004\255\255\015\001\255\255\255\255\
\255\255\082\001\229\004\255\255\092\001\255\255\255\255\255\255\
\255\255\212\001\255\255\099\001\239\004\094\001\255\255\096\001\
\128\002\098\001\099\001\255\255\255\255\255\255\255\255\111\001\
\112\001\043\001\044\001\045\001\046\001\110\001\255\255\255\255\
\113\001\255\255\192\001\255\255\117\001\255\255\255\255\255\255\
\255\255\255\255\245\001\246\001\247\001\248\001\204\001\255\255\
\255\255\067\001\255\255\254\001\255\255\000\001\072\001\073\001\
\255\255\028\005\255\255\255\255\000\001\255\255\255\255\003\001\
\255\255\255\255\255\255\085\001\086\001\087\001\088\001\183\002\
\000\000\013\001\021\002\022\002\255\255\255\255\255\255\026\002\
\255\255\028\002\255\255\255\255\102\001\255\255\026\001\027\001\
\028\001\029\001\255\255\255\255\111\001\040\002\255\255\207\002\
\255\255\255\255\255\255\211\002\255\255\041\001\255\255\255\255\
\255\255\255\255\255\255\054\002\255\255\056\001\255\255\058\001\
\059\001\060\001\061\002\062\001\255\255\088\005\065\001\066\001\
\255\255\061\001\255\255\255\255\064\001\255\255\255\255\067\001\
\068\001\069\001\242\002\255\255\103\005\255\255\081\002\075\001\
\083\001\255\255\255\255\000\000\255\255\255\255\082\001\255\255\
\091\001\092\001\255\255\003\003\255\255\255\255\255\255\255\255\
\099\001\255\255\094\001\011\003\096\001\013\003\098\001\099\001\
\255\255\006\001\255\255\000\001\111\001\112\001\255\255\255\255\
\255\255\255\255\110\001\255\255\255\255\113\001\076\002\255\255\
\013\001\117\001\255\255\255\255\255\255\128\002\255\255\255\255\
\255\255\255\255\255\255\255\255\159\005\026\001\255\255\028\001\
\029\001\212\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\041\001\255\255\255\255\255\255\
\255\255\255\255\255\255\056\001\255\255\058\001\059\001\060\001\
\000\000\062\001\255\255\255\255\065\001\066\001\255\255\255\255\
\061\001\255\255\255\255\246\001\247\001\248\001\255\255\068\001\
\069\001\255\255\255\255\254\001\255\001\255\255\075\001\255\255\
\096\003\097\003\255\255\255\255\255\255\082\001\255\255\092\001\
\255\255\255\255\255\255\000\001\255\255\255\255\099\001\255\255\
\255\255\159\002\021\002\022\002\207\002\098\001\255\255\026\002\
\211\002\028\002\111\001\112\001\255\255\255\255\255\255\255\255\
\255\255\110\001\255\255\255\255\113\001\255\255\255\255\255\255\
\136\003\255\255\255\255\255\255\255\255\141\003\255\255\255\255\
\030\000\031\000\255\255\054\002\255\255\255\255\255\255\242\002\
\255\255\255\255\061\002\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\056\001\255\255\058\001\059\001\060\001\
\003\003\062\001\255\255\171\003\065\001\066\001\081\002\255\255\
\011\003\255\255\013\003\255\255\255\255\255\255\255\255\255\255\
\000\001\255\255\255\255\003\001\188\003\255\255\083\001\255\255\
\255\255\255\255\255\255\255\255\255\255\013\001\091\001\092\001\
\255\255\087\000\088\000\255\255\255\255\255\255\099\001\207\003\
\255\255\255\255\026\001\255\255\028\001\029\001\255\255\255\255\
\255\255\255\255\111\001\112\001\255\255\128\002\255\255\255\255\
\255\255\041\001\255\255\227\003\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\027\003\255\255\255\255\
\255\255\255\255\255\255\243\003\000\000\061\001\255\255\255\255\
\255\255\255\255\255\255\000\001\255\255\069\001\003\001\255\255\
\255\255\255\255\255\255\075\001\255\255\096\003\097\003\255\255\
\013\001\055\003\082\001\255\255\255\255\255\255\014\004\255\255\
\255\255\255\255\255\255\065\003\255\255\026\001\027\001\028\001\
\029\001\255\255\098\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\041\001\255\255\110\001\255\255\
\255\255\113\001\255\255\134\003\207\002\045\004\255\255\255\255\
\211\002\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\061\001\255\255\255\255\064\001\255\255\255\255\067\001\068\001\
\069\001\255\255\112\003\255\255\255\255\069\004\075\001\006\001\
\000\001\008\001\255\255\255\255\255\255\082\001\124\003\242\002\
\171\003\255\255\255\255\083\004\255\255\013\001\132\003\255\255\
\255\255\094\001\090\004\096\001\255\255\098\001\099\001\255\255\
\003\003\188\003\026\001\255\255\028\001\029\001\255\255\103\004\
\011\003\110\001\013\003\255\255\113\001\255\255\255\255\255\255\
\117\001\041\001\255\255\255\255\207\003\255\255\255\255\255\255\
\255\255\056\001\255\255\058\001\059\001\060\001\172\003\062\001\
\255\255\255\255\065\001\066\001\255\255\061\001\255\255\255\255\
\227\003\255\255\255\255\185\003\255\255\069\001\255\255\255\255\
\255\255\255\255\255\255\075\001\083\001\255\255\255\255\255\255\
\243\003\255\255\082\001\255\255\091\001\092\001\000\000\255\255\
\255\255\255\255\255\255\209\003\099\001\255\255\212\003\213\003\
\255\255\255\255\098\001\255\255\255\255\255\255\255\255\255\255\
\111\001\112\001\255\255\014\004\255\255\255\255\110\001\255\255\
\255\255\113\001\255\255\255\255\255\255\096\003\097\003\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\200\004\087\001\088\001\089\001\090\001\091\001\092\001\093\001\
\094\001\095\001\096\001\097\001\098\001\099\001\100\001\101\001\
\102\001\103\001\104\001\105\001\106\001\107\001\222\004\109\001\
\255\255\255\255\255\255\255\255\255\255\229\004\255\255\255\255\
\255\255\023\004\255\255\255\255\255\255\123\001\255\255\239\004\
\255\255\255\255\255\255\255\255\000\001\035\004\002\001\003\001\
\083\004\135\001\255\255\255\255\008\001\255\255\255\255\255\255\
\255\255\013\001\255\255\255\255\255\255\017\001\018\001\019\001\
\171\003\255\255\255\255\255\255\103\004\255\255\026\001\027\001\
\028\001\029\001\255\255\255\255\066\004\255\255\255\255\255\255\
\036\001\188\003\255\255\255\255\028\005\041\001\255\255\255\255\
\255\255\255\255\255\255\047\001\048\001\255\255\255\255\255\255\
\255\255\000\000\255\255\255\255\207\003\255\255\255\255\255\255\
\255\255\061\001\255\255\255\255\064\001\255\255\255\255\067\001\
\068\001\069\001\255\255\071\001\255\255\255\255\255\255\075\001\
\227\003\255\255\255\255\255\255\255\255\255\255\082\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\243\003\093\001\094\001\255\255\096\001\097\001\098\001\099\001\
\088\005\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\110\001\255\255\255\255\113\001\255\255\255\255\
\255\255\117\001\255\255\014\004\255\255\200\004\255\255\255\255\
\255\255\255\255\056\001\255\255\058\001\059\001\060\001\165\004\
\062\001\255\255\255\255\065\001\066\001\255\255\255\255\255\255\
\174\004\255\255\255\255\222\004\255\255\179\004\180\004\255\255\
\255\255\255\255\255\255\255\255\255\255\083\001\255\255\255\255\
\190\004\255\255\255\255\033\002\239\004\091\001\092\001\255\255\
\255\255\255\255\255\255\255\255\042\002\099\001\000\001\255\255\
\046\002\003\001\255\255\049\002\255\255\255\255\008\001\255\255\
\010\001\111\001\112\001\013\001\014\001\219\004\255\255\017\001\
\083\004\019\001\020\001\021\001\255\255\255\255\024\001\025\001\
\026\001\000\000\028\001\029\001\255\255\255\255\255\255\255\255\
\255\255\028\005\255\255\037\001\103\004\243\004\040\001\041\001\
\255\255\255\255\255\255\255\255\255\255\047\001\048\001\255\255\
\255\255\255\255\255\255\255\255\098\002\099\002\255\255\255\255\
\255\255\255\255\255\255\061\001\255\255\255\255\064\001\255\255\
\255\255\255\255\068\001\069\001\255\255\071\001\255\255\255\255\
\074\001\075\001\255\255\255\255\255\255\255\255\255\255\255\255\
\082\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\136\002\093\001\094\001\088\005\096\001\097\001\
\098\001\099\001\255\255\255\255\255\255\255\255\255\255\105\001\
\255\255\107\001\056\005\255\255\110\001\255\255\255\255\113\001\
\255\255\063\005\255\255\117\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\073\005\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\056\001\200\004\058\001\059\001\
\060\001\000\001\062\001\255\255\003\001\065\001\066\001\255\255\
\255\255\008\001\255\255\010\001\255\255\000\000\013\001\014\001\
\255\255\255\255\017\001\222\004\019\001\020\001\021\001\083\001\
\255\255\024\001\025\001\026\001\255\255\028\001\029\001\091\001\
\092\001\255\255\255\255\255\255\239\004\255\255\037\001\099\001\
\126\005\040\001\041\001\129\005\255\255\255\255\255\255\255\255\
\047\001\048\001\232\002\111\001\112\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\061\001\255\255\
\255\255\064\001\255\255\255\255\255\255\068\001\069\001\255\255\
\071\001\255\255\255\255\074\001\075\001\255\255\255\255\255\255\
\255\255\028\005\255\255\082\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\177\005\018\003\255\255\093\001\094\001\
\255\255\096\001\097\001\098\001\099\001\255\255\255\255\255\255\
\255\255\255\255\105\001\255\255\107\001\255\255\255\255\110\001\
\255\255\255\255\113\001\255\255\255\255\255\255\117\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\054\003\255\255\255\255\255\255\255\255\255\255\255\255\000\000\
\255\255\255\255\255\255\255\255\255\255\088\005\255\255\255\255\
\255\255\000\001\001\001\002\001\003\001\255\255\255\255\006\001\
\007\001\008\001\009\001\010\001\011\001\012\001\013\001\014\001\
\015\001\016\001\017\001\018\001\019\001\020\001\021\001\022\001\
\255\255\024\001\025\001\026\001\027\001\028\001\029\001\030\001\
\031\001\255\255\255\255\255\255\255\255\036\001\037\001\255\255\
\110\003\040\001\041\001\042\001\043\001\044\001\045\001\046\001\
\047\001\048\001\049\001\050\001\051\001\052\001\255\255\054\001\
\055\001\056\001\057\001\255\255\255\255\060\001\061\001\062\001\
\063\001\064\001\065\001\066\001\067\001\068\001\069\001\255\255\
\071\001\072\001\073\001\074\001\075\001\255\255\077\001\078\001\
\255\255\255\255\255\255\082\001\083\001\084\001\085\001\086\001\
\087\001\088\001\089\001\255\255\091\001\255\255\093\001\094\001\
\255\255\096\001\097\001\098\001\099\001\100\001\255\255\102\001\
\103\001\255\255\105\001\106\001\107\001\108\001\000\000\110\001\
\111\001\255\255\113\001\255\255\255\255\255\255\117\001\255\255\
\255\255\255\255\255\255\255\255\255\255\000\001\001\001\002\001\
\003\001\004\001\255\255\006\001\007\001\008\001\009\001\010\001\
\011\001\012\001\013\001\014\001\015\001\016\001\017\001\018\001\
\019\001\020\001\021\001\255\255\218\003\024\001\025\001\026\001\
\027\001\028\001\029\001\030\001\031\001\255\255\255\255\255\255\
\255\255\036\001\037\001\255\255\255\255\040\001\041\001\042\001\
\043\001\044\001\045\001\046\001\047\001\048\001\049\001\050\001\
\051\001\052\001\255\255\054\001\055\001\056\001\057\001\255\255\
\255\255\060\001\061\001\062\001\255\255\064\001\065\001\066\001\
\067\001\068\001\069\001\255\255\071\001\072\001\073\001\074\001\
\075\001\255\255\077\001\078\001\255\255\255\255\255\255\082\001\
\083\001\084\001\085\001\086\001\087\001\088\001\089\001\255\255\
\091\001\255\255\093\001\094\001\255\255\096\001\097\001\098\001\
\099\001\100\001\255\255\102\001\103\001\000\000\105\001\106\001\
\107\001\108\001\255\255\110\001\111\001\255\255\113\001\255\255\
\255\255\255\255\117\001\255\255\255\255\255\255\255\255\000\001\
\001\001\002\001\003\001\255\255\255\255\255\255\255\255\008\001\
\009\001\010\001\255\255\255\255\013\001\014\001\015\001\016\001\
\017\001\018\001\019\001\020\001\021\001\255\255\255\255\024\001\
\025\001\026\001\027\001\028\001\029\001\255\255\255\255\255\255\
\255\255\255\255\255\255\036\001\037\001\255\255\255\255\040\001\
\041\001\042\001\043\001\044\001\045\001\046\001\047\001\048\001\
\255\255\255\255\255\255\255\255\114\004\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\061\001\062\001\255\255\064\001\
\126\004\255\255\067\001\068\001\069\001\255\255\071\001\072\001\
\073\001\074\001\075\001\255\255\255\255\255\255\255\255\255\255\
\255\255\082\001\255\255\084\001\085\001\086\001\087\001\088\001\
\255\255\255\255\255\255\255\255\093\001\094\001\255\255\096\001\
\097\001\098\001\099\001\000\000\255\255\102\001\255\255\255\255\
\105\001\255\255\107\001\255\255\255\255\110\001\255\255\255\255\
\113\001\175\004\176\004\177\004\117\001\255\255\000\001\001\001\
\002\001\003\001\255\255\255\255\006\001\007\001\008\001\009\001\
\010\001\011\001\012\001\013\001\014\001\015\001\016\001\017\001\
\018\001\019\001\020\001\021\001\022\001\255\255\024\001\025\001\
\026\001\027\001\028\001\029\001\030\001\031\001\255\255\255\255\
\255\255\255\255\036\001\037\001\255\255\255\255\040\001\041\001\
\042\001\043\001\044\001\045\001\046\001\047\001\048\001\049\001\
\050\001\051\001\052\001\255\255\054\001\055\001\056\001\057\001\
\255\255\255\255\060\001\061\001\062\001\255\255\064\001\065\001\
\066\001\067\001\068\001\069\001\255\255\071\001\072\001\073\001\
\074\001\075\001\255\255\077\001\078\001\255\255\255\255\255\255\
\082\001\083\001\084\001\085\001\086\001\087\001\088\001\089\001\
\255\255\091\001\255\255\093\001\094\001\255\255\096\001\097\001\
\098\001\099\001\100\001\000\000\102\001\103\001\255\255\105\001\
\106\001\107\001\108\001\255\255\110\001\111\001\255\255\113\001\
\255\255\255\255\255\255\117\001\255\255\000\001\001\001\002\001\
\003\001\004\001\255\255\006\001\007\001\008\001\009\001\010\001\
\011\001\012\001\013\001\014\001\015\001\016\001\017\001\018\001\
\019\001\020\001\021\001\255\255\255\255\024\001\025\001\026\001\
\027\001\028\001\029\001\030\001\031\001\255\255\255\255\255\255\
\255\255\036\001\037\001\255\255\255\255\040\001\041\001\042\001\
\043\001\044\001\045\001\046\001\047\001\048\001\049\001\050\001\
\051\001\052\001\255\255\054\001\055\001\056\001\057\001\255\255\
\255\255\060\001\061\001\062\001\255\255\064\001\065\001\066\001\
\067\001\068\001\069\001\255\255\071\001\072\001\073\001\074\001\
\075\001\255\255\077\001\078\001\255\255\255\255\255\255\082\001\
\083\001\084\001\085\001\086\001\087\001\088\001\089\001\255\255\
\091\001\255\255\093\001\094\001\255\255\096\001\097\001\098\001\
\099\001\100\001\000\000\102\001\103\001\255\255\105\001\106\001\
\107\001\108\001\255\255\110\001\111\001\255\255\113\001\255\255\
\255\255\255\255\117\001\000\001\001\001\002\001\003\001\255\255\
\255\255\006\001\007\001\008\001\009\001\010\001\011\001\012\001\
\013\001\014\001\015\001\016\001\017\001\018\001\019\001\020\001\
\021\001\022\001\255\255\024\001\025\001\026\001\027\001\028\001\
\029\001\030\001\031\001\255\255\255\255\255\255\255\255\036\001\
\037\001\255\255\255\255\040\001\041\001\042\001\043\001\044\001\
\045\001\046\001\047\001\048\001\049\001\050\001\051\001\052\001\
\255\255\054\001\055\001\056\001\057\001\255\255\255\255\060\001\
\061\001\062\001\255\255\064\001\065\001\066\001\067\001\068\001\
\069\001\255\255\071\001\072\001\073\001\074\001\075\001\255\255\
\077\001\078\001\255\255\255\255\255\255\082\001\083\001\084\001\
\085\001\086\001\087\001\088\001\089\001\255\255\091\001\255\255\
\093\001\094\001\255\255\096\001\097\001\098\001\099\001\100\001\
\000\000\102\001\103\001\255\255\105\001\106\001\107\001\108\001\
\255\255\110\001\111\001\255\255\113\001\255\255\255\255\255\255\
\117\001\255\255\255\255\000\001\001\001\002\001\003\001\255\255\
\255\255\006\001\007\001\008\001\009\001\010\001\011\001\012\001\
\013\001\014\001\015\001\016\001\017\001\018\001\019\001\020\001\
\021\001\022\001\255\255\024\001\025\001\026\001\027\001\028\001\
\029\001\030\001\031\001\255\255\255\255\255\255\255\255\036\001\
\037\001\255\255\255\255\040\001\041\001\042\001\043\001\044\001\
\045\001\046\001\047\001\048\001\049\001\050\001\051\001\052\001\
\255\255\054\001\055\001\056\001\057\001\255\255\255\255\060\001\
\061\001\062\001\255\255\064\001\065\001\066\001\067\001\068\001\
\069\001\255\255\071\001\072\001\073\001\074\001\075\001\255\255\
\077\001\078\001\255\255\255\255\255\255\082\001\083\001\084\001\
\085\001\086\001\087\001\088\001\089\001\255\255\091\001\255\255\
\093\001\094\001\255\255\096\001\097\001\098\001\099\001\100\001\
\000\000\102\001\103\001\255\255\105\001\106\001\107\001\108\001\
\255\255\110\001\111\001\255\255\113\001\255\255\255\255\255\255\
\117\001\255\255\000\001\001\001\002\001\003\001\255\255\255\255\
\006\001\007\001\008\001\009\001\010\001\011\001\012\001\013\001\
\014\001\015\001\016\001\017\001\018\001\019\001\020\001\021\001\
\022\001\255\255\024\001\025\001\026\001\027\001\028\001\029\001\
\030\001\031\001\255\255\255\255\255\255\255\255\036\001\037\001\
\255\255\255\255\040\001\041\001\042\001\043\001\044\001\045\001\
\046\001\047\001\048\001\049\001\050\001\051\001\052\001\255\255\
\054\001\055\001\056\001\057\001\255\255\255\255\060\001\061\001\
\062\001\255\255\064\001\065\001\066\001\067\001\068\001\069\001\
\255\255\071\001\072\001\073\001\074\001\075\001\255\255\077\001\
\078\001\255\255\255\255\255\255\082\001\083\001\084\001\085\001\
\086\001\087\001\088\001\089\001\255\255\091\001\255\255\093\001\
\094\001\255\255\096\001\097\001\098\001\099\001\100\001\000\000\
\102\001\103\001\255\255\105\001\106\001\107\001\108\001\255\255\
\110\001\111\001\255\255\113\001\255\255\255\255\255\255\117\001\
\000\001\001\001\002\001\003\001\004\001\255\255\006\001\007\001\
\008\001\009\001\010\001\011\001\012\001\013\001\014\001\015\001\
\016\001\017\001\018\001\019\001\020\001\021\001\255\255\255\255\
\024\001\025\001\026\001\027\001\028\001\029\001\030\001\031\001\
\255\255\255\255\255\255\255\255\036\001\037\001\255\255\255\255\
\040\001\041\001\042\001\043\001\044\001\045\001\046\001\047\001\
\048\001\049\001\050\001\051\001\052\001\255\255\054\001\055\001\
\056\001\057\001\255\255\255\255\060\001\061\001\062\001\255\255\
\064\001\065\001\066\001\067\001\068\001\069\001\255\255\071\001\
\072\001\073\001\074\001\075\001\255\255\077\001\078\001\255\255\
\255\255\255\255\082\001\083\001\084\001\085\001\086\001\087\001\
\088\001\089\001\255\255\091\001\255\255\093\001\094\001\255\255\
\096\001\097\001\098\001\255\255\255\255\000\000\102\001\103\001\
\255\255\105\001\106\001\107\001\108\001\255\255\110\001\111\001\
\255\255\113\001\255\255\255\255\255\255\117\001\255\255\255\255\
\000\001\001\001\002\001\003\001\004\001\255\255\006\001\007\001\
\008\001\009\001\010\001\011\001\012\001\013\001\014\001\015\001\
\016\001\017\001\018\001\019\001\020\001\021\001\255\255\255\255\
\024\001\025\001\026\001\027\001\028\001\029\001\030\001\031\001\
\255\255\255\255\255\255\255\255\036\001\037\001\255\255\255\255\
\040\001\041\001\042\001\043\001\044\001\045\001\046\001\047\001\
\048\001\049\001\050\001\051\001\052\001\255\255\054\001\055\001\
\056\001\057\001\255\255\255\255\060\001\061\001\062\001\255\255\
\064\001\065\001\066\001\067\001\068\001\069\001\255\255\071\001\
\072\001\073\001\074\001\075\001\255\255\077\001\078\001\255\255\
\255\255\255\255\082\001\083\001\084\001\085\001\086\001\087\001\
\088\001\089\001\255\255\091\001\255\255\093\001\094\001\255\255\
\096\001\097\001\098\001\000\000\255\255\255\255\102\001\103\001\
\255\255\105\001\106\001\107\001\108\001\255\255\110\001\111\001\
\255\255\113\001\255\255\255\255\255\255\117\001\255\255\000\001\
\001\001\002\001\003\001\004\001\255\255\006\001\007\001\008\001\
\009\001\010\001\011\001\012\001\013\001\014\001\015\001\016\001\
\017\001\018\001\019\001\020\001\021\001\255\255\255\255\024\001\
\025\001\026\001\027\001\028\001\029\001\030\001\031\001\255\255\
\255\255\255\255\255\255\036\001\037\001\255\255\255\255\040\001\
\041\001\042\001\043\001\044\001\045\001\046\001\047\001\048\001\
\049\001\050\001\051\001\052\001\255\255\054\001\055\001\056\001\
\057\001\255\255\255\255\060\001\061\001\062\001\255\255\064\001\
\065\001\066\001\067\001\068\001\069\001\255\255\071\001\072\001\
\073\001\074\001\075\001\255\255\077\001\078\001\255\255\255\255\
\255\255\082\001\083\001\084\001\085\001\086\001\087\001\088\001\
\089\001\255\255\091\001\255\255\093\001\094\001\255\255\096\001\
\097\001\098\001\000\000\255\255\255\255\102\001\103\001\255\255\
\105\001\106\001\107\001\108\001\255\255\110\001\111\001\255\255\
\113\001\255\255\255\255\255\255\117\001\000\001\001\001\002\001\
\003\001\255\255\255\255\255\255\255\255\008\001\009\001\010\001\
\255\255\255\255\013\001\014\001\015\001\016\001\017\001\018\001\
\019\001\020\001\021\001\022\001\255\255\024\001\025\001\026\001\
\027\001\028\001\029\001\255\255\255\255\255\255\255\255\255\255\
\255\255\036\001\037\001\255\255\255\255\040\001\041\001\042\001\
\043\001\044\001\045\001\046\001\047\001\048\001\255\255\255\255\
\255\255\052\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\061\001\062\001\255\255\064\001\255\255\255\255\
\067\001\068\001\069\001\255\255\071\001\072\001\073\001\074\001\
\075\001\255\255\255\255\255\255\255\255\255\255\255\255\082\001\
\083\001\084\001\085\001\086\001\087\001\088\001\255\255\255\255\
\091\001\255\255\093\001\094\001\255\255\096\001\097\001\098\001\
\099\001\100\001\000\000\102\001\255\255\255\255\105\001\106\001\
\107\001\255\255\255\255\110\001\255\255\255\255\113\001\255\255\
\255\255\255\255\117\001\000\001\001\001\002\001\003\001\255\255\
\255\255\255\255\255\255\008\001\009\001\010\001\255\255\255\255\
\013\001\014\001\015\001\016\001\017\001\018\001\019\001\020\001\
\021\001\022\001\255\255\024\001\025\001\026\001\027\001\028\001\
\029\001\255\255\255\255\255\255\255\255\255\255\255\255\036\001\
\037\001\255\255\255\255\040\001\041\001\042\001\043\001\044\001\
\045\001\046\001\047\001\048\001\255\255\255\255\255\255\052\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\061\001\062\001\255\255\064\001\255\255\255\255\067\001\068\001\
\069\001\255\255\071\001\072\001\073\001\074\001\075\001\255\255\
\255\255\255\255\255\255\255\255\255\255\082\001\083\001\084\001\
\085\001\086\001\087\001\088\001\255\255\255\255\091\001\255\255\
\093\001\094\001\255\255\096\001\097\001\098\001\099\001\100\001\
\000\000\102\001\255\255\255\255\105\001\106\001\107\001\255\255\
\255\255\110\001\255\255\255\255\113\001\255\255\255\255\255\255\
\117\001\255\255\000\001\001\001\002\001\003\001\255\255\255\255\
\255\255\255\255\008\001\009\001\010\001\255\255\255\255\013\001\
\014\001\015\001\016\001\017\001\018\001\019\001\020\001\021\001\
\255\255\255\255\024\001\025\001\026\001\027\001\028\001\029\001\
\255\255\255\255\255\255\255\255\255\255\255\255\036\001\037\001\
\255\255\255\255\040\001\041\001\042\001\043\001\044\001\045\001\
\046\001\047\001\048\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\061\001\
\062\001\255\255\064\001\255\255\255\255\067\001\068\001\069\001\
\255\255\071\001\072\001\073\001\074\001\075\001\255\255\255\255\
\255\255\255\255\255\255\255\255\082\001\255\255\084\001\085\001\
\086\001\087\001\088\001\255\255\255\255\255\255\255\255\093\001\
\094\001\255\255\096\001\097\001\098\001\255\255\000\000\255\255\
\102\001\255\255\255\255\105\001\255\255\107\001\255\255\255\255\
\110\001\255\255\255\255\113\001\255\255\255\255\255\255\117\001\
\255\255\255\255\000\001\001\001\002\001\003\001\255\255\255\255\
\255\255\255\255\008\001\009\001\010\001\255\255\255\255\013\001\
\014\001\015\001\016\001\017\001\255\255\019\001\020\001\021\001\
\255\255\255\255\024\001\025\001\026\001\027\001\028\001\029\001\
\255\255\255\255\255\255\255\255\255\255\255\255\036\001\037\001\
\255\255\255\255\040\001\041\001\042\001\043\001\044\001\045\001\
\046\001\047\001\048\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\061\001\
\062\001\255\255\064\001\255\255\255\255\067\001\068\001\069\001\
\255\255\071\001\072\001\073\001\074\001\075\001\255\255\255\255\
\255\255\255\255\255\255\255\255\082\001\255\255\084\001\085\001\
\086\001\087\001\088\001\255\255\255\255\255\255\255\255\093\001\
\094\001\255\255\096\001\097\001\098\001\099\001\000\000\255\255\
\102\001\255\255\255\255\105\001\255\255\107\001\255\255\255\255\
\110\001\255\255\255\255\113\001\255\255\255\255\255\255\117\001\
\000\001\001\001\002\001\003\001\255\255\255\255\255\255\255\255\
\008\001\009\001\010\001\255\255\255\255\013\001\014\001\015\001\
\016\001\017\001\018\001\019\001\020\001\021\001\255\255\255\255\
\024\001\025\001\026\001\027\001\028\001\029\001\255\255\255\255\
\255\255\255\255\255\255\255\255\036\001\037\001\255\255\255\255\
\040\001\041\001\042\001\043\001\044\001\045\001\046\001\047\001\
\048\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\061\001\062\001\255\255\
\064\001\255\255\255\255\067\001\068\001\069\001\255\255\071\001\
\072\001\073\001\074\001\075\001\255\255\255\255\255\255\255\255\
\255\255\255\255\082\001\255\255\084\001\085\001\086\001\087\001\
\088\001\255\255\255\255\255\255\255\255\093\001\094\001\255\255\
\096\001\097\001\098\001\255\255\000\000\255\255\102\001\255\255\
\255\255\105\001\255\255\107\001\255\255\255\255\110\001\255\255\
\255\255\113\001\255\255\255\255\255\255\117\001\000\001\001\001\
\002\001\003\001\255\255\255\255\255\255\255\255\008\001\009\001\
\010\001\255\255\255\255\013\001\014\001\015\001\016\001\017\001\
\018\001\019\001\020\001\021\001\255\255\255\255\024\001\025\001\
\026\001\027\001\028\001\029\001\255\255\255\255\255\255\255\255\
\255\255\255\255\036\001\037\001\255\255\255\255\040\001\041\001\
\042\001\043\001\044\001\045\001\046\001\047\001\048\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\061\001\062\001\255\255\064\001\255\255\
\255\255\067\001\068\001\069\001\255\255\071\001\072\001\073\001\
\074\001\075\001\255\255\255\255\255\255\255\255\255\255\255\255\
\082\001\255\255\084\001\085\001\086\001\087\001\088\001\255\255\
\255\255\255\255\255\255\093\001\094\001\255\255\096\001\097\001\
\098\001\255\255\000\000\255\255\102\001\255\255\255\255\105\001\
\255\255\107\001\255\255\255\255\110\001\255\255\255\255\113\001\
\255\255\255\255\255\255\117\001\255\255\255\255\000\001\001\001\
\002\001\003\001\255\255\255\255\255\255\255\255\008\001\009\001\
\010\001\255\255\255\255\013\001\014\001\015\001\016\001\017\001\
\018\001\019\001\020\001\021\001\255\255\255\255\024\001\025\001\
\026\001\027\001\028\001\029\001\255\255\255\255\255\255\255\255\
\255\255\255\255\036\001\037\001\255\255\255\255\040\001\041\001\
\042\001\043\001\044\001\045\001\046\001\047\001\048\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\061\001\062\001\255\255\064\001\255\255\
\255\255\067\001\068\001\069\001\255\255\071\001\072\001\073\001\
\074\001\075\001\255\255\255\255\255\255\255\255\255\255\255\255\
\082\001\255\255\084\001\085\001\086\001\087\001\088\001\255\255\
\255\255\255\255\255\255\093\001\094\001\255\255\096\001\097\001\
\098\001\000\000\255\255\255\255\102\001\255\255\255\255\105\001\
\255\255\107\001\255\255\255\255\110\001\255\255\255\255\113\001\
\255\255\255\255\255\255\117\001\000\001\001\001\002\001\003\001\
\255\255\255\255\255\255\255\255\008\001\009\001\010\001\255\255\
\255\255\013\001\014\001\015\001\016\001\017\001\018\001\019\001\
\020\001\021\001\255\255\255\255\024\001\025\001\026\001\027\001\
\028\001\029\001\255\255\255\255\255\255\255\255\255\255\255\255\
\036\001\037\001\255\255\255\255\040\001\041\001\042\001\043\001\
\044\001\045\001\046\001\047\001\048\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\061\001\062\001\255\255\064\001\255\255\255\255\067\001\
\068\001\069\001\255\255\071\001\072\001\073\001\074\001\075\001\
\255\255\255\255\255\255\255\255\255\255\255\255\082\001\255\255\
\084\001\085\001\086\001\087\001\088\001\255\255\255\255\255\255\
\255\255\093\001\094\001\255\255\096\001\097\001\098\001\000\000\
\255\255\255\255\102\001\255\255\255\255\105\001\255\255\107\001\
\255\255\255\255\110\001\255\255\255\255\113\001\255\255\255\255\
\255\255\117\001\000\001\001\001\002\001\003\001\255\255\255\255\
\255\255\255\255\008\001\009\001\010\001\255\255\255\255\013\001\
\014\001\015\001\016\001\017\001\018\001\019\001\020\001\021\001\
\255\255\255\255\024\001\025\001\026\001\027\001\028\001\029\001\
\255\255\255\255\255\255\255\255\255\255\255\255\036\001\037\001\
\255\255\255\255\040\001\041\001\042\001\043\001\044\001\045\001\
\255\255\047\001\048\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\061\001\
\062\001\255\255\064\001\255\255\255\255\067\001\068\001\069\001\
\255\255\071\001\072\001\073\001\074\001\075\001\255\255\255\255\
\255\255\255\255\255\255\255\255\082\001\255\255\084\001\085\001\
\086\001\087\001\088\001\255\255\255\255\255\255\255\255\093\001\
\094\001\255\255\096\001\097\001\098\001\099\001\000\000\255\255\
\102\001\255\255\255\255\105\001\255\255\107\001\255\255\255\255\
\110\001\255\255\255\255\113\001\255\255\255\255\255\255\117\001\
\255\255\000\001\001\001\002\001\003\001\255\255\255\255\255\255\
\255\255\008\001\009\001\010\001\255\255\255\255\013\001\014\001\
\015\001\016\001\017\001\018\001\019\001\020\001\021\001\255\255\
\255\255\024\001\025\001\026\001\027\001\028\001\029\001\255\255\
\255\255\255\255\255\255\255\255\255\255\036\001\037\001\255\255\
\255\255\040\001\041\001\042\001\043\001\044\001\045\001\255\255\
\047\001\048\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\061\001\062\001\
\255\255\064\001\255\255\255\255\067\001\068\001\069\001\255\255\
\071\001\072\001\073\001\074\001\075\001\255\255\255\255\255\255\
\255\255\255\255\255\255\082\001\255\255\084\001\085\001\086\001\
\087\001\088\001\255\255\255\255\255\255\255\255\093\001\094\001\
\255\255\096\001\097\001\098\001\099\001\000\000\255\255\102\001\
\255\255\255\255\105\001\255\255\107\001\255\255\255\255\110\001\
\255\255\255\255\113\001\255\255\255\255\255\255\117\001\000\001\
\001\001\002\001\003\001\255\255\255\255\255\255\255\255\008\001\
\009\001\010\001\255\255\255\255\013\001\014\001\015\001\016\001\
\017\001\018\001\019\001\020\001\021\001\255\255\255\255\024\001\
\025\001\026\001\027\001\028\001\029\001\255\255\255\255\255\255\
\255\255\255\255\255\255\036\001\037\001\255\255\255\255\040\001\
\041\001\042\001\043\001\044\001\045\001\255\255\047\001\048\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\061\001\062\001\255\255\064\001\
\255\255\255\255\067\001\068\001\069\001\255\255\071\001\072\001\
\073\001\074\001\075\001\255\255\255\255\255\255\255\255\255\255\
\255\255\082\001\255\255\084\001\085\001\086\001\087\001\088\001\
\255\255\255\255\255\255\255\255\093\001\094\001\255\255\096\001\
\097\001\098\001\099\001\000\000\255\255\102\001\255\255\255\255\
\105\001\255\255\107\001\255\255\255\255\110\001\255\255\255\255\
\113\001\255\255\255\255\255\255\117\001\255\255\000\001\001\001\
\002\001\003\001\255\255\255\255\255\255\255\255\008\001\009\001\
\010\001\255\255\255\255\013\001\014\001\015\001\016\001\017\001\
\018\001\019\001\020\001\021\001\255\255\255\255\024\001\025\001\
\026\001\027\001\028\001\029\001\255\255\255\255\255\255\255\255\
\255\255\255\255\036\001\037\001\255\255\255\255\040\001\041\001\
\042\001\043\001\044\001\045\001\255\255\047\001\048\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\061\001\062\001\255\255\064\001\255\255\
\255\255\067\001\068\001\069\001\255\255\071\001\072\001\073\001\
\074\001\075\001\255\255\255\255\255\255\255\255\255\255\255\255\
\082\001\255\255\084\001\085\001\086\001\087\001\088\001\255\255\
\255\255\255\255\255\255\093\001\094\001\255\255\096\001\097\001\
\098\001\099\001\000\000\255\255\102\001\255\255\255\255\105\001\
\255\255\107\001\255\255\255\255\110\001\255\255\255\255\113\001\
\255\255\255\255\255\255\117\001\255\255\000\001\001\001\002\001\
\003\001\255\255\255\255\255\255\255\255\255\255\009\001\010\001\
\255\255\255\255\013\001\014\001\015\001\016\001\017\001\018\001\
\019\001\020\001\021\001\255\255\255\255\024\001\025\001\026\001\
\027\001\028\001\029\001\255\255\255\255\255\255\255\255\255\255\
\255\255\036\001\037\001\255\255\255\255\040\001\041\001\042\001\
\043\001\044\001\045\001\046\001\047\001\048\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\061\001\062\001\255\255\064\001\255\255\255\255\
\067\001\068\001\069\001\255\255\071\001\072\001\073\001\074\001\
\075\001\255\255\255\255\255\255\255\255\255\255\255\255\082\001\
\255\255\084\001\085\001\086\001\087\001\088\001\255\255\255\255\
\255\255\255\255\093\001\094\001\255\255\096\001\097\001\098\001\
\099\001\000\000\255\255\102\001\255\255\255\255\105\001\255\255\
\107\001\255\255\255\255\110\001\255\255\255\255\113\001\255\255\
\255\255\255\255\117\001\000\001\001\001\002\001\003\001\255\255\
\255\255\255\255\255\255\255\255\009\001\010\001\255\255\255\255\
\013\001\014\001\015\001\016\001\017\001\018\001\019\001\020\001\
\021\001\255\255\255\255\024\001\025\001\026\001\027\001\028\001\
\029\001\255\255\255\255\255\255\255\255\255\255\255\255\036\001\
\037\001\255\255\255\255\040\001\041\001\042\001\043\001\044\001\
\045\001\046\001\047\001\048\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\061\001\062\001\255\255\064\001\255\255\255\255\067\001\068\001\
\069\001\255\255\071\001\072\001\073\001\074\001\075\001\255\255\
\255\255\255\255\255\255\255\255\255\255\082\001\255\255\084\001\
\085\001\086\001\087\001\088\001\255\255\255\255\255\255\255\255\
\093\001\094\001\255\255\096\001\097\001\098\001\099\001\000\000\
\255\255\102\001\255\255\255\255\105\001\255\255\107\001\255\255\
\255\255\110\001\255\255\255\255\113\001\255\255\255\255\255\255\
\117\001\255\255\000\001\001\001\002\001\003\001\255\255\255\255\
\255\255\255\255\255\255\009\001\010\001\255\255\255\255\013\001\
\014\001\015\001\016\001\017\001\018\001\019\001\020\001\021\001\
\255\255\255\255\024\001\025\001\026\001\027\001\028\001\029\001\
\255\255\255\255\255\255\255\255\255\255\255\255\036\001\037\001\
\255\255\255\255\040\001\041\001\042\001\043\001\044\001\045\001\
\046\001\047\001\048\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\061\001\
\062\001\255\255\064\001\255\255\255\255\067\001\068\001\069\001\
\255\255\071\001\072\001\073\001\074\001\075\001\255\255\255\255\
\255\255\255\255\255\255\255\255\082\001\255\255\084\001\085\001\
\086\001\087\001\088\001\255\255\255\255\255\255\255\255\093\001\
\094\001\255\255\096\001\097\001\098\001\099\001\000\000\255\255\
\102\001\255\255\255\255\105\001\255\255\107\001\255\255\255\255\
\110\001\255\255\255\255\113\001\255\255\255\255\255\255\117\001\
\255\255\000\001\001\001\002\001\003\001\255\255\255\255\255\255\
\255\255\008\001\009\001\010\001\255\255\255\255\013\001\014\001\
\015\001\016\001\017\001\018\001\019\001\020\001\021\001\255\255\
\255\255\024\001\025\001\026\001\027\001\028\001\029\001\255\255\
\255\255\255\255\255\255\255\255\255\255\036\001\037\001\255\255\
\255\255\040\001\041\001\042\001\043\001\044\001\255\255\255\255\
\047\001\048\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\061\001\062\001\
\255\255\064\001\255\255\255\255\067\001\068\001\069\001\255\255\
\071\001\072\001\073\001\074\001\075\001\255\255\255\255\255\255\
\255\255\255\255\255\255\082\001\255\255\084\001\255\255\086\001\
\087\001\088\001\255\255\255\255\255\255\255\255\093\001\094\001\
\255\255\096\001\097\001\098\001\099\001\000\000\255\255\255\255\
\255\255\255\255\105\001\255\255\107\001\255\255\255\255\110\001\
\255\255\255\255\113\001\255\255\255\255\255\255\117\001\000\001\
\001\001\002\001\003\001\255\255\255\255\255\255\255\255\008\001\
\009\001\010\001\255\255\255\255\013\001\014\001\015\001\016\001\
\017\001\018\001\019\001\020\001\021\001\255\255\255\255\024\001\
\025\001\026\001\027\001\028\001\029\001\255\255\255\255\255\255\
\255\255\255\255\255\255\036\001\037\001\255\255\255\255\040\001\
\041\001\042\001\043\001\044\001\255\255\255\255\047\001\048\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\061\001\062\001\255\255\064\001\
\255\255\255\255\067\001\068\001\069\001\255\255\071\001\072\001\
\073\001\074\001\075\001\255\255\255\255\255\255\255\255\255\255\
\255\255\082\001\255\255\084\001\255\255\086\001\087\001\088\001\
\255\255\255\255\255\255\255\255\093\001\094\001\255\255\096\001\
\097\001\098\001\099\001\000\000\255\255\255\255\255\255\255\255\
\105\001\255\255\107\001\255\255\255\255\110\001\255\255\255\255\
\113\001\255\255\255\255\255\255\117\001\255\255\000\001\001\001\
\002\001\003\001\255\255\255\255\255\255\255\255\008\001\009\001\
\010\001\255\255\255\255\013\001\014\001\015\001\016\001\017\001\
\018\001\019\001\020\001\021\001\255\255\255\255\024\001\025\001\
\026\001\027\001\028\001\029\001\255\255\255\255\255\255\255\255\
\255\255\255\255\036\001\037\001\255\255\255\255\040\001\041\001\
\042\001\043\001\044\001\255\255\255\255\047\001\048\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\061\001\062\001\255\255\064\001\255\255\
\255\255\067\001\068\001\069\001\255\255\071\001\072\001\073\001\
\074\001\075\001\255\255\255\255\255\255\255\255\255\255\255\255\
\082\001\255\255\084\001\255\255\086\001\087\001\088\001\255\255\
\255\255\255\255\255\255\093\001\094\001\255\255\096\001\097\001\
\098\001\099\001\000\000\255\255\255\255\255\255\255\255\105\001\
\255\255\107\001\255\255\255\255\110\001\255\255\255\255\113\001\
\255\255\255\255\255\255\117\001\255\255\000\001\001\001\002\001\
\003\001\255\255\255\255\255\255\255\255\008\001\009\001\010\001\
\255\255\255\255\013\001\014\001\015\001\016\001\017\001\018\001\
\019\001\020\001\021\001\255\255\255\255\024\001\025\001\026\001\
\027\001\028\001\029\001\255\255\255\255\255\255\255\255\255\255\
\255\255\036\001\037\001\255\255\255\255\040\001\041\001\042\001\
\043\001\044\001\255\255\255\255\047\001\048\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\061\001\062\001\255\255\064\001\255\255\255\255\
\067\001\068\001\069\001\255\255\071\001\072\001\073\001\074\001\
\075\001\255\255\255\255\255\255\255\255\255\255\255\255\082\001\
\255\255\084\001\255\255\086\001\087\001\088\001\255\255\255\255\
\255\255\255\255\093\001\094\001\255\255\096\001\097\001\098\001\
\099\001\000\000\255\255\255\255\255\255\255\255\105\001\255\255\
\107\001\255\255\255\255\110\001\255\255\255\255\113\001\255\255\
\255\255\255\255\117\001\000\001\001\001\002\001\003\001\255\255\
\255\255\255\255\255\255\008\001\009\001\010\001\255\255\255\255\
\013\001\014\001\015\001\016\001\017\001\018\001\019\001\020\001\
\021\001\255\255\255\255\024\001\025\001\026\001\027\001\028\001\
\029\001\255\255\255\255\255\255\255\255\255\255\255\255\036\001\
\037\001\255\255\255\255\040\001\041\001\042\001\043\001\044\001\
\255\255\255\255\047\001\048\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\061\001\062\001\255\255\064\001\255\255\255\255\067\001\068\001\
\069\001\255\255\071\001\072\001\073\001\074\001\075\001\255\255\
\255\255\255\255\255\255\255\255\255\255\082\001\255\255\084\001\
\255\255\086\001\087\001\088\001\255\255\255\255\255\255\255\255\
\093\001\094\001\255\255\096\001\097\001\098\001\099\001\000\000\
\255\255\255\255\255\255\255\255\105\001\255\255\107\001\255\255\
\255\255\110\001\255\255\255\255\113\001\255\255\255\255\255\255\
\117\001\255\255\000\001\001\001\002\001\003\001\255\255\255\255\
\255\255\255\255\008\001\009\001\010\001\255\255\255\255\013\001\
\014\001\015\001\016\001\017\001\018\001\019\001\020\001\021\001\
\255\255\255\255\024\001\025\001\026\001\027\001\028\001\029\001\
\255\255\255\255\255\255\255\255\255\255\255\255\036\001\037\001\
\255\255\255\255\040\001\041\001\042\001\043\001\044\001\255\255\
\255\255\047\001\048\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\061\001\
\062\001\255\255\064\001\255\255\255\255\067\001\068\001\069\001\
\255\255\071\001\072\001\073\001\074\001\075\001\255\255\255\255\
\255\255\255\255\255\255\255\255\082\001\255\255\084\001\255\255\
\086\001\087\001\088\001\255\255\255\255\255\255\255\255\093\001\
\094\001\255\255\096\001\097\001\098\001\099\001\000\000\255\255\
\255\255\255\255\255\255\105\001\255\255\107\001\255\255\255\255\
\110\001\255\255\255\255\113\001\255\255\255\255\255\255\117\001\
\255\255\000\001\001\001\002\001\003\001\255\255\255\255\255\255\
\255\255\008\001\009\001\010\001\255\255\255\255\013\001\014\001\
\015\001\016\001\017\001\018\001\019\001\020\001\021\001\255\255\
\255\255\024\001\025\001\026\001\027\001\028\001\029\001\255\255\
\255\255\255\255\255\255\255\255\255\255\036\001\037\001\255\255\
\255\255\040\001\041\001\042\001\043\001\044\001\045\001\046\001\
\047\001\048\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\061\001\062\001\
\255\255\255\255\255\255\255\255\067\001\068\001\069\001\255\255\
\071\001\255\255\255\255\074\001\075\001\255\255\255\255\255\255\
\255\255\255\255\255\255\082\001\255\255\084\001\085\001\255\255\
\255\255\088\001\255\255\255\255\255\255\255\255\093\001\094\001\
\255\255\096\001\097\001\098\001\099\001\000\000\255\255\102\001\
\255\255\255\255\105\001\255\255\107\001\255\255\255\255\110\001\
\255\255\255\255\113\001\255\255\255\255\255\255\117\001\000\001\
\001\001\002\001\003\001\255\255\255\255\255\255\255\255\008\001\
\009\001\010\001\255\255\255\255\013\001\014\001\255\255\016\001\
\017\001\018\001\019\001\020\001\021\001\255\255\255\255\024\001\
\025\001\026\001\027\001\028\001\029\001\255\255\255\255\255\255\
\255\255\255\255\255\255\036\001\037\001\255\255\255\255\040\001\
\041\001\042\001\255\255\255\255\255\255\255\255\047\001\048\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\061\001\062\001\255\255\064\001\
\255\255\255\255\255\255\068\001\069\001\255\255\071\001\255\255\
\255\255\074\001\075\001\255\255\255\255\255\255\255\255\255\255\
\255\255\082\001\255\255\084\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\093\001\094\001\255\255\096\001\
\097\001\098\001\099\001\000\000\255\255\255\255\255\255\255\255\
\105\001\255\255\107\001\255\255\255\255\110\001\255\255\255\255\
\113\001\255\255\255\255\255\255\117\001\255\255\000\001\001\001\
\002\001\003\001\255\255\255\255\255\255\255\255\008\001\009\001\
\010\001\255\255\255\255\013\001\014\001\255\255\016\001\017\001\
\018\001\019\001\020\001\021\001\255\255\255\255\024\001\025\001\
\026\001\027\001\028\001\029\001\255\255\255\255\255\255\255\255\
\255\255\255\255\036\001\037\001\255\255\255\255\040\001\041\001\
\042\001\255\255\255\255\255\255\255\255\047\001\048\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\061\001\062\001\255\255\064\001\255\255\
\255\255\255\255\068\001\069\001\255\255\071\001\255\255\255\255\
\074\001\075\001\255\255\255\255\255\255\255\255\255\255\255\255\
\082\001\255\255\084\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\093\001\094\001\255\255\096\001\097\001\
\098\001\099\001\000\000\255\255\255\255\255\255\255\255\105\001\
\255\255\107\001\255\255\255\255\110\001\255\255\255\255\113\001\
\255\255\255\255\255\255\117\001\255\255\000\001\001\001\002\001\
\003\001\255\255\255\255\255\255\255\255\008\001\009\001\010\001\
\255\255\255\255\013\001\014\001\255\255\016\001\017\001\018\001\
\019\001\020\001\021\001\255\255\255\255\024\001\025\001\026\001\
\027\001\028\001\029\001\255\255\255\255\255\255\255\255\255\255\
\255\255\036\001\037\001\255\255\255\255\040\001\041\001\042\001\
\255\255\255\255\255\255\255\255\047\001\048\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\061\001\062\001\255\255\064\001\255\255\255\255\
\255\255\068\001\069\001\255\255\071\001\255\255\255\255\074\001\
\075\001\255\255\255\255\255\255\255\255\255\255\255\255\082\001\
\255\255\084\001\255\255\255\255\000\000\255\255\255\255\255\255\
\255\255\255\255\093\001\094\001\255\255\096\001\097\001\098\001\
\099\001\255\255\255\255\255\255\255\255\255\255\105\001\255\255\
\107\001\255\255\255\255\110\001\255\255\255\255\113\001\255\255\
\255\255\255\255\117\001\000\001\001\001\002\001\003\001\255\255\
\255\255\255\255\255\255\008\001\009\001\010\001\255\255\255\255\
\013\001\014\001\255\255\016\001\017\001\018\001\019\001\020\001\
\021\001\255\255\255\255\024\001\025\001\026\001\027\001\028\001\
\029\001\255\255\255\255\255\255\255\255\255\255\255\255\036\001\
\037\001\255\255\255\255\040\001\041\001\042\001\255\255\255\255\
\255\255\255\255\047\001\048\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\061\001\062\001\255\255\064\001\255\255\255\255\255\255\068\001\
\069\001\255\255\071\001\255\255\255\255\074\001\075\001\255\255\
\255\255\255\255\255\255\000\000\255\255\082\001\255\255\084\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\093\001\094\001\255\255\096\001\097\001\098\001\099\001\255\255\
\255\255\255\255\255\255\255\255\105\001\255\255\107\001\255\255\
\255\255\110\001\255\255\255\255\113\001\255\255\255\255\255\255\
\117\001\255\255\000\001\001\001\002\001\003\001\255\255\255\255\
\255\255\255\255\008\001\009\001\010\001\255\255\255\255\013\001\
\014\001\255\255\016\001\017\001\018\001\019\001\020\001\021\001\
\255\255\255\255\024\001\025\001\026\001\027\001\028\001\029\001\
\255\255\255\255\255\255\255\255\255\255\255\255\036\001\037\001\
\255\255\255\255\040\001\041\001\042\001\255\255\255\255\255\255\
\255\255\047\001\048\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\061\001\
\062\001\255\255\064\001\255\255\255\255\000\000\068\001\069\001\
\255\255\071\001\255\255\255\255\074\001\075\001\255\255\255\255\
\255\255\255\255\255\255\255\255\082\001\255\255\084\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\093\001\
\094\001\255\255\096\001\097\001\098\001\099\001\255\255\255\255\
\255\255\255\255\255\255\105\001\000\001\107\001\255\255\003\001\
\110\001\255\255\255\255\113\001\008\001\009\001\010\001\117\001\
\255\255\013\001\014\001\255\255\016\001\017\001\018\001\019\001\
\020\001\021\001\255\255\255\255\024\001\025\001\026\001\255\255\
\028\001\029\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\037\001\255\255\255\255\040\001\041\001\255\255\255\255\
\255\255\255\255\255\255\047\001\048\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\061\001\255\255\255\255\064\001\255\255\255\255\000\000\
\068\001\069\001\255\255\071\001\255\255\255\255\074\001\075\001\
\255\255\255\255\255\255\255\255\255\255\255\255\082\001\255\255\
\084\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\093\001\094\001\255\255\096\001\097\001\098\001\099\001\
\255\255\255\255\255\255\255\255\255\255\105\001\255\255\107\001\
\255\255\255\255\110\001\000\001\255\255\113\001\003\001\255\255\
\255\255\117\001\255\255\008\001\009\001\010\001\255\255\255\255\
\013\001\014\001\255\255\016\001\017\001\018\001\019\001\020\001\
\021\001\255\255\255\255\024\001\025\001\026\001\255\255\028\001\
\029\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\037\001\255\255\255\255\040\001\041\001\255\255\255\255\255\255\
\255\255\255\255\047\001\048\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\061\001\000\000\255\255\064\001\255\255\255\255\255\255\068\001\
\069\001\255\255\071\001\255\255\255\255\074\001\075\001\255\255\
\255\255\255\255\255\255\255\255\255\255\082\001\255\255\084\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\093\001\094\001\255\255\096\001\097\001\098\001\099\001\255\255\
\255\255\255\255\255\255\255\255\105\001\000\001\107\001\255\255\
\003\001\110\001\255\255\255\255\113\001\008\001\255\255\010\001\
\117\001\255\255\013\001\014\001\255\255\016\001\017\001\018\001\
\019\001\020\001\021\001\255\255\255\255\024\001\025\001\026\001\
\255\255\028\001\029\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\037\001\255\255\255\255\040\001\041\001\255\255\
\255\255\255\255\255\255\255\255\047\001\048\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\000\000\255\255\
\255\255\255\255\061\001\255\255\255\255\064\001\255\255\255\255\
\255\255\068\001\069\001\255\255\071\001\255\255\255\255\074\001\
\075\001\255\255\255\255\255\255\255\255\255\255\255\255\082\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\093\001\094\001\255\255\096\001\097\001\098\001\
\099\001\255\255\255\255\255\255\255\255\255\255\105\001\000\001\
\107\001\255\255\003\001\110\001\255\255\255\255\113\001\008\001\
\255\255\010\001\117\001\255\255\013\001\014\001\255\255\016\001\
\017\001\018\001\019\001\020\001\021\001\255\255\255\255\024\001\
\025\001\026\001\255\255\028\001\029\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\037\001\255\255\255\255\040\001\
\041\001\255\255\255\255\255\255\255\255\255\255\047\001\048\001\
\255\255\255\255\255\255\000\000\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\061\001\255\255\255\255\064\001\
\255\255\255\255\255\255\068\001\069\001\255\255\071\001\255\255\
\255\255\074\001\075\001\255\255\255\255\255\255\255\255\255\255\
\255\255\082\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\093\001\094\001\255\255\096\001\
\097\001\098\001\099\001\255\255\255\255\255\255\255\255\255\255\
\105\001\000\001\107\001\255\255\003\001\110\001\255\255\255\255\
\113\001\008\001\255\255\010\001\117\001\255\255\013\001\014\001\
\255\255\016\001\017\001\018\001\019\001\020\001\021\001\255\255\
\255\255\024\001\025\001\026\001\255\255\028\001\029\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\037\001\255\255\
\255\255\040\001\041\001\255\255\255\255\255\255\255\255\255\255\
\047\001\048\001\255\255\255\255\255\255\000\000\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\061\001\255\255\
\255\255\064\001\255\255\255\255\255\255\068\001\069\001\255\255\
\071\001\255\255\255\255\074\001\075\001\255\255\255\255\255\255\
\255\255\255\255\255\255\082\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\093\001\094\001\
\255\255\096\001\097\001\098\001\099\001\255\255\000\001\255\255\
\255\255\003\001\105\001\255\255\107\001\255\255\008\001\110\001\
\010\001\255\255\113\001\013\001\014\001\255\255\117\001\017\001\
\255\255\019\001\020\001\021\001\255\255\255\255\024\001\025\001\
\026\001\255\255\028\001\029\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\037\001\255\255\255\255\040\001\041\001\
\255\255\255\255\255\255\255\255\255\255\047\001\048\001\255\255\
\255\255\255\255\000\000\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\061\001\255\255\255\255\064\001\255\255\
\255\255\255\255\068\001\069\001\255\255\071\001\255\255\255\255\
\074\001\075\001\255\255\255\255\255\255\255\255\255\255\255\255\
\082\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\093\001\094\001\255\255\096\001\097\001\
\098\001\099\001\255\255\000\001\255\255\255\255\003\001\105\001\
\255\255\107\001\255\255\008\001\110\001\010\001\255\255\113\001\
\013\001\014\001\255\255\117\001\017\001\255\255\019\001\020\001\
\021\001\255\255\255\255\024\001\025\001\026\001\255\255\028\001\
\029\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\037\001\255\255\255\255\040\001\041\001\255\255\255\255\255\255\
\255\255\255\255\047\001\048\001\255\255\255\255\255\255\000\000\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\061\001\255\255\255\255\064\001\255\255\255\255\255\255\068\001\
\069\001\255\255\071\001\255\255\255\255\074\001\075\001\255\255\
\255\255\255\255\255\255\255\255\255\255\082\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\093\001\094\001\255\255\096\001\097\001\098\001\099\001\255\255\
\255\255\255\255\255\255\255\255\105\001\000\001\107\001\255\255\
\003\001\110\001\255\255\255\255\113\001\008\001\255\255\010\001\
\117\001\255\255\013\001\014\001\255\255\255\255\017\001\255\255\
\019\001\020\001\021\001\255\255\255\255\024\001\025\001\026\001\
\255\255\028\001\029\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\037\001\255\255\255\255\040\001\041\001\255\255\
\255\255\255\255\255\255\255\255\047\001\048\001\255\255\255\255\
\255\255\000\000\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\061\001\255\255\255\255\064\001\255\255\255\255\
\255\255\068\001\069\001\255\255\071\001\255\255\255\255\074\001\
\075\001\255\255\255\255\255\255\255\255\255\255\255\255\082\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\093\001\094\001\255\255\096\001\097\001\098\001\
\099\001\255\255\000\001\255\255\255\255\003\001\105\001\255\255\
\107\001\255\255\008\001\110\001\010\001\255\255\113\001\013\001\
\014\001\255\255\117\001\017\001\255\255\019\001\020\001\021\001\
\255\255\255\255\024\001\025\001\026\001\255\255\028\001\029\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\037\001\
\255\255\255\255\040\001\041\001\255\255\255\255\255\255\255\255\
\255\255\047\001\048\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\061\001\
\255\255\000\000\064\001\255\255\255\255\255\255\068\001\069\001\
\255\255\071\001\000\000\255\255\074\001\075\001\255\255\255\255\
\255\255\255\255\255\255\255\255\082\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\093\001\
\094\001\255\255\096\001\097\001\098\001\099\001\255\255\000\001\
\255\255\255\255\003\001\105\001\255\255\107\001\255\255\008\001\
\110\001\010\001\255\255\113\001\013\001\014\001\255\255\117\001\
\017\001\255\255\019\001\020\001\021\001\255\255\255\255\024\001\
\025\001\026\001\255\255\028\001\029\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\037\001\255\255\255\255\040\001\
\041\001\255\255\255\255\255\255\255\255\255\255\047\001\048\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\061\001\255\255\255\255\064\001\
\255\255\255\255\255\255\068\001\069\001\255\255\071\001\255\255\
\255\255\074\001\075\001\255\255\000\000\255\255\255\255\255\255\
\255\255\082\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\093\001\094\001\255\255\096\001\
\097\001\098\001\099\001\255\255\255\255\255\255\255\255\255\255\
\105\001\000\001\107\001\255\255\003\001\110\001\255\255\255\255\
\113\001\008\001\255\255\010\001\117\001\255\255\013\001\014\001\
\255\255\255\255\017\001\255\255\019\001\020\001\021\001\255\255\
\255\255\024\001\025\001\026\001\255\255\028\001\029\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\037\001\255\255\
\255\255\040\001\041\001\255\255\255\255\255\255\255\255\255\255\
\047\001\048\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\061\001\255\255\
\255\255\064\001\255\255\255\255\255\255\068\001\069\001\255\255\
\071\001\255\255\255\255\074\001\075\001\255\255\255\255\255\255\
\255\255\255\255\255\255\082\001\000\000\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\093\001\094\001\
\255\255\096\001\255\255\098\001\099\001\255\255\255\255\255\255\
\255\255\255\255\105\001\255\255\107\001\255\255\255\255\110\001\
\255\255\000\001\113\001\002\001\003\001\004\001\117\001\255\255\
\255\255\008\001\000\001\255\255\255\255\255\255\013\001\255\255\
\255\255\255\255\017\001\018\001\019\001\255\255\255\255\013\001\
\255\255\255\255\255\255\026\001\027\001\028\001\029\001\255\255\
\255\255\255\255\255\255\255\255\026\001\036\001\028\001\029\001\
\255\255\255\255\041\001\255\255\255\255\255\255\255\255\255\255\
\047\001\048\001\056\001\041\001\058\001\059\001\060\001\255\255\
\062\001\255\255\255\255\065\001\066\001\255\255\061\001\255\255\
\255\255\064\001\065\001\255\255\067\001\068\001\069\001\061\001\
\071\001\000\000\064\001\074\001\075\001\255\255\068\001\069\001\
\255\255\255\255\255\255\082\001\255\255\075\001\092\001\255\255\
\255\255\255\255\255\255\255\255\082\001\099\001\093\001\094\001\
\255\255\096\001\097\001\098\001\099\001\255\255\255\255\102\001\
\094\001\111\001\112\001\255\255\098\001\099\001\255\255\110\001\
\111\001\255\255\113\001\255\255\000\001\255\255\117\001\003\001\
\110\001\255\255\255\255\113\001\008\001\255\255\010\001\255\255\
\255\255\013\001\014\001\255\255\255\255\017\001\255\255\019\001\
\020\001\021\001\255\255\255\255\024\001\255\255\026\001\255\255\
\028\001\029\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\037\001\255\255\255\255\040\001\041\001\255\255\255\255\
\255\255\255\255\255\255\047\001\048\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\000\000\255\255\
\255\255\061\001\255\255\255\255\064\001\255\255\255\255\255\255\
\068\001\069\001\255\255\071\001\255\255\255\255\074\001\075\001\
\255\255\255\255\255\255\255\255\255\255\255\255\082\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\093\001\094\001\255\255\096\001\097\001\098\001\099\001\
\255\255\255\255\255\255\255\255\255\255\105\001\255\255\107\001\
\255\255\255\255\110\001\255\255\000\001\113\001\002\001\003\001\
\004\001\117\001\255\255\255\255\008\001\255\255\255\255\255\255\
\255\255\013\001\255\255\255\255\255\255\017\001\018\001\019\001\
\255\255\255\255\255\255\255\255\255\255\255\255\026\001\027\001\
\028\001\029\001\255\255\255\255\255\255\255\255\255\255\255\255\
\036\001\255\255\255\255\255\255\255\255\041\001\255\255\255\255\
\255\255\255\255\255\255\047\001\048\001\000\000\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\061\001\255\255\255\255\064\001\255\255\255\255\067\001\
\068\001\069\001\255\255\071\001\255\255\255\255\074\001\075\001\
\255\255\255\255\255\255\255\255\255\255\255\255\082\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\093\001\094\001\255\255\096\001\097\001\098\001\099\001\
\255\255\000\001\255\255\002\001\003\001\004\001\255\255\255\255\
\255\255\008\001\110\001\255\255\255\255\113\001\013\001\255\255\
\255\255\117\001\017\001\018\001\019\001\255\255\255\255\255\255\
\255\255\255\255\255\255\026\001\027\001\028\001\029\001\255\255\
\255\255\255\255\255\255\255\255\255\255\036\001\255\255\255\255\
\255\255\255\255\041\001\255\255\255\255\255\255\255\255\255\255\
\047\001\048\001\000\000\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\061\001\255\255\
\255\255\064\001\255\255\255\255\067\001\068\001\069\001\255\255\
\071\001\255\255\255\255\074\001\075\001\255\255\255\255\255\255\
\255\255\255\255\255\255\082\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\093\001\094\001\
\255\255\096\001\097\001\098\001\255\255\255\255\000\001\102\001\
\002\001\003\001\004\001\255\255\255\255\255\255\008\001\110\001\
\255\255\255\255\113\001\013\001\255\255\255\255\117\001\017\001\
\018\001\019\001\255\255\255\255\255\255\255\255\255\255\255\255\
\026\001\027\001\028\001\029\001\255\255\255\255\255\255\255\255\
\255\255\255\255\036\001\255\255\255\255\255\255\255\255\041\001\
\255\255\255\255\255\255\255\255\255\255\047\001\048\001\000\000\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\061\001\255\255\255\255\064\001\255\255\
\255\255\067\001\068\001\069\001\255\255\071\001\255\255\255\255\
\074\001\075\001\255\255\255\255\255\255\255\255\255\255\255\255\
\082\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\093\001\094\001\255\255\096\001\097\001\
\098\001\255\255\255\255\255\255\102\001\000\001\255\255\002\001\
\003\001\004\001\255\255\255\255\110\001\008\001\255\255\113\001\
\255\255\255\255\013\001\117\001\255\255\255\255\017\001\018\001\
\019\001\255\255\255\255\255\255\255\255\255\255\255\255\026\001\
\027\001\028\001\029\001\255\255\255\255\255\255\255\255\255\255\
\255\255\036\001\255\255\255\255\255\255\255\255\041\001\255\255\
\255\255\255\255\255\255\255\255\047\001\048\001\000\000\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\061\001\255\255\255\255\064\001\255\255\255\255\
\067\001\068\001\069\001\255\255\071\001\255\255\255\255\074\001\
\075\001\255\255\255\255\255\255\255\255\255\255\255\255\082\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\093\001\094\001\255\255\096\001\097\001\098\001\
\099\001\255\255\000\001\255\255\002\001\003\001\004\001\255\255\
\255\255\255\255\008\001\110\001\255\255\255\255\113\001\013\001\
\255\255\255\255\117\001\017\001\018\001\019\001\255\255\255\255\
\255\255\255\255\255\255\255\255\026\001\027\001\028\001\029\001\
\255\255\255\255\255\255\255\255\255\255\255\255\036\001\255\255\
\255\255\255\255\255\255\041\001\255\255\255\255\255\255\255\255\
\255\255\047\001\048\001\000\000\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\061\001\
\255\255\255\255\064\001\255\255\255\255\067\001\068\001\069\001\
\255\255\071\001\255\255\255\255\255\255\075\001\255\255\255\255\
\255\255\255\255\255\255\255\255\082\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\093\001\
\094\001\255\255\096\001\097\001\098\001\099\001\255\255\000\001\
\255\255\002\001\003\001\004\001\255\255\255\255\000\000\008\001\
\110\001\255\255\255\255\113\001\013\001\255\255\255\255\117\001\
\017\001\018\001\019\001\255\255\255\255\255\255\255\255\255\255\
\255\255\026\001\027\001\028\001\029\001\255\255\255\255\255\255\
\255\255\255\255\255\255\036\001\255\255\255\255\255\255\255\255\
\041\001\255\255\255\255\255\255\255\255\255\255\047\001\048\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\000\000\255\255\255\255\255\255\061\001\255\255\255\255\064\001\
\255\255\255\255\067\001\068\001\069\001\255\255\071\001\255\255\
\255\255\255\255\075\001\255\255\255\255\255\255\255\255\255\255\
\255\255\082\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\093\001\094\001\255\255\096\001\
\097\001\098\001\099\001\255\255\255\255\255\255\000\001\255\255\
\002\001\003\001\004\001\255\255\255\255\110\001\008\001\255\255\
\113\001\255\255\255\255\013\001\117\001\255\255\255\255\017\001\
\018\001\019\001\255\255\255\255\255\255\255\255\255\255\255\255\
\026\001\027\001\028\001\029\001\255\255\255\255\255\255\255\255\
\255\255\255\255\036\001\255\255\255\255\255\255\255\255\041\001\
\255\255\255\255\255\255\255\255\255\255\047\001\048\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\061\001\255\255\255\255\064\001\255\255\
\255\255\067\001\068\001\069\001\000\000\071\001\255\255\255\255\
\255\255\075\001\255\255\255\255\255\255\255\255\255\255\255\255\
\082\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\093\001\094\001\255\255\096\001\097\001\
\098\001\099\001\255\255\000\001\255\255\002\001\003\001\004\001\
\255\255\255\255\255\255\008\001\110\001\255\255\255\255\113\001\
\013\001\255\255\255\255\117\001\017\001\018\001\019\001\255\255\
\255\255\255\255\255\255\255\255\255\255\026\001\027\001\028\001\
\029\001\255\255\255\255\255\255\255\255\255\255\255\255\036\001\
\255\255\255\255\255\255\255\255\041\001\255\255\255\255\255\255\
\255\255\255\255\047\001\048\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\000\001\255\255\
\061\001\003\001\255\255\064\001\255\255\255\255\067\001\068\001\
\069\001\255\255\071\001\013\001\255\255\255\255\075\001\255\255\
\255\255\019\001\255\255\255\255\000\000\082\001\255\255\255\255\
\026\001\027\001\028\001\029\001\255\255\255\255\255\255\255\255\
\093\001\094\001\255\255\096\001\097\001\098\001\099\001\041\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\000\001\110\001\255\255\003\001\113\001\255\255\255\255\255\255\
\117\001\255\255\255\255\061\001\255\255\013\001\064\001\255\255\
\255\255\255\255\068\001\069\001\255\255\255\255\255\255\255\255\
\255\255\075\001\026\001\027\001\028\001\029\001\255\255\255\255\
\082\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\041\001\255\255\255\255\094\001\255\255\096\001\255\255\
\098\001\099\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\110\001\061\001\255\255\113\001\
\064\001\255\255\255\255\117\001\068\001\069\001\255\255\255\255\
\255\255\255\255\255\255\075\001\255\255\255\255\255\255\000\000\
\255\255\255\255\082\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\094\001\255\255\
\096\001\255\255\098\001\099\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\110\001\255\255\
\255\255\113\001\255\255\255\255\000\001\117\001\255\255\003\001\
\255\255\005\001\006\001\007\001\008\001\255\255\255\255\011\001\
\012\001\013\001\255\255\255\255\255\255\255\255\255\255\019\001\
\255\255\255\255\255\255\255\255\255\255\255\255\026\001\255\255\
\028\001\029\001\030\001\031\001\032\001\033\001\034\001\255\255\
\036\001\255\255\255\255\039\001\255\255\041\001\255\255\255\255\
\255\255\255\255\255\255\047\001\048\001\049\001\050\001\051\001\
\052\001\053\001\054\001\055\001\056\001\057\001\255\255\255\255\
\060\001\061\001\255\255\255\255\064\001\065\001\066\001\255\255\
\068\001\069\001\070\001\071\001\072\001\073\001\255\255\075\001\
\076\001\077\001\078\001\000\000\080\001\255\255\082\001\083\001\
\255\255\255\255\086\001\087\001\255\255\089\001\255\255\091\001\
\255\255\093\001\094\001\095\001\255\255\097\001\098\001\099\001\
\255\255\255\255\255\255\103\001\255\255\255\255\106\001\255\255\
\108\001\109\001\110\001\111\001\112\001\113\001\255\255\255\255\
\116\001\005\001\006\001\007\001\255\255\255\255\255\255\011\001\
\012\001\013\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\028\001\029\001\030\001\031\001\032\001\033\001\034\001\255\255\
\255\255\255\255\255\255\039\001\255\255\041\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\049\001\050\001\051\001\
\255\255\053\001\054\001\055\001\056\001\057\001\255\255\255\255\
\060\001\061\001\255\255\255\255\064\001\065\001\066\001\255\255\
\255\255\069\001\070\001\255\255\072\001\073\001\255\255\075\001\
\255\255\077\001\078\001\255\255\080\001\000\000\082\001\255\255\
\255\255\255\255\086\001\087\001\255\255\089\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\098\001\099\001\
\255\255\255\255\255\255\103\001\255\255\255\255\255\255\255\255\
\108\001\109\001\110\001\111\001\005\001\006\001\007\001\255\255\
\116\001\255\255\011\001\012\001\013\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\028\001\029\001\030\001\031\001\032\001\
\033\001\034\001\255\255\255\255\255\255\255\255\039\001\255\255\
\041\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\049\001\050\001\051\001\255\255\053\001\054\001\055\001\056\001\
\057\001\255\255\255\255\060\001\061\001\255\255\255\255\064\001\
\065\001\066\001\255\255\255\255\069\001\070\001\255\255\072\001\
\073\001\255\255\075\001\255\255\077\001\078\001\255\255\080\001\
\255\255\082\001\255\255\255\255\255\255\086\001\087\001\000\000\
\089\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\099\001\255\255\255\255\255\255\103\001\255\255\
\255\255\255\255\255\255\108\001\109\001\110\001\111\001\255\255\
\255\255\255\255\255\255\116\001\255\255\255\255\255\255\255\255\
\005\001\006\001\007\001\255\255\255\255\255\255\011\001\012\001\
\013\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\028\001\
\029\001\030\001\031\001\032\001\033\001\034\001\255\255\255\255\
\255\255\255\255\039\001\255\255\041\001\255\255\255\255\255\255\
\255\255\255\255\255\255\000\000\049\001\050\001\051\001\255\255\
\053\001\054\001\055\001\056\001\057\001\255\255\255\255\060\001\
\061\001\255\255\255\255\064\001\065\001\066\001\255\255\255\255\
\069\001\070\001\255\255\072\001\073\001\255\255\075\001\255\255\
\077\001\078\001\255\255\080\001\255\255\082\001\255\255\255\255\
\255\255\086\001\087\001\255\255\089\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\099\001\255\255\
\255\255\255\255\103\001\255\255\255\255\255\255\000\000\108\001\
\109\001\110\001\111\001\255\255\255\255\000\001\255\255\116\001\
\255\255\004\001\255\255\006\001\255\255\008\001\255\255\010\001\
\255\255\012\001\013\001\014\001\015\001\255\255\017\001\018\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\026\001\
\027\001\028\001\029\001\030\001\031\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\041\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\049\001\050\001\
\051\001\052\001\053\001\054\001\255\255\056\001\057\001\255\255\
\255\255\060\001\061\001\255\255\255\255\064\001\065\001\066\001\
\067\001\068\001\069\001\255\255\000\000\072\001\255\255\074\001\
\075\001\255\255\077\001\255\255\255\255\255\255\255\255\082\001\
\083\001\255\255\255\255\086\001\255\255\255\255\255\255\255\255\
\091\001\255\255\093\001\094\001\255\255\096\001\097\001\098\001\
\099\001\255\255\255\255\255\255\103\001\255\255\255\255\106\001\
\255\255\108\001\255\255\110\001\111\001\112\001\255\255\000\001\
\115\001\255\255\255\255\004\001\255\255\006\001\255\255\008\001\
\255\255\010\001\255\255\012\001\255\255\014\001\015\001\000\000\
\017\001\018\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\027\001\255\255\255\255\030\001\031\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\049\001\050\001\051\001\052\001\255\255\054\001\255\255\056\001\
\057\001\255\255\255\255\060\001\255\255\255\255\255\255\255\255\
\065\001\066\001\067\001\255\255\255\255\255\255\255\255\072\001\
\255\255\074\001\000\000\000\001\077\001\255\255\003\001\004\001\
\255\255\255\255\083\001\255\255\255\255\086\001\255\255\255\255\
\013\001\014\001\091\001\255\255\093\001\094\001\019\001\096\001\
\097\001\255\255\099\001\255\255\255\255\026\001\103\001\028\001\
\029\001\106\001\255\255\108\001\255\255\255\255\111\001\112\001\
\255\255\255\255\115\001\255\255\041\001\255\255\255\255\255\255\
\255\255\255\255\047\001\048\001\000\000\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\000\001\255\255\
\061\001\003\001\004\001\064\001\255\255\255\255\067\001\068\001\
\069\001\255\255\071\001\013\001\014\001\255\255\075\001\255\255\
\255\255\019\001\255\255\255\255\255\255\082\001\255\255\255\255\
\026\001\255\255\028\001\029\001\255\255\255\255\255\255\255\255\
\255\255\094\001\255\255\096\001\255\255\098\001\099\001\041\001\
\255\255\255\255\255\255\255\255\255\255\047\001\048\001\000\000\
\255\255\110\001\255\255\255\255\113\001\255\255\255\255\255\255\
\255\255\255\255\255\255\061\001\255\255\255\255\064\001\255\255\
\255\255\067\001\068\001\069\001\255\255\071\001\255\255\255\255\
\255\255\075\001\255\255\255\255\000\001\255\255\255\255\003\001\
\082\001\255\255\255\255\255\255\008\001\255\255\255\255\255\255\
\255\255\013\001\014\001\255\255\094\001\255\255\096\001\019\001\
\098\001\099\001\022\001\255\255\255\255\255\255\026\001\255\255\
\028\001\029\001\000\000\255\255\110\001\255\255\255\255\113\001\
\255\255\255\255\255\255\255\255\056\001\041\001\058\001\059\001\
\060\001\255\255\062\001\255\255\255\255\065\001\066\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\000\001\
\255\255\061\001\003\001\004\001\064\001\255\255\066\001\067\001\
\068\001\069\001\255\255\255\255\013\001\014\001\255\255\075\001\
\092\001\255\255\019\001\255\255\255\255\081\001\082\001\099\001\
\255\255\026\001\255\255\028\001\029\001\255\255\000\000\255\255\
\255\255\255\255\094\001\111\001\112\001\255\255\098\001\099\001\
\041\001\255\255\255\255\255\255\255\255\255\255\047\001\048\001\
\255\255\255\255\110\001\255\255\255\255\113\001\255\255\255\255\
\255\255\255\255\000\001\255\255\061\001\003\001\004\001\064\001\
\255\255\255\255\255\255\068\001\069\001\255\255\071\001\013\001\
\014\001\255\255\075\001\255\255\255\255\019\001\255\255\255\255\
\255\255\082\001\255\255\255\255\026\001\000\000\028\001\029\001\
\255\255\255\255\255\255\255\255\255\255\094\001\255\255\096\001\
\255\255\098\001\099\001\041\001\255\255\255\255\255\255\255\255\
\255\255\047\001\048\001\255\255\000\001\110\001\255\255\003\001\
\113\001\255\255\255\255\255\255\255\255\255\255\255\255\061\001\
\255\255\013\001\064\001\255\255\255\255\255\255\068\001\069\001\
\255\255\071\001\255\255\255\255\255\255\075\001\026\001\027\001\
\028\001\029\001\255\255\255\255\082\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\041\001\255\255\255\255\
\094\001\255\255\096\001\255\255\098\001\099\001\255\255\255\255\
\255\255\000\000\255\255\255\255\255\255\255\255\255\255\000\001\
\110\001\061\001\003\001\113\001\255\255\065\001\255\255\067\001\
\068\001\069\001\000\000\255\255\013\001\255\255\074\001\075\001\
\255\255\255\255\255\255\255\255\255\255\255\255\082\001\255\255\
\255\255\026\001\027\001\028\001\029\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\096\001\255\255\098\001\099\001\
\041\001\255\255\102\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\110\001\111\001\255\255\113\001\255\255\255\255\
\255\255\255\255\000\001\255\255\061\001\003\001\255\255\255\255\
\065\001\255\255\067\001\068\001\069\001\255\255\255\255\013\001\
\255\255\074\001\075\001\255\255\255\255\255\255\255\255\255\255\
\255\255\082\001\255\255\255\255\026\001\027\001\028\001\029\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\096\001\
\255\255\098\001\099\001\041\001\255\255\102\001\000\000\255\255\
\255\255\255\255\255\255\255\255\255\255\110\001\111\001\255\255\
\113\001\255\255\255\255\255\255\255\255\255\255\000\001\061\001\
\255\255\003\001\255\255\065\001\255\255\067\001\068\001\069\001\
\255\255\255\255\255\255\013\001\074\001\075\001\255\255\255\255\
\255\255\019\001\255\255\255\255\082\001\255\255\255\255\255\255\
\026\001\255\255\028\001\029\001\255\255\255\255\255\255\255\255\
\255\255\255\255\096\001\255\255\098\001\099\001\040\001\041\001\
\102\001\255\255\255\255\255\255\255\255\047\001\048\001\255\255\
\110\001\111\001\255\255\113\001\255\255\000\001\255\255\255\255\
\003\001\255\255\255\255\061\001\000\000\008\001\064\001\255\255\
\255\255\255\255\013\001\069\001\255\255\071\001\000\000\255\255\
\019\001\075\001\255\255\255\255\255\255\255\255\255\255\026\001\
\082\001\028\001\029\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\094\001\255\255\041\001\255\255\
\098\001\099\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\110\001\255\255\255\255\113\001\
\255\255\255\255\061\001\255\255\255\255\064\001\255\255\255\255\
\067\001\068\001\069\001\255\255\255\255\255\255\255\255\074\001\
\075\001\000\001\255\255\255\255\003\001\255\255\255\255\082\001\
\255\255\008\001\000\000\255\255\255\255\255\255\013\001\255\255\
\255\255\255\255\000\001\094\001\019\001\003\001\255\255\098\001\
\099\001\255\255\008\001\026\001\255\255\028\001\029\001\013\001\
\255\255\255\255\255\255\110\001\255\255\019\001\113\001\255\255\
\255\255\255\255\041\001\255\255\026\001\255\255\028\001\029\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\041\001\000\000\255\255\061\001\255\255\
\255\255\064\001\255\255\255\255\067\001\068\001\069\001\255\255\
\255\255\255\255\255\255\074\001\075\001\255\255\255\255\061\001\
\255\255\255\255\064\001\082\001\000\000\067\001\068\001\069\001\
\255\255\255\255\255\255\255\255\074\001\075\001\255\255\094\001\
\255\255\255\255\255\255\098\001\082\001\255\255\255\255\102\001\
\255\255\255\255\255\255\255\255\255\255\255\255\000\001\110\001\
\094\001\003\001\113\001\255\255\098\001\255\255\008\001\255\255\
\102\001\255\255\255\255\013\001\255\255\255\255\255\255\255\255\
\110\001\019\001\255\255\113\001\255\255\255\255\000\000\255\255\
\026\001\255\255\028\001\029\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\041\001\
\255\255\255\255\056\001\255\255\058\001\059\001\060\001\255\255\
\062\001\255\255\255\255\065\001\066\001\255\255\255\255\255\255\
\255\255\255\255\255\255\061\001\255\255\075\001\064\001\255\255\
\255\255\067\001\068\001\069\001\255\255\083\001\255\255\255\255\
\074\001\075\001\255\255\255\255\000\001\091\001\092\001\003\001\
\082\001\000\000\096\001\255\255\008\001\099\001\000\001\255\255\
\255\255\013\001\255\255\255\255\094\001\255\255\255\255\019\001\
\098\001\111\001\112\001\013\001\102\001\255\255\026\001\255\255\
\028\001\029\001\255\255\255\255\110\001\255\255\255\255\113\001\
\026\001\255\255\028\001\029\001\255\255\041\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\041\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\061\001\255\255\255\255\064\001\000\000\255\255\067\001\
\068\001\069\001\255\255\061\001\255\255\255\255\074\001\075\001\
\255\255\255\255\000\001\069\001\255\255\003\001\082\001\255\255\
\255\255\075\001\008\001\255\255\255\255\255\255\255\255\013\001\
\082\001\255\255\094\001\255\255\255\255\019\001\098\001\255\255\
\255\255\255\255\102\001\255\255\026\001\255\255\028\001\029\001\
\098\001\255\255\110\001\255\255\255\255\113\001\255\255\255\255\
\255\255\255\255\255\255\041\001\110\001\255\255\255\255\113\001\
\000\000\255\255\255\255\255\255\000\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\061\001\
\255\255\013\001\064\001\255\255\255\255\067\001\068\001\069\001\
\255\255\255\255\255\255\255\255\000\001\075\001\026\001\003\001\
\028\001\029\001\255\255\255\255\082\001\255\255\255\255\255\255\
\255\255\013\001\255\255\255\255\255\255\041\001\255\255\019\001\
\094\001\255\255\255\255\255\255\098\001\099\001\026\001\255\255\
\028\001\029\001\255\255\000\000\255\255\255\255\255\255\000\000\
\110\001\061\001\255\255\113\001\255\255\041\001\255\255\255\255\
\255\255\069\001\255\255\255\255\255\255\255\255\000\001\075\001\
\255\255\003\001\255\255\255\255\255\255\255\255\082\001\255\255\
\255\255\061\001\255\255\013\001\064\001\255\255\255\255\255\255\
\068\001\069\001\255\255\255\255\255\255\255\255\098\001\075\001\
\026\001\027\001\028\001\029\001\255\255\255\255\082\001\255\255\
\255\255\255\255\110\001\255\255\088\001\113\001\000\000\041\001\
\255\255\255\255\094\001\255\255\255\255\255\255\098\001\099\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\000\001\110\001\061\001\003\001\113\001\064\001\255\255\
\255\255\008\001\068\001\069\001\255\255\255\255\013\001\255\255\
\255\255\075\001\255\255\255\255\019\001\255\255\255\255\255\255\
\082\001\255\255\255\255\026\001\255\255\028\001\029\001\255\255\
\000\000\255\255\255\255\255\255\094\001\255\255\096\001\255\255\
\098\001\099\001\041\001\255\255\255\255\255\255\255\255\255\255\
\255\255\000\000\255\255\255\255\110\001\255\255\255\255\113\001\
\255\255\255\255\255\255\255\255\255\255\000\001\061\001\255\255\
\003\001\064\001\255\255\255\255\255\255\068\001\069\001\255\255\
\255\255\255\255\013\001\255\255\075\001\255\255\255\255\255\255\
\019\001\255\255\255\255\082\001\255\255\255\255\255\255\026\001\
\255\255\028\001\029\001\255\255\255\255\255\255\255\255\094\001\
\255\255\255\255\255\255\098\001\099\001\255\255\041\001\255\255\
\255\255\255\255\255\255\255\255\000\000\255\255\255\255\110\001\
\255\255\255\255\113\001\255\255\255\255\255\255\255\255\255\255\
\000\001\255\255\061\001\003\001\255\255\064\001\255\255\255\255\
\255\255\068\001\069\001\255\255\255\255\013\001\255\255\255\255\
\075\001\255\255\255\255\019\001\255\255\255\255\255\255\082\001\
\255\255\255\255\026\001\255\255\028\001\029\001\255\255\255\255\
\255\255\255\255\255\255\094\001\255\255\255\255\000\000\098\001\
\099\001\041\001\255\255\255\255\255\255\255\255\255\255\000\000\
\255\255\255\255\255\255\110\001\255\255\255\255\113\001\255\255\
\255\255\255\255\255\255\000\001\255\255\061\001\003\001\000\001\
\064\001\255\255\255\255\255\255\068\001\069\001\255\255\255\255\
\013\001\255\255\255\255\075\001\013\001\255\255\019\001\255\255\
\255\255\255\255\082\001\255\255\255\255\026\001\255\255\028\001\
\029\001\026\001\255\255\028\001\029\001\255\255\094\001\255\255\
\255\255\000\000\098\001\099\001\041\001\255\255\255\255\255\255\
\041\001\255\255\255\255\255\255\255\255\255\255\110\001\255\255\
\255\255\113\001\255\255\255\255\255\255\255\255\000\001\255\255\
\061\001\003\001\255\255\064\001\061\001\255\255\255\255\068\001\
\069\001\255\255\255\255\013\001\069\001\255\255\075\001\255\255\
\255\255\019\001\075\001\255\255\255\255\082\001\255\255\255\255\
\026\001\082\001\028\001\029\001\255\255\255\255\255\255\255\255\
\255\255\094\001\255\255\255\255\000\000\098\001\099\001\041\001\
\255\255\098\001\255\255\255\255\255\255\255\255\255\255\255\255\
\000\001\110\001\255\255\255\255\113\001\110\001\255\255\255\255\
\113\001\255\255\255\255\061\001\255\255\013\001\064\001\255\255\
\255\255\000\001\068\001\069\001\003\001\255\255\255\255\255\255\
\255\255\075\001\026\001\255\255\028\001\029\001\013\001\255\255\
\082\001\000\000\255\255\255\255\019\001\255\255\255\255\255\255\
\255\255\041\001\255\255\026\001\094\001\028\001\029\001\255\255\
\098\001\099\001\255\255\255\255\255\255\255\255\255\255\000\000\
\255\255\255\255\041\001\255\255\110\001\061\001\255\255\113\001\
\255\255\255\255\255\255\255\255\255\255\069\001\255\255\255\255\
\255\255\255\255\255\255\075\001\000\001\255\255\061\001\003\001\
\255\255\064\001\082\001\255\255\255\255\068\001\069\001\255\255\
\255\255\013\001\255\255\255\255\075\001\255\255\255\255\019\001\
\255\255\255\255\098\001\082\001\000\000\255\255\026\001\255\255\
\028\001\029\001\255\255\255\255\255\255\255\255\110\001\094\001\
\255\255\113\001\255\255\098\001\099\001\041\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\000\001\110\001\
\255\255\255\255\113\001\255\255\255\255\255\255\008\001\000\001\
\255\255\061\001\255\255\013\001\064\001\255\255\255\255\255\255\
\068\001\069\001\255\255\255\255\013\001\255\255\000\000\075\001\
\026\001\255\255\028\001\029\001\255\255\255\255\082\001\000\000\
\255\255\026\001\255\255\028\001\029\001\255\255\255\255\041\001\
\255\255\255\255\094\001\255\255\255\255\255\255\098\001\099\001\
\041\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\000\001\110\001\061\001\255\255\113\001\064\001\255\255\
\255\255\255\255\068\001\069\001\061\001\255\255\013\001\064\001\
\255\255\075\001\255\255\068\001\069\001\255\255\255\255\255\255\
\082\001\255\255\075\001\026\001\255\255\028\001\029\001\255\255\
\255\255\082\001\255\255\255\255\094\001\255\255\255\255\255\255\
\098\001\099\001\041\001\255\255\255\255\094\001\255\255\255\255\
\255\255\098\001\099\001\255\255\110\001\000\000\255\255\113\001\
\255\255\255\255\255\255\255\255\000\001\110\001\061\001\003\001\
\113\001\064\001\255\255\255\255\255\255\068\001\069\001\255\255\
\255\255\013\001\255\255\000\000\075\001\255\255\255\255\255\255\
\255\255\255\255\255\255\082\001\255\255\255\255\026\001\255\255\
\028\001\029\001\255\255\255\255\255\255\255\255\255\255\094\001\
\255\255\000\000\255\255\098\001\099\001\041\001\255\255\255\255\
\255\255\000\001\255\255\255\255\255\255\255\255\255\255\110\001\
\255\255\255\255\113\001\255\255\255\255\255\255\013\001\255\255\
\255\255\061\001\255\255\255\255\064\001\255\255\255\255\000\001\
\255\255\069\001\003\001\026\001\255\255\028\001\029\001\075\001\
\255\255\255\255\255\255\255\255\013\001\255\255\082\001\255\255\
\255\255\255\255\041\001\255\255\255\255\255\255\255\255\255\255\
\255\255\026\001\094\001\028\001\029\001\255\255\098\001\099\001\
\255\255\255\255\255\255\255\255\255\255\255\255\061\001\040\001\
\041\001\064\001\110\001\255\255\000\001\113\001\069\001\003\001\
\000\000\255\255\255\255\255\255\075\001\255\255\255\255\255\255\
\255\255\013\001\000\000\082\001\061\001\255\255\255\255\064\001\
\255\255\255\255\255\255\068\001\069\001\255\255\026\001\094\001\
\028\001\029\001\075\001\098\001\099\001\255\255\255\255\255\255\
\255\255\082\001\255\255\255\255\040\001\041\001\255\255\110\001\
\255\255\255\255\113\001\255\255\255\255\094\001\000\001\255\255\
\255\255\098\001\099\001\255\255\255\255\255\255\008\001\000\001\
\255\255\061\001\255\255\013\001\064\001\110\001\255\255\255\255\
\068\001\069\001\255\255\255\255\013\001\255\255\255\255\075\001\
\026\001\255\255\028\001\029\001\255\255\000\000\082\001\255\255\
\255\255\026\001\255\255\028\001\029\001\255\255\255\255\041\001\
\255\255\255\255\094\001\255\255\255\255\255\255\098\001\099\001\
\041\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\110\001\061\001\255\255\255\255\064\001\255\255\
\255\255\067\001\068\001\069\001\061\001\255\255\255\255\064\001\
\255\255\075\001\067\001\068\001\069\001\255\255\255\255\000\000\
\082\001\255\255\075\001\255\255\255\255\000\001\255\255\255\255\
\003\001\082\001\255\255\255\255\094\001\255\255\255\255\255\255\
\098\001\099\001\013\001\255\255\255\255\094\001\255\255\255\255\
\255\255\098\001\099\001\000\001\110\001\255\255\003\001\026\001\
\255\255\028\001\029\001\255\255\255\255\110\001\000\000\255\255\
\013\001\255\255\255\255\255\255\255\255\040\001\041\001\255\255\
\255\255\000\001\255\255\255\255\003\001\026\001\255\255\028\001\
\029\001\255\255\255\255\255\255\255\255\255\255\013\001\255\255\
\255\255\255\255\061\001\255\255\041\001\064\001\255\255\255\255\
\255\255\255\255\069\001\026\001\255\255\028\001\029\001\255\255\
\075\001\255\255\000\000\255\255\255\255\255\255\255\255\082\001\
\061\001\255\255\041\001\064\001\255\255\255\255\255\255\068\001\
\069\001\255\255\255\255\094\001\255\255\255\255\075\001\098\001\
\099\001\255\255\255\255\255\255\255\255\082\001\061\001\255\255\
\255\255\064\001\255\255\110\001\255\255\068\001\069\001\255\255\
\255\255\094\001\255\255\255\255\075\001\098\001\099\001\000\000\
\000\001\255\255\255\255\082\001\255\255\255\255\255\255\255\255\
\008\001\110\001\000\001\255\255\255\255\013\001\255\255\094\001\
\255\255\255\255\255\255\098\001\099\001\000\000\255\255\013\001\
\255\255\255\255\026\001\255\255\028\001\029\001\000\000\110\001\
\255\255\255\255\255\255\255\255\026\001\255\255\028\001\029\001\
\255\255\041\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\041\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\061\001\255\255\255\255\
\064\001\255\255\255\255\255\255\068\001\069\001\255\255\061\001\
\255\255\255\255\064\001\075\001\255\255\000\001\068\001\069\001\
\003\001\255\255\082\001\255\255\255\255\075\001\255\255\255\255\
\255\255\255\255\013\001\255\255\082\001\255\255\094\001\255\255\
\255\255\255\255\098\001\099\001\255\255\255\255\255\255\026\001\
\094\001\028\001\029\001\255\255\098\001\099\001\110\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\041\001\255\255\
\110\001\255\255\056\001\255\255\058\001\059\001\060\001\000\001\
\062\001\255\255\255\255\065\001\066\001\255\255\255\255\255\255\
\255\255\255\255\061\001\255\255\013\001\064\001\255\255\255\255\
\255\255\255\255\069\001\255\255\255\255\083\001\255\255\255\255\
\075\001\026\001\255\255\028\001\029\001\091\001\092\001\082\001\
\255\255\255\255\255\255\255\255\255\255\099\001\000\001\255\255\
\041\001\255\255\255\255\094\001\255\255\255\255\255\255\098\001\
\099\001\111\001\112\001\013\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\110\001\061\001\255\255\255\255\064\001\
\026\001\255\255\028\001\029\001\069\001\255\255\255\255\255\255\
\255\255\255\255\075\001\255\255\255\255\255\255\255\255\041\001\
\255\255\082\001\000\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\094\001\255\255\013\001\
\255\255\098\001\099\001\061\001\255\255\255\255\064\001\255\255\
\255\255\255\255\255\255\069\001\026\001\110\001\028\001\029\001\
\255\255\075\001\255\255\255\255\255\255\255\255\255\255\255\255\
\082\001\255\255\255\255\041\001\255\255\255\255\255\255\000\001\
\255\255\255\255\255\255\255\255\094\001\255\255\255\255\255\255\
\098\001\099\001\255\255\255\255\013\001\255\255\255\255\061\001\
\255\255\255\255\064\001\255\255\110\001\000\001\255\255\069\001\
\255\255\026\001\255\255\028\001\029\001\075\001\000\001\255\255\
\255\255\255\255\013\001\255\255\082\001\255\255\255\255\255\255\
\041\001\255\255\255\255\013\001\255\255\255\255\255\255\026\001\
\094\001\028\001\029\001\255\255\098\001\099\001\255\255\255\255\
\026\001\255\255\028\001\029\001\061\001\255\255\041\001\064\001\
\110\001\255\255\255\255\255\255\069\001\255\255\255\255\041\001\
\255\255\255\255\075\001\255\255\255\255\255\255\255\255\255\255\
\255\255\082\001\061\001\255\255\255\255\064\001\255\255\255\255\
\255\255\255\255\069\001\061\001\255\255\094\001\064\001\255\255\
\075\001\098\001\099\001\069\001\255\255\255\255\255\255\082\001\
\255\255\075\001\255\255\255\255\255\255\110\001\255\255\255\255\
\082\001\255\255\255\255\094\001\255\255\255\255\255\255\098\001\
\099\001\255\255\255\255\255\255\094\001\255\255\255\255\255\255\
\098\001\099\001\000\001\110\001\255\255\255\255\255\255\005\001\
\006\001\007\001\008\001\255\255\110\001\011\001\012\001\013\001\
\014\001\255\255\255\255\255\255\255\255\019\001\255\255\255\255\
\255\255\255\255\255\255\255\255\026\001\255\255\028\001\029\001\
\030\001\031\001\032\001\033\001\034\001\255\255\255\255\255\255\
\255\255\039\001\255\255\041\001\255\255\255\255\255\255\255\255\
\255\255\047\001\048\001\049\001\050\001\051\001\052\001\053\001\
\054\001\055\001\056\001\057\001\255\255\255\255\060\001\061\001\
\255\255\255\255\064\001\065\001\066\001\067\001\255\255\069\001\
\070\001\071\001\072\001\073\001\255\255\075\001\255\255\077\001\
\078\001\255\255\080\001\255\255\082\001\083\001\255\255\255\255\
\086\001\087\001\255\255\089\001\255\255\091\001\255\255\255\255\
\094\001\095\001\255\255\255\255\098\001\099\001\255\255\255\255\
\255\255\103\001\255\255\255\255\106\001\255\255\108\001\109\001\
\110\001\111\001\112\001\113\001\255\255\255\255\116\001\000\001\
\001\001\002\001\255\255\255\255\005\001\006\001\007\001\255\255\
\009\001\255\255\011\001\012\001\255\255\255\255\015\001\016\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\027\001\255\255\255\255\030\001\031\001\032\001\
\033\001\034\001\255\255\036\001\255\255\255\255\039\001\255\255\
\255\255\042\001\043\001\044\001\045\001\046\001\255\255\255\255\
\049\001\050\001\051\001\255\255\053\001\054\001\055\001\056\001\
\057\001\255\255\255\255\060\001\255\255\062\001\255\255\064\001\
\065\001\066\001\255\255\255\255\255\255\070\001\255\255\072\001\
\073\001\255\255\075\001\255\255\077\001\078\001\255\255\080\001\
\255\255\255\255\255\255\084\001\085\001\086\001\087\001\088\001\
\089\001\255\255\255\255\255\255\255\255\255\255\255\255\096\001\
\255\255\255\255\255\255\100\001\255\255\102\001\103\001\255\255\
\255\255\255\255\255\255\108\001\109\001\255\255\111\001\000\001\
\001\001\002\001\255\255\116\001\005\001\006\001\007\001\255\255\
\009\001\255\255\011\001\012\001\255\255\255\255\255\255\016\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\027\001\255\255\255\255\030\001\031\001\032\001\
\033\001\034\001\255\255\036\001\255\255\255\255\039\001\255\255\
\255\255\042\001\043\001\044\001\045\001\046\001\255\255\255\255\
\049\001\050\001\051\001\255\255\053\001\054\001\055\001\056\001\
\057\001\255\255\255\255\060\001\255\255\062\001\255\255\064\001\
\065\001\066\001\255\255\255\255\255\255\070\001\255\255\072\001\
\073\001\255\255\075\001\255\255\077\001\078\001\255\255\080\001\
\255\255\255\255\255\255\084\001\085\001\086\001\087\001\088\001\
\089\001\255\255\255\255\255\255\255\255\255\255\255\255\096\001\
\255\255\255\255\255\255\100\001\255\255\102\001\103\001\255\255\
\255\255\255\255\255\255\108\001\109\001\255\255\111\001\000\001\
\001\001\002\001\255\255\116\001\005\001\006\001\007\001\255\255\
\009\001\255\255\011\001\012\001\255\255\255\255\255\255\016\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\027\001\255\255\255\255\030\001\031\001\032\001\
\033\001\034\001\255\255\036\001\255\255\255\255\039\001\255\255\
\255\255\042\001\043\001\044\001\045\001\046\001\255\255\255\255\
\049\001\050\001\051\001\255\255\053\001\054\001\055\001\056\001\
\057\001\255\255\255\255\060\001\255\255\062\001\255\255\064\001\
\065\001\066\001\255\255\255\255\255\255\070\001\255\255\072\001\
\073\001\255\255\075\001\255\255\077\001\078\001\255\255\080\001\
\255\255\255\255\255\255\084\001\085\001\086\001\087\001\088\001\
\089\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\100\001\255\255\102\001\103\001\255\255\
\255\255\255\255\000\001\108\001\109\001\255\255\111\001\005\001\
\006\001\007\001\008\001\116\001\255\255\011\001\012\001\255\255\
\255\255\255\255\255\255\255\255\255\255\019\001\255\255\255\255\
\255\255\255\255\255\255\255\255\026\001\255\255\028\001\255\255\
\030\001\031\001\032\001\033\001\034\001\255\255\255\255\255\255\
\255\255\039\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\047\001\048\001\049\001\050\001\051\001\052\001\053\001\
\054\001\055\001\056\001\057\001\255\255\255\255\060\001\061\001\
\255\255\255\255\064\001\065\001\066\001\255\255\255\255\069\001\
\070\001\071\001\072\001\073\001\255\255\255\255\255\255\077\001\
\078\001\255\255\080\001\255\255\255\255\083\001\255\255\255\255\
\086\001\087\001\255\255\089\001\255\255\091\001\255\255\255\255\
\255\255\095\001\255\255\255\255\255\255\099\001\255\255\255\255\
\255\255\103\001\255\255\255\255\106\001\255\255\108\001\109\001\
\255\255\111\001\112\001\113\001\000\001\255\255\116\001\255\255\
\255\255\005\001\006\001\007\001\255\255\255\255\255\255\011\001\
\012\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\030\001\031\001\032\001\033\001\034\001\255\255\
\255\255\255\255\255\255\039\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\049\001\050\001\051\001\
\255\255\053\001\054\001\055\001\056\001\057\001\255\255\255\255\
\060\001\255\255\255\255\255\255\064\001\065\001\066\001\255\255\
\255\255\255\255\070\001\255\255\072\001\073\001\255\255\255\255\
\255\255\077\001\078\001\255\255\080\001\255\255\255\255\255\255\
\255\255\255\255\086\001\087\001\000\001\089\001\255\255\255\255\
\255\255\005\001\006\001\007\001\096\001\255\255\255\255\011\001\
\012\001\255\255\255\255\103\001\255\255\255\255\255\255\255\255\
\108\001\109\001\255\255\111\001\255\255\255\255\255\255\255\255\
\116\001\255\255\030\001\031\001\032\001\033\001\034\001\255\255\
\255\255\255\255\255\255\039\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\049\001\050\001\051\001\
\255\255\053\001\054\001\055\001\056\001\057\001\255\255\255\255\
\060\001\255\255\255\255\255\255\064\001\065\001\066\001\255\255\
\255\255\255\255\070\001\255\255\072\001\073\001\255\255\255\255\
\255\255\077\001\078\001\255\255\080\001\255\255\255\255\255\255\
\255\255\255\255\086\001\087\001\000\001\089\001\255\255\255\255\
\255\255\005\001\006\001\007\001\096\001\255\255\255\255\011\001\
\012\001\255\255\255\255\103\001\255\255\255\255\255\255\255\255\
\108\001\109\001\255\255\111\001\255\255\255\255\255\255\255\255\
\116\001\255\255\030\001\031\001\032\001\033\001\034\001\255\255\
\255\255\255\255\255\255\039\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\049\001\050\001\051\001\
\255\255\053\001\054\001\055\001\056\001\057\001\255\255\255\255\
\060\001\255\255\255\255\255\255\064\001\065\001\066\001\255\255\
\255\255\255\255\070\001\255\255\072\001\073\001\255\255\255\255\
\255\255\077\001\078\001\255\255\080\001\255\255\255\255\255\255\
\255\255\255\255\086\001\087\001\000\001\089\001\255\255\255\255\
\255\255\005\001\006\001\007\001\096\001\255\255\255\255\011\001\
\012\001\255\255\255\255\103\001\255\255\255\255\255\255\255\255\
\108\001\109\001\255\255\111\001\255\255\255\255\255\255\255\255\
\116\001\255\255\030\001\031\001\032\001\033\001\034\001\255\255\
\255\255\255\255\255\255\039\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\049\001\050\001\051\001\
\255\255\053\001\054\001\055\001\056\001\057\001\255\255\255\255\
\060\001\255\255\255\255\255\255\064\001\065\001\066\001\255\255\
\255\255\255\255\070\001\255\255\072\001\073\001\255\255\255\255\
\255\255\077\001\078\001\255\255\080\001\255\255\255\255\255\255\
\255\255\255\255\086\001\087\001\255\255\089\001\255\255\255\255\
\255\255\255\255\255\255\255\255\096\001\003\001\004\001\005\001\
\255\255\255\255\255\255\103\001\255\255\011\001\255\255\013\001\
\108\001\109\001\255\255\111\001\255\255\019\001\020\001\021\001\
\116\001\255\255\024\001\025\001\026\001\255\255\028\001\029\001\
\030\001\255\255\032\001\033\001\034\001\035\001\255\255\255\255\
\255\255\039\001\040\001\041\001\255\255\255\255\255\255\255\255\
\255\255\047\001\048\001\255\255\255\255\255\255\255\255\053\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\064\001\065\001\255\255\255\255\255\255\255\255\
\070\001\071\001\255\255\255\255\255\255\075\001\076\001\255\255\
\078\001\255\255\080\001\081\001\082\001\255\255\084\001\255\255\
\255\255\255\255\255\255\255\255\090\001\255\255\255\255\255\255\
\255\255\095\001\255\255\255\255\255\255\255\255\255\255\101\001\
\000\001\255\255\104\001\105\001\004\001\107\001\108\001\109\001\
\110\001\111\001\255\255\113\001\114\001\115\001\116\001\117\001\
\255\255\017\001\255\255\019\001\255\255\255\255\022\001\255\255\
\255\255\255\255\026\001\027\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\036\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\047\001\
\048\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\061\001\255\255\255\255\
\255\255\065\001\255\255\067\001\068\001\069\001\255\255\071\001\
\255\255\255\255\074\001\255\255\255\255\255\255\255\255\000\001\
\001\001\002\001\255\255\255\255\255\255\006\001\007\001\255\255\
\009\001\255\255\255\255\012\001\092\001\093\001\015\001\016\001\
\255\255\097\001\255\255\099\001\255\255\255\255\102\001\255\255\
\255\255\255\255\027\001\028\001\255\255\030\001\031\001\111\001\
\255\255\113\001\255\255\036\001\255\255\255\255\255\255\255\255\
\255\255\042\001\043\001\044\001\045\001\046\001\255\255\255\255\
\049\001\050\001\051\001\255\255\053\001\054\001\255\255\056\001\
\057\001\255\255\255\255\060\001\255\255\062\001\255\255\255\255\
\065\001\066\001\255\255\255\255\255\255\255\255\255\255\072\001\
\073\001\255\255\075\001\255\255\077\001\255\255\255\255\255\255\
\255\255\255\255\255\255\084\001\085\001\086\001\087\001\088\001\
\089\001\255\255\255\255\255\255\255\255\255\255\255\255\096\001\
\255\255\255\255\099\001\100\001\255\255\102\001\103\001\255\255\
\255\255\255\255\255\255\108\001\255\255\255\255\111\001\112\001\
\000\001\001\001\002\001\255\255\255\255\255\255\006\001\007\001\
\255\255\009\001\255\255\255\255\012\001\255\255\255\255\255\255\
\016\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\027\001\028\001\255\255\030\001\031\001\
\255\255\255\255\255\255\255\255\036\001\255\255\255\255\255\255\
\255\255\255\255\042\001\043\001\044\001\045\001\046\001\255\255\
\255\255\049\001\050\001\051\001\255\255\053\001\054\001\255\255\
\056\001\057\001\255\255\255\255\060\001\255\255\062\001\255\255\
\255\255\065\001\066\001\255\255\255\255\255\255\255\255\255\255\
\072\001\073\001\255\255\075\001\255\255\077\001\255\255\255\255\
\255\255\255\255\255\255\255\255\084\001\085\001\086\001\087\001\
\088\001\089\001\255\255\255\255\255\255\255\255\255\255\255\255\
\096\001\255\255\255\255\099\001\100\001\255\255\102\001\103\001\
\255\255\255\255\255\255\255\255\108\001\255\255\110\001\111\001\
\112\001\000\001\001\001\002\001\255\255\255\255\255\255\006\001\
\007\001\255\255\009\001\255\255\255\255\012\001\255\255\255\255\
\255\255\016\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\027\001\028\001\255\255\030\001\
\031\001\255\255\255\255\255\255\255\255\036\001\255\255\255\255\
\255\255\255\255\255\255\042\001\043\001\044\001\045\001\046\001\
\255\255\255\255\049\001\050\001\051\001\255\255\053\001\054\001\
\255\255\056\001\057\001\255\255\255\255\060\001\255\255\062\001\
\255\255\255\255\065\001\066\001\255\255\255\255\255\255\255\255\
\255\255\072\001\073\001\255\255\075\001\255\255\077\001\255\255\
\255\255\255\255\255\255\255\255\255\255\084\001\085\001\086\001\
\087\001\088\001\089\001\255\255\255\255\255\255\255\255\255\255\
\255\255\096\001\255\255\255\255\099\001\100\001\255\255\102\001\
\103\001\255\255\255\255\255\255\255\255\108\001\255\255\110\001\
\111\001\112\001\000\001\001\001\002\001\255\255\255\255\255\255\
\006\001\007\001\255\255\009\001\255\255\255\255\012\001\255\255\
\255\255\255\255\016\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\027\001\028\001\255\255\
\030\001\031\001\255\255\255\255\255\255\255\255\036\001\255\255\
\255\255\255\255\255\255\255\255\042\001\043\001\044\001\045\001\
\046\001\255\255\255\255\049\001\050\001\051\001\255\255\053\001\
\054\001\255\255\056\001\057\001\255\255\255\255\060\001\255\255\
\062\001\255\255\255\255\065\001\066\001\255\255\255\255\255\255\
\255\255\255\255\072\001\073\001\255\255\075\001\255\255\077\001\
\255\255\255\255\255\255\255\255\255\255\255\255\084\001\085\001\
\086\001\087\001\088\001\089\001\255\255\255\255\255\255\255\255\
\255\255\255\255\096\001\255\255\255\255\099\001\100\001\255\255\
\102\001\103\001\255\255\255\255\255\255\255\255\108\001\255\255\
\110\001\111\001\112\001\000\001\001\001\002\001\255\255\255\255\
\255\255\006\001\007\001\255\255\009\001\255\255\255\255\012\001\
\255\255\255\255\255\255\016\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\027\001\028\001\
\255\255\030\001\031\001\255\255\255\255\255\255\255\255\036\001\
\255\255\255\255\255\255\255\255\255\255\042\001\043\001\044\001\
\045\001\046\001\255\255\255\255\049\001\050\001\051\001\255\255\
\053\001\054\001\255\255\056\001\057\001\255\255\255\255\060\001\
\255\255\062\001\255\255\000\001\065\001\066\001\255\255\255\255\
\255\255\006\001\255\255\072\001\073\001\255\255\075\001\012\001\
\077\001\255\255\255\255\255\255\255\255\255\255\255\255\084\001\
\085\001\086\001\087\001\088\001\089\001\255\255\255\255\028\001\
\255\255\030\001\031\001\096\001\255\255\255\255\099\001\100\001\
\255\255\102\001\103\001\255\255\255\255\255\255\255\255\108\001\
\255\255\255\255\111\001\112\001\049\001\050\001\051\001\255\255\
\053\001\054\001\255\255\056\001\057\001\255\255\255\255\060\001\
\255\255\255\255\255\255\000\001\065\001\066\001\255\255\255\255\
\255\255\006\001\255\255\072\001\255\255\255\255\255\255\012\001\
\077\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\086\001\255\255\255\255\255\255\255\255\255\255\028\001\
\255\255\030\001\031\001\255\255\255\255\255\255\099\001\255\255\
\255\255\255\255\103\001\255\255\255\255\255\255\255\255\108\001\
\255\255\255\255\111\001\112\001\049\001\050\001\051\001\255\255\
\053\001\054\001\255\255\056\001\057\001\255\255\255\255\060\001\
\255\255\255\255\255\255\000\001\065\001\066\001\255\255\255\255\
\255\255\006\001\255\255\072\001\255\255\255\255\255\255\012\001\
\077\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\086\001\255\255\255\255\255\255\255\255\255\255\028\001\
\255\255\030\001\031\001\255\255\255\255\255\255\099\001\255\255\
\255\255\255\255\103\001\255\255\255\255\255\255\255\255\108\001\
\255\255\255\255\111\001\112\001\049\001\050\001\051\001\255\255\
\053\001\054\001\255\255\056\001\057\001\255\255\255\255\060\001\
\255\255\255\255\255\255\255\255\065\001\066\001\255\255\255\255\
\255\255\255\255\255\255\072\001\255\255\255\255\255\255\255\255\
\077\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\086\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\099\001\255\255\
\255\255\255\255\103\001\255\255\255\255\255\255\255\255\108\001\
\255\255\255\255\111\001\112\001\005\001\006\001\007\001\255\255\
\255\255\255\255\011\001\012\001\013\001\014\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\028\001\029\001\030\001\031\001\032\001\
\033\001\034\001\255\255\255\255\255\255\255\255\039\001\255\255\
\041\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\049\001\050\001\051\001\255\255\053\001\054\001\055\001\056\001\
\057\001\255\255\255\255\060\001\061\001\255\255\255\255\064\001\
\065\001\066\001\255\255\255\255\069\001\070\001\255\255\072\001\
\073\001\255\255\075\001\255\255\077\001\078\001\255\255\080\001\
\255\255\082\001\255\255\255\255\255\255\086\001\087\001\255\255\
\089\001\255\255\091\001\255\255\255\255\005\001\006\001\007\001\
\255\255\098\001\255\255\011\001\012\001\013\001\103\001\255\255\
\255\255\255\255\255\255\108\001\109\001\110\001\111\001\255\255\
\255\255\255\255\255\255\116\001\028\001\029\001\030\001\031\001\
\032\001\033\001\034\001\255\255\255\255\255\255\255\255\039\001\
\255\255\041\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\049\001\050\001\051\001\255\255\053\001\054\001\055\001\
\056\001\057\001\255\255\255\255\060\001\061\001\255\255\255\255\
\064\001\065\001\066\001\255\255\255\255\069\001\070\001\255\255\
\072\001\073\001\255\255\075\001\255\255\077\001\078\001\255\255\
\080\001\255\255\082\001\255\255\255\255\255\255\086\001\087\001\
\255\255\089\001\255\255\255\255\255\255\005\001\006\001\007\001\
\255\255\255\255\098\001\011\001\012\001\255\255\255\255\103\001\
\255\255\255\255\255\255\255\255\108\001\109\001\110\001\111\001\
\255\255\255\255\255\255\255\255\116\001\255\255\030\001\031\001\
\032\001\033\001\034\001\255\255\255\255\255\255\255\255\039\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\049\001\050\001\051\001\255\255\053\001\054\001\055\001\
\056\001\057\001\255\255\255\255\060\001\255\255\255\255\255\255\
\064\001\065\001\066\001\255\255\255\255\255\255\070\001\255\255\
\072\001\073\001\255\255\255\255\255\255\077\001\078\001\255\255\
\080\001\255\255\255\255\255\255\255\255\255\255\086\001\087\001\
\255\255\089\001\255\255\255\255\255\255\255\255\094\001\005\001\
\006\001\007\001\255\255\255\255\010\001\011\001\012\001\103\001\
\255\255\255\255\255\255\255\255\108\001\109\001\255\255\111\001\
\255\255\255\255\255\255\255\255\116\001\255\255\255\255\255\255\
\030\001\031\001\032\001\033\001\034\001\255\255\255\255\255\255\
\255\255\039\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\049\001\050\001\051\001\255\255\053\001\
\054\001\055\001\056\001\057\001\255\255\255\255\060\001\255\255\
\255\255\255\255\064\001\065\001\066\001\255\255\255\255\255\255\
\070\001\255\255\072\001\073\001\255\255\255\255\255\255\077\001\
\078\001\255\255\080\001\255\255\255\255\255\255\255\255\255\255\
\086\001\087\001\255\255\089\001\255\255\255\255\005\001\006\001\
\007\001\255\255\255\255\255\255\011\001\012\001\255\255\255\255\
\255\255\103\001\255\255\255\255\255\255\255\255\108\001\109\001\
\255\255\111\001\255\255\026\001\255\255\255\255\116\001\030\001\
\031\001\032\001\033\001\034\001\255\255\255\255\255\255\255\255\
\039\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\049\001\050\001\051\001\255\255\053\001\054\001\
\055\001\056\001\057\001\255\255\255\255\060\001\255\255\255\255\
\255\255\064\001\065\001\066\001\255\255\255\255\255\255\070\001\
\255\255\072\001\073\001\255\255\255\255\255\255\077\001\078\001\
\255\255\080\001\255\255\255\255\255\255\255\255\255\255\086\001\
\087\001\255\255\089\001\255\255\255\255\005\001\006\001\007\001\
\255\255\255\255\255\255\011\001\012\001\255\255\255\255\255\255\
\103\001\255\255\255\255\255\255\255\255\108\001\109\001\255\255\
\111\001\255\255\026\001\255\255\255\255\116\001\030\001\031\001\
\032\001\033\001\034\001\255\255\255\255\255\255\255\255\039\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\049\001\050\001\051\001\255\255\053\001\054\001\055\001\
\056\001\057\001\255\255\255\255\060\001\255\255\255\255\255\255\
\064\001\065\001\066\001\255\255\255\255\255\255\070\001\255\255\
\072\001\073\001\255\255\255\255\255\255\077\001\078\001\255\255\
\080\001\255\255\255\255\255\255\255\255\255\255\086\001\087\001\
\255\255\089\001\255\255\255\255\005\001\006\001\007\001\255\255\
\255\255\255\255\011\001\012\001\255\255\255\255\255\255\103\001\
\255\255\255\255\255\255\255\255\108\001\109\001\255\255\111\001\
\255\255\255\255\255\255\255\255\116\001\030\001\031\001\032\001\
\033\001\034\001\255\255\255\255\255\255\255\255\039\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\049\001\050\001\051\001\255\255\053\001\054\001\055\001\056\001\
\057\001\255\255\255\255\060\001\255\255\255\255\255\255\064\001\
\065\001\066\001\255\255\255\255\255\255\070\001\255\255\072\001\
\073\001\255\255\255\255\255\255\077\001\078\001\255\255\080\001\
\255\255\255\255\255\255\255\255\255\255\086\001\087\001\255\255\
\089\001\255\255\255\255\005\001\006\001\007\001\255\255\255\255\
\255\255\011\001\012\001\255\255\255\255\255\255\103\001\255\255\
\255\255\255\255\255\255\108\001\109\001\255\255\111\001\255\255\
\255\255\255\255\255\255\116\001\030\001\031\001\032\001\033\001\
\034\001\255\255\255\255\255\255\255\255\039\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\049\001\
\050\001\051\001\255\255\053\001\054\001\055\001\056\001\057\001\
\255\255\255\255\060\001\255\255\255\255\255\255\064\001\065\001\
\066\001\255\255\255\255\255\255\070\001\255\255\072\001\073\001\
\255\255\255\255\255\255\077\001\078\001\255\255\080\001\255\255\
\255\255\255\255\255\255\255\255\086\001\087\001\255\255\089\001\
\255\255\255\255\255\255\006\001\255\255\255\255\255\255\255\255\
\255\255\012\001\255\255\014\001\255\255\103\001\017\001\255\255\
\255\255\255\255\108\001\109\001\255\255\111\001\255\255\255\255\
\027\001\255\255\116\001\030\001\031\001\056\001\255\255\058\001\
\059\001\060\001\255\255\062\001\255\255\255\255\065\001\066\001\
\255\255\255\255\255\255\255\255\255\255\255\255\049\001\050\001\
\051\001\052\001\255\255\054\001\255\255\056\001\057\001\255\255\
\083\001\060\001\255\255\255\255\255\255\255\255\065\001\066\001\
\091\001\092\001\255\255\255\255\255\255\072\001\006\001\255\255\
\099\001\255\255\077\001\255\255\012\001\255\255\014\001\255\255\
\083\001\017\001\255\255\086\001\111\001\112\001\255\255\255\255\
\091\001\255\255\255\255\027\001\255\255\255\255\030\001\031\001\
\099\001\255\255\255\255\255\255\103\001\255\255\255\255\106\001\
\255\255\108\001\255\255\255\255\111\001\112\001\255\255\255\255\
\255\255\049\001\050\001\051\001\052\001\255\255\054\001\255\255\
\056\001\057\001\255\255\255\255\060\001\255\255\255\255\255\255\
\255\255\065\001\066\001\255\255\255\255\255\255\255\255\255\255\
\072\001\006\001\255\255\255\255\255\255\077\001\255\255\012\001\
\255\255\014\001\255\255\083\001\255\255\255\255\086\001\255\255\
\255\255\255\255\255\255\091\001\255\255\255\255\027\001\255\255\
\255\255\030\001\031\001\099\001\255\255\255\255\255\255\103\001\
\255\255\255\255\106\001\255\255\108\001\255\255\255\255\111\001\
\112\001\255\255\255\255\255\255\049\001\050\001\051\001\052\001\
\255\255\054\001\255\255\056\001\057\001\255\255\255\255\060\001\
\255\255\255\255\255\255\255\255\065\001\066\001\255\255\255\255\
\255\255\255\255\255\255\072\001\006\001\255\255\255\255\255\255\
\077\001\255\255\012\001\255\255\014\001\255\255\083\001\255\255\
\255\255\086\001\255\255\255\255\255\255\255\255\091\001\255\255\
\255\255\027\001\255\255\255\255\030\001\031\001\099\001\255\255\
\255\255\255\255\103\001\255\255\255\255\106\001\255\255\108\001\
\255\255\255\255\111\001\112\001\255\255\255\255\255\255\049\001\
\050\001\051\001\052\001\255\255\054\001\255\255\056\001\057\001\
\255\255\255\255\060\001\255\255\255\255\255\255\255\255\065\001\
\066\001\255\255\255\255\255\255\006\001\255\255\072\001\255\255\
\255\255\255\255\012\001\077\001\255\255\255\255\255\255\255\255\
\255\255\083\001\255\255\255\255\086\001\255\255\255\255\255\255\
\255\255\091\001\255\255\255\255\030\001\031\001\255\255\255\255\
\255\255\099\001\255\255\255\255\255\255\103\001\255\255\255\255\
\106\001\255\255\108\001\255\255\255\255\111\001\112\001\049\001\
\050\001\051\001\052\001\255\255\054\001\255\255\056\001\057\001\
\255\255\255\255\060\001\255\255\255\255\255\255\255\255\065\001\
\066\001\255\255\255\255\255\255\006\001\255\255\072\001\255\255\
\074\001\255\255\012\001\077\001\255\255\255\255\255\255\255\255\
\255\255\083\001\255\255\255\255\086\001\255\255\255\255\255\255\
\255\255\091\001\255\255\255\255\030\001\031\001\255\255\255\255\
\255\255\099\001\255\255\255\255\255\255\103\001\255\255\255\255\
\106\001\255\255\108\001\255\255\255\255\111\001\112\001\049\001\
\050\001\051\001\052\001\255\255\054\001\255\255\056\001\057\001\
\255\255\255\255\060\001\255\255\255\255\255\255\255\255\065\001\
\066\001\255\255\255\255\255\255\006\001\255\255\072\001\255\255\
\074\001\255\255\012\001\077\001\255\255\255\255\255\255\255\255\
\255\255\083\001\255\255\255\255\086\001\255\255\255\255\255\255\
\255\255\091\001\255\255\255\255\030\001\031\001\255\255\255\255\
\255\255\099\001\255\255\255\255\255\255\103\001\255\255\255\255\
\106\001\255\255\108\001\255\255\255\255\111\001\112\001\049\001\
\050\001\051\001\052\001\255\255\054\001\255\255\056\001\057\001\
\255\255\255\255\060\001\255\255\255\255\255\255\255\255\065\001\
\066\001\255\255\255\255\255\255\006\001\255\255\072\001\255\255\
\255\255\255\255\012\001\077\001\255\255\255\255\255\255\255\255\
\255\255\083\001\255\255\255\255\086\001\255\255\255\255\255\255\
\255\255\091\001\255\255\255\255\030\001\031\001\255\255\255\255\
\255\255\099\001\255\255\255\255\255\255\103\001\255\255\255\255\
\106\001\255\255\108\001\255\255\255\255\111\001\112\001\049\001\
\050\001\051\001\052\001\255\255\054\001\255\255\056\001\057\001\
\255\255\255\255\060\001\255\255\255\255\255\255\255\255\065\001\
\066\001\255\255\255\255\255\255\006\001\255\255\072\001\255\255\
\255\255\255\255\012\001\077\001\255\255\255\255\255\255\255\255\
\255\255\083\001\255\255\255\255\086\001\255\255\255\255\255\255\
\255\255\091\001\255\255\255\255\030\001\031\001\255\255\255\255\
\255\255\099\001\255\255\255\255\255\255\103\001\255\255\255\255\
\106\001\255\255\108\001\255\255\255\255\111\001\112\001\049\001\
\050\001\051\001\052\001\255\255\054\001\255\255\056\001\057\001\
\255\255\255\255\060\001\255\255\255\255\255\255\255\255\065\001\
\066\001\255\255\255\255\255\255\006\001\255\255\072\001\255\255\
\255\255\255\255\012\001\077\001\255\255\255\255\255\255\255\255\
\255\255\083\001\255\255\255\255\086\001\255\255\255\255\255\255\
\255\255\091\001\028\001\255\255\030\001\031\001\255\255\255\255\
\255\255\099\001\255\255\255\255\255\255\103\001\255\255\255\255\
\106\001\255\255\108\001\255\255\255\255\111\001\112\001\049\001\
\050\001\051\001\255\255\053\001\054\001\255\255\056\001\057\001\
\255\255\255\255\060\001\255\255\255\255\255\255\255\255\065\001\
\066\001\255\255\255\255\255\255\255\255\255\255\072\001\255\255\
\255\255\255\255\006\001\077\001\255\255\255\255\010\001\255\255\
\012\001\255\255\255\255\255\255\086\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\094\001\255\255\255\255\255\255\
\028\001\099\001\030\001\031\001\255\255\103\001\255\255\255\255\
\255\255\255\255\108\001\255\255\255\255\111\001\112\001\255\255\
\255\255\255\255\255\255\255\255\255\255\049\001\050\001\051\001\
\255\255\053\001\054\001\255\255\056\001\057\001\255\255\255\255\
\060\001\255\255\255\255\255\255\255\255\065\001\066\001\255\255\
\255\255\255\255\255\255\255\255\072\001\006\001\255\255\008\001\
\255\255\077\001\255\255\012\001\255\255\255\255\255\255\255\255\
\255\255\255\255\086\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\028\001\255\255\030\001\031\001\099\001\
\255\255\255\255\255\255\103\001\255\255\255\255\255\255\255\255\
\108\001\255\255\255\255\111\001\112\001\255\255\255\255\255\255\
\049\001\050\001\051\001\255\255\053\001\054\001\255\255\056\001\
\057\001\255\255\255\255\060\001\255\255\255\255\255\255\255\255\
\065\001\066\001\255\255\255\255\255\255\006\001\255\255\072\001\
\255\255\255\255\255\255\012\001\077\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\086\001\255\255\255\255\
\255\255\255\255\255\255\028\001\255\255\030\001\031\001\255\255\
\255\255\255\255\099\001\255\255\255\255\255\255\103\001\255\255\
\255\255\255\255\255\255\108\001\255\255\255\255\111\001\112\001\
\049\001\050\001\051\001\255\255\053\001\054\001\255\255\056\001\
\057\001\255\255\255\255\060\001\255\255\255\255\255\255\255\255\
\065\001\066\001\255\255\255\255\255\255\255\255\255\255\072\001\
\255\255\255\255\255\255\006\001\077\001\255\255\255\255\255\255\
\255\255\012\001\255\255\255\255\255\255\086\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\095\001\255\255\
\255\255\028\001\099\001\030\001\031\001\255\255\103\001\255\255\
\255\255\255\255\255\255\108\001\255\255\255\255\111\001\112\001\
\255\255\255\255\255\255\255\255\255\255\255\255\049\001\050\001\
\051\001\255\255\053\001\054\001\255\255\056\001\057\001\255\255\
\255\255\060\001\255\255\255\255\255\255\255\255\065\001\066\001\
\255\255\255\255\255\255\006\001\255\255\072\001\255\255\255\255\
\255\255\012\001\077\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\086\001\255\255\255\255\255\255\255\255\
\255\255\028\001\255\255\030\001\031\001\255\255\255\255\255\255\
\099\001\255\255\255\255\255\255\103\001\255\255\255\255\255\255\
\255\255\108\001\255\255\255\255\111\001\112\001\049\001\050\001\
\051\001\255\255\053\001\054\001\255\255\056\001\057\001\255\255\
\255\255\060\001\255\255\255\255\255\255\255\255\065\001\066\001\
\255\255\255\255\255\255\006\001\255\255\072\001\255\255\255\255\
\255\255\012\001\077\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\086\001\255\255\255\255\255\255\255\255\
\255\255\028\001\255\255\030\001\031\001\255\255\255\255\255\255\
\099\001\255\255\255\255\255\255\103\001\255\255\255\255\255\255\
\255\255\108\001\255\255\255\255\111\001\112\001\049\001\050\001\
\051\001\255\255\053\001\054\001\255\255\056\001\057\001\255\255\
\255\255\060\001\255\255\255\255\255\255\255\255\065\001\066\001\
\255\255\255\255\255\255\006\001\255\255\072\001\255\255\255\255\
\255\255\012\001\077\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\086\001\255\255\255\255\255\255\255\255\
\255\255\028\001\255\255\030\001\031\001\255\255\255\255\255\255\
\099\001\255\255\255\255\255\255\103\001\255\255\255\255\255\255\
\255\255\108\001\255\255\255\255\111\001\112\001\049\001\050\001\
\051\001\255\255\053\001\054\001\255\255\056\001\057\001\255\255\
\255\255\060\001\255\255\255\255\255\255\255\255\065\001\066\001\
\255\255\255\255\255\255\006\001\255\255\072\001\255\255\255\255\
\255\255\012\001\077\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\086\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\030\001\031\001\255\255\255\255\255\255\
\099\001\255\255\255\255\255\255\103\001\255\255\255\255\255\255\
\255\255\108\001\255\255\255\255\111\001\112\001\049\001\050\001\
\051\001\255\255\255\255\054\001\255\255\056\001\057\001\255\255\
\255\255\060\001\255\255\255\255\255\255\255\255\065\001\066\001\
\255\255\255\255\255\255\255\255\255\255\072\001\006\001\007\001\
\255\255\255\255\077\001\011\001\012\001\255\255\255\255\255\255\
\255\255\255\255\255\255\086\001\255\255\255\255\022\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\030\001\031\001\
\099\001\255\255\255\255\255\255\103\001\255\255\255\255\255\255\
\255\255\108\001\255\255\255\255\111\001\112\001\255\255\255\255\
\255\255\049\001\050\001\051\001\052\001\255\255\054\001\055\001\
\056\001\057\001\255\255\255\255\060\001\255\255\255\255\255\255\
\255\255\065\001\066\001\255\255\255\255\006\001\007\001\255\255\
\255\255\255\255\011\001\012\001\255\255\077\001\078\001\255\255\
\255\255\255\255\255\255\083\001\255\255\255\255\255\255\255\255\
\255\255\089\001\255\255\091\001\255\255\030\001\031\001\255\255\
\255\255\255\255\255\255\099\001\100\001\255\255\255\255\103\001\
\255\255\255\255\106\001\255\255\108\001\255\255\255\255\111\001\
\049\001\050\001\051\001\052\001\255\255\054\001\055\001\056\001\
\057\001\255\255\255\255\060\001\255\255\255\255\255\255\255\255\
\065\001\066\001\255\255\255\255\006\001\007\001\255\255\255\255\
\255\255\011\001\012\001\255\255\077\001\078\001\255\255\255\255\
\255\255\255\255\083\001\255\255\255\255\255\255\255\255\255\255\
\089\001\255\255\091\001\255\255\030\001\031\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\103\001\255\255\
\255\255\106\001\255\255\108\001\255\255\255\255\111\001\049\001\
\050\001\051\001\255\255\255\255\054\001\055\001\056\001\057\001\
\255\255\255\255\060\001\255\255\255\255\255\255\255\255\065\001\
\066\001\255\255\255\255\006\001\007\001\255\255\255\255\255\255\
\011\001\012\001\255\255\077\001\078\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\089\001\
\255\255\255\255\255\255\030\001\031\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\103\001\255\255\255\255\
\255\255\255\255\108\001\255\255\255\255\111\001\049\001\050\001\
\051\001\255\255\255\255\054\001\055\001\056\001\057\001\255\255\
\255\255\060\001\255\255\255\255\255\255\255\255\065\001\066\001\
\255\255\255\255\006\001\007\001\255\255\255\255\255\255\011\001\
\012\001\255\255\077\001\078\001\255\255\255\255\255\255\255\255\
\255\255\255\255\008\001\255\255\255\255\255\255\089\001\255\255\
\255\255\015\001\030\001\031\001\056\001\255\255\058\001\059\001\
\060\001\023\001\062\001\255\255\103\001\065\001\066\001\255\255\
\030\001\108\001\255\255\255\255\111\001\049\001\050\001\051\001\
\255\255\255\255\054\001\055\001\056\001\057\001\255\255\083\001\
\060\001\255\255\255\255\255\255\255\255\065\001\066\001\091\001\
\092\001\255\255\056\001\255\255\058\001\059\001\060\001\099\001\
\062\001\077\001\078\001\065\001\066\001\255\255\255\255\255\255\
\255\255\008\001\110\001\111\001\112\001\089\001\255\255\255\255\
\015\001\255\255\255\255\255\255\255\255\083\001\255\255\255\255\
\255\255\255\255\255\255\103\001\090\001\091\001\092\001\030\001\
\108\001\255\255\255\255\111\001\255\255\099\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\108\001\255\255\
\255\255\111\001\112\001\255\255\255\255\255\255\255\255\255\255\
\255\255\056\001\255\255\058\001\059\001\060\001\255\255\062\001\
\255\255\255\255\065\001\066\001\255\255\255\255\255\255\255\255\
\000\001\001\001\002\001\255\255\255\255\255\255\255\255\255\255\
\255\255\009\001\255\255\255\255\083\001\255\255\014\001\015\001\
\016\001\017\001\018\001\255\255\091\001\092\001\255\255\255\255\
\255\255\255\255\255\255\027\001\099\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\036\001\108\001\255\255\255\255\
\111\001\112\001\042\001\043\001\044\001\045\001\046\001\000\001\
\001\001\002\001\255\255\255\255\255\255\255\255\007\001\255\255\
\009\001\255\255\255\255\255\255\255\255\255\255\062\001\016\001\
\255\255\255\255\255\255\067\001\255\255\255\255\255\255\255\255\
\072\001\073\001\027\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\036\001\084\001\085\001\086\001\087\001\
\088\001\042\001\043\001\044\001\045\001\046\001\255\255\255\255\
\096\001\255\255\255\255\255\255\255\255\255\255\102\001\255\255\
\255\255\255\255\255\255\255\255\255\255\062\001\255\255\255\255\
\255\255\001\001\002\001\255\255\255\255\255\255\255\255\072\001\
\073\001\009\001\075\001\255\255\255\255\255\255\255\255\015\001\
\016\001\255\255\018\001\084\001\085\001\086\001\087\001\088\001\
\089\001\255\255\255\255\027\001\255\255\255\255\255\255\255\255\
\255\255\001\001\002\001\100\001\036\001\102\001\255\255\255\255\
\255\255\009\001\042\001\043\001\044\001\045\001\046\001\015\001\
\016\001\255\255\018\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\027\001\255\255\255\255\062\001\255\255\
\255\255\255\255\255\255\067\001\036\001\255\255\255\255\255\255\
\072\001\073\001\042\001\043\001\044\001\045\001\046\001\255\255\
\255\255\255\255\255\255\255\255\084\001\085\001\086\001\087\001\
\088\001\255\255\255\255\255\255\255\255\255\255\062\001\001\001\
\002\001\097\001\255\255\067\001\255\255\255\255\102\001\009\001\
\072\001\073\001\255\255\255\255\255\255\015\001\016\001\255\255\
\018\001\255\255\255\255\255\255\084\001\085\001\086\001\087\001\
\088\001\027\001\255\255\255\255\255\255\093\001\255\255\001\001\
\002\001\255\255\036\001\255\255\255\255\255\255\102\001\009\001\
\042\001\043\001\044\001\045\001\046\001\015\001\016\001\255\255\
\018\001\255\255\255\255\255\255\255\255\255\255\255\255\025\001\
\255\255\027\001\255\255\255\255\062\001\255\255\255\255\255\255\
\255\255\067\001\036\001\255\255\255\255\255\255\072\001\073\001\
\042\001\043\001\044\001\045\001\046\001\255\255\255\255\255\255\
\255\255\255\255\084\001\085\001\086\001\087\001\088\001\255\255\
\255\255\255\255\255\255\093\001\062\001\001\001\002\001\255\255\
\255\255\067\001\255\255\255\255\102\001\009\001\072\001\073\001\
\255\255\255\255\255\255\015\001\016\001\255\255\018\001\255\255\
\255\255\255\255\084\001\085\001\086\001\087\001\088\001\027\001\
\255\255\255\255\255\255\255\255\255\255\001\001\002\001\255\255\
\036\001\255\255\255\255\255\255\102\001\009\001\042\001\043\001\
\044\001\045\001\046\001\015\001\016\001\255\255\018\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\027\001\
\255\255\255\255\062\001\255\255\255\255\255\255\255\255\067\001\
\036\001\255\255\255\255\255\255\072\001\073\001\042\001\043\001\
\044\001\045\001\046\001\255\255\255\255\255\255\255\255\255\255\
\084\001\085\001\086\001\087\001\088\001\255\255\255\255\255\255\
\255\255\255\255\062\001\001\001\002\001\255\255\255\255\067\001\
\255\255\255\255\102\001\009\001\072\001\073\001\255\255\255\255\
\255\255\015\001\016\001\255\255\255\255\255\255\255\255\255\255\
\084\001\085\001\086\001\087\001\088\001\027\001\255\255\255\255\
\255\255\255\255\255\255\001\001\002\001\255\255\036\001\255\255\
\255\255\255\255\102\001\009\001\042\001\043\001\044\001\045\001\
\046\001\015\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\027\001\255\255\255\255\
\062\001\255\255\255\255\255\255\255\255\067\001\036\001\255\255\
\255\255\255\255\072\001\073\001\042\001\043\001\044\001\045\001\
\046\001\255\255\255\255\255\255\255\255\255\255\084\001\085\001\
\086\001\087\001\088\001\255\255\255\255\255\255\255\255\093\001\
\062\001\001\001\002\001\255\255\255\255\067\001\255\255\255\255\
\102\001\009\001\072\001\073\001\255\255\255\255\255\255\015\001\
\255\255\255\255\255\255\255\255\255\255\255\255\084\001\085\001\
\086\001\087\001\088\001\027\001\255\255\255\255\255\255\255\255\
\255\255\255\255\096\001\255\255\036\001\255\255\255\255\255\255\
\102\001\255\255\042\001\043\001\044\001\045\001\046\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\001\001\002\001\
\255\255\255\255\255\255\255\255\255\255\255\255\062\001\255\255\
\255\255\255\255\255\255\067\001\015\001\255\255\255\255\255\255\
\072\001\073\001\255\255\255\255\255\255\255\255\255\255\255\255\
\027\001\255\255\255\255\255\255\084\001\085\001\086\001\087\001\
\088\001\036\001\255\255\255\255\255\255\255\255\255\255\042\001\
\043\001\044\001\045\001\046\001\255\255\255\255\102\001\255\255\
\255\255\255\255\255\255\255\255\056\001\255\255\058\001\059\001\
\060\001\255\255\062\001\062\001\255\255\065\001\066\001\255\255\
\067\001\255\255\255\255\255\255\255\255\072\001\073\001\075\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\083\001\
\255\255\255\255\085\001\086\001\087\001\088\001\255\255\091\001\
\092\001\255\255\255\255\255\255\255\255\255\255\255\255\099\001\
\255\255\255\255\255\255\102\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\111\001\112\001"

let yynames_const = "\
  AMPERAMPER\000\
  AMPERSAND\000\
  AND\000\
  AS\000\
  ASSERT\000\
  BACKQUOTE\000\
  BANG\000\
  BAR\000\
  BARBAR\000\
  BARRBRACKET\000\
  BEGIN\000\
  CLASS\000\
  COLON\000\
  COLONCOLON\000\
  COLONEQUAL\000\
  COLONGREATER\000\
  COMMA\000\
  CONSTRAINT\000\
  DO\000\
  DONE\000\
  DOT\000\
  DOTDOT\000\
  DOWNTO\000\
  ELSE\000\
  END\000\
  EOF\000\
  EQUAL\000\
  EXCEPTION\000\
  EXTERNAL\000\
  FALSE\000\
  FOR\000\
  FUN\000\
  FUNCTION\000\
  FUNCTOR\000\
  GREATER\000\
  GREATERRBRACE\000\
  GREATERRBRACKET\000\
  IF\000\
  IN\000\
  INCLUDE\000\
  INHERIT\000\
  INITIALIZER\000\
  LAZY\000\
  LBRACE\000\
  LBRACELESS\000\
  LBRACKET\000\
  LBRACKETBAR\000\
  LBRACKETLESS\000\
  LBRACKETGREATER\000\
  LBRACKETPERCENT\000\
  LBRACKETPERCENTPERCENT\000\
  LESS\000\
  LESSMINUS\000\
  LET\000\
  LPAREN\000\
  LBRACKETAT\000\
  LBRACKETATAT\000\
  LBRACKETATATAT\000\
  MATCH\000\
  METHOD\000\
  MINUS\000\
  MINUSDOT\000\
  MINUSGREATER\000\
  MODULE\000\
  MUTABLE\000\
  NEW\000\
  NONREC\000\
  OBJECT\000\
  OF\000\
  OPEN\000\
  OR\000\
  PERCENT\000\
  PLUS\000\
  PLUSDOT\000\
  PLUSEQ\000\
  PRIVATE\000\
  QUESTION\000\
  QUOTE\000\
  RBRACE\000\
  RBRACKET\000\
  REC\000\
  RPAREN\000\
  SEMI\000\
  SEMISEMI\000\
  SHARP\000\
  SIG\000\
  STAR\000\
  STRUCT\000\
  THEN\000\
  TILDE\000\
  TO\000\
  TRUE\000\
  TRY\000\
  TYPE\000\
  UNDERSCORE\000\
  VAL\000\
  VIRTUAL\000\
  WHEN\000\
  WHILE\000\
  WITH\000\
  EOL\000\
  "

let yynames_block = "\
  CHAR\000\
  FLOAT\000\
  INFIXOP0\000\
  INFIXOP1\000\
  INFIXOP2\000\
  INFIXOP3\000\
  INFIXOP4\000\
  INT\000\
  INT32\000\
  INT64\000\
  LABEL\000\
  LIDENT\000\
  NATIVEINT\000\
  OPTLABEL\000\
  PREFIXOP\000\
  SHARPOP\000\
  STRING\000\
  UIDENT\000\
  COMMENT\000\
  DOCSTRING\000\
  "

let yyact = [|
  (fun _ -> failwith "parser")
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'structure) in
    Obj.repr(
(*# 614 "parsing/parser.mly"*)
                                         ( extra_str 1 _1 )
(*# 6402 "parsing/parser.ml"*)
               : Parsetree.structure))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'signature) in
    Obj.repr(
(*# 617 "parsing/parser.mly"*)
                                         ( extra_sig 1 _1 )
(*# 6409 "parsing/parser.ml"*)
               : Parsetree.signature))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'top_structure) in
    Obj.repr(
(*# 620 "parsing/parser.mly"*)
                                         ( Ptop_def (extra_str 1 _1) )
(*# 6416 "parsing/parser.ml"*)
               : Parsetree.toplevel_phrase))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'toplevel_directive) in
    Obj.repr(
(*# 621 "parsing/parser.mly"*)
                                         ( _1 )
(*# 6423 "parsing/parser.ml"*)
               : Parsetree.toplevel_phrase))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 622 "parsing/parser.mly"*)
                                         ( raise End_of_file )
(*# 6429 "parsing/parser.ml"*)
               : Parsetree.toplevel_phrase))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 626 "parsing/parser.mly"*)
      ( (text_str 1) @ [mkstrexp _1 _2] )
(*# 6437 "parsing/parser.ml"*)
               : 'top_structure))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'top_structure_tail) in
    Obj.repr(
(*# 628 "parsing/parser.mly"*)
      ( _1 )
(*# 6444 "parsing/parser.ml"*)
               : 'top_structure))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 631 "parsing/parser.mly"*)
                                         ( [] )
(*# 6450 "parsing/parser.ml"*)
               : 'top_structure_tail))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'structure_item) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'top_structure_tail) in
    Obj.repr(
(*# 632 "parsing/parser.mly"*)
                                         ( (text_str 1) @ _1 :: _2 )
(*# 6458 "parsing/parser.ml"*)
               : 'top_structure_tail))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'use_file_body) in
    Obj.repr(
(*# 635 "parsing/parser.mly"*)
                                         ( extra_def 1 _1 )
(*# 6465 "parsing/parser.ml"*)
               : Parsetree.toplevel_phrase list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'use_file_tail) in
    Obj.repr(
(*# 638 "parsing/parser.mly"*)
                                         ( _1 )
(*# 6472 "parsing/parser.ml"*)
               : 'use_file_body))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'seq_expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'post_item_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'use_file_tail) in
    Obj.repr(
(*# 640 "parsing/parser.mly"*)
      ( (text_def 1) @ Ptop_def[mkstrexp _1 _2] :: _3 )
(*# 6481 "parsing/parser.ml"*)
               : 'use_file_body))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 644 "parsing/parser.mly"*)
      ( [] )
(*# 6487 "parsing/parser.ml"*)
               : 'use_file_tail))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 646 "parsing/parser.mly"*)
      ( text_def 1 )
(*# 6493 "parsing/parser.ml"*)
               : 'use_file_tail))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'seq_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'post_item_attributes) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'use_file_tail) in
    Obj.repr(
(*# 648 "parsing/parser.mly"*)
      (  mark_rhs_docs 2 3;
        (text_def 1) @ (text_def 2) @ Ptop_def[mkstrexp _2 _3] :: _4 )
(*# 6503 "parsing/parser.ml"*)
               : 'use_file_tail))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'structure_item) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'use_file_tail) in
    Obj.repr(
(*# 651 "parsing/parser.mly"*)
      ( (text_def 1) @ (text_def 2) @ Ptop_def[_2] :: _3 )
(*# 6511 "parsing/parser.ml"*)
               : 'use_file_tail))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'toplevel_directive) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'use_file_tail) in
    Obj.repr(
(*# 653 "parsing/parser.mly"*)
      (  mark_rhs_docs 2 3;
        (text_def 1) @ (text_def 2) @ _2 :: _3 )
(*# 6520 "parsing/parser.ml"*)
               : 'use_file_tail))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'structure_item) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'use_file_tail) in
    Obj.repr(
(*# 656 "parsing/parser.mly"*)
      ( (text_def 1) @ Ptop_def[_1] :: _2 )
(*# 6528 "parsing/parser.ml"*)
               : 'use_file_tail))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'toplevel_directive) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'use_file_tail) in
    Obj.repr(
(*# 658 "parsing/parser.mly"*)
      ( mark_rhs_docs 1 1;
        (text_def 1) @ _1 :: _2 )
(*# 6537 "parsing/parser.ml"*)
               : 'use_file_tail))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'core_type) in
    Obj.repr(
(*# 662 "parsing/parser.mly"*)
                  ( _1 )
(*# 6544 "parsing/parser.ml"*)
               : Parsetree.core_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
(*# 665 "parsing/parser.mly"*)
                 ( _1 )
(*# 6551 "parsing/parser.ml"*)
               : Parsetree.expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'pattern) in
    Obj.repr(
(*# 668 "parsing/parser.mly"*)
                ( _1 )
(*# 6558 "parsing/parser.ml"*)
               : Parsetree.pattern))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 675 "parsing/parser.mly"*)
      ( mkrhs "*" 2, None )
(*# 6564 "parsing/parser.ml"*)
               : 'functor_arg))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'functor_arg_name) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'module_type) in
    Obj.repr(
(*# 677 "parsing/parser.mly"*)
      ( mkrhs _2 2, Some _4 )
(*# 6572 "parsing/parser.ml"*)
               : 'functor_arg))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
(*# 681 "parsing/parser.mly"*)
               ( _1 )
(*# 6579 "parsing/parser.ml"*)
               : 'functor_arg_name))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 682 "parsing/parser.mly"*)
               ( "_" )
(*# 6585 "parsing/parser.ml"*)
               : 'functor_arg_name))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'functor_args) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'functor_arg) in
    Obj.repr(
(*# 687 "parsing/parser.mly"*)
      ( _2 :: _1 )
(*# 6593 "parsing/parser.ml"*)
               : 'functor_args))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'functor_arg) in
    Obj.repr(
(*# 689 "parsing/parser.mly"*)
      ( [ _1 ] )
(*# 6600 "parsing/parser.ml"*)
               : 'functor_args))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'mod_longident) in
    Obj.repr(
(*# 694 "parsing/parser.mly"*)
      ( mkmod(Pmod_ident (mkrhs _1 1)) )
(*# 6607 "parsing/parser.ml"*)
               : 'module_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'structure) in
    Obj.repr(
(*# 696 "parsing/parser.mly"*)
      ( mkmod(Pmod_structure(extra_str 2 _2)) )
(*# 6614 "parsing/parser.ml"*)
               : 'module_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'structure) in
    Obj.repr(
(*# 698 "parsing/parser.mly"*)
      ( unclosed "struct" 1 "end" 3 )
(*# 6621 "parsing/parser.ml"*)
               : 'module_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'functor_args) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'module_expr) in
    Obj.repr(
(*# 700 "parsing/parser.mly"*)
      ( List.fold_left (fun acc (n, t) -> mkmod(Pmod_functor(n, t, acc)))
                       _4 _2 )
(*# 6630 "parsing/parser.ml"*)
               : 'module_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'module_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'module_expr) in
    Obj.repr(
(*# 703 "parsing/parser.mly"*)
      ( mkmod(Pmod_apply(_1, _3)) )
(*# 6638 "parsing/parser.ml"*)
               : 'module_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'module_expr) in
    Obj.repr(
(*# 705 "parsing/parser.mly"*)
      ( mkmod(Pmod_apply(_1, mkmod (Pmod_structure []))) )
(*# 6645 "parsing/parser.ml"*)
               : 'module_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'module_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'module_expr) in
    Obj.repr(
(*# 707 "parsing/parser.mly"*)
      ( unclosed "(" 2 ")" 4 )
(*# 6653 "parsing/parser.ml"*)
               : 'module_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'module_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'module_type) in
    Obj.repr(
(*# 709 "parsing/parser.mly"*)
      ( mkmod(Pmod_constraint(_2, _4)) )
(*# 6661 "parsing/parser.ml"*)
               : 'module_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'module_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'module_type) in
    Obj.repr(
(*# 711 "parsing/parser.mly"*)
      ( unclosed "(" 1 ")" 5 )
(*# 6669 "parsing/parser.ml"*)
               : 'module_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'module_expr) in
    Obj.repr(
(*# 713 "parsing/parser.mly"*)
      ( _2 )
(*# 6676 "parsing/parser.ml"*)
               : 'module_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'module_expr) in
    Obj.repr(
(*# 715 "parsing/parser.mly"*)
      ( unclosed "(" 1 ")" 3 )
(*# 6683 "parsing/parser.ml"*)
               : 'module_expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    Obj.repr(
(*# 717 "parsing/parser.mly"*)
      ( mkmod(Pmod_unpack _3) )
(*# 6690 "parsing/parser.ml"*)
               : 'module_expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'expr) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'package_type) in
    Obj.repr(
(*# 719 "parsing/parser.mly"*)
      ( mkmod(Pmod_unpack(
              ghexp(Pexp_constraint(_3, ghtyp(Ptyp_package _5))))) )
(*# 6699 "parsing/parser.ml"*)
               : 'module_expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 5 : 'expr) in
    let _5 = (Parsing.peek_val __caml_parser_env 3 : 'package_type) in
    let _7 = (Parsing.peek_val __caml_parser_env 1 : 'package_type) in
    Obj.repr(
(*# 722 "parsing/parser.mly"*)
      ( mkmod(Pmod_unpack(
              ghexp(Pexp_coerce(_3, Some(ghtyp(Ptyp_package _5)),
                                    ghtyp(Ptyp_package _7))))) )
(*# 6710 "parsing/parser.ml"*)
               : 'module_expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'expr) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'package_type) in
    Obj.repr(
(*# 726 "parsing/parser.mly"*)
      ( mkmod(Pmod_unpack(
              ghexp(Pexp_coerce(_3, None, ghtyp(Ptyp_package _5))))) )
(*# 6719 "parsing/parser.ml"*)
               : 'module_expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    Obj.repr(
(*# 729 "parsing/parser.mly"*)
      ( unclosed "(" 1 ")" 5 )
(*# 6726 "parsing/parser.ml"*)
               : 'module_expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    Obj.repr(
(*# 731 "parsing/parser.mly"*)
      ( unclosed "(" 1 ")" 5 )
(*# 6733 "parsing/parser.ml"*)
               : 'module_expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    Obj.repr(
(*# 733 "parsing/parser.mly"*)
      ( unclosed "(" 1 ")" 4 )
(*# 6740 "parsing/parser.ml"*)
               : 'module_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'module_expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attribute) in
    Obj.repr(
(*# 735 "parsing/parser.mly"*)
      ( Mod.attr _1 _2 )
(*# 6748 "parsing/parser.ml"*)
               : 'module_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'extension) in
    Obj.repr(
(*# 737 "parsing/parser.mly"*)
      ( mkmod(Pmod_extension _1) )
(*# 6755 "parsing/parser.ml"*)
               : 'module_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'seq_expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'post_item_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'structure_tail) in
    Obj.repr(
(*# 742 "parsing/parser.mly"*)
      ( mark_rhs_docs 1 2;
        (text_str 1) @ mkstrexp _1 _2 :: _3 )
(*# 6765 "parsing/parser.ml"*)
               : 'structure))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'structure_tail) in
    Obj.repr(
(*# 744 "parsing/parser.mly"*)
                   ( _1 )
(*# 6772 "parsing/parser.ml"*)
               : 'structure))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 747 "parsing/parser.mly"*)
                         ( [] )
(*# 6778 "parsing/parser.ml"*)
               : 'structure_tail))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'structure) in
    Obj.repr(
(*# 748 "parsing/parser.mly"*)
                         ( (text_str 1) @ _2 )
(*# 6785 "parsing/parser.ml"*)
               : 'structure_tail))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'structure_item) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'structure_tail) in
    Obj.repr(
(*# 749 "parsing/parser.mly"*)
                                  ( (text_str 1) @ _1 :: _2 )
(*# 6793 "parsing/parser.ml"*)
               : 'structure_tail))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'let_bindings) in
    Obj.repr(
(*# 753 "parsing/parser.mly"*)
      ( val_of_let_bindings _1 )
(*# 6800 "parsing/parser.ml"*)
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'primitive_declaration) in
    Obj.repr(
(*# 755 "parsing/parser.mly"*)
      ( mkstr (Pstr_primitive _1) )
(*# 6807 "parsing/parser.ml"*)
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'type_declarations) in
    Obj.repr(
(*# 757 "parsing/parser.mly"*)
      ( mkstr(Pstr_type (List.rev _1)) )
(*# 6814 "parsing/parser.ml"*)
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'str_type_extension) in
    Obj.repr(
(*# 759 "parsing/parser.mly"*)
      ( mkstr(Pstr_typext _1) )
(*# 6821 "parsing/parser.ml"*)
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'str_exception_declaration) in
    Obj.repr(
(*# 761 "parsing/parser.mly"*)
      ( mkstr(Pstr_exception _1) )
(*# 6828 "parsing/parser.ml"*)
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'module_binding) in
    Obj.repr(
(*# 763 "parsing/parser.mly"*)
      ( mkstr(Pstr_module _1) )
(*# 6835 "parsing/parser.ml"*)
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'rec_module_bindings) in
    Obj.repr(
(*# 765 "parsing/parser.mly"*)
      ( mkstr(Pstr_recmodule(List.rev _1)) )
(*# 6842 "parsing/parser.ml"*)
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'module_type_declaration) in
    Obj.repr(
(*# 767 "parsing/parser.mly"*)
      ( mkstr(Pstr_modtype _1) )
(*# 6849 "parsing/parser.ml"*)
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'open_statement) in
    Obj.repr(
(*# 768 "parsing/parser.mly"*)
                   ( mkstr(Pstr_open _1) )
(*# 6856 "parsing/parser.ml"*)
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'class_declarations) in
    Obj.repr(
(*# 770 "parsing/parser.mly"*)
      ( mkstr(Pstr_class (List.rev _1)) )
(*# 6863 "parsing/parser.ml"*)
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'class_type_declarations) in
    Obj.repr(
(*# 772 "parsing/parser.mly"*)
      ( mkstr(Pstr_class_type (List.rev _1)) )
(*# 6870 "parsing/parser.ml"*)
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'str_include_statement) in
    Obj.repr(
(*# 774 "parsing/parser.mly"*)
      ( mkstr(Pstr_include _1) )
(*# 6877 "parsing/parser.ml"*)
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'item_extension) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 776 "parsing/parser.mly"*)
      ( mkstr(Pstr_extension (_1, (add_docs_attrs (symbol_docs ()) _2))) )
(*# 6885 "parsing/parser.ml"*)
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'floating_attribute) in
    Obj.repr(
(*# 778 "parsing/parser.mly"*)
      ( mark_symbol_docs ();
        mkstr(Pstr_attribute _1) )
(*# 6893 "parsing/parser.ml"*)
               : 'structure_item))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'module_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 783 "parsing/parser.mly"*)
      ( Incl.mk _2 ~attrs:_3
                ~loc:(symbol_rloc()) ~docs:(symbol_docs ()) )
(*# 6902 "parsing/parser.ml"*)
               : 'str_include_statement))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'module_expr) in
    Obj.repr(
(*# 788 "parsing/parser.mly"*)
      ( _2 )
(*# 6909 "parsing/parser.ml"*)
               : 'module_binding_body))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'module_type) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'module_expr) in
    Obj.repr(
(*# 790 "parsing/parser.mly"*)
      ( mkmod(Pmod_constraint(_4, _2)) )
(*# 6917 "parsing/parser.ml"*)
               : 'module_binding_body))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'functor_arg) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'module_binding_body) in
    Obj.repr(
(*# 792 "parsing/parser.mly"*)
      ( mkmod(Pmod_functor(fst _1, snd _1, _2)) )
(*# 6925 "parsing/parser.ml"*)
               : 'module_binding_body))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'module_binding_body) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 796 "parsing/parser.mly"*)
      ( Mb.mk (mkrhs _2 2) _3 ~attrs:_4
              ~loc:(symbol_rloc ()) ~docs:(symbol_docs ()) )
(*# 6935 "parsing/parser.ml"*)
               : 'module_binding))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'rec_module_binding) in
    Obj.repr(
(*# 800 "parsing/parser.mly"*)
                                                  ( [_1] )
(*# 6942 "parsing/parser.ml"*)
               : 'rec_module_bindings))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'rec_module_bindings) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'and_module_binding) in
    Obj.repr(
(*# 801 "parsing/parser.mly"*)
                                                  ( _2 :: _1 )
(*# 6950 "parsing/parser.ml"*)
               : 'rec_module_bindings))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'module_binding_body) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 805 "parsing/parser.mly"*)
      ( Mb.mk (mkrhs _3 3) _4 ~attrs:_5
              ~loc:(symbol_rloc ()) ~docs:(symbol_docs ()) )
(*# 6960 "parsing/parser.ml"*)
               : 'rec_module_binding))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'module_binding_body) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 810 "parsing/parser.mly"*)
      ( Mb.mk (mkrhs _2 2) _3 ~attrs:_4 ~loc:(symbol_rloc ())
               ~text:(symbol_text ()) ~docs:(symbol_docs ()) )
(*# 6970 "parsing/parser.ml"*)
               : 'and_module_binding))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'mty_longident) in
    Obj.repr(
(*# 818 "parsing/parser.mly"*)
      ( mkmty(Pmty_ident (mkrhs _1 1)) )
(*# 6977 "parsing/parser.ml"*)
               : 'module_type))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'signature) in
    Obj.repr(
(*# 820 "parsing/parser.mly"*)
      ( mkmty(Pmty_signature (extra_sig 2 _2)) )
(*# 6984 "parsing/parser.ml"*)
               : 'module_type))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'signature) in
    Obj.repr(
(*# 822 "parsing/parser.mly"*)
      ( unclosed "sig" 1 "end" 3 )
(*# 6991 "parsing/parser.ml"*)
               : 'module_type))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'functor_args) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'module_type) in
    Obj.repr(
(*# 825 "parsing/parser.mly"*)
      ( List.fold_left (fun acc (n, t) -> mkmty(Pmty_functor(n, t, acc)))
                       _4 _2 )
(*# 7000 "parsing/parser.ml"*)
               : 'module_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'module_type) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'with_constraints) in
    Obj.repr(
(*# 828 "parsing/parser.mly"*)
      ( mkmty(Pmty_with(_1, List.rev _3)) )
(*# 7008 "parsing/parser.ml"*)
               : 'module_type))
; (fun __caml_parser_env ->
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'module_expr) in
    Obj.repr(
(*# 830 "parsing/parser.mly"*)
      ( mkmty(Pmty_typeof _4) )
(*# 7015 "parsing/parser.ml"*)
               : 'module_type))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'module_type) in
    Obj.repr(
(*# 834 "parsing/parser.mly"*)
      ( _2 )
(*# 7022 "parsing/parser.ml"*)
               : 'module_type))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'module_type) in
    Obj.repr(
(*# 836 "parsing/parser.mly"*)
      ( unclosed "(" 1 ")" 3 )
(*# 7029 "parsing/parser.ml"*)
               : 'module_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'extension) in
    Obj.repr(
(*# 838 "parsing/parser.mly"*)
      ( mkmty(Pmty_extension _1) )
(*# 7036 "parsing/parser.ml"*)
               : 'module_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'module_type) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attribute) in
    Obj.repr(
(*# 840 "parsing/parser.mly"*)
      ( Mty.attr _1 _2 )
(*# 7044 "parsing/parser.ml"*)
               : 'module_type))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 843 "parsing/parser.mly"*)
                         ( [] )
(*# 7050 "parsing/parser.ml"*)
               : 'signature))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'signature) in
    Obj.repr(
(*# 844 "parsing/parser.mly"*)
                         ( (text_sig 1) @ _2 )
(*# 7057 "parsing/parser.ml"*)
               : 'signature))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'signature_item) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'signature) in
    Obj.repr(
(*# 845 "parsing/parser.mly"*)
                             ( (text_sig 1) @ _1 :: _2 )
(*# 7065 "parsing/parser.ml"*)
               : 'signature))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'value_description) in
    Obj.repr(
(*# 849 "parsing/parser.mly"*)
      ( mksig(Psig_value _1) )
(*# 7072 "parsing/parser.ml"*)
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'primitive_declaration) in
    Obj.repr(
(*# 851 "parsing/parser.mly"*)
      ( mksig(Psig_value _1) )
(*# 7079 "parsing/parser.ml"*)
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'type_declarations) in
    Obj.repr(
(*# 853 "parsing/parser.mly"*)
      ( mksig(Psig_type (List.rev _1)) )
(*# 7086 "parsing/parser.ml"*)
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'sig_type_extension) in
    Obj.repr(
(*# 855 "parsing/parser.mly"*)
      ( mksig(Psig_typext _1) )
(*# 7093 "parsing/parser.ml"*)
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'sig_exception_declaration) in
    Obj.repr(
(*# 857 "parsing/parser.mly"*)
      ( mksig(Psig_exception _1) )
(*# 7100 "parsing/parser.ml"*)
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'module_declaration) in
    Obj.repr(
(*# 859 "parsing/parser.mly"*)
      ( mksig(Psig_module _1) )
(*# 7107 "parsing/parser.ml"*)
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'module_alias) in
    Obj.repr(
(*# 861 "parsing/parser.mly"*)
      ( mksig(Psig_module _1) )
(*# 7114 "parsing/parser.ml"*)
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'rec_module_declarations) in
    Obj.repr(
(*# 863 "parsing/parser.mly"*)
      ( mksig(Psig_recmodule (List.rev _1)) )
(*# 7121 "parsing/parser.ml"*)
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'module_type_declaration) in
    Obj.repr(
(*# 865 "parsing/parser.mly"*)
      ( mksig(Psig_modtype _1) )
(*# 7128 "parsing/parser.ml"*)
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'open_statement) in
    Obj.repr(
(*# 867 "parsing/parser.mly"*)
      ( mksig(Psig_open _1) )
(*# 7135 "parsing/parser.ml"*)
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'sig_include_statement) in
    Obj.repr(
(*# 869 "parsing/parser.mly"*)
      ( mksig(Psig_include _1) )
(*# 7142 "parsing/parser.ml"*)
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'class_descriptions) in
    Obj.repr(
(*# 871 "parsing/parser.mly"*)
      ( mksig(Psig_class (List.rev _1)) )
(*# 7149 "parsing/parser.ml"*)
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'class_type_declarations) in
    Obj.repr(
(*# 873 "parsing/parser.mly"*)
      ( mksig(Psig_class_type (List.rev _1)) )
(*# 7156 "parsing/parser.ml"*)
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'item_extension) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 875 "parsing/parser.mly"*)
      ( mksig(Psig_extension (_1, (add_docs_attrs (symbol_docs ()) _2))) )
(*# 7164 "parsing/parser.ml"*)
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'floating_attribute) in
    Obj.repr(
(*# 877 "parsing/parser.mly"*)
      ( mark_symbol_docs ();
        mksig(Psig_attribute _1) )
(*# 7172 "parsing/parser.ml"*)
               : 'signature_item))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'override_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 882 "parsing/parser.mly"*)
      ( Opn.mk (mkrhs _3 3) ~override:_2 ~attrs:_4
          ~loc:(symbol_rloc()) ~docs:(symbol_docs ()) )
(*# 7182 "parsing/parser.ml"*)
               : 'open_statement))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'module_type) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 887 "parsing/parser.mly"*)
      ( Incl.mk _2 ~attrs:_3
                ~loc:(symbol_rloc()) ~docs:(symbol_docs ()) )
(*# 7191 "parsing/parser.ml"*)
               : 'sig_include_statement))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'module_type) in
    Obj.repr(
(*# 892 "parsing/parser.mly"*)
      ( _2 )
(*# 7198 "parsing/parser.ml"*)
               : 'module_declaration_body))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'module_type) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'module_declaration_body) in
    Obj.repr(
(*# 894 "parsing/parser.mly"*)
      ( mkmty(Pmty_functor(mkrhs _2 2, Some _4, _6)) )
(*# 7207 "parsing/parser.ml"*)
               : 'module_declaration_body))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'module_declaration_body) in
    Obj.repr(
(*# 896 "parsing/parser.mly"*)
      ( mkmty(Pmty_functor(mkrhs "*" 1, None, _3)) )
(*# 7214 "parsing/parser.ml"*)
               : 'module_declaration_body))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'module_declaration_body) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 900 "parsing/parser.mly"*)
      ( Md.mk (mkrhs _2 2) _3 ~attrs:_4
          ~loc:(symbol_rloc()) ~docs:(symbol_docs ()) )
(*# 7224 "parsing/parser.ml"*)
               : 'module_declaration))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'mod_longident) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 905 "parsing/parser.mly"*)
      ( Md.mk (mkrhs _2 2)
          (Mty.alias ~loc:(rhs_loc 4) (mkrhs _4 4)) ~attrs:_5
             ~loc:(symbol_rloc()) ~docs:(symbol_docs ()) )
(*# 7235 "parsing/parser.ml"*)
               : 'module_alias))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'rec_module_declaration) in
    Obj.repr(
(*# 910 "parsing/parser.mly"*)
                                                    ( [_1] )
(*# 7242 "parsing/parser.ml"*)
               : 'rec_module_declarations))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'rec_module_declarations) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'and_module_declaration) in
    Obj.repr(
(*# 911 "parsing/parser.mly"*)
                                                    ( _2 :: _1 )
(*# 7250 "parsing/parser.ml"*)
               : 'rec_module_declarations))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'module_type) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 915 "parsing/parser.mly"*)
      ( Md.mk (mkrhs _3 3) _5 ~attrs:_6
              ~loc:(symbol_rloc()) ~docs:(symbol_docs ()) )
(*# 7260 "parsing/parser.ml"*)
               : 'rec_module_declaration))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'module_type) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 920 "parsing/parser.mly"*)
      ( Md.mk (mkrhs _2 2) _4 ~attrs:_5 ~loc:(symbol_rloc())
              ~text:(symbol_text()) ~docs:(symbol_docs()) )
(*# 7270 "parsing/parser.ml"*)
               : 'and_module_declaration))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 924 "parsing/parser.mly"*)
                              ( None )
(*# 7276 "parsing/parser.ml"*)
               : 'module_type_declaration_body))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'module_type) in
    Obj.repr(
(*# 925 "parsing/parser.mly"*)
                              ( Some _2 )
(*# 7283 "parsing/parser.ml"*)
               : 'module_type_declaration_body))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'ident) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'module_type_declaration_body) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 929 "parsing/parser.mly"*)
      ( Mtd.mk (mkrhs _3 3) ?typ:_4 ~attrs:_5
          ~loc:(symbol_rloc()) ~docs:(symbol_docs ()) )
(*# 7293 "parsing/parser.ml"*)
               : 'module_type_declaration))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'class_declaration) in
    Obj.repr(
(*# 935 "parsing/parser.mly"*)
                                                ( [_1] )
(*# 7300 "parsing/parser.ml"*)
               : 'class_declarations))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'class_declarations) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'and_class_declaration) in
    Obj.repr(
(*# 936 "parsing/parser.mly"*)
                                                ( _2 :: _1 )
(*# 7308 "parsing/parser.ml"*)
               : 'class_declarations))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'virtual_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'class_type_parameters) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'class_fun_binding) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 941 "parsing/parser.mly"*)
      ( Ci.mk (mkrhs _4 4) _5 ~virt:_2 ~params:_3 ~attrs:_6
              ~loc:(symbol_rloc ()) ~docs:(symbol_docs ()) )
(*# 7320 "parsing/parser.ml"*)
               : 'class_declaration))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'virtual_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'class_type_parameters) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'class_fun_binding) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 947 "parsing/parser.mly"*)
      ( Ci.mk (mkrhs _4 4) _5 ~virt:_2 ~params:_3
         ~attrs:_6 ~loc:(symbol_rloc ())
         ~text:(symbol_text ()) ~docs:(symbol_docs ()) )
(*# 7333 "parsing/parser.ml"*)
               : 'and_class_declaration))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'class_expr) in
    Obj.repr(
(*# 953 "parsing/parser.mly"*)
      ( _2 )
(*# 7340 "parsing/parser.ml"*)
               : 'class_fun_binding))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'class_type) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'class_expr) in
    Obj.repr(
(*# 955 "parsing/parser.mly"*)
      ( mkclass(Pcl_constraint(_4, _2)) )
(*# 7348 "parsing/parser.ml"*)
               : 'class_fun_binding))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'labeled_simple_pattern) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'class_fun_binding) in
    Obj.repr(
(*# 957 "parsing/parser.mly"*)
      ( let (l,o,p) = _1 in mkclass(Pcl_fun(l, o, p, _2)) )
(*# 7356 "parsing/parser.ml"*)
               : 'class_fun_binding))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 960 "parsing/parser.mly"*)
                                                ( [] )
(*# 7362 "parsing/parser.ml"*)
               : 'class_type_parameters))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'type_parameter_list) in
    Obj.repr(
(*# 961 "parsing/parser.mly"*)
                                                ( List.rev _2 )
(*# 7369 "parsing/parser.ml"*)
               : 'class_type_parameters))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'labeled_simple_pattern) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'class_expr) in
    Obj.repr(
(*# 965 "parsing/parser.mly"*)
      ( let (l,o,p) = _1 in mkclass(Pcl_fun(l, o, p, _3)) )
(*# 7377 "parsing/parser.ml"*)
               : 'class_fun_def))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'labeled_simple_pattern) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'class_fun_def) in
    Obj.repr(
(*# 967 "parsing/parser.mly"*)
      ( let (l,o,p) = _1 in mkclass(Pcl_fun(l, o, p, _2)) )
(*# 7385 "parsing/parser.ml"*)
               : 'class_fun_def))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'class_simple_expr) in
    Obj.repr(
(*# 971 "parsing/parser.mly"*)
      ( _1 )
(*# 7392 "parsing/parser.ml"*)
               : 'class_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'class_fun_def) in
    Obj.repr(
(*# 973 "parsing/parser.mly"*)
      ( _2 )
(*# 7399 "parsing/parser.ml"*)
               : 'class_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'class_simple_expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'simple_labeled_expr_list) in
    Obj.repr(
(*# 975 "parsing/parser.mly"*)
      ( mkclass(Pcl_apply(_1, List.rev _2)) )
(*# 7407 "parsing/parser.ml"*)
               : 'class_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'let_bindings) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'class_expr) in
    Obj.repr(
(*# 977 "parsing/parser.mly"*)
      ( class_of_let_bindings _1 _3 )
(*# 7415 "parsing/parser.ml"*)
               : 'class_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'class_expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attribute) in
    Obj.repr(
(*# 979 "parsing/parser.mly"*)
      ( Cl.attr _1 _2 )
(*# 7423 "parsing/parser.ml"*)
               : 'class_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'extension) in
    Obj.repr(
(*# 981 "parsing/parser.mly"*)
      ( mkclass(Pcl_extension _1) )
(*# 7430 "parsing/parser.ml"*)
               : 'class_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'core_type_comma_list) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'class_longident) in
    Obj.repr(
(*# 985 "parsing/parser.mly"*)
      ( mkclass(Pcl_constr(mkloc _4 (rhs_loc 4), List.rev _2)) )
(*# 7438 "parsing/parser.ml"*)
               : 'class_simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'class_longident) in
    Obj.repr(
(*# 987 "parsing/parser.mly"*)
      ( mkclass(Pcl_constr(mkrhs _1 1, [])) )
(*# 7445 "parsing/parser.ml"*)
               : 'class_simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'class_structure) in
    Obj.repr(
(*# 989 "parsing/parser.mly"*)
      ( mkclass(Pcl_structure _2) )
(*# 7452 "parsing/parser.ml"*)
               : 'class_simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'class_structure) in
    Obj.repr(
(*# 991 "parsing/parser.mly"*)
      ( unclosed "object" 1 "end" 3 )
(*# 7459 "parsing/parser.ml"*)
               : 'class_simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'class_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'class_type) in
    Obj.repr(
(*# 993 "parsing/parser.mly"*)
      ( mkclass(Pcl_constraint(_2, _4)) )
(*# 7467 "parsing/parser.ml"*)
               : 'class_simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'class_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'class_type) in
    Obj.repr(
(*# 995 "parsing/parser.mly"*)
      ( unclosed "(" 1 ")" 5 )
(*# 7475 "parsing/parser.ml"*)
               : 'class_simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'class_expr) in
    Obj.repr(
(*# 997 "parsing/parser.mly"*)
      ( _2 )
(*# 7482 "parsing/parser.ml"*)
               : 'class_simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'class_expr) in
    Obj.repr(
(*# 999 "parsing/parser.mly"*)
      ( unclosed "(" 1 ")" 3 )
(*# 7489 "parsing/parser.ml"*)
               : 'class_simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'class_self_pattern) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'class_fields) in
    Obj.repr(
(*# 1003 "parsing/parser.mly"*)
       ( Cstr.mk _1 (extra_cstr 2 (List.rev _2)) )
(*# 7497 "parsing/parser.ml"*)
               : 'class_structure))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'pattern) in
    Obj.repr(
(*# 1007 "parsing/parser.mly"*)
      ( reloc_pat _2 )
(*# 7504 "parsing/parser.ml"*)
               : 'class_self_pattern))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'pattern) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'core_type) in
    Obj.repr(
(*# 1009 "parsing/parser.mly"*)
      ( mkpat(Ppat_constraint(_2, _4)) )
(*# 7512 "parsing/parser.ml"*)
               : 'class_self_pattern))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 1011 "parsing/parser.mly"*)
      ( ghpat(Ppat_any) )
(*# 7518 "parsing/parser.ml"*)
               : 'class_self_pattern))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 1015 "parsing/parser.mly"*)
      ( [] )
(*# 7524 "parsing/parser.ml"*)
               : 'class_fields))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'class_fields) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'class_field) in
    Obj.repr(
(*# 1017 "parsing/parser.mly"*)
      ( _2 :: (text_cstr 2) @ _1 )
(*# 7532 "parsing/parser.ml"*)
               : 'class_fields))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'override_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'class_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'parent_binder) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 1021 "parsing/parser.mly"*)
      ( mkcf (Pcf_inherit (_2, _3, _4)) ~attrs:_5 ~docs:(symbol_docs ()) )
(*# 7542 "parsing/parser.ml"*)
               : 'class_field))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'value) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 1023 "parsing/parser.mly"*)
      ( mkcf (Pcf_val _2) ~attrs:_3 ~docs:(symbol_docs ()) )
(*# 7550 "parsing/parser.ml"*)
               : 'class_field))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'method_) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 1025 "parsing/parser.mly"*)
      ( mkcf (Pcf_method _2) ~attrs:_3 ~docs:(symbol_docs ()) )
(*# 7558 "parsing/parser.ml"*)
               : 'class_field))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'constrain_field) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 1027 "parsing/parser.mly"*)
      ( mkcf (Pcf_constraint _2) ~attrs:_3 ~docs:(symbol_docs ()) )
(*# 7566 "parsing/parser.ml"*)
               : 'class_field))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 1029 "parsing/parser.mly"*)
      ( mkcf (Pcf_initializer _2) ~attrs:_3 ~docs:(symbol_docs ()) )
(*# 7574 "parsing/parser.ml"*)
               : 'class_field))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'item_extension) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 1031 "parsing/parser.mly"*)
      ( mkcf (Pcf_extension _1) ~attrs:_2 ~docs:(symbol_docs ()) )
(*# 7582 "parsing/parser.ml"*)
               : 'class_field))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'floating_attribute) in
    Obj.repr(
(*# 1033 "parsing/parser.mly"*)
      ( mark_symbol_docs ();
        mkcf (Pcf_attribute _1) )
(*# 7590 "parsing/parser.ml"*)
               : 'class_field))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
(*# 1038 "parsing/parser.mly"*)
          ( Some _2 )
(*# 7597 "parsing/parser.ml"*)
               : 'parent_binder))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 1040 "parsing/parser.mly"*)
          ( None )
(*# 7603 "parsing/parser.ml"*)
               : 'parent_binder))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 5 : 'override_flag) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'label) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
(*# 1045 "parsing/parser.mly"*)
      ( if _1 = Override then syntax_error ();
        mkloc _4 (rhs_loc 4), Mutable, Cfk_virtual _6 )
(*# 7613 "parsing/parser.ml"*)
               : 'value))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'mutable_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'label) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
(*# 1048 "parsing/parser.mly"*)
      ( mkrhs _3 3, _2, Cfk_virtual _5 )
(*# 7622 "parsing/parser.ml"*)
               : 'value))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'override_flag) in
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'mutable_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'label) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
(*# 1050 "parsing/parser.mly"*)
      ( mkrhs _3 3, _2, Cfk_concrete (_1, _5) )
(*# 7632 "parsing/parser.ml"*)
               : 'value))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 5 : 'override_flag) in
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'mutable_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'label) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'type_constraint) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
(*# 1052 "parsing/parser.mly"*)
      (
       let e = mkexp_constraint _6 _4 in
       mkrhs _3 3, _2, Cfk_concrete (_1, e)
      )
(*# 7646 "parsing/parser.ml"*)
               : 'value))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 5 : 'override_flag) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'label) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'poly_type) in
    Obj.repr(
(*# 1060 "parsing/parser.mly"*)
      ( if _1 = Override then syntax_error ();
        mkloc _4 (rhs_loc 4), Private, Cfk_virtual _6 )
(*# 7656 "parsing/parser.ml"*)
               : 'method_))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 5 : 'override_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'private_flag) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'label) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'poly_type) in
    Obj.repr(
(*# 1063 "parsing/parser.mly"*)
      ( if _1 = Override then syntax_error ();
        mkloc _4 (rhs_loc 4), _3, Cfk_virtual _6 )
(*# 7667 "parsing/parser.ml"*)
               : 'method_))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'override_flag) in
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'private_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'label) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'strict_binding) in
    Obj.repr(
(*# 1066 "parsing/parser.mly"*)
      ( mkloc _3 (rhs_loc 3), _2,
        Cfk_concrete (_1, ghexp(Pexp_poly (_4, None))) )
(*# 7678 "parsing/parser.ml"*)
               : 'method_))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : 'override_flag) in
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'private_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'label) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'poly_type) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
(*# 1069 "parsing/parser.mly"*)
      ( mkloc _3 (rhs_loc 3), _2,
        Cfk_concrete (_1, ghexp(Pexp_poly(_7, Some _5))) )
(*# 7690 "parsing/parser.ml"*)
               : 'method_))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 9 : 'override_flag) in
    let _2 = (Parsing.peek_val __caml_parser_env 8 : 'private_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 7 : 'label) in
    let _6 = (Parsing.peek_val __caml_parser_env 4 : 'lident_list) in
    let _8 = (Parsing.peek_val __caml_parser_env 2 : 'core_type) in
    let _10 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
(*# 1073 "parsing/parser.mly"*)
      ( let exp, poly = wrap_type_annotation _6 _8 _10 in
        mkloc _3 (rhs_loc 3), _2,
        Cfk_concrete (_1, ghexp(Pexp_poly(exp, Some poly))) )
(*# 7704 "parsing/parser.ml"*)
               : 'method_))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'class_signature) in
    Obj.repr(
(*# 1082 "parsing/parser.mly"*)
      ( _1 )
(*# 7711 "parsing/parser.ml"*)
               : 'class_type))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'simple_core_type_or_tuple_no_attr) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'class_type) in
    Obj.repr(
(*# 1085 "parsing/parser.mly"*)
      ( mkcty(Pcty_arrow("?" ^ _2 , mkoption _4, _6)) )
(*# 7720 "parsing/parser.ml"*)
               : 'class_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'simple_core_type_or_tuple_no_attr) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'class_type) in
    Obj.repr(
(*# 1087 "parsing/parser.mly"*)
      ( mkcty(Pcty_arrow("?" ^ _1, mkoption _2, _4)) )
(*# 7729 "parsing/parser.ml"*)
               : 'class_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'simple_core_type_or_tuple_no_attr) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'class_type) in
    Obj.repr(
(*# 1089 "parsing/parser.mly"*)
      ( mkcty(Pcty_arrow(_1, _3, _5)) )
(*# 7738 "parsing/parser.ml"*)
               : 'class_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'simple_core_type_or_tuple_no_attr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'class_type) in
    Obj.repr(
(*# 1091 "parsing/parser.mly"*)
      ( mkcty(Pcty_arrow("", _1, _3)) )
(*# 7746 "parsing/parser.ml"*)
               : 'class_type))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'core_type_comma_list) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'clty_longident) in
    Obj.repr(
(*# 1095 "parsing/parser.mly"*)
      ( mkcty(Pcty_constr (mkloc _4 (rhs_loc 4), List.rev _2)) )
(*# 7754 "parsing/parser.ml"*)
               : 'class_signature))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'clty_longident) in
    Obj.repr(
(*# 1097 "parsing/parser.mly"*)
      ( mkcty(Pcty_constr (mkrhs _1 1, [])) )
(*# 7761 "parsing/parser.ml"*)
               : 'class_signature))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'class_sig_body) in
    Obj.repr(
(*# 1099 "parsing/parser.mly"*)
      ( mkcty(Pcty_signature _2) )
(*# 7768 "parsing/parser.ml"*)
               : 'class_signature))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'class_sig_body) in
    Obj.repr(
(*# 1101 "parsing/parser.mly"*)
      ( unclosed "object" 1 "end" 3 )
(*# 7775 "parsing/parser.ml"*)
               : 'class_signature))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'class_signature) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attribute) in
    Obj.repr(
(*# 1103 "parsing/parser.mly"*)
      ( Cty.attr _1 _2 )
(*# 7783 "parsing/parser.ml"*)
               : 'class_signature))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'extension) in
    Obj.repr(
(*# 1105 "parsing/parser.mly"*)
      ( mkcty(Pcty_extension _1) )
(*# 7790 "parsing/parser.ml"*)
               : 'class_signature))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'class_self_type) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'class_sig_fields) in
    Obj.repr(
(*# 1109 "parsing/parser.mly"*)
      ( Csig.mk _1 (extra_csig 2 (List.rev _2)) )
(*# 7798 "parsing/parser.ml"*)
               : 'class_sig_body))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'core_type) in
    Obj.repr(
(*# 1113 "parsing/parser.mly"*)
      ( _2 )
(*# 7805 "parsing/parser.ml"*)
               : 'class_self_type))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 1115 "parsing/parser.mly"*)
      ( mktyp(Ptyp_any) )
(*# 7811 "parsing/parser.ml"*)
               : 'class_self_type))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 1118 "parsing/parser.mly"*)
                                                ( [] )
(*# 7817 "parsing/parser.ml"*)
               : 'class_sig_fields))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'class_sig_fields) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'class_sig_field) in
    Obj.repr(
(*# 1119 "parsing/parser.mly"*)
                                       ( _2 :: (text_csig 2) @ _1 )
(*# 7825 "parsing/parser.ml"*)
               : 'class_sig_fields))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'class_signature) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 1123 "parsing/parser.mly"*)
      ( mkctf (Pctf_inherit _2) ~attrs:_3 ~docs:(symbol_docs ()) )
(*# 7833 "parsing/parser.ml"*)
               : 'class_sig_field))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'value_type) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 1125 "parsing/parser.mly"*)
      ( mkctf (Pctf_val _2) ~attrs:_3 ~docs:(symbol_docs ()) )
(*# 7841 "parsing/parser.ml"*)
               : 'class_sig_field))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'private_virtual_flags) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'label) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'poly_type) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 1127 "parsing/parser.mly"*)
      (
       let (p, v) = _2 in
       mkctf (Pctf_method (_3, p, v, _5)) ~attrs:_6 ~docs:(symbol_docs ())
      )
(*# 7854 "parsing/parser.ml"*)
               : 'class_sig_field))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'constrain_field) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 1132 "parsing/parser.mly"*)
      ( mkctf (Pctf_constraint _2) ~attrs:_3 ~docs:(symbol_docs ()) )
(*# 7862 "parsing/parser.ml"*)
               : 'class_sig_field))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'item_extension) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 1134 "parsing/parser.mly"*)
      ( mkctf (Pctf_extension _1) ~attrs:_2 ~docs:(symbol_docs ()) )
(*# 7870 "parsing/parser.ml"*)
               : 'class_sig_field))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'floating_attribute) in
    Obj.repr(
(*# 1136 "parsing/parser.mly"*)
      ( mark_symbol_docs ();
        mkctf(Pctf_attribute _1) )
(*# 7878 "parsing/parser.ml"*)
               : 'class_sig_field))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'mutable_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'label) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
(*# 1141 "parsing/parser.mly"*)
      ( _3, _2, Virtual, _5 )
(*# 7887 "parsing/parser.ml"*)
               : 'value_type))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'virtual_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'label) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
(*# 1143 "parsing/parser.mly"*)
      ( _3, Mutable, _2, _5 )
(*# 7896 "parsing/parser.ml"*)
               : 'value_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'label) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
(*# 1145 "parsing/parser.mly"*)
      ( _1, Immutable, Concrete, _3 )
(*# 7904 "parsing/parser.ml"*)
               : 'value_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'core_type) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
(*# 1148 "parsing/parser.mly"*)
                                           ( _1, _3, symbol_rloc() )
(*# 7912 "parsing/parser.ml"*)
               : 'constrain))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'core_type) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
(*# 1151 "parsing/parser.mly"*)
                                           ( _1, _3 )
(*# 7920 "parsing/parser.ml"*)
               : 'constrain_field))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'class_description) in
    Obj.repr(
(*# 1154 "parsing/parser.mly"*)
                                                ( [_1] )
(*# 7927 "parsing/parser.ml"*)
               : 'class_descriptions))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'class_descriptions) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'and_class_description) in
    Obj.repr(
(*# 1155 "parsing/parser.mly"*)
                                                ( _2 :: _1 )
(*# 7935 "parsing/parser.ml"*)
               : 'class_descriptions))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'virtual_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'class_type_parameters) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : 'class_type) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 1160 "parsing/parser.mly"*)
      ( Ci.mk (mkrhs _4 4) _6 ~virt:_2 ~params:_3 ~attrs:_7
              ~loc:(symbol_rloc ()) ~docs:(symbol_docs ()) )
(*# 7947 "parsing/parser.ml"*)
               : 'class_description))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'virtual_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'class_type_parameters) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : 'class_type) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 1166 "parsing/parser.mly"*)
      ( Ci.mk (mkrhs _4 4) _6 ~virt:_2 ~params:_3
              ~attrs:_7 ~loc:(symbol_rloc ())
              ~text:(symbol_text ()) ~docs:(symbol_docs ()) )
(*# 7960 "parsing/parser.ml"*)
               : 'and_class_description))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'class_type_declaration) in
    Obj.repr(
(*# 1171 "parsing/parser.mly"*)
                                                        ( [_1] )
(*# 7967 "parsing/parser.ml"*)
               : 'class_type_declarations))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'class_type_declarations) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'and_class_type_declaration) in
    Obj.repr(
(*# 1172 "parsing/parser.mly"*)
                                                        ( _2 :: _1 )
(*# 7975 "parsing/parser.ml"*)
               : 'class_type_declarations))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 5 : 'virtual_flag) in
    let _4 = (Parsing.peek_val __caml_parser_env 4 : 'class_type_parameters) in
    let _5 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _7 = (Parsing.peek_val __caml_parser_env 1 : 'class_signature) in
    let _8 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 1177 "parsing/parser.mly"*)
      ( Ci.mk (mkrhs _5 5) _7 ~virt:_3 ~params:_4 ~attrs:_8
              ~loc:(symbol_rloc ()) ~docs:(symbol_docs ()) )
(*# 7987 "parsing/parser.ml"*)
               : 'class_type_declaration))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'virtual_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'class_type_parameters) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : 'class_signature) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 1183 "parsing/parser.mly"*)
      ( Ci.mk (mkrhs _4 4) _6 ~virt:_2 ~params:_3
         ~attrs:_7 ~loc:(symbol_rloc ())
         ~text:(symbol_text ()) ~docs:(symbol_docs ()) )
(*# 8000 "parsing/parser.ml"*)
               : 'and_class_type_declaration))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1191 "parsing/parser.mly"*)
                                  ( _1 )
(*# 8007 "parsing/parser.ml"*)
               : 'seq_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    Obj.repr(
(*# 1192 "parsing/parser.mly"*)
                                  ( reloc_exp _1 )
(*# 8014 "parsing/parser.ml"*)
               : 'seq_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
(*# 1193 "parsing/parser.mly"*)
                                  ( mkexp(Pexp_sequence(_1, _3)) )
(*# 8022 "parsing/parser.ml"*)
               : 'seq_expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'label_let_pattern) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'opt_default) in
    Obj.repr(
(*# 1197 "parsing/parser.mly"*)
      ( ("?" ^ fst _3, _4, snd _3) )
(*# 8030 "parsing/parser.ml"*)
               : 'labeled_simple_pattern))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'label_var) in
    Obj.repr(
(*# 1199 "parsing/parser.mly"*)
      ( ("?" ^ fst _2, None, snd _2) )
(*# 8037 "parsing/parser.ml"*)
               : 'labeled_simple_pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'let_pattern) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'opt_default) in
    Obj.repr(
(*# 1201 "parsing/parser.mly"*)
      ( ("?" ^ _1, _4, _3) )
(*# 8046 "parsing/parser.ml"*)
               : 'labeled_simple_pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'pattern_var) in
    Obj.repr(
(*# 1203 "parsing/parser.mly"*)
      ( ("?" ^ _1, None, _2) )
(*# 8054 "parsing/parser.ml"*)
               : 'labeled_simple_pattern))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'label_let_pattern) in
    Obj.repr(
(*# 1205 "parsing/parser.mly"*)
      ( (fst _3, None, snd _3) )
(*# 8061 "parsing/parser.ml"*)
               : 'labeled_simple_pattern))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'label_var) in
    Obj.repr(
(*# 1207 "parsing/parser.mly"*)
      ( (fst _2, None, snd _2) )
(*# 8068 "parsing/parser.ml"*)
               : 'labeled_simple_pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'simple_pattern) in
    Obj.repr(
(*# 1209 "parsing/parser.mly"*)
      ( (_1, None, _2) )
(*# 8076 "parsing/parser.ml"*)
               : 'labeled_simple_pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_pattern) in
    Obj.repr(
(*# 1211 "parsing/parser.mly"*)
      ( ("", None, _1) )
(*# 8083 "parsing/parser.ml"*)
               : 'labeled_simple_pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
(*# 1214 "parsing/parser.mly"*)
                      ( mkpat(Ppat_var (mkrhs _1 1)) )
(*# 8090 "parsing/parser.ml"*)
               : 'pattern_var))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 1215 "parsing/parser.mly"*)
                      ( mkpat Ppat_any )
(*# 8096 "parsing/parser.ml"*)
               : 'pattern_var))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 1218 "parsing/parser.mly"*)
                                        ( None )
(*# 8102 "parsing/parser.ml"*)
               : 'opt_default))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
(*# 1219 "parsing/parser.mly"*)
                                        ( Some _2 )
(*# 8109 "parsing/parser.ml"*)
               : 'opt_default))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'label_var) in
    Obj.repr(
(*# 1223 "parsing/parser.mly"*)
      ( _1 )
(*# 8116 "parsing/parser.ml"*)
               : 'label_let_pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'label_var) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
(*# 1225 "parsing/parser.mly"*)
      ( let (lab, pat) = _1 in (lab, mkpat(Ppat_constraint(pat, _3))) )
(*# 8124 "parsing/parser.ml"*)
               : 'label_let_pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
(*# 1228 "parsing/parser.mly"*)
              ( (_1, mkpat(Ppat_var (mkrhs _1 1))) )
(*# 8131 "parsing/parser.ml"*)
               : 'label_var))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
(*# 1232 "parsing/parser.mly"*)
      ( _1 )
(*# 8138 "parsing/parser.ml"*)
               : 'let_pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
(*# 1234 "parsing/parser.mly"*)
      ( mkpat(Ppat_constraint(_1, _3)) )
(*# 8146 "parsing/parser.ml"*)
               : 'let_pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_expr) in
    Obj.repr(
(*# 1238 "parsing/parser.mly"*)
      ( _1 )
(*# 8153 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'simple_expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'simple_labeled_expr_list) in
    Obj.repr(
(*# 1240 "parsing/parser.mly"*)
      ( mkexp(Pexp_apply(_1, List.rev _2)) )
(*# 8161 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'let_bindings) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
(*# 1242 "parsing/parser.mly"*)
      ( expr_of_let_bindings _1 _3 )
(*# 8169 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'ext_attributes) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'module_binding_body) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
(*# 1244 "parsing/parser.mly"*)
      ( mkexp_attrs (Pexp_letmodule(mkrhs _4 4, _5, _7)) _3 )
(*# 8179 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'override_flag) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'ext_attributes) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'mod_longident) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
(*# 1246 "parsing/parser.mly"*)
      ( mkexp_attrs (Pexp_open(_3, mkrhs _5 5, _7)) _4 )
(*# 8189 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'opt_bar) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'match_cases) in
    Obj.repr(
(*# 1248 "parsing/parser.mly"*)
      ( mkexp_attrs (Pexp_function(List.rev _4)) _2 )
(*# 8198 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'labeled_simple_pattern) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'fun_def) in
    Obj.repr(
(*# 1250 "parsing/parser.mly"*)
      ( let (l,o,p) = _3 in
        mkexp_attrs (Pexp_fun(l, o, p, _4)) _2 )
(*# 8208 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'ext_attributes) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'fun_def) in
    Obj.repr(
(*# 1253 "parsing/parser.mly"*)
      ( mkexp_attrs (Pexp_newtype(_5, _7)) _2 )
(*# 8217 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'seq_expr) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'opt_bar) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'match_cases) in
    Obj.repr(
(*# 1255 "parsing/parser.mly"*)
      ( mkexp_attrs (Pexp_match(_3, List.rev _6)) _2 )
(*# 8227 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'seq_expr) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'opt_bar) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'match_cases) in
    Obj.repr(
(*# 1257 "parsing/parser.mly"*)
      ( mkexp_attrs (Pexp_try(_3, List.rev _6)) _2 )
(*# 8237 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'seq_expr) in
    Obj.repr(
(*# 1259 "parsing/parser.mly"*)
      ( syntax_error() )
(*# 8245 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'expr_comma_list) in
    Obj.repr(
(*# 1261 "parsing/parser.mly"*)
      ( mkexp(Pexp_tuple(List.rev _1)) )
(*# 8252 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'constr_longident) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'simple_expr) in
    Obj.repr(
(*# 1263 "parsing/parser.mly"*)
      ( mkexp(Pexp_construct(mkrhs _1 1, Some _2)) )
(*# 8260 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'name_tag) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'simple_expr) in
    Obj.repr(
(*# 1265 "parsing/parser.mly"*)
      ( mkexp(Pexp_variant(_1, Some _2)) )
(*# 8268 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'seq_expr) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1267 "parsing/parser.mly"*)
      ( mkexp_attrs(Pexp_ifthenelse(_3, _5, Some _7)) _2 )
(*# 8278 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'seq_expr) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1269 "parsing/parser.mly"*)
      ( mkexp_attrs (Pexp_ifthenelse(_3, _5, None)) _2 )
(*# 8287 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'seq_expr) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
(*# 1271 "parsing/parser.mly"*)
      ( mkexp_attrs (Pexp_while(_3, _5)) _2 )
(*# 8296 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 8 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 7 : 'pattern) in
    let _5 = (Parsing.peek_val __caml_parser_env 5 : 'seq_expr) in
    let _6 = (Parsing.peek_val __caml_parser_env 4 : 'direction_flag) in
    let _7 = (Parsing.peek_val __caml_parser_env 3 : 'seq_expr) in
    let _9 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
(*# 1274 "parsing/parser.mly"*)
      ( mkexp_attrs(Pexp_for(_3, _5, _7, _6, _9)) _2 )
(*# 8308 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1276 "parsing/parser.mly"*)
      ( mkexp_cons (rhs_loc 2) (ghexp(Pexp_tuple[_1;_3])) (symbol_rloc()) )
(*# 8316 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _5 = (Parsing.peek_val __caml_parser_env 3 : 'expr) in
    let _7 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    Obj.repr(
(*# 1278 "parsing/parser.mly"*)
      ( mkexp_cons (rhs_loc 2) (ghexp(Pexp_tuple[_5;_7])) (symbol_rloc()) )
(*# 8324 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1280 "parsing/parser.mly"*)
      ( mkinfix _1 _2 _3 )
(*# 8333 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1282 "parsing/parser.mly"*)
      ( mkinfix _1 _2 _3 )
(*# 8342 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1284 "parsing/parser.mly"*)
      ( mkinfix _1 _2 _3 )
(*# 8351 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1286 "parsing/parser.mly"*)
      ( mkinfix _1 _2 _3 )
(*# 8360 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1288 "parsing/parser.mly"*)
      ( mkinfix _1 _2 _3 )
(*# 8369 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1290 "parsing/parser.mly"*)
      ( mkinfix _1 "+" _3 )
(*# 8377 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1292 "parsing/parser.mly"*)
      ( mkinfix _1 "+." _3 )
(*# 8385 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1294 "parsing/parser.mly"*)
      ( mkinfix _1 "+=" _3 )
(*# 8393 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1296 "parsing/parser.mly"*)
      ( mkinfix _1 "-" _3 )
(*# 8401 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1298 "parsing/parser.mly"*)
      ( mkinfix _1 "-." _3 )
(*# 8409 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1300 "parsing/parser.mly"*)
      ( mkinfix _1 "*" _3 )
(*# 8417 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1302 "parsing/parser.mly"*)
      ( mkinfix _1 "%" _3 )
(*# 8425 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1304 "parsing/parser.mly"*)
      ( mkinfix _1 "=" _3 )
(*# 8433 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1306 "parsing/parser.mly"*)
      ( mkinfix _1 "<" _3 )
(*# 8441 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1308 "parsing/parser.mly"*)
      ( mkinfix _1 ">" _3 )
(*# 8449 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1310 "parsing/parser.mly"*)
      ( mkinfix _1 "or" _3 )
(*# 8457 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1312 "parsing/parser.mly"*)
      ( mkinfix _1 "||" _3 )
(*# 8465 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1314 "parsing/parser.mly"*)
      ( mkinfix _1 "&" _3 )
(*# 8473 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1316 "parsing/parser.mly"*)
      ( mkinfix _1 "&&" _3 )
(*# 8481 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1318 "parsing/parser.mly"*)
      ( mkinfix _1 ":=" _3 )
(*# 8489 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'subtractive) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1320 "parsing/parser.mly"*)
      ( mkuminus _1 _2 )
(*# 8497 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'additive) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1322 "parsing/parser.mly"*)
      ( mkuplus _1 _2 )
(*# 8505 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'simple_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'label_longident) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1324 "parsing/parser.mly"*)
      ( mkexp(Pexp_setfield(_1, mkrhs _3 3, _5)) )
(*# 8514 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : 'simple_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'seq_expr) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1326 "parsing/parser.mly"*)
      ( mkexp(Pexp_apply(ghexp(Pexp_ident(array_function "Array" "set")),
                         ["",_1; "",_4; "",_7])) )
(*# 8524 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : 'simple_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'seq_expr) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1329 "parsing/parser.mly"*)
      ( mkexp(Pexp_apply(ghexp(Pexp_ident(array_function "String" "set")),
                         ["",_1; "",_4; "",_7])) )
(*# 8534 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : 'simple_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'expr) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1332 "parsing/parser.mly"*)
      ( bigarray_set _1 _4 _7 )
(*# 8543 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'label) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1334 "parsing/parser.mly"*)
      ( mkexp(Pexp_setinstvar(mkrhs _1 1, _3)) )
(*# 8551 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'simple_expr) in
    Obj.repr(
(*# 1336 "parsing/parser.mly"*)
      ( mkexp_attrs (Pexp_assert _3) _2 )
(*# 8559 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'simple_expr) in
    Obj.repr(
(*# 1338 "parsing/parser.mly"*)
      ( mkexp_attrs (Pexp_lazy _3) _2 )
(*# 8567 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'class_structure) in
    Obj.repr(
(*# 1340 "parsing/parser.mly"*)
      ( mkexp_attrs (Pexp_object _3) _2 )
(*# 8575 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'class_structure) in
    Obj.repr(
(*# 1342 "parsing/parser.mly"*)
      ( unclosed "object" 1 "end" 4 )
(*# 8583 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attribute) in
    Obj.repr(
(*# 1344 "parsing/parser.mly"*)
      ( Exp.attr _1 _2 )
(*# 8591 "parsing/parser.ml"*)
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'val_longident) in
    Obj.repr(
(*# 1348 "parsing/parser.mly"*)
      ( mkexp(Pexp_ident (mkrhs _1 1)) )
(*# 8598 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'constant) in
    Obj.repr(
(*# 1350 "parsing/parser.mly"*)
      ( mkexp(Pexp_constant _1) )
(*# 8605 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'constr_longident) in
    Obj.repr(
(*# 1352 "parsing/parser.mly"*)
      ( mkexp(Pexp_construct(mkrhs _1 1, None)) )
(*# 8612 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'name_tag) in
    Obj.repr(
(*# 1354 "parsing/parser.mly"*)
      ( mkexp(Pexp_variant(_1, None)) )
(*# 8619 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
(*# 1356 "parsing/parser.mly"*)
      ( reloc_exp _2 )
(*# 8626 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
(*# 1358 "parsing/parser.mly"*)
      ( unclosed "(" 1 ")" 3 )
(*# 8633 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
(*# 1360 "parsing/parser.mly"*)
      ( wrap_exp_attrs (reloc_exp _3) _2 (* check location *) )
(*# 8641 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'ext_attributes) in
    Obj.repr(
(*# 1362 "parsing/parser.mly"*)
      ( mkexp_attrs (Pexp_construct (mkloc (Lident "()") (symbol_rloc ()),
                               None)) _2 )
(*# 8649 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
(*# 1365 "parsing/parser.mly"*)
      ( unclosed "begin" 1 "end" 3 )
(*# 8657 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'seq_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'type_constraint) in
    Obj.repr(
(*# 1367 "parsing/parser.mly"*)
      ( mkexp_constraint _2 _3 )
(*# 8665 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'simple_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'label_longident) in
    Obj.repr(
(*# 1369 "parsing/parser.mly"*)
      ( mkexp(Pexp_field(_1, mkrhs _3 3)) )
(*# 8673 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
(*# 1371 "parsing/parser.mly"*)
      ( mkexp(Pexp_open(Fresh, mkrhs _1 1, _4)) )
(*# 8681 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
(*# 1373 "parsing/parser.mly"*)
      ( unclosed "(" 3 ")" 5 )
(*# 8689 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'simple_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
(*# 1375 "parsing/parser.mly"*)
      ( mkexp(Pexp_apply(ghexp(Pexp_ident(array_function "Array" "get")),
                         ["",_1; "",_4])) )
(*# 8698 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'simple_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
(*# 1378 "parsing/parser.mly"*)
      ( unclosed "(" 3 ")" 5 )
(*# 8706 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'simple_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
(*# 1380 "parsing/parser.mly"*)
      ( mkexp(Pexp_apply(ghexp(Pexp_ident(array_function "String" "get")),
                         ["",_1; "",_4])) )
(*# 8715 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'simple_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
(*# 1383 "parsing/parser.mly"*)
      ( unclosed "[" 3 "]" 5 )
(*# 8723 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'simple_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    Obj.repr(
(*# 1385 "parsing/parser.mly"*)
      ( bigarray_get _1 _4 )
(*# 8731 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'simple_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'expr_comma_list) in
    Obj.repr(
(*# 1387 "parsing/parser.mly"*)
      ( unclosed "{" 3 "}" 5 )
(*# 8739 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'record_expr) in
    Obj.repr(
(*# 1389 "parsing/parser.mly"*)
      ( let (exten, fields) = _2 in mkexp (Pexp_record(fields, exten)) )
(*# 8746 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'record_expr) in
    Obj.repr(
(*# 1391 "parsing/parser.mly"*)
      ( unclosed "{" 1 "}" 3 )
(*# 8753 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'record_expr) in
    Obj.repr(
(*# 1393 "parsing/parser.mly"*)
      ( let (exten, fields) = _4 in
        let rec_exp = mkexp(Pexp_record(fields, exten)) in
        mkexp(Pexp_open(Fresh, mkrhs _1 1, rec_exp)) )
(*# 8763 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'record_expr) in
    Obj.repr(
(*# 1397 "parsing/parser.mly"*)
      ( unclosed "{" 3 "}" 5 )
(*# 8771 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'expr_semi_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
(*# 1399 "parsing/parser.mly"*)
      ( mkexp (Pexp_array(List.rev _2)) )
(*# 8779 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'expr_semi_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
(*# 1401 "parsing/parser.mly"*)
      ( unclosed "[|" 1 "|]" 4 )
(*# 8787 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 1403 "parsing/parser.mly"*)
      ( mkexp (Pexp_array []) )
(*# 8793 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 5 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'expr_semi_list) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
(*# 1405 "parsing/parser.mly"*)
      ( mkexp(Pexp_open(Fresh, mkrhs _1 1, mkexp(Pexp_array(List.rev _4)))) )
(*# 8802 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 5 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'expr_semi_list) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
(*# 1407 "parsing/parser.mly"*)
      ( unclosed "[|" 3 "|]" 6 )
(*# 8811 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'expr_semi_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
(*# 1409 "parsing/parser.mly"*)
      ( reloc_exp (mktailexp (rhs_loc 4) (List.rev _2)) )
(*# 8819 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'expr_semi_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
(*# 1411 "parsing/parser.mly"*)
      ( unclosed "[" 1 "]" 4 )
(*# 8827 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 5 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'expr_semi_list) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
(*# 1413 "parsing/parser.mly"*)
      ( let list_exp = reloc_exp (mktailexp (rhs_loc 6) (List.rev _4)) in
        mkexp(Pexp_open(Fresh, mkrhs _1 1, list_exp)) )
(*# 8837 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 5 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'expr_semi_list) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
(*# 1416 "parsing/parser.mly"*)
      ( unclosed "[" 3 "]" 6 )
(*# 8846 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'simple_expr) in
    Obj.repr(
(*# 1418 "parsing/parser.mly"*)
      ( mkexp(Pexp_apply(mkoperator _1 1, ["",_2])) )
(*# 8854 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'simple_expr) in
    Obj.repr(
(*# 1420 "parsing/parser.mly"*)
      ( mkexp(Pexp_apply(mkoperator "!" 1, ["",_2])) )
(*# 8861 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'class_longident) in
    Obj.repr(
(*# 1422 "parsing/parser.mly"*)
      ( mkexp_attrs (Pexp_new(mkrhs _3 3)) _2 )
(*# 8869 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'field_expr_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
(*# 1424 "parsing/parser.mly"*)
      ( mkexp (Pexp_override(List.rev _2)) )
(*# 8877 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'field_expr_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
(*# 1426 "parsing/parser.mly"*)
      ( unclosed "{<" 1 ">}" 4 )
(*# 8885 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 1428 "parsing/parser.mly"*)
      ( mkexp (Pexp_override []))
(*# 8891 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 5 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'field_expr_list) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
(*# 1430 "parsing/parser.mly"*)
      ( mkexp(Pexp_open(Fresh, mkrhs _1 1, mkexp (Pexp_override(List.rev _4)))))
(*# 8900 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 5 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'field_expr_list) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
(*# 1432 "parsing/parser.mly"*)
      ( unclosed "{<" 3 ">}" 6 )
(*# 8909 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'simple_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'label) in
    Obj.repr(
(*# 1434 "parsing/parser.mly"*)
      ( mkexp(Pexp_send(_1, _3)) )
(*# 8917 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'simple_expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'simple_expr) in
    Obj.repr(
(*# 1436 "parsing/parser.mly"*)
      ( mkinfix _1 _2 _3 )
(*# 8926 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'module_expr) in
    Obj.repr(
(*# 1438 "parsing/parser.mly"*)
      ( mkexp (Pexp_pack _3) )
(*# 8933 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'module_expr) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'package_type) in
    Obj.repr(
(*# 1440 "parsing/parser.mly"*)
      ( mkexp (Pexp_constraint (ghexp (Pexp_pack _3),
                                ghtyp (Ptyp_package _5))) )
(*# 8942 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'module_expr) in
    Obj.repr(
(*# 1443 "parsing/parser.mly"*)
      ( unclosed "(" 1 ")" 5 )
(*# 8949 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 7 : 'mod_longident) in
    let _5 = (Parsing.peek_val __caml_parser_env 3 : 'module_expr) in
    let _7 = (Parsing.peek_val __caml_parser_env 1 : 'package_type) in
    Obj.repr(
(*# 1445 "parsing/parser.mly"*)
      ( mkexp(Pexp_open(Fresh, mkrhs _1 1,
        mkexp (Pexp_constraint (ghexp (Pexp_pack _5),
                                ghtyp (Ptyp_package _7))))) )
(*# 8960 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : 'mod_longident) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'module_expr) in
    Obj.repr(
(*# 1449 "parsing/parser.mly"*)
      ( unclosed "(" 3 ")" 7 )
(*# 8968 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'extension) in
    Obj.repr(
(*# 1451 "parsing/parser.mly"*)
      ( mkexp (Pexp_extension _1) )
(*# 8975 "parsing/parser.ml"*)
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'labeled_simple_expr) in
    Obj.repr(
(*# 1455 "parsing/parser.mly"*)
      ( [_1] )
(*# 8982 "parsing/parser.ml"*)
               : 'simple_labeled_expr_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'simple_labeled_expr_list) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'labeled_simple_expr) in
    Obj.repr(
(*# 1457 "parsing/parser.mly"*)
      ( _2 :: _1 )
(*# 8990 "parsing/parser.ml"*)
               : 'simple_labeled_expr_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_expr) in
    Obj.repr(
(*# 1461 "parsing/parser.mly"*)
      ( ("", _1) )
(*# 8997 "parsing/parser.ml"*)
               : 'labeled_simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'label_expr) in
    Obj.repr(
(*# 1463 "parsing/parser.mly"*)
      ( _1 )
(*# 9004 "parsing/parser.ml"*)
               : 'labeled_simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'simple_expr) in
    Obj.repr(
(*# 1467 "parsing/parser.mly"*)
      ( (_1, _2) )
(*# 9012 "parsing/parser.ml"*)
               : 'label_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'label_ident) in
    Obj.repr(
(*# 1469 "parsing/parser.mly"*)
      ( _2 )
(*# 9019 "parsing/parser.ml"*)
               : 'label_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'label_ident) in
    Obj.repr(
(*# 1471 "parsing/parser.mly"*)
      ( ("?" ^ fst _2, snd _2) )
(*# 9026 "parsing/parser.ml"*)
               : 'label_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'simple_expr) in
    Obj.repr(
(*# 1473 "parsing/parser.mly"*)
      ( ("?" ^ _1, _2) )
(*# 9034 "parsing/parser.ml"*)
               : 'label_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
(*# 1476 "parsing/parser.mly"*)
             ( (_1, mkexp(Pexp_ident(mkrhs (Lident _1) 1))) )
(*# 9041 "parsing/parser.ml"*)
               : 'label_ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
(*# 1479 "parsing/parser.mly"*)
                                      ( [_1] )
(*# 9048 "parsing/parser.ml"*)
               : 'lident_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lident_list) in
    Obj.repr(
(*# 1480 "parsing/parser.mly"*)
                                      ( _1 :: _2 )
(*# 9056 "parsing/parser.ml"*)
               : 'lident_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'val_ident) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'fun_binding) in
    Obj.repr(
(*# 1484 "parsing/parser.mly"*)
      ( (mkpatvar _1 1, _2) )
(*# 9064 "parsing/parser.ml"*)
               : 'let_binding_body))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : 'val_ident) in
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'typevar_list) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'core_type) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
(*# 1486 "parsing/parser.mly"*)
      ( (ghpat(Ppat_constraint(mkpatvar _1 1,
                               ghtyp(Ptyp_poly(List.rev _3,_5)))),
         _7) )
(*# 9076 "parsing/parser.ml"*)
               : 'let_binding_body))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 7 : 'val_ident) in
    let _4 = (Parsing.peek_val __caml_parser_env 4 : 'lident_list) in
    let _6 = (Parsing.peek_val __caml_parser_env 2 : 'core_type) in
    let _8 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
(*# 1490 "parsing/parser.mly"*)
      ( let exp, poly = wrap_type_annotation _4 _6 _8 in
        (ghpat(Ppat_constraint(mkpatvar _1 1, poly)), exp) )
(*# 9087 "parsing/parser.ml"*)
               : 'let_binding_body))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
(*# 1493 "parsing/parser.mly"*)
      ( (_1, _3) )
(*# 9095 "parsing/parser.ml"*)
               : 'let_binding_body))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'simple_pattern_not_ident) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'core_type) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
(*# 1495 "parsing/parser.mly"*)
      ( (ghpat(Ppat_constraint(_1, _3)), _5) )
(*# 9104 "parsing/parser.ml"*)
               : 'let_binding_body))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'let_binding) in
    Obj.repr(
(*# 1498 "parsing/parser.mly"*)
                                                ( _1 )
(*# 9111 "parsing/parser.ml"*)
               : 'let_bindings))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'let_bindings) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'and_let_binding) in
    Obj.repr(
(*# 1499 "parsing/parser.mly"*)
                                                ( addlb _1 _2 )
(*# 9119 "parsing/parser.ml"*)
               : 'let_bindings))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'rec_flag) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'let_binding_body) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 1503 "parsing/parser.mly"*)
      ( mklbs _2 _3 (mklb _4 _5) )
(*# 9129 "parsing/parser.ml"*)
               : 'let_binding))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'let_binding_body) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 1507 "parsing/parser.mly"*)
      ( mklb _2 _3 )
(*# 9137 "parsing/parser.ml"*)
               : 'and_let_binding))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'strict_binding) in
    Obj.repr(
(*# 1511 "parsing/parser.mly"*)
      ( _1 )
(*# 9144 "parsing/parser.ml"*)
               : 'fun_binding))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'type_constraint) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
(*# 1513 "parsing/parser.mly"*)
      ( mkexp_constraint _3 _1 )
(*# 9152 "parsing/parser.ml"*)
               : 'fun_binding))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
(*# 1517 "parsing/parser.mly"*)
      ( _2 )
(*# 9159 "parsing/parser.ml"*)
               : 'strict_binding))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'labeled_simple_pattern) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'fun_binding) in
    Obj.repr(
(*# 1519 "parsing/parser.mly"*)
      ( let (l, o, p) = _1 in ghexp(Pexp_fun(l, o, p, _2)) )
(*# 9167 "parsing/parser.ml"*)
               : 'strict_binding))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'fun_binding) in
    Obj.repr(
(*# 1521 "parsing/parser.mly"*)
      ( mkexp(Pexp_newtype(_3, _5)) )
(*# 9175 "parsing/parser.ml"*)
               : 'strict_binding))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'match_case) in
    Obj.repr(
(*# 1524 "parsing/parser.mly"*)
               ( [_1] )
(*# 9182 "parsing/parser.ml"*)
               : 'match_cases))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'match_cases) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'match_case) in
    Obj.repr(
(*# 1525 "parsing/parser.mly"*)
                               ( _3 :: _1 )
(*# 9190 "parsing/parser.ml"*)
               : 'match_cases))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
(*# 1529 "parsing/parser.mly"*)
      ( Exp.case _1 _3 )
(*# 9198 "parsing/parser.ml"*)
               : 'match_case))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'pattern) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'seq_expr) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
(*# 1531 "parsing/parser.mly"*)
      ( Exp.case _1 ~guard:_3 _5 )
(*# 9207 "parsing/parser.ml"*)
               : 'match_case))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
(*# 1534 "parsing/parser.mly"*)
                                                ( _2 )
(*# 9214 "parsing/parser.ml"*)
               : 'fun_def))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'labeled_simple_pattern) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'fun_def) in
    Obj.repr(
(*# 1537 "parsing/parser.mly"*)
      (
       let (l,o,p) = _1 in
       ghexp(Pexp_fun(l, o, p, _2))
      )
(*# 9225 "parsing/parser.ml"*)
               : 'fun_def))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'fun_def) in
    Obj.repr(
(*# 1542 "parsing/parser.mly"*)
      ( mkexp(Pexp_newtype(_3, _5)) )
(*# 9233 "parsing/parser.ml"*)
               : 'fun_def))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr_comma_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1545 "parsing/parser.mly"*)
                                                ( _3 :: _1 )
(*# 9241 "parsing/parser.ml"*)
               : 'expr_comma_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1546 "parsing/parser.mly"*)
                                                ( [_3; _1] )
(*# 9249 "parsing/parser.ml"*)
               : 'expr_comma_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'simple_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'lbl_expr_list) in
    Obj.repr(
(*# 1549 "parsing/parser.mly"*)
                                                ( (Some _1, _3) )
(*# 9257 "parsing/parser.ml"*)
               : 'record_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'lbl_expr_list) in
    Obj.repr(
(*# 1550 "parsing/parser.mly"*)
                                                ( (None, _1) )
(*# 9264 "parsing/parser.ml"*)
               : 'record_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'lbl_expr) in
    Obj.repr(
(*# 1553 "parsing/parser.mly"*)
              ( [_1] )
(*# 9271 "parsing/parser.ml"*)
               : 'lbl_expr_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'lbl_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'lbl_expr_list) in
    Obj.repr(
(*# 1554 "parsing/parser.mly"*)
                                 ( _1 :: _3 )
(*# 9279 "parsing/parser.ml"*)
               : 'lbl_expr_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'lbl_expr) in
    Obj.repr(
(*# 1555 "parsing/parser.mly"*)
                   ( [_1] )
(*# 9286 "parsing/parser.ml"*)
               : 'lbl_expr_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'label_longident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1559 "parsing/parser.mly"*)
      ( (mkrhs _1 1,_3) )
(*# 9294 "parsing/parser.ml"*)
               : 'lbl_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'label_longident) in
    Obj.repr(
(*# 1561 "parsing/parser.mly"*)
      ( (mkrhs _1 1, exp_of_label _1 1) )
(*# 9301 "parsing/parser.ml"*)
               : 'lbl_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'label) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1565 "parsing/parser.mly"*)
      ( [mkrhs _1 1,_3] )
(*# 9309 "parsing/parser.ml"*)
               : 'field_expr_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'field_expr_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'label) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1567 "parsing/parser.mly"*)
      ( (mkrhs _3 3, _5) :: _1 )
(*# 9318 "parsing/parser.ml"*)
               : 'field_expr_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1570 "parsing/parser.mly"*)
                                                ( [_1] )
(*# 9325 "parsing/parser.ml"*)
               : 'expr_semi_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr_semi_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
(*# 1571 "parsing/parser.mly"*)
                                                ( _3 :: _1 )
(*# 9333 "parsing/parser.ml"*)
               : 'expr_semi_list))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
(*# 1574 "parsing/parser.mly"*)
                                                ( (Some _2, None) )
(*# 9340 "parsing/parser.ml"*)
               : 'type_constraint))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'core_type) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
(*# 1575 "parsing/parser.mly"*)
                                                ( (Some _2, Some _4) )
(*# 9348 "parsing/parser.ml"*)
               : 'type_constraint))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
(*# 1576 "parsing/parser.mly"*)
                                                ( (None, Some _2) )
(*# 9355 "parsing/parser.ml"*)
               : 'type_constraint))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 1577 "parsing/parser.mly"*)
                                                ( syntax_error() )
(*# 9361 "parsing/parser.ml"*)
               : 'type_constraint))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 1578 "parsing/parser.mly"*)
                                                ( syntax_error() )
(*# 9367 "parsing/parser.ml"*)
               : 'type_constraint))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_pattern) in
    Obj.repr(
(*# 1585 "parsing/parser.mly"*)
      ( _1 )
(*# 9374 "parsing/parser.ml"*)
               : 'pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'val_ident) in
    Obj.repr(
(*# 1587 "parsing/parser.mly"*)
      ( mkpat(Ppat_alias(_1, mkrhs _3 3)) )
(*# 9382 "parsing/parser.ml"*)
               : 'pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    Obj.repr(
(*# 1589 "parsing/parser.mly"*)
      ( expecting 3 "identifier" )
(*# 9389 "parsing/parser.ml"*)
               : 'pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'pattern_comma_list) in
    Obj.repr(
(*# 1591 "parsing/parser.mly"*)
      ( mkpat(Ppat_tuple(List.rev _1)) )
(*# 9396 "parsing/parser.ml"*)
               : 'pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'constr_longident) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
(*# 1593 "parsing/parser.mly"*)
      ( mkpat(Ppat_construct(mkrhs _1 1, Some _2)) )
(*# 9404 "parsing/parser.ml"*)
               : 'pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'name_tag) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
(*# 1595 "parsing/parser.mly"*)
      ( mkpat(Ppat_variant(_1, Some _2)) )
(*# 9412 "parsing/parser.ml"*)
               : 'pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
(*# 1597 "parsing/parser.mly"*)
      ( mkpat_cons (rhs_loc 2) (ghpat(Ppat_tuple[_1;_3])) (symbol_rloc()) )
(*# 9420 "parsing/parser.ml"*)
               : 'pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    Obj.repr(
(*# 1599 "parsing/parser.mly"*)
      ( expecting 3 "pattern" )
(*# 9427 "parsing/parser.ml"*)
               : 'pattern))
; (fun __caml_parser_env ->
    let _5 = (Parsing.peek_val __caml_parser_env 3 : 'pattern) in
    let _7 = (Parsing.peek_val __caml_parser_env 1 : 'pattern) in
    Obj.repr(
(*# 1601 "parsing/parser.mly"*)
      ( mkpat_cons (rhs_loc 2) (ghpat(Ppat_tuple[_5;_7])) (symbol_rloc()) )
(*# 9435 "parsing/parser.ml"*)
               : 'pattern))
; (fun __caml_parser_env ->
    let _5 = (Parsing.peek_val __caml_parser_env 3 : 'pattern) in
    let _7 = (Parsing.peek_val __caml_parser_env 1 : 'pattern) in
    Obj.repr(
(*# 1603 "parsing/parser.mly"*)
      ( unclosed "(" 4 ")" 8 )
(*# 9443 "parsing/parser.ml"*)
               : 'pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
(*# 1605 "parsing/parser.mly"*)
      ( mkpat(Ppat_or(_1, _3)) )
(*# 9451 "parsing/parser.ml"*)
               : 'pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    Obj.repr(
(*# 1607 "parsing/parser.mly"*)
      ( expecting 3 "pattern" )
(*# 9458 "parsing/parser.ml"*)
               : 'pattern))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'simple_pattern) in
    Obj.repr(
(*# 1609 "parsing/parser.mly"*)
      ( mkpat(Ppat_lazy _2) )
(*# 9465 "parsing/parser.ml"*)
               : 'pattern))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
(*# 1611 "parsing/parser.mly"*)
      ( mkpat(Ppat_exception _2) )
(*# 9472 "parsing/parser.ml"*)
               : 'pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'pattern) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attribute) in
    Obj.repr(
(*# 1613 "parsing/parser.mly"*)
      ( Pat.attr _1 _2 )
(*# 9480 "parsing/parser.ml"*)
               : 'pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'val_ident) in
    Obj.repr(
(*# 1617 "parsing/parser.mly"*)
      ( mkpat(Ppat_var (mkrhs _1 1)) )
(*# 9487 "parsing/parser.ml"*)
               : 'simple_pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_pattern_not_ident) in
    Obj.repr(
(*# 1618 "parsing/parser.mly"*)
                             ( _1 )
(*# 9494 "parsing/parser.ml"*)
               : 'simple_pattern))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 1622 "parsing/parser.mly"*)
      ( mkpat(Ppat_any) )
(*# 9500 "parsing/parser.ml"*)
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'signed_constant) in
    Obj.repr(
(*# 1624 "parsing/parser.mly"*)
      ( mkpat(Ppat_constant _1) )
(*# 9507 "parsing/parser.ml"*)
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'signed_constant) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'signed_constant) in
    Obj.repr(
(*# 1626 "parsing/parser.mly"*)
      ( mkpat(Ppat_interval (_1, _3)) )
(*# 9515 "parsing/parser.ml"*)
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'constr_longident) in
    Obj.repr(
(*# 1628 "parsing/parser.mly"*)
      ( mkpat(Ppat_construct(mkrhs _1 1, None)) )
(*# 9522 "parsing/parser.ml"*)
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'name_tag) in
    Obj.repr(
(*# 1630 "parsing/parser.mly"*)
      ( mkpat(Ppat_variant(_1, None)) )
(*# 9529 "parsing/parser.ml"*)
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'type_longident) in
    Obj.repr(
(*# 1632 "parsing/parser.mly"*)
      ( mkpat(Ppat_type (mkrhs _2 2)) )
(*# 9536 "parsing/parser.ml"*)
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'lbl_pattern_list) in
    Obj.repr(
(*# 1634 "parsing/parser.mly"*)
      ( let (fields, closed) = _2 in mkpat(Ppat_record(fields, closed)) )
(*# 9543 "parsing/parser.ml"*)
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'lbl_pattern_list) in
    Obj.repr(
(*# 1636 "parsing/parser.mly"*)
      ( unclosed "{" 1 "}" 3 )
(*# 9550 "parsing/parser.ml"*)
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'pattern_semi_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
(*# 1638 "parsing/parser.mly"*)
      ( reloc_pat (mktailpat (rhs_loc 4) (List.rev _2)) )
(*# 9558 "parsing/parser.ml"*)
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'pattern_semi_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
(*# 1640 "parsing/parser.mly"*)
      ( unclosed "[" 1 "]" 4 )
(*# 9566 "parsing/parser.ml"*)
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'pattern_semi_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
(*# 1642 "parsing/parser.mly"*)
      ( mkpat(Ppat_array(List.rev _2)) )
(*# 9574 "parsing/parser.ml"*)
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 1644 "parsing/parser.mly"*)
      ( mkpat(Ppat_array []) )
(*# 9580 "parsing/parser.ml"*)
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'pattern_semi_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
(*# 1646 "parsing/parser.mly"*)
      ( unclosed "[|" 1 "|]" 4 )
(*# 9588 "parsing/parser.ml"*)
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'pattern) in
    Obj.repr(
(*# 1648 "parsing/parser.mly"*)
      ( reloc_pat _2 )
(*# 9595 "parsing/parser.ml"*)
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'pattern) in
    Obj.repr(
(*# 1650 "parsing/parser.mly"*)
      ( unclosed "(" 1 ")" 3 )
(*# 9602 "parsing/parser.ml"*)
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'pattern) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'core_type) in
    Obj.repr(
(*# 1652 "parsing/parser.mly"*)
      ( mkpat(Ppat_constraint(_2, _4)) )
(*# 9610 "parsing/parser.ml"*)
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'pattern) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'core_type) in
    Obj.repr(
(*# 1654 "parsing/parser.mly"*)
      ( unclosed "(" 1 ")" 5 )
(*# 9618 "parsing/parser.ml"*)
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    Obj.repr(
(*# 1656 "parsing/parser.mly"*)
      ( expecting 4 "type" )
(*# 9625 "parsing/parser.ml"*)
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : string) in
    Obj.repr(
(*# 1658 "parsing/parser.mly"*)
      ( mkpat(Ppat_unpack (mkrhs _3 3)) )
(*# 9632 "parsing/parser.ml"*)
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'package_type) in
    Obj.repr(
(*# 1660 "parsing/parser.mly"*)
      ( mkpat(Ppat_constraint(mkpat(Ppat_unpack (mkrhs _3 3)),
                              ghtyp(Ptyp_package _5))) )
(*# 9641 "parsing/parser.ml"*)
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'package_type) in
    Obj.repr(
(*# 1663 "parsing/parser.mly"*)
      ( unclosed "(" 1 ")" 6 )
(*# 9649 "parsing/parser.ml"*)
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'extension) in
    Obj.repr(
(*# 1665 "parsing/parser.mly"*)
      ( mkpat(Ppat_extension _1) )
(*# 9656 "parsing/parser.ml"*)
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern_comma_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
(*# 1669 "parsing/parser.mly"*)
                                                ( _3 :: _1 )
(*# 9664 "parsing/parser.ml"*)
               : 'pattern_comma_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
(*# 1670 "parsing/parser.mly"*)
                                                ( [_3; _1] )
(*# 9672 "parsing/parser.ml"*)
               : 'pattern_comma_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    Obj.repr(
(*# 1671 "parsing/parser.mly"*)
                                                ( expecting 3 "pattern" )
(*# 9679 "parsing/parser.ml"*)
               : 'pattern_comma_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
(*# 1674 "parsing/parser.mly"*)
                                                ( [_1] )
(*# 9686 "parsing/parser.ml"*)
               : 'pattern_semi_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern_semi_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
(*# 1675 "parsing/parser.mly"*)
                                                ( _3 :: _1 )
(*# 9694 "parsing/parser.ml"*)
               : 'pattern_semi_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'lbl_pattern) in
    Obj.repr(
(*# 1678 "parsing/parser.mly"*)
                ( [_1], Closed )
(*# 9701 "parsing/parser.ml"*)
               : 'lbl_pattern_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'lbl_pattern) in
    Obj.repr(
(*# 1679 "parsing/parser.mly"*)
                     ( [_1], Closed )
(*# 9708 "parsing/parser.ml"*)
               : 'lbl_pattern_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'lbl_pattern) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'opt_semi) in
    Obj.repr(
(*# 1680 "parsing/parser.mly"*)
                                         ( [_1], Open )
(*# 9716 "parsing/parser.ml"*)
               : 'lbl_pattern_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'lbl_pattern) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'lbl_pattern_list) in
    Obj.repr(
(*# 1682 "parsing/parser.mly"*)
      ( let (fields, closed) = _3 in _1 :: fields, closed )
(*# 9724 "parsing/parser.ml"*)
               : 'lbl_pattern_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'label_longident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
(*# 1686 "parsing/parser.mly"*)
      ( (mkrhs _1 1,_3) )
(*# 9732 "parsing/parser.ml"*)
               : 'lbl_pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'label_longident) in
    Obj.repr(
(*# 1688 "parsing/parser.mly"*)
      ( (mkrhs _1 1, pat_of_label _1 1) )
(*# 9739 "parsing/parser.ml"*)
               : 'lbl_pattern))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'val_ident) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'core_type) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 1695 "parsing/parser.mly"*)
      ( Val.mk (mkrhs _2 2) _4 ~attrs:_5
               ~loc:(symbol_rloc()) ~docs:(symbol_docs ()) )
(*# 9749 "parsing/parser.ml"*)
               : 'value_description))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string * string option) in
    Obj.repr(
(*# 1702 "parsing/parser.mly"*)
                                                ( [fst _1] )
(*# 9756 "parsing/parser.ml"*)
               : 'primitive_declaration_body))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string * string option) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'primitive_declaration_body) in
    Obj.repr(
(*# 1703 "parsing/parser.mly"*)
                                                ( fst _1 :: _2 )
(*# 9764 "parsing/parser.ml"*)
               : 'primitive_declaration_body))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'val_ident) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'core_type) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : 'primitive_declaration_body) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 1708 "parsing/parser.mly"*)
      ( Val.mk (mkrhs _2 2) _4 ~prim:_6 ~attrs:_7
               ~loc:(symbol_rloc ()) ~docs:(symbol_docs ()) )
(*# 9775 "parsing/parser.ml"*)
               : 'primitive_declaration))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'type_declaration) in
    Obj.repr(
(*# 1715 "parsing/parser.mly"*)
                                                ( [_1] )
(*# 9782 "parsing/parser.ml"*)
               : 'type_declarations))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'type_declarations) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'and_type_declaration) in
    Obj.repr(
(*# 1716 "parsing/parser.mly"*)
                                                ( _2 :: _1 )
(*# 9790 "parsing/parser.ml"*)
               : 'type_declarations))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'nonrec_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'optional_type_parameters) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'type_kind) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : 'constraints) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 1722 "parsing/parser.mly"*)
      ( let (kind, priv, manifest) = _5 in
          Type.mk (mkrhs _4 4) ~params:_3 ~cstrs:(List.rev _6) ~kind
            ~priv ?manifest ~attrs:(add_nonrec _2 _7 2)
            ~loc:(symbol_rloc ()) ~docs:(symbol_docs ()) )
(*# 9805 "parsing/parser.ml"*)
               : 'type_declaration))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'optional_type_parameters) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'type_kind) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'constraints) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 1730 "parsing/parser.mly"*)
      ( let (kind, priv, manifest) = _4 in
          Type.mk (mkrhs _3 3) ~params:_2 ~cstrs:(List.rev _5)
            ~kind ~priv ?manifest ~attrs:_6 ~loc:(symbol_rloc ())
            ~text:(symbol_text ()) ~docs:(symbol_docs ()) )
(*# 9819 "parsing/parser.ml"*)
               : 'and_type_declaration))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'constraints) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'constrain) in
    Obj.repr(
(*# 1736 "parsing/parser.mly"*)
                                                ( _3 :: _1 )
(*# 9827 "parsing/parser.ml"*)
               : 'constraints))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 1737 "parsing/parser.mly"*)
                                                ( [] )
(*# 9833 "parsing/parser.ml"*)
               : 'constraints))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 1741 "parsing/parser.mly"*)
      ( (Ptype_abstract, Public, None) )
(*# 9839 "parsing/parser.ml"*)
               : 'type_kind))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
(*# 1743 "parsing/parser.mly"*)
      ( (Ptype_abstract, Public, Some _2) )
(*# 9846 "parsing/parser.ml"*)
               : 'type_kind))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
(*# 1745 "parsing/parser.mly"*)
      ( (Ptype_abstract, Private, Some _3) )
(*# 9853 "parsing/parser.ml"*)
               : 'type_kind))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'constructor_declarations) in
    Obj.repr(
(*# 1747 "parsing/parser.mly"*)
      ( (Ptype_variant(List.rev _2), Public, None) )
(*# 9860 "parsing/parser.ml"*)
               : 'type_kind))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'constructor_declarations) in
    Obj.repr(
(*# 1749 "parsing/parser.mly"*)
      ( (Ptype_variant(List.rev _3), Private, None) )
(*# 9867 "parsing/parser.ml"*)
               : 'type_kind))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 1751 "parsing/parser.mly"*)
      ( (Ptype_open, Public, None) )
(*# 9873 "parsing/parser.ml"*)
               : 'type_kind))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'private_flag) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'label_declarations) in
    Obj.repr(
(*# 1753 "parsing/parser.mly"*)
      ( (Ptype_record _4, _2, None) )
(*# 9881 "parsing/parser.ml"*)
               : 'type_kind))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'core_type) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'private_flag) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'constructor_declarations) in
    Obj.repr(
(*# 1755 "parsing/parser.mly"*)
      ( (Ptype_variant(List.rev _5), _4, Some _2) )
(*# 9890 "parsing/parser.ml"*)
               : 'type_kind))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'core_type) in
    Obj.repr(
(*# 1757 "parsing/parser.mly"*)
      ( (Ptype_open, Public, Some _2) )
(*# 9897 "parsing/parser.ml"*)
               : 'type_kind))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'core_type) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'private_flag) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : 'label_declarations) in
    Obj.repr(
(*# 1759 "parsing/parser.mly"*)
      ( (Ptype_record _6, _4, Some _2) )
(*# 9906 "parsing/parser.ml"*)
               : 'type_kind))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 1762 "parsing/parser.mly"*)
                                                ( [] )
(*# 9912 "parsing/parser.ml"*)
               : 'optional_type_parameters))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'optional_type_parameter) in
    Obj.repr(
(*# 1763 "parsing/parser.mly"*)
                                                ( [_1] )
(*# 9919 "parsing/parser.ml"*)
               : 'optional_type_parameters))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'optional_type_parameter_list) in
    Obj.repr(
(*# 1764 "parsing/parser.mly"*)
                                                ( List.rev _2 )
(*# 9926 "parsing/parser.ml"*)
               : 'optional_type_parameters))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'type_variance) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'optional_type_variable) in
    Obj.repr(
(*# 1767 "parsing/parser.mly"*)
                                                ( _2, _1 )
(*# 9934 "parsing/parser.ml"*)
               : 'optional_type_parameter))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'optional_type_parameter) in
    Obj.repr(
(*# 1770 "parsing/parser.mly"*)
                                                         ( [_1] )
(*# 9941 "parsing/parser.ml"*)
               : 'optional_type_parameter_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'optional_type_parameter_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'optional_type_parameter) in
    Obj.repr(
(*# 1771 "parsing/parser.mly"*)
                                                                  ( _3 :: _1 )
(*# 9949 "parsing/parser.ml"*)
               : 'optional_type_parameter_list))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
(*# 1774 "parsing/parser.mly"*)
                                                ( mktyp(Ptyp_var _2) )
(*# 9956 "parsing/parser.ml"*)
               : 'optional_type_variable))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 1775 "parsing/parser.mly"*)
                                                ( mktyp(Ptyp_any) )
(*# 9962 "parsing/parser.ml"*)
               : 'optional_type_variable))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 1780 "parsing/parser.mly"*)
                                                ( [] )
(*# 9968 "parsing/parser.ml"*)
               : 'type_parameters))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'type_parameter) in
    Obj.repr(
(*# 1781 "parsing/parser.mly"*)
                                                ( [_1] )
(*# 9975 "parsing/parser.ml"*)
               : 'type_parameters))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'type_parameter_list) in
    Obj.repr(
(*# 1782 "parsing/parser.mly"*)
                                                ( List.rev _2 )
(*# 9982 "parsing/parser.ml"*)
               : 'type_parameters))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'type_variance) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'type_variable) in
    Obj.repr(
(*# 1785 "parsing/parser.mly"*)
                                                  ( _2, _1 )
(*# 9990 "parsing/parser.ml"*)
               : 'type_parameter))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 1788 "parsing/parser.mly"*)
                                                ( Invariant )
(*# 9996 "parsing/parser.ml"*)
               : 'type_variance))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 1789 "parsing/parser.mly"*)
                                                ( Covariant )
(*# 10002 "parsing/parser.ml"*)
               : 'type_variance))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 1790 "parsing/parser.mly"*)
                                                ( Contravariant )
(*# 10008 "parsing/parser.ml"*)
               : 'type_variance))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
(*# 1793 "parsing/parser.mly"*)
                                                ( mktyp(Ptyp_var _2) )
(*# 10015 "parsing/parser.ml"*)
               : 'type_variable))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'type_parameter) in
    Obj.repr(
(*# 1796 "parsing/parser.mly"*)
                                                ( [_1] )
(*# 10022 "parsing/parser.ml"*)
               : 'type_parameter_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'type_parameter_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'type_parameter) in
    Obj.repr(
(*# 1797 "parsing/parser.mly"*)
                                                ( _3 :: _1 )
(*# 10030 "parsing/parser.ml"*)
               : 'type_parameter_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'constructor_declaration) in
    Obj.repr(
(*# 1800 "parsing/parser.mly"*)
                                                         ( [_1] )
(*# 10037 "parsing/parser.ml"*)
               : 'constructor_declarations))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'bar_constructor_declaration) in
    Obj.repr(
(*# 1801 "parsing/parser.mly"*)
                                                         ( [_1] )
(*# 10044 "parsing/parser.ml"*)
               : 'constructor_declarations))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'constructor_declarations) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'bar_constructor_declaration) in
    Obj.repr(
(*# 1802 "parsing/parser.mly"*)
                                                         ( _2 :: _1 )
(*# 10052 "parsing/parser.ml"*)
               : 'constructor_declarations))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'constr_ident) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'generalized_constructor_arguments) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
(*# 1806 "parsing/parser.mly"*)
      (
       let args,res = _2 in
       Type.constructor (mkrhs _1 1) ~args ?res ~attrs:_3
         ~loc:(symbol_rloc()) ~info:(symbol_info ())
      )
(*# 10065 "parsing/parser.ml"*)
               : 'constructor_declaration))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'constr_ident) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'generalized_constructor_arguments) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
(*# 1814 "parsing/parser.mly"*)
      (
       let args,res = _3 in
       Type.constructor (mkrhs _2 2) ~args ?res ~attrs:_4
         ~loc:(symbol_rloc()) ~info:(symbol_info ())
      )
(*# 10078 "parsing/parser.ml"*)
               : 'bar_constructor_declaration))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'sig_exception_declaration) in
    Obj.repr(
(*# 1821 "parsing/parser.mly"*)
                                                 ( _1 )
(*# 10085 "parsing/parser.ml"*)
               : 'str_exception_declaration))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'constr_ident) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'constr_longident) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'attributes) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 1824 "parsing/parser.mly"*)
      ( Te.rebind (mkrhs _2 2) (mkrhs _4 4) ~attrs:(_5 @ _6)
          ~loc:(symbol_rloc()) ~docs:(symbol_docs ()) )
(*# 10096 "parsing/parser.ml"*)
               : 'str_exception_declaration))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'constr_ident) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'generalized_constructor_arguments) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'attributes) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 1830 "parsing/parser.mly"*)
      ( let args, res = _3 in
          Te.decl (mkrhs _2 2) ~args ?res ~attrs:(_4 @ _5)
            ~loc:(symbol_rloc()) ~docs:(symbol_docs ()) )
(*# 10108 "parsing/parser.ml"*)
               : 'sig_exception_declaration))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 1835 "parsing/parser.mly"*)
                                                ( ([],None) )
(*# 10114 "parsing/parser.ml"*)
               : 'generalized_constructor_arguments))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'core_type_list_no_attr) in
    Obj.repr(
(*# 1836 "parsing/parser.mly"*)
                                                ( (List.rev _2,None) )
(*# 10121 "parsing/parser.ml"*)
               : 'generalized_constructor_arguments))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'core_type_list_no_attr) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'simple_core_type_no_attr) in
    Obj.repr(
(*# 1838 "parsing/parser.mly"*)
                                                ( (List.rev _2,Some _4) )
(*# 10129 "parsing/parser.ml"*)
               : 'generalized_constructor_arguments))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'simple_core_type_no_attr) in
    Obj.repr(
(*# 1840 "parsing/parser.mly"*)
                                                ( ([],Some _2) )
(*# 10136 "parsing/parser.ml"*)
               : 'generalized_constructor_arguments))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'label_declaration) in
    Obj.repr(
(*# 1846 "parsing/parser.mly"*)
                                                ( [_1] )
(*# 10143 "parsing/parser.ml"*)
               : 'label_declarations))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'label_declaration_semi) in
    Obj.repr(
(*# 1847 "parsing/parser.mly"*)
                                                ( [_1] )
(*# 10150 "parsing/parser.ml"*)
               : 'label_declarations))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'label_declaration_semi) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'label_declarations) in
    Obj.repr(
(*# 1848 "parsing/parser.mly"*)
                                                ( _1 :: _2 )
(*# 10158 "parsing/parser.ml"*)
               : 'label_declarations))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'mutable_flag) in
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'label) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'poly_type_no_attr) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
(*# 1852 "parsing/parser.mly"*)
      (
       Type.field (mkrhs _2 2) _4 ~mut:_1 ~attrs:_5
         ~loc:(symbol_rloc()) ~info:(symbol_info ())
      )
(*# 10171 "parsing/parser.ml"*)
               : 'label_declaration))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : 'mutable_flag) in
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'label) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'poly_type_no_attr) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'attributes) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
(*# 1859 "parsing/parser.mly"*)
      (
       let info =
         match rhs_info 5 with
         | Some _ as info_before_semi -> info_before_semi
         | None -> symbol_info ()
       in
       Type.field (mkrhs _2 2) _4 ~mut:_1 ~attrs:(_5 @ _7)
         ~loc:(symbol_rloc()) ~info
      )
(*# 10190 "parsing/parser.ml"*)
               : 'label_declaration_semi))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 6 : 'nonrec_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 5 : 'optional_type_parameters) in
    let _4 = (Parsing.peek_val __caml_parser_env 4 : 'type_longident) in
    let _6 = (Parsing.peek_val __caml_parser_env 2 : 'private_flag) in
    let _7 = (Parsing.peek_val __caml_parser_env 1 : 'str_extension_constructors) in
    let _8 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 1875 "parsing/parser.mly"*)
      ( if _2 <> Recursive then not_expecting 2 "nonrec flag";
        Te.mk (mkrhs _4 4) (List.rev _7) ~params:_3 ~priv:_6
          ~attrs:_8 ~docs:(symbol_docs ()) )
(*# 10204 "parsing/parser.ml"*)
               : 'str_type_extension))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 6 : 'nonrec_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 5 : 'optional_type_parameters) in
    let _4 = (Parsing.peek_val __caml_parser_env 4 : 'type_longident) in
    let _6 = (Parsing.peek_val __caml_parser_env 2 : 'private_flag) in
    let _7 = (Parsing.peek_val __caml_parser_env 1 : 'sig_extension_constructors) in
    let _8 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 1882 "parsing/parser.mly"*)
      ( if _2 <> Recursive then not_expecting 2 "nonrec flag";
        Te.mk (mkrhs _4 4) (List.rev _7) ~params:_3 ~priv:_6
          ~attrs:_8 ~docs:(symbol_docs ()) )
(*# 10218 "parsing/parser.ml"*)
               : 'sig_type_extension))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'extension_constructor_declaration) in
    Obj.repr(
(*# 1887 "parsing/parser.mly"*)
                                                          ( [_1] )
(*# 10225 "parsing/parser.ml"*)
               : 'str_extension_constructors))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'bar_extension_constructor_declaration) in
    Obj.repr(
(*# 1888 "parsing/parser.mly"*)
                                                          ( [_1] )
(*# 10232 "parsing/parser.ml"*)
               : 'str_extension_constructors))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'extension_constructor_rebind) in
    Obj.repr(
(*# 1889 "parsing/parser.mly"*)
                                                          ( [_1] )
(*# 10239 "parsing/parser.ml"*)
               : 'str_extension_constructors))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'bar_extension_constructor_rebind) in
    Obj.repr(
(*# 1890 "parsing/parser.mly"*)
                                                          ( [_1] )
(*# 10246 "parsing/parser.ml"*)
               : 'str_extension_constructors))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'str_extension_constructors) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'bar_extension_constructor_declaration) in
    Obj.repr(
(*# 1892 "parsing/parser.mly"*)
      ( _2 :: _1 )
(*# 10254 "parsing/parser.ml"*)
               : 'str_extension_constructors))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'str_extension_constructors) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'bar_extension_constructor_rebind) in
    Obj.repr(
(*# 1894 "parsing/parser.mly"*)
      ( _2 :: _1 )
(*# 10262 "parsing/parser.ml"*)
               : 'str_extension_constructors))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'extension_constructor_declaration) in
    Obj.repr(
(*# 1897 "parsing/parser.mly"*)
                                                          ( [_1] )
(*# 10269 "parsing/parser.ml"*)
               : 'sig_extension_constructors))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'bar_extension_constructor_declaration) in
    Obj.repr(
(*# 1898 "parsing/parser.mly"*)
                                                          ( [_1] )
(*# 10276 "parsing/parser.ml"*)
               : 'sig_extension_constructors))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'sig_extension_constructors) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'bar_extension_constructor_declaration) in
    Obj.repr(
(*# 1900 "parsing/parser.mly"*)
      ( _2 :: _1 )
(*# 10284 "parsing/parser.ml"*)
               : 'sig_extension_constructors))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'constr_ident) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'generalized_constructor_arguments) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
(*# 1904 "parsing/parser.mly"*)
      ( let args, res = _2 in
        Te.decl (mkrhs _1 1) ~args ?res ~attrs:_3
          ~loc:(symbol_rloc()) ~info:(symbol_info ()) )
(*# 10295 "parsing/parser.ml"*)
               : 'extension_constructor_declaration))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'constr_ident) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'generalized_constructor_arguments) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
(*# 1910 "parsing/parser.mly"*)
      ( let args, res = _3 in
        Te.decl (mkrhs _2 2) ~args ?res ~attrs:_4
           ~loc:(symbol_rloc()) ~info:(symbol_info ()) )
(*# 10306 "parsing/parser.ml"*)
               : 'bar_extension_constructor_declaration))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'constr_ident) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'constr_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
(*# 1916 "parsing/parser.mly"*)
      ( Te.rebind (mkrhs _1 1) (mkrhs _3 3) ~attrs:_4
          ~loc:(symbol_rloc()) ~info:(symbol_info ()) )
(*# 10316 "parsing/parser.ml"*)
               : 'extension_constructor_rebind))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'constr_ident) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'constr_longident) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
(*# 1921 "parsing/parser.mly"*)
      ( Te.rebind (mkrhs _2 2) (mkrhs _4 4) ~attrs:_5
          ~loc:(symbol_rloc()) ~info:(symbol_info ()) )
(*# 10326 "parsing/parser.ml"*)
               : 'bar_extension_constructor_rebind))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'with_constraint) in
    Obj.repr(
(*# 1928 "parsing/parser.mly"*)
                                                ( [_1] )
(*# 10333 "parsing/parser.ml"*)
               : 'with_constraints))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'with_constraints) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'with_constraint) in
    Obj.repr(
(*# 1929 "parsing/parser.mly"*)
                                                ( _3 :: _1 )
(*# 10341 "parsing/parser.ml"*)
               : 'with_constraints))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'type_parameters) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'label_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'with_type_binder) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'core_type_no_attr) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'constraints) in
    Obj.repr(
(*# 1933 "parsing/parser.mly"*)
      ( Pwith_type
          (mkrhs _3 3,
           (Type.mk (mkrhs (Longident.last _3) 3)
              ~params:_2
              ~cstrs:(List.rev _6)
              ~manifest:_5
              ~priv:_4
              ~loc:(symbol_rloc()))) )
(*# 10359 "parsing/parser.ml"*)
               : 'with_constraint))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'type_parameters) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'label) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'core_type_no_attr) in
    Obj.repr(
(*# 1944 "parsing/parser.mly"*)
      ( Pwith_typesubst
          (Type.mk (mkrhs _3 3)
             ~params:_2
             ~manifest:_5
             ~loc:(symbol_rloc())) )
(*# 10372 "parsing/parser.ml"*)
               : 'with_constraint))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'mod_ext_longident) in
    Obj.repr(
(*# 1950 "parsing/parser.mly"*)
      ( Pwith_module (mkrhs _2 2, mkrhs _4 4) )
(*# 10380 "parsing/parser.ml"*)
               : 'with_constraint))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'mod_ext_longident) in
    Obj.repr(
(*# 1952 "parsing/parser.mly"*)
      ( Pwith_modsubst (mkrhs _2 2, mkrhs _4 4) )
(*# 10388 "parsing/parser.ml"*)
               : 'with_constraint))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 1955 "parsing/parser.mly"*)
                   ( Public )
(*# 10394 "parsing/parser.ml"*)
               : 'with_type_binder))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 1956 "parsing/parser.mly"*)
                   ( Private )
(*# 10400 "parsing/parser.ml"*)
               : 'with_type_binder))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
(*# 1962 "parsing/parser.mly"*)
                                                ( [_2] )
(*# 10407 "parsing/parser.ml"*)
               : 'typevar_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'typevar_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
(*# 1963 "parsing/parser.mly"*)
                                                ( _3 :: _1 )
(*# 10415 "parsing/parser.ml"*)
               : 'typevar_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
(*# 1967 "parsing/parser.mly"*)
          ( _1 )
(*# 10422 "parsing/parser.ml"*)
               : 'poly_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'typevar_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
(*# 1969 "parsing/parser.mly"*)
          ( mktyp(Ptyp_poly(List.rev _1, _3)) )
(*# 10430 "parsing/parser.ml"*)
               : 'poly_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'core_type_no_attr) in
    Obj.repr(
(*# 1973 "parsing/parser.mly"*)
          ( _1 )
(*# 10437 "parsing/parser.ml"*)
               : 'poly_type_no_attr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'typevar_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type_no_attr) in
    Obj.repr(
(*# 1975 "parsing/parser.mly"*)
          ( mktyp(Ptyp_poly(List.rev _1, _3)) )
(*# 10445 "parsing/parser.ml"*)
               : 'poly_type_no_attr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'core_type_no_attr) in
    Obj.repr(
(*# 1982 "parsing/parser.mly"*)
      ( _1 )
(*# 10452 "parsing/parser.ml"*)
               : 'core_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'core_type) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attribute) in
    Obj.repr(
(*# 1984 "parsing/parser.mly"*)
      ( Typ.attr _1 _2 )
(*# 10460 "parsing/parser.ml"*)
               : 'core_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'core_type2) in
    Obj.repr(
(*# 1988 "parsing/parser.mly"*)
      ( _1 )
(*# 10467 "parsing/parser.ml"*)
               : 'core_type_no_attr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'core_type2) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
(*# 1990 "parsing/parser.mly"*)
      ( mktyp(Ptyp_alias(_1, _4)) )
(*# 10475 "parsing/parser.ml"*)
               : 'core_type_no_attr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_core_type_or_tuple) in
    Obj.repr(
(*# 1994 "parsing/parser.mly"*)
      ( _1 )
(*# 10482 "parsing/parser.ml"*)
               : 'core_type2))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'core_type2) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'core_type2) in
    Obj.repr(
(*# 1996 "parsing/parser.mly"*)
      ( mktyp(Ptyp_arrow("?" ^ _2 , mkoption _4, _6)) )
(*# 10491 "parsing/parser.ml"*)
               : 'core_type2))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'core_type2) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'core_type2) in
    Obj.repr(
(*# 1998 "parsing/parser.mly"*)
      ( mktyp(Ptyp_arrow("?" ^ _1 , mkoption _2, _4)) )
(*# 10500 "parsing/parser.ml"*)
               : 'core_type2))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'core_type2) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'core_type2) in
    Obj.repr(
(*# 2000 "parsing/parser.mly"*)
      ( mktyp(Ptyp_arrow(_1, _3, _5)) )
(*# 10509 "parsing/parser.ml"*)
               : 'core_type2))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'core_type2) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type2) in
    Obj.repr(
(*# 2002 "parsing/parser.mly"*)
      ( mktyp(Ptyp_arrow("", _1, _3)) )
(*# 10517 "parsing/parser.ml"*)
               : 'core_type2))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_core_type2) in
    Obj.repr(
(*# 2007 "parsing/parser.mly"*)
      ( _1 )
(*# 10524 "parsing/parser.ml"*)
               : 'simple_core_type))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'core_type_comma_list) in
    Obj.repr(
(*# 2009 "parsing/parser.mly"*)
      ( match _2 with [sty] -> sty | _ -> raise Parse_error )
(*# 10531 "parsing/parser.ml"*)
               : 'simple_core_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_core_type2) in
    Obj.repr(
(*# 2014 "parsing/parser.mly"*)
      ( _1 )
(*# 10538 "parsing/parser.ml"*)
               : 'simple_core_type_no_attr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'core_type_comma_list) in
    Obj.repr(
(*# 2016 "parsing/parser.mly"*)
      ( match _2 with [sty] -> sty | _ -> raise Parse_error )
(*# 10545 "parsing/parser.ml"*)
               : 'simple_core_type_no_attr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
(*# 2021 "parsing/parser.mly"*)
      ( mktyp(Ptyp_var _2) )
(*# 10552 "parsing/parser.ml"*)
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2023 "parsing/parser.mly"*)
      ( mktyp(Ptyp_any) )
(*# 10558 "parsing/parser.ml"*)
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'type_longident) in
    Obj.repr(
(*# 2025 "parsing/parser.mly"*)
      ( mktyp(Ptyp_constr(mkrhs _1 1, [])) )
(*# 10565 "parsing/parser.ml"*)
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'simple_core_type2) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'type_longident) in
    Obj.repr(
(*# 2027 "parsing/parser.mly"*)
      ( mktyp(Ptyp_constr(mkrhs _2 2, [_1])) )
(*# 10573 "parsing/parser.ml"*)
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'core_type_comma_list) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'type_longident) in
    Obj.repr(
(*# 2029 "parsing/parser.mly"*)
      ( mktyp(Ptyp_constr(mkrhs _4 4, List.rev _2)) )
(*# 10581 "parsing/parser.ml"*)
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'meth_list) in
    Obj.repr(
(*# 2031 "parsing/parser.mly"*)
      ( let (f, c) = _2 in mktyp(Ptyp_object (f, c)) )
(*# 10588 "parsing/parser.ml"*)
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2033 "parsing/parser.mly"*)
      ( mktyp(Ptyp_object ([], Closed)) )
(*# 10594 "parsing/parser.ml"*)
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'class_longident) in
    Obj.repr(
(*# 2035 "parsing/parser.mly"*)
      ( mktyp(Ptyp_class(mkrhs _2 2, [])) )
(*# 10601 "parsing/parser.ml"*)
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'simple_core_type2) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'class_longident) in
    Obj.repr(
(*# 2037 "parsing/parser.mly"*)
      ( mktyp(Ptyp_class(mkrhs _3 3, [_1])) )
(*# 10609 "parsing/parser.ml"*)
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'core_type_comma_list) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'class_longident) in
    Obj.repr(
(*# 2039 "parsing/parser.mly"*)
      ( mktyp(Ptyp_class(mkrhs _5 5, List.rev _2)) )
(*# 10617 "parsing/parser.ml"*)
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'tag_field) in
    Obj.repr(
(*# 2041 "parsing/parser.mly"*)
      ( mktyp(Ptyp_variant([_2], Closed, None)) )
(*# 10624 "parsing/parser.ml"*)
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'row_field_list) in
    Obj.repr(
(*# 2047 "parsing/parser.mly"*)
      ( mktyp(Ptyp_variant(List.rev _3, Closed, None)) )
(*# 10631 "parsing/parser.ml"*)
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'row_field) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'row_field_list) in
    Obj.repr(
(*# 2049 "parsing/parser.mly"*)
      ( mktyp(Ptyp_variant(_2 :: List.rev _4, Closed, None)) )
(*# 10639 "parsing/parser.ml"*)
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'opt_bar) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'row_field_list) in
    Obj.repr(
(*# 2051 "parsing/parser.mly"*)
      ( mktyp(Ptyp_variant(List.rev _3, Open, None)) )
(*# 10647 "parsing/parser.ml"*)
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2053 "parsing/parser.mly"*)
      ( mktyp(Ptyp_variant([], Open, None)) )
(*# 10653 "parsing/parser.ml"*)
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'opt_bar) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'row_field_list) in
    Obj.repr(
(*# 2055 "parsing/parser.mly"*)
      ( mktyp(Ptyp_variant(List.rev _3, Closed, Some [])) )
(*# 10661 "parsing/parser.ml"*)
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'opt_bar) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'row_field_list) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'name_tag_list) in
    Obj.repr(
(*# 2057 "parsing/parser.mly"*)
      ( mktyp(Ptyp_variant(List.rev _3, Closed, Some (List.rev _5))) )
(*# 10670 "parsing/parser.ml"*)
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'package_type) in
    Obj.repr(
(*# 2059 "parsing/parser.mly"*)
      ( mktyp(Ptyp_package _3) )
(*# 10677 "parsing/parser.ml"*)
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'extension) in
    Obj.repr(
(*# 2061 "parsing/parser.mly"*)
      ( mktyp (Ptyp_extension _1) )
(*# 10684 "parsing/parser.ml"*)
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'mty_longident) in
    Obj.repr(
(*# 2064 "parsing/parser.mly"*)
                  ( (mkrhs _1 1, []) )
(*# 10691 "parsing/parser.ml"*)
               : 'package_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'mty_longident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'package_type_cstrs) in
    Obj.repr(
(*# 2065 "parsing/parser.mly"*)
                                          ( (mkrhs _1 1, _3) )
(*# 10699 "parsing/parser.ml"*)
               : 'package_type))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'label_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
(*# 2068 "parsing/parser.mly"*)
                                         ( (mkrhs _2 2, _4) )
(*# 10707 "parsing/parser.ml"*)
               : 'package_type_cstr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'package_type_cstr) in
    Obj.repr(
(*# 2071 "parsing/parser.mly"*)
                      ( [_1] )
(*# 10714 "parsing/parser.ml"*)
               : 'package_type_cstrs))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'package_type_cstr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'package_type_cstrs) in
    Obj.repr(
(*# 2072 "parsing/parser.mly"*)
                                             ( _1::_3 )
(*# 10722 "parsing/parser.ml"*)
               : 'package_type_cstrs))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'row_field) in
    Obj.repr(
(*# 2075 "parsing/parser.mly"*)
                                                ( [_1] )
(*# 10729 "parsing/parser.ml"*)
               : 'row_field_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'row_field_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'row_field) in
    Obj.repr(
(*# 2076 "parsing/parser.mly"*)
                                                ( _3 :: _1 )
(*# 10737 "parsing/parser.ml"*)
               : 'row_field_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'tag_field) in
    Obj.repr(
(*# 2079 "parsing/parser.mly"*)
                                                ( _1 )
(*# 10744 "parsing/parser.ml"*)
               : 'row_field))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_core_type) in
    Obj.repr(
(*# 2080 "parsing/parser.mly"*)
                                                ( Rinherit _1 )
(*# 10751 "parsing/parser.ml"*)
               : 'row_field))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'name_tag) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'opt_ampersand) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'amper_type_list) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
(*# 2084 "parsing/parser.mly"*)
      ( Rtag (_1, _5, _3, List.rev _4) )
(*# 10761 "parsing/parser.ml"*)
               : 'tag_field))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'name_tag) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
(*# 2086 "parsing/parser.mly"*)
      ( Rtag (_1, _2, true, []) )
(*# 10769 "parsing/parser.ml"*)
               : 'tag_field))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2089 "parsing/parser.mly"*)
                                                ( true )
(*# 10775 "parsing/parser.ml"*)
               : 'opt_ampersand))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2090 "parsing/parser.mly"*)
                                                ( false )
(*# 10781 "parsing/parser.ml"*)
               : 'opt_ampersand))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'core_type_no_attr) in
    Obj.repr(
(*# 2093 "parsing/parser.mly"*)
                                                ( [_1] )
(*# 10788 "parsing/parser.ml"*)
               : 'amper_type_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'amper_type_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type_no_attr) in
    Obj.repr(
(*# 2094 "parsing/parser.mly"*)
                                                ( _3 :: _1 )
(*# 10796 "parsing/parser.ml"*)
               : 'amper_type_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'name_tag) in
    Obj.repr(
(*# 2097 "parsing/parser.mly"*)
                                                ( [_1] )
(*# 10803 "parsing/parser.ml"*)
               : 'name_tag_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'name_tag_list) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'name_tag) in
    Obj.repr(
(*# 2098 "parsing/parser.mly"*)
                                                ( _2 :: _1 )
(*# 10811 "parsing/parser.ml"*)
               : 'name_tag_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_core_type) in
    Obj.repr(
(*# 2101 "parsing/parser.mly"*)
                                             ( _1 )
(*# 10818 "parsing/parser.ml"*)
               : 'simple_core_type_or_tuple))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'simple_core_type) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type_list) in
    Obj.repr(
(*# 2103 "parsing/parser.mly"*)
      ( mktyp(Ptyp_tuple(_1 :: List.rev _3)) )
(*# 10826 "parsing/parser.ml"*)
               : 'simple_core_type_or_tuple))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_core_type_no_attr) in
    Obj.repr(
(*# 2107 "parsing/parser.mly"*)
      ( _1 )
(*# 10833 "parsing/parser.ml"*)
               : 'simple_core_type_or_tuple_no_attr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'simple_core_type_no_attr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type_list_no_attr) in
    Obj.repr(
(*# 2109 "parsing/parser.mly"*)
      ( mktyp(Ptyp_tuple(_1 :: List.rev _3)) )
(*# 10841 "parsing/parser.ml"*)
               : 'simple_core_type_or_tuple_no_attr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
(*# 2112 "parsing/parser.mly"*)
                                                ( [_1] )
(*# 10848 "parsing/parser.ml"*)
               : 'core_type_comma_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'core_type_comma_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
(*# 2113 "parsing/parser.mly"*)
                                                ( _3 :: _1 )
(*# 10856 "parsing/parser.ml"*)
               : 'core_type_comma_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_core_type) in
    Obj.repr(
(*# 2116 "parsing/parser.mly"*)
                                             ( [_1] )
(*# 10863 "parsing/parser.ml"*)
               : 'core_type_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'core_type_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'simple_core_type) in
    Obj.repr(
(*# 2117 "parsing/parser.mly"*)
                                                ( _3 :: _1 )
(*# 10871 "parsing/parser.ml"*)
               : 'core_type_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_core_type_no_attr) in
    Obj.repr(
(*# 2120 "parsing/parser.mly"*)
                                                 ( [_1] )
(*# 10878 "parsing/parser.ml"*)
               : 'core_type_list_no_attr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'core_type_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'simple_core_type_no_attr) in
    Obj.repr(
(*# 2121 "parsing/parser.mly"*)
                                                 ( _3 :: _1 )
(*# 10886 "parsing/parser.ml"*)
               : 'core_type_list_no_attr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'field) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'meth_list) in
    Obj.repr(
(*# 2124 "parsing/parser.mly"*)
                                             ( let (f, c) = _3 in (_1 :: f, c) )
(*# 10894 "parsing/parser.ml"*)
               : 'meth_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'field) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'opt_semi) in
    Obj.repr(
(*# 2125 "parsing/parser.mly"*)
                                                ( [_1], Closed )
(*# 10902 "parsing/parser.ml"*)
               : 'meth_list))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2126 "parsing/parser.mly"*)
                                                ( [], Open )
(*# 10908 "parsing/parser.ml"*)
               : 'meth_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'label) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'poly_type_no_attr) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
(*# 2129 "parsing/parser.mly"*)
                                                ( (_1, _4, _3) )
(*# 10917 "parsing/parser.ml"*)
               : 'field))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
(*# 2132 "parsing/parser.mly"*)
                                                ( _1 )
(*# 10924 "parsing/parser.ml"*)
               : 'label))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in
    Obj.repr(
(*# 2138 "parsing/parser.mly"*)
                                      ( Const_int _1 )
(*# 10931 "parsing/parser.ml"*)
               : 'constant))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : char) in
    Obj.repr(
(*# 2139 "parsing/parser.mly"*)
                                      ( Const_char _1 )
(*# 10938 "parsing/parser.ml"*)
               : 'constant))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string * string option) in
    Obj.repr(
(*# 2140 "parsing/parser.mly"*)
                                      ( let (s, d) = _1 in Const_string (s, d) )
(*# 10945 "parsing/parser.ml"*)
               : 'constant))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
(*# 2141 "parsing/parser.mly"*)
                                      ( Const_float _1 )
(*# 10952 "parsing/parser.ml"*)
               : 'constant))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : int32) in
    Obj.repr(
(*# 2142 "parsing/parser.mly"*)
                                      ( Const_int32 _1 )
(*# 10959 "parsing/parser.ml"*)
               : 'constant))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : int64) in
    Obj.repr(
(*# 2143 "parsing/parser.mly"*)
                                      ( Const_int64 _1 )
(*# 10966 "parsing/parser.ml"*)
               : 'constant))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : nativeint) in
    Obj.repr(
(*# 2144 "parsing/parser.mly"*)
                                      ( Const_nativeint _1 )
(*# 10973 "parsing/parser.ml"*)
               : 'constant))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'constant) in
    Obj.repr(
(*# 2147 "parsing/parser.mly"*)
                                           ( _1 )
(*# 10980 "parsing/parser.ml"*)
               : 'signed_constant))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : int) in
    Obj.repr(
(*# 2148 "parsing/parser.mly"*)
                                           ( Const_int(- _2) )
(*# 10987 "parsing/parser.ml"*)
               : 'signed_constant))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
(*# 2149 "parsing/parser.mly"*)
                                           ( Const_float("-" ^ _2) )
(*# 10994 "parsing/parser.ml"*)
               : 'signed_constant))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : int32) in
    Obj.repr(
(*# 2150 "parsing/parser.mly"*)
                                           ( Const_int32(Int32.neg _2) )
(*# 11001 "parsing/parser.ml"*)
               : 'signed_constant))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : int64) in
    Obj.repr(
(*# 2151 "parsing/parser.mly"*)
                                           ( Const_int64(Int64.neg _2) )
(*# 11008 "parsing/parser.ml"*)
               : 'signed_constant))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : nativeint) in
    Obj.repr(
(*# 2152 "parsing/parser.mly"*)
                                           ( Const_nativeint(Nativeint.neg _2) )
(*# 11015 "parsing/parser.ml"*)
               : 'signed_constant))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : int) in
    Obj.repr(
(*# 2153 "parsing/parser.mly"*)
                                           ( Const_int _2 )
(*# 11022 "parsing/parser.ml"*)
               : 'signed_constant))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
(*# 2154 "parsing/parser.mly"*)
                                           ( Const_float _2 )
(*# 11029 "parsing/parser.ml"*)
               : 'signed_constant))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : int32) in
    Obj.repr(
(*# 2155 "parsing/parser.mly"*)
                                           ( Const_int32 _2 )
(*# 11036 "parsing/parser.ml"*)
               : 'signed_constant))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : int64) in
    Obj.repr(
(*# 2156 "parsing/parser.mly"*)
                                           ( Const_int64 _2 )
(*# 11043 "parsing/parser.ml"*)
               : 'signed_constant))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : nativeint) in
    Obj.repr(
(*# 2157 "parsing/parser.mly"*)
                                           ( Const_nativeint _2 )
(*# 11050 "parsing/parser.ml"*)
               : 'signed_constant))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
(*# 2163 "parsing/parser.mly"*)
                                                ( _1 )
(*# 11057 "parsing/parser.ml"*)
               : 'ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
(*# 2164 "parsing/parser.mly"*)
                                                ( _1 )
(*# 11064 "parsing/parser.ml"*)
               : 'ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
(*# 2167 "parsing/parser.mly"*)
                                                ( _1 )
(*# 11071 "parsing/parser.ml"*)
               : 'val_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'operator) in
    Obj.repr(
(*# 2168 "parsing/parser.mly"*)
                                                ( _2 )
(*# 11078 "parsing/parser.ml"*)
               : 'val_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'operator) in
    Obj.repr(
(*# 2169 "parsing/parser.mly"*)
                                                ( unclosed "(" 1 ")" 3 )
(*# 11085 "parsing/parser.ml"*)
               : 'val_ident))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2170 "parsing/parser.mly"*)
                                                ( expecting 2 "operator" )
(*# 11091 "parsing/parser.ml"*)
               : 'val_ident))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2171 "parsing/parser.mly"*)
                                                ( expecting 3 "module-expr" )
(*# 11097 "parsing/parser.ml"*)
               : 'val_ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
(*# 2174 "parsing/parser.mly"*)
                                                ( _1 )
(*# 11104 "parsing/parser.ml"*)
               : 'operator))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
(*# 2175 "parsing/parser.mly"*)
                                                ( _1 )
(*# 11111 "parsing/parser.ml"*)
               : 'operator))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
(*# 2176 "parsing/parser.mly"*)
                                                ( _1 )
(*# 11118 "parsing/parser.ml"*)
               : 'operator))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
(*# 2177 "parsing/parser.mly"*)
                                                ( _1 )
(*# 11125 "parsing/parser.ml"*)
               : 'operator))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
(*# 2178 "parsing/parser.mly"*)
                                                ( _1 )
(*# 11132 "parsing/parser.ml"*)
               : 'operator))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
(*# 2179 "parsing/parser.mly"*)
                                                ( _1 )
(*# 11139 "parsing/parser.ml"*)
               : 'operator))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
(*# 2180 "parsing/parser.mly"*)
                                                ( _1 )
(*# 11146 "parsing/parser.ml"*)
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2181 "parsing/parser.mly"*)
                                                ( "!" )
(*# 11152 "parsing/parser.ml"*)
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2182 "parsing/parser.mly"*)
                                                ( "+" )
(*# 11158 "parsing/parser.ml"*)
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2183 "parsing/parser.mly"*)
                                                ( "+." )
(*# 11164 "parsing/parser.ml"*)
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2184 "parsing/parser.mly"*)
                                                ( "-" )
(*# 11170 "parsing/parser.ml"*)
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2185 "parsing/parser.mly"*)
                                                ( "-." )
(*# 11176 "parsing/parser.ml"*)
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2186 "parsing/parser.mly"*)
                                                ( "*" )
(*# 11182 "parsing/parser.ml"*)
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2187 "parsing/parser.mly"*)
                                                ( "=" )
(*# 11188 "parsing/parser.ml"*)
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2188 "parsing/parser.mly"*)
                                                ( "<" )
(*# 11194 "parsing/parser.ml"*)
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2189 "parsing/parser.mly"*)
                                                ( ">" )
(*# 11200 "parsing/parser.ml"*)
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2190 "parsing/parser.mly"*)
                                                ( "or" )
(*# 11206 "parsing/parser.ml"*)
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2191 "parsing/parser.mly"*)
                                                ( "||" )
(*# 11212 "parsing/parser.ml"*)
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2192 "parsing/parser.mly"*)
                                                ( "&" )
(*# 11218 "parsing/parser.ml"*)
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2193 "parsing/parser.mly"*)
                                                ( "&&" )
(*# 11224 "parsing/parser.ml"*)
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2194 "parsing/parser.mly"*)
                                                ( ":=" )
(*# 11230 "parsing/parser.ml"*)
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2195 "parsing/parser.mly"*)
                                                ( "+=" )
(*# 11236 "parsing/parser.ml"*)
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2196 "parsing/parser.mly"*)
                                                ( "%" )
(*# 11242 "parsing/parser.ml"*)
               : 'operator))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
(*# 2199 "parsing/parser.mly"*)
                                                ( _1 )
(*# 11249 "parsing/parser.ml"*)
               : 'constr_ident))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2201 "parsing/parser.mly"*)
                                                ( "()" )
(*# 11255 "parsing/parser.ml"*)
               : 'constr_ident))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2202 "parsing/parser.mly"*)
                                                ( "::" )
(*# 11261 "parsing/parser.ml"*)
               : 'constr_ident))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2204 "parsing/parser.mly"*)
                                                ( "false" )
(*# 11267 "parsing/parser.ml"*)
               : 'constr_ident))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2205 "parsing/parser.mly"*)
                                                ( "true" )
(*# 11273 "parsing/parser.ml"*)
               : 'constr_ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'val_ident) in
    Obj.repr(
(*# 2209 "parsing/parser.mly"*)
                                                ( Lident _1 )
(*# 11280 "parsing/parser.ml"*)
               : 'val_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'mod_longident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'val_ident) in
    Obj.repr(
(*# 2210 "parsing/parser.mly"*)
                                                ( Ldot(_1, _3) )
(*# 11288 "parsing/parser.ml"*)
               : 'val_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'mod_longident) in
    Obj.repr(
(*# 2213 "parsing/parser.mly"*)
                                                ( _1 )
(*# 11295 "parsing/parser.ml"*)
               : 'constr_longident))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2214 "parsing/parser.mly"*)
                                                ( Lident "[]" )
(*# 11301 "parsing/parser.ml"*)
               : 'constr_longident))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2215 "parsing/parser.mly"*)
                                                ( Lident "()" )
(*# 11307 "parsing/parser.ml"*)
               : 'constr_longident))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2216 "parsing/parser.mly"*)
                                                ( Lident "false" )
(*# 11313 "parsing/parser.ml"*)
               : 'constr_longident))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2217 "parsing/parser.mly"*)
                                                ( Lident "true" )
(*# 11319 "parsing/parser.ml"*)
               : 'constr_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
(*# 2220 "parsing/parser.mly"*)
                                                ( Lident _1 )
(*# 11326 "parsing/parser.ml"*)
               : 'label_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'mod_longident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
(*# 2221 "parsing/parser.mly"*)
                                                ( Ldot(_1, _3) )
(*# 11334 "parsing/parser.ml"*)
               : 'label_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
(*# 2224 "parsing/parser.mly"*)
                                                ( Lident _1 )
(*# 11341 "parsing/parser.ml"*)
               : 'type_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'mod_ext_longident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
(*# 2225 "parsing/parser.mly"*)
                                                ( Ldot(_1, _3) )
(*# 11349 "parsing/parser.ml"*)
               : 'type_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
(*# 2228 "parsing/parser.mly"*)
                                                ( Lident _1 )
(*# 11356 "parsing/parser.ml"*)
               : 'mod_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'mod_longident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
(*# 2229 "parsing/parser.mly"*)
                                                ( Ldot(_1, _3) )
(*# 11364 "parsing/parser.ml"*)
               : 'mod_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
(*# 2232 "parsing/parser.mly"*)
                                                ( Lident _1 )
(*# 11371 "parsing/parser.ml"*)
               : 'mod_ext_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'mod_ext_longident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
(*# 2233 "parsing/parser.mly"*)
                                                ( Ldot(_1, _3) )
(*# 11379 "parsing/parser.ml"*)
               : 'mod_ext_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'mod_ext_longident) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'mod_ext_longident) in
    Obj.repr(
(*# 2234 "parsing/parser.mly"*)
                                                      ( lapply _1 _3 )
(*# 11387 "parsing/parser.ml"*)
               : 'mod_ext_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
(*# 2237 "parsing/parser.mly"*)
                                                ( Lident _1 )
(*# 11394 "parsing/parser.ml"*)
               : 'mty_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'mod_ext_longident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
(*# 2238 "parsing/parser.mly"*)
                                                ( Ldot(_1, _3) )
(*# 11402 "parsing/parser.ml"*)
               : 'mty_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
(*# 2241 "parsing/parser.mly"*)
                                                ( Lident _1 )
(*# 11409 "parsing/parser.ml"*)
               : 'clty_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'mod_ext_longident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
(*# 2242 "parsing/parser.mly"*)
                                                ( Ldot(_1, _3) )
(*# 11417 "parsing/parser.ml"*)
               : 'clty_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
(*# 2245 "parsing/parser.mly"*)
                                                ( Lident _1 )
(*# 11424 "parsing/parser.ml"*)
               : 'class_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'mod_longident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
(*# 2246 "parsing/parser.mly"*)
                                                ( Ldot(_1, _3) )
(*# 11432 "parsing/parser.ml"*)
               : 'class_longident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
(*# 2252 "parsing/parser.mly"*)
                                ( Ptop_dir(_2, Pdir_none) )
(*# 11439 "parsing/parser.ml"*)
               : 'toplevel_directive))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'ident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : string * string option) in
    Obj.repr(
(*# 2253 "parsing/parser.mly"*)
                                ( Ptop_dir(_2, Pdir_string (fst _3)) )
(*# 11447 "parsing/parser.ml"*)
               : 'toplevel_directive))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'ident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : int) in
    Obj.repr(
(*# 2254 "parsing/parser.mly"*)
                                ( Ptop_dir(_2, Pdir_int _3) )
(*# 11455 "parsing/parser.ml"*)
               : 'toplevel_directive))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'ident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'val_longident) in
    Obj.repr(
(*# 2255 "parsing/parser.mly"*)
                                ( Ptop_dir(_2, Pdir_ident _3) )
(*# 11463 "parsing/parser.ml"*)
               : 'toplevel_directive))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'ident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'mod_longident) in
    Obj.repr(
(*# 2256 "parsing/parser.mly"*)
                                ( Ptop_dir(_2, Pdir_ident _3) )
(*# 11471 "parsing/parser.ml"*)
               : 'toplevel_directive))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'ident) in
    Obj.repr(
(*# 2257 "parsing/parser.mly"*)
                                ( Ptop_dir(_2, Pdir_bool false) )
(*# 11478 "parsing/parser.ml"*)
               : 'toplevel_directive))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'ident) in
    Obj.repr(
(*# 2258 "parsing/parser.mly"*)
                                ( Ptop_dir(_2, Pdir_bool true) )
(*# 11485 "parsing/parser.ml"*)
               : 'toplevel_directive))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
(*# 2264 "parsing/parser.mly"*)
                                                ( _2 )
(*# 11492 "parsing/parser.ml"*)
               : 'name_tag))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2267 "parsing/parser.mly"*)
                                                ( Nonrecursive )
(*# 11498 "parsing/parser.ml"*)
               : 'rec_flag))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2268 "parsing/parser.mly"*)
                                                ( Recursive )
(*# 11504 "parsing/parser.ml"*)
               : 'rec_flag))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2271 "parsing/parser.mly"*)
                                                ( Recursive )
(*# 11510 "parsing/parser.ml"*)
               : 'nonrec_flag))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2272 "parsing/parser.mly"*)
                                                ( Nonrecursive )
(*# 11516 "parsing/parser.ml"*)
               : 'nonrec_flag))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2275 "parsing/parser.mly"*)
                                                ( Upto )
(*# 11522 "parsing/parser.ml"*)
               : 'direction_flag))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2276 "parsing/parser.mly"*)
                                                ( Downto )
(*# 11528 "parsing/parser.ml"*)
               : 'direction_flag))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2279 "parsing/parser.mly"*)
                                                ( Public )
(*# 11534 "parsing/parser.ml"*)
               : 'private_flag))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2280 "parsing/parser.mly"*)
                                                ( Private )
(*# 11540 "parsing/parser.ml"*)
               : 'private_flag))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2283 "parsing/parser.mly"*)
                                                ( Immutable )
(*# 11546 "parsing/parser.ml"*)
               : 'mutable_flag))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2284 "parsing/parser.mly"*)
                                                ( Mutable )
(*# 11552 "parsing/parser.ml"*)
               : 'mutable_flag))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2287 "parsing/parser.mly"*)
                                                ( Concrete )
(*# 11558 "parsing/parser.ml"*)
               : 'virtual_flag))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2288 "parsing/parser.mly"*)
                                                ( Virtual )
(*# 11564 "parsing/parser.ml"*)
               : 'virtual_flag))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2291 "parsing/parser.mly"*)
                 ( Public, Concrete )
(*# 11570 "parsing/parser.ml"*)
               : 'private_virtual_flags))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2292 "parsing/parser.mly"*)
            ( Private, Concrete )
(*# 11576 "parsing/parser.ml"*)
               : 'private_virtual_flags))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2293 "parsing/parser.mly"*)
            ( Public, Virtual )
(*# 11582 "parsing/parser.ml"*)
               : 'private_virtual_flags))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2294 "parsing/parser.mly"*)
                    ( Private, Virtual )
(*# 11588 "parsing/parser.ml"*)
               : 'private_virtual_flags))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2295 "parsing/parser.mly"*)
                    ( Private, Virtual )
(*# 11594 "parsing/parser.ml"*)
               : 'private_virtual_flags))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2298 "parsing/parser.mly"*)
                                                ( Fresh )
(*# 11600 "parsing/parser.ml"*)
               : 'override_flag))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2299 "parsing/parser.mly"*)
                                                ( Override )
(*# 11606 "parsing/parser.ml"*)
               : 'override_flag))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2302 "parsing/parser.mly"*)
                                                ( () )
(*# 11612 "parsing/parser.ml"*)
               : 'opt_bar))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2303 "parsing/parser.mly"*)
                                                ( () )
(*# 11618 "parsing/parser.ml"*)
               : 'opt_bar))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2306 "parsing/parser.mly"*)
                                                ( () )
(*# 11624 "parsing/parser.ml"*)
               : 'opt_semi))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2307 "parsing/parser.mly"*)
                                                ( () )
(*# 11630 "parsing/parser.ml"*)
               : 'opt_semi))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2310 "parsing/parser.mly"*)
                                                ( "-" )
(*# 11636 "parsing/parser.ml"*)
               : 'subtractive))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2311 "parsing/parser.mly"*)
                                                ( "-." )
(*# 11642 "parsing/parser.ml"*)
               : 'subtractive))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2314 "parsing/parser.mly"*)
                                                ( "+" )
(*# 11648 "parsing/parser.ml"*)
               : 'additive))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2315 "parsing/parser.mly"*)
                                                ( "+." )
(*# 11654 "parsing/parser.ml"*)
               : 'additive))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
(*# 2321 "parsing/parser.mly"*)
           ( _1 )
(*# 11661 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
(*# 2322 "parsing/parser.mly"*)
           ( _1 )
(*# 11668 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2323 "parsing/parser.mly"*)
        ( "and" )
(*# 11674 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2324 "parsing/parser.mly"*)
       ( "as" )
(*# 11680 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2325 "parsing/parser.mly"*)
           ( "assert" )
(*# 11686 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2326 "parsing/parser.mly"*)
          ( "begin" )
(*# 11692 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2327 "parsing/parser.mly"*)
          ( "class" )
(*# 11698 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2328 "parsing/parser.mly"*)
               ( "constraint" )
(*# 11704 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2329 "parsing/parser.mly"*)
       ( "do" )
(*# 11710 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2330 "parsing/parser.mly"*)
         ( "done" )
(*# 11716 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2331 "parsing/parser.mly"*)
           ( "downto" )
(*# 11722 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2332 "parsing/parser.mly"*)
         ( "else" )
(*# 11728 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2333 "parsing/parser.mly"*)
        ( "end" )
(*# 11734 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2334 "parsing/parser.mly"*)
              ( "exception" )
(*# 11740 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2335 "parsing/parser.mly"*)
             ( "external" )
(*# 11746 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2336 "parsing/parser.mly"*)
          ( "false" )
(*# 11752 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2337 "parsing/parser.mly"*)
        ( "for" )
(*# 11758 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2338 "parsing/parser.mly"*)
        ( "fun" )
(*# 11764 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2339 "parsing/parser.mly"*)
             ( "function" )
(*# 11770 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2340 "parsing/parser.mly"*)
            ( "functor" )
(*# 11776 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2341 "parsing/parser.mly"*)
       ( "if" )
(*# 11782 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2342 "parsing/parser.mly"*)
       ( "in" )
(*# 11788 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2343 "parsing/parser.mly"*)
            ( "include" )
(*# 11794 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2344 "parsing/parser.mly"*)
            ( "inherit" )
(*# 11800 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2345 "parsing/parser.mly"*)
                ( "initializer" )
(*# 11806 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2346 "parsing/parser.mly"*)
         ( "lazy" )
(*# 11812 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2347 "parsing/parser.mly"*)
        ( "let" )
(*# 11818 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2348 "parsing/parser.mly"*)
          ( "match" )
(*# 11824 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2349 "parsing/parser.mly"*)
           ( "method" )
(*# 11830 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2350 "parsing/parser.mly"*)
           ( "module" )
(*# 11836 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2351 "parsing/parser.mly"*)
            ( "mutable" )
(*# 11842 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2352 "parsing/parser.mly"*)
        ( "new" )
(*# 11848 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2353 "parsing/parser.mly"*)
           ( "object" )
(*# 11854 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2354 "parsing/parser.mly"*)
       ( "of" )
(*# 11860 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2355 "parsing/parser.mly"*)
         ( "open" )
(*# 11866 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2356 "parsing/parser.mly"*)
       ( "or" )
(*# 11872 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2357 "parsing/parser.mly"*)
            ( "private" )
(*# 11878 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2358 "parsing/parser.mly"*)
        ( "rec" )
(*# 11884 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2359 "parsing/parser.mly"*)
        ( "sig" )
(*# 11890 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2360 "parsing/parser.mly"*)
           ( "struct" )
(*# 11896 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2361 "parsing/parser.mly"*)
         ( "then" )
(*# 11902 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2362 "parsing/parser.mly"*)
       ( "to" )
(*# 11908 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2363 "parsing/parser.mly"*)
         ( "true" )
(*# 11914 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2364 "parsing/parser.mly"*)
        ( "try" )
(*# 11920 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2365 "parsing/parser.mly"*)
         ( "type" )
(*# 11926 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2366 "parsing/parser.mly"*)
        ( "val" )
(*# 11932 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2367 "parsing/parser.mly"*)
            ( "virtual" )
(*# 11938 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2368 "parsing/parser.mly"*)
         ( "when" )
(*# 11944 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2369 "parsing/parser.mly"*)
          ( "while" )
(*# 11950 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2370 "parsing/parser.mly"*)
         ( "with" )
(*# 11956 "parsing/parser.ml"*)
               : 'single_attr_id))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'single_attr_id) in
    Obj.repr(
(*# 2375 "parsing/parser.mly"*)
                   ( mkloc _1 (symbol_rloc()) )
(*# 11963 "parsing/parser.ml"*)
               : 'attr_id))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'single_attr_id) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'attr_id) in
    Obj.repr(
(*# 2376 "parsing/parser.mly"*)
                               ( mkloc (_1 ^ "." ^ _3.txt) (symbol_rloc()))
(*# 11971 "parsing/parser.ml"*)
               : 'attr_id))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'attr_id) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'payload) in
    Obj.repr(
(*# 2379 "parsing/parser.mly"*)
                                      ( (_2, _3) )
(*# 11979 "parsing/parser.ml"*)
               : 'attribute))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'attr_id) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'payload) in
    Obj.repr(
(*# 2382 "parsing/parser.mly"*)
                                        ( (_2, _3) )
(*# 11987 "parsing/parser.ml"*)
               : 'post_item_attribute))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'attr_id) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'payload) in
    Obj.repr(
(*# 2385 "parsing/parser.mly"*)
                                          ( (_2, _3) )
(*# 11995 "parsing/parser.ml"*)
               : 'floating_attribute))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2388 "parsing/parser.mly"*)
                 ( [] )
(*# 12001 "parsing/parser.ml"*)
               : 'post_item_attributes))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'post_item_attribute) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
(*# 2389 "parsing/parser.mly"*)
                                             ( _1 :: _2 )
(*# 12009 "parsing/parser.ml"*)
               : 'post_item_attributes))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2392 "parsing/parser.mly"*)
               ( [] )
(*# 12015 "parsing/parser.ml"*)
               : 'attributes))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'attribute) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
(*# 2393 "parsing/parser.mly"*)
                         ( _1 :: _2 )
(*# 12023 "parsing/parser.ml"*)
               : 'attributes))
; (fun __caml_parser_env ->
    Obj.repr(
(*# 2396 "parsing/parser.mly"*)
                 ( None, [] )
(*# 12029 "parsing/parser.ml"*)
               : 'ext_attributes))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'attribute) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
(*# 2397 "parsing/parser.mly"*)
                         ( None, _1 :: _2 )
(*# 12037 "parsing/parser.ml"*)
               : 'ext_attributes))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'attr_id) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
(*# 2398 "parsing/parser.mly"*)
                               ( Some _2, _3 )
(*# 12045 "parsing/parser.ml"*)
               : 'ext_attributes))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'attr_id) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'payload) in
    Obj.repr(
(*# 2401 "parsing/parser.mly"*)
                                           ( (_2, _3) )
(*# 12053 "parsing/parser.ml"*)
               : 'extension))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'attr_id) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'payload) in
    Obj.repr(
(*# 2404 "parsing/parser.mly"*)
                                                  ( (_2, _3) )
(*# 12061 "parsing/parser.ml"*)
               : 'item_extension))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'structure) in
    Obj.repr(
(*# 2407 "parsing/parser.mly"*)
              ( PStr _1 )
(*# 12068 "parsing/parser.ml"*)
               : 'payload))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
(*# 2408 "parsing/parser.mly"*)
                    ( PTyp _2 )
(*# 12075 "parsing/parser.ml"*)
               : 'payload))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
(*# 2409 "parsing/parser.mly"*)
                     ( PPat (_2, None) )
(*# 12082 "parsing/parser.ml"*)
               : 'payload))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
(*# 2410 "parsing/parser.mly"*)
                                   ( PPat (_2, Some _4) )
(*# 12090 "parsing/parser.ml"*)
               : 'payload))
(* Entry implementation *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
(* Entry interface *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
(* Entry toplevel_phrase *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
(* Entry use_file *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
(* Entry parse_core_type *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
(* Entry parse_expression *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
(* Entry parse_pattern *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
|]
let yytables =
  { Parsing.actions=yyact;
    Parsing.transl_const=yytransl_const;
    Parsing.transl_block=yytransl_block;
    Parsing.lhs=yylhs;
    Parsing.len=yylen;
    Parsing.defred=yydefred;
    Parsing.dgoto=yydgoto;
    Parsing.sindex=yysindex;
    Parsing.rindex=yyrindex;
    Parsing.gindex=yygindex;
    Parsing.tablesize=yytablesize;
    Parsing.table=yytable;
    Parsing.check=yycheck;
    Parsing.error_function=parse_error;
    Parsing.names_const=yynames_const;
    Parsing.names_block=yynames_block }
let implementation (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 1 lexfun lexbuf : Parsetree.structure)
let interface (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 2 lexfun lexbuf : Parsetree.signature)
let toplevel_phrase (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 3 lexfun lexbuf : Parsetree.toplevel_phrase)
let use_file (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 4 lexfun lexbuf : Parsetree.toplevel_phrase list)
let parse_core_type (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 5 lexfun lexbuf : Parsetree.core_type)
let parse_expression (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 6 lexfun lexbuf : Parsetree.expression)
let parse_pattern (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 7 lexfun lexbuf : Parsetree.pattern)
;;

end
module Lexer : sig
(*#1 "lexer.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* The lexical analyzer *)

val init : unit -> unit
val token: Lexing.lexbuf -> Parser.token
val skip_sharp_bang: Lexing.lexbuf -> unit

type directive_type

(* type directive_value = *)
(*   | Dir_bool of bool  *)
(*   | Dir_float of float *)
(*   | Dir_int of int *)
(*   | Dir_string of string *)
(*   | Dir_null *)

type error =
  | Illegal_character of char
  | Illegal_escape of string
  | Unterminated_comment of Location.t
  | Unterminated_string
  | Unterminated_string_in_comment of Location.t * Location.t
  | Keyword_as_label of string
  | Literal_overflow of string
  | Unterminated_paren_in_conditional
  | Unterminated_if
  | Unterminated_else
  | Unexpected_token_in_conditional
  | Expect_hash_then_in_conditional
  | Illegal_semver of string
  | Unexpected_directive
  | Conditional_expr_expected_type of directive_type * directive_type
;;

exception Error of error * Location.t

open Format

val report_error: formatter -> error -> unit
 (* Deprecated.  Use Location.{error_of_exn, report_error}. *)

val in_comment : unit -> bool;;
val in_string : unit -> bool;;


val print_warnings : bool ref
val comments : unit -> (string * Location.t) list
val token_with_comments : Lexing.lexbuf -> Parser.token

(*
  [set_preprocessor init preprocessor] registers [init] as the function
to call to initialize the preprocessor when the lexer is initialized,
and [preprocessor] a function that is called when a new token is needed
by the parser, as [preprocessor lexer lexbuf] where [lexer] is the
lexing function.

When a preprocessor is configured by calling [set_preprocessor], the lexer
changes its behavior to accept backslash-newline as a token-separating blank.
*)

val set_preprocessor :
  (unit -> unit) ->
  ((Lexing.lexbuf -> Parser.token) -> Lexing.lexbuf -> Parser.token) ->
  unit


(* val replace_directive_built_in_value :  *)
(*   string ->  directive_value -> unit *)

(** Raises Not_found *)
(* val find_directive_built_in_value : *)
(*   string -> directive_value *)

(* val iter_directive_built_in_value :  *)
(*   (string -> directive_value -> unit) -> unit *)


(** semantic version predicate *)
val semver : Location.t ->   string -> string -> bool

val filter_directive_from_lexbuf : Lexing.lexbuf -> (int * int) list

val replace_directive_int : string -> int -> unit
val replace_directive_string : string -> string -> unit
val replace_directive_bool : string -> bool -> unit
val remove_directive_built_in_value : string -> unit

(** @return false means failed to define *)
val define_key_value : string -> string -> bool
val list_variables : Format.formatter -> unit

end = struct
(*#1 "lexer.ml"*)
(*# 15 "parsing/lexer.mll"*)

open Lexing
open Misc
open Parser

type directive_value =
  | Dir_bool of bool
  | Dir_float of float
  | Dir_int of int
  | Dir_string of string
  | Dir_null

type directive_type =
  | Dir_type_bool
  | Dir_type_float
  | Dir_type_int
  | Dir_type_string
  | Dir_type_null

let type_of_directive x =
  match x with
  | Dir_bool _ -> Dir_type_bool
  | Dir_float _ -> Dir_type_float
  | Dir_int _ -> Dir_type_int
  | Dir_string _ -> Dir_type_string
  | Dir_null -> Dir_type_null

let string_of_type_directive x =
  match x with
  | Dir_type_bool  -> "bool"
  | Dir_type_float  -> "float"
  | Dir_type_int  -> "int"
  | Dir_type_string  -> "string"
  | Dir_type_null -> "null"

type error =
  | Illegal_character of char
  | Illegal_escape of string
  | Unterminated_comment of Location.t
  | Unterminated_string
  | Unterminated_string_in_comment of Location.t * Location.t
  | Keyword_as_label of string
  | Literal_overflow of string
  | Unterminated_paren_in_conditional
  | Unterminated_if
  | Unterminated_else
  | Unexpected_token_in_conditional
  | Expect_hash_then_in_conditional
  | Illegal_semver of string
  | Unexpected_directive
  | Conditional_expr_expected_type of directive_type * directive_type

;;

exception Error of error * Location.t;;

let assert_same_type  lexbuf x y =
  let lhs = type_of_directive x in let rhs =  type_of_directive y  in
  if lhs <> rhs then
    raise (Error(Conditional_expr_expected_type(lhs,rhs), Location.curr lexbuf))
  else y

let directive_built_in_values  =
  Hashtbl.create 51


let replace_directive_built_in_value k v =
  Hashtbl.replace directive_built_in_values k v

let remove_directive_built_in_value k  =
  Hashtbl.replace directive_built_in_values k Dir_null

let replace_directive_int k v =
  Hashtbl.replace directive_built_in_values k (Dir_int v)

let replace_directive_bool k v =
  Hashtbl.replace directive_built_in_values k (Dir_bool v)

let replace_directive_string k v =
  Hashtbl.replace directive_built_in_values k (Dir_string v)

let () =
  (* Note we use {!Config} instead of {!Sys} becasue
     we want to overwrite in some cases with the
     same stdlib
  *)
  let version =

    Config.version (* so that it can be overridden*)

  in
  replace_directive_built_in_value "OCAML_VERSION"
    (Dir_string version);
  replace_directive_built_in_value "OCAML_PATCH"
    (Dir_string
       (match String.rindex version '+' with
       | exception Not_found -> ""
       | i ->
           String.sub version (i + 1)
             (String.length version - i - 1)))
  ;
  replace_directive_built_in_value "OS_TYPE"
    (Dir_string Sys.os_type);
  replace_directive_built_in_value "BIG_ENDIAN"
    (Dir_bool Sys.big_endian);
  replace_directive_built_in_value "WORD_SIZE"
    (Dir_int Sys.word_size)

let find_directive_built_in_value k =
  Hashtbl.find directive_built_in_values k

let iter_directive_built_in_value f = Hashtbl.iter f directive_built_in_values

(*
   {[
     # semver 0 "12";;
     - : int * int * int * string = (12, 0, 0, "");;
     # semver 0 "12.3";;
     - : int * int * int * string = (12, 3, 0, "");;
       semver 0 "12.3.10";;
     - : int * int * int * string = (12, 3, 10, "");;
     # semver 0 "12.3.10+x";;
     - : int * int * int * string = (12, 3, 10, "+x")
   ]}
*)
let zero = Char.code '0'
let dot = Char.code '.'
let semantic_version_parse str start  last_index =
  let rec aux start  acc last_index =
    if start <= last_index then
      let c = Char.code (String.unsafe_get str start) in
      if c = dot then (acc, start + 1) (* consume [4.] instead of [4]*)
      else
        let v =  c - zero in
        if v >=0 && v <= 9  then
          aux (start + 1) (acc * 10 + v) last_index
        else (acc , start)
    else (acc, start)
  in
  let major, major_end =  aux start 0 last_index  in
  let minor, minor_end = aux major_end 0 last_index in
  let patch, patch_end = aux minor_end 0 last_index in
  let additional = String.sub str patch_end (last_index - patch_end  +1) in
  (major, minor, patch), additional

(**
   {[
     semver Location.none "1.2.3" "~1.3.0" = false;;
     semver Location.none "1.2.3" "^1.3.0" = true ;;
     semver Location.none "1.2.3" ">1.3.0" = false ;;
     semver Location.none "1.2.3" ">=1.3.0" = false ;;
     semver Location.none "1.2.3" "<1.3.0" = true ;;
     semver Location.none "1.2.3" "<=1.3.0" = true ;;
   ]}
*)
let semver loc lhs str =
  let last_index = String.length str - 1 in
  if last_index < 0 then raise (Error(Illegal_semver str, loc))
  else
    let pred, ((major, minor,patch) as version, _) =
      let v = String.unsafe_get str 0 in
      match v with
      | '>' ->
          if last_index = 0 then raise (Error(Illegal_semver str, loc)) else
          if String.unsafe_get str 1 = '=' then
            `Ge, semantic_version_parse str 2 last_index
          else `Gt, semantic_version_parse str 1 last_index
      | '<'
        ->
          if last_index = 0 then raise (Error(Illegal_semver str, loc)) else
          if String.unsafe_get str 1 = '=' then
            `Le, semantic_version_parse str 2 last_index
          else `Lt, semantic_version_parse str 1 last_index
      | '^'
        -> `Compatible, semantic_version_parse str 1 last_index
      | '~' ->  `Approximate, semantic_version_parse str 1 last_index
      | _ -> `Exact, semantic_version_parse str 0 last_index
    in
    let ((l_major, l_minor, l_patch) as lversion,_) =
      semantic_version_parse lhs 0 (String.length lhs - 1) in
    match pred with
    | `Ge -> lversion >= version
    | `Gt -> lversion > version
    | `Le -> lversion <= version
    | `Lt -> lversion < version
    | `Approximate -> major = l_major && minor = l_minor
    |  `Compatible -> major = l_major
    | `Exact -> lversion = version


let pp_directive_value fmt (x : directive_value) =
  match x with
  | Dir_bool b -> Format.pp_print_bool fmt b
  | Dir_int b -> Format.pp_print_int fmt b
  | Dir_float b -> Format.pp_print_float fmt b
  | Dir_string s  -> Format.fprintf fmt "%S" s
  | Dir_null -> Format.pp_print_string fmt "null"

let list_variables fmt =
  iter_directive_built_in_value
    (fun s  dir_value ->
       Format.fprintf
         fmt "@[%s@ %a@]@."
         s pp_directive_value dir_value
    )

let defined str =
  begin match  find_directive_built_in_value str with
  |  Dir_null -> false
  | _ ->  true
  | exception _ ->
      try ignore @@ Sys.getenv str; true with _ ->  false
  end

let query loc str =
  begin match find_directive_built_in_value str with
  | Dir_null -> Dir_bool false
  | v -> v
  | exception Not_found ->
      begin match Sys.getenv str with
      | v ->
          begin
            try Dir_bool (bool_of_string v) with
              _ ->
                begin
                  try Dir_int (int_of_string v )
                  with
                    _ ->
                      begin try (Dir_float (float_of_string v))
                      with _ -> Dir_string v
                      end
                end
          end
      | exception Not_found ->
          Dir_bool false
      end
  end


let define_key_value key v  =
  if String.length key > 0
      && Char.uppercase_ascii (key.[0]) = key.[0] then
    begin
      replace_directive_built_in_value key
      begin
        (* NEED Sync up across {!lexer.mll} {!bspp.ml} and here,
           TODO: put it in {!lexer.mll}
        *)
        try Dir_bool (bool_of_string v) with
          _ ->
          begin
            try Dir_int (int_of_string v )
            with
              _ ->
              begin try (Dir_float (float_of_string v))
                with _ -> Dir_string v
              end
          end
      end;
    true
    end
  else false


let value_of_token loc (t : Parser.token)  =
  match t with
  | INT i -> Dir_int i
  | STRING (s,_) -> Dir_string s
  | FLOAT s  -> Dir_float (float_of_string s)
  | TRUE -> Dir_bool true
  | FALSE -> Dir_bool false
  | UIDENT s -> query loc s
  | _ -> raise (Error (Unexpected_token_in_conditional, loc))


let directive_parse token_with_comments lexbuf =
  let look_ahead = ref None in
  let token () : Parser.token =
    let v = !look_ahead in
    match v with
    | Some v ->
        look_ahead := None ;
        v
    | None ->
       let rec skip () =
        match token_with_comments lexbuf  with
        | COMMENT _ -> skip ()

        | DOCSTRING _ -> skip ()

        | EOL -> skip ()
        | EOF -> raise (Error (Unterminated_if, Location.curr lexbuf))
        | t -> t
        in  skip ()
  in
  let push e =
    (* INVARIANT: only look at most one token *)
    assert (!look_ahead = None);
    look_ahead := Some e
  in
  let rec
    token_op calc   ~no  lhs   =
    match token () with
    | (LESS
    | GREATER
    | INFIXOP0 "<="
    | INFIXOP0 ">="
    | EQUAL
    | INFIXOP0 "<>" as op) ->
        let f =
          match op with
          | LESS -> (<)
          | GREATER -> (>)
          | INFIXOP0 "<=" -> (<=)
          | EQUAL -> (=)
          | INFIXOP0 "<>" -> (<>)
          | _ -> assert false
        in
        let curr_loc = Location.curr lexbuf in
        let rhs = value_of_token curr_loc (token ()) in
        not calc ||
        f lhs (assert_same_type lexbuf lhs rhs)
    | INFIXOP0 "=~" ->
        not calc ||
        begin match lhs with
        | Dir_string s ->
            let curr_loc = Location.curr lexbuf in
            let rhs = value_of_token curr_loc (token ()) in
            begin match rhs with
            | Dir_string rhs ->
                semver curr_loc s rhs
            | _ ->
                raise
                  (Error
                     ( Conditional_expr_expected_type
                         (Dir_type_string, type_of_directive lhs), Location.curr lexbuf))
            end
        | _ -> raise
                 (Error
                    ( Conditional_expr_expected_type
                        (Dir_type_string, type_of_directive lhs), Location.curr lexbuf))
        end
    | e -> no e
  and
    parse_or calc : bool =
    parse_or_aux calc (parse_and calc)
  and  (* a || (b || (c || d))*)
    parse_or_aux calc v : bool =
    (* let l = v  in *)
    match token () with
    | BARBAR ->
        let b =   parse_or (calc && not v)  in
        v || b
    | e -> push e ; v
  and parse_and calc =
    parse_and_aux calc (parse_relation calc)
  and parse_and_aux calc v = (* a && (b && (c && d)) *)
    (* let l = v  in *)
    match token () with
    | AMPERAMPER ->
        let b =  parse_and (calc && v) in
        v && b
    | e -> push e ; v
  and parse_relation (calc : bool) : bool  =
    let curr_token = token () in
    let curr_loc = Location.curr lexbuf in
    match curr_token with
    | TRUE -> true
    | FALSE -> false
    | UIDENT v ->
        let value_v = query curr_loc v in
        token_op calc
          ~no:(fun e -> push e ;
                match value_v with
                | Dir_bool b -> b
                | _ ->
                    let ty = type_of_directive value_v in
                    raise
                      (Error(Conditional_expr_expected_type (Dir_type_bool, ty),
                             curr_loc)))
          value_v
    | INT v ->
        token_op calc
          ~no:(fun e ->
              raise(Error(Conditional_expr_expected_type(Dir_type_bool,Dir_type_int),
                          curr_loc)))
          (Dir_int v)
    | FLOAT v ->
        token_op calc
          ~no:(fun e ->
              raise (Error(Conditional_expr_expected_type(Dir_type_bool, Dir_type_float),
                           curr_loc)))
          (Dir_float (float_of_string v))
    | STRING (v,_) ->
        token_op calc
          ~no:(fun e ->
              raise (Error
                       (Conditional_expr_expected_type(Dir_type_bool, Dir_type_string),
                        curr_loc)))
          (Dir_string v)
    | LIDENT ("defined" | "undefined" as r) ->
        let t = token () in
        let loc = Location.curr lexbuf in
        begin match t with
        | UIDENT s ->
            not calc ||
            if r.[0] = 'u' then
              not @@ defined s
            else defined s
        | _ -> raise (Error (Unexpected_token_in_conditional, loc))
        end
    | LPAREN ->
        let v = parse_or calc in
        begin match token () with
        | RPAREN ->  v
        | _ -> raise (Error(Unterminated_paren_in_conditional, Location.curr lexbuf))
        end

    | _ -> raise (Error (Unexpected_token_in_conditional, curr_loc))
  in
  let v = parse_or true in
  begin match token () with
  | THEN ->  v
  | _ -> raise (Error (Expect_hash_then_in_conditional, Location.curr lexbuf))
  end


type dir_conditional =
  | Dir_if_true
  | Dir_if_false
  | Dir_out

let string_of_dir_conditional (x : dir_conditional) =
  match x with
  | Dir_if_true -> "Dir_if_true"
  | Dir_if_false -> "Dir_if_false"
  | Dir_out -> "Dir_out"

let is_elif (i : Parser.token ) =
  match i with
  | LIDENT "elif" -> true
  | _ -> false (* avoid polymorphic equal *)


(* The table of keywords *)

let keyword_table =
  create_hashtable 149 [
    "and", AND;
    "as", AS;
    "assert", ASSERT;
    "begin", BEGIN;
    "class", CLASS;
    "constraint", CONSTRAINT;
    "do", DO;
    "done", DONE;
    "downto", DOWNTO;
    "else", ELSE;
    "end", END;
    "exception", EXCEPTION;
    "external", EXTERNAL;
    "false", FALSE;
    "for", FOR;
    "fun", FUN;
    "function", FUNCTION;
    "functor", FUNCTOR;
    "if", IF;
    "in", IN;
    "include", INCLUDE;
    "inherit", INHERIT;
    "initializer", INITIALIZER;
    "lazy", LAZY;
    "let", LET;
    "match", MATCH;
    "method", METHOD;
    "module", MODULE;
    "mutable", MUTABLE;
    "new", NEW;
    "nonrec", NONREC;
    "object", OBJECT;
    "of", OF;
    "open", OPEN;
    "or", OR;
(*  "parser", PARSER; *)
    "private", PRIVATE;
    "rec", REC;
    "sig", SIG;
    "struct", STRUCT;
    "then", THEN;
    "to", TO;
    "true", TRUE;
    "try", TRY;
    "type", TYPE;
    "val", VAL;
    "virtual", VIRTUAL;
    "when", WHEN;
    "while", WHILE;
    "with", WITH;

    "mod", INFIXOP3("mod");
    "land", INFIXOP3("land");
    "lor", INFIXOP3("lor");
    "lxor", INFIXOP3("lxor");
    "lsl", INFIXOP4("lsl");
    "lsr", INFIXOP4("lsr");
    "asr", INFIXOP4("asr")
]

(* To buffer string literals *)

let initial_string_buffer = Bytes.create 256
let string_buff = ref initial_string_buffer
let string_index = ref 0

let reset_string_buffer () =
  string_buff := initial_string_buffer;
  string_index := 0

let store_string_char c =
  if !string_index >= Bytes.length !string_buff then begin
    let new_buff = Bytes.create (Bytes.length (!string_buff) * 2) in
    Bytes.blit !string_buff 0 new_buff 0 (Bytes.length !string_buff);
    string_buff := new_buff
  end;
  Bytes.unsafe_set !string_buff !string_index c;
  incr string_index

let store_string s =
  for i = 0 to String.length s - 1 do
    store_string_char s.[i];
  done

let store_lexeme lexbuf =
  store_string (Lexing.lexeme lexbuf)

let get_stored_string () =
  let s = Bytes.sub_string !string_buff 0 !string_index in
  string_buff := initial_string_buffer;
  s

(* To store the position of the beginning of a string and comment *)
let string_start_loc = ref Location.none;;
let comment_start_loc = ref [];;
let in_comment () = !comment_start_loc <> [];;
let is_in_string = ref false
let in_string () = !is_in_string
let print_warnings = ref true
let if_then_else = ref Dir_out
let sharp_look_ahead = ref None
let update_if_then_else v =
  (* Format.fprintf Format.err_formatter "@[update %s \n@]@." (string_of_dir_conditional v); *)
  if_then_else := v

let with_comment_buffer comment lexbuf =
  let start_loc = Location.curr lexbuf  in
  comment_start_loc := [start_loc];
  reset_string_buffer ();
  let end_loc = comment lexbuf in
  let s = get_stored_string () in
  reset_string_buffer ();
  let loc = { start_loc with Location.loc_end = end_loc.Location.loc_end } in
  s, loc

(* To translate escape sequences *)

let char_for_backslash = function
  | 'n' -> '\010'
  | 'r' -> '\013'
  | 'b' -> '\008'
  | 't' -> '\009'
  | c   -> c

let char_for_decimal_code lexbuf i =
  let c = 100 * (Char.code(Lexing.lexeme_char lexbuf i) - 48) +
           10 * (Char.code(Lexing.lexeme_char lexbuf (i+1)) - 48) +
                (Char.code(Lexing.lexeme_char lexbuf (i+2)) - 48) in
  if (c < 0 || c > 255) then
    if in_comment ()
    then 'x'
    else raise (Error(Illegal_escape (Lexing.lexeme lexbuf),
                      Location.curr lexbuf))
  else Char.chr c

let char_for_hexadecimal_code lexbuf i =
  let d1 = Char.code (Lexing.lexeme_char lexbuf i) in
  let val1 = if d1 >= 97 then d1 - 87
             else if d1 >= 65 then d1 - 55
             else d1 - 48
  in
  let d2 = Char.code (Lexing.lexeme_char lexbuf (i+1)) in
  let val2 = if d2 >= 97 then d2 - 87
             else if d2 >= 65 then d2 - 55
             else d2 - 48
  in
  Char.chr (val1 * 16 + val2)

(* To convert integer literals, allowing max_int + 1 (PR#4210) *)

let cvt_int_literal s =
  - int_of_string ("-" ^ s)
let cvt_int32_literal s =
  Int32.neg (Int32.of_string ("-" ^ String.sub s 0 (String.length s - 1)))
let cvt_int64_literal s =
  Int64.neg (Int64.of_string ("-" ^ String.sub s 0 (String.length s - 1)))
let cvt_nativeint_literal s = assert false
  (* Nativeint.neg (Nativeint.of_string ("-" ^ String.sub s 0
                                                       (String.length s - 1))) *)

(* Remove underscores from float literals *)

let remove_underscores s =
  let l = String.length s in
  let b = Bytes.create l in
  let rec remove src dst =
    if src >= l then
      if dst >= l then s else Bytes.sub_string b 0 dst
    else
      match s.[src] with
        '_' -> remove (src + 1) dst
      |  c  -> Bytes.set b dst c; remove (src + 1) (dst + 1)
  in remove 0 0

(* recover the name from a LABEL or OPTLABEL token *)

let get_label_name lexbuf =
  let s = Lexing.lexeme lexbuf in
  let name = String.sub s 1 (String.length s - 2) in
  if Hashtbl.mem keyword_table name then
    raise (Error(Keyword_as_label name, Location.curr lexbuf));
  name
;;

(* Update the current location with file name and line number. *)

let update_loc lexbuf file line absolute chars =
  let pos = lexbuf.lex_curr_p in
  let new_file = match file with
                 | None -> pos.pos_fname
                 | Some s -> s
  in
  lexbuf.lex_curr_p <- { pos with
    pos_fname = new_file;
    pos_lnum = if absolute then line else pos.pos_lnum + line;
    pos_bol = pos.pos_cnum - chars;
  }
;;

let preprocessor = ref None

let escaped_newlines = ref false

(* Warn about Latin-1 characters used in idents *)

let warn_latin1 lexbuf =
  Location.prerr_warning (Location.curr lexbuf)
    (Warnings.Deprecated "ISO-Latin1 characters in identifiers")
;;

let comment_list = ref []

let add_comment com =
  comment_list := com :: !comment_list

let add_docstring_comment ds =

  let com = (Docstrings.docstring_body ds, Docstrings.docstring_loc ds) in
    add_comment com


let comments () = List.rev !comment_list

(* Error report *)

open Format

let report_error ppf = function
  | Illegal_character c ->
      fprintf ppf "Illegal character (%s)" (Char.escaped c)
  | Illegal_escape s ->
      fprintf ppf "Illegal backslash escape in string or character (%s)" s
  | Unterminated_comment _ ->
      fprintf ppf "Comment not terminated"
  | Unterminated_string ->
      fprintf ppf "String literal not terminated"
  | Unterminated_string_in_comment (_, loc) ->
      fprintf ppf "This comment contains an unterminated string literal@.\
                   %aString literal begins here"
              Location.print_error loc
  | Keyword_as_label kwd ->
      fprintf ppf "`%s' is a keyword, it cannot be used as label name" kwd
  | Literal_overflow ty ->
      fprintf ppf "Integer literal exceeds the range of representable \
                   integers of type %s" ty
  | Unterminated_if ->
      fprintf ppf "#if not terminated"
  | Unterminated_else ->
      fprintf ppf "#else not terminated"
  | Unexpected_directive -> fprintf ppf "Unexpected directive"
  | Unexpected_token_in_conditional ->
      fprintf ppf "Unexpected token in conditional predicate"
  | Unterminated_paren_in_conditional ->
    fprintf ppf "Unterminated parens in conditional predicate"
  | Expect_hash_then_in_conditional ->
      fprintf ppf "Expect `then` after conditional predicate"
  | Conditional_expr_expected_type (a,b) ->
      fprintf ppf "Conditional expression type mismatch (%s,%s)"
        (string_of_type_directive a )
        (string_of_type_directive b )
  | Illegal_semver s ->
      fprintf ppf "Illegal semantic version string %s" s
let () =
  Location.register_error_of_exn
    (function
      | Error (err, loc) ->
          Some (Location.error_of_printer loc report_error err)
      | _ ->
          None
    )


(*# 727 "parsing/lexer.ml"*)
let __ocaml_lex_tables = {
  Lexing.lex_base =
   "\000\000\164\255\165\255\224\000\003\001\038\001\073\001\108\001\
    \143\001\188\255\178\001\215\001\196\255\091\000\252\001\031\002\
    \068\000\071\000\084\000\066\002\213\255\215\255\218\255\101\002\
    \196\002\231\002\089\000\255\000\005\003\236\255\082\003\115\003\
    \188\003\140\004\092\005\044\006\011\007\103\007\055\008\125\000\
    \254\255\001\000\005\000\255\255\006\000\007\000\022\009\052\009\
    \004\010\250\255\249\255\212\010\164\011\247\255\246\255\237\255\
    \238\255\239\255\093\000\118\002\091\000\110\000\231\002\007\004\
    \215\004\101\002\254\002\118\000\194\255\235\255\120\005\132\012\
    \096\000\113\000\011\000\234\255\233\255\229\255\229\004\128\000\
    \115\000\232\255\224\000\117\000\231\255\119\006\147\000\230\255\
    \146\000\225\255\148\000\224\255\217\000\132\012\223\255\171\012\
    \175\008\174\006\222\255\012\000\024\001\044\001\080\001\045\001\
    \222\255\013\000\217\012\000\013\035\013\073\013\210\255\206\255\
    \207\255\208\255\204\255\108\013\154\000\183\000\197\255\198\255\
    \199\255\199\000\182\255\184\255\191\255\143\013\187\255\189\255\
    \178\013\213\013\248\013\027\014\235\005\243\255\244\255\017\000\
    \245\255\062\002\172\007\253\255\223\000\241\000\255\255\254\255\
    \252\255\200\007\045\014\250\000\252\000\018\000\251\255\250\255\
    \249\255\128\009\030\003\003\001\248\255\092\003\004\001\247\255\
    \079\010\005\001\246\255\043\001\199\001\247\255\248\255\249\255\
    \059\001\118\014\255\255\250\255\031\011\036\004\253\255\038\001\
    \069\001\094\001\252\004\252\255\239\011\251\255\095\001\181\001\
    \252\255\238\006\254\255\255\255\111\001\112\001\253\255\074\007\
    \016\001\019\001\050\001\063\001\026\001\107\001\033\001\019\000\
    \255\255";
  Lexing.lex_backtrk =
   "\255\255\255\255\255\255\088\000\087\000\084\000\083\000\076\000\
    \074\000\255\255\065\000\062\000\255\255\055\000\054\000\052\000\
    \050\000\046\000\044\000\079\000\255\255\255\255\255\255\035\000\
    \034\000\041\000\039\000\038\000\060\000\255\255\014\000\014\000\
    \013\000\012\000\011\000\010\000\007\000\004\000\003\000\002\000\
    \255\255\091\000\091\000\255\255\255\255\255\255\082\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\015\000\255\255\255\255\255\255\014\000\
    \014\000\014\000\015\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\026\000\026\000\
    \026\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \027\000\255\255\028\000\255\255\029\000\086\000\255\255\089\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\036\000\085\000\080\000\043\000\255\255\255\255\
    \255\255\255\255\255\255\053\000\070\000\069\000\255\255\255\255\
    \255\255\072\000\255\255\255\255\255\255\063\000\255\255\255\255\
    \081\000\075\000\078\000\077\000\255\255\255\255\255\255\012\000\
    \255\255\012\000\012\000\255\255\012\000\012\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \008\000\008\000\255\255\255\255\005\000\005\000\255\255\001\000\
    \005\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\003\000\255\255\255\255\003\000\255\255\255\255\255\255\
    \002\000\255\255\255\255\001\000\255\255\255\255\255\255\255\255\
    \255\255";
  Lexing.lex_default =
   "\001\000\000\000\000\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\255\255\255\255\000\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\000\000\000\000\000\000\255\255\
    \255\255\255\255\255\255\072\000\255\255\000\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\255\255\255\255\000\000\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\255\255\255\255\000\000\000\000\000\000\
    \000\000\000\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\000\000\000\000\255\255\077\000\
    \255\255\255\255\255\255\000\000\000\000\000\000\255\255\255\255\
    \255\255\000\000\255\255\255\255\000\000\255\255\255\255\000\000\
    \255\255\000\000\255\255\000\000\255\255\255\255\000\000\255\255\
    \100\000\255\255\000\000\255\255\100\000\101\000\100\000\103\000\
    \000\000\255\255\255\255\255\255\255\255\255\255\000\000\000\000\
    \000\000\000\000\000\000\255\255\255\255\255\255\000\000\000\000\
    \000\000\255\255\000\000\000\000\000\000\255\255\000\000\000\000\
    \255\255\255\255\255\255\255\255\133\000\000\000\000\000\255\255\
    \000\000\147\000\255\255\000\000\255\255\255\255\000\000\000\000\
    \000\000\255\255\255\255\255\255\255\255\255\255\000\000\000\000\
    \000\000\255\255\255\255\255\255\000\000\255\255\255\255\000\000\
    \255\255\255\255\000\000\255\255\165\000\000\000\000\000\000\000\
    \255\255\171\000\000\000\000\000\255\255\255\255\000\000\255\255\
    \255\255\255\255\255\255\000\000\255\255\000\000\255\255\184\000\
    \000\000\255\255\000\000\000\000\255\255\255\255\000\000\255\255\
    \255\255\255\255\194\000\197\000\255\255\197\000\255\255\255\255\
    \000\000";
  Lexing.lex_trans =
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\039\000\040\000\040\000\039\000\041\000\045\000\043\000\
    \043\000\040\000\044\000\044\000\045\000\073\000\098\000\104\000\
    \074\000\099\000\105\000\134\000\148\000\200\000\163\000\149\000\
    \039\000\008\000\029\000\024\000\006\000\004\000\023\000\027\000\
    \026\000\021\000\025\000\007\000\020\000\019\000\018\000\003\000\
    \031\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\017\000\016\000\015\000\014\000\010\000\036\000\
    \005\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\013\000\042\000\012\000\005\000\038\000\
    \022\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\028\000\011\000\009\000\037\000\114\000\
    \116\000\113\000\110\000\088\000\112\000\111\000\039\000\076\000\
    \067\000\039\000\067\000\065\000\065\000\066\000\066\000\066\000\
    \066\000\066\000\066\000\066\000\066\000\066\000\066\000\119\000\
    \075\000\118\000\081\000\117\000\084\000\039\000\064\000\064\000\
    \064\000\064\000\064\000\064\000\064\000\064\000\066\000\066\000\
    \066\000\066\000\066\000\066\000\066\000\066\000\066\000\066\000\
    \082\000\082\000\082\000\082\000\082\000\082\000\082\000\082\000\
    \082\000\082\000\087\000\089\000\090\000\091\000\092\000\123\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\120\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\121\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \002\000\003\000\091\000\092\000\003\000\003\000\003\000\122\000\
    \143\000\073\000\003\000\003\000\074\000\003\000\003\000\003\000\
    \083\000\083\000\083\000\083\000\083\000\083\000\083\000\083\000\
    \083\000\083\000\003\000\142\000\003\000\003\000\003\000\003\000\
    \003\000\152\000\098\000\151\000\003\000\099\000\255\255\003\000\
    \003\000\003\000\156\000\159\000\162\000\003\000\003\000\175\000\
    \003\000\003\000\003\000\193\000\194\000\134\000\098\000\104\000\
    \163\000\099\000\105\000\198\000\195\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\199\000\167\000\175\000\005\000\
    \182\000\196\000\005\000\005\000\005\000\000\000\103\000\175\000\
    \005\000\005\000\177\000\005\000\005\000\005\000\000\000\000\000\
    \000\000\102\000\098\000\071\000\003\000\099\000\003\000\000\000\
    \005\000\003\000\005\000\005\000\005\000\005\000\005\000\000\000\
    \175\000\167\000\006\000\177\000\182\000\006\000\006\000\006\000\
    \102\000\000\000\101\000\006\000\006\000\196\000\006\000\006\000\
    \006\000\187\000\187\000\000\000\189\000\189\000\000\000\003\000\
    \000\000\003\000\000\000\006\000\005\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\107\000\000\000\000\000\
    \107\000\107\000\107\000\000\000\000\000\000\000\107\000\107\000\
    \000\000\107\000\131\000\107\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\005\000\000\000\005\000\000\000\107\000\006\000\
    \107\000\130\000\107\000\107\000\107\000\000\000\000\000\000\000\
    \128\000\000\000\000\000\128\000\128\000\128\000\000\000\000\000\
    \000\000\128\000\128\000\000\000\128\000\128\000\128\000\187\000\
    \000\000\000\000\188\000\000\000\000\000\006\000\000\000\006\000\
    \000\000\128\000\107\000\128\000\129\000\128\000\128\000\128\000\
    \000\000\167\000\000\000\006\000\168\000\000\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \107\000\170\000\107\000\000\000\006\000\128\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\000\000\000\000\
    \006\000\000\000\000\000\006\000\006\000\006\000\000\000\255\255\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\000\000\128\000\000\000\128\000\000\000\127\000\
    \006\000\006\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \255\255\000\000\000\000\000\000\000\000\006\000\000\000\000\000\
    \006\000\006\000\006\000\169\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\255\255\255\255\006\000\126\000\
    \006\000\185\000\255\255\000\000\124\000\006\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\255\255\
    \006\000\000\000\000\000\006\000\006\000\006\000\000\000\000\000\
    \148\000\006\000\006\000\149\000\115\000\006\000\006\000\000\000\
    \255\255\000\000\000\000\125\000\000\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\107\000\000\000\150\000\107\000\107\000\
    \107\000\000\000\000\000\255\255\107\000\107\000\000\000\107\000\
    \108\000\107\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \006\000\000\000\006\000\000\000\107\000\006\000\107\000\107\000\
    \109\000\107\000\107\000\000\000\000\000\000\000\006\000\000\000\
    \000\000\006\000\006\000\106\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\065\000\065\000\000\000\
    \000\000\000\000\146\000\006\000\000\000\006\000\000\000\006\000\
    \107\000\006\000\006\000\006\000\006\000\006\000\059\000\059\000\
    \059\000\059\000\059\000\059\000\059\000\059\000\059\000\059\000\
    \000\000\056\000\000\000\000\000\000\000\186\000\000\000\000\000\
    \000\000\000\000\000\000\058\000\000\000\000\000\107\000\000\000\
    \107\000\000\000\000\000\006\000\065\000\000\000\000\000\166\000\
    \000\000\000\000\000\000\000\000\000\000\097\000\000\000\000\000\
    \000\000\057\000\000\000\055\000\000\000\059\000\000\000\000\000\
    \000\000\000\000\000\000\058\000\000\000\000\000\000\000\000\000\
    \000\000\006\000\000\000\006\000\097\000\095\000\000\000\095\000\
    \095\000\095\000\095\000\000\000\000\000\000\000\095\000\095\000\
    \000\000\095\000\095\000\095\000\096\000\096\000\096\000\096\000\
    \096\000\096\000\096\000\096\000\096\000\096\000\095\000\000\000\
    \095\000\095\000\095\000\095\000\095\000\000\000\000\000\000\000\
    \003\000\000\000\000\000\003\000\003\000\003\000\000\000\000\000\
    \094\000\093\000\003\000\000\000\003\000\003\000\003\000\063\000\
    \063\000\063\000\063\000\063\000\063\000\063\000\063\000\063\000\
    \063\000\003\000\095\000\003\000\003\000\003\000\003\000\003\000\
    \063\000\063\000\063\000\063\000\063\000\063\000\066\000\066\000\
    \066\000\066\000\066\000\066\000\066\000\066\000\066\000\066\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\255\255\000\000\
    \095\000\068\000\095\000\000\000\000\000\003\000\000\000\000\000\
    \063\000\063\000\063\000\063\000\063\000\063\000\157\000\157\000\
    \157\000\157\000\157\000\157\000\157\000\157\000\157\000\157\000\
    \000\000\000\000\000\000\000\000\000\000\066\000\000\000\000\000\
    \000\000\000\000\000\000\003\000\070\000\003\000\070\000\070\000\
    \070\000\070\000\070\000\070\000\070\000\070\000\070\000\070\000\
    \070\000\070\000\070\000\070\000\070\000\070\000\070\000\070\000\
    \070\000\070\000\070\000\070\000\070\000\070\000\070\000\070\000\
    \059\000\069\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\158\000\158\000\158\000\158\000\
    \158\000\158\000\158\000\158\000\158\000\158\000\000\000\058\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\056\000\000\000\
    \000\000\059\000\000\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\000\000\000\000\000\000\
    \000\000\030\000\000\000\000\000\000\000\060\000\000\000\058\000\
    \058\000\000\000\000\000\000\000\000\000\000\000\057\000\056\000\
    \055\000\000\000\061\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\062\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\030\000\000\000\000\000\060\000\000\000\000\000\
    \058\000\000\000\000\000\000\000\000\000\000\000\000\000\057\000\
    \000\000\055\000\061\000\032\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\062\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\000\000\
    \000\000\000\000\000\000\032\000\000\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\063\000\
    \063\000\063\000\063\000\063\000\063\000\063\000\063\000\063\000\
    \063\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \063\000\063\000\063\000\063\000\063\000\063\000\000\000\000\000\
    \000\000\000\000\000\000\056\000\178\000\178\000\178\000\178\000\
    \178\000\178\000\178\000\178\000\178\000\178\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\063\000\000\000\
    \063\000\063\000\063\000\063\000\063\000\063\000\000\000\000\000\
    \000\000\000\000\000\000\057\000\000\000\055\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\000\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\033\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\000\000\
    \000\000\000\000\000\000\033\000\000\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\064\000\
    \064\000\064\000\064\000\064\000\064\000\064\000\064\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\085\000\085\000\085\000\
    \085\000\085\000\085\000\085\000\085\000\085\000\085\000\000\000\
    \000\000\000\000\000\000\056\000\000\000\000\000\085\000\085\000\
    \085\000\085\000\085\000\085\000\179\000\179\000\179\000\179\000\
    \179\000\179\000\179\000\179\000\179\000\179\000\064\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\057\000\000\000\055\000\085\000\085\000\
    \085\000\085\000\085\000\085\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\000\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\034\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\000\000\
    \000\000\000\000\000\000\034\000\000\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\070\000\
    \000\000\070\000\070\000\070\000\070\000\070\000\070\000\070\000\
    \070\000\070\000\070\000\070\000\070\000\070\000\070\000\070\000\
    \070\000\070\000\070\000\070\000\070\000\070\000\070\000\070\000\
    \070\000\070\000\070\000\000\000\069\000\134\000\000\000\000\000\
    \135\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\139\000\000\000\000\000\
    \000\000\000\000\137\000\141\000\000\000\140\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\000\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\035\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\138\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\000\000\
    \000\000\000\000\000\000\035\000\000\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\086\000\
    \086\000\086\000\086\000\086\000\086\000\086\000\086\000\086\000\
    \086\000\000\000\000\000\000\000\000\000\000\000\000\000\097\000\
    \086\000\086\000\086\000\086\000\086\000\086\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\097\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \086\000\086\000\086\000\086\000\086\000\086\000\096\000\096\000\
    \096\000\096\000\096\000\096\000\096\000\096\000\096\000\096\000\
    \000\000\000\000\000\000\136\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\000\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\000\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\046\000\000\000\000\000\046\000\
    \046\000\046\000\000\000\000\000\000\000\046\000\046\000\000\000\
    \046\000\046\000\046\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\046\000\000\000\046\000\
    \046\000\046\000\046\000\046\000\000\000\191\000\000\000\191\000\
    \191\000\191\000\191\000\191\000\191\000\191\000\191\000\191\000\
    \191\000\191\000\191\000\191\000\191\000\191\000\191\000\191\000\
    \191\000\191\000\191\000\191\000\191\000\191\000\191\000\191\000\
    \191\000\046\000\052\000\190\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\000\000\046\000\
    \046\000\046\000\000\000\046\000\046\000\046\000\000\000\000\000\
    \000\000\046\000\046\000\000\000\046\000\046\000\046\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\046\000\000\000\046\000\046\000\046\000\046\000\046\000\
    \000\000\191\000\000\000\191\000\191\000\191\000\191\000\191\000\
    \191\000\191\000\191\000\191\000\191\000\191\000\191\000\191\000\
    \191\000\191\000\191\000\191\000\191\000\191\000\191\000\191\000\
    \191\000\191\000\191\000\191\000\191\000\046\000\048\000\190\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\000\000\046\000\000\000\046\000\000\000\000\000\
    \000\000\000\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\000\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\145\000\000\000\145\000\145\000\145\000\
    \145\000\145\000\145\000\145\000\145\000\145\000\145\000\145\000\
    \145\000\145\000\145\000\145\000\145\000\145\000\145\000\145\000\
    \145\000\145\000\145\000\145\000\145\000\145\000\145\000\145\000\
    \144\000\145\000\145\000\145\000\145\000\145\000\145\000\145\000\
    \145\000\145\000\145\000\145\000\145\000\145\000\145\000\145\000\
    \145\000\145\000\145\000\145\000\145\000\145\000\145\000\145\000\
    \145\000\145\000\145\000\000\000\144\000\000\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\035\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\000\000\000\000\000\000\000\000\035\000\000\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \102\000\098\000\000\000\000\000\099\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\102\000\
    \000\000\101\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\096\000\
    \096\000\096\000\096\000\096\000\096\000\096\000\096\000\096\000\
    \096\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\000\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\000\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\046\000\
    \000\000\000\000\046\000\046\000\046\000\000\000\000\000\000\000\
    \046\000\046\000\000\000\046\000\046\000\046\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \046\000\000\000\046\000\046\000\046\000\046\000\046\000\000\000\
    \000\000\000\000\000\000\047\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\050\000\000\000\
    \000\000\000\000\000\000\000\000\046\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\000\000\
    \000\000\000\000\046\000\047\000\046\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\255\255\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\160\000\160\000\160\000\160\000\160\000\160\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\160\000\160\000\160\000\160\000\160\000\160\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\000\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\048\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\049\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\000\000\
    \000\000\000\000\000\000\048\000\000\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\161\000\
    \161\000\161\000\161\000\161\000\161\000\161\000\161\000\161\000\
    \161\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \161\000\161\000\161\000\161\000\161\000\161\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \161\000\161\000\161\000\161\000\161\000\161\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\000\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\051\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\054\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\000\000\
    \000\000\000\000\000\000\051\000\000\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\180\000\
    \180\000\180\000\180\000\180\000\180\000\180\000\180\000\180\000\
    \180\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \180\000\180\000\180\000\180\000\180\000\180\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \180\000\180\000\180\000\180\000\180\000\180\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\000\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\052\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\053\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\000\000\
    \000\000\000\000\000\000\052\000\000\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\181\000\
    \181\000\181\000\181\000\181\000\181\000\181\000\181\000\181\000\
    \181\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \181\000\181\000\181\000\181\000\181\000\181\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \181\000\181\000\181\000\181\000\181\000\181\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\000\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\000\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\080\000\093\000\080\000\000\000\
    \093\000\093\000\093\000\080\000\000\000\000\000\093\000\093\000\
    \000\000\093\000\093\000\093\000\079\000\079\000\079\000\079\000\
    \079\000\079\000\079\000\079\000\079\000\079\000\093\000\000\000\
    \093\000\093\000\093\000\093\000\093\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\095\000\000\000\095\000\095\000\
    \095\000\095\000\000\000\000\000\000\000\095\000\095\000\000\000\
    \095\000\095\000\095\000\000\000\000\000\000\000\000\000\000\000\
    \080\000\000\000\093\000\000\000\000\000\095\000\080\000\095\000\
    \095\000\095\000\095\000\095\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\080\000\000\000\000\000\000\000\080\000\000\000\
    \080\000\000\000\006\000\000\000\078\000\006\000\006\000\006\000\
    \093\000\000\000\093\000\006\000\006\000\000\000\006\000\006\000\
    \006\000\095\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\107\000\000\000\000\000\107\000\107\000\107\000\095\000\
    \000\000\095\000\107\000\107\000\000\000\107\000\107\000\107\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\006\000\
    \000\000\000\000\107\000\000\000\107\000\107\000\107\000\107\000\
    \107\000\000\000\000\000\000\000\107\000\000\000\000\000\107\000\
    \107\000\107\000\000\000\000\000\000\000\107\000\107\000\000\000\
    \107\000\107\000\107\000\000\000\000\000\006\000\000\000\006\000\
    \000\000\000\000\000\000\000\000\000\000\107\000\107\000\107\000\
    \107\000\107\000\107\000\107\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\107\000\000\000\000\000\107\000\107\000\107\000\
    \000\000\000\000\000\000\107\000\107\000\000\000\107\000\107\000\
    \107\000\000\000\000\000\000\000\107\000\000\000\107\000\000\000\
    \000\000\107\000\000\000\107\000\255\255\107\000\107\000\107\000\
    \107\000\107\000\000\000\000\000\000\000\006\000\000\000\000\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\000\000\000\000\000\000\107\000\
    \000\000\107\000\000\000\000\000\000\000\000\000\006\000\107\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\000\000\000\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\107\000\000\000\107\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\128\000\000\000\000\000\128\000\128\000\
    \128\000\000\000\000\000\000\000\128\000\128\000\000\000\128\000\
    \128\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \006\000\000\000\006\000\000\000\128\000\006\000\128\000\128\000\
    \128\000\128\000\128\000\000\000\000\000\000\000\128\000\000\000\
    \000\000\128\000\128\000\128\000\000\000\000\000\000\000\128\000\
    \128\000\000\000\128\000\128\000\128\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\006\000\000\000\006\000\000\000\128\000\
    \128\000\128\000\128\000\128\000\128\000\128\000\000\000\000\000\
    \000\000\107\000\000\000\000\000\107\000\107\000\107\000\000\000\
    \000\000\000\000\107\000\107\000\000\000\107\000\107\000\107\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\
    \128\000\000\000\107\000\128\000\107\000\107\000\107\000\107\000\
    \107\000\000\000\000\000\000\000\107\000\000\000\000\000\107\000\
    \107\000\107\000\000\000\000\000\000\000\107\000\107\000\000\000\
    \107\000\107\000\107\000\000\000\000\000\155\000\000\000\155\000\
    \000\000\128\000\000\000\128\000\155\000\107\000\107\000\107\000\
    \107\000\107\000\107\000\107\000\000\000\154\000\154\000\154\000\
    \154\000\154\000\154\000\154\000\154\000\154\000\154\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\107\000\000\000\107\000\000\000\
    \000\000\107\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \175\000\000\000\000\000\176\000\000\000\000\000\000\000\000\000\
    \000\000\155\000\000\000\000\000\000\000\000\000\000\000\155\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\174\000\107\000\
    \174\000\107\000\000\000\155\000\000\000\174\000\000\000\155\000\
    \000\000\155\000\000\000\000\000\000\000\153\000\173\000\173\000\
    \173\000\173\000\173\000\173\000\173\000\173\000\173\000\173\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\174\000\000\000\000\000\000\000\000\000\000\000\
    \174\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\174\000\000\000\000\000\000\000\
    \174\000\000\000\174\000\000\000\000\000\000\000\172\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\255\255";
  Lexing.lex_check =
   "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\041\000\000\000\000\000\041\000\042\000\
    \044\000\045\000\042\000\044\000\045\000\074\000\099\000\105\000\
    \074\000\099\000\105\000\135\000\149\000\199\000\135\000\149\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\
    \013\000\017\000\018\000\026\000\017\000\017\000\039\000\072\000\
    \058\000\039\000\058\000\060\000\060\000\058\000\058\000\058\000\
    \058\000\058\000\058\000\058\000\058\000\058\000\058\000\013\000\
    \073\000\013\000\080\000\013\000\083\000\039\000\061\000\061\000\
    \061\000\061\000\061\000\061\000\061\000\061\000\067\000\067\000\
    \067\000\067\000\067\000\067\000\067\000\067\000\067\000\067\000\
    \079\000\079\000\079\000\079\000\079\000\079\000\079\000\079\000\
    \079\000\079\000\086\000\088\000\088\000\090\000\090\000\116\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\013\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\117\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\003\000\092\000\092\000\003\000\003\000\003\000\121\000\
    \140\000\027\000\003\000\003\000\027\000\003\000\003\000\003\000\
    \082\000\082\000\082\000\082\000\082\000\082\000\082\000\082\000\
    \082\000\082\000\003\000\141\000\003\000\003\000\003\000\003\000\
    \003\000\147\000\100\000\148\000\004\000\100\000\027\000\004\000\
    \004\000\004\000\155\000\158\000\161\000\004\000\004\000\175\000\
    \004\000\004\000\004\000\192\000\193\000\163\000\101\000\103\000\
    \163\000\101\000\103\000\196\000\194\000\004\000\003\000\004\000\
    \004\000\004\000\004\000\004\000\198\000\168\000\175\000\005\000\
    \168\000\195\000\005\000\005\000\005\000\255\255\101\000\176\000\
    \005\000\005\000\176\000\005\000\005\000\005\000\255\255\255\255\
    \255\255\102\000\102\000\027\000\003\000\102\000\003\000\255\255\
    \005\000\004\000\005\000\005\000\005\000\005\000\005\000\255\255\
    \177\000\182\000\006\000\177\000\182\000\006\000\006\000\006\000\
    \102\000\255\255\102\000\006\000\006\000\197\000\006\000\006\000\
    \006\000\188\000\189\000\255\255\188\000\189\000\255\255\004\000\
    \255\255\004\000\255\255\006\000\005\000\006\000\006\000\006\000\
    \006\000\006\000\255\255\255\255\255\255\007\000\255\255\255\255\
    \007\000\007\000\007\000\255\255\255\255\255\255\007\000\007\000\
    \255\255\007\000\007\000\007\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\005\000\255\255\005\000\255\255\007\000\006\000\
    \007\000\007\000\007\000\007\000\007\000\255\255\255\255\255\255\
    \008\000\255\255\255\255\008\000\008\000\008\000\255\255\255\255\
    \255\255\008\000\008\000\255\255\008\000\008\000\008\000\183\000\
    \255\255\255\255\183\000\255\255\255\255\006\000\255\255\006\000\
    \255\255\008\000\007\000\008\000\008\000\008\000\008\000\008\000\
    \255\255\164\000\255\255\010\000\164\000\255\255\010\000\010\000\
    \010\000\255\255\255\255\255\255\010\000\010\000\255\255\010\000\
    \010\000\010\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \007\000\164\000\007\000\255\255\010\000\008\000\010\000\010\000\
    \010\000\010\000\010\000\255\255\255\255\255\255\255\255\255\255\
    \011\000\255\255\255\255\011\000\011\000\011\000\255\255\027\000\
    \255\255\011\000\011\000\255\255\011\000\011\000\011\000\255\255\
    \255\255\255\255\255\255\008\000\255\255\008\000\255\255\010\000\
    \010\000\011\000\255\255\011\000\011\000\011\000\011\000\011\000\
    \100\000\255\255\255\255\255\255\255\255\014\000\255\255\255\255\
    \014\000\014\000\014\000\164\000\255\255\255\255\014\000\014\000\
    \255\255\014\000\014\000\014\000\101\000\103\000\010\000\010\000\
    \010\000\183\000\194\000\255\255\011\000\011\000\014\000\255\255\
    \014\000\014\000\014\000\014\000\014\000\255\255\255\255\195\000\
    \015\000\255\255\255\255\015\000\015\000\015\000\255\255\255\255\
    \137\000\015\000\015\000\137\000\015\000\015\000\015\000\255\255\
    \102\000\255\255\255\255\011\000\255\255\011\000\255\255\255\255\
    \255\255\015\000\014\000\015\000\015\000\015\000\015\000\015\000\
    \255\255\255\255\255\255\019\000\255\255\137\000\019\000\019\000\
    \019\000\255\255\255\255\197\000\019\000\019\000\255\255\019\000\
    \019\000\019\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \014\000\255\255\014\000\255\255\019\000\015\000\019\000\019\000\
    \019\000\019\000\019\000\255\255\255\255\255\255\023\000\255\255\
    \255\255\023\000\023\000\023\000\255\255\255\255\255\255\023\000\
    \023\000\255\255\023\000\023\000\023\000\065\000\065\000\255\255\
    \255\255\255\255\137\000\015\000\255\255\015\000\255\255\023\000\
    \019\000\023\000\023\000\023\000\023\000\023\000\059\000\059\000\
    \059\000\059\000\059\000\059\000\059\000\059\000\059\000\059\000\
    \255\255\065\000\255\255\255\255\255\255\183\000\255\255\255\255\
    \255\255\255\255\255\255\059\000\255\255\255\255\019\000\255\255\
    \019\000\255\255\255\255\023\000\065\000\255\255\255\255\164\000\
    \255\255\255\255\255\255\255\255\255\255\024\000\255\255\255\255\
    \255\255\065\000\255\255\065\000\255\255\059\000\255\255\255\255\
    \255\255\255\255\255\255\059\000\255\255\255\255\255\255\255\255\
    \255\255\023\000\255\255\023\000\024\000\024\000\255\255\024\000\
    \024\000\024\000\024\000\255\255\255\255\255\255\024\000\024\000\
    \255\255\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\024\000\024\000\024\000\024\000\255\255\
    \024\000\024\000\024\000\024\000\024\000\255\255\255\255\255\255\
    \025\000\255\255\255\255\025\000\025\000\025\000\255\255\255\255\
    \025\000\025\000\025\000\255\255\025\000\025\000\025\000\062\000\
    \062\000\062\000\062\000\062\000\062\000\062\000\062\000\062\000\
    \062\000\025\000\024\000\025\000\025\000\025\000\025\000\025\000\
    \062\000\062\000\062\000\062\000\062\000\062\000\066\000\066\000\
    \066\000\066\000\066\000\066\000\066\000\066\000\066\000\066\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\137\000\255\255\
    \024\000\028\000\024\000\255\255\255\255\025\000\255\255\255\255\
    \062\000\062\000\062\000\062\000\062\000\062\000\154\000\154\000\
    \154\000\154\000\154\000\154\000\154\000\154\000\154\000\154\000\
    \255\255\255\255\255\255\255\255\255\255\066\000\255\255\255\255\
    \255\255\255\255\255\255\025\000\028\000\025\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \030\000\028\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\157\000\157\000\157\000\157\000\
    \157\000\157\000\157\000\157\000\157\000\157\000\255\255\030\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\030\000\255\255\
    \255\255\031\000\255\255\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\255\255\255\255\255\255\
    \255\255\030\000\255\255\255\255\255\255\031\000\255\255\030\000\
    \031\000\255\255\255\255\255\255\255\255\255\255\030\000\031\000\
    \030\000\255\255\031\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\031\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\031\000\255\255\255\255\031\000\255\255\255\255\
    \031\000\255\255\255\255\255\255\255\255\255\255\255\255\031\000\
    \255\255\031\000\031\000\032\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\031\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\255\255\
    \255\255\255\255\255\255\032\000\255\255\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\063\000\
    \063\000\063\000\063\000\063\000\063\000\063\000\063\000\063\000\
    \063\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \063\000\063\000\063\000\063\000\063\000\063\000\255\255\255\255\
    \255\255\255\255\255\255\063\000\173\000\173\000\173\000\173\000\
    \173\000\173\000\173\000\173\000\173\000\173\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\063\000\255\255\
    \063\000\063\000\063\000\063\000\063\000\063\000\255\255\255\255\
    \255\255\255\255\255\255\063\000\255\255\063\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\255\255\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\033\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\255\255\
    \255\255\255\255\255\255\033\000\255\255\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\064\000\
    \064\000\064\000\064\000\064\000\064\000\064\000\064\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\078\000\078\000\078\000\
    \078\000\078\000\078\000\078\000\078\000\078\000\078\000\255\255\
    \255\255\255\255\255\255\064\000\255\255\255\255\078\000\078\000\
    \078\000\078\000\078\000\078\000\178\000\178\000\178\000\178\000\
    \178\000\178\000\178\000\178\000\178\000\178\000\064\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\064\000\255\255\064\000\078\000\078\000\
    \078\000\078\000\078\000\078\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\255\255\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\034\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\255\255\
    \255\255\255\255\255\255\034\000\255\255\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\070\000\
    \255\255\070\000\070\000\070\000\070\000\070\000\070\000\070\000\
    \070\000\070\000\070\000\070\000\070\000\070\000\070\000\070\000\
    \070\000\070\000\070\000\070\000\070\000\070\000\070\000\070\000\
    \070\000\070\000\070\000\255\255\070\000\132\000\255\255\255\255\
    \132\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\132\000\255\255\255\255\
    \255\255\255\255\132\000\132\000\255\255\132\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\255\255\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\035\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\132\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\255\255\
    \255\255\255\255\255\255\035\000\255\255\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\085\000\
    \085\000\085\000\085\000\085\000\085\000\085\000\085\000\085\000\
    \085\000\255\255\255\255\255\255\255\255\255\255\255\255\097\000\
    \085\000\085\000\085\000\085\000\085\000\085\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\097\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \085\000\085\000\085\000\085\000\085\000\085\000\097\000\097\000\
    \097\000\097\000\097\000\097\000\097\000\097\000\097\000\097\000\
    \255\255\255\255\255\255\132\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\255\255\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\255\255\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\036\000\255\255\255\255\036\000\
    \036\000\036\000\255\255\255\255\255\255\036\000\036\000\255\255\
    \036\000\036\000\036\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\036\000\255\255\036\000\
    \036\000\036\000\036\000\036\000\255\255\185\000\255\255\185\000\
    \185\000\185\000\185\000\185\000\185\000\185\000\185\000\185\000\
    \185\000\185\000\185\000\185\000\185\000\185\000\185\000\185\000\
    \185\000\185\000\185\000\185\000\185\000\185\000\185\000\185\000\
    \185\000\036\000\036\000\185\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\255\255\036\000\
    \037\000\036\000\255\255\037\000\037\000\037\000\255\255\255\255\
    \255\255\037\000\037\000\255\255\037\000\037\000\037\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\037\000\255\255\037\000\037\000\037\000\037\000\037\000\
    \255\255\191\000\255\255\191\000\191\000\191\000\191\000\191\000\
    \191\000\191\000\191\000\191\000\191\000\191\000\191\000\191\000\
    \191\000\191\000\191\000\191\000\191\000\191\000\191\000\191\000\
    \191\000\191\000\191\000\191\000\191\000\037\000\037\000\191\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\255\255\037\000\255\255\037\000\255\255\255\255\
    \255\255\255\255\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\255\255\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\138\000\255\255\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\138\000\145\000\
    \138\000\145\000\145\000\145\000\145\000\145\000\145\000\145\000\
    \145\000\145\000\145\000\145\000\145\000\145\000\145\000\145\000\
    \145\000\145\000\145\000\145\000\145\000\145\000\145\000\145\000\
    \145\000\145\000\145\000\255\255\145\000\255\255\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\038\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\255\255\255\255\255\255\255\255\038\000\255\255\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \096\000\096\000\255\255\255\255\096\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\096\000\
    \255\255\096\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\096\000\
    \096\000\096\000\096\000\096\000\096\000\096\000\096\000\096\000\
    \096\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\255\255\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\255\255\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\046\000\
    \255\255\255\255\046\000\046\000\046\000\255\255\255\255\255\255\
    \046\000\046\000\255\255\046\000\046\000\046\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \046\000\255\255\046\000\046\000\046\000\046\000\046\000\255\255\
    \255\255\255\255\255\255\047\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\255\255\
    \255\255\255\255\255\255\255\255\046\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\255\255\
    \255\255\255\255\046\000\047\000\046\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\096\000\
    \153\000\153\000\153\000\153\000\153\000\153\000\153\000\153\000\
    \153\000\153\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\153\000\153\000\153\000\153\000\153\000\153\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\153\000\153\000\153\000\153\000\153\000\153\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\255\255\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\048\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\255\255\
    \255\255\255\255\255\255\048\000\255\255\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \160\000\160\000\160\000\160\000\160\000\160\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \160\000\160\000\160\000\160\000\160\000\160\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\255\255\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\051\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\255\255\
    \255\255\255\255\255\255\051\000\255\255\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\172\000\
    \172\000\172\000\172\000\172\000\172\000\172\000\172\000\172\000\
    \172\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \172\000\172\000\172\000\172\000\172\000\172\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \172\000\172\000\172\000\172\000\172\000\172\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\255\255\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\052\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\255\255\
    \255\255\255\255\255\255\052\000\255\255\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\180\000\
    \180\000\180\000\180\000\180\000\180\000\180\000\180\000\180\000\
    \180\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \180\000\180\000\180\000\180\000\180\000\180\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \180\000\180\000\180\000\180\000\180\000\180\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\255\255\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\255\255\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\071\000\093\000\071\000\255\255\
    \093\000\093\000\093\000\071\000\255\255\255\255\093\000\093\000\
    \255\255\093\000\093\000\093\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\071\000\093\000\255\255\
    \093\000\093\000\093\000\093\000\093\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\095\000\255\255\095\000\095\000\
    \095\000\095\000\255\255\255\255\255\255\095\000\095\000\255\255\
    \095\000\095\000\095\000\255\255\255\255\255\255\255\255\255\255\
    \071\000\255\255\093\000\255\255\255\255\095\000\071\000\095\000\
    \095\000\095\000\095\000\095\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\071\000\255\255\255\255\255\255\071\000\255\255\
    \071\000\255\255\106\000\255\255\071\000\106\000\106\000\106\000\
    \093\000\255\255\093\000\106\000\106\000\255\255\106\000\106\000\
    \106\000\095\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\106\000\255\255\106\000\106\000\106\000\
    \106\000\106\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\107\000\255\255\255\255\107\000\107\000\107\000\095\000\
    \255\255\095\000\107\000\107\000\255\255\107\000\107\000\107\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\106\000\
    \255\255\255\255\107\000\255\255\107\000\107\000\107\000\107\000\
    \107\000\255\255\255\255\255\255\108\000\255\255\255\255\108\000\
    \108\000\108\000\255\255\255\255\255\255\108\000\108\000\255\255\
    \108\000\108\000\108\000\255\255\255\255\106\000\255\255\106\000\
    \255\255\255\255\255\255\255\255\255\255\108\000\107\000\108\000\
    \108\000\108\000\108\000\108\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\109\000\255\255\255\255\109\000\109\000\109\000\
    \255\255\255\255\255\255\109\000\109\000\255\255\109\000\109\000\
    \109\000\255\255\255\255\255\255\107\000\255\255\107\000\255\255\
    \255\255\108\000\255\255\109\000\071\000\109\000\109\000\109\000\
    \109\000\109\000\255\255\255\255\255\255\115\000\255\255\255\255\
    \115\000\115\000\115\000\255\255\255\255\255\255\115\000\115\000\
    \255\255\115\000\115\000\115\000\255\255\255\255\255\255\108\000\
    \255\255\108\000\255\255\255\255\255\255\255\255\115\000\109\000\
    \115\000\115\000\115\000\115\000\115\000\255\255\255\255\255\255\
    \125\000\255\255\255\255\125\000\125\000\125\000\255\255\255\255\
    \255\255\125\000\125\000\255\255\125\000\125\000\125\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\109\000\255\255\109\000\
    \255\255\125\000\115\000\125\000\125\000\125\000\125\000\125\000\
    \255\255\255\255\255\255\128\000\255\255\255\255\128\000\128\000\
    \128\000\255\255\255\255\255\255\128\000\128\000\255\255\128\000\
    \128\000\128\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \115\000\255\255\115\000\255\255\128\000\125\000\128\000\128\000\
    \128\000\128\000\128\000\255\255\255\255\255\255\129\000\255\255\
    \255\255\129\000\129\000\129\000\255\255\255\255\255\255\129\000\
    \129\000\255\255\129\000\129\000\129\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\125\000\255\255\125\000\255\255\129\000\
    \128\000\129\000\129\000\129\000\129\000\129\000\255\255\255\255\
    \255\255\130\000\255\255\255\255\130\000\130\000\130\000\255\255\
    \255\255\255\255\130\000\130\000\255\255\130\000\130\000\130\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\128\000\255\255\
    \128\000\255\255\130\000\129\000\130\000\130\000\130\000\130\000\
    \130\000\255\255\255\255\255\255\131\000\255\255\255\255\131\000\
    \131\000\131\000\255\255\255\255\255\255\131\000\131\000\255\255\
    \131\000\131\000\131\000\255\255\255\255\146\000\255\255\146\000\
    \255\255\129\000\255\255\129\000\146\000\131\000\130\000\131\000\
    \131\000\131\000\131\000\131\000\255\255\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\130\000\255\255\130\000\255\255\
    \255\255\131\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \169\000\255\255\255\255\169\000\255\255\255\255\255\255\255\255\
    \255\255\146\000\255\255\255\255\255\255\255\255\255\255\146\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\169\000\131\000\
    \169\000\131\000\255\255\146\000\255\255\169\000\255\255\146\000\
    \255\255\146\000\255\255\255\255\255\255\146\000\169\000\169\000\
    \169\000\169\000\169\000\169\000\169\000\169\000\169\000\169\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\169\000\255\255\255\255\255\255\255\255\255\255\
    \169\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\169\000\255\255\255\255\255\255\
    \169\000\255\255\169\000\255\255\255\255\255\255\169\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\169\000";
  Lexing.lex_base_code =
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \010\000\036\000\012\000\000\000\000\000\000\000\002\000\000\000\
    \027\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \002\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000";
  Lexing.lex_backtrk_code =
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\039\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000";
  Lexing.lex_default_code =
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\019\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000";
  Lexing.lex_trans_code =
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\001\000\000\000\036\000\036\000\000\000\036\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \001\000\000\000\000\000\001\000\022\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\007\000\001\000\000\000\000\000\
    \004\000\004\000\004\000\004\000\004\000\004\000\004\000\004\000\
    \004\000\004\000\004\000\004\000\004\000\004\000\004\000\004\000\
    \004\000\004\000\004\000\004\000\001\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\004\000\004\000\004\000\004\000\
    \004\000\004\000\004\000\004\000\004\000\004\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000";
  Lexing.lex_check_code =
   "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\024\000\101\000\169\000\176\000\101\000\177\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \024\000\255\255\101\000\000\000\102\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\096\000\097\000\255\255\255\255\
    \024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\096\000\096\000\096\000\096\000\096\000\096\000\
    \096\000\096\000\096\000\096\000\097\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\097\000\097\000\097\000\097\000\
    \097\000\097\000\097\000\097\000\097\000\097\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \101\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255";
  Lexing.lex_code =
   "\255\004\255\255\005\255\255\007\255\006\255\255\003\255\000\004\
    \001\005\255\007\255\255\006\255\007\255\255\000\004\001\005\003\
    \006\002\007\255\001\255\255\000\001\255";
}

let rec token lexbuf =
  lexbuf.Lexing.lex_mem <- Array.make 8 (-1) ;   __ocaml_lex_token_rec lexbuf 0
and __ocaml_lex_token_rec lexbuf __ocaml_lex_state =
  match Lexing.new_engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
(*# 767 "parsing/lexer.mll"*)
                 (
      if not !escaped_newlines then
        raise (Error(Illegal_character (Lexing.lexeme_char lexbuf 0),
                     Location.curr lexbuf));
      update_loc lexbuf None 1 false 0;
      token lexbuf )
(*# 1977 "parsing/lexer.ml"*)

  | 1 ->
(*# 774 "parsing/lexer.mll"*)
      ( update_loc lexbuf None 1 false 0;
        EOL )
(*# 1983 "parsing/lexer.ml"*)

  | 2 ->
(*# 777 "parsing/lexer.mll"*)
      ( token lexbuf )
(*# 1988 "parsing/lexer.ml"*)

  | 3 ->
(*# 779 "parsing/lexer.mll"*)
      ( UNDERSCORE )
(*# 1993 "parsing/lexer.ml"*)

  | 4 ->
(*# 781 "parsing/lexer.mll"*)
      ( TILDE )
(*# 1998 "parsing/lexer.ml"*)

  | 5 ->
(*# 783 "parsing/lexer.mll"*)
      ( LABEL (get_label_name lexbuf) )
(*# 2003 "parsing/lexer.ml"*)

  | 6 ->
(*# 785 "parsing/lexer.mll"*)
      ( warn_latin1 lexbuf; LABEL (get_label_name lexbuf) )
(*# 2008 "parsing/lexer.ml"*)

  | 7 ->
(*# 787 "parsing/lexer.mll"*)
      ( QUESTION )
(*# 2013 "parsing/lexer.ml"*)

  | 8 ->
(*# 789 "parsing/lexer.mll"*)
      ( OPTLABEL (get_label_name lexbuf) )
(*# 2018 "parsing/lexer.ml"*)

  | 9 ->
(*# 791 "parsing/lexer.mll"*)
      ( warn_latin1 lexbuf; OPTLABEL (get_label_name lexbuf) )
(*# 2023 "parsing/lexer.ml"*)

  | 10 ->
(*# 793 "parsing/lexer.mll"*)
      ( let s = Lexing.lexeme lexbuf in
        try Hashtbl.find keyword_table s
        with Not_found -> LIDENT s )
(*# 2030 "parsing/lexer.ml"*)

  | 11 ->
(*# 797 "parsing/lexer.mll"*)
      ( warn_latin1 lexbuf; LIDENT (Lexing.lexeme lexbuf) )
(*# 2035 "parsing/lexer.ml"*)

  | 12 ->
(*# 799 "parsing/lexer.mll"*)
      ( UIDENT(Lexing.lexeme lexbuf) )
(*# 2040 "parsing/lexer.ml"*)

  | 13 ->
(*# 801 "parsing/lexer.mll"*)
      ( warn_latin1 lexbuf; UIDENT(Lexing.lexeme lexbuf) )
(*# 2045 "parsing/lexer.ml"*)

  | 14 ->
(*# 803 "parsing/lexer.mll"*)
      ( try
          INT (cvt_int_literal (Lexing.lexeme lexbuf))
        with Failure _ ->
          raise (Error(Literal_overflow "int", Location.curr lexbuf))
      )
(*# 2054 "parsing/lexer.ml"*)

  | 15 ->
(*# 809 "parsing/lexer.mll"*)
      ( FLOAT (remove_underscores(Lexing.lexeme lexbuf)) )
(*# 2059 "parsing/lexer.ml"*)

  | 16 ->
(*# 811 "parsing/lexer.mll"*)
      ( try
          INT32 (cvt_int32_literal (Lexing.lexeme lexbuf))
        with Failure _ ->
          raise (Error(Literal_overflow "int32", Location.curr lexbuf)) )
(*# 2067 "parsing/lexer.ml"*)

  | 17 ->
(*# 816 "parsing/lexer.mll"*)
      ( try
          INT64 (cvt_int64_literal (Lexing.lexeme lexbuf))
        with Failure _ ->
          raise (Error(Literal_overflow "int64", Location.curr lexbuf)) )
(*# 2075 "parsing/lexer.ml"*)

  | 18 ->
(*# 821 "parsing/lexer.mll"*)
      ( try
          NATIVEINT (cvt_nativeint_literal (Lexing.lexeme lexbuf))
        with Failure _ ->
          raise (Error(Literal_overflow "nativeint", Location.curr lexbuf)) )
(*# 2083 "parsing/lexer.ml"*)

  | 19 ->
(*# 826 "parsing/lexer.mll"*)
      ( reset_string_buffer();
        is_in_string := true;
        let string_start = lexbuf.lex_start_p in
        string_start_loc := Location.curr lexbuf;
        string lexbuf;
        is_in_string := false;
        lexbuf.lex_start_p <- string_start;
        STRING (get_stored_string(), None) )
(*# 2095 "parsing/lexer.ml"*)

  | 20 ->
(*# 835 "parsing/lexer.mll"*)
      ( reset_string_buffer();
        let delim = Lexing.lexeme lexbuf in
        let delim = String.sub delim 1 (String.length delim - 2) in
        is_in_string := true;
        let string_start = lexbuf.lex_start_p in
        string_start_loc := Location.curr lexbuf;
        quoted_string delim lexbuf;
        is_in_string := false;
        lexbuf.lex_start_p <- string_start;
        STRING (get_stored_string(), Some delim) )
(*# 2109 "parsing/lexer.ml"*)

  | 21 ->
(*# 846 "parsing/lexer.mll"*)
      ( update_loc lexbuf None 1 false 1;
        CHAR (Lexing.lexeme_char lexbuf 1) )
(*# 2115 "parsing/lexer.ml"*)

  | 22 ->
(*# 849 "parsing/lexer.mll"*)
      ( CHAR(Lexing.lexeme_char lexbuf 1) )
(*# 2120 "parsing/lexer.ml"*)

  | 23 ->
(*# 851 "parsing/lexer.mll"*)
      ( CHAR(char_for_backslash (Lexing.lexeme_char lexbuf 2)) )
(*# 2125 "parsing/lexer.ml"*)

  | 24 ->
(*# 853 "parsing/lexer.mll"*)
      ( CHAR(char_for_decimal_code lexbuf 2) )
(*# 2130 "parsing/lexer.ml"*)

  | 25 ->
(*# 855 "parsing/lexer.mll"*)
      ( CHAR(char_for_hexadecimal_code lexbuf 3) )
(*# 2135 "parsing/lexer.ml"*)

  | 26 ->
(*# 857 "parsing/lexer.mll"*)
      ( let l = Lexing.lexeme lexbuf in
        let esc = String.sub l 1 (String.length l - 1) in
        raise (Error(Illegal_escape esc, Location.curr lexbuf))
      )
(*# 2143 "parsing/lexer.ml"*)

  | 27 ->
(*# 862 "parsing/lexer.mll"*)
      ( let s, loc = with_comment_buffer comment lexbuf in
        COMMENT (s, loc) )
(*# 2149 "parsing/lexer.ml"*)

  | 28 ->
(*# 865 "parsing/lexer.mll"*)
      ( let s, loc = with_comment_buffer comment lexbuf in

        DOCSTRING (Docstrings.docstring s loc)

)
(*# 2160 "parsing/lexer.ml"*)

  | 29 ->
let
(*# 872 "parsing/lexer.mll"*)
                    stars
(*# 2166 "parsing/lexer.ml"*)
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in
(*# 873 "parsing/lexer.mll"*)
      ( let s, loc =
          with_comment_buffer
            (fun lexbuf ->
               store_string ("*" ^ stars);
               comment lexbuf)
            lexbuf
        in
        COMMENT (s, loc) )
(*# 2177 "parsing/lexer.ml"*)

  | 30 ->
(*# 882 "parsing/lexer.mll"*)
      ( if !print_warnings then
          Location.prerr_warning (Location.curr lexbuf) Warnings.Comment_start;
        let s, loc = with_comment_buffer comment lexbuf in
        COMMENT (s, loc) )
(*# 2185 "parsing/lexer.ml"*)

  | 31 ->
let
(*# 886 "parsing/lexer.mll"*)
                   stars
(*# 2191 "parsing/lexer.ml"*)
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos (lexbuf.Lexing.lex_curr_pos + -2) in
(*# 887 "parsing/lexer.mll"*)
      ( COMMENT (stars, Location.curr lexbuf) )
(*# 2195 "parsing/lexer.ml"*)

  | 32 ->
(*# 889 "parsing/lexer.mll"*)
      ( let loc = Location.curr lexbuf in
        Location.prerr_warning loc Warnings.Comment_not_end;
        lexbuf.Lexing.lex_curr_pos <- lexbuf.Lexing.lex_curr_pos - 1;
        let curpos = lexbuf.lex_curr_p in
        lexbuf.lex_curr_p <- { curpos with pos_cnum = curpos.pos_cnum - 1 };
        STAR
      )
(*# 2206 "parsing/lexer.ml"*)

  | 33 ->
let
(*# 896 "parsing/lexer.mll"*)
                                   num
(*# 2212 "parsing/lexer.ml"*)
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_mem.(0) lexbuf.Lexing.lex_mem.(1)
and
(*# 897 "parsing/lexer.mll"*)
                                           name
(*# 2217 "parsing/lexer.ml"*)
= Lexing.sub_lexeme_opt lexbuf lexbuf.Lexing.lex_mem.(3) lexbuf.Lexing.lex_mem.(2) in
(*# 899 "parsing/lexer.mll"*)
      ( update_loc lexbuf name (int_of_string num) true 0;
        token lexbuf
      )
(*# 2223 "parsing/lexer.ml"*)

  | 34 ->
(*# 902 "parsing/lexer.mll"*)
         ( SHARP )
(*# 2228 "parsing/lexer.ml"*)

  | 35 ->
(*# 903 "parsing/lexer.mll"*)
         ( AMPERSAND )
(*# 2233 "parsing/lexer.ml"*)

  | 36 ->
(*# 904 "parsing/lexer.mll"*)
         ( AMPERAMPER )
(*# 2238 "parsing/lexer.ml"*)

  | 37 ->
(*# 905 "parsing/lexer.mll"*)
         ( BACKQUOTE )
(*# 2243 "parsing/lexer.ml"*)

  | 38 ->
(*# 906 "parsing/lexer.mll"*)
         ( QUOTE )
(*# 2248 "parsing/lexer.ml"*)

  | 39 ->
(*# 907 "parsing/lexer.mll"*)
         ( LPAREN )
(*# 2253 "parsing/lexer.ml"*)

  | 40 ->
(*# 908 "parsing/lexer.mll"*)
         ( RPAREN )
(*# 2258 "parsing/lexer.ml"*)

  | 41 ->
(*# 909 "parsing/lexer.mll"*)
         ( STAR )
(*# 2263 "parsing/lexer.ml"*)

  | 42 ->
(*# 910 "parsing/lexer.mll"*)
         ( COMMA )
(*# 2268 "parsing/lexer.ml"*)

  | 43 ->
(*# 911 "parsing/lexer.mll"*)
         ( MINUSGREATER )
(*# 2273 "parsing/lexer.ml"*)

  | 44 ->
(*# 912 "parsing/lexer.mll"*)
         ( DOT )
(*# 2278 "parsing/lexer.ml"*)

  | 45 ->
(*# 913 "parsing/lexer.mll"*)
         ( DOTDOT )
(*# 2283 "parsing/lexer.ml"*)

  | 46 ->
(*# 914 "parsing/lexer.mll"*)
         ( COLON )
(*# 2288 "parsing/lexer.ml"*)

  | 47 ->
(*# 915 "parsing/lexer.mll"*)
         ( COLONCOLON )
(*# 2293 "parsing/lexer.ml"*)

  | 48 ->
(*# 916 "parsing/lexer.mll"*)
         ( COLONEQUAL )
(*# 2298 "parsing/lexer.ml"*)

  | 49 ->
(*# 917 "parsing/lexer.mll"*)
         ( COLONGREATER )
(*# 2303 "parsing/lexer.ml"*)

  | 50 ->
(*# 918 "parsing/lexer.mll"*)
         ( SEMI )
(*# 2308 "parsing/lexer.ml"*)

  | 51 ->
(*# 919 "parsing/lexer.mll"*)
         ( SEMISEMI )
(*# 2313 "parsing/lexer.ml"*)

  | 52 ->
(*# 920 "parsing/lexer.mll"*)
         ( LESS )
(*# 2318 "parsing/lexer.ml"*)

  | 53 ->
(*# 921 "parsing/lexer.mll"*)
         ( LESSMINUS )
(*# 2323 "parsing/lexer.ml"*)

  | 54 ->
(*# 922 "parsing/lexer.mll"*)
         ( EQUAL )
(*# 2328 "parsing/lexer.ml"*)

  | 55 ->
(*# 923 "parsing/lexer.mll"*)
         ( LBRACKET )
(*# 2333 "parsing/lexer.ml"*)

  | 56 ->
(*# 924 "parsing/lexer.mll"*)
         ( LBRACKETBAR )
(*# 2338 "parsing/lexer.ml"*)

  | 57 ->
(*# 925 "parsing/lexer.mll"*)
         ( LBRACKETLESS )
(*# 2343 "parsing/lexer.ml"*)

  | 58 ->
(*# 926 "parsing/lexer.mll"*)
         ( LBRACKETGREATER )
(*# 2348 "parsing/lexer.ml"*)

  | 59 ->
(*# 927 "parsing/lexer.mll"*)
         ( RBRACKET )
(*# 2353 "parsing/lexer.ml"*)

  | 60 ->
(*# 928 "parsing/lexer.mll"*)
         ( LBRACE )
(*# 2358 "parsing/lexer.ml"*)

  | 61 ->
(*# 929 "parsing/lexer.mll"*)
         ( LBRACELESS )
(*# 2363 "parsing/lexer.ml"*)

  | 62 ->
(*# 930 "parsing/lexer.mll"*)
         ( BAR )
(*# 2368 "parsing/lexer.ml"*)

  | 63 ->
(*# 931 "parsing/lexer.mll"*)
         ( BARBAR )
(*# 2373 "parsing/lexer.ml"*)

  | 64 ->
(*# 932 "parsing/lexer.mll"*)
         ( BARRBRACKET )
(*# 2378 "parsing/lexer.ml"*)

  | 65 ->
(*# 933 "parsing/lexer.mll"*)
         ( GREATER )
(*# 2383 "parsing/lexer.ml"*)

  | 66 ->
(*# 934 "parsing/lexer.mll"*)
         ( GREATERRBRACKET )
(*# 2388 "parsing/lexer.ml"*)

  | 67 ->
(*# 935 "parsing/lexer.mll"*)
         ( RBRACE )
(*# 2393 "parsing/lexer.ml"*)

  | 68 ->
(*# 936 "parsing/lexer.mll"*)
         ( GREATERRBRACE )
(*# 2398 "parsing/lexer.ml"*)

  | 69 ->
(*# 937 "parsing/lexer.mll"*)
         ( LBRACKETAT )
(*# 2403 "parsing/lexer.ml"*)

  | 70 ->
(*# 938 "parsing/lexer.mll"*)
         ( LBRACKETPERCENT )
(*# 2408 "parsing/lexer.ml"*)

  | 71 ->
(*# 939 "parsing/lexer.mll"*)
          ( LBRACKETPERCENTPERCENT )
(*# 2413 "parsing/lexer.ml"*)

  | 72 ->
(*# 940 "parsing/lexer.mll"*)
          ( LBRACKETATAT )
(*# 2418 "parsing/lexer.ml"*)

  | 73 ->
(*# 941 "parsing/lexer.mll"*)
           ( LBRACKETATATAT )
(*# 2423 "parsing/lexer.ml"*)

  | 74 ->
(*# 942 "parsing/lexer.mll"*)
         ( BANG )
(*# 2428 "parsing/lexer.ml"*)

  | 75 ->
(*# 943 "parsing/lexer.mll"*)
         ( INFIXOP0 "!=" )
(*# 2433 "parsing/lexer.ml"*)

  | 76 ->
(*# 944 "parsing/lexer.mll"*)
         ( PLUS )
(*# 2438 "parsing/lexer.ml"*)

  | 77 ->
(*# 945 "parsing/lexer.mll"*)
         ( PLUSDOT )
(*# 2443 "parsing/lexer.ml"*)

  | 78 ->
(*# 946 "parsing/lexer.mll"*)
         ( PLUSEQ )
(*# 2448 "parsing/lexer.ml"*)

  | 79 ->
(*# 947 "parsing/lexer.mll"*)
         ( MINUS )
(*# 2453 "parsing/lexer.ml"*)

  | 80 ->
(*# 948 "parsing/lexer.mll"*)
         ( MINUSDOT )
(*# 2458 "parsing/lexer.ml"*)

  | 81 ->
(*# 951 "parsing/lexer.mll"*)
            ( PREFIXOP(Lexing.lexeme lexbuf) )
(*# 2463 "parsing/lexer.ml"*)

  | 82 ->
(*# 953 "parsing/lexer.mll"*)
            ( PREFIXOP(Lexing.lexeme lexbuf) )
(*# 2468 "parsing/lexer.ml"*)

  | 83 ->
(*# 955 "parsing/lexer.mll"*)
            ( INFIXOP0(Lexing.lexeme lexbuf) )
(*# 2473 "parsing/lexer.ml"*)

  | 84 ->
(*# 957 "parsing/lexer.mll"*)
            ( INFIXOP1(Lexing.lexeme lexbuf) )
(*# 2478 "parsing/lexer.ml"*)

  | 85 ->
(*# 959 "parsing/lexer.mll"*)
            ( INFIXOP2(Lexing.lexeme lexbuf) )
(*# 2483 "parsing/lexer.ml"*)

  | 86 ->
(*# 961 "parsing/lexer.mll"*)
            ( INFIXOP4(Lexing.lexeme lexbuf) )
(*# 2488 "parsing/lexer.ml"*)

  | 87 ->
(*# 962 "parsing/lexer.mll"*)
            ( PERCENT )
(*# 2493 "parsing/lexer.ml"*)

  | 88 ->
(*# 964 "parsing/lexer.mll"*)
            ( INFIXOP3(Lexing.lexeme lexbuf) )
(*# 2498 "parsing/lexer.ml"*)

  | 89 ->
(*# 966 "parsing/lexer.mll"*)
            ( SHARPOP(Lexing.lexeme lexbuf) )
(*# 2503 "parsing/lexer.ml"*)

  | 90 ->
(*# 967 "parsing/lexer.mll"*)
        (
      if !if_then_else <> Dir_out then
        if !if_then_else = Dir_if_true then
          raise (Error (Unterminated_if, Location.curr lexbuf))
        else raise (Error(Unterminated_else, Location.curr lexbuf))
      else
        EOF

    )
(*# 2516 "parsing/lexer.ml"*)

  | 91 ->
(*# 977 "parsing/lexer.mll"*)
      ( raise (Error(Illegal_character (Lexing.lexeme_char lexbuf 0),
                     Location.curr lexbuf))
      )
(*# 2523 "parsing/lexer.ml"*)

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf;
      __ocaml_lex_token_rec lexbuf __ocaml_lex_state

and comment lexbuf =
    __ocaml_lex_comment_rec lexbuf 132
and __ocaml_lex_comment_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
(*# 983 "parsing/lexer.mll"*)
      ( comment_start_loc := (Location.curr lexbuf) :: !comment_start_loc;
        store_lexeme lexbuf;
        comment lexbuf;
      )
(*# 2538 "parsing/lexer.ml"*)

  | 1 ->
(*# 988 "parsing/lexer.mll"*)
      ( match !comment_start_loc with
        | [] -> assert false
        | [_] -> comment_start_loc := []; Location.curr lexbuf
        | _ :: l -> comment_start_loc := l;
                  store_lexeme lexbuf;
                  comment lexbuf;
       )
(*# 2549 "parsing/lexer.ml"*)

  | 2 ->
(*# 996 "parsing/lexer.mll"*)
      (
        string_start_loc := Location.curr lexbuf;
        store_string_char '"';
        is_in_string := true;
        begin try string lexbuf
        with Error (Unterminated_string, str_start) ->
          match !comment_start_loc with
          | [] -> assert false
          | loc :: _ ->
            let start = List.hd (List.rev !comment_start_loc) in
            comment_start_loc := [];
            raise (Error (Unterminated_string_in_comment (start, str_start),
                          loc))
        end;
        is_in_string := false;
        store_string_char '"';
        comment lexbuf )
(*# 2570 "parsing/lexer.ml"*)

  | 3 ->
(*# 1014 "parsing/lexer.mll"*)
      (
        let delim = Lexing.lexeme lexbuf in
        let delim = String.sub delim 1 (String.length delim - 2) in
        string_start_loc := Location.curr lexbuf;
        store_lexeme lexbuf;
        is_in_string := true;
        begin try quoted_string delim lexbuf
        with Error (Unterminated_string, str_start) ->
          match !comment_start_loc with
          | [] -> assert false
          | loc :: _ ->
            let start = List.hd (List.rev !comment_start_loc) in
            comment_start_loc := [];
            raise (Error (Unterminated_string_in_comment (start, str_start),
                          loc))
        end;
        is_in_string := false;
        store_string_char '|';
        store_string delim;
        store_string_char '}';
        comment lexbuf )
(*# 2595 "parsing/lexer.ml"*)

  | 4 ->
(*# 1037 "parsing/lexer.mll"*)
      ( store_lexeme lexbuf; comment lexbuf )
(*# 2600 "parsing/lexer.ml"*)

  | 5 ->
(*# 1039 "parsing/lexer.mll"*)
      ( update_loc lexbuf None 1 false 1;
        store_lexeme lexbuf;
        comment lexbuf
      )
(*# 2608 "parsing/lexer.ml"*)

  | 6 ->
(*# 1044 "parsing/lexer.mll"*)
      ( store_lexeme lexbuf; comment lexbuf )
(*# 2613 "parsing/lexer.ml"*)

  | 7 ->
(*# 1046 "parsing/lexer.mll"*)
      ( store_lexeme lexbuf; comment lexbuf )
(*# 2618 "parsing/lexer.ml"*)

  | 8 ->
(*# 1048 "parsing/lexer.mll"*)
      ( store_lexeme lexbuf; comment lexbuf )
(*# 2623 "parsing/lexer.ml"*)

  | 9 ->
(*# 1050 "parsing/lexer.mll"*)
      ( store_lexeme lexbuf; comment lexbuf )
(*# 2628 "parsing/lexer.ml"*)

  | 10 ->
(*# 1052 "parsing/lexer.mll"*)
      ( match !comment_start_loc with
        | [] -> assert false
        | loc :: _ ->
          let start = List.hd (List.rev !comment_start_loc) in
          comment_start_loc := [];
          raise (Error (Unterminated_comment start, loc))
      )
(*# 2639 "parsing/lexer.ml"*)

  | 11 ->
(*# 1060 "parsing/lexer.mll"*)
      ( update_loc lexbuf None 1 false 0;
        store_lexeme lexbuf;
        comment lexbuf
      )
(*# 2647 "parsing/lexer.ml"*)

  | 12 ->
(*# 1065 "parsing/lexer.mll"*)
      ( store_lexeme lexbuf; comment lexbuf )
(*# 2652 "parsing/lexer.ml"*)

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf;
      __ocaml_lex_comment_rec lexbuf __ocaml_lex_state

and string lexbuf =
  lexbuf.Lexing.lex_mem <- Array.make 2 (-1) ;   __ocaml_lex_string_rec lexbuf 164
and __ocaml_lex_string_rec lexbuf __ocaml_lex_state =
  match Lexing.new_engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
(*# 1069 "parsing/lexer.mll"*)
      ( () )
(*# 2664 "parsing/lexer.ml"*)

  | 1 ->
let
(*# 1070 "parsing/lexer.mll"*)
                                  space
(*# 2670 "parsing/lexer.ml"*)
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_mem.(0) lexbuf.Lexing.lex_curr_pos in
(*# 1071 "parsing/lexer.mll"*)
      ( update_loc lexbuf None 1 false (String.length space);
        string lexbuf
      )
(*# 2676 "parsing/lexer.ml"*)

  | 2 ->
(*# 1075 "parsing/lexer.mll"*)
      ( store_string_char(char_for_backslash(Lexing.lexeme_char lexbuf 1));
        string lexbuf )
(*# 2682 "parsing/lexer.ml"*)

  | 3 ->
(*# 1078 "parsing/lexer.mll"*)
      ( store_string_char(char_for_decimal_code lexbuf 1);
         string lexbuf )
(*# 2688 "parsing/lexer.ml"*)

  | 4 ->
(*# 1081 "parsing/lexer.mll"*)
      ( store_string_char(char_for_hexadecimal_code lexbuf 2);
         string lexbuf )
(*# 2694 "parsing/lexer.ml"*)

  | 5 ->
(*# 1084 "parsing/lexer.mll"*)
      ( if in_comment ()
        then string lexbuf
        else begin
(*  Should be an error, but we are very lax.
          raise (Error (Illegal_escape (Lexing.lexeme lexbuf),
                        Location.curr lexbuf))
*)
          let loc = Location.curr lexbuf in
          Location.prerr_warning loc Warnings.Illegal_backslash;
          store_string_char (Lexing.lexeme_char lexbuf 0);
          store_string_char (Lexing.lexeme_char lexbuf 1);
          string lexbuf
        end
      )
(*# 2712 "parsing/lexer.ml"*)

  | 6 ->
(*# 1099 "parsing/lexer.mll"*)
      ( if not (in_comment ()) then
          Location.prerr_warning (Location.curr lexbuf) Warnings.Eol_in_string;
        update_loc lexbuf None 1 false 0;
        store_lexeme lexbuf;
        string lexbuf
      )
(*# 2722 "parsing/lexer.ml"*)

  | 7 ->
(*# 1106 "parsing/lexer.mll"*)
      ( is_in_string := false;
        raise (Error (Unterminated_string, !string_start_loc)) )
(*# 2728 "parsing/lexer.ml"*)

  | 8 ->
(*# 1109 "parsing/lexer.mll"*)
      ( store_string_char(Lexing.lexeme_char lexbuf 0);
        string lexbuf )
(*# 2734 "parsing/lexer.ml"*)

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf;
      __ocaml_lex_string_rec lexbuf __ocaml_lex_state

and quoted_string delim lexbuf =
    __ocaml_lex_quoted_string_rec delim lexbuf 183
and __ocaml_lex_quoted_string_rec delim lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
(*# 1114 "parsing/lexer.mll"*)
      ( update_loc lexbuf None 1 false 0;
        store_lexeme lexbuf;
        quoted_string delim lexbuf
      )
(*# 2749 "parsing/lexer.ml"*)

  | 1 ->
(*# 1119 "parsing/lexer.mll"*)
      ( is_in_string := false;
        raise (Error (Unterminated_string, !string_start_loc)) )
(*# 2755 "parsing/lexer.ml"*)

  | 2 ->
(*# 1122 "parsing/lexer.mll"*)
      (
        let edelim = Lexing.lexeme lexbuf in
        let edelim = String.sub edelim 1 (String.length edelim - 2) in
        if delim = edelim then ()
        else (store_lexeme lexbuf; quoted_string delim lexbuf)
      )
(*# 2765 "parsing/lexer.ml"*)

  | 3 ->
(*# 1129 "parsing/lexer.mll"*)
      ( store_string_char(Lexing.lexeme_char lexbuf 0);
        quoted_string delim lexbuf )
(*# 2771 "parsing/lexer.ml"*)

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf;
      __ocaml_lex_quoted_string_rec delim lexbuf __ocaml_lex_state

and skip_sharp_bang lexbuf =
    __ocaml_lex_skip_sharp_bang_rec lexbuf 192
and __ocaml_lex_skip_sharp_bang_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
(*# 1134 "parsing/lexer.mll"*)
       ( update_loc lexbuf None 3 false 0 )
(*# 2783 "parsing/lexer.ml"*)

  | 1 ->
(*# 1136 "parsing/lexer.mll"*)
       ( update_loc lexbuf None 1 false 0 )
(*# 2788 "parsing/lexer.ml"*)

  | 2 ->
(*# 1137 "parsing/lexer.mll"*)
       ( () )
(*# 2793 "parsing/lexer.ml"*)

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf;
      __ocaml_lex_skip_sharp_bang_rec lexbuf __ocaml_lex_state

;;

(*# 1139 "parsing/lexer.mll"*)


  let at_bol lexbuf =
    let pos = Lexing.lexeme_start_p lexbuf in
    pos.pos_cnum = pos.pos_bol

  let token_with_comments lexbuf =
    match !preprocessor with
    | None -> token lexbuf
    | Some (_init, preprocess) -> preprocess token lexbuf

  type newline_state =
    | NoLine (* There have been no blank lines yet. *)
    | NewLine
        (* There have been no blank lines, and the previous
           token was a newline. *)
    | BlankLine (* There have been blank lines. *)

  type doc_state =
    | Initial  (* There have been no docstrings yet *)

    | After of docstring list
        (* There have been docstrings, none of which were
           preceeded by a blank line *)
    | Before of docstring list * docstring list * docstring list
        (* There have been docstrings, some of which were
           preceeded by a blank line *)

  and docstring = Docstrings.docstring

  let interpret_directive lexbuf cont look_ahead =
    let if_then_else = !if_then_else in
    begin match token_with_comments lexbuf, if_then_else with
    |  IF, Dir_out  ->
        let rec skip_from_if_false () =
          let token = token_with_comments lexbuf in
          if token = EOF then
            raise (Error (Unterminated_if, Location.curr lexbuf)) else
          if token = SHARP && at_bol lexbuf then
            begin
              let token = token_with_comments lexbuf in
              match token with
              | END ->
                  begin
                    update_if_then_else Dir_out;
                    cont lexbuf
                  end
              | ELSE ->
                  begin
                    update_if_then_else Dir_if_false;
                    cont lexbuf
                  end
              | IF ->
                  raise (Error (Unexpected_directive, Location.curr lexbuf))
              | _ ->
                  if is_elif token &&
                     directive_parse token_with_comments lexbuf then
                    begin
                      update_if_then_else Dir_if_true;
                      cont lexbuf
                    end
                  else skip_from_if_false ()
            end
          else skip_from_if_false () in
        if directive_parse token_with_comments lexbuf then
          begin
            update_if_then_else Dir_if_true (* Next state: ELSE *);
            cont lexbuf
          end
        else
          skip_from_if_false ()
    | IF,  (Dir_if_false | Dir_if_true)->
        raise (Error(Unexpected_directive, Location.curr lexbuf))
    | LIDENT "elif", (Dir_if_false | Dir_out)
      -> (* when the predicate is false, it will continue eating `elif` *)
        raise (Error(Unexpected_directive, Location.curr lexbuf))
    | (LIDENT "elif" | ELSE as token), Dir_if_true ->
        (* looking for #end, however, it can not see #if anymore *)
        let rec skip_from_if_true else_seen =
          let token = token_with_comments lexbuf in
          if token = EOF then
            raise (Error (Unterminated_else, Location.curr lexbuf)) else
          if token = SHARP && at_bol lexbuf then
            begin
              let token = token_with_comments lexbuf in
              match token with
              | END ->
                  begin
                    update_if_then_else Dir_out;
                    cont lexbuf
                  end
              | IF ->
                  raise (Error (Unexpected_directive, Location.curr lexbuf))
              | ELSE ->
                  if else_seen then
                    raise (Error (Unexpected_directive, Location.curr lexbuf))
                  else
                    skip_from_if_true true
              | _ ->
                  if else_seen && is_elif token then
                    raise (Error (Unexpected_directive, Location.curr lexbuf))
                  else
                    skip_from_if_true else_seen
            end
          else skip_from_if_true else_seen in
        skip_from_if_true (token = ELSE)
    | ELSE, Dir_if_false
    | ELSE, Dir_out ->
        raise (Error(Unexpected_directive, Location.curr lexbuf))
    | END, (Dir_if_false | Dir_if_true ) ->
        update_if_then_else  Dir_out;
        cont lexbuf
    | END,  Dir_out  ->
        raise (Error(Unexpected_directive, Location.curr lexbuf))
    | token, (Dir_if_true | Dir_if_false | Dir_out) ->
        look_ahead token
    end

  let token lexbuf =
    let post_pos = lexeme_end_p lexbuf in

    let attach lines docs pre_pos =
      let open Docstrings in
        match docs, lines with
        | Initial, _ -> ()
        | After a, (NoLine | NewLine) ->
            set_post_docstrings post_pos (List.rev a);
            set_pre_docstrings pre_pos a;
        | After a, BlankLine ->
            set_post_docstrings post_pos (List.rev a);
            set_pre_extra_docstrings pre_pos (List.rev a)
        | Before(a, f, b), (NoLine | NewLine) ->
            set_post_docstrings post_pos (List.rev a);
            set_post_extra_docstrings post_pos
              (List.rev_append f (List.rev b));
            set_floating_docstrings pre_pos (List.rev f);
            set_pre_extra_docstrings pre_pos (List.rev a);
            set_pre_docstrings pre_pos b
        | Before(a, f, b), BlankLine ->
            set_post_docstrings post_pos (List.rev a);
            set_post_extra_docstrings post_pos
              (List.rev_append f (List.rev b));
            set_floating_docstrings pre_pos
              (List.rev_append f (List.rev b));
            set_pre_extra_docstrings pre_pos (List.rev a)
    in

    let rec loop lines docs lexbuf : Parser.token =
      match token_with_comments lexbuf with
      | COMMENT (s, loc) ->
          add_comment (s, loc);
          let lines' =
            match lines with
            | NoLine -> NoLine
            | NewLine -> NoLine
            | BlankLine -> BlankLine
          in
          loop lines' docs lexbuf
      | EOL ->
          let lines' =
            match lines with
            | NoLine -> NewLine
            | NewLine -> BlankLine
            | BlankLine -> BlankLine
          in
          loop lines' docs lexbuf
      | SHARP when at_bol lexbuf ->
          interpret_directive lexbuf
            (fun lexbuf -> loop lines docs lexbuf)
            (fun token -> sharp_look_ahead := Some token; SHARP)

      | DOCSTRING doc ->
          add_docstring_comment doc;
          let docs' =
            match docs, lines with
            | Initial, (NoLine | NewLine) -> After [doc]
            | Initial, BlankLine -> Before([], [], [doc])
            | After a, (NoLine | NewLine) -> After (doc :: a)
            | After a, BlankLine -> Before (a, [], [doc])
            | Before(a, f, b), (NoLine | NewLine) -> Before(a, f, doc :: b)
            | Before(a, f, b), BlankLine -> Before(a, b @ f, [doc])
          in
          loop NoLine docs' lexbuf

      | tok ->

          attach lines docs (lexeme_start_p lexbuf);

          tok


    in
      match !sharp_look_ahead with
      | None ->
           loop NoLine Initial lexbuf
      | Some token ->
           sharp_look_ahead := None ;
           token

  let init () =
    sharp_look_ahead := None;
    update_if_then_else  Dir_out;
    is_in_string := false;
    comment_start_loc := [];
    comment_list := [];
    match !preprocessor with
    | None -> ()
    | Some (init, _preprocess) -> init ()

  let rec filter_directive pos   acc lexbuf : (int * int ) list =
    match token_with_comments lexbuf with
    | SHARP when at_bol lexbuf ->
        (* ^[start_pos]#if ... #then^[end_pos] *)
        let start_pos = Lexing.lexeme_start lexbuf in
        interpret_directive lexbuf
          (fun lexbuf ->
             filter_directive
               (Lexing.lexeme_end lexbuf)
               ((pos, start_pos) :: acc)
               lexbuf

          )
          (fun _token -> filter_directive pos acc lexbuf  )
    | EOF -> (pos, Lexing.lexeme_end lexbuf) :: acc
    | _ -> filter_directive pos  acc lexbuf

  let filter_directive_from_lexbuf lexbuf =
    List.rev (filter_directive 0 [] lexbuf )

  let set_preprocessor init preprocess =
    escaped_newlines := true;
    preprocessor := Some (init, preprocess)


(*# 3035 "parsing/lexer.ml"*)

end
module Parse : sig
(*#1 "parse.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Entry points in the parser *)

val implementation : Lexing.lexbuf -> Parsetree.structure
val interface : Lexing.lexbuf -> Parsetree.signature
val toplevel_phrase : Lexing.lexbuf -> Parsetree.toplevel_phrase
val use_file : Lexing.lexbuf -> Parsetree.toplevel_phrase list
val core_type : Lexing.lexbuf -> Parsetree.core_type
val expression : Lexing.lexbuf -> Parsetree.expression
val pattern : Lexing.lexbuf -> Parsetree.pattern

end = struct
(*#1 "parse.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Entry points in the parser *)

(* Skip tokens to the end of the phrase *)

let rec skip_phrase lexbuf =
  try
    match Lexer.token lexbuf with
      Parser.SEMISEMI | Parser.EOF -> ()
    | _ -> skip_phrase lexbuf
  with
    | Lexer.Error (Lexer.Unterminated_comment _, _)
    | Lexer.Error (Lexer.Unterminated_string, _)
    | Lexer.Error (Lexer.Unterminated_string_in_comment _, _)
    | Lexer.Error (Lexer.Illegal_character _, _) -> skip_phrase lexbuf
;;

let maybe_skip_phrase lexbuf =
  if Parsing.is_current_lookahead Parser.SEMISEMI
  || Parsing.is_current_lookahead Parser.EOF
  then ()
  else skip_phrase lexbuf

let wrap parsing_fun lexbuf =
  try
    Docstrings.init ();
    Lexer.init ();
    let ast = parsing_fun Lexer.token lexbuf in
    Parsing.clear_parser();
    Docstrings.warn_bad_docstrings ();
    ast
  with
  | Lexer.Error(Lexer.Illegal_character _, _) as err
    when !Location.input_name = "//toplevel//"->
      skip_phrase lexbuf;
      raise err
  | Syntaxerr.Error _ as err
    when !Location.input_name = "//toplevel//" ->
      maybe_skip_phrase lexbuf;
      raise err
  | Parsing.Parse_error | Syntaxerr.Escape_error ->
      let loc = Location.curr lexbuf in
      if !Location.input_name = "//toplevel//"
      then maybe_skip_phrase lexbuf;
      raise(Syntaxerr.Error(Syntaxerr.Other loc))

let implementation = wrap Parser.implementation
and interface = wrap Parser.interface
and toplevel_phrase = wrap Parser.toplevel_phrase
and use_file = wrap Parser.use_file
and core_type = wrap Parser.parse_core_type
and expression = wrap Parser.parse_expression
and pattern = wrap Parser.parse_pattern

end
module Typedtree : sig
(*#1 "typedtree.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Abstract syntax tree after typing *)

open Asttypes
open Types

(* Value expressions for the core language *)

type partial = Partial | Total
type optional = Required | Optional

type attribute = Parsetree.attribute
type attributes = attribute list

type pattern =
  { pat_desc: pattern_desc;
    pat_loc: Location.t;
    pat_extra : (pat_extra * Location.t * attributes) list;
    pat_type: type_expr;
    mutable pat_env: Env.t;
    pat_attributes: attributes;
   }

and pat_extra =
  | Tpat_constraint of core_type
  | Tpat_type of Path.t * Longident.t loc
  | Tpat_unpack

and pattern_desc =
    Tpat_any
  | Tpat_var of Ident.t * string loc
  | Tpat_alias of pattern * Ident.t * string loc
  | Tpat_constant of constant
  | Tpat_tuple of pattern list
  | Tpat_construct of
      Longident.t loc * constructor_description * pattern list
  | Tpat_variant of label * pattern option * row_desc ref
  | Tpat_record of
      (Longident.t loc * label_description * pattern) list *
        closed_flag
  | Tpat_array of pattern list
  | Tpat_or of pattern * pattern * row_desc option
  | Tpat_lazy of pattern

and expression =
  { exp_desc: expression_desc;
    exp_loc: Location.t;
    exp_extra: (exp_extra * Location.t * attributes) list;
    exp_type: type_expr;
    exp_env: Env.t;
    exp_attributes: attributes;
   }

and exp_extra =
  | Texp_constraint of core_type
  | Texp_coerce of core_type option * core_type
  | Texp_open of override_flag * Path.t * Longident.t loc * Env.t
  | Texp_poly of core_type option
  | Texp_newtype of string

and expression_desc =
    Texp_ident of Path.t * Longident.t loc * Types.value_description
  | Texp_constant of constant
  | Texp_let of rec_flag * value_binding list * expression
  | Texp_function of label * case list * partial
  | Texp_apply of expression * (label * expression option * optional) list
  | Texp_match of expression * case list * case list * partial
  | Texp_try of expression * case list
  | Texp_tuple of expression list
  | Texp_construct of
      Longident.t loc * constructor_description * expression list
  | Texp_variant of label * expression option
  | Texp_record of
      (Longident.t loc * label_description * expression) list *
        expression option
  | Texp_field of expression * Longident.t loc * label_description
  | Texp_setfield of
      expression * Longident.t loc * label_description * expression
  | Texp_array of expression list
  | Texp_ifthenelse of expression * expression * expression option
  | Texp_sequence of expression * expression
  | Texp_while of expression * expression
  | Texp_for of
      Ident.t * Parsetree.pattern * expression * expression * direction_flag *
        expression
  | Texp_send of expression * meth * expression option
  | Texp_new of Path.t * Longident.t loc * Types.class_declaration
  | Texp_instvar of Path.t * Path.t * string loc
  | Texp_setinstvar of Path.t * Path.t * string loc * expression
  | Texp_override of Path.t * (Path.t * string loc * expression) list
  | Texp_letmodule of Ident.t * string loc * module_expr * expression
  | Texp_assert of expression
  | Texp_lazy of expression
  | Texp_object of class_structure * string list
  | Texp_pack of module_expr

and meth =
    Tmeth_name of string
  | Tmeth_val of Ident.t

and case =
    {
     c_lhs: pattern;
     c_guard: expression option;
     c_rhs: expression;
    }

(* Value expressions for the class language *)

and class_expr =
    {
     cl_desc: class_expr_desc;
     cl_loc: Location.t;
     cl_type: Types.class_type;
     cl_env: Env.t;
     cl_attributes: attributes;
    }

and class_expr_desc =
    Tcl_ident of Path.t * Longident.t loc * core_type list
  | Tcl_structure of class_structure
  | Tcl_fun of
      label * pattern * (Ident.t * string loc * expression) list * class_expr *
        partial
  | Tcl_apply of class_expr * (label * expression option * optional) list
  | Tcl_let of rec_flag * value_binding list *
                  (Ident.t * string loc * expression) list * class_expr
  | Tcl_constraint of
      class_expr * class_type option * string list * string list * Concr.t
    (* Visible instance variables, methods and concretes methods *)

and class_structure =
  {
   cstr_self: pattern;
   cstr_fields: class_field list;
   cstr_type: Types.class_signature;
   cstr_meths: Ident.t Meths.t;
  }

and class_field =
   {
    cf_desc: class_field_desc;
    cf_loc: Location.t;
    cf_attributes: attributes;
  }

and class_field_kind =
  | Tcfk_virtual of core_type
  | Tcfk_concrete of override_flag * expression

and class_field_desc =
    Tcf_inherit of
      override_flag * class_expr * string option * (string * Ident.t) list *
        (string * Ident.t) list
    (* Inherited instance variables and concrete methods *)
  | Tcf_val of string loc * mutable_flag * Ident.t * class_field_kind * bool
  | Tcf_method of string loc * private_flag * class_field_kind
  | Tcf_constraint of core_type * core_type
  | Tcf_initializer of expression
  | Tcf_attribute of attribute

(* Value expressions for the module language *)

and module_expr =
  { mod_desc: module_expr_desc;
    mod_loc: Location.t;
    mod_type: Types.module_type;
    mod_env: Env.t;
    mod_attributes: attributes;
   }

and module_type_constraint =
  Tmodtype_implicit
| Tmodtype_explicit of module_type

and module_expr_desc =
    Tmod_ident of Path.t * Longident.t loc
  | Tmod_structure of structure
  | Tmod_functor of Ident.t * string loc * module_type option * module_expr
  | Tmod_apply of module_expr * module_expr * module_coercion
  | Tmod_constraint of
      module_expr * Types.module_type * module_type_constraint * module_coercion
  | Tmod_unpack of expression * Types.module_type

and structure = {
  str_items : structure_item list;
  str_type : Types.signature;
  str_final_env : Env.t;
}

and structure_item =
  { str_desc : structure_item_desc;
    str_loc : Location.t;
    str_env : Env.t
  }

and structure_item_desc =
    Tstr_eval of expression * attributes
  | Tstr_value of rec_flag * value_binding list
  | Tstr_primitive of value_description
  | Tstr_type of type_declaration list
  | Tstr_typext of type_extension
  | Tstr_exception of extension_constructor
  | Tstr_module of module_binding
  | Tstr_recmodule of module_binding list
  | Tstr_modtype of module_type_declaration
  | Tstr_open of open_description
  | Tstr_class of (class_declaration * string list * virtual_flag) list
  | Tstr_class_type of (Ident.t * string loc * class_type_declaration) list
  | Tstr_include of include_declaration
  | Tstr_attribute of attribute

and module_binding =
    {
     mb_id: Ident.t;
     mb_name: string loc;
     mb_expr: module_expr;
     mb_attributes: attributes;
     mb_loc: Location.t;
    }

and value_binding =
  {
    vb_pat: pattern;
    vb_expr: expression;
    vb_attributes: attributes;
    vb_loc: Location.t;
  }

and module_coercion =
    Tcoerce_none
  | Tcoerce_structure of (int * module_coercion) list *
                         (Ident.t * int * module_coercion) list
  | Tcoerce_functor of module_coercion * module_coercion
  | Tcoerce_primitive of Ident.t * Primitive.description
  | Tcoerce_alias of Path.t * module_coercion

and module_type =
  { mty_desc: module_type_desc;
    mty_type : Types.module_type;
    mty_env : Env.t;
    mty_loc: Location.t;
    mty_attributes: attributes;
   }

and module_type_desc =
    Tmty_ident of Path.t * Longident.t loc
  | Tmty_signature of signature
  | Tmty_functor of Ident.t * string loc * module_type option * module_type
  | Tmty_with of module_type * (Path.t * Longident.t loc * with_constraint) list
  | Tmty_typeof of module_expr
  | Tmty_alias of Path.t * Longident.t loc

and signature = {
  sig_items : signature_item list;
  sig_type : Types.signature;
  sig_final_env : Env.t;
}

and signature_item =
  { sig_desc: signature_item_desc;
    sig_env : Env.t; (* BINANNOT ADDED *)
    sig_loc: Location.t }

and signature_item_desc =
    Tsig_value of value_description
  | Tsig_type of type_declaration list
  | Tsig_typext of type_extension
  | Tsig_exception of extension_constructor
  | Tsig_module of module_declaration
  | Tsig_recmodule of module_declaration list
  | Tsig_modtype of module_type_declaration
  | Tsig_open of open_description
  | Tsig_include of include_description
  | Tsig_class of class_description list
  | Tsig_class_type of class_type_declaration list
  | Tsig_attribute of attribute

and module_declaration =
    {
     md_id: Ident.t;
     md_name: string loc;
     md_type: module_type;
     md_attributes: attributes;
     md_loc: Location.t;
    }

and module_type_declaration =
    {
     mtd_id: Ident.t;
     mtd_name: string loc;
     mtd_type: module_type option;
     mtd_attributes: attributes;
     mtd_loc: Location.t;
    }

and open_description =
    {
     open_path: Path.t;
     open_txt: Longident.t loc;
     open_override: override_flag;
     open_loc: Location.t;
     open_attributes: attribute list;
    }

and 'a include_infos =
    {
     incl_mod: 'a;
     incl_type: Types.signature;
     incl_loc: Location.t;
     incl_attributes: attribute list;
    }

and include_description = module_type include_infos

and include_declaration = module_expr include_infos

and with_constraint =
    Twith_type of type_declaration
  | Twith_module of Path.t * Longident.t loc
  | Twith_typesubst of type_declaration
  | Twith_modsubst of Path.t * Longident.t loc

and core_type =
(* mutable because of [Typeclass.declare_method] *)
  { mutable ctyp_desc : core_type_desc;
    mutable ctyp_type : type_expr;
    ctyp_env : Env.t; (* BINANNOT ADDED *)
    ctyp_loc : Location.t;
    ctyp_attributes: attributes;
   }

and core_type_desc =
    Ttyp_any
  | Ttyp_var of string
  | Ttyp_arrow of label * core_type * core_type
  | Ttyp_tuple of core_type list
  | Ttyp_constr of Path.t * Longident.t loc * core_type list
  | Ttyp_object of (string * attributes * core_type) list * closed_flag
  | Ttyp_class of Path.t * Longident.t loc * core_type list
  | Ttyp_alias of core_type * string
  | Ttyp_variant of row_field list * closed_flag * label list option
  | Ttyp_poly of string list * core_type
  | Ttyp_package of package_type

and package_type = {
  pack_path : Path.t;
  pack_fields : (Longident.t loc * core_type) list;
  pack_type : Types.module_type;
  pack_txt : Longident.t loc;
}

and row_field =
    Ttag of label * attributes * bool * core_type list
  | Tinherit of core_type

and value_description =
  { val_id: Ident.t;
    val_name: string loc;
    val_desc: core_type;
    val_val: Types.value_description;
    val_prim: string list;
    val_loc: Location.t;
    val_attributes: attributes;
    }

and type_declaration =
  {
    typ_id: Ident.t;
    typ_name: string loc;
    typ_params: (core_type * variance) list;
    typ_type: Types.type_declaration;
    typ_cstrs: (core_type * core_type * Location.t) list;
    typ_kind: type_kind;
    typ_private: private_flag;
    typ_manifest: core_type option;
    typ_loc: Location.t;
    typ_attributes: attributes;
   }

and type_kind =
    Ttype_abstract
  | Ttype_variant of constructor_declaration list
  | Ttype_record of label_declaration list
  | Ttype_open

and label_declaration =
    {
     ld_id: Ident.t;
     ld_name: string loc;
     ld_mutable: mutable_flag;
     ld_type: core_type;
     ld_loc: Location.t;
     ld_attributes: attributes;
    }

and constructor_declaration =
    {
     cd_id: Ident.t;
     cd_name: string loc;
     cd_args: core_type list;
     cd_res: core_type option;
     cd_loc: Location.t;
     cd_attributes: attributes;
    }

and type_extension =
  {
    tyext_path: Path.t;
    tyext_txt: Longident.t loc;
    tyext_params: (core_type * variance) list;
    tyext_constructors: extension_constructor list;
    tyext_private: private_flag;
    tyext_attributes: attributes;
  }

and extension_constructor =
  {
    ext_id: Ident.t;
    ext_name: string loc;
    ext_type : Types.extension_constructor;
    ext_kind : extension_constructor_kind;
    ext_loc : Location.t;
    ext_attributes: attributes;
  }

and extension_constructor_kind =
    Text_decl of core_type list * core_type option
  | Text_rebind of Path.t * Longident.t loc

and class_type =
    {
     cltyp_desc: class_type_desc;
     cltyp_type: Types.class_type;
     cltyp_env: Env.t;
     cltyp_loc: Location.t;
     cltyp_attributes: attributes;
    }

and class_type_desc =
    Tcty_constr of Path.t * Longident.t loc * core_type list
  | Tcty_signature of class_signature
  | Tcty_arrow of label * core_type * class_type

and class_signature = {
    csig_self : core_type;
    csig_fields : class_type_field list;
    csig_type : Types.class_signature;
  }

and class_type_field = {
    ctf_desc: class_type_field_desc;
    ctf_loc: Location.t;
    ctf_attributes: attributes;
  }

and class_type_field_desc =
  | Tctf_inherit of class_type
  | Tctf_val of (string * mutable_flag * virtual_flag * core_type)
  | Tctf_method of (string * private_flag * virtual_flag * core_type)
  | Tctf_constraint of (core_type * core_type)
  | Tctf_attribute of attribute

and class_declaration =
  class_expr class_infos

and class_description =
  class_type class_infos

and class_type_declaration =
  class_type class_infos

and 'a class_infos =
  { ci_virt: virtual_flag;
    ci_params: (core_type * variance) list;
    ci_id_name : string loc;
    ci_id_class: Ident.t;
    ci_id_class_type : Ident.t;
    ci_id_object : Ident.t;
    ci_id_typesharp : Ident.t;
    ci_expr: 'a;
    ci_decl: Types.class_declaration;
    ci_type_decl : Types.class_type_declaration;
    ci_loc: Location.t;
    ci_attributes: attributes;
   }

(* Auxiliary functions over the a.s.t. *)

val iter_pattern_desc: (pattern -> unit) -> pattern_desc -> unit
val map_pattern_desc: (pattern -> pattern) -> pattern_desc -> pattern_desc

val let_bound_idents: value_binding list -> Ident.t list
val rev_let_bound_idents: value_binding list -> Ident.t list

val let_bound_idents_with_loc:
    value_binding list -> (Ident.t * string loc) list

(* Alpha conversion of patterns *)
val alpha_pat: (Ident.t * Ident.t) list -> pattern -> pattern

val mknoloc: 'a -> 'a Asttypes.loc
val mkloc: 'a -> Location.t -> 'a Asttypes.loc

val pat_bound_idents: pattern -> (Ident.t * string Asttypes.loc) list

end = struct
(*#1 "typedtree.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Abstract syntax tree after typing *)

open Misc
open Asttypes
open Types

(* Value expressions for the core language *)

type partial = Partial | Total
type optional = Required | Optional

type attribute = Parsetree.attribute
type attributes = attribute list

type pattern =
  { pat_desc: pattern_desc;
    pat_loc: Location.t;
    pat_extra : (pat_extra * Location.t * attribute list) list;
    pat_type: type_expr;
    mutable pat_env: Env.t;
    pat_attributes: attribute list;
   }

and pat_extra =
  | Tpat_constraint of core_type
  | Tpat_type of Path.t * Longident.t loc
  | Tpat_unpack

and pattern_desc =
    Tpat_any
  | Tpat_var of Ident.t * string loc
  | Tpat_alias of pattern * Ident.t * string loc
  | Tpat_constant of constant
  | Tpat_tuple of pattern list
  | Tpat_construct of
      Longident.t loc * constructor_description * pattern list
  | Tpat_variant of label * pattern option * row_desc ref
  | Tpat_record of
      (Longident.t loc * label_description * pattern) list *
        closed_flag
  | Tpat_array of pattern list
  | Tpat_or of pattern * pattern * row_desc option
  | Tpat_lazy of pattern

and expression =
  { exp_desc: expression_desc;
    exp_loc: Location.t;
    exp_extra: (exp_extra * Location.t * attribute list) list;
    exp_type: type_expr;
    exp_env: Env.t;
    exp_attributes: attribute list;
   }

and exp_extra =
  | Texp_constraint of core_type
  | Texp_coerce of core_type option * core_type
  | Texp_open of override_flag * Path.t * Longident.t loc * Env.t
  | Texp_poly of core_type option
  | Texp_newtype of string

and expression_desc =
    Texp_ident of Path.t * Longident.t loc * Types.value_description
  | Texp_constant of constant
  | Texp_let of rec_flag * value_binding list * expression
  | Texp_function of label * case list * partial
  | Texp_apply of expression * (label * expression option * optional) list
  | Texp_match of expression * case list * case list * partial
  | Texp_try of expression * case list
  | Texp_tuple of expression list
  | Texp_construct of
      Longident.t loc * constructor_description * expression list
  | Texp_variant of label * expression option
  | Texp_record of
      (Longident.t loc * label_description * expression) list *
        expression option
  | Texp_field of expression * Longident.t loc * label_description
  | Texp_setfield of
      expression * Longident.t loc * label_description * expression
  | Texp_array of expression list
  | Texp_ifthenelse of expression * expression * expression option
  | Texp_sequence of expression * expression
  | Texp_while of expression * expression
  | Texp_for of
      Ident.t * Parsetree.pattern * expression * expression * direction_flag *
        expression
  | Texp_send of expression * meth * expression option
  | Texp_new of Path.t * Longident.t loc * Types.class_declaration
  | Texp_instvar of Path.t * Path.t * string loc
  | Texp_setinstvar of Path.t * Path.t * string loc * expression
  | Texp_override of Path.t * (Path.t * string loc * expression) list
  | Texp_letmodule of Ident.t * string loc * module_expr * expression
  | Texp_assert of expression
  | Texp_lazy of expression
  | Texp_object of class_structure * string list
  | Texp_pack of module_expr

and meth =
    Tmeth_name of string
  | Tmeth_val of Ident.t

and case =
    {
     c_lhs: pattern;
     c_guard: expression option;
     c_rhs: expression;
    }

(* Value expressions for the class language *)

and class_expr =
    {
     cl_desc: class_expr_desc;
     cl_loc: Location.t;
     cl_type: Types.class_type;
     cl_env: Env.t;
     cl_attributes: attribute list;
    }

and class_expr_desc =
    Tcl_ident of Path.t * Longident.t loc * core_type list
  | Tcl_structure of class_structure
  | Tcl_fun of
      label * pattern * (Ident.t * string loc * expression) list * class_expr *
        partial
  | Tcl_apply of class_expr * (label * expression option * optional) list
  | Tcl_let of rec_flag * value_binding list *
                  (Ident.t * string loc * expression) list * class_expr
  | Tcl_constraint of
      class_expr * class_type option * string list * string list * Concr.t
    (* Visible instance variables, methods and concretes methods *)

and class_structure =
  {
   cstr_self: pattern;
   cstr_fields: class_field list;
   cstr_type: Types.class_signature;
   cstr_meths: Ident.t Meths.t;
  }

and class_field =
   {
    cf_desc: class_field_desc;
    cf_loc: Location.t;
    cf_attributes: attribute list;
  }

and class_field_kind =
  | Tcfk_virtual of core_type
  | Tcfk_concrete of override_flag * expression

and class_field_desc =
    Tcf_inherit of
      override_flag * class_expr * string option * (string * Ident.t) list *
        (string * Ident.t) list
    (* Inherited instance variables and concrete methods *)
  | Tcf_val of string loc * mutable_flag * Ident.t * class_field_kind * bool
  | Tcf_method of string loc * private_flag * class_field_kind
  | Tcf_constraint of core_type * core_type
  | Tcf_initializer of expression
  | Tcf_attribute of attribute

(* Value expressions for the module language *)

and module_expr =
  { mod_desc: module_expr_desc;
    mod_loc: Location.t;
    mod_type: Types.module_type;
    mod_env: Env.t;
    mod_attributes: attribute list;
   }

and module_type_constraint =
  Tmodtype_implicit
| Tmodtype_explicit of module_type

and module_expr_desc =
    Tmod_ident of Path.t * Longident.t loc
  | Tmod_structure of structure
  | Tmod_functor of Ident.t * string loc * module_type option * module_expr
  | Tmod_apply of module_expr * module_expr * module_coercion
  | Tmod_constraint of
      module_expr * Types.module_type * module_type_constraint * module_coercion
  | Tmod_unpack of expression * Types.module_type

and structure = {
  str_items : structure_item list;
  str_type : Types.signature;
  str_final_env : Env.t;
}

and structure_item =
  { str_desc : structure_item_desc;
    str_loc : Location.t;
    str_env : Env.t
  }

and structure_item_desc =
    Tstr_eval of expression * attributes
  | Tstr_value of rec_flag * value_binding list
  | Tstr_primitive of value_description
  | Tstr_type of type_declaration list
  | Tstr_typext of type_extension
  | Tstr_exception of extension_constructor
  | Tstr_module of module_binding
  | Tstr_recmodule of module_binding list
  | Tstr_modtype of module_type_declaration
  | Tstr_open of open_description
  | Tstr_class of (class_declaration * string list * virtual_flag) list
  | Tstr_class_type of (Ident.t * string loc * class_type_declaration) list
  | Tstr_include of include_declaration
  | Tstr_attribute of attribute

and module_binding =
    {
     mb_id: Ident.t;
     mb_name: string loc;
     mb_expr: module_expr;
     mb_attributes: attribute list;
     mb_loc: Location.t;
    }

and value_binding =
  {
    vb_pat: pattern;
    vb_expr: expression;
    vb_attributes: attributes;
    vb_loc: Location.t;
  }

and module_coercion =
    Tcoerce_none
  | Tcoerce_structure of (int * module_coercion) list *
                         (Ident.t * int * module_coercion) list
  | Tcoerce_functor of module_coercion * module_coercion
  | Tcoerce_primitive of Ident.t *  Primitive.description
  | Tcoerce_alias of Path.t * module_coercion

and module_type =
  { mty_desc: module_type_desc;
    mty_type : Types.module_type;
    mty_env : Env.t;
    mty_loc: Location.t;
    mty_attributes: attribute list;
   }

and module_type_desc =
    Tmty_ident of Path.t * Longident.t loc
  | Tmty_signature of signature
  | Tmty_functor of Ident.t * string loc * module_type option * module_type
  | Tmty_with of module_type * (Path.t * Longident.t loc * with_constraint) list
  | Tmty_typeof of module_expr
  | Tmty_alias of Path.t * Longident.t loc

and signature = {
  sig_items : signature_item list;
  sig_type : Types.signature;
  sig_final_env : Env.t;
}

and signature_item =
  { sig_desc: signature_item_desc;
    sig_env : Env.t; (* BINANNOT ADDED *)
    sig_loc: Location.t }

and signature_item_desc =
    Tsig_value of value_description
  | Tsig_type of type_declaration list
  | Tsig_typext of type_extension
  | Tsig_exception of extension_constructor
  | Tsig_module of module_declaration
  | Tsig_recmodule of module_declaration list
  | Tsig_modtype of module_type_declaration
  | Tsig_open of open_description
  | Tsig_include of include_description
  | Tsig_class of class_description list
  | Tsig_class_type of class_type_declaration list
  | Tsig_attribute of attribute

and module_declaration =
    {
     md_id: Ident.t;
     md_name: string loc;
     md_type: module_type;
     md_attributes: attribute list;
     md_loc: Location.t;
    }

and module_type_declaration =
    {
     mtd_id: Ident.t;
     mtd_name: string loc;
     mtd_type: module_type option;
     mtd_attributes: attribute list;
     mtd_loc: Location.t;
    }

and open_description =
    {
     open_path: Path.t;
     open_txt: Longident.t loc;
     open_override: override_flag;
     open_loc: Location.t;
     open_attributes: attribute list;
    }

and 'a include_infos =
    {
     incl_mod: 'a;
     incl_type: Types.signature;
     incl_loc: Location.t;
     incl_attributes: attribute list;
    }

and include_description = module_type include_infos

and include_declaration = module_expr include_infos

and with_constraint =
    Twith_type of type_declaration
  | Twith_module of Path.t * Longident.t loc
  | Twith_typesubst of type_declaration
  | Twith_modsubst of Path.t * Longident.t loc

and core_type =
(* mutable because of [Typeclass.declare_method] *)
  { mutable ctyp_desc : core_type_desc;
    mutable ctyp_type : type_expr;
    ctyp_env : Env.t; (* BINANNOT ADDED *)
    ctyp_loc : Location.t;
    ctyp_attributes: attribute list;
   }

and core_type_desc =
    Ttyp_any
  | Ttyp_var of string
  | Ttyp_arrow of label * core_type * core_type
  | Ttyp_tuple of core_type list
  | Ttyp_constr of Path.t * Longident.t loc * core_type list
  | Ttyp_object of (string * attributes * core_type) list * closed_flag
  | Ttyp_class of Path.t * Longident.t loc * core_type list
  | Ttyp_alias of core_type * string
  | Ttyp_variant of row_field list * closed_flag * label list option
  | Ttyp_poly of string list * core_type
  | Ttyp_package of package_type

and package_type = {
  pack_path : Path.t;
  pack_fields : (Longident.t loc * core_type) list;
  pack_type : Types.module_type;
  pack_txt : Longident.t loc;
}

and row_field =
    Ttag of label * attributes * bool * core_type list
  | Tinherit of core_type

and value_description =
  { val_id: Ident.t;
    val_name: string loc;
    val_desc: core_type;
    val_val: Types.value_description;
    val_prim: string list;
    val_loc: Location.t;
    val_attributes: attribute list;
    }

and type_declaration =
  { typ_id: Ident.t;
    typ_name: string loc;
    typ_params: (core_type * variance) list;
    typ_type: Types.type_declaration;
    typ_cstrs: (core_type * core_type * Location.t) list;
    typ_kind: type_kind;
    typ_private: private_flag;
    typ_manifest: core_type option;
    typ_loc: Location.t;
    typ_attributes: attribute list;
   }

and type_kind =
    Ttype_abstract
  | Ttype_variant of constructor_declaration list
  | Ttype_record of label_declaration list
  | Ttype_open

and label_declaration =
    {
     ld_id: Ident.t;
     ld_name: string loc;
     ld_mutable: mutable_flag;
     ld_type: core_type;
     ld_loc: Location.t;
     ld_attributes: attribute list;
    }

and constructor_declaration =
    {
     cd_id: Ident.t;
     cd_name: string loc;
     cd_args: core_type list;
     cd_res: core_type option;
     cd_loc: Location.t;
     cd_attributes: attribute list;
    }

and type_extension =
  {
    tyext_path: Path.t;
    tyext_txt: Longident.t loc;
    tyext_params: (core_type * variance) list;
    tyext_constructors: extension_constructor list;
    tyext_private: private_flag;
    tyext_attributes: attribute list;
  }

and extension_constructor =
  {
    ext_id: Ident.t;
    ext_name: string loc;
    ext_type : Types.extension_constructor;
    ext_kind : extension_constructor_kind;
    ext_loc : Location.t;
    ext_attributes: attribute list;
  }

and extension_constructor_kind =
    Text_decl of core_type list * core_type option
  | Text_rebind of Path.t * Longident.t loc

and class_type =
    {
     cltyp_desc: class_type_desc;
     cltyp_type: Types.class_type;
     cltyp_env: Env.t;
     cltyp_loc: Location.t;
     cltyp_attributes: attribute list;
    }

and class_type_desc =
    Tcty_constr of Path.t * Longident.t loc * core_type list
  | Tcty_signature of class_signature
  | Tcty_arrow of label * core_type * class_type

and class_signature = {
    csig_self : core_type;
    csig_fields : class_type_field list;
    csig_type : Types.class_signature;
  }

and class_type_field = {
    ctf_desc: class_type_field_desc;
    ctf_loc: Location.t;
    ctf_attributes: attribute list;
  }

and class_type_field_desc =
  | Tctf_inherit of class_type
  | Tctf_val of (string * mutable_flag * virtual_flag * core_type)
  | Tctf_method of (string * private_flag * virtual_flag * core_type)
  | Tctf_constraint of (core_type * core_type)
  | Tctf_attribute of attribute

and class_declaration =
  class_expr class_infos

and class_description =
  class_type class_infos

and class_type_declaration =
  class_type class_infos

and 'a class_infos =
  { ci_virt: virtual_flag;
    ci_params: (core_type * variance) list;
    ci_id_name : string loc;
    ci_id_class: Ident.t;
    ci_id_class_type : Ident.t;
    ci_id_object : Ident.t;
    ci_id_typesharp : Ident.t;
    ci_expr: 'a;
    ci_decl: Types.class_declaration;
    ci_type_decl : Types.class_type_declaration;
    ci_loc: Location.t;
    ci_attributes: attribute list;
   }

(* Auxiliary functions over the a.s.t. *)

let iter_pattern_desc f = function
  | Tpat_alias(p, _, _) -> f p
  | Tpat_tuple patl -> List.iter f patl
  | Tpat_construct(_, cstr, patl) -> List.iter f patl
  | Tpat_variant(_, pat, _) -> may f pat
  | Tpat_record (lbl_pat_list, _) ->
      List.iter (fun (_, lbl, pat) -> f pat) lbl_pat_list
  | Tpat_array patl -> List.iter f patl
  | Tpat_or(p1, p2, _) -> f p1; f p2
  | Tpat_lazy p -> f p
  | Tpat_any
  | Tpat_var _
  | Tpat_constant _ -> ()

let map_pattern_desc f d =
  match d with
  | Tpat_alias (p1, id, s) ->
      Tpat_alias (f p1, id, s)
  | Tpat_tuple pats ->
      Tpat_tuple (List.map f pats)
  | Tpat_record (lpats, closed) ->
      Tpat_record (List.map (fun (lid, l,p) -> lid, l, f p) lpats, closed)
  | Tpat_construct (lid, c,pats) ->
      Tpat_construct (lid, c, List.map f pats)
  | Tpat_array pats ->
      Tpat_array (List.map f pats)
  | Tpat_lazy p1 -> Tpat_lazy (f p1)
  | Tpat_variant (x1, Some p1, x2) ->
      Tpat_variant (x1, Some (f p1), x2)
  | Tpat_or (p1,p2,path) ->
      Tpat_or (f p1, f p2, path)
  | Tpat_var _
  | Tpat_constant _
  | Tpat_any
  | Tpat_variant (_,None,_) -> d

(* List the identifiers bound by a pattern or a let *)

let idents = ref([]: (Ident.t * string loc) list)

let rec bound_idents pat =
  match pat.pat_desc with
  | Tpat_var (id,s) -> idents := (id,s) :: !idents
  | Tpat_alias(p, id, s ) ->
      bound_idents p; idents := (id,s) :: !idents
  | Tpat_or(p1, _, _) ->
      (* Invariant : both arguments binds the same variables *)
      bound_idents p1
  | d -> iter_pattern_desc bound_idents d

let pat_bound_idents pat =
  idents := []; bound_idents pat; let res = !idents in idents := []; res

let rev_let_bound_idents_with_loc bindings =
  idents := [];
  List.iter (fun vb -> bound_idents vb.vb_pat) bindings;
  let res = !idents in idents := []; res

let let_bound_idents_with_loc pat_expr_list =
  List.rev(rev_let_bound_idents_with_loc pat_expr_list)

let rev_let_bound_idents pat = List.map fst (rev_let_bound_idents_with_loc pat)
let let_bound_idents pat = List.map  fst (let_bound_idents_with_loc pat)

let alpha_var env id = List.assoc id env

let rec alpha_pat env p = match p.pat_desc with
| Tpat_var (id, s) -> (* note the ``Not_found'' case *)
    {p with pat_desc =
     try Tpat_var (alpha_var env id, s) with
     | Not_found -> Tpat_any}
| Tpat_alias (p1, id, s) ->
    let new_p =  alpha_pat env p1 in
    begin try
      {p with pat_desc = Tpat_alias (new_p, alpha_var env id, s)}
    with
    | Not_found -> new_p
    end
| d ->
    {p with pat_desc = map_pattern_desc (alpha_pat env) d}

let mkloc = Location.mkloc
let mknoloc = Location.mknoloc

end
(** Interface as module  *)
module Annot
= struct
(*#1 "annot.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*          Damien Doligez, projet Gallium, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 2007 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Data types for annotations (Stypes.ml) *)

type call = Tail | Stack | Inline;;

type ident =
  | Iref_internal of Location.t (* defining occurrence *)
  | Iref_external
  | Idef of Location.t          (* scope *)
;;

end
module TypedtreeMap : sig
(*#1 "typedtreeMap.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*                  Fabrice Le Fessant, INRIA Saclay                   *)
(*                                                                     *)
(*  Copyright 2012 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Typedtree

module type MapArgument = sig
  val enter_structure : structure -> structure
  val enter_value_description : value_description -> value_description
  val enter_type_declaration : type_declaration -> type_declaration
  val enter_type_extension : type_extension -> type_extension
  val enter_extension_constructor :
    extension_constructor -> extension_constructor
  val enter_pattern : pattern -> pattern
  val enter_expression : expression -> expression
  val enter_package_type : package_type -> package_type
  val enter_signature : signature -> signature
  val enter_signature_item : signature_item -> signature_item
  val enter_module_type_declaration : module_type_declaration -> module_type_declaration
  val enter_module_type : module_type -> module_type
  val enter_module_expr : module_expr -> module_expr
  val enter_with_constraint : with_constraint -> with_constraint
  val enter_class_expr : class_expr -> class_expr
  val enter_class_signature : class_signature -> class_signature
  val enter_class_declaration : class_declaration -> class_declaration
  val enter_class_description : class_description -> class_description
  val enter_class_type_declaration :
    class_type_declaration -> class_type_declaration
  val enter_class_type : class_type -> class_type
  val enter_class_type_field : class_type_field -> class_type_field
  val enter_core_type : core_type -> core_type
  val enter_class_structure : class_structure -> class_structure
  val enter_class_field : class_field -> class_field
  val enter_structure_item : structure_item -> structure_item

  val leave_structure : structure -> structure
  val leave_value_description : value_description -> value_description
  val leave_type_declaration : type_declaration -> type_declaration
  val leave_type_extension : type_extension -> type_extension
  val leave_extension_constructor :
    extension_constructor -> extension_constructor
  val leave_pattern : pattern -> pattern
  val leave_expression : expression -> expression
  val leave_package_type : package_type -> package_type
  val leave_signature : signature -> signature
  val leave_signature_item : signature_item -> signature_item
  val leave_module_type_declaration : module_type_declaration -> module_type_declaration
  val leave_module_type : module_type -> module_type
  val leave_module_expr : module_expr -> module_expr
  val leave_with_constraint : with_constraint -> with_constraint
  val leave_class_expr : class_expr -> class_expr
  val leave_class_signature : class_signature -> class_signature
  val leave_class_declaration : class_declaration -> class_declaration
  val leave_class_description : class_description -> class_description
  val leave_class_type_declaration :
    class_type_declaration -> class_type_declaration
  val leave_class_type : class_type -> class_type
  val leave_class_type_field : class_type_field -> class_type_field
  val leave_core_type : core_type -> core_type
  val leave_class_structure : class_structure -> class_structure
  val leave_class_field : class_field -> class_field
  val leave_structure_item : structure_item -> structure_item

end

module MakeMap :
  functor
    (Iter : MapArgument) ->
sig
  val map_structure : structure -> structure
  val map_pattern : pattern -> pattern
  val map_structure_item : structure_item -> structure_item
  val map_expression : expression -> expression
  val map_class_expr : class_expr -> class_expr

  val map_signature : signature -> signature
  val map_signature_item : signature_item -> signature_item
  val map_module_type : module_type -> module_type
end

module DefaultMapArgument : MapArgument

end = struct
(*#1 "typedtreeMap.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*                  Fabrice Le Fessant, INRIA Saclay                   *)
(*                                                                     *)
(*  Copyright 2012 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Typedtree

module type MapArgument = sig
  val enter_structure : structure -> structure
  val enter_value_description : value_description -> value_description
  val enter_type_declaration : type_declaration -> type_declaration
  val enter_type_extension : type_extension -> type_extension
  val enter_extension_constructor :
    extension_constructor -> extension_constructor
  val enter_pattern : pattern -> pattern
  val enter_expression : expression -> expression
  val enter_package_type : package_type -> package_type
  val enter_signature : signature -> signature
  val enter_signature_item : signature_item -> signature_item
  val enter_module_type_declaration : module_type_declaration -> module_type_declaration
  val enter_module_type : module_type -> module_type
  val enter_module_expr : module_expr -> module_expr
  val enter_with_constraint : with_constraint -> with_constraint
  val enter_class_expr : class_expr -> class_expr
  val enter_class_signature : class_signature -> class_signature
  val enter_class_declaration : class_declaration -> class_declaration
  val enter_class_description : class_description -> class_description
  val enter_class_type_declaration :
    class_type_declaration -> class_type_declaration
  val enter_class_type : class_type -> class_type
  val enter_class_type_field : class_type_field -> class_type_field
  val enter_core_type : core_type -> core_type
  val enter_class_structure : class_structure -> class_structure
  val enter_class_field : class_field -> class_field
  val enter_structure_item : structure_item -> structure_item

  val leave_structure : structure -> structure
  val leave_value_description : value_description -> value_description
  val leave_type_declaration : type_declaration -> type_declaration
  val leave_type_extension : type_extension -> type_extension
  val leave_extension_constructor :
    extension_constructor -> extension_constructor
  val leave_pattern : pattern -> pattern
  val leave_expression : expression -> expression
  val leave_package_type : package_type -> package_type
  val leave_signature : signature -> signature
  val leave_signature_item : signature_item -> signature_item
  val leave_module_type_declaration : module_type_declaration -> module_type_declaration
  val leave_module_type : module_type -> module_type
  val leave_module_expr : module_expr -> module_expr
  val leave_with_constraint : with_constraint -> with_constraint
  val leave_class_expr : class_expr -> class_expr
  val leave_class_signature : class_signature -> class_signature
  val leave_class_declaration : class_declaration -> class_declaration
  val leave_class_description : class_description -> class_description
  val leave_class_type_declaration :
    class_type_declaration -> class_type_declaration
  val leave_class_type : class_type -> class_type
  val leave_class_type_field : class_type_field -> class_type_field
  val leave_core_type : core_type -> core_type
  val leave_class_structure : class_structure -> class_structure
  val leave_class_field : class_field -> class_field
  val leave_structure_item : structure_item -> structure_item

end


module MakeMap(Map : MapArgument) = struct

  let may_map f v =
    match v with
        None -> v
      | Some x -> Some (f x)


  open Misc

  let rec map_structure str =
    let str = Map.enter_structure str in
    let str_items = List.map map_structure_item str.str_items in
    Map.leave_structure { str with str_items = str_items }

  and map_binding vb =
    {
      vb_pat = map_pattern vb.vb_pat;
      vb_expr = map_expression vb.vb_expr;
      vb_attributes = vb.vb_attributes;
      vb_loc = vb.vb_loc;
    }

  and map_bindings rec_flag list =
    List.map map_binding list

  and map_case {c_lhs; c_guard; c_rhs} =
    {
     c_lhs = map_pattern c_lhs;
     c_guard = may_map map_expression c_guard;
     c_rhs = map_expression c_rhs;
    }

  and map_cases list =
    List.map map_case list

  and map_structure_item item =
    let item = Map.enter_structure_item item in
    let str_desc =
      match item.str_desc with
          Tstr_eval (exp, attrs) -> Tstr_eval (map_expression exp, attrs)
        | Tstr_value (rec_flag, list) ->
          Tstr_value (rec_flag, map_bindings rec_flag list)
        | Tstr_primitive vd ->
          Tstr_primitive (map_value_description vd)
        | Tstr_type list ->
          Tstr_type (List.map map_type_declaration list)
        | Tstr_typext tyext ->
          Tstr_typext (map_type_extension tyext)
        | Tstr_exception ext ->
          Tstr_exception (map_extension_constructor ext)
        | Tstr_module x ->
          Tstr_module (map_module_binding x)
        | Tstr_recmodule list ->
          let list = List.map map_module_binding list in
          Tstr_recmodule list
        | Tstr_modtype mtd ->
          Tstr_modtype (map_module_type_declaration mtd)
        | Tstr_open od -> Tstr_open od
        | Tstr_class list ->
          let list =
            List.map
              (fun (ci, string_list, virtual_flag) ->
                 map_class_declaration ci, string_list, virtual_flag)
              list
          in
            Tstr_class list
        | Tstr_class_type list ->
          let list =
            List.map
              (fun (id, name, ct) ->
               id, name, map_class_type_declaration ct)
              list
          in
            Tstr_class_type list
        | Tstr_include incl ->
          Tstr_include {incl with incl_mod = map_module_expr incl.incl_mod}
        | Tstr_attribute x -> Tstr_attribute x
    in
    Map.leave_structure_item { item with str_desc = str_desc}

  and map_module_binding x =
    {x with mb_expr = map_module_expr x.mb_expr}

  and map_value_description v =
    let v = Map.enter_value_description v in
    let val_desc = map_core_type v.val_desc in
    Map.leave_value_description { v with val_desc = val_desc }

  and map_type_declaration decl =
    let decl = Map.enter_type_declaration decl in
    let typ_params = List.map map_type_parameter decl.typ_params in
    let typ_cstrs = List.map (fun (ct1, ct2, loc) ->
      (map_core_type ct1,
       map_core_type ct2,
       loc)
    ) decl.typ_cstrs in
    let typ_kind = match decl.typ_kind with
        Ttype_abstract -> Ttype_abstract
      | Ttype_variant list ->
          let list = List.map map_constructor_declaration list in
          Ttype_variant list
      | Ttype_record list ->
        let list =
          List.map
            (fun ld ->
              {ld with ld_type = map_core_type ld.ld_type}
            ) list
        in
        Ttype_record list
      | Ttype_open -> Ttype_open
    in
    let typ_manifest = may_map map_core_type decl.typ_manifest in
    Map.leave_type_declaration { decl with typ_params = typ_params;
      typ_cstrs = typ_cstrs; typ_kind = typ_kind; typ_manifest = typ_manifest }

  and map_type_parameter (ct, v) = (map_core_type ct, v)

  and map_constructor_declaration cd =
    {cd with cd_args = List.map map_core_type cd.cd_args;
     cd_res = may_map map_core_type cd.cd_res
    }

  and map_type_extension tyext =
    let tyext = Map.enter_type_extension tyext in
    let tyext_params = List.map map_type_parameter tyext.tyext_params in
    let tyext_constructors  =
      List.map map_extension_constructor tyext.tyext_constructors
    in
    Map.leave_type_extension { tyext with tyext_params = tyext_params;
      tyext_constructors = tyext_constructors }

  and map_extension_constructor ext =
    let ext = Map.enter_extension_constructor ext in
    let ext_kind = match ext.ext_kind with
        Text_decl(args, ret) ->
          let args = List.map map_core_type args in
          let ret = may_map map_core_type ret in
            Text_decl(args, ret)
      | Text_rebind(p, lid) -> Text_rebind(p, lid)
    in
    Map.leave_extension_constructor {ext with ext_kind = ext_kind}

  and map_pattern pat =
    let pat = Map.enter_pattern pat in
    let pat_desc =
      match pat.pat_desc with
        | Tpat_alias (pat1, p, text) ->
          let pat1 = map_pattern pat1 in
          Tpat_alias (pat1, p, text)
        | Tpat_tuple list -> Tpat_tuple (List.map map_pattern list)
        | Tpat_construct (lid, cstr_decl, args) ->
          Tpat_construct (lid, cstr_decl,
                          List.map map_pattern args)
        | Tpat_variant (label, pato, rowo) ->
          let pato = match pato with
              None -> pato
            | Some pat -> Some (map_pattern pat)
          in
          Tpat_variant (label, pato, rowo)
        | Tpat_record (list, closed) ->
          Tpat_record (List.map (fun (lid, lab_desc, pat) ->
            (lid, lab_desc, map_pattern pat) ) list, closed)
        | Tpat_array list -> Tpat_array (List.map map_pattern list)
        | Tpat_or (p1, p2, rowo) ->
          Tpat_or (map_pattern p1, map_pattern p2, rowo)
        | Tpat_lazy p -> Tpat_lazy (map_pattern p)
        | Tpat_constant _
        | Tpat_any
        | Tpat_var _ -> pat.pat_desc

    in
    let pat_extra = List.map map_pat_extra pat.pat_extra in
    Map.leave_pattern { pat with pat_desc = pat_desc; pat_extra = pat_extra }

  and map_pat_extra pat_extra =
    match pat_extra with
      | Tpat_constraint ct, loc, attrs -> (Tpat_constraint (map_core_type  ct), loc, attrs)
      | (Tpat_type _ | Tpat_unpack), _, _ -> pat_extra

  and map_expression exp =
    let exp = Map.enter_expression exp in
    let exp_desc =
      match exp.exp_desc with
          Texp_ident (_, _, _)
        | Texp_constant _ -> exp.exp_desc
        | Texp_let (rec_flag, list, exp) ->
          Texp_let (rec_flag,
                    map_bindings rec_flag list,
                    map_expression exp)
        | Texp_function (label, cases, partial) ->
          Texp_function (label, map_cases cases, partial)
        | Texp_apply (exp, list) ->
          Texp_apply (map_expression exp,
                      List.map (fun (label, expo, optional) ->
                        let expo =
                          match expo with
                              None -> expo
                            | Some exp -> Some (map_expression exp)
                        in
                        (label, expo, optional)
                      ) list )
        | Texp_match (exp, list1, list2, partial) ->
          Texp_match (
            map_expression exp,
            map_cases list1,
            map_cases list2,
            partial
          )
        | Texp_try (exp, list) ->
          Texp_try (
            map_expression exp,
            map_cases list
          )
        | Texp_tuple list ->
          Texp_tuple (List.map map_expression list)
        | Texp_construct (lid, cstr_desc, args) ->
          Texp_construct (lid, cstr_desc,
                          List.map map_expression args )
        | Texp_variant (label, expo) ->
          let expo =match expo with
              None -> expo
            | Some exp -> Some (map_expression exp)
          in
          Texp_variant (label, expo)
        | Texp_record (list, expo) ->
          let list =
            List.map (fun (lid, lab_desc, exp) ->
              (lid, lab_desc, map_expression exp)
            ) list in
          let expo = match expo with
              None -> expo
            | Some exp -> Some (map_expression exp)
          in
          Texp_record (list, expo)
        | Texp_field (exp, lid, label) ->
          Texp_field (map_expression exp, lid, label)
        | Texp_setfield (exp1, lid, label, exp2) ->
          Texp_setfield (
            map_expression exp1,
            lid,
            label,
            map_expression exp2)
        | Texp_array list ->
          Texp_array (List.map map_expression list)
        | Texp_ifthenelse (exp1, exp2, expo) ->
          Texp_ifthenelse (
            map_expression exp1,
            map_expression exp2,
            match expo with
                None -> expo
              | Some exp -> Some (map_expression exp)
          )
        | Texp_sequence (exp1, exp2) ->
          Texp_sequence (
            map_expression exp1,
            map_expression exp2
          )
        | Texp_while (exp1, exp2) ->
          Texp_while (
            map_expression exp1,
            map_expression exp2
          )
        | Texp_for (id, name, exp1, exp2, dir, exp3) ->
          Texp_for (
            id, name,
            map_expression exp1,
            map_expression exp2,
            dir,
            map_expression exp3
          )
        | Texp_send (exp, meth, expo) ->
          Texp_send (map_expression exp, meth, may_map map_expression expo)
        | Texp_new (path, lid, cl_decl) -> exp.exp_desc
        | Texp_instvar (_, path, _) -> exp.exp_desc
        | Texp_setinstvar (path, lid, path2, exp) ->
          Texp_setinstvar (path, lid, path2, map_expression exp)
        | Texp_override (path, list) ->
          Texp_override (
            path,
            List.map (fun (path, lid, exp) ->
              (path, lid, map_expression exp)
            ) list
          )
        | Texp_letmodule (id, name, mexpr, exp) ->
          Texp_letmodule (
            id, name,
            map_module_expr mexpr,
            map_expression exp
          )
        | Texp_assert exp -> Texp_assert (map_expression exp)
        | Texp_lazy exp -> Texp_lazy (map_expression exp)
        | Texp_object (cl, string_list) ->
          Texp_object (map_class_structure cl, string_list)
        | Texp_pack (mexpr) ->
          Texp_pack (map_module_expr mexpr)
    in
    let exp_extra = List.map map_exp_extra exp.exp_extra in
    Map.leave_expression {
      exp with
        exp_desc = exp_desc;
        exp_extra = exp_extra; }

  and map_exp_extra ((desc, loc, attrs) as exp_extra) =
    match desc with
      | Texp_constraint ct ->
        Texp_constraint (map_core_type ct), loc, attrs
      | Texp_coerce (None, ct) ->
        Texp_coerce (None, map_core_type ct), loc, attrs
      | Texp_coerce (Some ct1, ct2) ->
        Texp_coerce (Some (map_core_type ct1),
                         map_core_type ct2), loc, attrs
      | Texp_poly (Some ct) ->
        Texp_poly (Some ( map_core_type ct )), loc, attrs
      | Texp_newtype _
      | Texp_open _
      | Texp_poly None -> exp_extra


  and map_package_type pack =
    let pack = Map.enter_package_type pack in
    let pack_fields = List.map (
      fun (s, ct) -> (s, map_core_type ct) ) pack.pack_fields in
    Map.leave_package_type { pack with pack_fields = pack_fields }

  and map_signature sg =
    let sg = Map.enter_signature sg in
    let sig_items = List.map map_signature_item sg.sig_items in
    Map.leave_signature { sg with sig_items = sig_items }

  and map_signature_item item =
    let item = Map.enter_signature_item item in
    let sig_desc =
      match item.sig_desc with
          Tsig_value vd ->
            Tsig_value (map_value_description vd)
        | Tsig_type list -> Tsig_type (List.map map_type_declaration list)
        | Tsig_typext tyext ->
          Tsig_typext (map_type_extension tyext)
        | Tsig_exception ext ->
          Tsig_exception (map_extension_constructor ext)
        | Tsig_module md ->
          Tsig_module {md with md_type = map_module_type md.md_type}
        | Tsig_recmodule list ->
          Tsig_recmodule
              (List.map
                 (fun md -> {md with md_type = map_module_type md.md_type})
                 list
              )
        | Tsig_modtype mtd ->
          Tsig_modtype (map_module_type_declaration mtd)
        | Tsig_open _ -> item.sig_desc
        | Tsig_include incl ->
          Tsig_include {incl with incl_mod = map_module_type incl.incl_mod}
        | Tsig_class list -> Tsig_class (List.map map_class_description list)
        | Tsig_class_type list ->
          Tsig_class_type (List.map map_class_type_declaration list)
        | Tsig_attribute _ as x -> x
    in
    Map.leave_signature_item { item with sig_desc = sig_desc }

  and map_module_type_declaration mtd =
    let mtd = Map.enter_module_type_declaration mtd in
    let mtd = {mtd with mtd_type = may_map map_module_type mtd.mtd_type} in
    Map.leave_module_type_declaration mtd

  and map_class_declaration cd =
    let cd = Map.enter_class_declaration cd in
    let ci_params = List.map map_type_parameter cd.ci_params in
    let ci_expr = map_class_expr cd.ci_expr in
    Map.leave_class_declaration
      { cd with ci_params = ci_params; ci_expr = ci_expr }

  and map_class_description cd =
    let cd = Map.enter_class_description cd in
    let ci_params = List.map map_type_parameter cd.ci_params in
    let ci_expr = map_class_type cd.ci_expr in
    Map.leave_class_description
      { cd with ci_params = ci_params; ci_expr = ci_expr}

  and map_class_type_declaration cd =
    let cd = Map.enter_class_type_declaration cd in
    let ci_params = List.map map_type_parameter cd.ci_params in
    let ci_expr = map_class_type cd.ci_expr in
    Map.leave_class_type_declaration
      { cd with ci_params = ci_params; ci_expr = ci_expr }

  and map_module_type mty =
    let mty = Map.enter_module_type mty in
    let mty_desc =
      match mty.mty_desc with
          Tmty_ident _ -> mty.mty_desc
        | Tmty_alias _ -> mty.mty_desc
        | Tmty_signature sg -> Tmty_signature (map_signature sg)
        | Tmty_functor (id, name, mtype1, mtype2) ->
          Tmty_functor (id, name, Misc.may_map map_module_type mtype1,
                        map_module_type mtype2)
        | Tmty_with (mtype, list) ->
          Tmty_with (map_module_type mtype,
                     List.map (fun (path, lid, withc) ->
                       (path, lid, map_with_constraint withc)
                     ) list)
        | Tmty_typeof mexpr ->
          Tmty_typeof (map_module_expr mexpr)
    in
    Map.leave_module_type { mty with mty_desc = mty_desc}

  and map_with_constraint cstr =
    let cstr = Map.enter_with_constraint cstr in
    let cstr =
      match cstr with
          Twith_type decl -> Twith_type (map_type_declaration decl)
        | Twith_typesubst decl -> Twith_typesubst (map_type_declaration decl)
        | Twith_module (path, lid) -> cstr
        | Twith_modsubst (path, lid) -> cstr
    in
    Map.leave_with_constraint cstr

  and map_module_expr mexpr =
    let mexpr = Map.enter_module_expr mexpr in
    let mod_desc =
      match mexpr.mod_desc with
          Tmod_ident (p, lid) -> mexpr.mod_desc
        | Tmod_structure st -> Tmod_structure (map_structure st)
        | Tmod_functor (id, name, mtype, mexpr) ->
          Tmod_functor (id, name, Misc.may_map map_module_type mtype,
                        map_module_expr mexpr)
        | Tmod_apply (mexp1, mexp2, coercion) ->
          Tmod_apply (map_module_expr mexp1, map_module_expr mexp2, coercion)
        | Tmod_constraint (mexpr, mod_type, Tmodtype_implicit, coercion ) ->
          Tmod_constraint (map_module_expr mexpr, mod_type,
                           Tmodtype_implicit, coercion)
        | Tmod_constraint (mexpr, mod_type,
                           Tmodtype_explicit mtype, coercion) ->
          Tmod_constraint (map_module_expr mexpr, mod_type,
                           Tmodtype_explicit (map_module_type mtype),
                           coercion)
        | Tmod_unpack (exp, mod_type) ->
          Tmod_unpack (map_expression exp, mod_type)
    in
    Map.leave_module_expr { mexpr with mod_desc = mod_desc }

  and map_class_expr cexpr =
    let cexpr = Map.enter_class_expr cexpr in
    let cl_desc =
      match cexpr.cl_desc with
        | Tcl_constraint (cl, None, string_list1, string_list2, concr ) ->
          Tcl_constraint (map_class_expr cl, None, string_list1,
                          string_list2, concr)
        | Tcl_structure clstr -> Tcl_structure (map_class_structure clstr)
        | Tcl_fun (label, pat, priv, cl, partial) ->
          Tcl_fun (label, map_pattern pat,
                   List.map (fun (id, name, exp) ->
                     (id, name, map_expression exp)) priv,
                   map_class_expr cl, partial)

        | Tcl_apply (cl, args) ->
          Tcl_apply (map_class_expr cl,
                     List.map (fun (label, expo, optional) ->
                       (label, may_map map_expression expo,
                        optional)
                     ) args)
        | Tcl_let (rec_flat, bindings, ivars, cl) ->
          Tcl_let (rec_flat, map_bindings rec_flat bindings,
                   List.map (fun (id, name, exp) ->
                     (id, name, map_expression exp)) ivars,
                   map_class_expr cl)

        | Tcl_constraint (cl, Some clty, vals, meths, concrs) ->
          Tcl_constraint ( map_class_expr cl,
                           Some (map_class_type clty), vals, meths, concrs)

        | Tcl_ident (id, name, tyl) ->
          Tcl_ident (id, name, List.map map_core_type tyl)
    in
    Map.leave_class_expr { cexpr with cl_desc = cl_desc }

  and map_class_type ct =
    let ct = Map.enter_class_type ct in
    let cltyp_desc =
      match ct.cltyp_desc with
          Tcty_signature csg -> Tcty_signature (map_class_signature csg)
        | Tcty_constr (path, lid, list) ->
          Tcty_constr (path, lid, List.map map_core_type list)
        | Tcty_arrow (label, ct, cl) ->
          Tcty_arrow (label, map_core_type ct, map_class_type cl)
    in
    Map.leave_class_type { ct with cltyp_desc = cltyp_desc }

  and map_class_signature cs =
    let cs = Map.enter_class_signature cs in
    let csig_self = map_core_type cs.csig_self in
    let csig_fields = List.map map_class_type_field cs.csig_fields in
    Map.leave_class_signature { cs with
      csig_self = csig_self; csig_fields = csig_fields }


  and map_class_type_field ctf =
    let ctf = Map.enter_class_type_field ctf in
    let ctf_desc =
      match ctf.ctf_desc with
          Tctf_inherit ct -> Tctf_inherit (map_class_type ct)
        | Tctf_val (s, mut, virt, ct) ->
          Tctf_val (s, mut, virt, map_core_type ct)
        | Tctf_method (s, priv, virt, ct) ->
          Tctf_method (s, priv, virt, map_core_type ct)
        | Tctf_constraint (ct1, ct2) ->
          Tctf_constraint (map_core_type ct1, map_core_type ct2)
        | Tctf_attribute _ as x -> x
    in
    Map.leave_class_type_field { ctf with ctf_desc = ctf_desc }

  and map_core_type ct =
    let ct = Map.enter_core_type ct in
    let ctyp_desc =
      match ct.ctyp_desc with
          Ttyp_any
        | Ttyp_var _ -> ct.ctyp_desc
        | Ttyp_arrow (label, ct1, ct2) ->
          Ttyp_arrow (label, map_core_type ct1, map_core_type ct2)
        | Ttyp_tuple list -> Ttyp_tuple (List.map map_core_type list)
        | Ttyp_constr (path, lid, list) ->
          Ttyp_constr (path, lid, List.map map_core_type list)
        | Ttyp_object (list, o) ->
          Ttyp_object
            (List.map (fun (s, a, t) -> (s, a, map_core_type t)) list, o)
        | Ttyp_class (path, lid, list) ->
          Ttyp_class (path, lid, List.map map_core_type list)
        | Ttyp_alias (ct, s) -> Ttyp_alias (map_core_type ct, s)
        | Ttyp_variant (list, bool, labels) ->
          Ttyp_variant (List.map map_row_field list, bool, labels)
        | Ttyp_poly (list, ct) -> Ttyp_poly (list, map_core_type ct)
        | Ttyp_package pack -> Ttyp_package (map_package_type pack)
    in
    Map.leave_core_type { ct with ctyp_desc = ctyp_desc }

  and map_class_structure cs =
    let cs = Map.enter_class_structure cs in
    let cstr_self = map_pattern cs.cstr_self in
    let cstr_fields = List.map map_class_field cs.cstr_fields in
    Map.leave_class_structure { cs with cstr_self; cstr_fields }

  and map_row_field rf =
    match rf with
        Ttag (label, attrs, bool, list) ->
          Ttag (label, attrs, bool, List.map map_core_type list)
      | Tinherit ct -> Tinherit (map_core_type ct)

  and map_class_field cf =
    let cf = Map.enter_class_field cf in
    let cf_desc =
      match cf.cf_desc with
          Tcf_inherit (ovf, cl, super, vals, meths) ->
            Tcf_inherit (ovf, map_class_expr cl, super, vals, meths)
        | Tcf_constraint (cty, cty') ->
          Tcf_constraint (map_core_type cty, map_core_type cty')
        | Tcf_val (lab, mut, ident, Tcfk_virtual cty, b) ->
          Tcf_val (lab, mut, ident, Tcfk_virtual (map_core_type cty), b)
        | Tcf_val (lab, mut, ident, Tcfk_concrete (o, exp), b) ->
          Tcf_val (lab, mut, ident, Tcfk_concrete (o, map_expression exp), b)
        | Tcf_method (lab, priv, Tcfk_virtual cty) ->
          Tcf_method (lab, priv, Tcfk_virtual (map_core_type cty))
        | Tcf_method (lab, priv, Tcfk_concrete (o, exp)) ->
          Tcf_method (lab, priv, Tcfk_concrete (o, map_expression exp))
        | Tcf_initializer exp -> Tcf_initializer (map_expression exp)
        | Tcf_attribute _ as x -> x
    in
    Map.leave_class_field { cf with cf_desc = cf_desc }
end


module DefaultMapArgument = struct

  let enter_structure t = t
  let enter_value_description t = t
  let enter_type_declaration t = t
  let enter_type_extension t = t
  let enter_extension_constructor t = t
  let enter_pattern t = t
  let enter_expression t = t
  let enter_package_type t = t
  let enter_signature t = t
  let enter_signature_item t = t
  let enter_module_type_declaration t = t
  let enter_module_type t = t
  let enter_module_expr t = t
  let enter_with_constraint t = t
  let enter_class_expr t = t
  let enter_class_signature t = t
  let enter_class_declaration t = t
  let enter_class_description t = t
  let enter_class_type_declaration t = t
  let enter_class_type t = t
  let enter_class_type_field t = t
  let enter_core_type t = t
  let enter_class_structure t = t
  let enter_class_field t = t
  let enter_structure_item t = t


  let leave_structure t = t
  let leave_value_description t = t
  let leave_type_declaration t = t
  let leave_type_extension t = t
  let leave_extension_constructor t = t
  let leave_pattern t = t
  let leave_expression t = t
  let leave_package_type t = t
  let leave_signature t = t
  let leave_signature_item t = t
  let leave_module_type_declaration t = t
  let leave_module_type t = t
  let leave_module_expr t = t
  let leave_with_constraint t = t
  let leave_class_expr t = t
  let leave_class_signature t = t
  let leave_class_declaration t = t
  let leave_class_description t = t
  let leave_class_type_declaration t = t
  let leave_class_type t = t
  let leave_class_type_field t = t
  let leave_core_type t = t
  let leave_class_structure t = t
  let leave_class_field t = t
  let leave_structure_item t = t

end

end
module Cmt_format : sig
(*#1 "cmt_format.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*                  Fabrice Le Fessant, INRIA Saclay                   *)
(*                                                                     *)
(*  Copyright 2012 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(** cmt and cmti files format. *)

(** The layout of a cmt file is as follows:
      <cmt> := \{<cmi>\} <cmt magic> \{cmt infos\} \{<source info>\}
    where <cmi> is the cmi file format:
      <cmi> := <cmi magic> <cmi info>.
    More precisely, the optional <cmi> part must be present if and only if
    the file is:
    - a cmti, or
    - a cmt, for a ml file which has no corresponding mli (hence no
    corresponding cmti).

    Thus, we provide a common reading function for cmi and cmt(i)
    files which returns an option for each of the three parts: cmi
    info, cmt info, source info. *)

open Typedtree

type binary_annots =
  | Packed of Types.signature * string list
  | Implementation of structure
  | Interface of signature
  | Partial_implementation of binary_part array
  | Partial_interface of binary_part array

and binary_part =
  | Partial_structure of structure
  | Partial_structure_item of structure_item
  | Partial_expression of expression
  | Partial_pattern of pattern
  | Partial_class_expr of class_expr
  | Partial_signature of signature
  | Partial_signature_item of signature_item
  | Partial_module_type of module_type

type cmt_infos = {
  cmt_modname : string;
  cmt_annots : binary_annots;
  cmt_value_dependencies :
    (Types.value_description * Types.value_description) list;
  cmt_comments : (string * Location.t) list;
  cmt_args : string array;
  cmt_sourcefile : string option;
  cmt_builddir : string;
  cmt_loadpath : string list;
  cmt_source_digest : string option;
  cmt_initial_env : Env.t;
  cmt_imports : (string * Digest.t option) list;
  cmt_interface_digest : Digest.t option;
  cmt_use_summaries : bool;
}

type error =
    Not_a_typedtree of string

exception Error of error

(** [read filename] opens filename, and extract both the cmi_infos, if
    it exists, and the cmt_infos, if it exists. Thus, it can be used
    with .cmi, .cmt and .cmti files.

    .cmti files always contain a cmi_infos at the beginning. .cmt files
    only contain a cmi_infos at the beginning if there is no associated
    .cmti file.
*)
val read : string -> Cmi_format.cmi_infos option * cmt_infos option

val read_cmt : string -> cmt_infos
val read_cmi : string -> Cmi_format.cmi_infos

(** [save_cmt modname filename binary_annots sourcefile initial_env sg]
    writes a cmt(i) file.  *)
val save_cmt :
  string ->  (* filename.cmt to generate *)
  string ->  (* module name *)
  binary_annots ->
  string option ->  (* source file *)
  Env.t -> (* initial env *)
  Types.signature option -> (* if a .cmi was generated,
                               the signature saved there *)
  unit

(* Miscellaneous functions *)

val read_magic_number : in_channel -> string

val clear: unit -> unit

val add_saved_type : binary_part -> unit
val get_saved_types : unit -> binary_part list
val set_saved_types : binary_part list -> unit

val record_value_dependency:
  Types.value_description -> Types.value_description -> unit


(*

  val is_magic_number : string -> bool
  val read : in_channel -> Env.cmi_infos option * t
  val write_magic_number : out_channel -> unit
  val write : out_channel -> t -> unit

  val find : string list -> string -> string
  val read_signature : 'a -> string -> Types.signature * 'b list * 'c list

*)

end = struct
(*#1 "cmt_format.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*                  Fabrice Le Fessant, INRIA Saclay                   *)
(*                                                                     *)
(*  Copyright 2012 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Cmi_format
open Typedtree

(* Note that in Typerex, there is an awful hack to save a cmt file
   together with the interface file that was generated by ocaml (this
   is because the installed version of ocaml might differ from the one
   integrated in Typerex).
*)



let read_magic_number ic =
  let len_magic_number = String.length Config.cmt_magic_number in
  really_input_string ic len_magic_number

type binary_annots =
  | Packed of Types.signature * string list
  | Implementation of structure
  | Interface of signature
  | Partial_implementation of binary_part array
  | Partial_interface of binary_part array

and binary_part =
| Partial_structure of structure
| Partial_structure_item of structure_item
| Partial_expression of expression
| Partial_pattern of pattern
| Partial_class_expr of class_expr
| Partial_signature of signature
| Partial_signature_item of signature_item
| Partial_module_type of module_type

type cmt_infos = {
  cmt_modname : string;
  cmt_annots : binary_annots;
  cmt_value_dependencies :
    (Types.value_description * Types.value_description) list;
  cmt_comments : (string * Location.t) list;
  cmt_args : string array;
  cmt_sourcefile : string option;
  cmt_builddir : string;
  cmt_loadpath : string list;
  cmt_source_digest : Digest.t option;
  cmt_initial_env : Env.t;
  cmt_imports : (string * Digest.t option) list;
  cmt_interface_digest : Digest.t option;
  cmt_use_summaries : bool;
}

type error =
    Not_a_typedtree of string

let need_to_clear_env =
  try ignore (Sys.getenv "OCAML_BINANNOT_WITHENV"); false
  with Not_found -> true

let keep_only_summary = Env.keep_only_summary

module ClearEnv  = TypedtreeMap.MakeMap (struct
  open TypedtreeMap
  include DefaultMapArgument

  let leave_pattern p = { p with pat_env = keep_only_summary p.pat_env }
  let leave_expression e =
    let exp_extra = List.map (function
        (Texp_open (ovf, path, lloc, env), loc, attrs) ->
          (Texp_open (ovf, path, lloc, keep_only_summary env), loc, attrs)
      | exp_extra -> exp_extra) e.exp_extra in
    { e with
      exp_env = keep_only_summary e.exp_env;
      exp_extra = exp_extra }
  let leave_class_expr c =
    { c with cl_env = keep_only_summary c.cl_env }
  let leave_module_expr m =
    { m with mod_env = keep_only_summary m.mod_env }
  let leave_structure s =
    { s with str_final_env = keep_only_summary s.str_final_env }
  let leave_structure_item str =
    { str with str_env = keep_only_summary str.str_env }
  let leave_module_type m =
    { m with mty_env = keep_only_summary m.mty_env }
  let leave_signature s =
    { s with sig_final_env = keep_only_summary s.sig_final_env }
  let leave_signature_item s =
    { s with sig_env = keep_only_summary s.sig_env }
  let leave_core_type c =
    { c with ctyp_env = keep_only_summary c.ctyp_env }
  let leave_class_type c =
    { c with cltyp_env = keep_only_summary c.cltyp_env }

end)

let clear_part p = match p with
  | Partial_structure s -> Partial_structure (ClearEnv.map_structure s)
  | Partial_structure_item s ->
    Partial_structure_item (ClearEnv.map_structure_item s)
  | Partial_expression e -> Partial_expression (ClearEnv.map_expression e)
  | Partial_pattern p -> Partial_pattern (ClearEnv.map_pattern p)
  | Partial_class_expr ce -> Partial_class_expr (ClearEnv.map_class_expr ce)
  | Partial_signature s -> Partial_signature (ClearEnv.map_signature s)
  | Partial_signature_item s ->
    Partial_signature_item (ClearEnv.map_signature_item s)
  | Partial_module_type s -> Partial_module_type (ClearEnv.map_module_type s)

let clear_env binary_annots =
  if need_to_clear_env then
    match binary_annots with
      | Implementation s -> Implementation (ClearEnv.map_structure s)
      | Interface s -> Interface (ClearEnv.map_signature s)
      | Packed _ -> binary_annots
      | Partial_implementation array ->
        Partial_implementation (Array.map clear_part array)
      | Partial_interface array ->
        Partial_interface (Array.map clear_part array)

  else binary_annots




exception Error of error

let input_cmt ic = (input_value ic : cmt_infos)

let output_cmt oc cmt =
  output_string oc Config.cmt_magic_number;
  output_value oc (cmt : cmt_infos)

let read filename =
(*  Printf.fprintf stderr "Cmt_format.read %s\n%!" filename; *)
  let ic = open_in_bin filename in
  try
    let magic_number = read_magic_number ic in
    let cmi, cmt =
      if magic_number = Config.cmt_magic_number then
        None, Some (input_cmt ic)
      else if magic_number = Config.cmi_magic_number then
        let cmi = Cmi_format.input_cmi ic in
        let cmt = try
                    let magic_number = read_magic_number ic in
                    if magic_number = Config.cmt_magic_number then
                      let cmt = input_cmt ic in
                      Some cmt
                    else None
          with _ -> None
        in
        Some cmi, cmt
      else
        raise(Cmi_format.Error(Cmi_format.Not_an_interface filename))
    in
    close_in ic;
(*    Printf.fprintf stderr "Cmt_format.read done\n%!"; *)
    cmi, cmt
  with e ->
    close_in ic;
    raise e

let string_of_file filename =
  let ic = open_in filename in
  let s = Misc.string_of_file ic in
  close_in ic;
  s

let read_cmt filename =
  match read filename with
      _, None -> raise (Error (Not_a_typedtree filename))
    | _, Some cmt -> cmt

let read_cmi filename =
  match read filename with
      None, _ ->
        raise (Cmi_format.Error (Cmi_format.Not_an_interface filename))
    | Some cmi, _ -> cmi

let saved_types = ref []
let value_deps = ref []

let clear () =
  saved_types := [];
  value_deps := []

let add_saved_type b = saved_types := b :: !saved_types
let get_saved_types () = !saved_types
let set_saved_types l = saved_types := l

let record_value_dependency vd1 vd2 =
  if vd1.Types.val_loc <> vd2.Types.val_loc then
    value_deps := (vd1, vd2) :: !value_deps

let save_cmt filename modname binary_annots sourcefile initial_env sg =
  if !Clflags.binary_annotations && not !Clflags.print_types then begin
    let imports = Env.imports () in
    let oc = open_out_bin filename in
    let this_crc =
      match sg with
          None -> None
        | Some (sg) ->
          let cmi = {
            cmi_name = modname;
            cmi_sign = sg;
            cmi_flags =
            if !Clflags.recursive_types then [Cmi_format.Rectypes] else [];
            cmi_crcs = imports;
          } in
          Some (output_cmi filename oc cmi)
    in
    let source_digest = Misc.may_map Digest.file sourcefile in
    let cmt = {
      cmt_modname = modname;
      cmt_annots = clear_env binary_annots;
      cmt_value_dependencies = !value_deps;
      cmt_comments = Lexer.comments ();
      cmt_args = Sys.argv;
      cmt_sourcefile = sourcefile;
      cmt_builddir =  Sys.getcwd ();
      cmt_loadpath = !Config.load_path;
      cmt_source_digest = source_digest;
      cmt_initial_env = if need_to_clear_env then
          keep_only_summary initial_env else initial_env;
      cmt_imports = List.sort compare imports;
      cmt_interface_digest = this_crc;
      cmt_use_summaries = need_to_clear_env;
    } in
    output_cmt oc cmt;
    close_out oc;
    (* TODO: does not make sense to do post-proccesing for [Partial_implementaiton]*)
    match Sys.getenv "BS_CMT_POST_PROCESS_CMD" with
    | exception _ -> ()
    | cmd -> ignore (Sys.command (cmd ^ " -cmt-add " ^ filename ^ (match sourcefile with None -> "" | Some sourcefile -> ":" ^ sourcefile)))
  end;
  clear ()

end
module Ctype : sig
(*#1 "ctype.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Operations on core types *)

open Asttypes
open Types

exception Unify of (type_expr * type_expr) list
exception Tags of label * label
exception Subtype of
        (type_expr * type_expr) list * (type_expr * type_expr) list
exception Cannot_expand
exception Cannot_apply
exception Recursive_abbrev
exception Unification_recursive_abbrev of (type_expr * type_expr) list

val init_def: int -> unit
        (* Set the initial variable level *)
val begin_def: unit -> unit
        (* Raise the variable level by one at the beginning of a definition. *)
val end_def: unit -> unit
        (* Lower the variable level by one at the end of a definition *)
val begin_class_def: unit -> unit
val raise_nongen_level: unit -> unit
val reset_global_level: unit -> unit
        (* Reset the global level before typing an expression *)
val increase_global_level: unit -> int
val restore_global_level: int -> unit
        (* This pair of functions is only used in Typetexp *)

val newty: type_desc -> type_expr
val newvar: ?name:string -> unit -> type_expr
val newvar2: ?name:string -> int -> type_expr
        (* Return a fresh variable *)
val new_global_var: ?name:string -> unit -> type_expr
        (* Return a fresh variable, bound at toplevel
           (as type variables ['a] in type constraints). *)
val newobj: type_expr -> type_expr
val newconstr: Path.t -> type_expr list -> type_expr
val none: type_expr
        (* A dummy type expression *)

val repr: type_expr -> type_expr
        (* Return the canonical representative of a type. *)

val object_fields: type_expr -> type_expr
val flatten_fields:
        type_expr -> (string * field_kind * type_expr) list * type_expr
        (* Transform a field type into a list of pairs label-type *)
        (* The fields are sorted *)
val associate_fields:
        (string * field_kind * type_expr) list ->
        (string * field_kind * type_expr) list ->
        (string * field_kind * type_expr * field_kind * type_expr) list *
        (string * field_kind * type_expr) list *
        (string * field_kind * type_expr) list
val opened_object: type_expr -> bool
val close_object: type_expr -> unit
val row_variable: type_expr -> type_expr
        (* Return the row variable of an open object type *)
val set_object_name:
        Ident.t -> type_expr -> type_expr list -> type_expr -> unit
val remove_object_name: type_expr -> unit
val hide_private_methods: type_expr -> unit
val find_cltype_for_path: Env.t -> Path.t -> type_declaration * type_expr
val lid_of_path: ?sharp:string -> Path.t -> Longident.t

val sort_row_fields: (label * row_field) list -> (label * row_field) list
val merge_row_fields:
        (label * row_field) list -> (label * row_field) list ->
        (label * row_field) list * (label * row_field) list *
        (label * row_field * row_field) list
val filter_row_fields:
        bool -> (label * row_field) list -> (label * row_field) list

val generalize: type_expr -> unit
        (* Generalize in-place the given type *)
val iterative_generalization: int -> type_expr list -> type_expr list
        (* Efficient repeated generalization of a type *)
val generalize_expansive: Env.t -> type_expr -> unit
        (* Generalize the covariant part of a type, making
           contravariant branches non-generalizable *)
val generalize_global: type_expr -> unit
        (* Generalize the structure of a type, lowering variables
           to !global_level *)
val generalize_structure: type_expr -> unit
        (* Same, but variables are only lowered to !current_level *)
val generalize_spine: type_expr -> unit
        (* Special function to generalize a method during inference *)
val correct_levels: type_expr -> type_expr
        (* Returns a copy with decreasing levels *)
val limited_generalize: type_expr -> type_expr -> unit
        (* Only generalize some part of the type
           Make the remaining of the type non-generalizable *)

val instance: ?partial:bool -> Env.t -> type_expr -> type_expr
        (* Take an instance of a type scheme *)
        (* partial=None  -> normal
           partial=false -> newvar() for non generic subterms
           partial=true  -> newty2 ty.level Tvar for non generic subterms *)
val instance_def: type_expr -> type_expr
        (* use defaults *)
val instance_list: Env.t -> type_expr list -> type_expr list
        (* Take an instance of a list of type schemes *)
val instance_constructor:
        ?in_pattern:Env.t ref * int ->
        constructor_description -> type_expr list * type_expr
        (* Same, for a constructor *)
val instance_parameterized_type:
        ?keep_names:bool ->
        type_expr list -> type_expr -> type_expr list * type_expr
val instance_parameterized_type_2:
        type_expr list -> type_expr list -> type_expr ->
        type_expr list * type_expr list * type_expr
val instance_declaration: type_declaration -> type_declaration
val instance_class:
        type_expr list -> class_type -> type_expr list * class_type
val instance_poly:
        ?keep_names:bool ->
        bool -> type_expr list -> type_expr -> type_expr list * type_expr
        (* Take an instance of a type scheme containing free univars *)
val instance_label:
        bool -> label_description -> type_expr list * type_expr * type_expr
        (* Same, for a label *)
val apply:
        Env.t -> type_expr list -> type_expr -> type_expr list -> type_expr
        (* [apply [p1...pN] t [a1...aN]] match the arguments [ai] to
        the parameters [pi] and returns the corresponding instance of
        [t]. Exception [Cannot_apply] is raised in case of failure. *)

val expand_head_once: Env.t -> type_expr -> type_expr
val expand_head: Env.t -> type_expr -> type_expr
val try_expand_once_opt: Env.t -> type_expr -> type_expr
val expand_head_opt: Env.t -> type_expr -> type_expr
(** The compiler's own version of [expand_head] necessary for type-based
    optimisations. *)

val full_expand: Env.t -> type_expr -> type_expr
val extract_concrete_typedecl:
        Env.t -> type_expr -> Path.t * Path.t * type_declaration
        (* Return the original path of the types, and the first concrete
           type declaration found expanding it.
           Raise [Not_found] if none appears or not a type constructor. *)

val enforce_constraints: Env.t -> type_expr -> unit

val unify: Env.t -> type_expr -> type_expr -> unit
        (* Unify the two types given. Raise [Unify] if not possible. *)
val unify_gadt: newtype_level:int -> Env.t ref -> type_expr -> type_expr -> unit
        (* Unify the two types given and update the environment with the
           local constraints. Raise [Unify] if not possible. *)
val unify_var: Env.t -> type_expr -> type_expr -> unit
        (* Same as [unify], but allow free univars when first type
           is a variable. *)
val filter_arrow: Env.t -> type_expr -> label -> type_expr * type_expr
        (* A special case of unification (with l:'a -> 'b). *)
val filter_method: Env.t -> string -> private_flag -> type_expr -> type_expr
        (* A special case of unification (with {m : 'a; 'b}). *)
val check_filter_method: Env.t -> string -> private_flag -> type_expr -> unit
        (* A special case of unification (with {m : 'a; 'b}), returning unit. *)
val occur_in: Env.t -> type_expr -> type_expr -> bool
val deep_occur: type_expr -> type_expr -> bool
val filter_self_method:
        Env.t -> string -> private_flag -> (Ident.t * type_expr) Meths.t ref ->
        type_expr -> Ident.t * type_expr
val moregeneral: Env.t -> bool -> type_expr -> type_expr -> bool
        (* Check if the first type scheme is more general than the second. *)

val rigidify: type_expr -> type_expr list
        (* "Rigidify" a type and return its type variable *)
val all_distinct_vars: Env.t -> type_expr list -> bool
        (* Check those types are all distinct type variables *)
val matches: Env.t -> type_expr -> type_expr -> bool
        (* Same as [moregeneral false], implemented using the two above
           functions and backtracking. Ignore levels *)

type class_match_failure =
    CM_Virtual_class
  | CM_Parameter_arity_mismatch of int * int
  | CM_Type_parameter_mismatch of Env.t * (type_expr * type_expr) list
  | CM_Class_type_mismatch of Env.t * class_type * class_type
  | CM_Parameter_mismatch of Env.t * (type_expr * type_expr) list
  | CM_Val_type_mismatch of string * Env.t * (type_expr * type_expr) list
  | CM_Meth_type_mismatch of string * Env.t * (type_expr * type_expr) list
  | CM_Non_mutable_value of string
  | CM_Non_concrete_value of string
  | CM_Missing_value of string
  | CM_Missing_method of string
  | CM_Hide_public of string
  | CM_Hide_virtual of string * string
  | CM_Public_method of string
  | CM_Private_method of string
  | CM_Virtual_method of string
val match_class_types:
    ?trace:bool -> Env.t -> class_type -> class_type -> class_match_failure list
        (* Check if the first class type is more general than the second. *)
val equal: Env.t -> bool -> type_expr list -> type_expr list -> bool
        (* [equal env [x1...xn] tau [y1...yn] sigma]
           checks whether the parameterized types
           [/\x1.../\xn.tau] and [/\y1.../\yn.sigma] are equivalent. *)
val match_class_declarations:
        Env.t -> type_expr list -> class_type -> type_expr list ->
        class_type -> class_match_failure list
        (* Check if the first class type is more general than the second. *)

val enlarge_type: Env.t -> type_expr -> type_expr * bool
        (* Make a type larger, flag is true if some pruning had to be done *)
val subtype: Env.t -> type_expr -> type_expr -> unit -> unit
        (* [subtype env t1 t2] checks that [t1] is a subtype of [t2].
           It accumulates the constraints the type variables must
           enforce and returns a function that inforce this
           constraints. *)

val nondep_type: Env.t -> Ident.t -> type_expr -> type_expr
        (* Return a type equivalent to the given type but without
           references to the given module identifier. Raise [Not_found]
           if no such type exists. *)
val nondep_type_decl:
        Env.t -> Ident.t -> Ident.t -> bool -> type_declaration ->
        type_declaration
        (* Same for type declarations. *)
val nondep_extension_constructor:
        Env.t -> Ident.t -> extension_constructor ->
        extension_constructor
          (* Same for extension constructor *)
val nondep_class_declaration:
        Env.t -> Ident.t -> class_declaration -> class_declaration
        (* Same for class declarations. *)
val nondep_cltype_declaration:
        Env.t -> Ident.t -> class_type_declaration -> class_type_declaration
        (* Same for class type declarations. *)
(*val correct_abbrev: Env.t -> Path.t -> type_expr list -> type_expr -> unit*)
val cyclic_abbrev: Env.t -> Ident.t -> type_expr -> bool
val is_contractive: Env.t -> type_expr -> bool
val normalize_type: Env.t -> type_expr -> unit

val closed_schema: type_expr -> bool
        (* Check whether the given type scheme contains no non-generic
           type variables *)

val free_variables: ?env:Env.t -> type_expr -> type_expr list
        (* If env present, then check for incomplete definitions too *)
val closed_type_decl: type_declaration -> type_expr option
val closed_extension_constructor: extension_constructor -> type_expr option
type closed_class_failure =
    CC_Method of type_expr * bool * string * type_expr
  | CC_Value of type_expr * bool * string * type_expr
val closed_class:
        type_expr list -> class_signature -> closed_class_failure option
        (* Check whether all type variables are bound *)

val unalias: type_expr -> type_expr
val signature_of_class_type: class_type -> class_signature
val self_type: class_type -> type_expr
val class_type_arity: class_type -> int
val arity: type_expr -> int
        (* Return the arity (as for curried functions) of the given type. *)

val collapse_conj_params: Env.t -> type_expr list -> unit
        (* Collapse conjunctive types in class parameters *)

val get_current_level: unit -> int
val wrap_trace_gadt_instances: Env.t -> ('a -> 'b) -> 'a -> 'b

(* Stubs *)
val package_subtype :
    (Env.t -> Path.t -> Longident.t list -> type_expr list ->
      Path.t -> Longident.t list -> type_expr list -> bool) ref

end = struct
(*#1 "ctype.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(* Xavier Leroy and Jerome Vouillon, projet Cristal, INRIA Rocquencourt*)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Operations on core types *)

open Misc
open Asttypes
open Types
open Btype

(*
   Type manipulation after type inference
   ======================================
   If one wants to manipulate a type after type inference (for
   instance, during code generation or in the debugger), one must
   first make sure that the type levels are correct, using the
   function [correct_levels]. Then, this type can be correctely
   manipulated by [apply], [expand_head] and [moregeneral].
*)

(*
   General notes
   =============
   - As much sharing as possible should be kept : it makes types
     smaller and better abbreviated.
     When necessary, some sharing can be lost. Types will still be
     printed correctly (+++ TO DO...), and abbreviations defined by a
     class do not depend on sharing thanks to constrained
     abbreviations. (Of course, even if some sharing is lost, typing
     will still be correct.)
   - All nodes of a type have a level : that way, one know whether a
     node need to be duplicated or not when instantiating a type.
   - Levels of a type are decreasing (generic level being considered
     as greatest).
   - The level of a type constructor is superior to the binding
     time of its path.
   - Recursive types without limitation should be handled (even if
     there is still an occur check). This avoid treating specially the
     case for objects, for instance. Furthermore, the occur check
     policy can then be easily changed.
*)

(*
   A faire
   =======
   - Revoir affichage des types.
   - Etendre la portee d'un alias [... as 'a] a tout le type englobant.
   - #-type implementes comme de vraies abreviations.
   - Niveaux plus fins pour les identificateurs :
       Champ [global] renomme en [level];
       Niveau -1 : global
               0 : module toplevel
               1 : module contenu dans module toplevel
              ...
     En fait, incrementer le niveau a chaque fois que l'on rentre dans
     un module.

       3   4 6
        \ / /
       1 2 5
        \|/
         0

     [Subst] doit ecreter les niveaux (pour qu'un variable non
     generalisable dans un module de niveau 2 ne se retrouve pas
     generalisable lorsque l'on l'utilise au niveau 0).

   - Traitement de la trace de l'unification separe de la fonction
     [unify].
*)

(**** Errors ****)

exception Unify of (type_expr * type_expr) list

exception Tags of label * label

let () =
  Location.register_error_of_exn
    (function
      | Tags (l, l') ->
          Some
            Location.
              (errorf ~loc:(in_file !input_name)
                 "In this program,@ variant constructors@ `%s and `%s@ \
                  have the same hash value.@ Change one of them." l l'
              )
      | _ -> None
    )

exception Subtype of
        (type_expr * type_expr) list * (type_expr * type_expr) list

exception Cannot_expand

exception Cannot_apply

exception Recursive_abbrev

(* GADT: recursive abbrevs can appear as a result of local constraints *)
exception Unification_recursive_abbrev of (type_expr * type_expr) list

(**** Type level management ****)

let current_level = ref 0
let nongen_level = ref 0
let global_level = ref 1
let saved_level = ref []

let get_current_level () = !current_level
let init_def level = current_level := level; nongen_level := level
let begin_def () =
  saved_level := (!current_level, !nongen_level) :: !saved_level;
  incr current_level; nongen_level := !current_level
let begin_class_def () =
  saved_level := (!current_level, !nongen_level) :: !saved_level;
  incr current_level
let raise_nongen_level () =
  saved_level := (!current_level, !nongen_level) :: !saved_level;
  nongen_level := !current_level
let end_def () =
  let (cl, nl) = List.hd !saved_level in
  saved_level := List.tl !saved_level;
  current_level := cl; nongen_level := nl

let reset_global_level () =
  global_level := !current_level + 1
let increase_global_level () =
  let gl = !global_level in
  global_level := !current_level;
  gl
let restore_global_level gl =
  global_level := gl

(**** Whether a path points to an object type (with hidden row variable) ****)
let is_object_type path =
  let name =
    match path with Path.Pident id -> Ident.name id
    | Path.Pdot(_, s,_) -> s
    | Path.Papply _ -> assert false
  in name.[0] = '#'

(**** Control tracing of GADT instances *)

let trace_gadt_instances = ref false
let check_trace_gadt_instances env =
  not !trace_gadt_instances && Env.has_local_constraints env &&
  (trace_gadt_instances := true; cleanup_abbrev (); true)

let reset_trace_gadt_instances b =
  if b then trace_gadt_instances := false

let wrap_trace_gadt_instances env f x =
  let b = check_trace_gadt_instances env in
  let y = f x in
  reset_trace_gadt_instances b;
  y

(**** Abbreviations without parameters ****)
(* Shall reset after generalizing *)

let simple_abbrevs = ref Mnil

let proper_abbrevs path tl abbrev =
  if tl <> [] || !trace_gadt_instances || !Clflags.principal ||
     is_object_type path
  then abbrev
  else simple_abbrevs

(**** Some type creators ****)

(* Re-export generic type creators *)

let newty2             = Btype.newty2
let newty desc         = newty2 !current_level desc
let new_global_ty desc = newty2 !global_level desc

let newvar ?name ()         = newty2 !current_level (Tvar name)
let newvar2 ?name level     = newty2 level (Tvar name)
let new_global_var ?name () = newty2 !global_level (Tvar name)

let newobj fields      = newty (Tobject (fields, ref None))

let newconstr path tyl = newty (Tconstr (path, tyl, ref Mnil))

let none = newty (Ttuple [])                (* Clearly ill-formed type *)

(**** Representative of a type ****)

(* Re-export repr *)
let repr = repr

(**** Type maps ****)

module TypePairs =
  Hashtbl.Make (struct
    type t = type_expr * type_expr
    let equal (t1, t1') (t2, t2') = (t1 == t2) && (t1' == t2')
    let hash (t, t') = t.id + 93 * t'.id
 end)


(**** unification mode ****)

type unification_mode =
  | Expression (* unification in expression *)
  | Pattern (* unification in pattern which may add local constraints *)

let umode = ref Expression
let generate_equations = ref false
let assume_injective = ref false

let set_mode_expression f =
  let old_unification_mode = !umode in
  try
    umode := Expression;
    let ret = f () in
    umode := old_unification_mode;
    ret
  with e ->
    umode := old_unification_mode;
    raise e

let set_mode_pattern ~generate ~injective f =
  let old_unification_mode = !umode
  and old_gen = !generate_equations
  and old_inj = !assume_injective in
  try
    umode := Pattern;
    generate_equations := generate;
    assume_injective := injective;
    let ret = f () in
    umode := old_unification_mode;
    generate_equations := old_gen;
    assume_injective := old_inj;
    ret
  with e ->
    umode := old_unification_mode;
    generate_equations := old_gen;
    assume_injective := old_inj;
    raise e

(*** Checks for type definitions ***)

let in_current_module = function
  | Path.Pident _ -> true
  | Path.Pdot _ | Path.Papply _ -> false

let in_pervasives p =
  in_current_module p &&
  try ignore (Env.find_type p Env.initial_safe_string); true
  with Not_found -> false

let is_datatype decl=
  match decl.type_kind with
    Type_record _ | Type_variant _ | Type_open -> true
  | Type_abstract -> false


                  (**********************************************)
                  (*  Miscellaneous operations on object types  *)
                  (**********************************************)

(* Note:
   We need to maintain some invariants:
   * cty_self must be a Tobject
   * ...
*)

(**** Object field manipulation. ****)

let object_fields ty =
  match (repr ty).desc with
    Tobject (fields, _) -> fields
  | _                   -> assert false

let flatten_fields ty =
  let rec flatten l ty =
    let ty = repr ty in
    match ty.desc with
      Tfield(s, k, ty1, ty2) ->
        flatten ((s, k, ty1)::l) ty2
    | _ ->
        (l, ty)
  in
    let (l, r) = flatten [] ty in
    (List.sort (fun (n, _, _) (n', _, _) -> compare n n') l, r)

let build_fields level =
  List.fold_right
    (fun (s, k, ty1) ty2 -> newty2 level (Tfield(s, k, ty1, ty2)))

let associate_fields fields1 fields2 =
  let rec associate p s s' =
    function
      (l, []) ->
        (List.rev p, (List.rev s) @ l, List.rev s')
    | ([], l') ->
        (List.rev p, List.rev s, (List.rev s') @ l')
    | ((n, k, t)::r, (n', k', t')::r') when n = n' ->
        associate ((n, k, t, k', t')::p) s s' (r, r')
    | ((n, k, t)::r, ((n', k', t')::_ as l')) when n < n' ->
        associate p ((n, k, t)::s) s' (r, l')
    | (((n, k, t)::r as l), (n', k', t')::r') (* when n > n' *) ->
        associate p s ((n', k', t')::s') (l, r')
  in
  associate [] [] [] (fields1, fields2)

(**** Check whether an object is open ****)

(* +++ Il faudra penser a eventuellement expanser l'abreviation *)
let rec object_row ty =
  let ty = repr ty in
  match ty.desc with
    Tobject (t, _)     -> object_row t
  | Tfield(_, _, _, t) -> object_row t
  | _ -> ty

let opened_object ty =
  match (object_row ty).desc with
  | Tvar _  | Tunivar _ | Tconstr _ -> true
  | _                               -> false

let concrete_object ty =
  match (object_row ty).desc with
  | Tvar _             -> false
  | _                  -> true

(**** Close an object ****)

let close_object ty =
  let rec close ty =
    let ty = repr ty in
    match ty.desc with
      Tvar _ ->
        link_type ty (newty2 ty.level Tnil)
    | Tfield(_, _, _, ty') -> close ty'
    | _                    -> assert false
  in
  match (repr ty).desc with
    Tobject (ty, _)   -> close ty
  | _                 -> assert false

(**** Row variable of an object type ****)

let row_variable ty =
  let rec find ty =
    let ty = repr ty in
    match ty.desc with
      Tfield (_, _, _, ty) -> find ty
    | Tvar _               -> ty
    | _                    -> assert false
  in
  match (repr ty).desc with
    Tobject (fi, _) -> find fi
  | _               -> assert false

(**** Object name manipulation ****)
(* +++ Bientot obsolete *)

let set_object_name id rv params ty =
  match (repr ty).desc with
    Tobject (fi, nm) ->
      set_name nm (Some (Path.Pident id, rv::params))
  | _ ->
      assert false

let remove_object_name ty =
  match (repr ty).desc with
    Tobject (_, nm)   -> set_name nm None
  | Tconstr (_, _, _) -> ()
  | _                 -> fatal_error "Ctype.remove_object_name"

(**** Hiding of private methods ****)

let hide_private_methods ty =
  match (repr ty).desc with
    Tobject (fi, nm) ->
      nm := None;
      let (fl, _) = flatten_fields fi in
      List.iter
        (function (_, k, _) ->
          match field_kind_repr k with
            Fvar r -> set_kind r Fabsent
          | _      -> ())
        fl
  | _ ->
      assert false


                              (*******************************)
                              (*  Operations on class types  *)
                              (*******************************)


let rec signature_of_class_type =
  function
    Cty_constr (_, _, cty) -> signature_of_class_type cty
  | Cty_signature sign     -> sign
  | Cty_arrow (_, ty, cty)   -> signature_of_class_type cty

let self_type cty =
  repr (signature_of_class_type cty).csig_self

let rec class_type_arity =
  function
    Cty_constr (_, _, cty) ->  class_type_arity cty
  | Cty_signature _        ->  0
  | Cty_arrow (_, _, cty)    ->  1 + class_type_arity cty


                  (*******************************************)
                  (*  Miscellaneous operations on row types  *)
                  (*******************************************)

let sort_row_fields = List.sort (fun (p,_) (q,_) -> compare p q)

let rec merge_rf r1 r2 pairs fi1 fi2 =
  match fi1, fi2 with
    (l1,f1 as p1)::fi1', (l2,f2 as p2)::fi2' ->
      if l1 = l2 then merge_rf r1 r2 ((l1,f1,f2)::pairs) fi1' fi2' else
      if l1 < l2 then merge_rf (p1::r1) r2 pairs fi1' fi2 else
      merge_rf r1 (p2::r2) pairs fi1 fi2'
  | [], _ -> (List.rev r1, List.rev_append r2 fi2, pairs)
  | _, [] -> (List.rev_append r1 fi1, List.rev r2, pairs)

let merge_row_fields fi1 fi2 =
  match fi1, fi2 with
    [], _ | _, [] -> (fi1, fi2, [])
  | [p1], _ when not (List.mem_assoc (fst p1) fi2) -> (fi1, fi2, [])
  | _, [p2] when not (List.mem_assoc (fst p2) fi1) -> (fi1, fi2, [])
  | _ -> merge_rf [] [] [] (sort_row_fields fi1) (sort_row_fields fi2)

let rec filter_row_fields erase = function
    [] -> []
  | (l,f as p)::fi ->
      let fi = filter_row_fields erase fi in
      match row_field_repr f with
        Rabsent -> fi
      | Reither(_,_,false,e) when erase -> set_row_field e Rabsent; fi
      | _ -> p :: fi

                    (**************************************)
                    (*  Check genericity of type schemes  *)
                    (**************************************)


exception Non_closed0

let rec closed_schema_rec ty =
  let ty = repr ty in
  if ty.level >= lowest_level then begin
    let level = ty.level in
    ty.level <- pivot_level - level;
    match ty.desc with
      Tvar _ when level <> generic_level ->
        raise Non_closed0
    | Tfield(_, kind, t1, t2) ->
        if field_kind_repr kind = Fpresent then
          closed_schema_rec t1;
        closed_schema_rec t2
    | Tvariant row ->
        let row = row_repr row in
        iter_row closed_schema_rec row;
        if not (static_row row) then closed_schema_rec row.row_more
    | _ ->
        iter_type_expr closed_schema_rec ty
  end

(* Return whether all variables of type [ty] are generic. *)
let closed_schema ty =
  try
    closed_schema_rec ty;
    unmark_type ty;
    true
  with Non_closed0 ->
    unmark_type ty;
    false

exception Non_closed of type_expr * bool

let free_variables = ref []
let really_closed = ref None

let rec free_vars_rec real ty =
  let ty = repr ty in
  if ty.level >= lowest_level then begin
    ty.level <- pivot_level - ty.level;
    begin match ty.desc, !really_closed with
      Tvar _, _ ->
        free_variables := (ty, real) :: !free_variables
    | Tconstr (path, tl, _), Some env ->
        begin try
          let (_, body, _) = Env.find_type_expansion path env in
          if (repr body).level <> generic_level then
            free_variables := (ty, real) :: !free_variables
        with Not_found -> ()
        end;
        List.iter (free_vars_rec true) tl
(* Do not count "virtual" free variables
    | Tobject(ty, {contents = Some (_, p)}) ->
        free_vars_rec false ty; List.iter (free_vars_rec true) p
*)
    | Tobject (ty, _), _ ->
        free_vars_rec false ty
    | Tfield (_, _, ty1, ty2), _ ->
        free_vars_rec true ty1; free_vars_rec false ty2
    | Tvariant row, _ ->
        let row = row_repr row in
        iter_row (free_vars_rec true) row;
        if not (static_row row) then free_vars_rec false row.row_more
    | _    ->
        iter_type_expr (free_vars_rec true) ty
    end;
  end

let free_vars ?env ty =
  free_variables := [];
  really_closed := env;
  free_vars_rec true ty;
  let res = !free_variables in
  free_variables := [];
  really_closed := None;
  res

let free_variables ?env ty =
  let tl = List.map fst (free_vars ?env ty) in
  unmark_type ty;
  tl

let closed_type ty =
  match free_vars ty with
      []           -> ()
  | (v, real) :: _ -> raise (Non_closed (v, real))

let closed_parameterized_type params ty =
  List.iter mark_type params;
  let ok =
    try closed_type ty; true with Non_closed _ -> false in
  List.iter unmark_type params;
  unmark_type ty;
  ok

let closed_type_decl decl =
  try
    List.iter mark_type decl.type_params;
    begin match decl.type_kind with
      Type_abstract ->
        ()
    | Type_variant v ->
        List.iter
          (fun {cd_args; cd_res; _} ->
            match cd_res with
            | Some _ -> ()
            | None -> List.iter closed_type cd_args)
          v
    | Type_record(r, rep) ->
        List.iter (fun l -> closed_type l.ld_type) r
    | Type_open -> ()
    end;
    begin match decl.type_manifest with
      None    -> ()
    | Some ty -> closed_type ty
    end;
    unmark_type_decl decl;
    None
  with Non_closed (ty, _) ->
    unmark_type_decl decl;
    Some ty

let closed_extension_constructor ext =
  try
    List.iter mark_type ext.ext_type_params;
    begin match ext.ext_ret_type with
    | Some _ -> ()
    | None -> List.iter closed_type ext.ext_args
    end;
    unmark_extension_constructor ext;
    None
  with Non_closed (ty, _) ->
    unmark_extension_constructor ext;
    Some ty

type closed_class_failure =
    CC_Method of type_expr * bool * string * type_expr
  | CC_Value of type_expr * bool * string * type_expr

exception CCFailure of closed_class_failure

let closed_class params sign =
  let ty = object_fields (repr sign.csig_self) in
  let (fields, rest) = flatten_fields ty in
  List.iter mark_type params;
  mark_type rest;
  List.iter
    (fun (lab, _, ty) -> if lab = dummy_method then mark_type ty)
    fields;
  try
    mark_type_node (repr sign.csig_self);
    List.iter
      (fun (lab, kind, ty) ->
        if field_kind_repr kind = Fpresent then
        try closed_type ty with Non_closed (ty0, real) ->
          raise (CCFailure (CC_Method (ty0, real, lab, ty))))
      fields;
    mark_type_params (repr sign.csig_self);
    List.iter unmark_type params;
    unmark_class_signature sign;
    None
  with CCFailure reason ->
    mark_type_params (repr sign.csig_self);
    List.iter unmark_type params;
    unmark_class_signature sign;
    Some reason


                            (**********************)
                            (*  Type duplication  *)
                            (**********************)


(* Duplicate a type, preserving only type variables *)
let duplicate_type ty =
  Subst.type_expr Subst.identity ty

(* Same, for class types *)
let duplicate_class_type ty =
  Subst.class_type Subst.identity ty


                         (*****************************)
                         (*  Type level manipulation  *)
                         (*****************************)

(*
   It would be a bit more efficient to remove abbreviation expansions
   rather than generalizing them: these expansions will usually not be
   used anymore. However, this is not possible in the general case, as
   [expand_abbrev] (via [subst]) requires these expansions to be
   preserved. Does it worth duplicating this code ?
*)
let rec iter_generalize tyl ty =
  let ty = repr ty in
  if (ty.level > !current_level) && (ty.level <> generic_level) then begin
    set_level ty generic_level;
    begin match ty.desc with
      Tconstr (_, _, abbrev) ->
        iter_abbrev (iter_generalize tyl) !abbrev
    | _ -> ()
    end;
    iter_type_expr (iter_generalize tyl) ty
  end else
    tyl := ty :: !tyl

let iter_generalize tyl ty =
  simple_abbrevs := Mnil;
  iter_generalize tyl ty

let generalize ty =
  iter_generalize (ref []) ty

(* Efficient repeated generalisation of the same type *)
let iterative_generalization min_level tyl =
  let tyl' = ref [] in
  List.iter (iter_generalize tyl') tyl;
  List.fold_right (fun ty l -> if ty.level <= min_level then l else ty::l)
    !tyl' []

(* Generalize the structure and lower the variables *)

let rec generalize_structure var_level ty =
  let ty = repr ty in
  if ty.level <> generic_level then begin
    if is_Tvar ty && ty.level > var_level then
      set_level ty var_level
    else if
      ty.level > !current_level &&
      match ty.desc with
        Tconstr (p, _, abbrev) ->
          not (is_object_type p) && (abbrev := Mnil; true)
      | _ -> true
    then begin
      set_level ty generic_level;
      iter_type_expr (generalize_structure var_level) ty
    end
  end

let generalize_structure var_level ty =
  simple_abbrevs := Mnil;
  generalize_structure var_level ty

(* Generalize the spine of a function, if the level >= !current_level *)

let rec generalize_spine ty =
  let ty = repr ty in
  if ty.level < !current_level || ty.level = generic_level then () else
  match ty.desc with
    Tarrow (_, ty1, ty2, _) ->
      set_level ty generic_level;
      generalize_spine ty1;
      generalize_spine ty2;
  | Tpoly (ty', _) ->
      set_level ty generic_level;
      generalize_spine ty'
  | Ttuple tyl
  | Tpackage (_, _, tyl) ->
      set_level ty generic_level;
      List.iter generalize_spine tyl
  | Tconstr (p, tyl, memo) when not (is_object_type p) ->
      set_level ty generic_level;
      memo := Mnil;
      List.iter generalize_spine tyl
  | _ -> ()

let forward_try_expand_once = (* Forward declaration *)
  ref (fun env ty -> raise Cannot_expand)

(*
   Lower the levels of a type (assume [level] is not
   [generic_level]).
*)
(*
    The level of a type constructor must be greater than its binding
    time. That way, a type constructor cannot escape the scope of its
    definition, as would be the case in
      let x = ref []
      module M = struct type t let _ = (x : t list ref) end
    (without this constraint, the type system would actually be unsound.)
*)
let get_level env p =
  try
    match (Env.find_type p env).type_newtype_level with
      | None -> Path.binding_time p
      | Some (x, _) -> x
  with
    | Not_found ->
      (* no newtypes in predef *)
      Path.binding_time p

let rec normalize_package_path env p =
  let t =
    try (Env.find_modtype p env).mtd_type
    with Not_found -> None
  in
  match t with
  | Some (Mty_ident p) -> normalize_package_path env p
  | Some (Mty_signature _ | Mty_functor _ | Mty_alias _) | None -> p

let rec update_level env level ty =
  let ty = repr ty in
  if ty.level > level then begin
    begin match Env.gadt_instance_level env ty with
      Some lv -> if level < lv then raise (Unify [(ty, newvar2 level)])
    | None -> ()
    end;
    match ty.desc with
      Tconstr(p, tl, abbrev) when level < get_level env p ->
        (* Try first to replace an abbreviation by its expansion. *)
        begin try
          (* if is_newtype env p then raise Cannot_expand; *)
          link_type ty (!forward_try_expand_once env ty);
          update_level env level ty
        with Cannot_expand ->
          (* +++ Levels should be restored... *)
          (* Format.printf "update_level: %i < %i@." level (get_level env p); *)
          if level < get_level env p then raise (Unify [(ty, newvar2 level)]);
          iter_type_expr (update_level env level) ty
        end
    | Tpackage (p, nl, tl) when level < get_level env p ->
        let p' = normalize_package_path env p in
        if Path.same p p' then raise (Unify [(ty, newvar2 level)]);
        log_type ty; ty.desc <- Tpackage (p', nl, tl);
        update_level env level ty
    | Tobject(_, ({contents=Some(p, tl)} as nm))
      when level < get_level env p ->
        set_name nm None;
        update_level env level ty
    | Tvariant row ->
        let row = row_repr row in
        begin match row.row_name with
        | Some (p, tl) when level < get_level env p ->
            log_type ty;
            ty.desc <- Tvariant {row with row_name = None}
        | _ -> ()
        end;
        set_level ty level;
        iter_type_expr (update_level env level) ty
    | Tfield(lab, _, ty1, _)
      when lab = dummy_method && (repr ty1).level > level ->
        raise (Unify [(ty1, newvar2 level)])
    | _ ->
        set_level ty level;
        (* XXX what about abbreviations in Tconstr ? *)
        iter_type_expr (update_level env level) ty
  end

(* Generalize and lower levels of contravariant branches simultaneously *)

let generalize_contravariant env =
  if !Clflags.principal then generalize_structure else update_level env

let rec generalize_expansive env var_level ty =
  let ty = repr ty in
  if ty.level <> generic_level then begin
    if ty.level > var_level then begin
      set_level ty generic_level;
      match ty.desc with
        Tconstr (path, tyl, abbrev) ->
          let variance =
            try (Env.find_type path env).type_variance
            with Not_found -> List.map (fun _ -> Variance.may_inv) tyl in
          abbrev := Mnil;
          List.iter2
            (fun v t ->
              if Variance.(mem May_weak v)
              then generalize_contravariant env var_level t
              else generalize_expansive env var_level t)
            variance tyl
      | Tpackage (_, _, tyl) ->
          List.iter (generalize_contravariant env var_level) tyl
      | Tarrow (_, t1, t2, _) ->
          generalize_contravariant env var_level t1;
          generalize_expansive env var_level t2
      | _ ->
          iter_type_expr (generalize_expansive env var_level) ty
    end
  end

let generalize_expansive env ty =
  simple_abbrevs := Mnil;
  try
    generalize_expansive env !nongen_level ty
  with Unify ([_, ty'] as tr) ->
    raise (Unify ((ty, ty') :: tr))

let generalize_global ty = generalize_structure !global_level ty
let generalize_structure ty = generalize_structure !current_level ty

(* Correct the levels of type [ty]. *)
let correct_levels ty =
  duplicate_type ty

(* Only generalize the type ty0 in ty *)
let limited_generalize ty0 ty =
  let ty0 = repr ty0 in

  let graph = Hashtbl.create 17 in
  let idx = ref lowest_level in
  let roots = ref [] in

  let rec inverse pty ty =
    let ty = repr ty in
    if (ty.level > !current_level) || (ty.level = generic_level) then begin
      decr idx;
      Hashtbl.add graph !idx (ty, ref pty);
      if (ty.level = generic_level) || (ty == ty0) then
        roots := ty :: !roots;
      set_level ty !idx;
      iter_type_expr (inverse [ty]) ty
    end else if ty.level < lowest_level then begin
      let (_, parents) = Hashtbl.find graph ty.level in
      parents := pty @ !parents
    end

  and generalize_parents ty =
    let idx = ty.level in
    if idx <> generic_level then begin
      set_level ty generic_level;
      List.iter generalize_parents !(snd (Hashtbl.find graph idx));
      (* Special case for rows: must generalize the row variable *)
      match ty.desc with
        Tvariant row ->
          let more = row_more row in
          let lv = more.level in
          if (lv < lowest_level || lv > !current_level)
          && lv <> generic_level then set_level more generic_level
      | _ -> ()
    end
  in

  inverse [] ty;
  if ty0.level < lowest_level then
    iter_type_expr (inverse []) ty0;
  List.iter generalize_parents !roots;
  Hashtbl.iter
    (fun _ (ty, _) ->
       if ty.level <> generic_level then set_level ty !current_level)
    graph


(* Compute statically the free univars of all nodes in a type *)
(* This avoids doing it repeatedly during instantiation *)

type inv_type_expr =
    { inv_type : type_expr;
      mutable inv_parents : inv_type_expr list }

let rec inv_type hash pty ty =
  let ty = repr ty in
  try
    let inv = TypeHash.find hash ty in
    inv.inv_parents <- pty @ inv.inv_parents
  with Not_found ->
    let inv = { inv_type = ty; inv_parents = pty } in
    TypeHash.add hash ty inv;
    iter_type_expr (inv_type hash [inv]) ty

let compute_univars ty =
  let inverted = TypeHash.create 17 in
  inv_type inverted [] ty;
  let node_univars = TypeHash.create 17 in
  let rec add_univar univ inv =
    match inv.inv_type.desc with
      Tpoly (ty, tl) when List.memq univ (List.map repr tl) -> ()
    | _ ->
        try
          let univs = TypeHash.find node_univars inv.inv_type in
          if not (TypeSet.mem univ !univs) then begin
            univs := TypeSet.add univ !univs;
            List.iter (add_univar univ) inv.inv_parents
          end
        with Not_found ->
          TypeHash.add node_univars inv.inv_type (ref(TypeSet.singleton univ));
          List.iter (add_univar univ) inv.inv_parents
  in
  TypeHash.iter (fun ty inv -> if is_Tunivar ty then add_univar ty inv)
    inverted;
  fun ty ->
    try !(TypeHash.find node_univars ty) with Not_found -> TypeSet.empty


                              (*******************)
                              (*  Instantiation  *)
                              (*******************)


let rec find_repr p1 =
  function
    Mnil ->
      None
  | Mcons (Public, p2, ty, _, _) when Path.same p1 p2 ->
      Some ty
  | Mcons (_, _, _, _, rem) ->
      find_repr p1 rem
  | Mlink {contents = rem} ->
      find_repr p1 rem

(*
   Generic nodes are duplicated, while non-generic nodes are left
   as-is.
   During instantiation, the description of a generic node is first
   replaced by a link to a stub ([Tsubst (newvar ())]). Once the
   copy is made, it replaces the stub.
   After instantiation, the description of generic node, which was
   stored by [save_desc], must be put back, using [cleanup_types].
*)

let abbreviations = ref (ref Mnil)
  (* Abbreviation memorized. *)

(* partial: we may not wish to copy the non generic types
   before we call type_pat *)
let rec copy ?env ?partial ?keep_names ty =
  let copy = copy ?env ?partial ?keep_names in
  let ty = repr ty in
  match ty.desc with
    Tsubst ty -> ty
  | _ ->
    if ty.level <> generic_level && partial = None then ty else
    (* We only forget types that are non generic and do not contain
       free univars *)
    let forget =
      if ty.level = generic_level then generic_level else
      match partial with
        None -> assert false
      | Some (free_univars, keep) ->
          if TypeSet.is_empty (free_univars ty) then
            if keep then ty.level else !current_level
          else generic_level
    in
    if forget <> generic_level then newty2 forget (Tvar None) else
    let desc = ty.desc in
    save_desc ty desc;
    let t = newvar() in          (* Stub *)
    begin match env with
      Some env when Env.has_local_constraints env ->
        begin match Env.gadt_instance_level env ty with
          Some lv -> Env.add_gadt_instances env lv [t]
        | None -> ()
        end
    | _ -> ()
    end;
    ty.desc <- Tsubst t;
    t.desc <-
      begin match desc with
      | Tconstr (p, tl, _) ->
          let abbrevs = proper_abbrevs p tl !abbreviations in
          begin match find_repr p !abbrevs with
            Some ty when repr ty != t -> (* XXX Commentaire... *)
              Tlink ty
          | _ ->
          (*
             One must allocate a new reference, so that abbrevia-
             tions belonging to different branches of a type are
             independent.
             Moreover, a reference containing a [Mcons] must be
             shared, so that the memorized expansion of an abbrevi-
             ation can be released by changing the content of just
             one reference.
          *)
              Tconstr (p, List.map copy tl,
                       ref (match !(!abbreviations) with
                              Mcons _ -> Mlink !abbreviations
                            | abbrev  -> abbrev))
          end
      | Tvariant row0 ->
          let row = row_repr row0 in
          let more = repr row.row_more in
          (* We must substitute in a subtle way *)
          (* Tsubst takes a tuple containing the row var and the variant *)
          begin match more.desc with
            Tsubst {desc = Ttuple [_;ty2]} ->
              (* This variant type has been already copied *)
              ty.desc <- Tsubst ty2; (* avoid Tlink in the new type *)
              Tlink ty2
          | _ ->
              (* If the row variable is not generic, we must keep it *)
              let keep = more.level <> generic_level in
              let more' =
                match more.desc with
                  Tsubst ty -> ty
                | Tconstr _ | Tnil ->
                    if keep then save_desc more more.desc;
                    copy more
                | Tvar _ | Tunivar _ ->
                    save_desc more more.desc;
                    if keep then more else newty more.desc
                |  _ -> assert false
              in
              let row =
                match repr more' with (* PR#6163 *)
                  {desc=Tconstr _} when not row.row_fixed ->
                    {row with row_fixed = true}
                | _ -> row
              in
              (* Open row if partial for pattern and contains Reither *)
              let more', row =
                match partial with
                  Some (free_univars, false) ->
                    let more' =
                      if more.id != more'.id then more' else
                      let lv = if keep then more.level else !current_level in
                      newty2 lv (Tvar None)
                    in
                    let not_reither (_, f) =
                      match row_field_repr f with
                        Reither _ -> false
                      | _ -> true
                    in
                    if row.row_closed && not row.row_fixed
                    && TypeSet.is_empty (free_univars ty)
                    && not (List.for_all not_reither row.row_fields) then
                      (more',
                       {row_fields = List.filter not_reither row.row_fields;
                        row_more = more'; row_bound = ();
                        row_closed = false; row_fixed = false; row_name = None})
                    else (more', row)
                | _ -> (more', row)
              in
              (* Register new type first for recursion *)
              more.desc <- Tsubst(newgenty(Ttuple[more';t]));
              (* Return a new copy *)
              Tvariant (copy_row copy true row keep more')
          end
      | Tfield (p, k, ty1, ty2) ->
          begin match field_kind_repr k with
            Fabsent  -> Tlink (copy ty2)
          | Fpresent -> copy_type_desc copy desc
          | Fvar r ->
              dup_kind r;
              copy_type_desc copy desc
          end
      | Tobject (ty1, _) when partial <> None ->
          Tobject (copy ty1, ref None)
      | _ -> copy_type_desc ?keep_names copy desc
      end;
    t

let simple_copy t = copy t

(**** Variants of instantiations ****)

let gadt_env env =
  if Env.has_local_constraints env
  then Some env
  else None

let instance ?partial env sch =
  let env = gadt_env env in
  let partial =
    match partial with
      None -> None
    | Some keep -> Some (compute_univars sch, keep)
  in
  let ty = copy ?env ?partial sch in
  cleanup_types ();
  ty

let instance_def sch =
  let ty = copy sch in
  cleanup_types ();
  ty

let instance_list env schl =
  let env = gadt_env env in
  let tyl = List.map (fun t -> copy ?env t) schl in
  cleanup_types ();
  tyl

let reified_var_counter = ref Vars.empty

(* names given to new type constructors.
   Used for existential types and
   local constraints *)
let get_new_abstract_name s =
  let index =
    try Vars.find s !reified_var_counter + 1
    with Not_found -> 0 in
  reified_var_counter := Vars.add s index !reified_var_counter;
  Printf.sprintf "%s#%d" s index

let new_declaration newtype manifest =
  {
    type_params = [];
    type_arity = 0;
    type_kind = Type_abstract;
    type_private = Public;
    type_manifest = manifest;
    type_variance = [];
    type_newtype_level = newtype;
    type_loc = Location.none;
    type_attributes = [];
  }

let instance_constructor ?in_pattern cstr =
  begin match in_pattern with
  | None -> ()
  | Some (env, newtype_lev) ->
      let process existential =
        let decl = new_declaration (Some (newtype_lev, newtype_lev)) None in
        let name =
          match repr existential with
            {desc = Tvar (Some name)} -> name
          | _ -> "ex"
        in
        let (id, new_env) =
          Env.enter_type (get_new_abstract_name name) decl !env in
        env := new_env;
        let to_unify = newty (Tconstr (Path.Pident id,[],ref Mnil)) in
        let tv = copy existential in
        assert (is_Tvar tv);
        link_type tv to_unify
      in
      List.iter process cstr.cstr_existentials
  end;
  let ty_res = copy cstr.cstr_res in
  let ty_args = List.map simple_copy  cstr.cstr_args in
  cleanup_types ();
  (ty_args, ty_res)

let instance_parameterized_type ?keep_names sch_args sch =
  let ty_args = List.map (fun t -> copy ?keep_names t) sch_args in
  let ty = copy sch in
  cleanup_types ();
  (ty_args, ty)

let instance_parameterized_type_2 sch_args sch_lst sch =
  let ty_args = List.map simple_copy sch_args in
  let ty_lst = List.map simple_copy sch_lst in
  let ty = copy sch in
  cleanup_types ();
  (ty_args, ty_lst, ty)

let instance_declaration decl =
  let decl =
    {decl with type_params = List.map simple_copy decl.type_params;
     type_manifest = may_map simple_copy decl.type_manifest;
     type_kind = match decl.type_kind with
     | Type_abstract -> Type_abstract
     | Type_variant cl ->
         Type_variant (
           List.map
             (fun c ->
                {c with cd_args=List.map simple_copy c.cd_args;
                        cd_res=may_map simple_copy c.cd_res})
             cl)
     | Type_record (fl, rr) ->
         Type_record (
           List.map
             (fun l ->
                {l with ld_type = copy l.ld_type}
             ) fl, rr)
     | Type_open -> Type_open
    }
  in
  cleanup_types ();
  decl

let instance_class params cty =
  let rec copy_class_type =
    function
      Cty_constr (path, tyl, cty) ->
        Cty_constr (path, List.map simple_copy tyl, copy_class_type cty)
    | Cty_signature sign ->
        Cty_signature
          {csig_self = copy sign.csig_self;
           csig_vars =
             Vars.map (function (m, v, ty) -> (m, v, copy ty)) sign.csig_vars;
           csig_concr = sign.csig_concr;
           csig_inher =
             List.map (fun (p,tl) -> (p, List.map simple_copy tl))
               sign.csig_inher}
    | Cty_arrow (l, ty, cty) ->
        Cty_arrow (l, copy ty, copy_class_type cty)
  in
  let params' = List.map simple_copy params in
  let cty' = copy_class_type cty in
  cleanup_types ();
  (params', cty')

(**** Instanciation for types with free universal variables ****)

let rec diff_list l1 l2 =
  if l1 == l2 then [] else
  match l1 with [] -> invalid_arg "Ctype.diff_list"
  | a :: l1 -> a :: diff_list l1 l2

let conflicts free bound =
  let bound = List.map repr bound in
  TypeSet.exists (fun t -> List.memq (repr t) bound) free

let delayed_copy = ref []
    (* copying to do later *)

(* Copy without sharing until there are no free univars left *)
(* all free univars must be included in [visited]            *)
let rec copy_sep fixed free bound visited ty =
  let ty = repr ty in
  let univars = free ty in
  if TypeSet.is_empty univars then
    if ty.level <> generic_level then ty else
    let t = newvar () in
    delayed_copy :=
      lazy (t.desc <- Tlink (copy ty))
      :: !delayed_copy;
    t
  else try
    let t, bound_t = List.assq ty visited in
    let dl = if is_Tunivar ty then [] else diff_list bound bound_t in
    if dl <> [] && conflicts univars dl then raise Not_found;
    t
  with Not_found -> begin
    let t = newvar() in          (* Stub *)
    let visited =
      match ty.desc with
        Tarrow _ | Ttuple _ | Tvariant _ | Tconstr _ | Tobject _ | Tpackage _ ->
          (ty,(t,bound)) :: visited
      | _ -> visited in
    let copy_rec = copy_sep fixed free bound visited in
    t.desc <-
      begin match ty.desc with
      | Tvariant row0 ->
          let row = row_repr row0 in
          let more = repr row.row_more in
          (* We shall really check the level on the row variable *)
          let keep = is_Tvar more && more.level <> generic_level in
          let more' = copy_rec more in
          let fixed' = fixed && is_Tvar (repr more') in
          let row = copy_row copy_rec fixed' row keep more' in
          Tvariant row
      | Tpoly (t1, tl) ->
          let tl = List.map repr tl in
          let tl' = List.map (fun t -> newty t.desc) tl in
          let bound = tl @ bound in
          let visited =
            List.map2 (fun ty t -> ty,(t,bound)) tl tl' @ visited in
          Tpoly (copy_sep fixed free bound visited t1, tl')
      | _ -> copy_type_desc copy_rec ty.desc
      end;
    t
  end

let instance_poly ?(keep_names=false) fixed univars sch =
  let univars = List.map repr univars in
  let copy_var ty =
    match ty.desc with
      Tunivar name -> if keep_names then newty (Tvar name) else newvar ()
    | _ -> assert false
  in
  let vars = List.map copy_var univars in
  let pairs = List.map2 (fun u v -> u, (v, [])) univars vars in
  delayed_copy := [];
  let ty = copy_sep fixed (compute_univars sch) [] pairs sch in
  List.iter Lazy.force !delayed_copy;
  delayed_copy := [];
  cleanup_types ();
  vars, ty

let instance_label fixed lbl =
  let ty_res = copy lbl.lbl_res in
  let vars, ty_arg =
    match repr lbl.lbl_arg with
      {desc = Tpoly (ty, tl)} ->
        instance_poly fixed tl ty
    | ty ->
        [], copy lbl.lbl_arg
  in
  cleanup_types ();
  (vars, ty_arg, ty_res)

(**** Instantiation with parameter substitution ****)

let unify' = (* Forward declaration *)
  ref (fun env ty1 ty2 -> raise (Unify []))

let subst env level priv abbrev ty params args body =
  if List.length params <> List.length args then raise (Unify []);
  let old_level = !current_level in
  current_level := level;
  try
    let body0 = newvar () in          (* Stub *)
    begin match ty with
      None      -> ()
    | Some ({desc = Tconstr (path, tl, _)} as ty) ->
        let abbrev = proper_abbrevs path tl abbrev in
        memorize_abbrev abbrev priv path ty body0
    | _ ->
        assert false
    end;
    abbreviations := abbrev;
    let (params', body') = instance_parameterized_type params body in
    abbreviations := ref Mnil;
    !unify' env body0 body';
    List.iter2 (!unify' env) params' args;
    current_level := old_level;
    body'
  with Unify _ as exn ->
    current_level := old_level;
    raise exn

(*
   Only the shape of the type matters, not whether is is generic or
   not. [generic_level] might be somewhat slower, but it ensures
   invariants on types are enforced (decreasing levels.), and we don't
   care about efficiency here.
*)
let apply env params body args =
  try
    subst env generic_level Public (ref Mnil) None params args body
  with
    Unify _ -> raise Cannot_apply


                              (****************************)
                              (*  Abbreviation expansion  *)
                              (****************************)

(*
   If the environnement has changed, memorized expansions might not
   be correct anymore, and so we flush the cache. This is safe but
   quite pessimistic: it would be enough to flush the cache when a
   type or module definition is overridden in the environnement.
*)
let previous_env = ref Env.empty
let string_of_kind = function Public -> "public" | Private -> "private"
let check_abbrev_env env =
  if env != !previous_env then begin
    (* prerr_endline "cleanup expansion cache"; *)
    cleanup_abbrev ();
    previous_env := env
  end


(* Expand an abbreviation. The expansion is memorized. *)
(*
   Assume the level is greater than the path binding time of the
   expanded abbreviation.
*)
(*
   An abbreviation expansion will fail in either of these cases:
   1. The type constructor does not correspond to a manifest type.
   2. The type constructor is defined in an external file, and this
      file is not in the path (missing -I options).
   3. The type constructor is not in the "local" environment. This can
      happens when a non-generic type variable has been instantiated
      afterwards to the not yet defined type constructor. (Actually,
      this cannot happen at the moment due to the strong constraints
      between type levels and constructor binding time.)
   4. The expansion requires the expansion of another abbreviation,
      and this other expansion fails.
*)
let expand_abbrev_gen kind find_type_expansion env ty =
  check_abbrev_env env;
  match ty with
    {desc = Tconstr (path, args, abbrev); level = level} ->
      let lookup_abbrev = proper_abbrevs path args abbrev in
      begin match find_expans kind path !lookup_abbrev with
        Some ty ->
          (* prerr_endline
            ("found a "^string_of_kind kind^" expansion for "^Path.name path);*)
          if level <> generic_level then
            begin try
              update_level env level ty
            with Unify _ ->
              (* XXX This should not happen.
                 However, levels are not correctly restored after a
                 typing error *)
              ()
            end;
          ty
      | None ->
          let (params, body, lv) =
            try find_type_expansion path env with Not_found ->
              raise Cannot_expand
          in
          (* prerr_endline
            ("add a "^string_of_kind kind^" expansion for "^Path.name path);*)
          let ty' = subst env level kind abbrev (Some ty) params args body in
          (* Hack to name the variant type *)
          begin match repr ty' with
            {desc=Tvariant row} as ty when static_row row ->
              ty.desc <- Tvariant { row with row_name = Some (path, args) }
          | _ -> ()
          end;
          (* For gadts, remember type as non exportable *)
          (* The ambiguous level registered for ty' should be the highest *)
          if !trace_gadt_instances then begin
            match max lv (Env.gadt_instance_level env ty) with
              None -> ()
            | Some lv ->
                if level < lv then raise (Unify [(ty, newvar2 level)]);
                Env.add_gadt_instances env lv [ty; ty']
          end;
          ty'
      end
  | _ ->
      assert false

(* Expand respecting privacy *)
let expand_abbrev ty =
  expand_abbrev_gen Public Env.find_type_expansion ty

(* Expand once the head of a type *)
let expand_head_once env ty =
  try expand_abbrev env (repr ty) with Cannot_expand -> assert false

(* Check whether a type can be expanded *)
let safe_abbrev env ty =
  let snap = Btype.snapshot () in
  try ignore (expand_abbrev env ty); true
  with Cannot_expand | Unify _ ->
    Btype.backtrack snap;
    false

(* Expand the head of a type once.
   Raise Cannot_expand if the type cannot be expanded.
   May raise Unify, if a recursion was hidden in the type. *)
let try_expand_once env ty =
  let ty = repr ty in
  match ty.desc with
    Tconstr (p, _, _) -> repr (expand_abbrev env ty)
  | _ -> raise Cannot_expand

(* This one only raises Cannot_expand *)
let try_expand_safe env ty =
  let snap = Btype.snapshot () in
  try try_expand_once env ty
  with Unify _ ->
    Btype.backtrack snap; raise Cannot_expand

(* Fully expand the head of a type. *)
let rec try_expand_head try_once env ty =
  let ty' = try_once env ty in
  try try_expand_head try_once env ty'
  with Cannot_expand -> ty'

let try_expand_head try_once env ty =
  let ty' = try_expand_head try_once env ty in
  begin match Env.gadt_instance_level env ty' with
    None -> ()
  | Some lv -> Env.add_gadt_instance_chain env lv ty
  end;
  ty'

(* Unsafe full expansion, may raise Unify. *)
let expand_head_unif env ty =
  try try_expand_head try_expand_once env ty with Cannot_expand -> repr ty

(* Safe version of expand_head, never fails *)
let expand_head env ty =
  try try_expand_head try_expand_safe env ty with Cannot_expand -> repr ty

let _ = forward_try_expand_once := try_expand_safe


(* Expand until we find a non-abstract type declaration *)

let rec extract_concrete_typedecl env ty =
  let ty = repr ty in
  match ty.desc with
    Tconstr (p, _, _) ->
      let decl = Env.find_type p env in
      if decl.type_kind <> Type_abstract then (p, p, decl) else
      let ty =
        try try_expand_once env ty with Cannot_expand -> raise Not_found
      in
      let (_, p', decl) = extract_concrete_typedecl env ty in
        (p, p', decl)
  | _ -> raise Not_found

(* Implementing function [expand_head_opt], the compiler's own version of
   [expand_head] used for type-based optimisations.
   [expand_head_opt] uses [Env.find_type_expansion_opt] to access the
   manifest type information of private abstract data types which is
   normally hidden to the type-checker out of the implementation module of
   the private abbreviation. *)

let expand_abbrev_opt =
  expand_abbrev_gen Private Env.find_type_expansion_opt

let try_expand_once_opt env ty =
  let ty = repr ty in
  match ty.desc with
    Tconstr _ -> repr (expand_abbrev_opt env ty)
  | _ -> raise Cannot_expand

let rec try_expand_head_opt env ty =
  let ty' = try_expand_once_opt env ty in
  begin try
    try_expand_head_opt env ty'
  with Cannot_expand ->
    ty'
  end

let expand_head_opt env ty =
  let snap = Btype.snapshot () in
  try try_expand_head_opt env ty
  with Cannot_expand | Unify _ -> (* expand_head shall never fail *)
    Btype.backtrack snap;
    repr ty

(* Make sure that the type parameters of the type constructor [ty]
   respect the type constraints *)
let enforce_constraints env ty =
  match ty with
    {desc = Tconstr (path, args, abbrev); level = level} ->
      begin try
        let decl = Env.find_type path env in
        ignore
          (subst env level Public (ref Mnil) None decl.type_params args
             (newvar2 level))
      with Not_found -> ()
      end
  | _ ->
      assert false

(* Recursively expand the head of a type.
   Also expand #-types. *)
let full_expand env ty =
  let ty = repr (expand_head env ty) in
  match ty.desc with
    Tobject (fi, {contents = Some (_, v::_)}) when is_Tvar (repr v) ->
      newty2 ty.level (Tobject (fi, ref None))
  | _ ->
      ty

(*
   Check whether the abbreviation expands to a well-defined type.
   During the typing of a class, abbreviations for correspondings
   types expand to non-generic types.
*)
let generic_abbrev env path =
  try
    let (_, body, _) = Env.find_type_expansion path env in
    (repr body).level = generic_level
  with
    Not_found ->
      false

let generic_private_abbrev env path =
  try
    match Env.find_type path env with
      {type_kind = Type_abstract;
       type_private = Private;
       type_manifest = Some body} ->
         (repr body).level = generic_level
    | _ -> false
  with Not_found -> false

let is_contractive env ty =
  match (repr ty).desc with
    Tconstr (p, _, _) ->
      in_pervasives p ||
      (try is_datatype (Env.find_type p env) with Not_found -> false)
  | _ -> true

(* Code moved to Typedecl

(* The marks are already used by [expand_abbrev]... *)
let visited = ref []

let rec non_recursive_abbrev env ty0 ty =
  let ty = repr ty in
  if ty == repr ty0 then raise Recursive_abbrev;
  if not (List.memq ty !visited) then begin
    visited := ty :: !visited;
    match ty.desc with
      Tconstr(p, args, abbrev) ->
        begin try
          non_recursive_abbrev env ty0 (try_expand_once_opt env ty)
        with Cannot_expand ->
          if !Clflags.recursive_types &&
            (in_pervasives p ||
             try is_datatype (Env.find_type p env) with Not_found -> false)
          then ()
          else iter_type_expr (non_recursive_abbrev env ty0) ty
        end
    | Tobject _ | Tvariant _ ->
        ()
    | _ ->
        if !Clflags.recursive_types then () else
        iter_type_expr (non_recursive_abbrev env ty0) ty
  end

let correct_abbrev env path params ty =
  check_abbrev_env env;
  let ty0 = newgenvar () in
  visited := [];
  let abbrev = Mcons (Public, path, ty0, ty0, Mnil) in
  simple_abbrevs := abbrev;
  try
    non_recursive_abbrev env ty0
      (subst env generic_level Public (ref abbrev) None [] [] ty);
    simple_abbrevs := Mnil;
    visited := []
  with exn ->
    simple_abbrevs := Mnil;
    visited := [];
    raise exn
*)

                              (*****************)
                              (*  Occur check  *)
                              (*****************)


exception Occur

let rec occur_rec env visited ty0 ty =
  if ty == ty0  then raise Occur;
  let occur_ok = !Clflags.recursive_types && is_contractive env ty in
  match ty.desc with
    Tconstr(p, tl, abbrev) ->
      begin try
        if occur_ok || List.memq ty visited then raise Occur;
        iter_type_expr (occur_rec env (ty::visited) ty0) ty
      with Occur -> try
        let ty' = try_expand_head try_expand_once env ty in
        (* Maybe we could simply make a recursive call here,
           but it seems it could make the occur check loop
           (see change in rev. 1.58) *)
        if ty' == ty0 || List.memq ty' visited then raise Occur;
        match ty'.desc with
          Tobject _ | Tvariant _ -> ()
        | _ ->
            if not (!Clflags.recursive_types && is_contractive env ty') then
              iter_type_expr (occur_rec env (ty'::visited) ty0) ty'
      with Cannot_expand ->
        if not occur_ok then raise Occur
      end
  | Tobject _ | Tvariant _ ->
      ()
  | _ ->
      if not occur_ok then
        iter_type_expr (occur_rec env visited ty0) ty

let type_changed = ref false (* trace possible changes to the studied type *)

let merge r b = if b then r := true

let occur env ty0 ty =
  let old = !type_changed in
  try
    while type_changed := false; occur_rec env [] ty0 ty; !type_changed
    do () (* prerr_endline "changed" *) done;
    merge type_changed old
  with exn ->
    merge type_changed old;
    raise (match exn with Occur -> Unify [] | _ -> exn)

let occur_in env ty0 t =
  try occur env ty0 t; false with Unify _ -> true

(* Check that a local constraint is well-founded *)
(* PR#6405: not needed since we allow recursion and work on normalized types *)
(*
let rec local_non_recursive_abbrev visited env p ty =
  let ty = repr ty in
  if not (List.memq ty !visited) then begin
    visited := ty :: !visited;
    match ty.desc with
      Tconstr(p', args, abbrev) ->
        if Path.same p p' then raise Recursive_abbrev;
        begin try
          local_non_recursive_abbrev visited env p (try_expand_once_opt env ty)
        with Cannot_expand -> ()
        end
    | _ -> ()
  end

let local_non_recursive_abbrev env p =
  local_non_recursive_abbrev (ref []) env p
*)

                   (*****************************)
                   (*  Polymorphic Unification  *)
                   (*****************************)

(* Since we cannot duplicate universal variables, unification must
   be done at meta-level, using bindings in univar_pairs *)
let rec unify_univar t1 t2 = function
    (cl1, cl2) :: rem ->
      let find_univ t cl =
        try
          let (_, r) = List.find (fun (t',_) -> t == repr t') cl in
          Some r
        with Not_found -> None
      in
      begin match find_univ t1 cl1, find_univ t2 cl2 with
        Some {contents=Some t'2}, Some _ when t2 == repr t'2 ->
          ()
      | Some({contents=None} as r1), Some({contents=None} as r2) ->
          set_univar r1 t2; set_univar r2 t1
      | None, None ->
          unify_univar t1 t2 rem
      | _ ->
          raise (Unify [])
      end
  | [] -> raise (Unify [])

(* Test the occurence of free univars in a type *)
(* that's way too expansive. Must do some kind of cacheing *)
let occur_univar env ty =
  let visited = ref TypeMap.empty in
  let rec occur_rec bound ty =
    let ty = repr ty in
    if ty.level >= lowest_level &&
      if TypeSet.is_empty bound then
        (ty.level <- pivot_level - ty.level; true)
      else try
        let bound' = TypeMap.find ty !visited in
        if TypeSet.exists (fun x -> not (TypeSet.mem x bound)) bound' then
          (visited := TypeMap.add ty (TypeSet.inter bound bound') !visited;
           true)
        else false
      with Not_found ->
        visited := TypeMap.add ty bound !visited;
        true
    then
      match ty.desc with
        Tunivar _ ->
          if not (TypeSet.mem ty bound) then raise (Unify [ty, newgenvar ()])
      | Tpoly (ty, tyl) ->
          let bound = List.fold_right TypeSet.add (List.map repr tyl) bound in
          occur_rec bound  ty
      | Tconstr (_, [], _) -> ()
      | Tconstr (p, tl, _) ->
          begin try
            let td = Env.find_type p env in
            List.iter2
              (fun t v ->
                if Variance.(mem May_pos v || mem May_neg v)
                then occur_rec bound t)
              tl td.type_variance
          with Not_found ->
            List.iter (occur_rec bound) tl
          end
      | _ -> iter_type_expr (occur_rec bound) ty
  in
  try
    occur_rec TypeSet.empty ty; unmark_type ty
  with exn ->
    unmark_type ty; raise exn

(* Grouping univars by families according to their binders *)
let add_univars =
  List.fold_left (fun s (t,_) -> TypeSet.add (repr t) s)

let get_univar_family univar_pairs univars =
  if univars = [] then TypeSet.empty else
  let insert s = function
      cl1, (_::_ as cl2) ->
        if List.exists (fun (t1,_) -> TypeSet.mem (repr t1) s) cl1 then
          add_univars s cl2
        else s
    | _ -> s
  in
  let s = List.fold_right TypeSet.add univars TypeSet.empty in
  List.fold_left insert s univar_pairs

(* Whether a family of univars escapes from a type *)
let univars_escape env univar_pairs vl ty =
  let family = get_univar_family univar_pairs vl in
  let visited = ref TypeSet.empty in
  let rec occur t =
    let t = repr t in
    if TypeSet.mem t !visited then () else begin
      visited := TypeSet.add t !visited;
      match t.desc with
        Tpoly (t, tl) ->
          if List.exists (fun t -> TypeSet.mem (repr t) family) tl then ()
          else occur t
      | Tunivar _ ->
          if TypeSet.mem t family then raise Occur
      | Tconstr (_, [], _) -> ()
      | Tconstr (p, tl, _) ->
          begin try
            let td = Env.find_type p env in
            List.iter2
              (fun t v ->
                if Variance.(mem May_pos v || mem May_neg v) then occur t)
              tl td.type_variance
          with Not_found ->
            List.iter occur tl
          end
      | _ ->
          iter_type_expr occur t
    end
  in
  try occur ty; false with Occur -> true

(* Wrapper checking that no variable escapes and updating univar_pairs *)
let enter_poly env univar_pairs t1 tl1 t2 tl2 f =
  let old_univars = !univar_pairs in
  let known_univars =
    List.fold_left (fun s (cl,_) -> add_univars s cl)
      TypeSet.empty old_univars
  in
  let tl1 = List.map repr tl1 and tl2 = List.map repr tl2 in
  if List.exists (fun t -> TypeSet.mem t known_univars) tl1 &&
    univars_escape env old_univars tl1 (newty(Tpoly(t2,tl2)))
  || List.exists (fun t -> TypeSet.mem t known_univars) tl2 &&
    univars_escape env old_univars tl2 (newty(Tpoly(t1,tl1)))
  then raise (Unify []);
  let cl1 = List.map (fun t -> t, ref None) tl1
  and cl2 = List.map (fun t -> t, ref None) tl2 in
  univar_pairs := (cl1,cl2) :: (cl2,cl1) :: old_univars;
  try let res = f t1 t2 in univar_pairs := old_univars; res
  with exn -> univar_pairs := old_univars; raise exn

let univar_pairs = ref []


                              (*****************)
                              (*  Unification  *)
                              (*****************)



let rec has_cached_expansion p abbrev =
  match abbrev with
    Mnil                   -> false
  | Mcons(_, p', _, _, rem)   -> Path.same p p' || has_cached_expansion p rem
  | Mlink rem              -> has_cached_expansion p !rem

(**** Transform error trace ****)
(* +++ Move it to some other place ? *)

let expand_trace env trace =
  List.fold_right
    (fun (t1, t2) rem ->
       (repr t1, full_expand env t1)::(repr t2, full_expand env t2)::rem)
    trace []

(* build a dummy variant type *)
let mkvariant fields closed =
  newgenty
    (Tvariant
       {row_fields = fields; row_closed = closed; row_more = newvar();
        row_bound = (); row_fixed = false; row_name = None })

(* force unification in Reither when one side has as non-conjunctive type *)
let rigid_variants = ref false

(**** Unification ****)

(* Return whether [t0] occurs in [ty]. Objects are also traversed. *)
let deep_occur t0 ty =
  let rec occur_rec ty =
    let ty = repr ty in
    if ty.level >= lowest_level then begin
      if ty == t0 then raise Occur;
      ty.level <- pivot_level - ty.level;
      iter_type_expr occur_rec ty
    end
  in
  try
    occur_rec ty; unmark_type ty; false
  with Occur ->
    unmark_type ty; true

(*
   1. When unifying two non-abbreviated types, one type is made a link
      to the other. When unifying an abbreviated type with a
      non-abbreviated type, the non-abbreviated type is made a link to
      the other one. When unifying to abbreviated types, these two
      types are kept distincts, but they are made to (temporally)
      expand to the same type.
   2. Abbreviations with at least one parameter are systematically
      expanded. The overhead does not seem to high, and that way
      abbreviations where some parameters does not appear in the
      expansion, such as ['a t = int], are correctly handled. In
      particular, for this example, unifying ['a t] with ['b t] keeps
      ['a] and ['b] distincts. (Is it really important ?)
   3. Unifying an abbreviation ['a t = 'a] with ['a] should not yield
      ['a t as 'a]. Indeed, the type variable would otherwise be lost.
      This problem occurs for abbreviations expanding to a type
      variable, but also to many other constrained abbreviations (for
      instance, [(< x : 'a > -> unit) t = <x : 'a>]). The solution is
      that, if an abbreviation is unified with some subpart of its
      parameters, then the parameter actually does not get
      abbreviated.  It would be possible to check whether some
      information is indeed lost, but it probably does not worth it.
*)

let newtype_level = ref None

let get_newtype_level () =
  match !newtype_level with
  | None -> assert false
  | Some x -> x

(* a local constraint can be added only if the rhs
   of the constraint does not contain any Tvars.
   They need to be removed using this function *)
let reify env t =
  let newtype_level = get_newtype_level () in
  let create_fresh_constr lev name =
    let decl = new_declaration (Some (newtype_level, newtype_level)) None in
    let name = get_new_abstract_name name in
    let (id, new_env) = Env.enter_type name decl !env in
    let t = newty2 lev (Tconstr (Path.Pident id,[],ref Mnil))  in
    env := new_env;
    t
  in
  let visited = ref TypeSet.empty in
  let rec iterator ty =
    let ty = repr ty in
    if TypeSet.mem ty !visited then () else begin
      visited := TypeSet.add ty !visited;
      match ty.desc with
        Tvar o ->
          let name = match o with Some s -> s | _ -> "ex" in
          let t = create_fresh_constr ty.level name in
          link_type ty t
      | Tvariant r ->
          let r = row_repr r in
          if not (static_row r) then begin
            if r.row_fixed then iterator (row_more r) else
            let m = r.row_more in
            match m.desc with
              Tvar o ->
                let name = match o with Some s -> s | _ -> "ex" in
                let t = create_fresh_constr m.level name in
                let row =
                  {r with row_fields=[]; row_fixed=true; row_more = t} in
                link_type m (newty2 m.level (Tvariant row))
            | _ -> assert false
          end;
          iter_row iterator r
      | Tconstr (p, _, _) when is_object_type p ->
          iter_type_expr iterator (full_expand !env ty)
      | _ ->
          iter_type_expr iterator ty
    end
  in
  iterator t

let is_newtype env p =
  try
    let decl = Env.find_type p env in
    decl.type_newtype_level <> None &&
    decl.type_kind = Type_abstract &&
    decl.type_private = Public
  with Not_found -> false

let non_aliasable p decl =
  (* in_pervasives p ||  (subsumed by in_current_module) *)
  in_current_module p && decl.type_newtype_level = None

(* Check for datatypes carefully; see PR#6348 *)
let rec expands_to_datatype env ty =
  let ty = repr ty in
  match ty.desc with
    Tconstr (p, _, _) ->
      begin try
        is_datatype (Env.find_type p env) ||
        expands_to_datatype env (try_expand_once env ty)
      with Not_found | Cannot_expand -> false
      end
  | _ -> false

(* mcomp type_pairs subst env t1 t2 does not raise an
   exception if it is possible that t1 and t2 are actually
   equal, assuming the types in type_pairs are equal and
   that the mapping subst holds.
   Assumes that both t1 and t2 do not contain any tvars
   and that both their objects and variants are closed
 *)

let rec mcomp type_pairs env t1 t2 =
  if t1 == t2 then () else
  let t1 = repr t1 in
  let t2 = repr t2 in
  if t1 == t2 then () else
  match (t1.desc, t2.desc) with
  | (Tvar _, _)
  | (_, Tvar _)  ->
      ()
  | (Tconstr (p1, [], _), Tconstr (p2, [], _)) when Path.same p1 p2 ->
      ()
  | _ ->
      let t1' = expand_head_opt env t1 in
      let t2' = expand_head_opt env t2 in
      (* Expansion may have changed the representative of the types... *)
      let t1' = repr t1' and t2' = repr t2' in
      if t1' == t2' then () else
      begin try TypePairs.find type_pairs (t1', t2')
      with Not_found ->
        TypePairs.add type_pairs (t1', t2') ();
        match (t1'.desc, t2'.desc) with
          (Tvar _, Tvar _) -> assert false
        | (Tarrow (l1, t1, u1, _), Tarrow (l2, t2, u2, _))
          when l1 = l2 || not (is_optional l1 || is_optional l2) ->
            mcomp type_pairs env t1 t2;
            mcomp type_pairs env u1 u2;
        | (Ttuple tl1, Ttuple tl2) ->
            mcomp_list type_pairs env tl1 tl2
        | (Tconstr (p1, tl1, _), Tconstr (p2, tl2, _)) ->
            mcomp_type_decl type_pairs env p1 p2 tl1 tl2
        | (Tconstr (p, _, _), _) | (_, Tconstr (p, _, _)) ->
            begin try
              let decl = Env.find_type p env in
              if non_aliasable p decl || is_datatype decl then raise (Unify [])
            with Not_found -> ()
            end
        (*
        | (Tpackage (p1, n1, tl1), Tpackage (p2, n2, tl2)) when n1 = n2 ->
            mcomp_list type_pairs env tl1 tl2
        *)
        | (Tpackage _, Tpackage _) -> ()
        | (Tvariant row1, Tvariant row2) ->
            mcomp_row type_pairs env row1 row2
        | (Tobject (fi1, _), Tobject (fi2, _)) ->
            mcomp_fields type_pairs env fi1 fi2
        | (Tfield _, Tfield _) ->       (* Actually unused *)
            mcomp_fields type_pairs env t1' t2'
        | (Tnil, Tnil) ->
            ()
        | (Tpoly (t1, []), Tpoly (t2, [])) ->
            mcomp type_pairs env t1 t2
        | (Tpoly (t1, tl1), Tpoly (t2, tl2)) ->
            enter_poly env univar_pairs t1 tl1 t2 tl2
              (mcomp type_pairs env)
        | (Tunivar _, Tunivar _) ->
            unify_univar t1' t2' !univar_pairs
        | (_, _) ->
            raise (Unify [])
      end

and mcomp_list type_pairs env tl1 tl2 =
  if List.length tl1 <> List.length tl2 then
    raise (Unify []);
  List.iter2 (mcomp type_pairs env) tl1 tl2

and mcomp_fields type_pairs env ty1 ty2 =
  if not (concrete_object ty1 && concrete_object ty2) then assert false;
  let (fields2, rest2) = flatten_fields ty2 in
  let (fields1, rest1) = flatten_fields ty1 in
  let (pairs, miss1, miss2) = associate_fields fields1 fields2 in
  mcomp type_pairs env rest1 rest2;
  if miss1 <> []  && (object_row ty1).desc = Tnil
  || miss2 <> []  && (object_row ty2).desc = Tnil then raise (Unify []);
  List.iter
    (function (n, k1, t1, k2, t2) ->
       mcomp_kind k1 k2;
       mcomp type_pairs env t1 t2)
    pairs

and mcomp_kind k1 k2 =
  let k1 = field_kind_repr k1 in
  let k2 = field_kind_repr k2 in
  match k1, k2 with
    (Fvar _, Fvar _)
  | (Fpresent, Fpresent) -> ()
  | _                    -> raise (Unify [])

and mcomp_row type_pairs env row1 row2 =
  let row1 = row_repr row1 and row2 = row_repr row2 in
  let r1, r2, pairs = merge_row_fields row1.row_fields row2.row_fields in
  let cannot_erase (_,f) =
    match row_field_repr f with
      Rpresent _ -> true
    | Rabsent | Reither _ -> false
  in
  if row1.row_closed && List.exists cannot_erase r2
  || row2.row_closed && List.exists cannot_erase r1 then raise (Unify []);
  List.iter
    (fun (_,f1,f2) ->
      match row_field_repr f1, row_field_repr f2 with
      | Rpresent None, (Rpresent (Some _) | Reither (_, _::_, _, _) | Rabsent)
      | Rpresent (Some _), (Rpresent None | Reither (true, _, _, _) | Rabsent)
      | (Reither (_, _::_, _, _) | Rabsent), Rpresent None
      | (Reither (true, _, _, _) | Rabsent), Rpresent (Some _) ->
          raise (Unify [])
      | Rpresent(Some t1), Rpresent(Some t2) ->
          mcomp type_pairs env t1 t2
      | Rpresent(Some t1), Reither(false, tl2, _, _) ->
          List.iter (mcomp type_pairs env t1) tl2
      | Reither(false, tl1, _, _), Rpresent(Some t2) ->
          List.iter (mcomp type_pairs env t2) tl1
      | _ -> ())
    pairs

and mcomp_type_decl type_pairs env p1 p2 tl1 tl2 =
  try
    let decl = Env.find_type p1 env in
    let decl' = Env.find_type p2 env in
    if Path.same p1 p2 then begin
      let inj =
        try List.map Variance.(mem Inj) (Env.find_type p1 env).type_variance
        with Not_found -> List.map (fun _ -> false) tl1
      in
      List.iter2
        (fun i (t1,t2) -> if i then mcomp type_pairs env t1 t2)
        inj (List.combine tl1 tl2)
    end else if non_aliasable p1 decl && non_aliasable p2 decl' then
      raise (Unify [])
    else
      match decl.type_kind, decl'.type_kind with
      | Type_record (lst,r), Type_record (lst',r') when r = r' ->
          mcomp_list type_pairs env tl1 tl2;
          mcomp_record_description type_pairs env lst lst'
      | Type_variant v1, Type_variant v2 ->
          mcomp_list type_pairs env tl1 tl2;
          mcomp_variant_description type_pairs env v1 v2
      | Type_open, Type_open ->
          mcomp_list type_pairs env tl1 tl2
      | Type_abstract, Type_abstract -> ()
      | Type_abstract, _ when not (non_aliasable p1 decl)-> ()
      | _, Type_abstract when not (non_aliasable p2 decl') -> ()
      | _ -> raise (Unify [])
  with Not_found -> ()

and mcomp_type_option type_pairs env t t' =
  match t, t' with
    None, None -> ()
  | Some t, Some t' -> mcomp type_pairs env t t'
  | _ -> raise (Unify [])

and mcomp_variant_description type_pairs env xs ys =
  let rec iter = fun x y ->
    match x, y with
    | c1 :: xs, c2 :: ys   ->
      mcomp_type_option type_pairs env c1.cd_res c2.cd_res;
      mcomp_list type_pairs env c1.cd_args c2.cd_args;
     if Ident.name c1.cd_id = Ident.name c2.cd_id
      then iter xs ys
      else raise (Unify [])
    | [],[] -> ()
    | _ -> raise (Unify [])
  in
  iter xs ys

and mcomp_record_description type_pairs env =
  let rec iter x y =
    match x, y with
    | l1 :: xs, l2 :: ys ->
        mcomp type_pairs env l1.ld_type l2.ld_type;
        if Ident.name l1.ld_id = Ident.name l2.ld_id &&
           l1.ld_mutable = l2.ld_mutable
        then iter xs ys
        else raise (Unify [])
    | [], [] -> ()
    | _ -> raise (Unify [])
  in
  iter

let mcomp env t1 t2 =
  mcomp (TypePairs.create 4) env t1 t2

(* Real unification *)

let find_lowest_level ty =
  let lowest = ref generic_level in
  let rec find ty =
    let ty = repr ty in
    if ty.level >= lowest_level then begin
      if ty.level < !lowest then lowest := ty.level;
      ty.level <- pivot_level - ty.level;
      iter_type_expr find ty
    end
  in find ty; unmark_type ty; !lowest

let find_newtype_level env path =
  try match (Env.find_type path env).type_newtype_level with
    Some x -> x
  | None -> assert false
  with Not_found -> assert false

let add_gadt_equation env source destination =
  let destination = duplicate_type destination in
  let source_lev = find_newtype_level !env (Path.Pident source) in
  let decl = new_declaration (Some source_lev) (Some destination) in
  let newtype_level = get_newtype_level () in
  env := Env.add_local_constraint source decl newtype_level !env;
  cleanup_abbrev ()

let unify_eq_set = TypePairs.create 11

let order_type_pair t1 t2 =
  if t1.id <= t2.id then (t1, t2) else (t2, t1)

let add_type_equality t1 t2 =
  TypePairs.add unify_eq_set (order_type_pair t1 t2) ()

let eq_package_path env p1 p2 =
  Path.same p1 p2 ||
  Path.same (normalize_package_path env p1) (normalize_package_path env p2)

let nondep_type' = ref (fun _ _ _ -> assert false)
let package_subtype = ref (fun _ _ _ _ _ _ _ -> assert false)

let rec concat_longident lid1 =
  let open Longident in
  function
    Lident s -> Ldot (lid1, s)
  | Ldot (lid2, s) -> Ldot (concat_longident lid1 lid2, s)
  | Lapply (lid2, lid) -> Lapply (concat_longident lid1 lid2, lid)

let nondep_instance env level id ty =
  let ty = !nondep_type' env id ty in
  if level = generic_level then duplicate_type ty else
  let old = !current_level in
  current_level := level;
  let ty = instance env ty in
  current_level := old;
  ty

(* Find the type paths nl1 in the module type mty2, and add them to the
   list (nl2, tl2). raise Not_found if impossible *)
let complete_type_list ?(allow_absent=false) env nl1 lv2 mty2 nl2 tl2 =
  let id2 = Ident.create "Pkg" in
  let env' = Env.add_module id2 mty2 env in
  let rec complete nl1 ntl2 =
    match nl1, ntl2 with
      [], _ -> ntl2
    | n :: nl, (n2, _ as nt2) :: ntl' when n >= n2 ->
        nt2 :: complete (if n = n2 then nl else nl1) ntl'
    | n :: nl, _ ->
        try
          let (_, decl) =
            Env.lookup_type (concat_longident (Longident.Lident "Pkg") n) env'
          in
          match decl with
            {type_arity = 0; type_kind = Type_abstract;
             type_private = Public; type_manifest = Some t2} ->
               (n, nondep_instance env' lv2 id2 t2) :: complete nl ntl2
          | {type_arity = 0; type_kind = Type_abstract;
             type_private = Public; type_manifest = None} when allow_absent ->
               complete nl ntl2
          | _ -> raise Exit
        with
        | Not_found when allow_absent -> complete nl ntl2
        | Exit -> raise Not_found
  in
  complete nl1 (List.combine nl2 tl2)

(* raise Not_found rather than Unify if the module types are incompatible *)
let unify_package env unify_list lv1 p1 n1 tl1 lv2 p2 n2 tl2 =
  let ntl2 = complete_type_list env n1 lv2 (Mty_ident p2) n2 tl2
  and ntl1 = complete_type_list env n2 lv2 (Mty_ident p1) n1 tl1 in
  unify_list (List.map snd ntl1) (List.map snd ntl2);
  if eq_package_path env p1 p2
  || !package_subtype env p1 n1 tl1 p2 n2 tl2
  && !package_subtype env p2 n2 tl2 p1 n1 tl1 then () else raise Not_found


let unify_eq env t1 t2 =
  t1 == t2 ||
  match !umode with
  | Expression -> false
  | Pattern ->
      try TypePairs.find unify_eq_set (order_type_pair t1 t2); true
      with Not_found -> false

let rec unify (env:Env.t ref) t1 t2 =
  (* First step: special cases (optimizations) *)
  if t1 == t2 then () else
  let t1 = repr t1 in
  let t2 = repr t2 in
  if unify_eq !env t1 t2 then () else
  let reset_tracing = check_trace_gadt_instances !env in

  try
    type_changed := true;
    begin match (t1.desc, t2.desc) with
      (Tvar _, Tconstr _) when deep_occur t1 t2 ->
        unify2 env t1 t2
    | (Tconstr _, Tvar _) when deep_occur t2 t1 ->
        unify2 env t1 t2
    | (Tvar _, _) ->
        occur !env t1 t2;
        occur_univar !env t2;
        link_type t1 t2;
        update_level !env t1.level t2
    | (_, Tvar _) ->
        occur !env t2 t1;
        occur_univar !env t1;
        link_type t2 t1;
        update_level !env t2.level t1
    | (Tunivar _, Tunivar _) ->
        unify_univar t1 t2 !univar_pairs;
        update_level !env t1.level t2;
        link_type t1 t2
    | (Tconstr (p1, [], a1), Tconstr (p2, [], a2))
          when Path.same p1 p2 (* && actual_mode !env = Old *)
            (* This optimization assumes that t1 does not expand to t2
               (and conversely), so we fall back to the general case
               when any of the types has a cached expansion. *)
            && not (has_cached_expansion p1 !a1
                 || has_cached_expansion p2 !a2) ->
        update_level !env t1.level t2;
        link_type t1 t2
    | (Tconstr (p1, [], _), Tconstr (p2, [], _))
      when Env.has_local_constraints !env
      && is_newtype !env p1 && is_newtype !env p2 ->
        (* Do not use local constraints more than necessary *)
        begin try
          if find_newtype_level !env p1 < find_newtype_level !env p2 then
            unify env t1 (try_expand_once !env t2)
          else
            unify env (try_expand_once !env t1) t2
        with Cannot_expand ->
          unify2 env t1 t2
        end
    | _ ->
        unify2 env t1 t2
    end;
    reset_trace_gadt_instances reset_tracing;
  with Unify trace ->
    reset_trace_gadt_instances reset_tracing;
    raise (Unify ((t1, t2)::trace))

and unify2 env t1 t2 =
  (* Second step: expansion of abbreviations *)
  let rec expand_both t1'' t2'' =
    let t1' = expand_head_unif !env t1 in
    let t2' = expand_head_unif !env t2 in
    (* Expansion may have changed the representative of the types... *)
    if unify_eq !env t1' t1'' && unify_eq !env t2' t2'' then (t1',t2') else
    expand_both t1' t2'
  in
  let t1', t2' = expand_both t1 t2 in
  let lv = min t1'.level t2'.level in
  update_level !env lv t2;
  update_level !env lv t1;
  if unify_eq !env t1' t2' then () else

  let t1 = repr t1 and t2 = repr t2 in
  if !trace_gadt_instances then begin
    (* All types in chains already have the same ambiguity levels *)
    let ilevel t =
      match Env.gadt_instance_level !env t with None -> 0 | Some lv -> lv in
    let lv1 = ilevel t1 and lv2 = ilevel t2 in
    if lv1 > lv2 then Env.add_gadt_instance_chain !env lv1 t2 else
    if lv2 > lv1 then Env.add_gadt_instance_chain !env lv2 t1
  end;
  let t1, t2 =
    if !Clflags.principal
    && (find_lowest_level t1' < lv || find_lowest_level t2' < lv) then
      (* Expand abbreviations hiding a lower level *)
      (* Should also do it for parameterized types, after unification... *)
      (match t1.desc with Tconstr (_, [], _) -> t1' | _ -> t1),
      (match t2.desc with Tconstr (_, [], _) -> t2' | _ -> t2)
    else (t1, t2)
  in
  if unify_eq !env t1 t1' || not (unify_eq !env t2 t2') then
    unify3 env t1 t1' t2 t2'
  else
    try unify3 env t2 t2' t1 t1' with Unify trace ->
      raise (Unify (List.map (fun (x, y) -> (y, x)) trace))

and unify3 env t1 t1' t2 t2' =
  (* Third step: truly unification *)
  (* Assumes either [t1 == t1'] or [t2 != t2'] *)
  let d1 = t1'.desc and d2 = t2'.desc in
  let create_recursion = (t2 != t2') && (deep_occur t1' t2) in

  begin match (d1, d2) with (* handle vars and univars specially *)
    (Tunivar _, Tunivar _) ->
      unify_univar t1' t2' !univar_pairs;
      link_type t1' t2'
  | (Tvar _, _) ->
      occur !env t1' t2;
      occur_univar !env t2;
      link_type t1' t2;
  | (_, Tvar _) ->
      occur !env t2' t1;
      occur_univar !env t1;
      link_type t2' t1;
  | (Tfield _, Tfield _) -> (* special case for GADTs *)
      unify_fields env t1' t2'
  | _ ->
    begin match !umode with
    | Expression ->
        occur !env t1' t2';
        link_type t1' t2
    | Pattern ->
        add_type_equality t1' t2'
    end;
    try
      begin match (d1, d2) with
        (Tarrow (l1, t1, u1, c1), Tarrow (l2, t2, u2, c2)) when l1 = l2 ||
        !Clflags.classic && not (is_optional l1 || is_optional l2) ->
          unify  env t1 t2; unify env  u1 u2;
          begin match commu_repr c1, commu_repr c2 with
            Clink r, c2 -> set_commu r c2
          | c1, Clink r -> set_commu r c1
          | _ -> ()
          end
      | (Ttuple tl1, Ttuple tl2) ->
          unify_list env tl1 tl2
      | (Tconstr (p1, tl1, _), Tconstr (p2, tl2, _)) when Path.same p1 p2 ->
          if !umode = Expression || not !generate_equations then
            unify_list env tl1 tl2
          else if !assume_injective then
            set_mode_pattern ~generate:true ~injective:false
                             (fun () -> unify_list env tl1 tl2)
          else if in_current_module p1 (* || in_pervasives p1 *)
                  || List.exists (expands_to_datatype !env) [t1'; t1; t2] then
            unify_list env tl1 tl2
          else
            let inj =
              try List.map Variance.(mem Inj)
                    (Env.find_type p1 !env).type_variance
              with Not_found -> List.map (fun _ -> false) tl1
            in
            List.iter2
              (fun i (t1, t2) ->
                if i then unify env t1 t2 else
                set_mode_pattern ~generate:false ~injective:false
                  begin fun () ->
                    let snap = snapshot () in
                    try unify env t1 t2 with Unify _ ->
                      backtrack snap;
                      reify env t1; reify env t2
                  end)
              inj (List.combine tl1 tl2)
      | (Tconstr ((Path.Pident p) as path,[],_),
         Tconstr ((Path.Pident p') as path',[],_))
        when is_newtype !env path && is_newtype !env path'
        && !generate_equations ->
          let source,destination =
            if find_newtype_level !env path > find_newtype_level !env path'
            then  p,t2'
            else  p',t1'
          in add_gadt_equation env source destination
      | (Tconstr ((Path.Pident p) as path,[],_), _)
        when is_newtype !env path && !generate_equations ->
          reify env t2';
          (* local_non_recursive_abbrev !env (Path.Pident p) t2'; *)
          add_gadt_equation env p t2'
      | (_, Tconstr ((Path.Pident p) as path,[],_))
        when is_newtype !env path && !generate_equations ->
          reify env t1' ;
          (* local_non_recursive_abbrev !env (Path.Pident p) t1'; *)
          add_gadt_equation env p t1'
      | (Tconstr (_,_,_), _) | (_, Tconstr (_,_,_)) when !umode = Pattern ->
          reify env t1';
          reify env t2';
          if !generate_equations then mcomp !env t1' t2'
      | (Tobject (fi1, nm1), Tobject (fi2, _)) ->
          unify_fields env fi1 fi2;
          (* Type [t2'] may have been instantiated by [unify_fields] *)
          (* XXX One should do some kind of unification... *)
          begin match (repr t2').desc with
            Tobject (_, {contents = Some (_, va::_)}) when
              (match (repr va).desc with
                Tvar _|Tunivar _|Tnil -> true | _ -> false) -> ()
          | Tobject (_, nm2) -> set_name nm2 !nm1
          | _ -> ()
          end
      | (Tvariant row1, Tvariant row2) ->
          if !umode = Expression then
            unify_row env row1 row2
          else begin
            let snap = snapshot () in
            try unify_row env row1 row2
            with Unify _ ->
              backtrack snap;
              reify env t1';
              reify env t2';
              if !generate_equations then mcomp !env t1' t2'
          end
      | (Tfield(f,kind,_,rem), Tnil) | (Tnil, Tfield(f,kind,_,rem)) ->
          begin match field_kind_repr kind with
            Fvar r when f <> dummy_method ->
              set_kind r Fabsent;
              if d2 = Tnil then unify env rem t2'
              else unify env (newty2 rem.level Tnil) rem
          | _      -> raise (Unify [])
          end
      | (Tnil, Tnil) ->
          ()
      | (Tpoly (t1, []), Tpoly (t2, [])) ->
          unify env t1 t2
      | (Tpoly (t1, tl1), Tpoly (t2, tl2)) ->
          enter_poly !env univar_pairs t1 tl1 t2 tl2 (unify env)
      | (Tpackage (p1, n1, tl1), Tpackage (p2, n2, tl2)) ->
          begin try
            unify_package !env (unify_list env)
              t1.level p1 n1 tl1 t2.level p2 n2 tl2
          with Not_found ->
            if !umode = Expression then raise (Unify []);
            List.iter (reify env) (tl1 @ tl2);
            (* if !generate_equations then List.iter2 (mcomp !env) tl1 tl2 *)
          end
      | (_, _) ->
          raise (Unify [])
      end;
      (* XXX Commentaires + changer "create_recursion" *)
      if create_recursion then
        match t2.desc with
          Tconstr (p, tl, abbrev) ->
            forget_abbrev abbrev p;
            let t2'' = expand_head_unif !env t2 in
            if not (closed_parameterized_type tl t2'') then
              link_type (repr t2) (repr t2')
        | _ ->
            () (* t2 has already been expanded by update_level *)
    with Unify trace ->
      t1'.desc <- d1;
      raise (Unify trace)
  end

and unify_list env tl1 tl2 =
  if List.length tl1 <> List.length tl2 then
    raise (Unify []);
  List.iter2 (unify env) tl1 tl2

(* Build a fresh row variable for unification *)
and make_rowvar level use1 rest1 use2 rest2  =
  let set_name ty name =
    match ty.desc with
      Tvar None -> log_type ty; ty.desc <- Tvar name
    | _ -> ()
  in
  let name =
    match rest1.desc, rest2.desc with
      Tvar (Some _ as name1), Tvar (Some _ as name2) ->
        if rest1.level <= rest2.level then name1 else name2
    | Tvar (Some _ as name), _ ->
        if use2 then set_name rest2 name; name
    | _, Tvar (Some _ as name) ->
        if use1 then set_name rest2 name; name
    | _ -> None
  in
  if use1 then rest1 else
  if use2 then rest2 else newvar2 ?name level

and unify_fields env ty1 ty2 =          (* Optimization *)
  let (fields1, rest1) = flatten_fields ty1
  and (fields2, rest2) = flatten_fields ty2 in
  let (pairs, miss1, miss2) = associate_fields fields1 fields2 in
  let l1 = (repr ty1).level and l2 = (repr ty2).level in
  let va = make_rowvar (min l1 l2) (miss2=[]) rest1 (miss1=[]) rest2 in
  let d1 = rest1.desc and d2 = rest2.desc in
  try
    unify env (build_fields l1 miss1 va) rest2;
    unify env rest1 (build_fields l2 miss2 va);
    List.iter
      (fun (n, k1, t1, k2, t2) ->
        unify_kind k1 k2;
        try
          if !trace_gadt_instances then update_level !env va.level t1;
          unify env t1 t2
        with Unify trace ->
          raise (Unify ((newty (Tfield(n, k1, t1, newty Tnil)),
                         newty (Tfield(n, k2, t2, newty Tnil)))::trace)))
      pairs
  with exn ->
    log_type rest1; rest1.desc <- d1;
    log_type rest2; rest2.desc <- d2;
    raise exn

and unify_kind k1 k2 =
  let k1 = field_kind_repr k1 in
  let k2 = field_kind_repr k2 in
  if k1 == k2 then () else
  match k1, k2 with
    (Fvar r, (Fvar _ | Fpresent)) -> set_kind r k2
  | (Fpresent, Fvar r)            -> set_kind r k1
  | (Fpresent, Fpresent)          -> ()
  | _                             -> assert false

and unify_pairs mode env tpl =
  List.iter (fun (t1, t2) -> unify env t1 t2) tpl

and unify_row env row1 row2 =
  let row1 = row_repr row1 and row2 = row_repr row2 in
  let rm1 = row_more row1 and rm2 = row_more row2 in
  if unify_eq !env rm1 rm2 then () else
  let r1, r2, pairs = merge_row_fields row1.row_fields row2.row_fields in
  if r1 <> [] && r2 <> [] then begin
    let ht = Hashtbl.create (List.length r1) in
    List.iter (fun (l,_) -> Hashtbl.add ht (hash_variant l) l) r1;
    List.iter
      (fun (l,_) ->
        try raise (Tags(l, Hashtbl.find ht (hash_variant l)))
        with Not_found -> ())
      r2
  end;
  let fixed1 = row_fixed row1 and fixed2 = row_fixed row2 in
  let more =
    if fixed1 then rm1 else
    if fixed2 then rm2 else
    newty2 (min rm1.level rm2.level) (Tvar None) in
  let fixed = fixed1 || fixed2
  and closed = row1.row_closed || row2.row_closed in
  let keep switch =
    List.for_all
      (fun (_,f1,f2) ->
        let f1, f2 = switch f1 f2 in
        row_field_repr f1 = Rabsent || row_field_repr f2 <> Rabsent)
      pairs
  in
  let empty fields =
    List.for_all (fun (_,f) -> row_field_repr f = Rabsent) fields in
  (* Check whether we are going to build an empty type *)
  if closed && (empty r1 || row2.row_closed) && (empty r2 || row1.row_closed)
  && List.for_all
      (fun (_,f1,f2) ->
        row_field_repr f1 = Rabsent || row_field_repr f2 = Rabsent)
      pairs
  then raise (Unify [mkvariant [] true, mkvariant [] true]);
  let name =
    if row1.row_name <> None && (row1.row_closed || empty r2) &&
      (not row2.row_closed || keep (fun f1 f2 -> f1, f2) && empty r1)
    then row1.row_name
    else if row2.row_name <> None && (row2.row_closed || empty r1) &&
      (not row1.row_closed || keep (fun f1 f2 -> f2, f1) && empty r2)
    then row2.row_name
    else None
  in
  let row0 = {row_fields = []; row_more = more; row_bound = ();
              row_closed = closed; row_fixed = fixed; row_name = name} in
  let set_more row rest =
    let rest =
      if closed then
        filter_row_fields row.row_closed rest
      else rest in
    if rest <> [] && (row.row_closed || row_fixed row)
    || closed && row_fixed row && not row.row_closed then begin
      let t1 = mkvariant [] true and t2 = mkvariant rest false in
      raise (Unify [if row == row1 then (t1,t2) else (t2,t1)])
    end;
    (* The following test is not principal... should rather use Tnil *)
    let rm = row_more row in
    if !trace_gadt_instances && rm.desc = Tnil then () else
    if !trace_gadt_instances then
      update_level !env rm.level (newgenty (Tvariant row));
    if row_fixed row then
      if more == rm then () else
      if is_Tvar rm then link_type rm more else unify env rm more
    else
      let ty = newgenty (Tvariant {row0 with row_fields = rest}) in
      update_level !env rm.level ty;
      link_type rm ty
  in
  let md1 = rm1.desc and md2 = rm2.desc in
  begin try
    set_more row2 r1;
    set_more row1 r2;
    List.iter
      (fun (l,f1,f2) ->
        try unify_row_field env fixed1 fixed2 more l f1 f2
        with Unify trace ->
          raise (Unify ((mkvariant [l,f1] true,
                         mkvariant [l,f2] true) :: trace)))
      pairs;
  with exn ->
    log_type rm1; rm1.desc <- md1; log_type rm2; rm2.desc <- md2; raise exn
  end

and unify_row_field env fixed1 fixed2 more l f1 f2 =
  let f1 = row_field_repr f1 and f2 = row_field_repr f2 in
  if f1 == f2 then () else
  match f1, f2 with
    Rpresent(Some t1), Rpresent(Some t2) -> unify env t1 t2
  | Rpresent None, Rpresent None -> ()
  | Reither(c1, tl1, m1, e1), Reither(c2, tl2, m2, e2) ->
      if e1 == e2 then () else
      let redo =
        (m1 || m2 || fixed1 || fixed2 ||
         !rigid_variants && (List.length tl1 = 1 || List.length tl2 = 1)) &&
        begin match tl1 @ tl2 with [] -> false
        | t1 :: tl ->
            if c1 || c2 then raise (Unify []);
            List.iter (unify env t1) tl;
            !e1 <> None || !e2 <> None
        end in
      if redo then unify_row_field env fixed1 fixed2 more l f1 f2 else
      let tl1 = List.map repr tl1 and tl2 = List.map repr tl2 in
      let rec remq tl = function [] -> []
        | ty :: tl' ->
            if List.memq ty tl then remq tl tl' else ty :: remq tl tl'
      in
      let tl2' = remq tl2 tl1 and tl1' = remq tl1 tl2 in
      (* Is this handling of levels really principal? *)
      List.iter (update_level !env (repr more).level) (tl1' @ tl2');
      let e = ref None in
      let f1' = Reither(c1 || c2, tl1', m1 || m2, e)
      and f2' = Reither(c1 || c2, tl2', m1 || m2, e) in
      set_row_field e1 f1'; set_row_field e2 f2';
  | Reither(_, _, false, e1), Rabsent when not fixed1 -> set_row_field e1 f2
  | Rabsent, Reither(_, _, false, e2) when not fixed2 -> set_row_field e2 f1
  | Rabsent, Rabsent -> ()
  | Reither(false, tl, _, e1), Rpresent(Some t2) when not fixed1 ->
      set_row_field e1 f2;
      update_level !env (repr more).level t2;
      (try List.iter (fun t1 -> unify env t1 t2) tl
      with exn -> e1 := None; raise exn)
  | Rpresent(Some t1), Reither(false, tl, _, e2) when not fixed2 ->
      set_row_field e2 f1;
      update_level !env (repr more).level t1;
      (try List.iter (unify env t1) tl
      with exn -> e2 := None; raise exn)
  | Reither(true, [], _, e1), Rpresent None when not fixed1 ->
      set_row_field e1 f2
  | Rpresent None, Reither(true, [], _, e2) when not fixed2 ->
      set_row_field e2 f1
  | _ -> raise (Unify [])


let unify env ty1 ty2 =
  try
    unify env ty1 ty2
  with
    Unify trace ->
      raise (Unify (expand_trace !env trace))
  | Recursive_abbrev ->
      raise (Unification_recursive_abbrev (expand_trace !env [(ty1,ty2)]))

let unify_gadt ~newtype_level:lev (env:Env.t ref) ty1 ty2 =
  try
    univar_pairs := [];
    newtype_level := Some lev;
    set_mode_pattern ~generate:true ~injective:true
                     (fun () -> unify env ty1 ty2);
    newtype_level := None;
    TypePairs.clear unify_eq_set;
  with e ->
    TypePairs.clear unify_eq_set;
    match e with
      Unify e -> raise (Unify e)
    | e -> newtype_level := None; raise e

let unify_var env t1 t2 =
  let t1 = repr t1 and t2 = repr t2 in
  if t1 == t2 then () else
  match t1.desc with
    Tvar _ ->
      let reset_tracing = check_trace_gadt_instances env in
      begin try
        occur env t1 t2;
        update_level env t1.level t2;
        link_type t1 t2;
        reset_trace_gadt_instances reset_tracing;
      with Unify trace ->
        reset_trace_gadt_instances reset_tracing;
        let expanded_trace = expand_trace env ((t1,t2)::trace) in
        raise (Unify expanded_trace)
      end
  | _ ->
      unify (ref env) t1 t2

let _ = unify' := unify_var

let unify_pairs env ty1 ty2 pairs =
  univar_pairs := pairs;
  unify env ty1 ty2

let unify env ty1 ty2 =
  unify_pairs (ref env) ty1 ty2 []



(**** Special cases of unification ****)

let expand_head_trace env t =
  let reset_tracing = check_trace_gadt_instances env in
  let t = expand_head_unif env t in
  reset_trace_gadt_instances reset_tracing;
  t

(*
   Unify [t] and [l:'a -> 'b]. Return ['a] and ['b].
   In label mode, label mismatch is accepted when
   (1) the requested label is ""
   (2) the original label is not optional
*)

let filter_arrow env t l =
  let t = expand_head_trace env t in
  match t.desc with
    Tvar _ ->
      let lv = t.level in
      let t1 = newvar2 lv and t2 = newvar2 lv in
      let t' = newty2 lv (Tarrow (l, t1, t2, Cok)) in
      link_type t t';
      (t1, t2)
  | Tarrow(l', t1, t2, _)
    when l = l' || !Clflags.classic && l = "" && not (is_optional l') ->
      (t1, t2)
  | _ ->
      raise (Unify [])

(* Used by [filter_method]. *)
let rec filter_method_field env name priv ty =
  let ty = expand_head_trace env ty in
  match ty.desc with
    Tvar _ ->
      let level = ty.level in
      let ty1 = newvar2 level and ty2 = newvar2 level in
      let ty' = newty2 level (Tfield (name,
                                      begin match priv with
                                        Private -> Fvar (ref None)
                                      | Public  -> Fpresent
                                      end,
                                      ty1, ty2))
      in
      link_type ty ty';
      ty1
  | Tfield(n, kind, ty1, ty2) ->
      let kind = field_kind_repr kind in
      if (n = name) && (kind <> Fabsent) then begin
        if priv = Public then
          unify_kind kind Fpresent;
        ty1
      end else
        filter_method_field env name priv ty2
  | _ ->
      raise (Unify [])

(* Unify [ty] and [< name : 'a; .. >]. Return ['a]. *)
let filter_method env name priv ty =
  let ty = expand_head_trace env ty in
  match ty.desc with
    Tvar _ ->
      let ty1 = newvar () in
      let ty' = newobj ty1 in
      update_level env ty.level ty';
      link_type ty ty';
      filter_method_field env name priv ty1
  | Tobject(f, _) ->
      filter_method_field env name priv f
  | _ ->
      raise (Unify [])

let check_filter_method env name priv ty =
  ignore(filter_method env name priv ty)

let filter_self_method env lab priv meths ty =
  let ty' = filter_method env lab priv ty in
  try
    Meths.find lab !meths
  with Not_found ->
    let pair = (Ident.create lab, ty') in
    meths := Meths.add lab pair !meths;
    pair


                        (***********************************)
                        (*  Matching between type schemes  *)
                        (***********************************)

(*
   Update the level of [ty]. First check that the levels of generic
   variables from the subject are not lowered.
*)
let moregen_occur env level ty =
  let rec occur ty =
    let ty = repr ty in
    if ty.level > level then begin
      if is_Tvar ty && ty.level >= generic_level - 1 then raise Occur;
      ty.level <- pivot_level - ty.level;
      match ty.desc with
        Tvariant row when static_row row ->
          iter_row occur row
      | _ ->
          iter_type_expr occur ty
    end
  in
  begin try
    occur ty; unmark_type ty
  with Occur ->
    unmark_type ty; raise (Unify [])
  end;
  (* also check for free univars *)
  occur_univar env ty;
  update_level env level ty

let may_instantiate inst_nongen t1 =
  if inst_nongen then t1.level <> generic_level - 1
                 else t1.level =  generic_level

let rec moregen inst_nongen type_pairs env t1 t2 =
  if t1 == t2 then () else
  let t1 = repr t1 in
  let t2 = repr t2 in
  if t1 == t2 then () else

  try
    match (t1.desc, t2.desc) with
      (Tvar _, _) when may_instantiate inst_nongen t1 ->
        moregen_occur env t1.level t2;
        occur env t1 t2;
        link_type t1 t2
    | (Tconstr (p1, [], _), Tconstr (p2, [], _)) when Path.same p1 p2 ->
        ()
    | _ ->
        let t1' = expand_head env t1 in
        let t2' = expand_head env t2 in
        (* Expansion may have changed the representative of the types... *)
        let t1' = repr t1' and t2' = repr t2' in
        if t1' == t2' then () else
        begin try
          TypePairs.find type_pairs (t1', t2')
        with Not_found ->
          TypePairs.add type_pairs (t1', t2') ();
          match (t1'.desc, t2'.desc) with
            (Tvar _, _) when may_instantiate inst_nongen t1' ->
              moregen_occur env t1'.level t2;
              link_type t1' t2
          | (Tarrow (l1, t1, u1, _), Tarrow (l2, t2, u2, _)) when l1 = l2
            || !Clflags.classic && not (is_optional l1 || is_optional l2) ->
              moregen inst_nongen type_pairs env t1 t2;
              moregen inst_nongen type_pairs env u1 u2
          | (Ttuple tl1, Ttuple tl2) ->
              moregen_list inst_nongen type_pairs env tl1 tl2
          | (Tconstr (p1, tl1, _), Tconstr (p2, tl2, _))
                when Path.same p1 p2 ->
              moregen_list inst_nongen type_pairs env tl1 tl2
          | (Tpackage (p1, n1, tl1), Tpackage (p2, n2, tl2)) ->
              begin try
                unify_package env (moregen_list inst_nongen type_pairs env)
                  t1'.level p1 n1 tl1 t2'.level p2 n2 tl2
              with Not_found -> raise (Unify [])
              end
          | (Tvariant row1, Tvariant row2) ->
              moregen_row inst_nongen type_pairs env row1 row2
          | (Tobject (fi1, nm1), Tobject (fi2, nm2)) ->
              moregen_fields inst_nongen type_pairs env fi1 fi2
          | (Tfield _, Tfield _) ->           (* Actually unused *)
              moregen_fields inst_nongen type_pairs env t1' t2'
          | (Tnil, Tnil) ->
              ()
          | (Tpoly (t1, []), Tpoly (t2, [])) ->
              moregen inst_nongen type_pairs env t1 t2
          | (Tpoly (t1, tl1), Tpoly (t2, tl2)) ->
              enter_poly env univar_pairs t1 tl1 t2 tl2
                (moregen inst_nongen type_pairs env)
          | (Tunivar _, Tunivar _) ->
              unify_univar t1' t2' !univar_pairs
          | (_, _) ->
              raise (Unify [])
        end
  with Unify trace ->
    raise (Unify ((t1, t2)::trace))

and moregen_list inst_nongen type_pairs env tl1 tl2 =
  if List.length tl1 <> List.length tl2 then
    raise (Unify []);
  List.iter2 (moregen inst_nongen type_pairs env) tl1 tl2

and moregen_fields inst_nongen type_pairs env ty1 ty2 =
  let (fields1, rest1) = flatten_fields ty1
  and (fields2, rest2) = flatten_fields ty2 in
  let (pairs, miss1, miss2) = associate_fields fields1 fields2 in
  if miss1 <> [] then raise (Unify []);
  moregen inst_nongen type_pairs env rest1
    (build_fields (repr ty2).level miss2 rest2);
  List.iter
    (fun (n, k1, t1, k2, t2) ->
       moregen_kind k1 k2;
       try moregen inst_nongen type_pairs env t1 t2 with Unify trace ->
         raise (Unify ((newty (Tfield(n, k1, t1, rest2)),
                        newty (Tfield(n, k2, t2, rest2)))::trace)))
    pairs

and moregen_kind k1 k2 =
  let k1 = field_kind_repr k1 in
  let k2 = field_kind_repr k2 in
  if k1 == k2 then () else
  match k1, k2 with
    (Fvar r, (Fvar _ | Fpresent))  -> set_kind r k2
  | (Fpresent, Fpresent)           -> ()
  | _                              -> raise (Unify [])

and moregen_row inst_nongen type_pairs env row1 row2 =
  let row1 = row_repr row1 and row2 = row_repr row2 in
  let rm1 = repr row1.row_more and rm2 = repr row2.row_more in
  if rm1 == rm2 then () else
  let may_inst =
    is_Tvar rm1 && may_instantiate inst_nongen rm1 || rm1.desc = Tnil in
  let r1, r2, pairs = merge_row_fields row1.row_fields row2.row_fields in
  let r1, r2 =
    if row2.row_closed then
      filter_row_fields may_inst r1, filter_row_fields false r2
    else r1, r2
  in
  if r1 <> [] || row1.row_closed && (not row2.row_closed || r2 <> [])
  then raise (Unify []);
  begin match rm1.desc, rm2.desc with
    Tunivar _, Tunivar _ ->
      unify_univar rm1 rm2 !univar_pairs
  | Tunivar _, _ | _, Tunivar _ ->
      raise (Unify [])
  | _ when static_row row1 -> ()
  | _ when may_inst ->
      let ext = newgenty (Tvariant {row2 with row_fields = r2}) in
      moregen_occur env rm1.level ext;
      link_type rm1 ext
  | Tconstr _, Tconstr _ ->
      moregen inst_nongen type_pairs env rm1 rm2
  | _ -> raise (Unify [])
  end;
  List.iter
    (fun (l,f1,f2) ->
      let f1 = row_field_repr f1 and f2 = row_field_repr f2 in
      if f1 == f2 then () else
      match f1, f2 with
        Rpresent(Some t1), Rpresent(Some t2) ->
          moregen inst_nongen type_pairs env t1 t2
      | Rpresent None, Rpresent None -> ()
      | Reither(false, tl1, _, e1), Rpresent(Some t2) when may_inst ->
          set_row_field e1 f2;
          List.iter (fun t1 -> moregen inst_nongen type_pairs env t1 t2) tl1
      | Reither(c1, tl1, _, e1), Reither(c2, tl2, m2, e2) ->
          if e1 != e2 then begin
            if c1 && not c2 then raise(Unify []);
            set_row_field e1 (Reither (c2, [], m2, e2));
            if List.length tl1 = List.length tl2 then
              List.iter2 (moregen inst_nongen type_pairs env) tl1 tl2
            else match tl2 with
              t2 :: _ ->
                List.iter (fun t1 -> moregen inst_nongen type_pairs env t1 t2)
                  tl1
            | [] ->
                if tl1 <> [] then raise (Unify [])
          end
      | Reither(true, [], _, e1), Rpresent None when may_inst ->
          set_row_field e1 f2
      | Reither(_, _, _, e1), Rabsent when may_inst ->
          set_row_field e1 f2
      | Rabsent, Rabsent -> ()
      | _ -> raise (Unify []))
    pairs

(* Must empty univar_pairs first *)
let moregen inst_nongen type_pairs env patt subj =
  univar_pairs := [];
  moregen inst_nongen type_pairs env patt subj

(*
   Non-generic variable can be instanciated only if [inst_nongen] is
   true. So, [inst_nongen] should be set to false if the subject might
   contain non-generic variables (and we do not want them to be
   instanciated).
   Usually, the subject is given by the user, and the pattern
   is unimportant.  So, no need to propagate abbreviations.
*)
let moregeneral env inst_nongen pat_sch subj_sch =
  let old_level = !current_level in
  current_level := generic_level - 1;
  (*
     Generic variables are first duplicated with [instance].  So,
     their levels are lowered to [generic_level - 1].  The subject is
     then copied with [duplicate_type].  That way, its levels won't be
     changed.
  *)
  let subj = duplicate_type (instance env subj_sch) in
  current_level := generic_level;
  (* Duplicate generic variables *)
  let patt = instance env pat_sch in
  let res =
    try moregen inst_nongen (TypePairs.create 13) env patt subj; true with
      Unify _ -> false
  in
  current_level := old_level;
  res


(* Alternative approach: "rigidify" a type scheme,
   and check validity after unification *)
(* Simpler, no? *)

let rec rigidify_rec vars ty =
  let ty = repr ty in
  if ty.level >= lowest_level then begin
    ty.level <- pivot_level - ty.level;
    match ty.desc with
    | Tvar _ ->
        if not (List.memq ty !vars) then vars := ty :: !vars
    | Tvariant row ->
        let row = row_repr row in
        let more = repr row.row_more in
        if is_Tvar more && not (row_fixed row) then begin
          let more' = newty2 more.level more.desc in
          let row' = {row with row_fixed=true; row_fields=[]; row_more=more'}
          in link_type more (newty2 ty.level (Tvariant row'))
        end;
        iter_row (rigidify_rec vars) row;
        (* only consider the row variable if the variant is not static *)
        if not (static_row row) then rigidify_rec vars (row_more row)
    | _ ->
        iter_type_expr (rigidify_rec vars) ty
  end

let rigidify ty =
  let vars = ref [] in
  rigidify_rec vars ty;
  unmark_type ty;
  !vars

let all_distinct_vars env vars =
  let tyl = ref [] in
  List.for_all
    (fun ty ->
      let ty = expand_head env ty in
      if List.memq ty !tyl then false else
      (tyl := ty :: !tyl; is_Tvar ty))
    vars

let matches env ty ty' =
  let snap = snapshot () in
  let vars = rigidify ty in
  cleanup_abbrev ();
  let ok =
    try unify env ty ty'; all_distinct_vars env vars
    with Unify _ -> false
  in
  backtrack snap;
  ok


                 (*********************************************)
                 (*  Equivalence between parameterized types  *)
                 (*********************************************)

let rec get_object_row ty =
  match repr ty with
  | {desc=Tfield (_, _, _, tl)} -> get_object_row tl
  | ty -> ty

let expand_head_rigid env ty =
  let old = !rigid_variants in
  rigid_variants := true;
  let ty' = expand_head env ty in
  rigid_variants := old; ty'

let normalize_subst subst =
  if List.exists
      (function {desc=Tlink _}, _ | _, {desc=Tlink _} -> true | _ -> false)
      !subst
  then subst := List.map (fun (t1,t2) -> repr t1, repr t2) !subst

let rec eqtype rename type_pairs subst env t1 t2 =
  if t1 == t2 then () else
  let t1 = repr t1 in
  let t2 = repr t2 in
  if t1 == t2 then () else

  try
    match (t1.desc, t2.desc) with
      (Tvar _, Tvar _) when rename ->
        begin try
          normalize_subst subst;
          if List.assq t1 !subst != t2 then raise (Unify [])
        with Not_found ->
          if List.exists (fun (_, t) -> t == t2) !subst then raise (Unify []);
          subst := (t1, t2) :: !subst
        end
    | (Tconstr (p1, [], _), Tconstr (p2, [], _)) when Path.same p1 p2 ->
        ()
    | _ ->
        let t1' = expand_head_rigid env t1 in
        let t2' = expand_head_rigid env t2 in
        (* Expansion may have changed the representative of the types... *)
        let t1' = repr t1' and t2' = repr t2' in
        if t1' == t2' then () else
        begin try
          TypePairs.find type_pairs (t1', t2')
        with Not_found ->
          TypePairs.add type_pairs (t1', t2') ();
          match (t1'.desc, t2'.desc) with
            (Tvar _, Tvar _) when rename ->
              begin try
                normalize_subst subst;
                if List.assq t1' !subst != t2' then raise (Unify [])
              with Not_found ->
                if List.exists (fun (_, t) -> t == t2') !subst
                then raise (Unify []);
                subst := (t1', t2') :: !subst
              end
          | (Tarrow (l1, t1, u1, _), Tarrow (l2, t2, u2, _)) when l1 = l2
            || !Clflags.classic && not (is_optional l1 || is_optional l2) ->
              eqtype rename type_pairs subst env t1 t2;
              eqtype rename type_pairs subst env u1 u2;
          | (Ttuple tl1, Ttuple tl2) ->
              eqtype_list rename type_pairs subst env tl1 tl2
          | (Tconstr (p1, tl1, _), Tconstr (p2, tl2, _))
                when Path.same p1 p2 ->
              eqtype_list rename type_pairs subst env tl1 tl2
          | (Tpackage (p1, n1, tl1), Tpackage (p2, n2, tl2)) ->
              begin try
                unify_package env (eqtype_list rename type_pairs subst env)
                  t1'.level p1 n1 tl1 t2'.level p2 n2 tl2
              with Not_found -> raise (Unify [])
              end
          | (Tvariant row1, Tvariant row2) ->
              eqtype_row rename type_pairs subst env row1 row2
          | (Tobject (fi1, nm1), Tobject (fi2, nm2)) ->
              eqtype_fields rename type_pairs subst env fi1 fi2
          | (Tfield _, Tfield _) ->       (* Actually unused *)
              eqtype_fields rename type_pairs subst env t1' t2'
          | (Tnil, Tnil) ->
              ()
          | (Tpoly (t1, []), Tpoly (t2, [])) ->
              eqtype rename type_pairs subst env t1 t2
          | (Tpoly (t1, tl1), Tpoly (t2, tl2)) ->
              enter_poly env univar_pairs t1 tl1 t2 tl2
                (eqtype rename type_pairs subst env)
          | (Tunivar _, Tunivar _) ->
              unify_univar t1' t2' !univar_pairs
          | (_, _) ->
              raise (Unify [])
        end
  with Unify trace ->
    raise (Unify ((t1, t2)::trace))

and eqtype_list rename type_pairs subst env tl1 tl2 =
  if List.length tl1 <> List.length tl2 then
    raise (Unify []);
  List.iter2 (eqtype rename type_pairs subst env) tl1 tl2

and eqtype_fields rename type_pairs subst env ty1 ty2 =
  let (fields1, rest1) = flatten_fields ty1 in
  let (fields2, rest2) = flatten_fields ty2 in
  (* First check if same row => already equal *)
  let same_row =
    rest1 == rest2 || TypePairs.mem type_pairs (rest1,rest2) ||
    (rename && List.mem (rest1, rest2) !subst)
  in
  if same_row then () else
  (* Try expansion, needed when called from Includecore.type_manifest *)
  match expand_head_rigid env rest2 with
    {desc=Tobject(ty2,_)} -> eqtype_fields rename type_pairs subst env ty1 ty2
  | _ ->
  let (pairs, miss1, miss2) = associate_fields fields1 fields2 in
  eqtype rename type_pairs subst env rest1 rest2;
  if (miss1 <> []) || (miss2 <> []) then raise (Unify []);
  List.iter
    (function (n, k1, t1, k2, t2) ->
       eqtype_kind k1 k2;
       try eqtype rename type_pairs subst env t1 t2 with Unify trace ->
         raise (Unify ((newty (Tfield(n, k1, t1, rest2)),
                        newty (Tfield(n, k2, t2, rest2)))::trace)))
    pairs

and eqtype_kind k1 k2 =
  let k1 = field_kind_repr k1 in
  let k2 = field_kind_repr k2 in
  match k1, k2 with
    (Fvar _, Fvar _)
  | (Fpresent, Fpresent) -> ()
  | _                    -> raise (Unify [])

and eqtype_row rename type_pairs subst env row1 row2 =
  (* Try expansion, needed when called from Includecore.type_manifest *)
  match expand_head_rigid env (row_more row2) with
    {desc=Tvariant row2} -> eqtype_row rename type_pairs subst env row1 row2
  | _ ->
  let row1 = row_repr row1 and row2 = row_repr row2 in
  let r1, r2, pairs = merge_row_fields row1.row_fields row2.row_fields in
  if row1.row_closed <> row2.row_closed
  || not row1.row_closed && (r1 <> [] || r2 <> [])
  || filter_row_fields false (r1 @ r2) <> []
  then raise (Unify []);
  if not (static_row row1) then
    eqtype rename type_pairs subst env row1.row_more row2.row_more;
  List.iter
    (fun (_,f1,f2) ->
      match row_field_repr f1, row_field_repr f2 with
        Rpresent(Some t1), Rpresent(Some t2) ->
          eqtype rename type_pairs subst env t1 t2
      | Reither(true, [], _, _), Reither(true, [], _, _) ->
          ()
      | Reither(false, t1::tl1, _, _), Reither(false, t2::tl2, _, _) ->
          eqtype rename type_pairs subst env t1 t2;
          if List.length tl1 = List.length tl2 then
            (* if same length allow different types (meaning?) *)
            List.iter2 (eqtype rename type_pairs subst env) tl1 tl2
          else begin
            (* otherwise everything must be equal *)
            List.iter (eqtype rename type_pairs subst env t1) tl2;
            List.iter (fun t1 -> eqtype rename type_pairs subst env t1 t2) tl1
          end
      | Rpresent None, Rpresent None -> ()
      | Rabsent, Rabsent -> ()
      | _ -> raise (Unify []))
    pairs

(* Two modes: with or without renaming of variables *)
let equal env rename tyl1 tyl2 =
  try
    univar_pairs := [];
    eqtype_list rename (TypePairs.create 11) (ref []) env tyl1 tyl2; true
  with
    Unify _ -> false

(* Must empty univar_pairs first *)
let eqtype rename type_pairs subst env t1 t2 =
  univar_pairs := [];
  eqtype rename type_pairs subst env t1 t2


                          (*************************)
                          (*  Class type matching  *)
                          (*************************)


type class_match_failure =
    CM_Virtual_class
  | CM_Parameter_arity_mismatch of int * int
  | CM_Type_parameter_mismatch of Env.t * (type_expr * type_expr) list
  | CM_Class_type_mismatch of Env.t * class_type * class_type
  | CM_Parameter_mismatch of Env.t * (type_expr * type_expr) list
  | CM_Val_type_mismatch of string * Env.t * (type_expr * type_expr) list
  | CM_Meth_type_mismatch of string * Env.t * (type_expr * type_expr) list
  | CM_Non_mutable_value of string
  | CM_Non_concrete_value of string
  | CM_Missing_value of string
  | CM_Missing_method of string
  | CM_Hide_public of string
  | CM_Hide_virtual of string * string
  | CM_Public_method of string
  | CM_Private_method of string
  | CM_Virtual_method of string

exception Failure of class_match_failure list

let rec moregen_clty trace type_pairs env cty1 cty2 =
  try
    match cty1, cty2 with
      Cty_constr (_, _, cty1), _ ->
        moregen_clty true type_pairs env cty1 cty2
    | _, Cty_constr (_, _, cty2) ->
        moregen_clty true type_pairs env cty1 cty2
    | Cty_arrow (l1, ty1, cty1'), Cty_arrow (l2, ty2, cty2') when l1 = l2 ->
        begin try moregen true type_pairs env ty1 ty2 with Unify trace ->
          raise (Failure [CM_Parameter_mismatch (env, expand_trace env trace)])
        end;
        moregen_clty false type_pairs env cty1' cty2'
    | Cty_signature sign1, Cty_signature sign2 ->
        let ty1 = object_fields (repr sign1.csig_self) in
        let ty2 = object_fields (repr sign2.csig_self) in
        let (fields1, rest1) = flatten_fields ty1
        and (fields2, rest2) = flatten_fields ty2 in
        let (pairs, miss1, miss2) = associate_fields fields1 fields2 in
        List.iter
          (fun (lab, k1, t1, k2, t2) ->
            begin try moregen true type_pairs env t1 t2 with Unify trace ->
              raise (Failure [CM_Meth_type_mismatch
                                 (lab, env, expand_trace env trace)])
           end)
        pairs;
      Vars.iter
        (fun lab (mut, v, ty) ->
           let (mut', v', ty') = Vars.find lab sign1.csig_vars in
           try moregen true type_pairs env ty' ty with Unify trace ->
             raise (Failure [CM_Val_type_mismatch
                                (lab, env, expand_trace env trace)]))
        sign2.csig_vars
  | _ ->
      raise (Failure [])
  with
    Failure error when trace || error = [] ->
      raise (Failure (CM_Class_type_mismatch (env, cty1, cty2)::error))

let match_class_types ?(trace=true) env pat_sch subj_sch =
  let type_pairs = TypePairs.create 53 in
  let old_level = !current_level in
  current_level := generic_level - 1;
  (*
     Generic variables are first duplicated with [instance].  So,
     their levels are lowered to [generic_level - 1].  The subject is
     then copied with [duplicate_type].  That way, its levels won't be
     changed.
  *)
  let (_, subj_inst) = instance_class [] subj_sch in
  let subj = duplicate_class_type subj_inst in
  current_level := generic_level;
  (* Duplicate generic variables *)
  let (_, patt) = instance_class [] pat_sch in
  let res =
    let sign1 = signature_of_class_type patt in
    let sign2 = signature_of_class_type subj in
    let t1 = repr sign1.csig_self in
    let t2 = repr sign2.csig_self in
    TypePairs.add type_pairs (t1, t2) ();
    let (fields1, rest1) = flatten_fields (object_fields t1)
    and (fields2, rest2) = flatten_fields (object_fields t2) in
    let (pairs, miss1, miss2) = associate_fields fields1 fields2 in
    let error =
      List.fold_right
        (fun (lab, k, _) err ->
           let err =
             let k = field_kind_repr k in
             begin match k with
               Fvar r -> set_kind r Fabsent; err
             | _      -> CM_Hide_public lab::err
             end
           in
           if Concr.mem lab sign1.csig_concr then err
           else CM_Hide_virtual ("method", lab) :: err)
        miss1 []
    in
    let missing_method = List.map (fun (m, _, _) -> m) miss2 in
    let error =
      (List.map (fun m -> CM_Missing_method m) missing_method) @ error
    in
    (* Always succeeds *)
    moregen true type_pairs env rest1 rest2;
    let error =
      List.fold_right
        (fun (lab, k1, t1, k2, t2) err ->
           try moregen_kind k1 k2; err with
             Unify _ -> CM_Public_method lab::err)
        pairs error
    in
    let error =
      Vars.fold
        (fun lab (mut, vr, ty) err ->
          try
            let (mut', vr', ty') = Vars.find lab sign1.csig_vars in
            if mut = Mutable && mut' <> Mutable then
              CM_Non_mutable_value lab::err
            else if vr = Concrete && vr' <> Concrete then
              CM_Non_concrete_value lab::err
            else
              err
          with Not_found ->
            CM_Missing_value lab::err)
        sign2.csig_vars error
    in
    let error =
      Vars.fold
        (fun lab (_,vr,_) err ->
          if vr = Virtual && not (Vars.mem lab sign2.csig_vars) then
            CM_Hide_virtual ("instance variable", lab) :: err
          else err)
        sign1.csig_vars error
    in
    let error =
      List.fold_right
        (fun e l ->
           if List.mem e missing_method then l else CM_Virtual_method e::l)
        (Concr.elements (Concr.diff sign2.csig_concr sign1.csig_concr))
        error
    in
    match error with
      [] ->
        begin try
          moregen_clty trace type_pairs env patt subj;
          []
        with
          Failure r -> r
        end
    | error ->
        CM_Class_type_mismatch (env, patt, subj)::error
  in
  current_level := old_level;
  res

let rec equal_clty trace type_pairs subst env cty1 cty2 =
  try
    match cty1, cty2 with
      Cty_constr (_, _, cty1), Cty_constr (_, _, cty2) ->
        equal_clty true type_pairs subst env cty1 cty2
    | Cty_constr (_, _, cty1), _ ->
        equal_clty true type_pairs subst env cty1 cty2
    | _, Cty_constr (_, _, cty2) ->
        equal_clty true type_pairs subst env cty1 cty2
    | Cty_arrow (l1, ty1, cty1'), Cty_arrow (l2, ty2, cty2') when l1 = l2 ->
        begin try eqtype true type_pairs subst env ty1 ty2 with Unify trace ->
          raise (Failure [CM_Parameter_mismatch (env, expand_trace env trace)])
        end;
        equal_clty false type_pairs subst env cty1' cty2'
    | Cty_signature sign1, Cty_signature sign2 ->
        let ty1 = object_fields (repr sign1.csig_self) in
        let ty2 = object_fields (repr sign2.csig_self) in
        let (fields1, rest1) = flatten_fields ty1
        and (fields2, rest2) = flatten_fields ty2 in
        let (pairs, miss1, miss2) = associate_fields fields1 fields2 in
        List.iter
          (fun (lab, k1, t1, k2, t2) ->
             begin try eqtype true type_pairs subst env t1 t2 with
               Unify trace ->
                 raise (Failure [CM_Meth_type_mismatch
                                    (lab, env, expand_trace env trace)])
             end)
          pairs;
        Vars.iter
          (fun lab (_, _, ty) ->
             let (_, _, ty') = Vars.find lab sign1.csig_vars in
             try eqtype true type_pairs subst env ty' ty with Unify trace ->
               raise (Failure [CM_Val_type_mismatch
                                  (lab, env, expand_trace env trace)]))
          sign2.csig_vars
    | _ ->
        raise
          (Failure (if trace then []
                    else [CM_Class_type_mismatch (env, cty1, cty2)]))
  with
    Failure error when trace ->
      raise (Failure (CM_Class_type_mismatch (env, cty1, cty2)::error))

let match_class_declarations env patt_params patt_type subj_params subj_type =
  let type_pairs = TypePairs.create 53 in
  let subst = ref [] in
  let sign1 = signature_of_class_type patt_type in
  let sign2 = signature_of_class_type subj_type in
  let t1 = repr sign1.csig_self in
  let t2 = repr sign2.csig_self in
  TypePairs.add type_pairs (t1, t2) ();
  let (fields1, rest1) = flatten_fields (object_fields t1)
  and (fields2, rest2) = flatten_fields (object_fields t2) in
  let (pairs, miss1, miss2) = associate_fields fields1 fields2 in
  let error =
    List.fold_right
      (fun (lab, k, _) err ->
        let err =
          let k = field_kind_repr k in
          begin match k with
            Fvar r -> err
          | _      -> CM_Hide_public lab::err
          end
        in
        if Concr.mem lab sign1.csig_concr then err
        else CM_Hide_virtual ("method", lab) :: err)
      miss1 []
  in
  let missing_method = List.map (fun (m, _, _) -> m) miss2 in
  let error =
    (List.map (fun m -> CM_Missing_method m) missing_method) @ error
  in
  (* Always succeeds *)
  eqtype true type_pairs subst env rest1 rest2;
  let error =
    List.fold_right
      (fun (lab, k1, t1, k2, t2) err ->
        let k1 = field_kind_repr k1 in
        let k2 = field_kind_repr k2 in
        match k1, k2 with
          (Fvar _, Fvar _)
        | (Fpresent, Fpresent) -> err
        | (Fvar _, Fpresent)   -> CM_Private_method lab::err
        | (Fpresent, Fvar _)  -> CM_Public_method lab::err
        | _                    -> assert false)
      pairs error
  in
  let error =
    Vars.fold
      (fun lab (mut, vr, ty) err ->
         try
           let (mut', vr', ty') = Vars.find lab sign1.csig_vars in
           if mut = Mutable && mut' <> Mutable then
             CM_Non_mutable_value lab::err
           else if vr = Concrete && vr' <> Concrete then
             CM_Non_concrete_value lab::err
           else
             err
         with Not_found ->
           CM_Missing_value lab::err)
      sign2.csig_vars error
  in
  let error =
    Vars.fold
      (fun lab (_,vr,_) err ->
        if vr = Virtual && not (Vars.mem lab sign2.csig_vars) then
          CM_Hide_virtual ("instance variable", lab) :: err
        else err)
      sign1.csig_vars error
  in
  let error =
    List.fold_right
      (fun e l ->
        if List.mem e missing_method then l else CM_Virtual_method e::l)
      (Concr.elements (Concr.diff sign2.csig_concr sign1.csig_concr))
      error
  in
  match error with
    [] ->
      begin try
        let lp = List.length patt_params in
        let ls = List.length subj_params in
        if lp  <> ls then
          raise (Failure [CM_Parameter_arity_mismatch (lp, ls)]);
        List.iter2 (fun p s ->
          try eqtype true type_pairs subst env p s with Unify trace ->
            raise (Failure [CM_Type_parameter_mismatch
                               (env, expand_trace env trace)]))
          patt_params subj_params;
     (* old code: equal_clty false type_pairs subst env patt_type subj_type; *)
        equal_clty false type_pairs subst env
          (Cty_signature sign1) (Cty_signature sign2);
        (* Use moregeneral for class parameters, need to recheck everything to
           keeps relationships (PR#4824) *)
        let clty_params =
          List.fold_right (fun ty cty -> Cty_arrow ("*",ty,cty)) in
        match_class_types ~trace:false env
          (clty_params patt_params patt_type)
          (clty_params subj_params subj_type)
      with
        Failure r -> r
      end
  | error ->
      error


                              (***************)
                              (*  Subtyping  *)
                              (***************)


(**** Build a subtype of a given type. ****)

(* build_subtype:
   [visited] traces traversed object and variant types
   [loops] is a mapping from variables to variables, to reproduce
     positive loops in a class type
   [posi] true if the current variance is positive
   [level] number of expansions/enlargement allowed on this branch *)

let warn = ref false  (* whether double coercion might do better *)
let pred_expand n = if n mod 2 = 0 && n > 0 then pred n else n
let pred_enlarge n = if n mod 2 = 1 then pred n else n

type change = Unchanged | Equiv | Changed
let collect l = List.fold_left (fun c1 (_, c2) -> max c1 c2) Unchanged l

let rec filter_visited = function
    [] -> []
  | {desc=Tobject _|Tvariant _} :: _ as l -> l
  | _ :: l -> filter_visited l

let memq_warn t visited =
  if List.memq t visited then (warn := true; true) else false

let rec lid_of_path ?(sharp="") = function
    Path.Pident id ->
      Longident.Lident (sharp ^ Ident.name id)
  | Path.Pdot (p1, s, _) ->
      Longident.Ldot (lid_of_path p1, sharp ^ s)
  | Path.Papply (p1, p2) ->
      Longident.Lapply (lid_of_path ~sharp p1, lid_of_path p2)

let find_cltype_for_path env p =
  let path, cl_abbr = Env.lookup_type (lid_of_path ~sharp:"#" p) env in
  match cl_abbr.type_manifest with
    Some ty ->
      begin match (repr ty).desc with
        Tobject(_,{contents=Some(p',_)}) when Path.same p p' -> cl_abbr, ty
      | _ -> raise Not_found
      end
  | None -> assert false

let has_constr_row' env t =
  has_constr_row (expand_abbrev env t)

let rec build_subtype env visited loops posi level t =
  let t = repr t in
  match t.desc with
    Tvar _ ->
      if posi then
        try
          let t' = List.assq t loops in
          warn := true;
          (t', Equiv)
        with Not_found ->
          (t, Unchanged)
      else
        (t, Unchanged)
  | Tarrow(l, t1, t2, _) ->
      if memq_warn t visited then (t, Unchanged) else
      let visited = t :: visited in
      let (t1', c1) = build_subtype env visited loops (not posi) level t1 in
      let (t2', c2) = build_subtype env visited loops posi level t2 in
      let c = max c1 c2 in
      if c > Unchanged then (newty (Tarrow(l, t1', t2', Cok)), c)
      else (t, Unchanged)
  | Ttuple tlist ->
      if memq_warn t visited then (t, Unchanged) else
      let visited = t :: visited in
      let tlist' =
        List.map (build_subtype env visited loops posi level) tlist
      in
      let c = collect tlist' in
      if c > Unchanged then (newty (Ttuple (List.map fst tlist')), c)
      else (t, Unchanged)
  | Tconstr(p, tl, abbrev)
    when level > 0 && generic_abbrev env p && safe_abbrev env t
    && not (has_constr_row' env t) ->
      let t' = repr (expand_abbrev env t) in
      let level' = pred_expand level in
      begin try match t'.desc with
        Tobject _ when posi && not (opened_object t') ->
          let cl_abbr, body = find_cltype_for_path env p in
          let ty =
            subst env !current_level Public abbrev None
              cl_abbr.type_params tl body in
          let ty = repr ty in
          let ty1, tl1 =
            match ty.desc with
              Tobject(ty1,{contents=Some(p',tl1)}) when Path.same p p' ->
                ty1, tl1
            | _ -> raise Not_found
          in
          (* Fix PR4505: do not set ty to Tvar when it appears in tl1,
             as this occurence might break the occur check.
             XXX not clear whether this correct anyway... *)
          if List.exists (deep_occur ty) tl1 then raise Not_found;
          ty.desc <- Tvar None;
          let t'' = newvar () in
          let loops = (ty, t'') :: loops in
          (* May discard [visited] as level is going down *)
          let (ty1', c) =
            build_subtype env [t'] loops posi (pred_enlarge level') ty1 in
          assert (is_Tvar t'');
          let nm =
            if c > Equiv || deep_occur ty ty1' then None else Some(p,tl1) in
          t''.desc <- Tobject (ty1', ref nm);
          (try unify_var env ty t with Unify _ -> assert false);
          (t'', Changed)
      | _ -> raise Not_found
      with Not_found ->
        let (t'',c) = build_subtype env visited loops posi level' t' in
        if c > Unchanged then (t'',c)
        else (t, Unchanged)
      end
  | Tconstr(p, tl, abbrev) ->
      (* Must check recursion on constructors, since we do not always
         expand them *)
      if memq_warn t visited then (t, Unchanged) else
      let visited = t :: visited in
      begin try
        let decl = Env.find_type p env in
        if level = 0 && generic_abbrev env p && safe_abbrev env t
        && not (has_constr_row' env t)
        then warn := true;
        let tl' =
          List.map2
            (fun v t ->
              let (co,cn) = Variance.get_upper v in
              if cn then
                if co then (t, Unchanged)
                else build_subtype env visited loops (not posi) level t
              else
                if co then build_subtype env visited loops posi level t
                else (newvar(), Changed))
            decl.type_variance tl
        in
        let c = collect tl' in
        if c > Unchanged then (newconstr p (List.map fst tl'), c)
        else (t, Unchanged)
      with Not_found ->
        (t, Unchanged)
      end
  | Tvariant row ->
      let row = row_repr row in
      if memq_warn t visited || not (static_row row) then (t, Unchanged) else
      let level' = pred_enlarge level in
      let visited =
        t :: if level' < level then [] else filter_visited visited in
      let fields = filter_row_fields false row.row_fields in
      let fields =
        List.map
          (fun (l,f as orig) -> match row_field_repr f with
            Rpresent None ->
              if posi then
                (l, Reither(true, [], false, ref None)), Unchanged
              else
                orig, Unchanged
          | Rpresent(Some t) ->
              let (t', c) = build_subtype env visited loops posi level' t in
              let f =
                if posi && level > 0
                then Reither(false, [t'], false, ref None)
                else Rpresent(Some t')
              in (l, f), c
          | _ -> assert false)
          fields
      in
      let c = collect fields in
      let row =
        { row_fields = List.map fst fields; row_more = newvar();
          row_bound = (); row_closed = posi; row_fixed = false;
          row_name = if c > Unchanged then None else row.row_name }
      in
      (newty (Tvariant row), Changed)
  | Tobject (t1, _) ->
      if memq_warn t visited || opened_object t1 then (t, Unchanged) else
      let level' = pred_enlarge level in
      let visited =
        t :: if level' < level then [] else filter_visited visited in
      let (t1', c) = build_subtype env visited loops posi level' t1 in
      if c > Unchanged then (newty (Tobject (t1', ref None)), c)
      else (t, Unchanged)
  | Tfield(s, _, t1, t2) (* Always present *) ->
      let (t1', c1) = build_subtype env visited loops posi level t1 in
      let (t2', c2) = build_subtype env visited loops posi level t2 in
      let c = max c1 c2 in
      if c > Unchanged then (newty (Tfield(s, Fpresent, t1', t2')), c)
      else (t, Unchanged)
  | Tnil ->
      if posi then
        let v = newvar () in
        (v, Changed)
      else begin
        warn := true;
        (t, Unchanged)
      end
  | Tsubst _ | Tlink _ ->
      assert false
  | Tpoly(t1, tl) ->
      let (t1', c) = build_subtype env visited loops posi level t1 in
      if c > Unchanged then (newty (Tpoly(t1', tl)), c)
      else (t, Unchanged)
  | Tunivar _ | Tpackage _ ->
      (t, Unchanged)

let enlarge_type env ty =
  warn := false;
  (* [level = 4] allows 2 expansions involving objects/variants *)
  let (ty', _) = build_subtype env [] [] true 4 ty in
  (ty', !warn)

(**** Check whether a type is a subtype of another type. ****)

(*
    During the traversal, a trace of visited types is maintained. It
    is printed in case of error.
    Constraints (pairs of types that must be equals) are accumulated
    rather than being enforced straight. Indeed, the result would
    otherwise depend on the order in which these constraints are
    enforced.
    A function enforcing these constraints is returned. That way, type
    variables can be bound to their actual values before this function
    is called (see Typecore).
    Only well-defined abbreviations are expanded (hence the tests
    [generic_abbrev ...]).
*)

let subtypes = TypePairs.create 17

let subtype_error env trace =
  raise (Subtype (expand_trace env (List.rev trace), []))

(* check list inclusion, assuming lists are ordered *)
let rec included nl1 nl2 =
  match nl1, nl2 with
    (a::nl1', b::nl2') ->
      if a = b then included nl1' nl2' else
      a > b && included nl1 nl2'
  | ([], _) -> true
  | (_, []) -> false

let rec extract_assoc nl1 nl2 tl2 =
  match (nl1, nl2, tl2) with
    (a::nl1', b::nl2, t::tl2) ->
      if a = b then t :: extract_assoc nl1' nl2 tl2
      else extract_assoc nl1 nl2 tl2
  | ([], _, _) -> []
  | _ -> assert false

let rec subtype_rec env trace t1 t2 cstrs =
  let t1 = repr t1 in
  let t2 = repr t2 in
  if t1 == t2 then cstrs else

  begin try
    TypePairs.find subtypes (t1, t2);
    cstrs
  with Not_found ->
    TypePairs.add subtypes (t1, t2) ();
    match (t1.desc, t2.desc) with
      (Tvar _, _) | (_, Tvar _) ->
        (trace, t1, t2, !univar_pairs)::cstrs
    | (Tarrow(l1, t1, u1, _), Tarrow(l2, t2, u2, _)) when l1 = l2
      || !Clflags.classic && not (is_optional l1 || is_optional l2) ->
        let cstrs = subtype_rec env ((t2, t1)::trace) t2 t1 cstrs in
        subtype_rec env ((u1, u2)::trace) u1 u2 cstrs
    | (Ttuple tl1, Ttuple tl2) ->
        subtype_list env trace tl1 tl2 cstrs
    | (Tconstr(p1, [], _), Tconstr(p2, [], _)) when Path.same p1 p2 ->
        cstrs
    | (Tconstr(p1, tl1, abbrev1), _)
      when generic_abbrev env p1 && safe_abbrev env t1 ->
        subtype_rec env trace (expand_abbrev env t1) t2 cstrs
    | (_, Tconstr(p2, tl2, abbrev2))
      when generic_abbrev env p2 && safe_abbrev env t2 ->
        subtype_rec env trace t1 (expand_abbrev env t2) cstrs
    | (Tconstr(p1, tl1, _), Tconstr(p2, tl2, _)) when Path.same p1 p2 ->
        begin try
          let decl = Env.find_type p1 env in
          List.fold_left2
            (fun cstrs v (t1, t2) ->
              let (co, cn) = Variance.get_upper v in
              if co then
                if cn then
                  (trace, newty2 t1.level (Ttuple[t1]),
                   newty2 t2.level (Ttuple[t2]), !univar_pairs) :: cstrs
                else subtype_rec env ((t1, t2)::trace) t1 t2 cstrs
              else
                if cn then subtype_rec env ((t2, t1)::trace) t2 t1 cstrs
                else cstrs)
            cstrs decl.type_variance (List.combine tl1 tl2)
        with Not_found ->
          (trace, t1, t2, !univar_pairs)::cstrs
        end
    | (Tconstr(p1, _, _), _) when generic_private_abbrev env p1 ->
        subtype_rec env trace (expand_abbrev_opt env t1) t2 cstrs
(*  | (_, Tconstr(p2, _, _)) when generic_private_abbrev false env p2 ->
        subtype_rec env trace t1 (expand_abbrev_opt env t2) cstrs *)
    | (Tobject (f1, _), Tobject (f2, _))
      when is_Tvar (object_row f1) && is_Tvar (object_row f2) ->
        (* Same row variable implies same object. *)
        (trace, t1, t2, !univar_pairs)::cstrs
    | (Tobject (f1, _), Tobject (f2, _)) ->
        subtype_fields env trace f1 f2 cstrs
    | (Tvariant row1, Tvariant row2) ->
        begin try
          subtype_row env trace row1 row2 cstrs
        with Exit ->
          (trace, t1, t2, !univar_pairs)::cstrs
        end
    | (Tpoly (u1, []), Tpoly (u2, [])) ->
        subtype_rec env trace u1 u2 cstrs
    | (Tpoly (u1, tl1), Tpoly (u2, [])) ->
        let _, u1' = instance_poly false tl1 u1 in
        subtype_rec env trace u1' u2 cstrs
    | (Tpoly (u1, tl1), Tpoly (u2,tl2)) ->
        begin try
          enter_poly env univar_pairs u1 tl1 u2 tl2
            (fun t1 t2 -> subtype_rec env trace t1 t2 cstrs)
        with Unify _ ->
          (trace, t1, t2, !univar_pairs)::cstrs
        end
(*    | (Tpackage (p1, nl1, tl1), Tpackage (p2, nl2, tl2))
      when eq_package_path env p1 p2 && included nl2 nl1 ->
        List.map2 (fun t1 t2 -> (trace, t1, t2, !univar_pairs))
          (extract_assoc nl2 nl1 tl1) tl2
        @ cstrs *)
    | (Tpackage (p1, nl1, tl1), Tpackage (p2, nl2, tl2)) ->
        begin try
          let ntl1 = complete_type_list env nl2 t1.level (Mty_ident p1) nl1 tl1
          and ntl2 = complete_type_list env nl1 t2.level (Mty_ident p2) nl2 tl2
              ~allow_absent:true in
          let cstrs' =
            List.map
              (fun (n2,t2) -> (trace, List.assoc n2 ntl1, t2, !univar_pairs))
              ntl2
          in
          if eq_package_path env p1 p2 then cstrs' @ cstrs
          else begin
            (* need to check module subtyping *)
            let snap = Btype.snapshot () in
            try
              List.iter (fun (_, t1, t2, _) -> unify env t1 t2) cstrs';
              if !package_subtype env p1 nl1 tl1 p2 nl2 tl2
              then (Btype.backtrack snap; cstrs' @ cstrs)
              else raise (Unify [])
            with Unify _ ->
              Btype.backtrack snap; raise Not_found
          end
        with Not_found ->
          (trace, t1, t2, !univar_pairs)::cstrs
        end
    | (_, _) ->
        (trace, t1, t2, !univar_pairs)::cstrs
  end

and subtype_list env trace tl1 tl2 cstrs =
  if List.length tl1 <> List.length tl2 then
    subtype_error env trace;
  List.fold_left2
    (fun cstrs t1 t2 -> subtype_rec env ((t1, t2)::trace) t1 t2 cstrs)
    cstrs tl1 tl2

and subtype_fields env trace ty1 ty2 cstrs =
  (* Assume that either rest1 or rest2 is not Tvar *)
  let (fields1, rest1) = flatten_fields ty1 in
  let (fields2, rest2) = flatten_fields ty2 in
  let (pairs, miss1, miss2) = associate_fields fields1 fields2 in
  let cstrs =
    if rest2.desc = Tnil then cstrs else
    if miss1 = [] then
      subtype_rec env ((rest1, rest2)::trace) rest1 rest2 cstrs
    else
      (trace, build_fields (repr ty1).level miss1 rest1, rest2,
       !univar_pairs) :: cstrs
  in
  let cstrs =
    if miss2 = [] then cstrs else
    (trace, rest1, build_fields (repr ty2).level miss2 (newvar ()),
     !univar_pairs) :: cstrs
  in
  List.fold_left
    (fun cstrs (_, k1, t1, k2, t2) ->
      (* Theses fields are always present *)
      subtype_rec env ((t1, t2)::trace) t1 t2 cstrs)
    cstrs pairs

and subtype_row env trace row1 row2 cstrs =
  let row1 = row_repr row1 and row2 = row_repr row2 in
  let r1, r2, pairs =
    merge_row_fields row1.row_fields row2.row_fields in
  let more1 = repr row1.row_more
  and more2 = repr row2.row_more in
  match more1.desc, more2.desc with
    Tconstr(p1,_,_), Tconstr(p2,_,_) when Path.same p1 p2 ->
      subtype_rec env ((more1,more2)::trace) more1 more2 cstrs
  | (Tvar _|Tconstr _|Tnil), (Tvar _|Tconstr _|Tnil)
    when row1.row_closed && r1 = [] ->
      List.fold_left
        (fun cstrs (_,f1,f2) ->
          match row_field_repr f1, row_field_repr f2 with
            (Rpresent None|Reither(true,_,_,_)), Rpresent None ->
              cstrs
          | Rpresent(Some t1), Rpresent(Some t2) ->
              subtype_rec env ((t1, t2)::trace) t1 t2 cstrs
          | Reither(false, t1::_, _, _), Rpresent(Some t2) ->
              subtype_rec env ((t1, t2)::trace) t1 t2 cstrs
          | Rabsent, _ -> cstrs
          | _ -> raise Exit)
        cstrs pairs
  | Tunivar _, Tunivar _
    when row1.row_closed = row2.row_closed && r1 = [] && r2 = [] ->
      let cstrs =
        subtype_rec env ((more1,more2)::trace) more1 more2 cstrs in
      List.fold_left
        (fun cstrs (_,f1,f2) ->
          match row_field_repr f1, row_field_repr f2 with
            Rpresent None, Rpresent None
          | Reither(true,[],_,_), Reither(true,[],_,_)
          | Rabsent, Rabsent ->
              cstrs
          | Rpresent(Some t1), Rpresent(Some t2)
          | Reither(false,[t1],_,_), Reither(false,[t2],_,_) ->
              subtype_rec env ((t1, t2)::trace) t1 t2 cstrs
          | _ -> raise Exit)
        cstrs pairs
  | _ ->
      raise Exit

let subtype env ty1 ty2 =
  TypePairs.clear subtypes;
  univar_pairs := [];
  (* Build constraint set. *)
  let cstrs = subtype_rec env [(ty1, ty2)] ty1 ty2 [] in
  TypePairs.clear subtypes;
  (* Enforce constraints. *)
  function () ->
    List.iter
      (function (trace0, t1, t2, pairs) ->
         try unify_pairs (ref env) t1 t2 pairs with Unify trace ->
           raise (Subtype (expand_trace env (List.rev trace0),
                           List.tl (List.tl trace))))
      (List.rev cstrs)

                              (*******************)
                              (*  Miscellaneous  *)
                              (*******************)

(* Utility for printing. The resulting type is not used in computation. *)
let rec unalias_object ty =
  let ty = repr ty in
  match ty.desc with
    Tfield (s, k, t1, t2) ->
      newty2 ty.level (Tfield (s, k, t1, unalias_object t2))
  | Tvar _ | Tnil ->
      newty2 ty.level ty.desc
  | Tunivar _ ->
      ty
  | Tconstr _ ->
      newvar2 ty.level
  | _ ->
      assert false

let unalias ty =
  let ty = repr ty in
  match ty.desc with
    Tvar _ | Tunivar _ ->
      ty
  | Tvariant row ->
      let row = row_repr row in
      let more = row.row_more in
      newty2 ty.level
        (Tvariant {row with row_more = newty2 more.level more.desc})
  | Tobject (ty, nm) ->
      newty2 ty.level (Tobject (unalias_object ty, nm))
  | _ ->
      newty2 ty.level ty.desc

(* Return the arity (as for curried functions) of the given type. *)
let rec arity ty =
  match (repr ty).desc with
    Tarrow(_, t1, t2, _) -> 1 + arity t2
  | _ -> 0

(* Check whether an abbreviation expands to itself. *)
let cyclic_abbrev env id ty =
  let rec check_cycle seen ty =
    let ty = repr ty in
    match ty.desc with
      Tconstr (p, tl, abbrev) ->
        p = Path.Pident id || List.memq ty seen ||
        begin try
          check_cycle (ty :: seen) (expand_abbrev_opt env ty)
        with
          Cannot_expand -> false
        | Unify _ -> true
        end
    | _ ->
        false
  in check_cycle [] ty

(* Normalize a type before printing, saving... *)
(* Cannot use mark_type because deep_occur uses it too *)
let rec normalize_type_rec env visited ty =
  let ty = repr ty in
  if not (TypeSet.mem ty !visited) then begin
    visited := TypeSet.add ty !visited;
    begin match ty.desc with
    | Tvariant row ->
      let row = row_repr row in
      let fields = List.map
          (fun (l,f0) ->
            let f = row_field_repr f0 in l,
            match f with Reither(b, ty::(_::_ as tyl), m, e) ->
              let tyl' =
                List.fold_left
                  (fun tyl ty ->
                    if List.exists (fun ty' -> equal env false [ty] [ty']) tyl
                    then tyl else ty::tyl)
                  [ty] tyl
              in
              if f != f0 || List.length tyl' < List.length tyl then
                Reither(b, List.rev tyl', m, e)
              else f
            | _ -> f)
          row.row_fields in
      let fields =
        List.sort (fun (p,_) (q,_) -> compare p q)
          (List.filter (fun (_,fi) -> fi <> Rabsent) fields) in
      log_type ty;
      ty.desc <- Tvariant {row with row_fields = fields}
    | Tobject (fi, nm) ->
        begin match !nm with
        | None -> ()
        | Some (n, v :: l) ->
            if deep_occur ty (newgenty (Ttuple l)) then
              (* The abbreviation may be hiding something, so remove it *)
              set_name nm None
            else let v' = repr v in
            begin match v'.desc with
            | Tvar _ | Tunivar _ ->
                if v' != v then set_name nm (Some (n, v' :: l))
            | Tnil ->
                log_type ty; ty.desc <- Tconstr (n, l, ref Mnil)
            | _ -> set_name nm None
            end
        | _ ->
            fatal_error "Ctype.normalize_type_rec"
        end;
        let fi = repr fi in
        if fi.level < lowest_level then () else
        let fields, row = flatten_fields fi in
        let fi' = build_fields fi.level fields row in
        log_type ty; fi.desc <- fi'.desc
    | _ -> ()
    end;
    iter_type_expr (normalize_type_rec env visited) ty
  end

let normalize_type env ty =
  normalize_type_rec env (ref TypeSet.empty) ty


                              (*************************)
                              (*  Remove dependencies  *)
                              (*************************)


(*
   Variables are left unchanged. Other type nodes are duplicated, with
   levels set to generic level.
   We cannot use Tsubst here, because unification may be called by
   expand_abbrev.
*)

let nondep_hash     = TypeHash.create 47
let nondep_variants = TypeHash.create 17
let clear_hash ()   =
  TypeHash.clear nondep_hash; TypeHash.clear nondep_variants

let rec nondep_type_rec env id ty =
  match ty.desc with
    Tvar _ | Tunivar _ -> ty
  | Tlink ty -> nondep_type_rec env id ty
  | _ -> try TypeHash.find nondep_hash ty
  with Not_found ->
    let ty' = newgenvar () in        (* Stub *)
    TypeHash.add nondep_hash ty ty';
    ty'.desc <-
      begin match ty.desc with
      | Tconstr(p, tl, abbrev) ->
          if Path.isfree id p then
            begin try
              Tlink (nondep_type_rec env id
                       (expand_abbrev env (newty2 ty.level ty.desc)))
              (*
                 The [Tlink] is important. The expanded type may be a
                 variable, or may not be completely copied yet
                 (recursive type), so one cannot just take its
                 description.
               *)
            with Cannot_expand | Unify _ ->
              raise Not_found
            end
          else
            Tconstr(p, List.map (nondep_type_rec env id) tl, ref Mnil)
      | Tpackage(p, nl, tl) when Path.isfree id p ->
          let p' = normalize_package_path env p in
          if Path.isfree id p' then raise Not_found;
          Tpackage (p', nl, List.map (nondep_type_rec env id) tl)
      | Tobject (t1, name) ->
          Tobject (nondep_type_rec env id t1,
                 ref (match !name with
                        None -> None
                      | Some (p, tl) ->
                          if Path.isfree id p then None
                          else Some (p, List.map (nondep_type_rec env id) tl)))
      | Tvariant row ->
          let row = row_repr row in
          let more = repr row.row_more in
          (* We must keep sharing according to the row variable *)
          begin try
            let ty2 = TypeHash.find nondep_variants more in
            (* This variant type has been already copied *)
            TypeHash.add nondep_hash ty ty2;
            Tlink ty2
          with Not_found ->
            (* Register new type first for recursion *)
            TypeHash.add nondep_variants more ty';
            let static = static_row row in
            let more' = if static then newgenty Tnil else more in
            (* Return a new copy *)
            let row =
              copy_row (nondep_type_rec env id) true row true more' in
            match row.row_name with
              Some (p, tl) when Path.isfree id p ->
                Tvariant {row with row_name = None}
            | _ -> Tvariant row
          end
      | _ -> copy_type_desc (nondep_type_rec env id) ty.desc
      end;
    ty'

let nondep_type env id ty =
  try
    let ty' = nondep_type_rec env id ty in
    clear_hash ();
    ty'
  with Not_found ->
    clear_hash ();
    raise Not_found

let () = nondep_type' := nondep_type

let unroll_abbrev id tl ty =
  let ty = repr ty and path = Path.Pident id in
  if is_Tvar ty || (List.exists (deep_occur ty) tl)
  || is_object_type path then
    ty
  else
    let ty' = newty2 ty.level ty.desc in
    link_type ty (newty2 ty.level (Tconstr (path, tl, ref Mnil)));
    ty'

(* Preserve sharing inside type declarations. *)
let nondep_type_decl env mid id is_covariant decl =
  try
    let params = List.map (nondep_type_rec env mid) decl.type_params in
    let tk =
      try match decl.type_kind with
        Type_abstract ->
          Type_abstract
      | Type_variant cstrs ->
          Type_variant
            (List.map
               (fun c ->
                 {c with
                  cd_args = List.map (nondep_type_rec env mid) c.cd_args;
                  cd_res = may_map (nondep_type_rec env mid) c.cd_res;
                 }
               )
               cstrs)
      | Type_record(lbls, rep) ->
          Type_record
            (List.map
               (fun l ->
                  {l with ld_type = nondep_type_rec env mid l.ld_type}
               )
               lbls,
             rep)
      | Type_open ->
          Type_open
      with Not_found when is_covariant -> Type_abstract
    and tm =
      try match decl.type_manifest with
        None -> None
      | Some ty ->
          Some (unroll_abbrev id params (nondep_type_rec env mid ty))
      with Not_found when is_covariant ->
        None
    in
    clear_hash ();
    let priv =
      match tm with
      | Some ty when Btype.has_constr_row ty -> Private
      | _ -> decl.type_private
    in
    { type_params = params;
      type_arity = decl.type_arity;
      type_kind = tk;
      type_manifest = tm;
      type_private = priv;
      type_variance = decl.type_variance;
      type_newtype_level = None;
      type_loc = decl.type_loc;
      type_attributes = decl.type_attributes;
    }
  with Not_found ->
    clear_hash ();
    raise Not_found

(* Preserve sharing inside extension constructors. *)
let nondep_extension_constructor env mid ext =
  try
    let type_path, type_params =
      if Path.isfree mid ext.ext_type_path then
        begin
          let ty =
            newgenty (Tconstr(ext.ext_type_path, ext.ext_type_params, ref Mnil))
          in
          let ty' = nondep_type_rec env mid ty in
            match (repr ty').desc with
                Tconstr(p, tl, _) -> p, tl
              | _ -> raise Not_found
        end
      else
        let type_params =
          List.map (nondep_type_rec env mid) ext.ext_type_params
        in
          ext.ext_type_path, type_params
    in
    let args = List.map (nondep_type_rec env mid) ext.ext_args in
    let ret_type = may_map (nondep_type_rec env mid) ext.ext_ret_type in
      clear_hash ();
      { ext_type_path = type_path;
        ext_type_params = type_params;
        ext_args = args;
        ext_ret_type = ret_type;
        ext_private = ext.ext_private;
        ext_attributes = ext.ext_attributes;
        ext_loc = ext.ext_loc;
      }
  with Not_found ->
    clear_hash ();
    raise Not_found


(* Preserve sharing inside class types. *)
let nondep_class_signature env id sign =
  { csig_self = nondep_type_rec env id sign.csig_self;
    csig_vars =
      Vars.map (function (m, v, t) -> (m, v, nondep_type_rec env id t))
        sign.csig_vars;
    csig_concr = sign.csig_concr;
    csig_inher =
      List.map (fun (p,tl) -> (p, List.map (nondep_type_rec env id) tl))
        sign.csig_inher }

let rec nondep_class_type env id =
  function
    Cty_constr (p, _, cty) when Path.isfree id p ->
      nondep_class_type env id cty
  | Cty_constr (p, tyl, cty) ->
      Cty_constr (p, List.map (nondep_type_rec env id) tyl,
                   nondep_class_type env id cty)
  | Cty_signature sign ->
      Cty_signature (nondep_class_signature env id sign)
  | Cty_arrow (l, ty, cty) ->
      Cty_arrow (l, nondep_type_rec env id ty, nondep_class_type env id cty)

let nondep_class_declaration env id decl =
  assert (not (Path.isfree id decl.cty_path));
  let decl =
    { cty_params = List.map (nondep_type_rec env id) decl.cty_params;
      cty_variance = decl.cty_variance;
      cty_type = nondep_class_type env id decl.cty_type;
      cty_path = decl.cty_path;
      cty_new =
        begin match decl.cty_new with
          None    -> None
        | Some ty -> Some (nondep_type_rec env id ty)
        end;
      cty_loc = decl.cty_loc;
      cty_attributes = decl.cty_attributes;
    }
  in
  clear_hash ();
  decl

let nondep_cltype_declaration env id decl =
  assert (not (Path.isfree id decl.clty_path));
  let decl =
    { clty_params = List.map (nondep_type_rec env id) decl.clty_params;
      clty_variance = decl.clty_variance;
      clty_type = nondep_class_type env id decl.clty_type;
      clty_path = decl.clty_path;
      clty_loc = decl.clty_loc;
      clty_attributes = decl.clty_attributes;
    }
  in
  clear_hash ();
  decl

(* collapse conjonctive types in class parameters *)
let rec collapse_conj env visited ty =
  let ty = repr ty in
  if List.memq ty visited then () else
  let visited = ty :: visited in
  match ty.desc with
    Tvariant row ->
      let row = row_repr row in
      List.iter
        (fun (l,fi) ->
          match row_field_repr fi with
            Reither (c, t1::(_::_ as tl), m, e) ->
              List.iter (unify env t1) tl;
              set_row_field e (Reither (c, [t1], m, ref None))
          | _ ->
              ())
        row.row_fields;
      iter_row (collapse_conj env visited) row
  | _ ->
      iter_type_expr (collapse_conj env visited) ty

let collapse_conj_params env params =
  List.iter (collapse_conj env []) params

end
(** Interface as module  *)
module Outcometree
= struct
(*#1 "outcometree.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*     Daniel de Rauglaudre, projet Cristal, INRIA Rocquencourt        *)
(*                                                                     *)
(*  Copyright 2001 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Module [Outcometree]: results displayed by the toplevel *)

(* These types represent messages that the toplevel displays as normal
   results or errors. The real displaying is customisable using the hooks:
      [Toploop.print_out_value]
      [Toploop.print_out_type]
      [Toploop.print_out_sig_item]
      [Toploop.print_out_phrase] *)

type out_ident =
  | Oide_apply of out_ident * out_ident
  | Oide_dot of out_ident * string
  | Oide_ident of string

type out_value =
  | Oval_array of out_value list
  | Oval_char of char
  | Oval_constr of out_ident * out_value list
  | Oval_ellipsis
  | Oval_float of float
  | Oval_int of int
  | Oval_int32 of int32
  | Oval_int64 of int64
  | Oval_nativeint of nativeint
  | Oval_list of out_value list
  | Oval_printer of (Format.formatter -> unit)
  | Oval_record of (out_ident * out_value) list
  | Oval_string of string
  | Oval_stuff of string
  | Oval_tuple of out_value list
  | Oval_variant of string * out_value option

type out_type =
  | Otyp_abstract
  | Otyp_open
  | Otyp_alias of out_type * string
  | Otyp_arrow of string * out_type * out_type
  | Otyp_class of bool * out_ident * out_type list
  | Otyp_constr of out_ident * out_type list
  | Otyp_manifest of out_type * out_type
  | Otyp_object of (string * out_type) list * bool option
  | Otyp_record of (string * bool * out_type) list
  | Otyp_stuff of string
  | Otyp_sum of (string * out_type list * out_type option) list
  | Otyp_tuple of out_type list
  | Otyp_var of bool * string
  | Otyp_variant of
      bool * out_variant * bool * (string list) option
  | Otyp_poly of string list * out_type
  | Otyp_module of string * string list * out_type list

and out_variant =
  | Ovar_fields of (string * bool * out_type list) list
  | Ovar_name of out_ident * out_type list

type out_class_type =
  | Octy_constr of out_ident * out_type list
  | Octy_arrow of string * out_type * out_class_type
  | Octy_signature of out_type option * out_class_sig_item list
and out_class_sig_item =
  | Ocsg_constraint of out_type * out_type
  | Ocsg_method of string * bool * bool * out_type
  | Ocsg_value of string * bool * bool * out_type

type out_module_type =
  | Omty_abstract
  | Omty_functor of string * out_module_type option * out_module_type
  | Omty_ident of out_ident
  | Omty_signature of out_sig_item list
  | Omty_alias of out_ident
and out_sig_item =
  | Osig_class of
      bool * string * (string * (bool * bool)) list * out_class_type *
        out_rec_status
  | Osig_class_type of
      bool * string * (string * (bool * bool)) list * out_class_type *
        out_rec_status
  | Osig_typext of out_extension_constructor * out_ext_status
  | Osig_modtype of string * out_module_type
  | Osig_module of string * out_module_type * out_rec_status
  | Osig_type of out_type_decl * out_rec_status
  | Osig_value of string * out_type * string list
and out_type_decl =
  { otype_name: string;
    otype_params: (string * (bool * bool)) list;
    otype_type: out_type;
    otype_private: Asttypes.private_flag;
    otype_cstrs: (out_type * out_type) list }
and out_extension_constructor =
  { oext_name: string;
    oext_type_name: string;
    oext_type_params: string list;
    oext_args: out_type list;
    oext_ret_type: out_type option;
    oext_private: Asttypes.private_flag }
and out_type_extension =
  { otyext_name: string;
    otyext_params: string list;
    otyext_constructors: (string * out_type list * out_type option) list;
    otyext_private: Asttypes.private_flag }
and out_rec_status =
  | Orec_not
  | Orec_first
  | Orec_next
and out_ext_status =
  | Oext_first
  | Oext_next
  | Oext_exception

type out_phrase =
  | Ophr_eval of out_value * out_type
  | Ophr_signature of (out_sig_item * out_value option) list
  | Ophr_exception of (exn * out_value)

end
module Oprint : sig
(*#1 "oprint.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*                  Projet Cristal, INRIA Rocquencourt                 *)
(*                                                                     *)
(*  Copyright 2002 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Format
open Outcometree


val out_ident : (formatter -> string -> unit) ref

val out_value : (formatter -> out_value -> unit) ref
val out_type : (formatter -> out_type -> unit) ref
val out_class_type : (formatter -> out_class_type -> unit) ref
val out_module_type : (formatter -> out_module_type -> unit) ref
val out_sig_item : (formatter -> out_sig_item -> unit) ref
val out_signature : (formatter -> out_sig_item list -> unit) ref
val out_type_extension : (formatter -> out_type_extension -> unit) ref
val out_phrase : (formatter -> out_phrase -> unit) ref

val parenthesized_ident : string -> bool

end = struct
(*#1 "oprint.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*                  Projet Cristal, INRIA Rocquencourt                 *)
(*                                                                     *)
(*  Copyright 2002 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Format
open Outcometree

exception Ellipsis

let cautious f ppf arg =
  try f ppf arg with
    Ellipsis -> fprintf ppf "..."

let out_ident = ref pp_print_string

let rec print_ident ppf =
  function
    Oide_ident s -> !out_ident ppf s
  | Oide_dot (id, s) ->
      print_ident ppf id; pp_print_char ppf '.'; !out_ident ppf s
  | Oide_apply (id1, id2) ->
      fprintf ppf "%a(%a)" print_ident id1 print_ident id2

let parenthesized_ident name =
  (List.mem name ["or"; "mod"; "land"; "lor"; "lxor"; "lsl"; "lsr"; "asr"])
  ||
  (match name.[0] with
      'a'..'z' | 'A'..'Z' | '\223'..'\246' | '\248'..'\255' | '_' ->
        false
    | _ -> true)

let value_ident ppf name =
  if parenthesized_ident name then
    fprintf ppf "( %s )" name
  else
    pp_print_string ppf name

(* Values *)

let valid_float_lexeme s =
  let l = String.length s in
  let rec loop i =
    if i >= l then s ^ "." else
    match s.[i] with
    | '0' .. '9' | '-' -> loop (i+1)
    | _ -> s
  in loop 0

let float_repres f =
  match classify_float f with
    FP_nan -> "nan"
  | FP_infinite ->
      if f < 0.0 then "neg_infinity" else "infinity"
  | _ ->
      let float_val =
        let s1 = Printf.sprintf "%.12g" f in
        if f = float_of_string s1 then s1 else
        let s2 = Printf.sprintf "%.15g" f in
        if f = float_of_string s2 then s2 else
        Printf.sprintf "%.18g" f
      in valid_float_lexeme float_val

let parenthesize_if_neg ppf fmt v isneg =
  if isneg then pp_print_char ppf '(';
  fprintf ppf fmt v;
  if isneg then pp_print_char ppf ')'

let print_out_value ppf tree =
  let rec print_tree_1 ppf =
    function
    | Oval_constr (name, [param]) ->
        fprintf ppf "@[<1>%a@ %a@]" print_ident name print_constr_param param
    | Oval_constr (name, (_ :: _ as params)) ->
        fprintf ppf "@[<1>%a@ (%a)@]" print_ident name
          (print_tree_list print_tree_1 ",") params
    | Oval_variant (name, Some param) ->
        fprintf ppf "@[<2>`%s@ %a@]" name print_constr_param param
    | tree -> print_simple_tree ppf tree
  and print_constr_param ppf = function
    | Oval_int i -> parenthesize_if_neg ppf "%i" i (i < 0)
    | Oval_int32 i -> parenthesize_if_neg ppf "%lil" i (i < 0l)
    | Oval_int64 i -> parenthesize_if_neg ppf "%LiL" i (i < 0L)
    | Oval_nativeint i -> assert false (* parenthesize_if_neg ppf "%nin" i (i < 0n)*)
    | Oval_float f -> parenthesize_if_neg ppf "%s" (float_repres f) (f < 0.0)
    | tree -> print_simple_tree ppf tree
  and print_simple_tree ppf =
    function
      Oval_int i -> fprintf ppf "%i" i
    | Oval_int32 i -> fprintf ppf "%lil" i
    | Oval_int64 i -> fprintf ppf "%LiL" i
    | Oval_nativeint i -> fprintf ppf "%nin" i
    | Oval_float f -> pp_print_string ppf (float_repres f)
    | Oval_char c -> fprintf ppf "%C" c
    | Oval_string s ->
        begin try fprintf ppf "%S" s with
          Invalid_argument "String.create" -> fprintf ppf "<huge string>"
        end
    | Oval_list tl ->
        fprintf ppf "@[<1>[%a]@]" (print_tree_list print_tree_1 ";") tl
    | Oval_array tl ->
        fprintf ppf "@[<2>[|%a|]@]" (print_tree_list print_tree_1 ";") tl
    | Oval_constr (name, []) -> print_ident ppf name
    | Oval_variant (name, None) -> fprintf ppf "`%s" name
    | Oval_stuff s -> pp_print_string ppf s
    | Oval_record fel ->
        fprintf ppf "@[<1>{%a}@]" (cautious (print_fields true)) fel
    | Oval_ellipsis -> raise Ellipsis
    | Oval_printer f -> f ppf
    | Oval_tuple tree_list ->
        fprintf ppf "@[<1>(%a)@]" (print_tree_list print_tree_1 ",") tree_list
    | tree -> fprintf ppf "@[<1>(%a)@]" (cautious print_tree_1) tree
  and print_fields first ppf =
    function
      [] -> ()
    | (name, tree) :: fields ->
        if not first then fprintf ppf ";@ ";
        fprintf ppf "@[<1>%a@ =@ %a@]" print_ident name (cautious print_tree_1)
          tree;
        print_fields false ppf fields
  and print_tree_list print_item sep ppf tree_list =
    let rec print_list first ppf =
      function
        [] -> ()
      | tree :: tree_list ->
          if not first then fprintf ppf "%s@ " sep;
          print_item ppf tree;
          print_list false ppf tree_list
    in
    cautious (print_list true) ppf tree_list
  in
  cautious print_tree_1 ppf tree

let out_value = ref print_out_value

(* Types *)

let rec print_list_init pr sep ppf =
  function
    [] -> ()
  | a :: l -> sep ppf; pr ppf a; print_list_init pr sep ppf l

let rec print_list pr sep ppf =
  function
    [] -> ()
  | [a] -> pr ppf a
  | a :: l -> pr ppf a; sep ppf; print_list pr sep ppf l

let pr_present =
  print_list (fun ppf s -> fprintf ppf "`%s" s) (fun ppf -> fprintf ppf "@ ")

let pr_vars =
  print_list (fun ppf s -> fprintf ppf "'%s" s) (fun ppf -> fprintf ppf "@ ")

let rec print_out_type ppf =
  function
  | Otyp_alias (ty, s) ->
      fprintf ppf "@[%a@ as '%s@]" print_out_type ty s
  | Otyp_poly (sl, ty) ->
      fprintf ppf "@[<hov 2>%a.@ %a@]"
        pr_vars sl
        print_out_type ty
  | ty ->
      print_out_type_1 ppf ty

and print_out_type_1 ppf =
  function
    Otyp_arrow (lab, ty1, ty2) ->
      pp_open_box ppf 0;
      if lab <> "" then (pp_print_string ppf lab; pp_print_char ppf ':');
      print_out_type_2 ppf ty1;
      pp_print_string ppf " ->";
      pp_print_space ppf ();
      print_out_type_1 ppf ty2;
      pp_close_box ppf ()
  | ty -> print_out_type_2 ppf ty
and print_out_type_2 ppf =
  function
    Otyp_tuple tyl ->
      fprintf ppf "@[<0>%a@]" (print_typlist print_simple_out_type " *") tyl
  | ty -> print_simple_out_type ppf ty
and print_simple_out_type ppf =
  function
    Otyp_class (ng, id, tyl) ->
      fprintf ppf "@[%a%s#%a@]" print_typargs tyl (if ng then "_" else "")
        print_ident id

  | Otyp_constr ( (Oide_dot (((Oide_dot (Oide_ident "Js", "Internal"))| (Oide_ident "Js_internal")),
                             ("fn" | "meth" as name )) as id) ,
                 ([Otyp_variant(_,Ovar_fields [ variant, _, tys], _,_); result] as tyl))
    ->
      (* Otyp_arrow*)
      let make tys result =
        if tys = [] then
          Otyp_arrow ("", Otyp_constr (Oide_ident "unit", []),result)
        else
            match tys with
          | [ Otyp_tuple tys as single] ->
              if variant = "Arity_1" then
                Otyp_arrow ("", single, result)
              else
                List.fold_right (fun x acc  -> Otyp_arrow("",x,acc) ) tys result
          | [single] ->
              Otyp_arrow ("", single, result)
          | _ ->
              raise_notrace Not_found
      in
      begin match (make tys result) with
      | exception _ ->
          begin
            pp_open_box ppf 0;
            print_typargs ppf tyl;
            print_ident ppf id;
            pp_close_box ppf ()
          end
      | res ->
          begin match name  with
          | "fn" ->
              fprintf ppf "@[<0>(%a@ [@u])@]" print_out_type_1 res
          | "meth" ->
              fprintf ppf "@[<0>(%a@ [@mel.meth])@]" print_out_type_1 res
          | _ -> assert false
          end
      end
  | Otyp_constr ((Oide_dot ((Oide_dot (Oide_ident "Js", "Internal") | (Oide_ident "Js_internal")), "meth_callback" ) as id) ,
                 ([Otyp_variant(_,Ovar_fields [ variant, _, tys], _,_); result] as tyl))
    ->
      let make tys result =
          match tys with
          | [ Otyp_tuple tys as single ] ->
              if variant = "Arity_1" then Otyp_arrow ("", single, result)
              else
                List.fold_right (fun x acc  -> Otyp_arrow("",x,acc) ) tys result
          | [single] ->
              Otyp_arrow ("", single, result)
          | _ ->
              raise_notrace Not_found
      in
      begin match (make tys result) with
      | exception _ ->
          begin
            pp_open_box ppf 0;
            print_typargs ppf tyl;
            print_ident ppf id;
            pp_close_box ppf ()
          end
      | res ->
          fprintf ppf "@[<0>(%a@ [@mel.this])@]" print_out_type_1 res

      end

  | Otyp_constr (id, tyl) ->
      pp_open_box ppf 0;
      print_typargs ppf tyl;
      print_ident ppf id;
      pp_close_box ppf ()
  | Otyp_object (fields, rest) ->
      fprintf ppf "@[<2>< %a >@]" (print_fields rest) fields
  | Otyp_stuff s -> pp_print_string ppf s
  | Otyp_var (ng, s) -> fprintf ppf "'%s%s" (if ng then "_" else "") s
  | Otyp_variant (non_gen, row_fields, closed, tags) ->
      let print_present ppf =
        function
          None | Some [] -> ()
        | Some l -> fprintf ppf "@;<1 -2>> @[<hov>%a@]" pr_present l
      in
      let print_fields ppf =
        function
          Ovar_fields fields ->
            print_list print_row_field (fun ppf -> fprintf ppf "@;<1 -2>| ")
              ppf fields
        | Ovar_name (id, tyl) ->
            fprintf ppf "@[%a%a@]" print_typargs tyl print_ident id
      in
      fprintf ppf "%s[%s@[<hv>@[<hv>%a@]%a ]@]" (if non_gen then "_" else "")
        (if closed then if tags = None then " " else "< "
         else if tags = None then "> " else "? ")
        print_fields row_fields
        print_present tags
  | Otyp_alias _ | Otyp_poly _ | Otyp_arrow _ | Otyp_tuple _ as ty ->
      pp_open_box ppf 1;
      pp_print_char ppf '(';
      print_out_type ppf ty;
      pp_print_char ppf ')';
      pp_close_box ppf ()
  | Otyp_abstract | Otyp_open
  | Otyp_sum _ | Otyp_record _ | Otyp_manifest (_, _) -> ()
  | Otyp_module (p, n, tyl) ->
      fprintf ppf "@[<1>(module %s" p;
      let first = ref true in
      List.iter2
        (fun s t ->
          let sep = if !first then (first := false; "with") else "and" in
          fprintf ppf " %s type %s = %a" sep s print_out_type t
        )
        n tyl;
      fprintf ppf ")@]"
and print_fields rest ppf =
  function
    [] ->
      begin match rest with
        Some non_gen -> fprintf ppf "%s.." (if non_gen then "_" else "")
      | None -> ()
      end
  | [s, t] ->
      fprintf ppf "%s : %a" s print_out_type t;
      begin match rest with
        Some _ -> fprintf ppf ";@ "
      | None -> ()
      end;
      print_fields rest ppf []
  | (s, t) :: l ->
      fprintf ppf "%s : %a;@ %a" s print_out_type t (print_fields rest) l
and print_row_field ppf (l, opt_amp, tyl) =
  let pr_of ppf =
    if opt_amp then fprintf ppf " of@ &@ "
    else if tyl <> [] then fprintf ppf " of@ "
    else fprintf ppf ""
  in
  fprintf ppf "@[<hv 2>`%s%t%a@]" l pr_of (print_typlist print_out_type " &")
    tyl
and print_typlist print_elem sep ppf =
  function
    [] -> ()
  | [ty] -> print_elem ppf ty
  | ty :: tyl ->
      print_elem ppf ty;
      pp_print_string ppf sep;
      pp_print_space ppf ();
      print_typlist print_elem sep ppf tyl
and print_typargs ppf =
  function
    [] -> ()
  | [ty1] -> print_simple_out_type ppf ty1; pp_print_space ppf ()
  | tyl ->
      pp_open_box ppf 1;
      pp_print_char ppf '(';
      print_typlist print_out_type "," ppf tyl;
      pp_print_char ppf ')';
      pp_close_box ppf ();
      pp_print_space ppf ()

let out_type = ref print_out_type

(* Class types *)

let type_parameter ppf (ty, (co, cn)) =
  fprintf ppf "%s%s"
    (if not cn then "+" else if not co then "-" else "")
    (if ty = "_" then ty else "'"^ty)

let print_out_class_params ppf =
  function
    [] -> ()
  | tyl ->
      fprintf ppf "@[<1>[%a]@]@ "
        (print_list type_parameter (fun ppf -> fprintf ppf ", "))
        tyl

let rec print_out_class_type ppf =
  function
    Octy_constr (id, tyl) ->
      let pr_tyl ppf =
        function
          [] -> ()
        | tyl ->
            fprintf ppf "@[<1>[%a]@]@ " (print_typlist !out_type ",") tyl
      in
      fprintf ppf "@[%a%a@]" pr_tyl tyl print_ident id
  | Octy_arrow (lab, ty, cty) ->
      fprintf ppf "@[%s%a ->@ %a@]" (if lab <> "" then lab ^ ":" else "")
        print_out_type_2 ty print_out_class_type cty
  | Octy_signature (self_ty, csil) ->
      let pr_param ppf =
        function
          Some ty -> fprintf ppf "@ @[(%a)@]" !out_type ty
        | None -> ()
      in
      fprintf ppf "@[<hv 2>@[<2>object%a@]@ %a@;<1 -2>end@]" pr_param self_ty
        (print_list print_out_class_sig_item (fun ppf -> fprintf ppf "@ "))
        csil
and print_out_class_sig_item ppf =
  function
    Ocsg_constraint (ty1, ty2) ->
      fprintf ppf "@[<2>constraint %a =@ %a@]" !out_type ty1
        !out_type ty2
  | Ocsg_method (name, priv, virt, ty) ->
      fprintf ppf "@[<2>method %s%s%s :@ %a@]"
        (if priv then "private " else "") (if virt then "virtual " else "")
        name !out_type ty
  | Ocsg_value (name, mut, vr, ty) ->
      fprintf ppf "@[<2>val %s%s%s :@ %a@]"
        (if mut then "mutable " else "")
        (if vr then "virtual " else "")
        name !out_type ty

let out_class_type = ref print_out_class_type

(* Signature *)

let out_module_type = ref (fun _ -> failwith "Oprint.out_module_type")
let out_sig_item = ref (fun _ -> failwith "Oprint.out_sig_item")
let out_signature = ref (fun _ -> failwith "Oprint.out_signature")
let out_type_extension = ref (fun _ -> failwith "Oprint.out_type_extension")

let rec print_out_functor ppf =
  function
    Omty_functor (_, None, mty_res) ->
      fprintf ppf "() %a" print_out_functor mty_res
  | Omty_functor (name , Some mty_arg, mty_res) ->
      fprintf ppf "(%s : %a) %a" name
        print_out_module_type mty_arg print_out_functor mty_res
  | m -> fprintf ppf "->@ %a" print_out_module_type m
and print_out_module_type ppf =
  function
    Omty_abstract -> ()
  | Omty_functor _ as t ->
      fprintf ppf "@[<2>functor@ %a@]" print_out_functor t
  | Omty_ident id -> fprintf ppf "%a" print_ident id
  | Omty_signature sg ->
      fprintf ppf "@[<hv 2>sig@ %a@;<1 -2>end@]" !out_signature sg
  | Omty_alias id -> fprintf ppf "(module %a)" print_ident id
and print_out_signature ppf =
  function
    [] -> ()
  | [item] -> !out_sig_item ppf item
  | Osig_typext(ext, Oext_first) :: items ->
      (* Gather together the extension constructors *)
      let rec gather_extensions acc items =
        match items with
            Osig_typext(ext, Oext_next) :: items ->
              gather_extensions
                ((ext.oext_name, ext.oext_args, ext.oext_ret_type) :: acc)
                items
          | _ -> (List.rev acc, items)
      in
      let exts, items =
        gather_extensions
          [(ext.oext_name, ext.oext_args, ext.oext_ret_type)]
          items
      in
      let te =
        { otyext_name = ext.oext_type_name;
          otyext_params = ext.oext_type_params;
          otyext_constructors = exts;
          otyext_private = ext.oext_private }
      in
        fprintf ppf "%a@ %a" !out_type_extension te print_out_signature items
  | item :: items ->
      fprintf ppf "%a@ %a" !out_sig_item item print_out_signature items
and print_out_sig_item ppf =
  function
    Osig_class (vir_flag, name, params, clt, rs) ->
      fprintf ppf "@[<2>%s%s@ %a%s@ :@ %a@]"
        (if rs = Orec_next then "and" else "class")
        (if vir_flag then " virtual" else "") print_out_class_params params
        name !out_class_type clt
  | Osig_class_type (vir_flag, name, params, clt, rs) ->
      fprintf ppf "@[<2>%s%s@ %a%s@ =@ %a@]"
        (if rs = Orec_next then "and" else "class type")
        (if vir_flag then " virtual" else "") print_out_class_params params
        name !out_class_type clt
  | Osig_typext (ext, Oext_exception) ->
      fprintf ppf "@[<2>exception %a@]"
        print_out_constr (ext.oext_name, ext.oext_args, ext.oext_ret_type)
  | Osig_typext (ext, es) ->
      print_out_extension_constructor ppf ext
  | Osig_modtype (name, Omty_abstract) ->
      fprintf ppf "@[<2>module type %s@]" name
  | Osig_modtype (name, mty) ->
      fprintf ppf "@[<2>module type %s =@ %a@]" name !out_module_type mty
  | Osig_module (name, Omty_alias id, _) ->
      fprintf ppf "@[<2>module %s =@ %a@]" name print_ident id
  | Osig_module (name, mty, rs) ->
      fprintf ppf "@[<2>%s %s :@ %a@]"
        (match rs with Orec_not -> "module"
                     | Orec_first -> "module rec"
                     | Orec_next -> "and")
        name !out_module_type mty
  | Osig_type(td, rs) ->
        print_out_type_decl
          (match rs with
           | Orec_not   -> "type nonrec"
           | Orec_first -> "type"
           | Orec_next  -> "and")
          ppf td
  | Osig_value (name, ty, prims) ->
      let kwd = if prims = [] then "val" else "external" in
      let pr_prims ppf =
        function
          [] -> ()
        | s :: sl ->
            fprintf ppf "@ = \"%s\"" s;
            List.iter (fun s ->
(* TODO: in general, we should print bs attributes, some attributes like
  bs.splice does need it *)

    let len = String.length s in
    if len >= 3 && s.[0] = 'B' && s.[1] = 'S' && s.[2] = ':' then
      fprintf ppf "@ \"BS-EXTERNAL\""
    else
      fprintf ppf "@ \"%s\"" s

              ) sl
      in
      fprintf ppf "@[<2>%s %a :@ %a%a@]" kwd value_ident name !out_type
        ty pr_prims prims

and print_out_type_decl kwd ppf td =
  let print_constraints ppf =
    List.iter
      (fun (ty1, ty2) ->
         fprintf ppf "@ @[<2>constraint %a =@ %a@]" !out_type ty1
           !out_type ty2)
      td.otype_cstrs
  in
  let type_defined ppf =
    match td.otype_params with
      [] -> pp_print_string ppf td.otype_name
    | [param] -> fprintf ppf "@[%a@ %s@]" type_parameter param td.otype_name
    | _ ->
        fprintf ppf "@[(@[%a)@]@ %s@]"
          (print_list type_parameter (fun ppf -> fprintf ppf ",@ "))
          td.otype_params
          td.otype_name
  in
  let print_manifest ppf =
    function
      Otyp_manifest (ty, _) -> fprintf ppf " =@ %a" !out_type ty
    | _ -> ()
  in
  let print_name_params ppf =
    fprintf ppf "%s %t%a" kwd type_defined print_manifest td.otype_type
  in
  let ty =
    match td.otype_type with
      Otyp_manifest (_, ty) -> ty
    | _ -> td.otype_type
  in
  let print_private ppf = function
    Asttypes.Private -> fprintf ppf " private"
  | Asttypes.Public -> ()
  in
  let print_out_tkind ppf = function
  | Otyp_abstract -> ()
  | Otyp_record lbls ->
      fprintf ppf " =%a {%a@;<1 -2>}"
        print_private td.otype_private
        (print_list_init print_out_label (fun ppf -> fprintf ppf "@ ")) lbls
  | Otyp_sum constrs ->
      fprintf ppf " =%a@;<1 2>%a"
        print_private td.otype_private
        (print_list print_out_constr (fun ppf -> fprintf ppf "@ | ")) constrs
  | Otyp_open ->
      fprintf ppf " = .."
  | ty ->
      fprintf ppf " =%a@;<1 2>%a"
        print_private td.otype_private
        !out_type ty
  in
  fprintf ppf "@[<2>@[<hv 2>%t%a@]%t@]"
    print_name_params
    print_out_tkind ty
    print_constraints

and print_out_constr ppf (name, tyl,ret_type_opt) =
  match ret_type_opt with
  | None ->
      begin match tyl with
      | [] ->
          pp_print_string ppf name
      | _ ->
          fprintf ppf "@[<2>%s of@ %a@]" name
            (print_typlist print_simple_out_type " *") tyl
      end
  | Some ret_type ->
      begin match tyl with
      | [] ->
          fprintf ppf "@[<2>%s :@ %a@]" name print_simple_out_type  ret_type
      | _ ->
          fprintf ppf "@[<2>%s :@ %a -> %a@]" name
            (print_typlist print_simple_out_type " *")
            tyl print_simple_out_type ret_type
      end


and print_out_label ppf (name, mut, arg) =
  fprintf ppf "@[<2>%s%s :@ %a@];" (if mut then "mutable " else "") name
    !out_type arg

and print_out_extension_constructor ppf ext =
  let print_extended_type ppf =
    let print_type_parameter ppf ty =
      fprintf ppf "%s"
        (if ty = "_" then ty else "'"^ty)
    in
      match ext.oext_type_params with
        [] -> fprintf ppf "%s" ext.oext_type_name
      | [ty_param] ->
        fprintf ppf "@[%a@ %s@]"
          print_type_parameter
          ty_param
          ext.oext_type_name
      | _ ->
        fprintf ppf "@[(@[%a)@]@ %s@]"
          (print_list print_type_parameter (fun ppf -> fprintf ppf ",@ "))
          ext.oext_type_params
          ext.oext_type_name
  in
  fprintf ppf "@[<hv 2>type %t +=%s@;<1 2>%a@]"
    print_extended_type
    (if ext.oext_private = Asttypes.Private then " private" else "")
    print_out_constr (ext.oext_name, ext.oext_args, ext.oext_ret_type)

and print_out_type_extension ppf te =
  let print_extended_type ppf =
    let print_type_parameter ppf ty =
      fprintf ppf "%s"
        (if ty = "_" then ty else "'"^ty)
    in
    match te.otyext_params with
      [] -> fprintf ppf "%s" te.otyext_name
    | [param] ->
      fprintf ppf "@[%a@ %s@]"
        print_type_parameter param
        te.otyext_name
    | _ ->
        fprintf ppf "@[(@[%a)@]@ %s@]"
          (print_list print_type_parameter (fun ppf -> fprintf ppf ",@ "))
          te.otyext_params
          te.otyext_name
  in
  fprintf ppf "@[<hv 2>type %t +=%s@;<1 2>%a@]"
    print_extended_type
    (if te.otyext_private = Asttypes.Private then " private" else "")
    (print_list print_out_constr (fun ppf -> fprintf ppf "@ | "))
    te.otyext_constructors

let _ = out_module_type := print_out_module_type
let _ = out_signature := print_out_signature
let _ = out_sig_item := print_out_sig_item
let _ = out_type_extension := print_out_type_extension

(* Phrases *)

let print_out_exception ppf exn outv =
  match exn with
    Sys.Break -> fprintf ppf "Interrupted.@."
  | Out_of_memory -> fprintf ppf "Out of memory during evaluation.@."
  | Stack_overflow ->
      fprintf ppf "Stack overflow during evaluation (looping recursion?).@."
  | _ -> fprintf ppf "@[Exception:@ %a.@]@." !out_value outv

let rec print_items ppf =
  function
    [] -> ()
  | (Osig_typext(ext, Oext_first), None) :: items ->
      (* Gather together extension constructors *)
      let rec gather_extensions acc items =
        match items with
            (Osig_typext(ext, Oext_next), None) :: items ->
              gather_extensions
                ((ext.oext_name, ext.oext_args, ext.oext_ret_type) :: acc)
                items
          | _ -> (List.rev acc, items)
      in
      let exts, items =
        gather_extensions
          [(ext.oext_name, ext.oext_args, ext.oext_ret_type)]
          items
      in
      let te =
        { otyext_name = ext.oext_type_name;
          otyext_params = ext.oext_type_params;
          otyext_constructors = exts;
          otyext_private = ext.oext_private }
      in
        fprintf ppf "@[%a@]" !out_type_extension te;
        if items <> [] then fprintf ppf "@ %a" print_items items
  | (tree, valopt) :: items ->
      begin match valopt with
        Some v ->
          fprintf ppf "@[<2>%a =@ %a@]" !out_sig_item tree
            !out_value v
      | None -> fprintf ppf "@[%a@]" !out_sig_item tree
      end;
      if items <> [] then fprintf ppf "@ %a" print_items items

let print_out_phrase ppf =
  function
    Ophr_eval (outv, ty) ->
      fprintf ppf "@[- : %a@ =@ %a@]@." !out_type ty !out_value outv
  | Ophr_signature [] -> ()
  | Ophr_signature items -> fprintf ppf "@[<v>%a@]@." print_items items
  | Ophr_exception (exn, outv) -> print_out_exception ppf exn outv

let out_phrase = ref print_out_phrase

end
module Printtyp : sig
(*#1 "printtyp.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Printing functions *)

open Format
open Types
open Outcometree

val longident: formatter -> Longident.t -> unit
val ident: formatter -> Ident.t -> unit
val tree_of_path: Path.t -> out_ident
val path: formatter -> Path.t -> unit
val string_of_path: Path.t -> string
val raw_type_expr: formatter -> type_expr -> unit

val wrap_printing_env: Env.t -> (unit -> 'a) -> 'a
    (* Call the function using the environment for type path shortening *)
    (* This affects all the printing functions below *)

val reset: unit -> unit
val mark_loops: type_expr -> unit
val reset_and_mark_loops: type_expr -> unit
val reset_and_mark_loops_list: type_expr list -> unit
val type_expr: formatter -> type_expr -> unit
val tree_of_type_scheme: type_expr -> out_type
val type_sch : formatter -> type_expr -> unit
val type_scheme: formatter -> type_expr -> unit
(* Maxence *)
val reset_names: unit -> unit
val type_scheme_max: ?b_reset_names: bool ->
        formatter -> type_expr -> unit
(* Fin Maxence *)
val tree_of_value_description: Ident.t -> value_description -> out_sig_item
val value_description: Ident.t -> formatter -> value_description -> unit
val tree_of_type_declaration:
    Ident.t -> type_declaration -> rec_status -> out_sig_item
val type_declaration: Ident.t -> formatter -> type_declaration -> unit
val tree_of_extension_constructor:
    Ident.t -> extension_constructor -> ext_status -> out_sig_item
val extension_constructor:
    Ident.t -> formatter -> extension_constructor -> unit
val tree_of_module: Ident.t -> module_type -> rec_status -> out_sig_item
val modtype: formatter -> module_type -> unit
val signature: formatter -> signature -> unit
val tree_of_modtype_declaration:
    Ident.t -> modtype_declaration -> out_sig_item
val tree_of_signature: Types.signature -> out_sig_item list
val tree_of_typexp: bool -> type_expr -> out_type
val modtype_declaration: Ident.t -> formatter -> modtype_declaration -> unit
val class_type: formatter -> class_type -> unit
val tree_of_class_declaration:
    Ident.t -> class_declaration -> rec_status -> out_sig_item
val class_declaration: Ident.t -> formatter -> class_declaration -> unit
val tree_of_cltype_declaration:
    Ident.t -> class_type_declaration -> rec_status -> out_sig_item
val cltype_declaration: Ident.t -> formatter -> class_type_declaration -> unit
val type_expansion: type_expr -> Format.formatter -> type_expr -> unit
val prepare_expansion: type_expr * type_expr -> type_expr * type_expr
val trace:
    bool -> bool-> string -> formatter -> (type_expr * type_expr) list -> unit
val report_unification_error:
    formatter -> Env.t -> ?unif:bool -> (type_expr * type_expr) list ->
    (formatter -> unit) -> (formatter -> unit) ->
    unit


val super_report_unification_error:
    formatter -> Env.t -> ?unif:bool -> (type_expr * type_expr) list ->
    (formatter -> unit) -> (formatter -> unit) ->
    unit


val report_subtyping_error:
    formatter -> Env.t -> (type_expr * type_expr) list ->
    string -> (type_expr * type_expr) list -> unit
val report_ambiguous_type_error:
    formatter -> Env.t -> (Path.t * Path.t) -> (Path.t * Path.t) list ->
    (formatter -> unit) -> (formatter -> unit) -> (formatter -> unit) -> unit

(* for toploop *)
val hide_rec_items: signature_item list -> unit

end = struct
(*#1 "printtyp.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(* Xavier Leroy and Jerome Vouillon, projet Cristal, INRIA Rocquencourt*)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Printing functions *)

open Misc
open Ctype
open Format
open Longident
open Path
open Asttypes
open Types
open Btype
open Outcometree

(* Print a long identifier *)

let rec longident ppf = function
  | Lident s -> pp_print_string ppf s
  | Ldot(p, s) -> fprintf ppf "%a.%s" longident p s
  | Lapply(p1, p2) -> fprintf ppf "%a(%a)" longident p1 longident p2

(* Print an identifier *)

let unique_names = ref Ident.empty

let ident_name id =
  try Ident.find_same id !unique_names with Not_found -> Ident.name id

let add_unique id =
  try ignore (Ident.find_same id !unique_names)
  with Not_found ->
    unique_names := Ident.add id (Ident.unique_toplevel_name id) !unique_names

let ident ppf id = pp_print_string ppf (ident_name id)

(* Print a path *)

let ident_pervasive = Ident.create_persistent "Stdlib"

let rec tree_of_path = function
  | Pident id ->
      Oide_ident (ident_name id)
  | Pdot(Pident id, s, pos) when Ident.same id ident_pervasive ->
      Oide_ident s
  | Pdot(p, s, pos) ->
      Oide_dot (tree_of_path p, s)
  | Papply(p1, p2) ->
      Oide_apply (tree_of_path p1, tree_of_path p2)

let rec path ppf = function
  | Pident id ->
      ident ppf id
  | Pdot(Pident id, s, pos) when Ident.same id ident_pervasive ->
      pp_print_string ppf s
  | Pdot(p, s, pos) ->
      path ppf p;
      pp_print_char ppf '.';
      pp_print_string ppf s
  | Papply(p1, p2) ->
      fprintf ppf "%a(%a)" path p1 path p2

let rec string_of_out_ident = function
  | Oide_ident s -> s
  | Oide_dot (id, s) -> String.concat "." [string_of_out_ident id; s]
  | Oide_apply (id1, id2) ->
      String.concat ""
        [string_of_out_ident id1; "("; string_of_out_ident id2; ")"]

let string_of_path p = string_of_out_ident (tree_of_path p)

(* Print a recursive annotation *)

let tree_of_rec = function
  | Trec_not -> Orec_not
  | Trec_first -> Orec_first
  | Trec_next -> Orec_next

(* Print a raw type expression, with sharing *)

let raw_list pr ppf = function
    [] -> fprintf ppf "[]"
  | a :: l ->
      fprintf ppf "@[<1>[%a%t]@]" pr a
        (fun ppf -> List.iter (fun x -> fprintf ppf ";@,%a" pr x) l)

let rec safe_kind_repr v = function
    Fvar {contents=Some k}  ->
      if List.memq k v then "Fvar loop" else
      safe_kind_repr (k::v) k
  | Fvar _ -> "Fvar None"
  | Fpresent -> "Fpresent"
  | Fabsent -> "Fabsent"

let rec safe_commu_repr v = function
    Cok -> "Cok"
  | Cunknown -> "Cunknown"
  | Clink r ->
      if List.memq r v then "Clink loop" else
      safe_commu_repr (r::v) !r

let rec safe_repr v = function
    {desc = Tlink t} when not (List.memq t v) ->
      safe_repr (t::v) t
  | t -> t

let rec list_of_memo = function
    Mnil -> []
  | Mcons (priv, p, t1, t2, rem) -> p :: list_of_memo rem
  | Mlink rem -> list_of_memo !rem

let print_name ppf = function
    None -> fprintf ppf "None"
  | Some name -> fprintf ppf "\"%s\"" name

let visited = ref []
let rec raw_type ppf ty =
  let ty = safe_repr [] ty in
  if List.memq ty !visited then fprintf ppf "{id=%d}" ty.id else begin
    visited := ty :: !visited;
    fprintf ppf "@[<1>{id=%d;level=%d;desc=@,%a}@]" ty.id ty.level
      raw_type_desc ty.desc
  end
and raw_type_list tl = raw_list raw_type tl
and raw_type_desc ppf = function
    Tvar name -> fprintf ppf "Tvar %a" print_name name
  | Tarrow(l,t1,t2,c) ->
      fprintf ppf "@[<hov1>Tarrow(%s,@,%a,@,%a,@,%s)@]"
        l raw_type t1 raw_type t2
        (safe_commu_repr [] c)
  | Ttuple tl ->
      fprintf ppf "@[<1>Ttuple@,%a@]" raw_type_list tl
  | Tconstr (p, tl, abbrev) ->
      fprintf ppf "@[<hov1>Tconstr(@,%a,@,%a,@,%a)@]" path p
        raw_type_list tl
        (raw_list path) (list_of_memo !abbrev)
  | Tobject (t, nm) ->
      fprintf ppf "@[<hov1>Tobject(@,%a,@,@[<1>ref%t@])@]" raw_type t
        (fun ppf ->
          match !nm with None -> fprintf ppf " None"
          | Some(p,tl) ->
              fprintf ppf "(Some(@,%a,@,%a))" path p raw_type_list tl)
  | Tfield (f, k, t1, t2) ->
      fprintf ppf "@[<hov1>Tfield(@,%s,@,%s,@,%a,@;<0 -1>%a)@]" f
        (safe_kind_repr [] k)
        raw_type t1 raw_type t2
  | Tnil -> fprintf ppf "Tnil"
  | Tlink t -> fprintf ppf "@[<1>Tlink@,%a@]" raw_type t
  | Tsubst t -> fprintf ppf "@[<1>Tsubst@,%a@]" raw_type t
  | Tunivar name -> fprintf ppf "Tunivar %a" print_name name
  | Tpoly (t, tl) ->
      fprintf ppf "@[<hov1>Tpoly(@,%a,@,%a)@]"
        raw_type t
        raw_type_list tl
  | Tvariant row ->
      fprintf ppf
        "@[<hov1>{@[%s@,%a;@]@ @[%s@,%a;@]@ %s%b;@ %s%b;@ @[<1>%s%t@]}@]"
        "row_fields="
        (raw_list (fun ppf (l, f) ->
          fprintf ppf "@[%s,@ %a@]" l raw_field f))
        row.row_fields
        "row_more=" raw_type row.row_more
        "row_closed=" row.row_closed
        "row_fixed=" row.row_fixed
        "row_name="
        (fun ppf ->
          match row.row_name with None -> fprintf ppf "None"
          | Some(p,tl) ->
              fprintf ppf "Some(@,%a,@,%a)" path p raw_type_list tl)
  | Tpackage (p, _, tl) ->
      fprintf ppf "@[<hov1>Tpackage(@,%a@,%a)@]" path p
        raw_type_list tl

and raw_field ppf = function
    Rpresent None -> fprintf ppf "Rpresent None"
  | Rpresent (Some t) -> fprintf ppf "@[<1>Rpresent(Some@,%a)@]" raw_type t
  | Reither (c,tl,m,e) ->
      fprintf ppf "@[<hov1>Reither(%b,@,%a,@,%b,@,@[<1>ref%t@])@]" c
        raw_type_list tl m
        (fun ppf ->
          match !e with None -> fprintf ppf " None"
          | Some f -> fprintf ppf "@,@[<1>(%a)@]" raw_field f)
  | Rabsent -> fprintf ppf "Rabsent"

let raw_type_expr ppf t =
  visited := [];
  raw_type ppf t;
  visited := []

let () = Btype.print_raw := raw_type_expr

(* Normalize paths *)

type param_subst = Id | Nth of int | Map of int list

let is_nth = function
    Nth _ -> true
  | _ -> false

let compose l1 = function
  | Id -> Map l1
  | Map l2 -> Map (List.map (List.nth l1) l2)
  | Nth n  -> Nth (List.nth l1 n)

let apply_subst s1 tyl =
  match s1 with
    Nth n1 -> [List.nth tyl n1]
  | Map l1 -> List.map (List.nth tyl) l1
  | Id -> tyl

type best_path = Paths of Path.t list | Best of Path.t

let printing_env = ref Env.empty
let printing_depth = ref 0
let printing_cont = ref ([] : Env.iter_cont list)
let printing_old = ref Env.empty
let printing_pers = ref Concr.empty
module Path2 = struct
  include Path
  let rec compare p1 p2 =
    (* must ignore position when comparing paths *)
    match (p1, p2) with
      (Pdot(p1, s1, pos1), Pdot(p2, s2, pos2)) ->
        let c = compare p1 p2 in
        if c <> 0 then c else String.compare s1 s2
    | (Papply(fun1, arg1), Papply(fun2, arg2)) ->
        let c = compare fun1 fun2 in
        if c <> 0 then c else compare arg1 arg2
    | _ -> Stdlib.compare p1 p2
end
module PathMap = Map.Make(Path2)
let printing_map = ref PathMap.empty

let same_type t t' = repr t == repr t'

let rec index l x =
  match l with
    [] -> raise Not_found
  | a :: l -> if x == a then 0 else 1 + index l x

let rec uniq = function
    [] -> true
  | a :: l -> not (List.memq a l) && uniq l

let rec normalize_type_path ?(cache=false) env p =
  try
    let (params, ty, _) = Env.find_type_expansion p env in
    let params = List.map repr params in
    match repr ty with
      {desc = Tconstr (p1, tyl, _)} ->
        let tyl = List.map repr tyl in
        if List.length params = List.length tyl
        && List.for_all2 (==) params tyl
        then normalize_type_path ~cache env p1
        else if cache || List.length params <= List.length tyl
             || not (uniq tyl) then (p, Id)
        else
          let l1 = List.map (index params) tyl in
          let (p2, s2) = normalize_type_path ~cache env p1 in
          (p2, compose l1 s2)
    | ty ->
        (p, Nth (index params ty))
  with
    Not_found -> (p, Id)

let rec path_size = function
    Pident id ->
      (let s = Ident.name id in if s <> "" && s.[0] = '_' then 10 else 1),
      -Ident.binding_time id
  | Pdot (p, _, _) ->
      let (l, b) = path_size p in (1+l, b)
  | Papply (p1, p2) ->
      let (l, b) = path_size p1 in
      (l + fst (path_size p2), b)

let same_printing_env env =
  let used_pers = Env.used_persistent () in
  Env.same_types !printing_old env && Concr.equal !printing_pers used_pers

let set_printing_env env =
  printing_env := if !Clflags.real_paths then Env.empty else env;
  if !printing_env == Env.empty || same_printing_env env then () else
  begin
    (* printf "Reset printing_map@."; *)
    printing_old := env;
    printing_pers := Env.used_persistent ();
    printing_map := PathMap.empty;
    printing_depth := 0;
    (* printf "Recompute printing_map.@."; *)
    let cont =
      Env.iter_types
        (fun p (p', decl) ->
          let (p1, s1) = normalize_type_path env p' ~cache:true in
          (* Format.eprintf "%a -> %a = %a@." path p path p' path p1 *)
          if s1 = Id then
          try
            let r = PathMap.find p1 !printing_map in
            match !r with
              Paths l -> r := Paths (p :: l)
            | Best p' -> r := Paths [p; p'] (* assert false *)
          with Not_found ->
            printing_map := PathMap.add p1 (ref (Paths [p])) !printing_map)
        env in
    printing_cont := [cont];
  end

let wrap_printing_env env f =
  set_printing_env env;
  try_finally f (fun () -> set_printing_env Env.empty)

let is_unambiguous path env =
  let l = Env.find_shadowed_types path env in
  List.exists (Path.same path) l || (* concrete paths are ok *)
  match l with
    [] -> true
  | p :: rem ->
      (* allow also coherent paths:  *)
      let normalize p = fst (normalize_type_path ~cache:true env p) in
      let p' = normalize p in
      List.for_all (fun p -> Path.same (normalize p) p') rem ||
      (* also allow repeatedly defining and opening (for toplevel) *)
      let id = lid_of_path p in
      List.for_all (fun p -> lid_of_path p = id) rem &&
      Path.same p (fst (Env.lookup_type id env))

let rec get_best_path r =
  match !r with
    Best p' -> p'
  | Paths [] -> raise Not_found
  | Paths l ->
      r := Paths [];
      List.iter
        (fun p ->
          (* Format.eprintf "evaluating %a@." path p; *)
          match !r with
            Best p' when path_size p >= path_size p' -> ()
          | _ -> if is_unambiguous p !printing_env then r := Best p)
              (* else Format.eprintf "%a ignored as ambiguous@." path p *)
        l;
      get_best_path r

let best_type_path p =
  if !Clflags.real_paths || !printing_env == Env.empty
  then (p, Id)
  else
    let (p', s) = normalize_type_path !printing_env p in
    let get_path () = get_best_path (PathMap.find  p' !printing_map) in
    while !printing_cont <> [] &&
      try ignore (get_path ()); false with Not_found -> true
    do
      printing_cont := List.map snd (Env.run_iter_cont !printing_cont);
      incr printing_depth;
    done;
    let p'' = try get_path () with Not_found -> p' in
    (* Format.eprintf "%a = %a -> %a@." path p path p' path p''; *)
    (p'', s)

(* Print a type expression *)

let names = ref ([] : (type_expr * string) list)
let name_counter = ref 0
let named_vars = ref ([] : string list)

let reset_names () = names := []; name_counter := 0; named_vars := []
let add_named_var ty =
  match ty.desc with
    Tvar (Some name) | Tunivar (Some name) ->
      if List.mem name !named_vars then () else
      named_vars := name :: !named_vars
  | _ -> ()

let rec new_name () =
  let name =
    if !name_counter < 26
    then String.make 1 (Char.chr(97 + !name_counter))
    else String.make 1 (Char.chr(97 + !name_counter mod 26)) ^
           string_of_int(!name_counter / 26) in
  incr name_counter;
  if List.mem name !named_vars
  || List.exists (fun (_, name') -> name = name') !names
  then new_name ()
  else name

let name_of_type t =
  (* We've already been through repr at this stage, so t is our representative
     of the union-find class. *)
  try List.assq t !names with Not_found ->
    let name =
      match t.desc with
        Tvar (Some name) | Tunivar (Some name) ->
          (* Some part of the type we've already printed has assigned another
           * unification variable to that name. We want to keep the name, so try
           * adding a number until we find a name that's not taken. *)
          let current_name = ref name in
          let i = ref 0 in
          while List.exists (fun (_, name') -> !current_name = name') !names do
            current_name := name ^ (string_of_int !i);
            i := !i + 1;
          done;
          !current_name
      | _ ->
          (* No name available, create a new one *)
          new_name ()
    in
    (* Exception for type declarations *)
    if name <> "_" then names := (t, name) :: !names;
    name

let check_name_of_type t = ignore(name_of_type t)

let remove_names tyl =
  let tyl = List.map repr tyl in
  names := List.filter (fun (ty,_) -> not (List.memq ty tyl)) !names


let non_gen_mark sch ty =
  if sch && is_Tvar ty && ty.level <> generic_level then "_" else ""

let print_name_of_type sch ppf t =
  fprintf ppf "'%s%s" (non_gen_mark sch t) (name_of_type t)

let visited_objects = ref ([] : type_expr list)
let aliased = ref ([] : type_expr list)
let delayed = ref ([] : type_expr list)

let add_delayed t =
  if not (List.memq t !delayed) then delayed := t :: !delayed

let is_aliased ty = List.memq (proxy ty) !aliased
let add_alias ty =
  let px = proxy ty in
  if not (is_aliased px) then begin
    aliased := px :: !aliased;
    add_named_var px
  end

let aliasable ty =
  match ty.desc with
    Tvar _ | Tunivar _ | Tpoly _ -> false
  | Tconstr (p, _, _) ->
      not (is_nth (snd (best_type_path p)))
  | _ -> true

let namable_row row =
  row.row_name <> None &&
  List.for_all
    (fun (_, f) ->
       match row_field_repr f with
       | Reither(c, l, _, _) ->
           row.row_closed && if c then l = [] else List.length l = 1
       | _ -> true)
    row.row_fields

let rec mark_loops_rec visited ty =
  let ty = repr ty in
  let px = proxy ty in
  if List.memq px visited && aliasable ty then add_alias px else
    let visited = px :: visited in
    match ty.desc with
    | Tvar _ -> add_named_var ty
    | Tarrow(_, ty1, ty2, _) ->
        mark_loops_rec visited ty1; mark_loops_rec visited ty2
    | Ttuple tyl -> List.iter (mark_loops_rec visited) tyl
    | Tconstr(p, tyl, _) ->
        let (p', s) = best_type_path p in
        List.iter (mark_loops_rec visited) (apply_subst s tyl)
    | Tpackage (_, _, tyl) ->
        List.iter (mark_loops_rec visited) tyl
    | Tvariant row ->
        if List.memq px !visited_objects then add_alias px else
         begin
          let row = row_repr row in
          if not (static_row row) then
            visited_objects := px :: !visited_objects;
          match row.row_name with
          | Some(p, tyl) when namable_row row ->
              List.iter (mark_loops_rec visited) tyl
          | _ ->
              iter_row (mark_loops_rec visited) row
         end
    | Tobject (fi, nm) ->
        if List.memq px !visited_objects then add_alias px else
         begin
          if opened_object ty then
            visited_objects := px :: !visited_objects;
          begin match !nm with
          | None ->
              let fields, _ = flatten_fields fi in
              List.iter
                (fun (_, kind, ty) ->
                  if field_kind_repr kind = Fpresent then
                    mark_loops_rec visited ty)
                fields
          | Some (_, l) ->
              List.iter (mark_loops_rec visited) (List.tl l)
          end
        end
    | Tfield(_, kind, ty1, ty2) when field_kind_repr kind = Fpresent ->
        mark_loops_rec visited ty1; mark_loops_rec visited ty2
    | Tfield(_, _, _, ty2) ->
        mark_loops_rec visited ty2
    | Tnil -> ()
    | Tsubst ty -> mark_loops_rec visited ty
    | Tlink _ -> fatal_error "Printtyp.mark_loops_rec (2)"
    | Tpoly (ty, tyl) ->
        List.iter (fun t -> add_alias t) tyl;
        mark_loops_rec visited ty
    | Tunivar _ -> add_named_var ty

let mark_loops ty =
  normalize_type Env.empty ty;
  mark_loops_rec [] ty;;

let reset_loop_marks () =
  visited_objects := []; aliased := []; delayed := []

let reset () =
  unique_names := Ident.empty; reset_names (); reset_loop_marks ()

let reset_and_mark_loops ty =
  reset (); mark_loops ty

let reset_and_mark_loops_list tyl =
  reset (); List.iter mark_loops tyl

(* Disabled in classic mode when printing an unification error *)
let print_labels = ref true
let print_label ppf l =
  if !print_labels && l <> "" || is_optional l then fprintf ppf "%s:" l

let rec tree_of_typexp sch ty =
  let ty = repr ty in
  let px = proxy ty in
  if List.mem_assq px !names && not (List.memq px !delayed) then
   let mark = is_non_gen sch ty in
   Otyp_var (mark, name_of_type px) else

  let pr_typ () =
    match ty.desc with
    | Tvar _ ->
        Otyp_var (is_non_gen sch ty, name_of_type ty)
    | Tarrow(l, ty1, ty2, _) ->
        let pr_arrow l ty1 ty2 =
          let lab =
            if !print_labels && l <> "" || is_optional l then l else ""
          in
          let t1 =
            if is_optional l then
              match (repr ty1).desc with
              | Tconstr(path, [ty], _)
                when Path.same path Predef.path_option ->
                  tree_of_typexp sch ty
              | _ -> Otyp_stuff "<hidden>"
            else tree_of_typexp sch ty1 in
          Otyp_arrow (lab, t1, tree_of_typexp sch ty2) in
        pr_arrow l ty1 ty2
    | Ttuple tyl ->
        Otyp_tuple (tree_of_typlist sch tyl)
    | Tconstr(p, tyl, abbrev) ->
        let p', s = best_type_path p in
        let tyl' = apply_subst s tyl in
        if is_nth s then tree_of_typexp sch (List.hd tyl') else
        Otyp_constr (tree_of_path p', tree_of_typlist sch tyl')
    | Tvariant row ->
        let row = row_repr row in
        let fields =
          if row.row_closed then
            List.filter (fun (_, f) -> row_field_repr f <> Rabsent)
              row.row_fields
          else row.row_fields in
        let present =
          List.filter
            (fun (_, f) ->
               match row_field_repr f with
               | Rpresent _ -> true
               | _ -> false)
            fields in
        let all_present = List.length present = List.length fields in
        begin match row.row_name with
        | Some(p, tyl) when namable_row row ->
            let (p', s) = best_type_path p in
            let id = tree_of_path p' in
            let args = tree_of_typlist sch (apply_subst s tyl) in
            if row.row_closed && all_present then
              if is_nth s then List.hd args else Otyp_constr (id, args)
            else
              let non_gen = is_non_gen sch px in
              let tags =
                if all_present then None else Some (List.map fst present) in
              let inh =
                match args with
                  [Otyp_constr (i, a)] when is_nth s -> Ovar_name (i, a)
                | _ ->
                    (* fallback case, should change outcometree... *)
                    Ovar_name (tree_of_path p, tree_of_typlist sch tyl)
              in
              Otyp_variant (non_gen, inh, row.row_closed, tags)
        | _ ->
            let non_gen =
              not (row.row_closed && all_present) && is_non_gen sch px in
            let fields = List.map (tree_of_row_field sch) fields in
            let tags =
              if all_present then None else Some (List.map fst present) in
            Otyp_variant (non_gen, Ovar_fields fields, row.row_closed, tags)
        end
    | Tobject (fi, nm) ->
        tree_of_typobject sch fi !nm
    | Tnil | Tfield _ ->
        tree_of_typobject sch ty None
    | Tsubst ty ->
        tree_of_typexp sch ty
    | Tlink _ ->
        fatal_error "Printtyp.tree_of_typexp"
    | Tpoly (ty, []) ->
        tree_of_typexp sch ty
    | Tpoly (ty, tyl) ->
        (*let print_names () =
          List.iter (fun (_, name) -> prerr_string (name ^ " ")) !names;
          prerr_string "; " in *)
        let tyl = List.map repr tyl in
        if tyl = [] then tree_of_typexp sch ty else begin
          let old_delayed = !delayed in
          (* Make the names delayed, so that the real type is
             printed once when used as proxy *)
          List.iter add_delayed tyl;
          let tl = List.map name_of_type tyl in
          let tr = Otyp_poly (tl, tree_of_typexp sch ty) in
          (* Forget names when we leave scope *)
          remove_names tyl;
          delayed := old_delayed; tr
        end
    | Tunivar _ ->
        Otyp_var (false, name_of_type ty)
    | Tpackage (p, n, tyl) ->
        let n =
          List.map (fun li -> String.concat "." (Longident.flatten li)) n in
        Otyp_module (Path.name p, n, tree_of_typlist sch tyl)
  in
  if List.memq px !delayed then delayed := List.filter ((!=) px) !delayed;
  if is_aliased px && aliasable ty then begin
    check_name_of_type px;
    Otyp_alias (pr_typ (), name_of_type px) end
  else pr_typ ()

and tree_of_row_field sch (l, f) =
  match row_field_repr f with
  | Rpresent None | Reither(true, [], _, _) -> (l, false, [])
  | Rpresent(Some ty) -> (l, false, [tree_of_typexp sch ty])
  | Reither(c, tyl, _, _) ->
      if c (* contradiction: un constructeur constant qui a un argument *)
      then (l, true, tree_of_typlist sch tyl)
      else (l, false, tree_of_typlist sch tyl)
  | Rabsent -> (l, false, [] (* une erreur, en fait *))

and tree_of_typlist sch tyl =
  List.map (tree_of_typexp sch) tyl

and tree_of_typobject sch fi nm =
  begin match nm with
  | None ->
      let pr_fields fi =
        let (fields, rest) = flatten_fields fi in
        let present_fields =
          List.fold_right
            (fun (n, k, t) l ->
               match field_kind_repr k with
               | Fpresent -> (n, t) :: l
               | _ -> l)
            fields [] in
        let sorted_fields =
          List.sort (fun (n, _) (n', _) -> compare n n') present_fields in
        tree_of_typfields sch rest sorted_fields in
      let (fields, rest) = pr_fields fi in
      Otyp_object (fields, rest)
  | Some (p, ty :: tyl) ->
      let non_gen = is_non_gen sch (repr ty) in
      let args = tree_of_typlist sch tyl in
      let (p', s) = best_type_path p in
      assert (s = Id);
      Otyp_class (non_gen, tree_of_path p', args)
  | _ ->
      fatal_error "Printtyp.tree_of_typobject"
  end

and is_non_gen sch ty =
    sch && is_Tvar ty && ty.level <> generic_level

and tree_of_typfields sch rest = function
  | [] ->
      let rest =
        match rest.desc with
        | Tvar _ | Tunivar _ -> Some (is_non_gen sch rest)
        | Tconstr _ -> Some false
        | Tnil -> None
        | _ -> fatal_error "typfields (1)"
      in
      ([], rest)
  | (s, t) :: l ->
      let field = (s, tree_of_typexp sch t) in
      let (fields, rest) = tree_of_typfields sch rest l in
      (field :: fields, rest)

let typexp sch prio ppf ty =
  !Oprint.out_type ppf (tree_of_typexp sch ty)

let type_expr ppf ty = typexp false 0 ppf ty

and type_sch ppf ty = typexp true 0 ppf ty

and type_scheme ppf ty = reset_and_mark_loops ty; typexp true 0 ppf ty

(* Maxence *)
let type_scheme_max ?(b_reset_names=true) ppf ty =
  if b_reset_names then reset_names () ;
  typexp true 0 ppf ty
(* Fin Maxence *)

let tree_of_type_scheme ty = reset_and_mark_loops ty; tree_of_typexp true ty

(* Print one type declaration *)

let tree_of_constraints params =
  List.fold_right
    (fun ty list ->
       let ty' = unalias ty in
       if proxy ty != proxy ty' then
         let tr = tree_of_typexp true ty in
         (tr, tree_of_typexp true ty') :: list
       else list)
    params []

let filter_params tyl =
  let params =
    List.fold_left
      (fun tyl ty ->
        let ty = repr ty in
        if List.memq ty tyl then Btype.newgenty (Tsubst ty) :: tyl
        else ty :: tyl)
      [] tyl
  in List.rev params

let string_of_mutable = function
  | Immutable -> ""
  | Mutable -> "mutable "

let rec tree_of_type_decl id decl =

  reset();

  let params = filter_params decl.type_params in

  begin match decl.type_manifest with
  | Some ty ->
      let vars = free_variables ty in
      List.iter
        (function {desc = Tvar (Some "_")} as ty ->
            if List.memq ty vars then ty.desc <- Tvar None
          | _ -> ())
        params
  | None -> ()
  end;

  List.iter add_alias params;
  List.iter mark_loops params;
  List.iter check_name_of_type (List.map proxy params);
  let ty_manifest =
    match decl.type_manifest with
    | None -> None
    | Some ty ->
        let ty =
          (* Special hack to hide variant name *)
          match repr ty with {desc=Tvariant row} ->
            let row = row_repr row in
            begin match row.row_name with
              Some (Pident id', _) when Ident.same id id' ->
                newgenty (Tvariant {row with row_name = None})
            | _ -> ty
            end
          | _ -> ty
        in
        mark_loops ty;
        Some ty
  in
  begin match decl.type_kind with
  | Type_abstract -> ()
  | Type_variant cstrs ->
      List.iter
        (fun c ->
          List.iter mark_loops c.cd_args;
          may mark_loops c.cd_res)
        cstrs
  | Type_record(l, rep) ->
      List.iter (fun l -> mark_loops l.ld_type) l
  | Type_open -> ()
  end;

  let type_param =
    function
    | Otyp_var (_, id) -> id
    | _ -> "?"
  in
  let type_defined decl =
    let abstr =
      match decl.type_kind with
        Type_abstract ->
          decl.type_manifest = None || decl.type_private = Private
      | Type_record _ ->
          decl.type_private = Private
      | Type_variant tll ->
          decl.type_private = Private ||
          List.exists (fun cd -> cd.cd_res <> None) tll
      | Type_open ->
          decl.type_manifest = None
    in
    let vari =
      List.map2
        (fun ty v ->
          if abstr || not (is_Tvar (repr ty)) then Variance.get_upper v
          else (true,true))
        decl.type_params decl.type_variance
    in
    (Ident.name id,
     List.map2 (fun ty cocn -> type_param (tree_of_typexp false ty), cocn)
       params vari)
  in
  let tree_of_manifest ty1 =
    match ty_manifest with
    | None -> ty1
    | Some ty -> Otyp_manifest (tree_of_typexp false ty, ty1)
  in
  let (name, args) = type_defined decl in
  let constraints = tree_of_constraints params in
  let ty, priv =
    match decl.type_kind with
    | Type_abstract ->
        begin match ty_manifest with
        | None -> (Otyp_abstract, Public)
        | Some ty ->
            tree_of_typexp false ty, decl.type_private
        end
    | Type_variant cstrs ->
        tree_of_manifest (Otyp_sum (List.map tree_of_constructor cstrs)),
        decl.type_private
    | Type_record(lbls, rep) ->
        tree_of_manifest (Otyp_record (List.map tree_of_label lbls)),
        decl.type_private
    | Type_open ->
        tree_of_manifest Otyp_open,
        Public
  in
    { otype_name = name;
      otype_params = args;
      otype_type = ty;
      otype_private = priv;
      otype_cstrs = constraints }

and tree_of_constructor cd =
  let name = Ident.name cd.cd_id in
  match cd.cd_res with
  | None -> (name, tree_of_typlist false cd.cd_args, None)
  | Some res ->
      let nm = !names in
      names := [];
      let ret = tree_of_typexp false res in
      let args = tree_of_typlist false cd.cd_args in
      names := nm;
      (name, args, Some ret)

and tree_of_label l =
  (Ident.name l.ld_id, l.ld_mutable = Mutable, tree_of_typexp false l.ld_type)

let tree_of_type_declaration id decl rs =
  Osig_type (tree_of_type_decl id decl, tree_of_rec rs)

let type_declaration id ppf decl =
  !Oprint.out_sig_item ppf (tree_of_type_declaration id decl Trec_first)

(* Print an extension declaration *)

let tree_of_extension_constructor id ext es =
  reset ();
  let ty_name = Path.name ext.ext_type_path in
  let ty_params = filter_params ext.ext_type_params in
  List.iter add_alias ty_params;
  List.iter mark_loops ty_params;
  List.iter check_name_of_type (List.map proxy ty_params);
  List.iter mark_loops ext.ext_args;
  may mark_loops ext.ext_ret_type;
  let type_param =
    function
    | Otyp_var (_, id) -> id
    | _ -> "?"
  in
  let ty_params =
    List.map (fun ty -> type_param (tree_of_typexp false ty)) ty_params
  in
  let name = Ident.name id in
  let args, ret =
    match ext.ext_ret_type with
    | None -> (tree_of_typlist false ext.ext_args, None)
    | Some res ->
        let nm = !names in
        names := [];
        let ret = tree_of_typexp false res in
        let args = tree_of_typlist false ext.ext_args in
        names := nm;
        (args, Some ret)
  in
  let ext =
    { oext_name = name;
      oext_type_name = ty_name;
      oext_type_params = ty_params;
      oext_args = args;
      oext_ret_type = ret;
      oext_private = ext.ext_private }
  in
  let es =
    match es with
        Text_first -> Oext_first
      | Text_next -> Oext_next
      | Text_exception -> Oext_exception
  in
    Osig_typext (ext, es)

let extension_constructor id ppf ext =
  !Oprint.out_sig_item ppf (tree_of_extension_constructor id ext Text_first)

(* Print a value declaration *)

let tree_of_value_description id decl =
  (* Format.eprintf "@[%a@]@." raw_type_expr decl.val_type; *)
  let id = Ident.name id in
  let ty = tree_of_type_scheme decl.val_type in
  let prims =
    match decl.val_kind with
    | Val_prim p -> Primitive.description_list p
    | _ -> []
  in
  Osig_value (id, ty, prims)

let value_description id ppf decl =
  !Oprint.out_sig_item ppf (tree_of_value_description id decl)

(* Print a class type *)

let class_var sch ppf l (m, t) =
  fprintf ppf
    "@ @[<2>val %s%s :@ %a@]" (string_of_mutable m) l (typexp sch 0) t

let method_type (_, kind, ty) =
  match field_kind_repr kind, repr ty with
    Fpresent, {desc=Tpoly(ty, tyl)} -> (ty, tyl)
  | _       , ty                    -> (ty, [])

let tree_of_metho sch concrete csil (lab, kind, ty) =
  if lab <> dummy_method then begin
    let kind = field_kind_repr kind in
    let priv = kind <> Fpresent in
    let virt = not (Concr.mem lab concrete) in
    let (ty, tyl) = method_type (lab, kind, ty) in
    let tty = tree_of_typexp sch ty in
    remove_names tyl;
    Ocsg_method (lab, priv, virt, tty) :: csil
  end
  else csil

let rec prepare_class_type params = function
  | Cty_constr (p, tyl, cty) ->
      let sty = Ctype.self_type cty in
      if List.memq (proxy sty) !visited_objects
      || not (List.for_all is_Tvar params)
      || List.exists (deep_occur sty) tyl
      then prepare_class_type params cty
      else List.iter mark_loops tyl
  | Cty_signature sign ->
      let sty = repr sign.csig_self in
      (* Self may have a name *)
      let px = proxy sty in
      if List.memq px !visited_objects then add_alias sty
      else visited_objects := px :: !visited_objects;
      let (fields, _) =
        Ctype.flatten_fields (Ctype.object_fields sign.csig_self)
      in
      List.iter (fun met -> mark_loops (fst (method_type met))) fields;
      Vars.iter (fun _ (_, _, ty) -> mark_loops ty) sign.csig_vars
  | Cty_arrow (_, ty, cty) ->
      mark_loops ty;
      prepare_class_type params cty

let rec tree_of_class_type sch params =
  function
  | Cty_constr (p', tyl, cty) ->
      let sty = Ctype.self_type cty in
      if List.memq (proxy sty) !visited_objects
      || not (List.for_all is_Tvar params)
      then
        tree_of_class_type sch params cty
      else
        Octy_constr (tree_of_path p', tree_of_typlist true tyl)
  | Cty_signature sign ->
      let sty = repr sign.csig_self in
      let self_ty =
        if is_aliased sty then
          Some (Otyp_var (false, name_of_type (proxy sty)))
        else None
      in
      let (fields, _) =
        Ctype.flatten_fields (Ctype.object_fields sign.csig_self)
      in
      let csil = [] in
      let csil =
        List.fold_left
          (fun csil (ty1, ty2) -> Ocsg_constraint (ty1, ty2) :: csil)
          csil (tree_of_constraints params)
      in
      let all_vars =
        Vars.fold (fun l (m, v, t) all -> (l, m, v, t) :: all) sign.csig_vars []
      in
      (* Consequence of PR#3607: order of Map.fold has changed! *)
      let all_vars = List.rev all_vars in
      let csil =
        List.fold_left
          (fun csil (l, m, v, t) ->
            Ocsg_value (l, m = Mutable, v = Virtual, tree_of_typexp sch t)
            :: csil)
          csil all_vars
      in
      let csil =
        List.fold_left (tree_of_metho sch sign.csig_concr) csil fields
      in
      Octy_signature (self_ty, List.rev csil)
  | Cty_arrow (l, ty, cty) ->
      let lab = if !print_labels && l <> "" || is_optional l then l else "" in
      let ty =
       if is_optional l then
         match (repr ty).desc with
         | Tconstr(path, [ty], _) when Path.same path Predef.path_option -> ty
         | _ -> newconstr (Path.Pident(Ident.create "<hidden>")) []
       else ty in
      let tr = tree_of_typexp sch ty in
      Octy_arrow (lab, tr, tree_of_class_type sch params cty)

let class_type ppf cty =
  reset ();
  prepare_class_type [] cty;
  !Oprint.out_class_type ppf (tree_of_class_type false [] cty)

let tree_of_class_param param variance =
  (match tree_of_typexp true param with
    Otyp_var (_, s) -> s
  | _ -> "?"),
  if is_Tvar (repr param) then (true, true) else variance

let tree_of_class_params params =
  let tyl = tree_of_typlist true params in
  List.map (function Otyp_var (_, s) -> s | _ -> "?") tyl

let class_variance =
  List.map Variance.(fun v -> mem May_pos v, mem May_neg v)

let tree_of_class_declaration id cl rs =
  let params = filter_params cl.cty_params in

  reset ();
  List.iter add_alias params;
  prepare_class_type params cl.cty_type;
  let sty = Ctype.self_type cl.cty_type in
  List.iter mark_loops params;

  List.iter check_name_of_type (List.map proxy params);
  if is_aliased sty then check_name_of_type (proxy sty);

  let vir_flag = cl.cty_new = None in
  Osig_class
    (vir_flag, Ident.name id,
     List.map2 tree_of_class_param params (class_variance cl.cty_variance),
     tree_of_class_type true params cl.cty_type,
     tree_of_rec rs)

let class_declaration id ppf cl =
  !Oprint.out_sig_item ppf (tree_of_class_declaration id cl Trec_first)

let tree_of_cltype_declaration id cl rs =
  let params = List.map repr cl.clty_params in

  reset ();
  List.iter add_alias params;
  prepare_class_type params cl.clty_type;
  let sty = Ctype.self_type cl.clty_type in
  List.iter mark_loops params;

  List.iter check_name_of_type (List.map proxy params);
  if is_aliased sty then check_name_of_type (proxy sty);

  let sign = Ctype.signature_of_class_type cl.clty_type in

  let virt =
    let (fields, _) =
      Ctype.flatten_fields (Ctype.object_fields sign.csig_self) in
    List.exists
      (fun (lab, _, ty) ->
         not (lab = dummy_method || Concr.mem lab sign.csig_concr))
      fields
    || Vars.fold (fun _ (_,vr,_) b -> vr = Virtual || b) sign.csig_vars false
  in

  Osig_class_type
    (virt, Ident.name id,
     List.map2 tree_of_class_param params (class_variance cl.clty_variance),
     tree_of_class_type true params cl.clty_type,
     tree_of_rec rs)

let cltype_declaration id ppf cl =
  !Oprint.out_sig_item ppf (tree_of_cltype_declaration id cl Trec_first)

(* Print a module type *)

let wrap_env fenv ftree arg =
  let env = !printing_env in
  set_printing_env (fenv env);
  let tree = ftree arg in
  set_printing_env env;
  tree

let filter_rem_sig item rem =
  match item, rem with
  | Sig_class _, ctydecl :: tydecl1 :: tydecl2 :: rem ->
      ([ctydecl; tydecl1; tydecl2], rem)
  | Sig_class_type _, tydecl1 :: tydecl2 :: rem ->
      ([tydecl1; tydecl2], rem)
  | _ ->
      ([], rem)

let dummy =
  { type_params = []; type_arity = 0; type_kind = Type_abstract;
    type_private = Public; type_manifest = None; type_variance = [];
    type_newtype_level = None; type_loc = Location.none;
    type_attributes = [];
  }

let hide_rec_items = function
  | Sig_type(id, decl, rs) ::rem
    when rs = Trec_first && not !Clflags.real_paths ->
      let rec get_ids = function
          Sig_type (id, _, Trec_next) :: rem ->
            id :: get_ids rem
        | _ -> []
      in
      let ids = id :: get_ids rem in
      set_printing_env
        (List.fold_right
           (fun id -> Env.add_type ~check:false (Ident.rename id) dummy)
           ids !printing_env)
  | _ -> ()

let rec tree_of_modtype = function
  | Mty_ident p ->
      Omty_ident (tree_of_path p)
  | Mty_signature sg ->
      Omty_signature (tree_of_signature sg)
  | Mty_functor(param, ty_arg, ty_res) ->
      let res =
        match ty_arg with None -> tree_of_modtype ty_res
        | Some mty ->
            wrap_env (Env.add_module ~arg:true param mty) tree_of_modtype ty_res
      in
      Omty_functor (Ident.name param, may_map tree_of_modtype ty_arg, res)
  | Mty_alias p ->
      Omty_alias (tree_of_path p)

and tree_of_signature sg =
  wrap_env (fun env -> env) (tree_of_signature_rec !printing_env false) sg

and tree_of_signature_rec env' in_type_group = function
    [] -> []
  | item :: rem ->
      let in_type_group =
        match in_type_group, item with
          true, Sig_type (_, _, Trec_next) -> true
        | _, Sig_type (_, _, (Trec_not | Trec_first)) -> set_printing_env env'; true
        | _ -> set_printing_env env'; false
      in
      let (sg, rem) = filter_rem_sig item rem in
      let trees =
        match item with
        | Sig_value(id, decl) ->
            [tree_of_value_description id decl]
        | Sig_type(id, _, _) when is_row_name (Ident.name id) ->
            []
        | Sig_type(id, decl, rs) ->
            hide_rec_items (item :: rem);
            [Osig_type(tree_of_type_decl id decl, tree_of_rec rs)]
        | Sig_typext(id, ext, es) ->
            [tree_of_extension_constructor id ext es]
        | Sig_module(id, md, rs) ->
            [Osig_module (Ident.name id, tree_of_modtype md.md_type,
                          tree_of_rec rs)]
        | Sig_modtype(id, decl) ->
            [tree_of_modtype_declaration id decl]
        | Sig_class(id, decl, rs) ->
            [tree_of_class_declaration id decl rs]
        | Sig_class_type(id, decl, rs) ->
            [tree_of_cltype_declaration id decl rs]
      in
      let env' = Env.add_signature (item :: sg) env' in
      trees @ tree_of_signature_rec env' in_type_group rem

and tree_of_modtype_declaration id decl =
  let mty =
    match decl.mtd_type with
    | None -> Omty_abstract
    | Some mty -> tree_of_modtype mty
  in
  Osig_modtype (Ident.name id, mty)

let tree_of_module id mty rs =
  Osig_module (Ident.name id, tree_of_modtype mty, tree_of_rec rs)

let modtype ppf mty = !Oprint.out_module_type ppf (tree_of_modtype mty)
let modtype_declaration id ppf decl =
  !Oprint.out_sig_item ppf (tree_of_modtype_declaration id decl)

(* Print a signature body (used by -i when compiling a .ml) *)

let print_signature ppf tree =
  fprintf ppf "@[<v>%a@]" !Oprint.out_signature tree

let signature ppf sg =
  fprintf ppf "%a" print_signature (tree_of_signature sg)

(* Print an unification error *)

let same_path t t' =
  let t = repr t and t' = repr t' in
  t == t' ||
  match t.desc, t'.desc with
    Tconstr(p,tl,_), Tconstr(p',tl',_) ->
      let (p1, s1) = best_type_path p and (p2, s2)  = best_type_path p' in
      begin match s1, s2 with
        Nth n1, Nth n2 when n1 = n2 -> true
      | (Id | Map _), (Id | Map _) when Path.same p1 p2 ->
          let tl = apply_subst s1 tl and tl' = apply_subst s2 tl' in
          List.length tl = List.length tl' &&
          List.for_all2 same_type tl tl'
      | _ -> false
      end
  | _ ->
      false

let type_expansion t ppf t' =
  if same_path t t' then type_expr ppf t else
  let t' = if proxy t == proxy t' then unalias t' else t' in
  fprintf ppf "@[<2>%a@ =@ %a@]" type_expr t type_expr t'

let type_path_expansion tp ppf tp' =
  if Path.same tp tp' then path ppf tp else
  fprintf ppf "@[<2>%a@ =@ %a@]" path tp path tp'

let rec trace fst txt ppf = function
  | (t1, t1') :: (t2, t2') :: rem ->
      if not fst then fprintf ppf "@,";
      fprintf ppf "@[Type@;<1 2>%a@ %s@;<1 2>%a@] %a"
       (type_expansion t1) t1' txt (type_expansion t2) t2'
       (trace false txt) rem
  | _ -> ()

let rec filter_trace keep_last = function
  | (_, t1') :: (_, t2') :: [] when is_Tvar t1' || is_Tvar t2' ->
      []
  | (t1, t1') :: (t2, t2') :: rem ->
      let rem' = filter_trace keep_last rem in
      if is_constr_row t1' || is_constr_row t2'
      || same_path t1 t1' && same_path t2 t2' && not (keep_last && rem' = [])
      then rem'
      else (t1, t1') :: (t2, t2') :: rem'
  | _ -> []

let rec type_path_list ppf = function
  | [tp, tp'] -> type_path_expansion tp ppf tp'
  | (tp, tp') :: rem ->
      fprintf ppf "%a@;<2 0>%a"
        (type_path_expansion tp) tp'
        type_path_list rem
  | [] -> ()

(* Hide variant name and var, to force printing the expanded type *)
let hide_variant_name t =
  match repr t with
  | {desc = Tvariant row} as t when (row_repr row).row_name <> None ->
      newty2 t.level
        (Tvariant {(row_repr row) with row_name = None;
                   row_more = newvar2 (row_more row).level})
  | _ -> t

let prepare_expansion (t, t') =
  let t' = hide_variant_name t' in
  mark_loops t;
  if not (same_path t t') then mark_loops t';
  (t, t')

let may_prepare_expansion compact (t, t') =
  match (repr t').desc with
    Tvariant _ | Tobject _ when compact ->
      mark_loops t; (t, t)
  | _ -> prepare_expansion (t, t')

let print_tags ppf fields =
  match fields with [] -> ()
  | (t, _) :: fields ->
      fprintf ppf "`%s" t;
      List.iter (fun (t, _) -> fprintf ppf ",@ `%s" t) fields

let has_explanation unif t3 t4 =
  match t3.desc, t4.desc with
    Tfield _, (Tnil|Tconstr _) | (Tnil|Tconstr _), Tfield _
  | Tnil, Tconstr _ | Tconstr _, Tnil
  | _, Tvar _ | Tvar _, _
  | Tvariant _, Tvariant _ -> true
  | Tfield (l,_,_,{desc=Tnil}), Tfield (l',_,_,{desc=Tnil}) -> l = l'
  | _ -> false

let rec mismatch unif = function
    (_, t) :: (_, t') :: rem ->
      begin match mismatch unif rem with
        Some _ as m -> m
      | None ->
          if has_explanation unif t t' then Some(t,t') else None
      end
  | [] -> None
  | _ -> assert false

let explanation unif t3 t4 ppf =
  match t3.desc, t4.desc with
  | Ttuple [], Tvar _ | Tvar _, Ttuple [] ->
      fprintf ppf "@,Self type cannot escape its class"
  | Tconstr (p, tl, _), Tvar _
    when unif && t4.level < Path.binding_time p ->
      fprintf ppf
        "@,@[The type constructor@;<1 2>%a@ would escape its scope@]"
        path p
  | Tvar _, Tconstr (p, tl, _)
    when unif && t3.level < Path.binding_time p ->
      fprintf ppf
        "@,@[The type constructor@;<1 2>%a@ would escape its scope@]"
        path p
  | Tvar _, Tunivar _ | Tunivar _, Tvar _ ->
      fprintf ppf "@,The universal variable %a would escape its scope"
        type_expr (if is_Tunivar t3 then t3 else t4)
  | Tvar _, _ | _, Tvar _ ->
      let t, t' = if is_Tvar t3 then (t3, t4) else (t4, t3) in
      if occur_in Env.empty t t' then
        fprintf ppf "@,@[<hov>The type variable %a occurs inside@ %a@]"
          type_expr t type_expr t'
      else
        fprintf ppf "@,@[<hov>This instance of %a is ambiguous:@ %s@]"
          type_expr t'
          "it would escape the scope of its equation"
  | Tfield (lab, _, _, _), _
  | _, Tfield (lab, _, _, _) when lab = dummy_method ->
      fprintf ppf
        "@,Self type cannot be unified with a closed object type"
  | Tfield (l,_,_,{desc=Tnil}), Tfield (l',_,_,{desc=Tnil}) when l = l' ->
      fprintf ppf "@,Types for method %s are incompatible" l
  | (Tnil|Tconstr _), Tfield (l, _, _, _) ->
      fprintf ppf
        "@,@[The first object type has no method %s@]" l
  | Tfield (l, _, _, _), (Tnil|Tconstr _) ->
      fprintf ppf
        "@,@[The second object type has no method %s@]" l
  | Tnil, Tconstr _ | Tconstr _, Tnil ->
      fprintf ppf
        "@,@[The %s object type has an abstract row, it cannot be closed@]"
        (if t4.desc = Tnil then "first" else "second")
  | Tvariant row1, Tvariant row2 ->
      let row1 = row_repr row1 and row2 = row_repr row2 in
      begin match
        row1.row_fields, row1.row_closed, row2.row_fields, row2.row_closed with
      | [], true, [], true ->
          fprintf ppf "@,These two variant types have no intersection"
      | [], true, fields, _ ->
          fprintf ppf
            "@,@[The first variant type does not allow tag(s)@ @[<hov>%a@]@]"
            print_tags fields
      | fields, _, [], true ->
          fprintf ppf
            "@,@[The second variant type does not allow tag(s)@ @[<hov>%a@]@]"
            print_tags fields
      | [l1,_], true, [l2,_], true when l1 = l2 ->
          fprintf ppf "@,Types for tag `%s are incompatible" l1
      | _ -> ()
      end
  | _ -> ()

let explanation unif mis ppf =
  match mis with
    None -> ()
  | Some (t3, t4) -> explanation unif t3 t4 ppf

let ident_same_name id1 id2 =
  if Ident.equal id1 id2 && not (Ident.same id1 id2) then begin
    add_unique id1; add_unique id2
  end

let rec path_same_name p1 p2 =
  match p1, p2 with
    Pident id1, Pident id2 -> ident_same_name id1 id2
  | Pdot (p1, s1, _), Pdot (p2, s2, _) when s1 = s2 -> path_same_name p1 p2
  | Papply (p1, p1'), Papply (p2, p2') ->
      path_same_name p1 p2; path_same_name p1' p2'
  | _ -> ()

let type_same_name t1 t2 =
  match (repr t1).desc, (repr t2).desc with
    Tconstr (p1, _, _), Tconstr (p2, _, _) ->
      path_same_name (fst (best_type_path p1)) (fst (best_type_path p2))
  | _ -> ()

let rec trace_same_names = function
    (t1, t1') :: (t2, t2') :: rem ->
      type_same_name t1 t2; type_same_name t1' t2'; trace_same_names rem
  | _ -> ()

let unification_error unif tr txt1 ppf txt2 =
  reset ();
  trace_same_names tr;
  let tr = List.map (fun (t, t') -> (t, hide_variant_name t')) tr in
  let mis = mismatch unif tr in
  match tr with
  | [] | _ :: [] -> assert false
  | t1 :: t2 :: tr ->
    try
      let tr = filter_trace (mis = None) tr in
      let t1, t1' = may_prepare_expansion (tr = []) t1
      and t2, t2' = may_prepare_expansion (tr = []) t2 in
      print_labels := not !Clflags.classic;
      let tr = List.map prepare_expansion tr in
      fprintf ppf
        "@[<v>\
          @[%t@;<1 2>%a@ \
            %t@;<1 2>%a\
          @]%a%t\
         @]"
        txt1 (type_expansion t1) t1'
        txt2 (type_expansion t2) t2'
        (trace false "is not compatible with type") tr
        (explanation unif mis);
      print_labels := true
    with exn ->
      print_labels := true;
      raise exn

let report_unification_error ppf env ?(unif=true)
    tr txt1 txt2 =
  wrap_printing_env env (fun () -> unification_error unif tr txt1 ppf txt2)
;;


let super_type_expansion ~tag t ppf t' =
  let tag = String_tag tag in
  if same_path t t' then begin
    Format.pp_open_stag ppf tag;
    type_expr ppf t;
    Format.pp_close_stag ppf ();
  end else begin
    let t' = if proxy t == proxy t' then unalias t' else t' in
    fprintf ppf "@[<2>";
    Format.pp_open_stag ppf tag;
    fprintf ppf "%a" type_expr t;
    Format.pp_close_stag ppf ();
    fprintf ppf "@ @{<dim>(defined as@}@ ";
    Format.pp_open_stag ppf tag;
    fprintf ppf "%a" type_expr t';
    Format.pp_close_stag ppf ();
    fprintf ppf "@{<dim>)@}";
    fprintf ppf "@]";
  end

let super_trace ppf =
  let rec super_trace first_report ppf = function
    | (t1, t1') :: (t2, t2') :: rem ->
      fprintf ppf
        "@,@,@[<v 2>";
      if first_report then
        fprintf ppf "The incompatible parts:@,"
      else begin
        fprintf ppf "Further expanded:@,"
      end;
      fprintf ppf
        "@[<v>\
          @[%a@]@,\
          vs@,\
          @[%a@]\
          %a\
        @]"
        (super_type_expansion ~tag:"error" t1) t1'
        (super_type_expansion ~tag:"info" t2) t2'
        (super_trace false) rem;
      fprintf ppf "@]"
    | _ -> ()
  in super_trace true ppf

let super_unification_error unif tr txt1 ppf txt2 = begin
  reset ();
  trace_same_names tr;
  let tr = List.map (fun (t, t') -> (t, hide_variant_name t')) tr in
  let mis = mismatch unif tr in
  match tr with
  | [] | _ :: [] -> assert false
  | t1 :: t2 :: tr ->
    try
      let tr = filter_trace (mis = None) tr in
      let t1, t1' = may_prepare_expansion (tr = []) t1
      and t2, t2' = may_prepare_expansion (tr = []) t2 in
      print_labels := not !Clflags.classic;
      let tr = List.map prepare_expansion tr in
      fprintf ppf
        "@[<v 0>\
          @[<v 2>\
            %t@,\
            @[<2>%a@]\
          @]@,\
          @[<v 2>\
            %t@,\
            @[<2>%a@]\
          @]\
          %a\
          %t\
        @]"
        txt1 (super_type_expansion ~tag:"error" t1) t1'
        txt2 (super_type_expansion ~tag:"info" t2) t2'
        super_trace tr
        (explanation unif mis);
      print_labels := true
    with exn ->
      print_labels := true;
      raise exn
end

let super_report_unification_error ppf env ?(unif=true)
    tr txt1 txt2 =
  wrap_printing_env env (fun () -> super_unification_error unif tr txt1 ppf txt2)
;;


let trace fst keep_last txt ppf tr =
  print_labels := not !Clflags.classic;
  trace_same_names tr;
  try match tr with
    t1 :: t2 :: tr' ->
      if fst then trace fst txt ppf (t1 :: t2 :: filter_trace keep_last tr')
      else trace fst txt ppf (filter_trace keep_last tr);
      print_labels := true
  | _ -> ()
  with exn ->
    print_labels := true;
    raise exn

let report_subtyping_error ppf env tr1 txt1 tr2 =
  wrap_printing_env env (fun () ->
    reset ();
    let tr1 = List.map prepare_expansion tr1
    and tr2 = List.map prepare_expansion tr2 in
    fprintf ppf "@[<v>%a" (trace true (tr2 = []) txt1) tr1;
    if tr2 = [] then fprintf ppf "@]" else
    let mis = mismatch true tr2 in
    fprintf ppf "%a%t@]"
      (trace false (mis = None) "is not compatible with type") tr2
      (explanation true mis))

let report_ambiguous_type_error ppf env (tp0, tp0') tpl txt1 txt2 txt3 =
  wrap_printing_env env (fun () ->
    reset ();
    List.iter
      (fun (tp, tp') -> path_same_name tp0 tp; path_same_name tp0' tp')
      tpl;
    match tpl with
      [] -> assert false
    | [tp, tp'] ->
        fprintf ppf
          "@[%t@;<1 2>%a@ \
             %t@;<1 2>%a\
           @]"
          txt1 (type_path_expansion tp) tp'
          txt3 (type_path_expansion tp0) tp0'
    | _ ->
        fprintf ppf
          "@[%t@;<1 2>@[<hv>%a@]\
             @ %t@;<1 2>%a\
           @]"
          txt2 type_path_list tpl
          txt3 (type_path_expansion tp0) tp0')

end
module Includeclass : sig
(*#1 "includeclass.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*          Jerome Vouillon, projet Cristal, INRIA Rocquencourt        *)
(*                                                                     *)
(*  Copyright 1997 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Inclusion checks for the class language *)

open Types
open Ctype
open Format

val class_types:
        Env.t -> class_type -> class_type -> class_match_failure list
val class_type_declarations:
        Env.t -> class_type_declaration -> class_type_declaration ->
        class_match_failure list
val class_declarations:
        Env.t -> class_declaration -> class_declaration ->
        class_match_failure list

val report_error: formatter -> class_match_failure list -> unit

end = struct
(*#1 "includeclass.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*          Jerome Vouillon, projet Cristal, INRIA Rocquencourt        *)
(*                                                                     *)
(*  Copyright 1997 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Inclusion checks for the class language *)

open Types

let class_types env cty1 cty2 =
  Ctype.match_class_types env cty1 cty2

let class_type_declarations env cty1 cty2 =
  Ctype.match_class_declarations env
    cty1.clty_params cty1.clty_type
    cty2.clty_params cty2.clty_type

let class_declarations env cty1 cty2 =
  match cty1.cty_new, cty2.cty_new with
    None, Some _ ->
      [Ctype.CM_Virtual_class]
  | _ ->
      Ctype.match_class_declarations env
        cty1.cty_params cty1.cty_type
        cty2.cty_params cty2.cty_type

open Format
open Ctype

(*
let rec hide_params = function
    Tcty_arrow ("*", _, cty) -> hide_params cty
  | cty -> cty
*)

let include_err ppf =
  function
  | CM_Virtual_class ->
      fprintf ppf "A class cannot be changed from virtual to concrete"
  | CM_Parameter_arity_mismatch (ls, lp) ->
      fprintf ppf
        "The classes do not have the same number of type parameters"
  | CM_Type_parameter_mismatch (env, trace) ->
      Printtyp.report_unification_error ppf env ~unif:false trace
        (function ppf ->
          fprintf ppf "A type parameter has type")
        (function ppf ->
          fprintf ppf "but is expected to have type")
  | CM_Class_type_mismatch (env, cty1, cty2) ->
      Printtyp.wrap_printing_env env (fun () ->
        fprintf ppf
          "@[The class type@;<1 2>%a@ %s@;<1 2>%a@]"
          Printtyp.class_type cty1
          "is not matched by the class type"
          Printtyp.class_type cty2)
  | CM_Parameter_mismatch (env, trace) ->
      Printtyp.report_unification_error ppf env ~unif:false trace
        (function ppf ->
          fprintf ppf "A parameter has type")
        (function ppf ->
          fprintf ppf "but is expected to have type")
  | CM_Val_type_mismatch (lab, env, trace) ->
      Printtyp.report_unification_error ppf env ~unif:false trace
        (function ppf ->
          fprintf ppf "The instance variable %s@ has type" lab)
        (function ppf ->
          fprintf ppf "but is expected to have type")
  | CM_Meth_type_mismatch (lab, env, trace) ->
      Printtyp.report_unification_error ppf env ~unif:false trace
        (function ppf ->
          fprintf ppf "The method %s@ has type" lab)
        (function ppf ->
          fprintf ppf "but is expected to have type")
  | CM_Non_mutable_value lab ->
      fprintf ppf
       "@[The non-mutable instance variable %s cannot become mutable@]" lab
  | CM_Non_concrete_value lab ->
      fprintf ppf
       "@[The virtual instance variable %s cannot become concrete@]" lab
  | CM_Missing_value lab ->
      fprintf ppf "@[The first class type has no instance variable %s@]" lab
  | CM_Missing_method lab ->
      fprintf ppf "@[The first class type has no method %s@]" lab
  | CM_Hide_public lab ->
     fprintf ppf "@[The public method %s cannot be hidden@]" lab
  | CM_Hide_virtual (k, lab) ->
      fprintf ppf "@[The virtual %s %s cannot be hidden@]" k lab
  | CM_Public_method lab ->
      fprintf ppf "@[The public method %s cannot become private" lab
  | CM_Virtual_method lab ->
      fprintf ppf "@[The virtual method %s cannot become concrete" lab
  | CM_Private_method lab ->
      fprintf ppf "The private method %s cannot become public" lab

let report_error ppf = function
  |  [] -> ()
  | err :: errs ->
      let print_errs ppf errs =
         List.iter (fun err -> fprintf ppf "@ %a" include_err err) errs in
      fprintf ppf "@[<v>%a%a@]" include_err err print_errs errs

end
module Includecore : sig
(*#1 "includecore.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Inclusion checks for the core language *)

open Typedtree
open Types

exception Dont_match

type type_mismatch =
    Arity
  | Privacy
  | Kind
  | Constraint
  | Manifest
  | Variance
  | Field_type of Ident.t
  | Field_mutable of Ident.t
  | Field_arity of Ident.t
  | Field_names of int * Ident.t * Ident.t
  | Field_missing of bool * Ident.t
  | Record_representation of bool

val value_descriptions:
    Env.t -> Ident.t -> value_description -> value_description -> module_coercion
val type_declarations:
    ?equality:bool ->
      Env.t -> string ->
        type_declaration -> Ident.t -> type_declaration -> type_mismatch list
val extension_constructors:
    Env.t -> Ident.t -> extension_constructor -> extension_constructor -> bool
(*
val class_types:
        Env.t -> class_type -> class_type -> bool
*)

val report_type_mismatch:
    string -> string -> string -> Format.formatter -> type_mismatch list -> unit

end = struct
(*#1 "includecore.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Inclusion checks for the core language *)

open Asttypes
open Path
open Types
open Typedtree

(* Inclusion between value descriptions *)

exception Dont_match

let value_descriptions env id vd1 vd2 =
  if Ctype.moregeneral env true vd1.val_type vd2.val_type then begin
    match (vd1.val_kind, vd2.val_kind) with
        (Val_prim p1, Val_prim p2) ->
          if p1 = p2 then Tcoerce_none else raise Dont_match
      | (Val_prim p, _) -> Tcoerce_primitive (id,p)
      | (_, Val_prim p) -> raise Dont_match
      | (_, _) -> Tcoerce_none
  end else
    raise Dont_match

(* Inclusion between "private" annotations *)

let private_flags decl1 decl2 =
  match decl1.type_private, decl2.type_private with
  | Private, Public ->
      decl2.type_kind = Type_abstract &&
      (decl2.type_manifest = None || decl1.type_kind <> Type_abstract)
  | _, _ -> true

(* Inclusion between manifest types (particularly for private row types) *)

let is_absrow env ty =
  match ty.desc with
    Tconstr(Pident id, _, _) ->
      begin match Ctype.expand_head env ty with
        {desc=Tobject _|Tvariant _} -> true
      | _ -> false
      end
  | _ -> false

let type_manifest env ty1 params1 ty2 params2 priv2 =
  let ty1' = Ctype.expand_head env ty1 and ty2' = Ctype.expand_head env ty2 in
  match ty1'.desc, ty2'.desc with
    Tvariant row1, Tvariant row2 when is_absrow env (Btype.row_more row2) ->
      let row1 = Btype.row_repr row1 and row2 = Btype.row_repr row2 in
      Ctype.equal env true (ty1::params1) (row2.row_more::params2) &&
      begin match row1.row_more with
        {desc=Tvar _|Tconstr _|Tnil} -> true
      | _ -> false
      end &&
      let r1, r2, pairs =
        Ctype.merge_row_fields row1.row_fields row2.row_fields in
      (not row2.row_closed ||
       row1.row_closed && Ctype.filter_row_fields false r1 = []) &&
      List.for_all
        (fun (_,f) -> match Btype.row_field_repr f with
          Rabsent | Reither _ -> true | Rpresent _ -> false)
        r2 &&
      let to_equal = ref (List.combine params1 params2) in
      List.for_all
        (fun (_, f1, f2) ->
          match Btype.row_field_repr f1, Btype.row_field_repr f2 with
            Rpresent(Some t1),
            (Rpresent(Some t2) | Reither(false, [t2], _, _)) ->
              to_equal := (t1,t2) :: !to_equal; true
          | Rpresent None, (Rpresent None | Reither(true, [], _, _)) -> true
          | Reither(c1,tl1,_,_), Reither(c2,tl2,_,_)
            when List.length tl1 = List.length tl2 && c1 = c2 ->
              to_equal := List.combine tl1 tl2 @ !to_equal; true
          | Rabsent, (Reither _ | Rabsent) -> true
          | _ -> false)
        pairs &&
      let tl1, tl2 = List.split !to_equal in
      Ctype.equal env true tl1 tl2
  | Tobject (fi1, _), Tobject (fi2, _)
    when is_absrow env (snd(Ctype.flatten_fields fi2)) ->
      let (fields2,rest2) = Ctype.flatten_fields fi2 in
      Ctype.equal env true (ty1::params1) (rest2::params2) &&
      let (fields1,rest1) = Ctype.flatten_fields fi1 in
      (match rest1 with {desc=Tnil|Tvar _|Tconstr _} -> true | _ -> false) &&
      let pairs, miss1, miss2 = Ctype.associate_fields fields1 fields2 in
      miss2 = [] &&
      let tl1, tl2 =
        List.split (List.map (fun (_,_,t1,_,t2) -> t1, t2) pairs) in
      Ctype.equal env true (params1 @ tl1) (params2 @ tl2)
  | _ ->
      let rec check_super ty1 =
        Ctype.equal env true (ty1 :: params1) (ty2 :: params2) ||
        priv2 = Private &&
        try check_super
              (Ctype.try_expand_once_opt env (Ctype.expand_head env ty1))
        with Ctype.Cannot_expand -> false
      in check_super ty1

(* Inclusion between type declarations *)

type type_mismatch =
    Arity
  | Privacy
  | Kind
  | Constraint
  | Manifest
  | Variance
  | Field_type of Ident.t
  | Field_mutable of Ident.t
  | Field_arity of Ident.t
  | Field_names of int * Ident.t * Ident.t
  | Field_missing of bool * Ident.t
  | Record_representation of bool

let report_type_mismatch0 first second decl ppf err =
  let pr fmt = Format.fprintf ppf fmt in
  match err with
    Arity -> pr "They have different arities"
  | Privacy -> pr "A private type would be revealed"
  | Kind -> pr "Their kinds differ"
  | Constraint -> pr "Their constraints differ"
  | Manifest -> ()
  | Variance -> pr "Their variances do not agree"
  | Field_type s ->
      pr "The types for field %s are not equal" (Ident.name s)
  | Field_mutable s ->
      pr "The mutability of field %s is different" (Ident.name s)
  | Field_arity s ->
      pr "The arities for field %s differ" (Ident.name s)
  | Field_names (n, name1, name2) ->
      pr "Fields number %i have different names, %s and %s"
        n (Ident.name name1) (Ident.name name2)
  | Field_missing (b, s) ->
      pr "The field %s is only present in %s %s"
        (Ident.name s) (if b then second else first) decl
  | Record_representation b ->
      pr "Their internal representations differ:@ %s %s %s"
        (if b then second else first) decl
        "uses unboxed float representation"

let report_type_mismatch first second decl ppf =
  List.iter
    (fun err ->
      if err = Manifest then () else
      Format.fprintf ppf "@ %a." (report_type_mismatch0 first second decl) err)

let rec compare_variants env decl1 decl2 n cstrs1 cstrs2 =
  match cstrs1, cstrs2 with
    [], []           -> []
  | [], c::_ -> [Field_missing (true, c.Types.cd_id)]
  | c::_, [] -> [Field_missing (false, c.Types.cd_id)]
  | {Types.cd_id=cstr1; cd_args=arg1; cd_res=ret1}::rem1,
    {Types.cd_id=cstr2; cd_args=arg2; cd_res=ret2}::rem2 ->
      if Ident.name cstr1 <> Ident.name cstr2 then
        [Field_names (n, cstr1, cstr2)]
      else if List.length arg1 <> List.length arg2 then
        [Field_arity cstr1]
      else match ret1, ret2 with
      | Some r1, Some r2 when not (Ctype.equal env true [r1] [r2]) ->
          [Field_type cstr1]
      | Some _, None | None, Some _ ->
          [Field_type cstr1]
      | _ ->
          if Misc.for_all2
              (fun ty1 ty2 ->
                Ctype.equal env true (ty1::decl1.type_params)
                  (ty2::decl2.type_params))
              (arg1) (arg2)
          then
            compare_variants env decl1 decl2 (n+1) rem1 rem2
          else [Field_type cstr1]


let rec compare_records env decl1 decl2 n labels1 labels2 =
  match labels1, labels2 with
    [], []           -> []
  | [], l::_ -> [Field_missing (true, l.ld_id)]
  | l::_, [] -> [Field_missing (false, l.ld_id)]
  | {Types.ld_id=lab1; ld_mutable=mut1; ld_type=arg1}::rem1,
    {Types.ld_id=lab2; ld_mutable=mut2; ld_type=arg2}::rem2 ->
      if Ident.name lab1 <> Ident.name lab2
      then [Field_names (n, lab1, lab2)]
      else if mut1 <> mut2 then [Field_mutable lab1] else
      if Ctype.equal env true (arg1::decl1.type_params)
                              (arg2::decl2.type_params)
      then compare_records env decl1 decl2 (n+1) rem1 rem2
      else [Field_type lab1]

let type_declarations ?(equality = false) env name decl1 id decl2 =
  if decl1.type_arity <> decl2.type_arity then [Arity] else
  if not (private_flags decl1 decl2) then [Privacy] else
  let err = match (decl1.type_kind, decl2.type_kind) with
      (_, Type_abstract) -> []
    | (Type_variant cstrs1, Type_variant cstrs2) ->
        let mark cstrs usage name decl =
          List.iter
            (fun c ->
              Env.mark_constructor_used usage env name decl
                                        (Ident.name c.Types.cd_id))
            cstrs
        in
        let usage =
          if decl1.type_private = Private || decl2.type_private = Public
          then Env.Positive else Env.Privatize
        in
        mark cstrs1 usage name decl1;
        if equality then mark cstrs2 Env.Positive (Ident.name id) decl2;
        compare_variants env decl1 decl2 1 cstrs1 cstrs2
    | (Type_record(labels1,rep1), Type_record(labels2,rep2)) ->
        let err = compare_records env decl1 decl2 1 labels1 labels2 in
        if err <> [] || rep1 = rep2 then err else
        [Record_representation (rep2 = Record_float)]
    | (Type_open, Type_open) -> []
    | (_, _) -> [Kind]
  in
  if err <> [] then err else
  let err = match (decl1.type_manifest, decl2.type_manifest) with
      (_, None) ->
        if Ctype.equal env true decl1.type_params decl2.type_params
        then [] else [Constraint]
    | (Some ty1, Some ty2) ->
        if type_manifest env ty1 decl1.type_params ty2 decl2.type_params
            decl2.type_private
        then [] else [Manifest]
    | (None, Some ty2) ->
        let ty1 =
          Btype.newgenty (Tconstr(Pident id, decl2.type_params, ref Mnil))
        in
        if Ctype.equal env true decl1.type_params decl2.type_params then
          if Ctype.equal env false [ty1] [ty2] then []
          else [Manifest]
        else [Constraint]
  in
  if err <> [] then err else
  let abstr =
    decl2.type_private = Private ||
    decl2.type_kind = Type_abstract && decl2.type_manifest = None in
  let opn = decl2.type_kind = Type_open && decl2.type_manifest = None in
  let constrained ty = not (Btype.(is_Tvar (repr ty))) in
  if List.for_all2
      (fun ty (v1,v2) ->
        let open Variance in
        let imp a b = not a || b in
        let (co1,cn1) = get_upper v1 and (co2,cn2) = get_upper v2 in
        (if abstr then (imp co1 co2 && imp cn1 cn2)
         else if opn || constrained ty then (co1 = co2 && cn1 = cn2)
         else true) &&
        let (p1,n1,i1,j1) = get_lower v1 and (p2,n2,i2,j2) = get_lower v2 in
        imp abstr (imp p2 p1 && imp n2 n1 && imp i2 i1 && imp j2 j1))
      decl2.type_params (List.combine decl1.type_variance decl2.type_variance)
  then [] else [Variance]

(* Inclusion between extension constructors *)

let extension_constructors env id ext1 ext2 =
  let usage =
    if ext1.ext_private = Private || ext2.ext_private = Public
    then Env.Positive else Env.Privatize
  in
  Env.mark_extension_used usage env ext1 (Ident.name id);
  let ty1 =
    Btype.newgenty (Tconstr(ext1.ext_type_path, ext1.ext_type_params, ref Mnil))
  in
  let ty2 =
    Btype.newgenty (Tconstr(ext2.ext_type_path, ext2.ext_type_params, ref Mnil))
  in
  if Ctype.equal env true
       (ty1 :: ext1.ext_type_params)
       (ty2 :: ext2.ext_type_params)
  then
    if List.length ext1.ext_args = List.length ext2.ext_args then
      if match ext1.ext_ret_type, ext2.ext_ret_type with
          Some r1, Some r2 when not (Ctype.equal env true [r1] [r2]) -> false
        | Some _, None | None, Some _ -> false
        | _ ->
            Misc.for_all2
              (fun ty1 ty2 ->
                Ctype.equal env true
                  (ty1 :: ext1.ext_type_params)
                  (ty2 :: ext2.ext_type_params))
              ext1.ext_args ext2.ext_args
      then
        match ext1.ext_private, ext2.ext_private with
            Private, Public -> false
          | _, _ -> true
      else false
    else false
  else false

(* Inclusion between class types *)
let encode_val (mut, ty) rem =
  begin match mut with
    Asttypes.Mutable   -> Predef.type_unit
  | Asttypes.Immutable -> Btype.newgenvar ()
  end
  ::ty::rem

let meths meths1 meths2 =
  Meths.fold
    (fun nam t2 (ml1, ml2) ->
       (begin try
          Meths.find nam meths1 :: ml1
        with Not_found ->
          ml1
        end,
        t2 :: ml2))
    meths2 ([], [])

let vars vars1 vars2 =
  Vars.fold
    (fun lab v2 (vl1, vl2) ->
       (begin try
          encode_val (Vars.find lab vars1) vl1
        with Not_found ->
          vl1
        end,
        encode_val v2 vl2))
    vars2 ([], [])

end
module Mtype : sig
(*#1 "mtype.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Operations on module types *)

open Types

val scrape: Env.t -> module_type -> module_type
        (* Expand toplevel module type abbreviations
           till hitting a "hard" module type (signature, functor,
           or abstract module type ident. *)
val freshen: module_type -> module_type
        (* Return an alpha-equivalent copy of the given module type
           where bound identifiers are fresh. *)
val strengthen: Env.t -> module_type -> Path.t -> module_type
        (* Strengthen abstract type components relative to the
           given path. *)
val strengthen_decl: Env.t -> module_declaration -> Path.t -> module_declaration
val nondep_supertype: Env.t -> Ident.t -> module_type -> module_type
        (* Return the smallest supertype of the given type
           in which the given ident does not appear.
           Raise [Not_found] if no such type exists. *)
val no_code_needed: Env.t -> module_type -> bool
val no_code_needed_sig: Env.t -> signature -> bool
        (* Determine whether a module needs no implementation code,
           i.e. consists only of type definitions. *)
val enrich_modtype: Env.t -> Path.t -> module_type -> module_type
val enrich_typedecl: Env.t -> Path.t -> type_declaration -> type_declaration
val type_paths: Env.t -> Path.t -> module_type -> Path.t list
val contains_type: Env.t -> module_type -> bool
val remove_aliases: Env.t -> module_type -> module_type

end = struct
(*#1 "mtype.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Operations on module types *)

open Asttypes
open Path
open Types


let rec scrape env mty =
  match mty with
    Mty_ident p ->
      begin try
        scrape env (Env.find_modtype_expansion p env)
      with Not_found ->
        mty
      end
  | _ -> mty

let freshen mty =
  Subst.modtype Subst.identity mty

let rec strengthen env mty p =
  match scrape env mty with
    Mty_signature sg ->
      Mty_signature(strengthen_sig env sg p)
  | Mty_functor(param, arg, res)
    when !Clflags.applicative_functors && Ident.name param <> "*" ->
      Mty_functor(param, arg, strengthen env res (Papply(p, Pident param)))
  | mty ->
      mty

and strengthen_sig env sg p =
  match sg with
    [] -> []
  | (Sig_value(id, desc) as sigelt) :: rem ->
      sigelt :: strengthen_sig env rem p
  | Sig_type(id, decl, rs) :: rem ->
      let newdecl =
        match decl.type_manifest, decl.type_private, decl.type_kind with
          Some _, Public, _ -> decl
        | Some _, Private, (Type_record _ | Type_variant _) -> decl
        | _ ->
            let manif =
              Some(Btype.newgenty(Tconstr(Pdot(p, Ident.name id, nopos),
                                          decl.type_params, ref Mnil))) in
            if decl.type_kind = Type_abstract then
              { decl with type_private = Public; type_manifest = manif }
            else
              { decl with type_manifest = manif }
      in
      Sig_type(id, newdecl, rs) :: strengthen_sig env rem p
  | (Sig_typext(id, ext, es) as sigelt) :: rem ->
      sigelt :: strengthen_sig env rem p
  | Sig_module(id, md, rs) :: rem ->
      let str = strengthen_decl env md (Pdot(p, Ident.name id, nopos)) in
      Sig_module(id, str, rs)
      :: strengthen_sig (Env.add_module_declaration id md env) rem p
      (* Need to add the module in case it defines manifest module types *)
  | Sig_modtype(id, decl) :: rem ->
      let newdecl =
        match decl.mtd_type with
          None ->
            {decl with mtd_type = Some(Mty_ident(Pdot(p,Ident.name id,nopos)))}
        | Some _ ->
            decl
      in
      Sig_modtype(id, newdecl) ::
      strengthen_sig (Env.add_modtype id decl env) rem p
      (* Need to add the module type in case it is manifest *)
  | (Sig_class(id, decl, rs) as sigelt) :: rem ->
      sigelt :: strengthen_sig env rem p
  | (Sig_class_type(id, decl, rs) as sigelt) :: rem ->
      sigelt :: strengthen_sig env rem p

and strengthen_decl env md p =
  {md with md_type = strengthen env md.md_type p}

let () = Env.strengthen := strengthen

(* In nondep_supertype, env is only used for the type it assigns to id.
   Hence there is no need to keep env up-to-date by adding the bindings
   traversed. *)

type variance = Co | Contra | Strict

let nondep_supertype env mid mty =

  let rec nondep_mty env va mty =
    match mty with
      Mty_ident p ->
        if Path.isfree mid p then
          nondep_mty env va (Env.find_modtype_expansion p env)
        else mty
    | Mty_alias p ->
        if Path.isfree mid p then
          nondep_mty env va (Env.find_module p env).md_type
        else mty
    | Mty_signature sg ->
        Mty_signature(nondep_sig env va sg)
    | Mty_functor(param, arg, res) ->
        let var_inv =
          match va with Co -> Contra | Contra -> Co | Strict -> Strict in
        Mty_functor(param, Misc.may_map (nondep_mty env var_inv) arg,
                    nondep_mty
                      (Env.add_module ~arg:true param
                         (Btype.default_mty arg) env) va res)

  and nondep_sig env va = function
    [] -> []
  | item :: rem ->
      let rem' = nondep_sig env va rem in
      match item with
        Sig_value(id, d) ->
          Sig_value(id,
                    {d with val_type = Ctype.nondep_type env mid d.val_type})
          :: rem'
      | Sig_type(id, d, rs) ->
          Sig_type(id, Ctype.nondep_type_decl env mid id (va = Co) d, rs)
          :: rem'
      | Sig_typext(id, ext, es) ->
          Sig_typext(id, Ctype.nondep_extension_constructor env mid ext, es)
          :: rem'
      | Sig_module(id, md, rs) ->
          Sig_module(id, {md with md_type=nondep_mty env va md.md_type}, rs)
          :: rem'
      | Sig_modtype(id, d) ->
          begin try
            Sig_modtype(id, nondep_modtype_decl env d) :: rem'
          with Not_found ->
            match va with
              Co -> Sig_modtype(id, {mtd_type=None; mtd_loc=Location.none;
                                     mtd_attributes=[]}) :: rem'
            | _  -> raise Not_found
          end
      | Sig_class(id, d, rs) ->
          Sig_class(id, Ctype.nondep_class_declaration env mid d, rs)
          :: rem'
      | Sig_class_type(id, d, rs) ->
          Sig_class_type(id, Ctype.nondep_cltype_declaration env mid d, rs)
          :: rem'

  and nondep_modtype_decl env mtd =
    {mtd with mtd_type = Misc.may_map (nondep_mty env Strict) mtd.mtd_type}

  in
    nondep_mty env Co mty

let enrich_typedecl env p decl =
  match decl.type_manifest with
    Some ty -> decl
  | None ->
      try
        let orig_decl = Env.find_type p env in
        if orig_decl.type_arity <> decl.type_arity
        then decl
        else {decl with type_manifest =
                Some(Btype.newgenty(Tconstr(p, decl.type_params, ref Mnil)))}
      with Not_found ->
        decl

let rec enrich_modtype env p mty =
  match mty with
    Mty_signature sg ->
      Mty_signature(List.map (enrich_item env p) sg)
  | _ ->
      mty

and enrich_item env p = function
    Sig_type(id, decl, rs) ->
      Sig_type(id,
                enrich_typedecl env (Pdot(p, Ident.name id, nopos)) decl, rs)
  | Sig_module(id, md, rs) ->
      Sig_module(id,
                  {md with
                   md_type = enrich_modtype env
                       (Pdot(p, Ident.name id, nopos)) md.md_type},
                 rs)
  | item -> item

let rec type_paths env p mty =
  match scrape env mty with
    Mty_ident p -> []
  | Mty_alias p -> []
  | Mty_signature sg -> type_paths_sig env p 0 sg
  | Mty_functor(param, arg, res) -> []

and type_paths_sig env p pos sg =
  match sg with
    [] -> []
  | Sig_value(id, decl) :: rem ->
      let pos' = match decl.val_kind with Val_prim _ -> pos | _ -> pos + 1 in
      type_paths_sig env p pos' rem
  | Sig_type(id, decl, _) :: rem ->
      Pdot(p, Ident.name id, nopos) :: type_paths_sig env p pos rem
  | Sig_module(id, md, _) :: rem ->
      type_paths env (Pdot(p, Ident.name id, pos)) md.md_type @
      type_paths_sig (Env.add_module_declaration id md env) p (pos+1) rem
  | Sig_modtype(id, decl) :: rem ->
      type_paths_sig (Env.add_modtype id decl env) p pos rem
  | (Sig_typext _ | Sig_class _) :: rem ->
      type_paths_sig env p (pos+1) rem
  | (Sig_class_type _) :: rem ->
      type_paths_sig env p pos rem

let rec no_code_needed env mty =
  match scrape env mty with
    Mty_ident p -> false
  | Mty_signature sg -> no_code_needed_sig env sg
  | Mty_functor(_, _, _) -> false
  | Mty_alias p -> true

and no_code_needed_sig env sg =
  match sg with
    [] -> true
  | Sig_value(id, decl) :: rem ->
      begin match decl.val_kind with
      | Val_prim _ -> no_code_needed_sig env rem
      | _ -> false
      end
  | Sig_module(id, md, _) :: rem ->
      no_code_needed env md.md_type &&
      no_code_needed_sig (Env.add_module_declaration id md env) rem
  | (Sig_type _ | Sig_modtype _ | Sig_class_type _) :: rem ->
      no_code_needed_sig env rem
  | (Sig_typext _ | Sig_class _) :: rem ->
      false


(* Check whether a module type may return types *)

let rec contains_type env = function
    Mty_ident path ->
      begin try match (Env.find_modtype path env).mtd_type with
      | None -> raise Exit (* PR#6427 *)
      | Some mty -> contains_type env mty
      with Not_found -> raise Exit
      end
  | Mty_signature sg ->
      contains_type_sig env sg
  | Mty_functor (_, _, body) ->
      contains_type env body
  | Mty_alias _ ->
      ()

and contains_type_sig env = List.iter (contains_type_item env)

and contains_type_item env = function
    Sig_type (_,({type_manifest = None} |
                 {type_kind = Type_abstract; type_private = Private}),_)
  | Sig_modtype _ ->
      raise Exit
  | Sig_module (_, {md_type = mty}, _) ->
      contains_type env mty
  | Sig_value _
  | Sig_type _
  | Sig_typext _
  | Sig_class _
  | Sig_class_type _ ->
      ()

let contains_type env mty =
  try contains_type env mty; false with Exit -> true


(* Remove module aliases from a signature *)

module P = struct
  type t = Path.t
  let compare p1 p2 =
    if Path.same p1 p2 then 0 else compare p1 p2
end
module PathSet = Set.Make (P)
module PathMap = Map.Make (P)
module IdentSet = Set.Make (struct type t = Ident.t let compare = compare end)

let rec get_prefixes = function
    Pident _ -> PathSet.empty
  | Pdot (p, _, _)
  | Papply (p, _) -> PathSet.add p (get_prefixes p)

let rec get_arg_paths = function
    Pident _ -> PathSet.empty
  | Pdot (p, _, _) -> get_arg_paths p
  | Papply (p1, p2) ->
      PathSet.add p2
        (PathSet.union (get_prefixes p2)
           (PathSet.union (get_arg_paths p1) (get_arg_paths p2)))

let rec rollback_path subst p =
  try Pident (PathMap.find p subst)
  with Not_found ->
    match p with
      Pident _ | Papply _ -> p
    | Pdot (p1, s, n) ->
        let p1' = rollback_path subst p1 in
        if Path.same p1 p1' then p else rollback_path subst (Pdot (p1', s, n))

let rec collect_ids subst bindings p =
    begin match rollback_path subst p with
      Pident id ->
        let ids =
          try collect_ids subst bindings (Ident.find_same id bindings)
          with Not_found -> IdentSet.empty
        in
        IdentSet.add id ids
    | _ -> IdentSet.empty
    end

let collect_arg_paths mty =
  let open Btype in
  let paths = ref PathSet.empty
  and subst = ref PathMap.empty
  and bindings = ref Ident.empty in
  (* let rt = Ident.create "Root" in
     and prefix = ref (Path.Pident rt) in *)
  let it_path p = paths := PathSet.union (get_arg_paths p) !paths
  and it_signature_item it si =
    type_iterators.it_signature_item it si;
    match si with
      Sig_module (id, {md_type=Mty_alias p}, _) ->
        bindings := Ident.add id p !bindings
    | Sig_module (id, {md_type=Mty_signature sg}, _) ->
        List.iter
          (function Sig_module (id', _, _) ->
              subst :=
                PathMap.add (Pdot (Pident id, Ident.name id', -1)) id' !subst
            | _ -> ())
          sg
    | _ -> ()
  in
  let it = {type_iterators with it_path; it_signature_item} in
  it.it_module_type it mty;
  it.it_module_type unmark_iterators mty;
  PathSet.fold (fun p -> IdentSet.union (collect_ids !subst !bindings p))
    !paths IdentSet.empty

let rec remove_aliases env excl mty =
  match mty with
    Mty_signature sg ->
      Mty_signature (remove_aliases_sig env excl sg)
  | Mty_alias _ ->
      let mty' = Env.scrape_alias env mty in
      if mty' = mty then mty else
      remove_aliases env excl mty'
  | mty ->
      mty

and remove_aliases_sig env excl sg =
  match sg with
    [] -> []
  | Sig_module(id, md, rs) :: rem  ->
      let mty =
        match md.md_type with
          Mty_alias _ when IdentSet.mem id excl ->
            md.md_type
        | mty ->
            remove_aliases env excl mty
      in
      Sig_module(id, {md with md_type = mty} , rs) ::
      remove_aliases_sig (Env.add_module id mty env) excl rem
  | Sig_modtype(id, mtd) :: rem ->
      Sig_modtype(id, mtd) ::
      remove_aliases_sig (Env.add_modtype id mtd env) excl rem
  | it :: rem ->
      it :: remove_aliases_sig env excl rem

let remove_aliases env sg =
  let excl = collect_arg_paths sg in
  (* PathSet.iter (fun p -> Format.eprintf "%a@ " Printtyp.path p) excl;
  Format.eprintf "@."; *)
  remove_aliases env excl sg

end
module Includemod : sig
(*#1 "includemod.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Inclusion checks for the module language *)

open Typedtree
open Types
open Format

val modtypes: Env.t -> module_type -> module_type -> module_coercion
val signatures: Env.t -> signature -> signature -> module_coercion
val compunit:
      Env.t -> string -> signature -> string -> signature -> module_coercion
val type_declarations:
      Env.t -> Ident.t -> type_declaration -> type_declaration -> unit
val print_coercion: formatter -> module_coercion -> unit

type symptom =
    Missing_field of Ident.t * Location.t * string (* kind *)
  | Value_descriptions of Ident.t * value_description * value_description
  | Type_declarations of Ident.t * type_declaration
        * type_declaration * Includecore.type_mismatch list
  | Extension_constructors of
      Ident.t * extension_constructor * extension_constructor
  | Module_types of module_type * module_type
  | Modtype_infos of Ident.t * modtype_declaration * modtype_declaration
  | Modtype_permutation
  | Interface_mismatch of string * string
  | Class_type_declarations of
      Ident.t * class_type_declaration * class_type_declaration *
      Ctype.class_match_failure list
  | Class_declarations of
      Ident.t * class_declaration * class_declaration *
      Ctype.class_match_failure list
  | Unbound_modtype_path of Path.t
  | Unbound_module_path of Path.t
  | Invalid_module_alias of Path.t

type pos =
    Module of Ident.t | Modtype of Ident.t | Arg of Ident.t | Body of Ident.t
type error = pos list * Env.t * symptom

exception Error of error list

val report_error: formatter -> error list -> unit
val expand_module_alias: Env.t -> pos list -> Path.t -> Types.module_type

end = struct
(*#1 "includemod.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Inclusion checks for the module language *)

open Misc
open Path
open Typedtree
open Types

type symptom =
    Missing_field of Ident.t * Location.t * string (* kind *)
  | Value_descriptions of Ident.t * value_description * value_description
  | Type_declarations of Ident.t * type_declaration
        * type_declaration * Includecore.type_mismatch list
  | Extension_constructors of
      Ident.t * extension_constructor * extension_constructor
  | Module_types of module_type * module_type
  | Modtype_infos of Ident.t * modtype_declaration * modtype_declaration
  | Modtype_permutation
  | Interface_mismatch of string * string
  | Class_type_declarations of
      Ident.t * class_type_declaration * class_type_declaration *
      Ctype.class_match_failure list
  | Class_declarations of
      Ident.t * class_declaration * class_declaration *
      Ctype.class_match_failure list
  | Unbound_modtype_path of Path.t
  | Unbound_module_path of Path.t
  | Invalid_module_alias of Path.t

type pos =
    Module of Ident.t | Modtype of Ident.t | Arg of Ident.t | Body of Ident.t
type error = pos list * Env.t * symptom

exception Error of error list

(* All functions "blah env x1 x2" check that x1 is included in x2,
   i.e. that x1 is the type of an implementation that fulfills the
   specification x2. If not, Error is raised with a backtrace of the error. *)

(* Inclusion between value descriptions *)

let value_descriptions env cxt subst id vd1 vd2 =
  Cmt_format.record_value_dependency vd1 vd2;
  Env.mark_value_used env (Ident.name id) vd1;
  let vd2 = Subst.value_description subst vd2 in
  try
    Includecore.value_descriptions env id vd1 vd2
  with Includecore.Dont_match ->
    raise(Error[cxt, env, Value_descriptions(id, vd1, vd2)])

(* Inclusion between type declarations *)

let type_declarations env ?(old_env=env) cxt subst id decl1 decl2 =
  Env.mark_type_used env (Ident.name id) decl1;
  let decl2 = Subst.type_declaration subst decl2 in
  let err = Includecore.type_declarations env (Ident.name id) decl1 id decl2 in
  if err <> [] then
    raise(Error[cxt, old_env, Type_declarations(id, decl1, decl2, err)])

(* Inclusion between extension constructors *)

let extension_constructors env cxt subst id ext1 ext2 =
  let ext2 = Subst.extension_constructor subst ext2 in
  if Includecore.extension_constructors env id ext1 ext2
  then ()
  else raise(Error[cxt, env, Extension_constructors(id, ext1, ext2)])

(* Inclusion between class declarations *)

let class_type_declarations ~old_env env cxt subst id decl1 decl2 =
  let decl2 = Subst.cltype_declaration subst decl2 in
  match Includeclass.class_type_declarations env decl1 decl2 with
    []     -> ()
  | reason ->
      raise(Error[cxt, old_env,
                  Class_type_declarations(id, decl1, decl2, reason)])

let class_declarations ~old_env env cxt subst id decl1 decl2 =
  let decl2 = Subst.class_declaration subst decl2 in
  match Includeclass.class_declarations env decl1 decl2 with
    []     -> ()
  | reason ->
      raise(Error[cxt, old_env, Class_declarations(id, decl1, decl2, reason)])

(* Expand a module type identifier when possible *)

exception Dont_match

let may_expand_module_path env path =
  try ignore (Env.find_modtype_expansion path env); true
  with Not_found -> false

let expand_module_path env cxt path =
  try
    Env.find_modtype_expansion path env
  with Not_found ->
    raise(Error[cxt, env, Unbound_modtype_path path])

let expand_module_alias env cxt path =
  try (Env.find_module path env).md_type
  with Not_found ->
    raise(Error[cxt, env, Unbound_module_path path])

(*
let rec normalize_module_path env cxt path =
  match expand_module_alias env cxt path with
    Mty_alias path' -> normalize_module_path env cxt path'
  | _ -> path
*)

(* Extract name, kind and ident from a signature item *)

type field_desc =
    Field_value of string
  | Field_type of string
  | Field_typext of string
  | Field_module of string
  | Field_modtype of string
  | Field_class of string
  | Field_classtype of string

let kind_of_field_desc = function
  | Field_value _ -> "value"
  | Field_type _ -> "type"
  | Field_typext _ -> "extension constructor"
  | Field_module _ -> "module"
  | Field_modtype _ -> "module type"
  | Field_class _ -> "class"
  | Field_classtype _ -> "class type"

let item_ident_name = function
    Sig_value(id, d) -> (id, d.val_loc, Field_value(Ident.name id))
  | Sig_type(id, d, _) -> (id, d.type_loc, Field_type(Ident.name id))
  | Sig_typext(id, d, _) -> (id, d.ext_loc, Field_typext(Ident.name id))
  | Sig_module(id, d, _) -> (id, d.md_loc, Field_module(Ident.name id))
  | Sig_modtype(id, d) -> (id, d.mtd_loc, Field_modtype(Ident.name id))
  | Sig_class(id, d, _) -> (id, d.cty_loc, Field_class(Ident.name id))
  | Sig_class_type(id, d, _) -> (id, d.clty_loc, Field_classtype(Ident.name id))

let is_runtime_component = function
  | Sig_value(_,{val_kind = Val_prim _})
  | Sig_type(_,_,_)
  | Sig_modtype(_,_)
  | Sig_class_type(_,_,_) -> false
  | Sig_value(_,_)
  | Sig_typext(_,_,_)
  | Sig_module(_,_,_)
  | Sig_class(_, _,_) -> true

(* Print a coercion *)

let rec print_list pr ppf = function
    [] -> ()
  | [a] -> pr ppf a
  | a :: l -> pr ppf a; Format.fprintf ppf ";@ "; print_list pr ppf l
let print_list pr ppf l =
  Format.fprintf ppf "[@[%a@]]" (print_list pr) l

let rec print_coercion ppf c =
  let pr fmt = Format.fprintf ppf fmt in
  match c with
    Tcoerce_none -> pr "id"
  | Tcoerce_structure (fl, nl) ->
      pr "@[<2>struct@ %a@ %a@]"
        (print_list print_coercion2) fl
        (print_list print_coercion3) nl
  | Tcoerce_functor (inp, out) ->
      pr "@[<2>functor@ (%a)@ (%a)@]"
        print_coercion inp
        print_coercion out
  | Tcoerce_primitive (_,pd) ->
      pr "prim %s" pd.Primitive.prim_name
  | Tcoerce_alias (p, c) ->
      pr "@[<2>alias %a@ (%a)@]"
        Printtyp.path p
        print_coercion c
and print_coercion2 ppf (n, c) =
  Format.fprintf ppf "@[%d,@ %a@]" n print_coercion c
and print_coercion3 ppf (i, n, c) =
  Format.fprintf ppf "@[%s, %d,@ %a@]"
    (Ident.unique_name i) n print_coercion c

(* Simplify a structure coercion *)

let simplify_structure_coercion cc id_pos_list =
  let rec is_identity_coercion pos = function
  | [] ->
      true
  | (n, c) :: rem ->
      n = pos && c = Tcoerce_none && is_identity_coercion (pos + 1) rem in
  if is_identity_coercion 0 cc
  then Tcoerce_none
  else Tcoerce_structure (cc, id_pos_list)

(* Inclusion between module types.
   Return the restriction that transforms a value of the smaller type
   into a value of the bigger type. *)

let rec modtypes env cxt subst mty1 mty2 =
  try
    try_modtypes env cxt subst mty1 mty2
  with
    Dont_match ->
      raise(Error[cxt, env, Module_types(mty1, Subst.modtype subst mty2)])
  | Error reasons as err ->
      match mty1, mty2 with
        Mty_alias _, _
      | _, Mty_alias _ -> raise err
      | _ ->
          raise(Error((cxt, env, Module_types(mty1, Subst.modtype subst mty2))
                      :: reasons))

and try_modtypes env cxt subst mty1 mty2 =
  match (mty1, mty2) with
  | (Mty_alias p1, Mty_alias p2) ->
      if Env.is_functor_arg p2 env then
        raise (Error[cxt, env, Invalid_module_alias p2]);
      if Path.same p1 p2 then Tcoerce_none else
      let p1 = Env.normalize_path None env p1
      and p2 = Env.normalize_path None env (Subst.module_path subst p2) in
      (* Should actually be Tcoerce_ignore, if it existed *)
      if Path.same p1 p2 then Tcoerce_none else raise Dont_match
  | (Mty_alias p1, _) ->
      let p1 = try
        Env.normalize_path (Some Location.none) env p1
      with Env.Error (Env.Missing_module (_, _, path)) ->
        raise (Error[cxt, env, Unbound_module_path path])
      in
      let mty1 = Mtype.strengthen env (expand_module_alias env cxt p1) p1 in
      Tcoerce_alias (p1, modtypes env cxt subst mty1 mty2)
  | (Mty_ident p1, _) when may_expand_module_path env p1 ->
      try_modtypes env cxt subst (expand_module_path env cxt p1) mty2
  | (_, Mty_ident p2) ->
      try_modtypes2 env cxt mty1 (Subst.modtype subst mty2)
  | (Mty_signature sig1, Mty_signature sig2) ->
      signatures env cxt subst sig1 sig2
  | (Mty_functor(param1, None, res1), Mty_functor(param2, None, res2)) ->
      begin match modtypes env (Body param1::cxt) subst res1 res2 with
        Tcoerce_none -> Tcoerce_none
      | cc -> Tcoerce_functor (Tcoerce_none, cc)
      end
  | (Mty_functor(param1, Some arg1, res1),
     Mty_functor(param2, Some arg2, res2)) ->
      let arg2' = Subst.modtype subst arg2 in
      let cc_arg = modtypes env (Arg param1::cxt) Subst.identity arg2' arg1 in
      let cc_res =
        modtypes (Env.add_module param1 arg2' env) (Body param1::cxt)
          (Subst.add_module param2 (Pident param1) subst) res1 res2 in
      begin match (cc_arg, cc_res) with
          (Tcoerce_none, Tcoerce_none) -> Tcoerce_none
        | _ -> Tcoerce_functor(cc_arg, cc_res)
      end
  | (_, _) ->
      raise Dont_match

and try_modtypes2 env cxt mty1 mty2 =
  (* mty2 is an identifier *)
  match (mty1, mty2) with
    (Mty_ident p1, Mty_ident p2) when Path.same p1 p2 ->
      Tcoerce_none
  | (_, Mty_ident p2) ->
      try_modtypes env cxt Subst.identity mty1 (expand_module_path env cxt p2)
  | (_, _) ->
      assert false

(* Inclusion between signatures *)

and signatures env cxt subst sig1 sig2 =
  (* Environment used to check inclusion of components *)
  let new_env =
    Env.add_signature sig1 (Env.in_signature env) in
  (* Keep ids for module aliases *)
  let (id_pos_list,_) =
    List.fold_left
      (fun (l,pos) -> function
          Sig_module (id, _, _) ->
            ((id,pos,Tcoerce_none)::l , pos+1)
        | item -> (l, if is_runtime_component item then pos+1 else pos))
      ([], 0) sig1 in
  (* Build a table of the components of sig1, along with their positions.
     The table is indexed by kind and name of component *)
  let rec build_component_table pos tbl = function
      [] -> pos, tbl
    | item :: rem ->
        let (id, _loc, name) = item_ident_name item in
        let nextpos = if is_runtime_component item then pos + 1 else pos in
        build_component_table nextpos
                              (Tbl.add name (id, item, pos) tbl) rem in
  let len1, comps1 =
    build_component_table 0 Tbl.empty sig1 in
  let len2 =
    List.fold_left
      (fun n i -> if is_runtime_component i then n + 1 else n)
      0
      sig2
  in
  (* Pair each component of sig2 with a component of sig1,
     identifying the names along the way.
     Return a coercion list indicating, for all run-time components
     of sig2, the position of the matching run-time components of sig1
     and the coercion to be applied to it. *)
  let rec pair_components subst paired unpaired = function
      [] ->
        begin match unpaired with
            [] ->
              let cc =
                signature_components env new_env cxt subst (List.rev paired)
              in
              if len1 = len2 then (* see PR#5098 *)
                simplify_structure_coercion cc id_pos_list
              else
                Tcoerce_structure (cc, id_pos_list)
          | _  -> raise(Error unpaired)
        end
    | item2 :: rem ->
        let (id2, loc, name2) = item_ident_name item2 in
        let name2, report =
          match item2, name2 with
            Sig_type (_, {type_manifest=None}, _), Field_type s
            when let l = String.length s in
            l >= 4 && String.sub s (l-4) 4 = "#row" ->
              (* Do not report in case of failure,
                 as the main type will generate an error *)
              Field_type (String.sub s 0 (String.length s - 4)), false
          | _ -> name2, true
        in
        begin try
          let (id1, item1, pos1) = Tbl.find name2 comps1 in
          let new_subst =
            match item2 with
              Sig_type _ ->
                Subst.add_type id2 (Pident id1) subst
            | Sig_module _ ->
                Subst.add_module id2 (Pident id1) subst
            | Sig_modtype _ ->
                Subst.add_modtype id2 (Mty_ident (Pident id1)) subst
            | Sig_value _ | Sig_typext _
            | Sig_class _ | Sig_class_type _ ->
                subst
          in
          pair_components new_subst
            ((item1, item2, pos1) :: paired) unpaired rem
        with Not_found ->
          let unpaired =
            if report then
              (cxt, env, Missing_field (id2, loc, kind_of_field_desc name2)) ::
              unpaired
            else unpaired in
          pair_components subst paired unpaired rem
        end in
  (* Do the pairing and checking, and return the final coercion *)
  pair_components subst [] [] sig2

(* Inclusion between signature components *)

and signature_components old_env env cxt subst paired =
  let comps_rec rem = signature_components old_env env cxt subst rem in
  match paired with
    [] -> []
  | (Sig_value(id1, valdecl1), Sig_value(id2, valdecl2), pos) :: rem ->
      let cc = value_descriptions env cxt subst id1 valdecl1 valdecl2 in
      begin match valdecl2.val_kind with
        Val_prim p -> comps_rec rem
      | _ -> (pos, cc) :: comps_rec rem
      end
  | (Sig_type(id1, tydecl1, _), Sig_type(id2, tydecl2, _), pos) :: rem ->
      type_declarations ~old_env env cxt subst id1 tydecl1 tydecl2;
      comps_rec rem
  | (Sig_typext(id1, ext1, _), Sig_typext(id2, ext2, _), pos)
    :: rem ->
      extension_constructors env cxt subst id1 ext1 ext2;
      (pos, Tcoerce_none) :: comps_rec rem
  | (Sig_module(id1, mty1, _), Sig_module(id2, mty2, _), pos) :: rem ->
      let cc =
        modtypes env (Module id1::cxt) subst
          (Mtype.strengthen env mty1.md_type (Pident id1)) mty2.md_type in
      (pos, cc) :: comps_rec rem
  | (Sig_modtype(id1, info1), Sig_modtype(id2, info2), pos) :: rem ->
      modtype_infos env cxt subst id1 info1 info2;
      comps_rec rem
  | (Sig_class(id1, decl1, _), Sig_class(id2, decl2, _), pos) :: rem ->
      class_declarations ~old_env env cxt subst id1 decl1 decl2;
      (pos, Tcoerce_none) :: comps_rec rem
  | (Sig_class_type(id1, info1, _),
     Sig_class_type(id2, info2, _), pos) :: rem ->
      class_type_declarations ~old_env env cxt subst id1 info1 info2;
      comps_rec rem
  | _ ->
      assert false

(* Inclusion between module type specifications *)

and modtype_infos env cxt subst id info1 info2 =
  let info2 = Subst.modtype_declaration subst info2 in
  let cxt' = Modtype id :: cxt in
  try
    match (info1.mtd_type, info2.mtd_type) with
      (None, None) -> ()
    | (Some mty1, None) -> ()
    | (Some mty1, Some mty2) ->
        check_modtype_equiv env cxt' mty1 mty2
    | (None, Some mty2) ->
        check_modtype_equiv env cxt' (Mty_ident(Pident id)) mty2
  with Error reasons ->
    raise(Error((cxt, env, Modtype_infos(id, info1, info2)) :: reasons))

and check_modtype_equiv env cxt mty1 mty2 =
  match
    (modtypes env cxt Subst.identity mty1 mty2,
     modtypes env cxt Subst.identity mty2 mty1)
  with
    (Tcoerce_none, Tcoerce_none) -> ()
  | (_, _) -> raise(Error [cxt, env, Modtype_permutation])

(* Simplified inclusion check between module types (for Env) *)

let check_modtype_inclusion env mty1 path1 mty2 =
  try
    ignore(modtypes env [] Subst.identity
                    (Mtype.strengthen env mty1 path1) mty2)
  with Error reasons ->
    raise Not_found

let _ = Env.check_modtype_inclusion := check_modtype_inclusion

(* Check that an implementation of a compilation unit meets its
   interface. *)

let compunit env impl_name impl_sig intf_name intf_sig =
  try
    signatures env [] Subst.identity impl_sig intf_sig
  with Error reasons ->
    raise(Error(([], Env.empty,Interface_mismatch(impl_name, intf_name))
                :: reasons))

(* Hide the context and substitution parameters to the outside world *)

let modtypes env mty1 mty2 = modtypes env [] Subst.identity mty1 mty2
let signatures env sig1 sig2 = signatures env [] Subst.identity sig1 sig2
let type_declarations env id decl1 decl2 =
  type_declarations env [] Subst.identity id decl1 decl2

(*
let modtypes env m1 m2 =
  let c = modtypes env m1 m2 in
  Format.eprintf "@[<2>modtypes@ %a@ %a =@ %a@]@."
    Printtyp.modtype m1 Printtyp.modtype m2
    print_coercion c;
  c
*)

(* Error report *)

open Format
open Printtyp

let show_loc msg ppf loc =
  let pos = loc.Location.loc_start in
  if List.mem pos.Lexing.pos_fname [""; "_none_"; "//toplevel//"] then ()
  else fprintf ppf "@\n@[<2>%a:@ %s@]" Location.print_loc loc msg

let show_locs ppf (loc1, loc2) =
  show_loc "Expected declaration" ppf loc2;
  show_loc "Actual declaration" ppf loc1

let include_err ppf = function
  | Missing_field (id, loc, kind) ->
      fprintf ppf "The %s `%a' is required but not provided" kind ident id;
      show_loc "Expected declaration" ppf loc
  | Value_descriptions(id, d1, d2) ->
      fprintf ppf
        "@[<hv 2>Values do not match:@ %a@;<1 -2>is not included in@ %a@]"
        (value_description id) d1 (value_description id) d2;
      show_locs ppf (d1.val_loc, d2.val_loc);
  | Type_declarations(id, d1, d2, errs) ->
      fprintf ppf "@[<v>@[<hv>%s:@;<1 2>%a@ %s@;<1 2>%a@]%a%a@]"
        "Type declarations do not match"
        (type_declaration id) d1
        "is not included in"
        (type_declaration id) d2
        show_locs (d1.type_loc, d2.type_loc)
        (Includecore.report_type_mismatch
           "the first" "the second" "declaration") errs
  | Extension_constructors(id, x1, x2) ->
      fprintf ppf
       "@[<hv 2>Extension declarations do not match:@ \
        %a@;<1 -2>is not included in@ %a@]"
      (extension_constructor id) x1
      (extension_constructor id) x2;
      show_locs ppf (x1.ext_loc, x2.ext_loc)
  | Module_types(mty1, mty2)->
      fprintf ppf
       "@[<hv 2>Modules do not match:@ \
        %a@;<1 -2>is not included in@ %a@]"
      modtype mty1
      modtype mty2
  | Modtype_infos(id, d1, d2) ->
      fprintf ppf
       "@[<hv 2>Module type declarations do not match:@ \
        %a@;<1 -2>does not match@ %a@]"
      (modtype_declaration id) d1
      (modtype_declaration id) d2
  | Modtype_permutation ->
      fprintf ppf "Illegal permutation of structure fields"
  | Interface_mismatch(impl_name, intf_name) ->
      fprintf ppf "@[The implementation %s@ does not match the interface %s:"
       impl_name intf_name
  | Class_type_declarations(id, d1, d2, reason) ->
      fprintf ppf
       "@[<hv 2>Class type declarations do not match:@ \
        %a@;<1 -2>does not match@ %a@]@ %a"
      (Printtyp.cltype_declaration id) d1
      (Printtyp.cltype_declaration id) d2
      Includeclass.report_error reason
  | Class_declarations(id, d1, d2, reason) ->
      fprintf ppf
       "@[<hv 2>Class declarations do not match:@ \
        %a@;<1 -2>does not match@ %a@]@ %a"
      (Printtyp.class_declaration id) d1
      (Printtyp.class_declaration id) d2
      Includeclass.report_error reason
  | Unbound_modtype_path path ->
      fprintf ppf "Unbound module type %a" Printtyp.path path
  | Unbound_module_path path ->
      fprintf ppf "Unbound module %a" Printtyp.path path
  | Invalid_module_alias path ->
      fprintf ppf "Module %a cannot be aliased" Printtyp.path path

let rec context ppf = function
    Module id :: rem ->
      fprintf ppf "@[<2>module %a%a@]" ident id args rem
  | Modtype id :: rem ->
      fprintf ppf "@[<2>module type %a =@ %a@]" ident id context_mty rem
  | Body x :: rem ->
      fprintf ppf "functor (%s) ->@ %a" (argname x) context_mty rem
  | Arg x :: rem ->
      fprintf ppf "functor (%a : %a) -> ..." ident x context_mty rem
  | [] ->
      fprintf ppf "<here>"
and context_mty ppf = function
    (Module _ | Modtype _) :: _ as rem ->
      fprintf ppf "@[<2>sig@ %a@;<1 -2>end@]" context rem
  | cxt -> context ppf cxt
and args ppf = function
    Body x :: rem ->
      fprintf ppf "(%s)%a" (argname x) args rem
  | Arg x :: rem ->
      fprintf ppf "(%a :@ %a) : ..." ident x context_mty rem
  | cxt ->
      fprintf ppf " :@ %a" context_mty cxt
and argname x =
  let s = Ident.name x in
  if s = "*" then "" else s

let path_of_context = function
    Module id :: rem ->
      let rec subm path = function
          [] -> path
        | Module id :: rem -> subm (Pdot (path, Ident.name id, -1)) rem
        | _ -> assert false
      in subm (Pident id) rem
  | _ -> assert false

let context ppf cxt =
  if cxt = [] then () else
  if List.for_all (function Module _ -> true | _ -> false) cxt then
    fprintf ppf "In module %a:@ " path (path_of_context cxt)
  else
    fprintf ppf "@[<hv 2>At position@ %a@]@ " context cxt

let include_err ppf (cxt, env, err) =
  Printtyp.wrap_printing_env env (fun () ->
    fprintf ppf "@[<v>%a%a@]" context (List.rev cxt) include_err err)

let buffer = ref Bytes.empty
let is_big obj =
  let size = !Clflags.error_size in
  size > 0 &&
  begin
    if Bytes.length !buffer < size then buffer := Bytes.create size;
    try ignore (Marshal.to_buffer !buffer 0 size obj []); false
    with _ -> true
  end

let report_error ppf errs =
  if errs = [] then () else
  let (errs , err) = split_last errs in
  let pe = ref true in
  let include_err' ppf (_,_,obj as err) =
    if not (is_big obj) then fprintf ppf "%a@ " include_err err
    else if !pe then (fprintf ppf "...@ "; pe := false)
  in
  let print_errs ppf = List.iter (include_err' ppf) in
  fprintf ppf "@[<v>%a%a@]" print_errs errs include_err err


(* We could do a better job to split the individual error items
   as sub-messages of the main interface mismatch on the whole unit. *)
let () =
  Location.register_error_of_exn
    (function
      | Error err -> Some (Location.error_of_printer_file report_error err)
      | _ -> None
    )

end
module Stypes : sig
(*#1 "stypes.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*          Damien Doligez, projet Moscova, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 2003 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Recording and dumping (partial) type information *)

(* Clflags.save_types must be true *)

open Typedtree;;

type annotation =
  | Ti_pat   of pattern
  | Ti_expr  of expression
  | Ti_class of class_expr
  | Ti_mod   of module_expr
  | An_call of Location.t * Annot.call
  | An_ident of Location.t * string * Annot.ident
;;

val record : annotation -> unit;;
val record_phrase : Location.t -> unit;;
val dump : string option -> unit;;

val get_location : annotation -> Location.t;;
val get_info : unit -> annotation list;;

end = struct
(*#1 "stypes.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*          Damien Doligez, projet Moscova, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 2003 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Recording and dumping (partial) type information *)

(*
  We record all types in a list as they are created.
  This means we can dump type information even if type inference fails,
  which is extremely important, since type information is most
  interesting in case of errors.
*)

open Annot;;
open Lexing;;
open Location;;
open Typedtree;;

let output_int oc i = output_string oc (string_of_int i)

type annotation =
  | Ti_pat   of pattern
  | Ti_expr  of expression
  | Ti_class of class_expr
  | Ti_mod   of module_expr
  | An_call of Location.t * Annot.call
  | An_ident of Location.t * string * Annot.ident
;;

let get_location ti =
  match ti with
    Ti_pat p   -> p.pat_loc
  | Ti_expr e  -> e.exp_loc
  | Ti_class c -> c.cl_loc
  | Ti_mod m   -> m.mod_loc
  | An_call (l, k) -> l
  | An_ident (l, s, k) -> l
;;

let annotations = ref ([] : annotation list);;
let phrases = ref ([] : Location.t list);;

let record ti =
  if !Clflags.annotations && not (get_location ti).Location.loc_ghost then
    annotations := ti :: !annotations
;;

let record_phrase loc =
  if !Clflags.annotations then phrases := loc :: !phrases;
;;

(* comparison order:
   the intervals are sorted by order of increasing upper bound
   same upper bound -> sorted by decreasing lower bound
*)
let cmp_loc_inner_first loc1 loc2 =
  match compare loc1.loc_end.pos_cnum loc2.loc_end.pos_cnum with
  | 0 -> compare loc2.loc_start.pos_cnum loc1.loc_start.pos_cnum
  | x -> x
;;
let cmp_ti_inner_first ti1 ti2 =
  cmp_loc_inner_first (get_location ti1) (get_location ti2)
;;

let print_position pp pos =
  if pos = dummy_pos then
    output_string pp "--"
  else begin
    output_char pp '\"';
    output_string pp (String.escaped pos.pos_fname);
    output_string pp "\" ";
    output_int pp pos.pos_lnum;
    output_char pp ' ';
    output_int pp pos.pos_bol;
    output_char pp ' ';
    output_int pp pos.pos_cnum;
  end
;;

let print_location pp loc =
  print_position pp loc.loc_start;
  output_char pp ' ';
  print_position pp loc.loc_end;
;;

let sort_filter_phrases () =
  let ph = List.sort (fun x y -> cmp_loc_inner_first y x) !phrases in
  let rec loop accu cur l =
    match l with
    | [] -> accu
    | loc :: t ->
       if cur.loc_start.pos_cnum <= loc.loc_start.pos_cnum
          && cur.loc_end.pos_cnum >= loc.loc_end.pos_cnum
       then loop accu cur t
       else loop (loc :: accu) loc t
  in
  phrases := loop [] Location.none ph;
;;

let rec printtyp_reset_maybe loc =
  match !phrases with
  | cur :: t when cur.loc_start.pos_cnum <= loc.loc_start.pos_cnum ->
     Printtyp.reset ();
     phrases := t;
     printtyp_reset_maybe loc;
  | _ -> ()
;;

let call_kind_string k =
  match k with
  | Tail -> "tail"
  | Stack -> "stack"
  | Inline -> "inline"
;;

let print_ident_annot pp str k =
  match k with
  | Idef l ->
      output_string pp "def ";
      output_string pp str;
      output_char pp ' ';
      print_location pp l;
      output_char pp '\n'
  | Iref_internal l ->
      output_string pp "int_ref ";
      output_string pp str;
      output_char pp ' ';
      print_location pp l;
      output_char pp '\n'
  | Iref_external ->
      output_string pp "ext_ref ";
      output_string pp str;
      output_char pp '\n'
;;

(* The format of the annotation file is documented in emacs/caml-types.el. *)

let print_info pp prev_loc ti =
  match ti with
  | Ti_class _ | Ti_mod _ -> prev_loc
  | Ti_pat  {pat_loc = loc; pat_type = typ; pat_env = env}
  | Ti_expr {exp_loc = loc; exp_type = typ; exp_env = env} ->
      if loc <> prev_loc then begin
        print_location pp loc;
        output_char pp '\n'
      end;
      output_string pp "type(\n";
      printtyp_reset_maybe loc;
      Printtyp.mark_loops typ;
      Format.pp_print_string Format.str_formatter "  ";
      Printtyp.wrap_printing_env env
                       (fun () -> Printtyp.type_sch Format.str_formatter typ);
      Format.pp_print_newline Format.str_formatter ();
      let s = Format.flush_str_formatter () in
      output_string pp s;
      output_string pp ")\n";
      loc
  | An_call (loc, k) ->
      if loc <> prev_loc then begin
        print_location pp loc;
        output_char pp '\n'
      end;
      output_string pp "call(\n  ";
      output_string pp (call_kind_string k);
      output_string pp "\n)\n";
      loc
  | An_ident (loc, str, k) ->
      if loc <> prev_loc then begin
        print_location pp loc;
        output_char pp '\n'
      end;
      output_string pp "ident(\n  ";
      print_ident_annot pp str k;
      output_string pp ")\n";
      loc
;;

let get_info () =
  let info = List.fast_sort cmp_ti_inner_first !annotations in
  annotations := [];
  info
;;

let dump filename =
  if !Clflags.annotations then begin
    let info = get_info () in
    let pp =
      match filename with
          None -> stdout
        | Some filename -> open_out filename in
    sort_filter_phrases ();
    ignore (List.fold_left (print_info pp) Location.none info);
    begin match filename with
    | None -> ()
    | Some _ -> close_out pp
    end;
    phrases := [];
  end else begin
    annotations := [];
  end;
;;

end
module Parmatch : sig
(*#1 "parmatch.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Detection of partial matches and unused match cases. *)
open Asttypes
open Typedtree
open Types

val pretty_const : constant -> string
val top_pretty : Format.formatter -> pattern -> unit
val pretty_pat : pattern -> unit
val pretty_line : pattern list -> unit
val pretty_matrix : pattern list list -> unit

val omega : pattern
val omegas : int -> pattern list
val omega_list : 'a list -> pattern list
val normalize_pat : pattern -> pattern
val all_record_args :
    (Longident.t loc * label_description * pattern) list ->
    (Longident.t loc * label_description * pattern) list
val const_compare : constant -> constant -> int

val le_pat : pattern -> pattern -> bool
val le_pats : pattern list -> pattern list -> bool
val compat : pattern -> pattern -> bool
val compats : pattern list -> pattern list -> bool
exception Empty
val lub : pattern -> pattern -> pattern
val lubs : pattern list -> pattern list -> pattern list

val get_mins : ('a -> 'a -> bool) -> 'a list -> 'a list

(* Those two functions recombine one pattern and its arguments:
   For instance:
     (_,_)::p1::p2::rem -> (p1, p2)::rem
   The second one will replace mutable arguments by '_'
*)
val set_args : pattern -> pattern list -> pattern list
val set_args_erase_mutable : pattern -> pattern list -> pattern list

val pat_of_constr : pattern -> constructor_description -> pattern
val complete_constrs :
    pattern -> constructor_tag list -> constructor_description  list

val pressure_variants: Env.t -> pattern list -> unit
val check_partial_gadt:
    ((string, constructor_description) Hashtbl.t ->
     (string, label_description) Hashtbl.t ->
     Parsetree.pattern -> pattern option) ->
    Location.t -> case list -> partial
val check_unused: Env.t -> case list -> unit

(* Irrefutability tests *)
val irrefutable : pattern -> bool
val fluid : pattern -> bool

end = struct
(*#1 "parmatch.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Detection of partial matches and unused match cases. *)

open Misc
open Asttypes
open Types
open Typedtree

(*************************************)
(* Utilities for building patterns   *)
(*************************************)

let make_pat desc ty tenv =
  {pat_desc = desc; pat_loc = Location.none; pat_extra = [];
   pat_type = ty ; pat_env = tenv;
   pat_attributes = [];
  }

let omega = make_pat Tpat_any Ctype.none Env.empty

let extra_pat =
  make_pat
    (Tpat_var (Ident.create "+", mknoloc "+"))
    Ctype.none Env.empty

let rec omegas i =
  if i <= 0 then [] else omega :: omegas (i-1)

let omega_list l = List.map (fun _ -> omega) l

let zero = make_pat (Tpat_constant (Const_int 0)) Ctype.none Env.empty

(***********************)
(* Compatibility check *)
(***********************)

(* p and q compatible means, there exists V that matches both *)

let is_absent tag row = Btype.row_field tag !row = Rabsent

let is_absent_pat p = match p.pat_desc with
| Tpat_variant (tag, _, row) -> is_absent tag row
| _ -> false

let const_compare x y =
  match x,y with
  | Const_float f1, Const_float f2 ->
      Stdlib.compare (float_of_string f1) (float_of_string f2)
  | Const_string (s1, _), Const_string (s2, _) ->
      String.compare s1 s2
  | _, _ -> Stdlib.compare x y

let records_args l1 l2 =
  (* Invariant: fields are already sorted by Typecore.type_label_a_list *)
  let rec combine r1 r2 l1 l2 = match l1,l2 with
  | [],[] -> List.rev r1, List.rev r2
  | [],(_,_,p2)::rem2 -> combine (omega::r1) (p2::r2) [] rem2
  | (_,_,p1)::rem1,[] -> combine (p1::r1) (omega::r2) rem1 []
  | (_,lbl1,p1)::rem1, ( _,lbl2,p2)::rem2 ->
      if lbl1.lbl_pos < lbl2.lbl_pos then
        combine (p1::r1) (omega::r2) rem1 l2
      else if lbl1.lbl_pos > lbl2.lbl_pos then
        combine (omega::r1) (p2::r2) l1 rem2
      else (* same label on both sides *)
        combine (p1::r1) (p2::r2) rem1 rem2 in
  combine [] [] l1 l2


let rec compat p q =
  match p.pat_desc,q.pat_desc with
  | Tpat_alias (p,_,_),_      -> compat p q
  | _,Tpat_alias (q,_,_)      -> compat p q
  | (Tpat_any|Tpat_var _),_ -> true
  | _,(Tpat_any|Tpat_var _) -> true
  | Tpat_or (p1,p2,_),_     -> compat p1 q || compat p2 q
  | _,Tpat_or (q1,q2,_)     -> compat p q1 || compat p q2
  | Tpat_constant c1, Tpat_constant c2 -> const_compare c1 c2 = 0
  | Tpat_tuple ps, Tpat_tuple qs -> compats ps qs
  | Tpat_lazy p, Tpat_lazy q -> compat p q
  | Tpat_construct (_, c1,ps1), Tpat_construct (_, c2,ps2) ->
      Types.equal_tag c1.cstr_tag  c2.cstr_tag && compats ps1 ps2
  | Tpat_variant(l1,Some p1, r1), Tpat_variant(l2,Some p2,_) ->
      l1=l2 && compat p1 p2
  | Tpat_variant (l1,None,r1), Tpat_variant(l2,None,_) ->
      l1 = l2
  | Tpat_variant (_, None, _), Tpat_variant (_,Some _, _) -> false
  | Tpat_variant (_, Some _, _), Tpat_variant (_, None, _) -> false
  | Tpat_record (l1,_),Tpat_record (l2,_) ->
      let ps,qs = records_args l1 l2 in
      compats ps qs
  | Tpat_array ps, Tpat_array qs ->
      List.length ps = List.length qs &&
      compats ps qs
  | _,_  ->
      assert false

and compats ps qs = match ps,qs with
| [], [] -> true
| p::ps, q::qs -> compat p q && compats ps qs
| _,_    -> assert false

exception Empty (* Empty pattern *)

(****************************************)
(* Utilities for retrieving type paths  *)
(****************************************)

(* May need a clean copy, cf. PR#4745 *)
let clean_copy ty =
  if ty.level = Btype.generic_level then ty
  else Subst.type_expr Subst.identity ty

let get_type_path ty tenv =
  let ty = Ctype.repr (Ctype.expand_head tenv (clean_copy ty)) in
  match ty.desc with
  | Tconstr (path,_,_) -> path
  | _ -> fatal_error "Parmatch.get_type_path"

(*************************************)
(* Values as patterns pretty printer *)
(*************************************)

open Format
;;

let is_cons = function
| {cstr_name = "::"} -> true
| _ -> false

let pretty_const c = match c with
| Const_int i -> Printf.sprintf "%d" i
| Const_char c -> Printf.sprintf "%C" c
| Const_string (s, _) -> Printf.sprintf "%S" s
| Const_float f -> Printf.sprintf "%s" f
| Const_int32 i -> Printf.sprintf "%ldl" i
| Const_int64 i -> Printf.sprintf "%LdL" i
| Const_nativeint i -> Printf.sprintf "%ndn" i

let rec pretty_val ppf v =
  match v.pat_extra with
      (cstr, _loc, _attrs) :: rem ->
        begin match cstr with
          | Tpat_unpack ->
            fprintf ppf "@[(module %a)@]" pretty_val { v with pat_extra = rem }
          | Tpat_constraint ctyp ->
            fprintf ppf "@[(%a : _)@]" pretty_val { v with pat_extra = rem }
          | Tpat_type _ ->
            fprintf ppf "@[(# %a)@]" pretty_val { v with pat_extra = rem }
        end
    | [] ->
  match v.pat_desc with
  | Tpat_any -> fprintf ppf "_"
  | Tpat_var (x,_) -> Ident.print ppf x
  | Tpat_constant c -> fprintf ppf "%s" (pretty_const c)
  | Tpat_tuple vs ->
      fprintf ppf "@[(%a)@]" (pretty_vals ",") vs
  | Tpat_construct (_, cstr, []) ->
      fprintf ppf "%s" cstr.cstr_name
  | Tpat_construct (_, cstr, [w]) ->
      fprintf ppf "@[<2>%s@ %a@]" cstr.cstr_name pretty_arg w
  | Tpat_construct (_, cstr, vs) ->
      let name = cstr.cstr_name in
      begin match (name, vs) with
        ("::", [v1;v2]) ->
          fprintf ppf "@[%a::@,%a@]" pretty_car v1 pretty_cdr v2
      |  _ ->
          fprintf ppf "@[<2>%s@ @[(%a)@]@]" name (pretty_vals ",") vs
      end
  | Tpat_variant (l, None, _) ->
      fprintf ppf "`%s" l
  | Tpat_variant (l, Some w, _) ->
      fprintf ppf "@[<2>`%s@ %a@]" l pretty_arg w
  | Tpat_record (lvs,_) ->
      fprintf ppf "@[{%a}@]"
        pretty_lvals
        (List.filter
           (function
             | (_,_,{pat_desc=Tpat_any}) -> false (* do not show lbl=_ *)
             | _ -> true) lvs)
  | Tpat_array vs ->
      fprintf ppf "@[[| %a |]@]" (pretty_vals " ;") vs
  | Tpat_lazy v ->
      fprintf ppf "@[<2>lazy@ %a@]" pretty_arg v
  | Tpat_alias (v, x,_) ->
      fprintf ppf "@[(%a@ as %a)@]" pretty_val v Ident.print x
  | Tpat_or (v,w,_)    ->
      fprintf ppf "@[(%a|@,%a)@]" pretty_or v pretty_or w

and pretty_car ppf v = match v.pat_desc with
| Tpat_construct (_,cstr, [_ ; _])
    when is_cons cstr ->
      fprintf ppf "(%a)" pretty_val v
| _ -> pretty_val ppf v

and pretty_cdr ppf v = match v.pat_desc with
| Tpat_construct (_,cstr, [v1 ; v2])
    when is_cons cstr ->
      fprintf ppf "%a::@,%a" pretty_car v1 pretty_cdr v2
| _ -> pretty_val ppf v

and pretty_arg ppf v = match v.pat_desc with
| Tpat_construct (_,_,_::_)
| Tpat_variant (_, Some _, _) -> fprintf ppf "(%a)" pretty_val v
|  _ -> pretty_val ppf v

and pretty_or ppf v = match v.pat_desc with
| Tpat_or (v,w,_) ->
    fprintf ppf "%a|@,%a" pretty_or v pretty_or w
| _ -> pretty_val ppf v

and pretty_vals sep ppf = function
  | [] -> ()
  | [v] -> pretty_val ppf v
  | v::vs ->
      fprintf ppf "%a%s@ %a" pretty_val v sep (pretty_vals sep) vs

and pretty_lvals ppf = function
  | [] -> ()
  | [_,lbl,v] ->
      fprintf ppf "%s=%a" lbl.lbl_name pretty_val v
  | (_, lbl,v)::rest ->
      fprintf ppf "%s=%a;@ %a"
        lbl.lbl_name pretty_val v pretty_lvals rest

let top_pretty ppf v =
  fprintf ppf "@[%a@]@?" pretty_val v


let pretty_pat p =
  top_pretty Format.str_formatter p ;
  prerr_string (Format.flush_str_formatter ())

type matrix = pattern list list

let pretty_line ps =
  List.iter
    (fun p ->
      top_pretty Format.str_formatter p ;
      prerr_string " <" ;
      prerr_string (Format.flush_str_formatter ()) ;
      prerr_string ">")
    ps

let pretty_matrix (pss : matrix) =
  prerr_endline "begin matrix" ;
  List.iter
    (fun ps ->
      pretty_line ps ;
      prerr_endline "")
    pss ;
  prerr_endline "end matrix"


(****************************)
(* Utilities for matching   *)
(****************************)

(* Check top matching *)
let simple_match p1 p2 =
  match p1.pat_desc, p2.pat_desc with
  | Tpat_construct(_, c1, _), Tpat_construct(_, c2, _) ->
      Types.equal_tag c1.cstr_tag c2.cstr_tag
  | Tpat_variant(l1, _, _), Tpat_variant(l2, _, _) ->
      l1 = l2
  | Tpat_constant(c1), Tpat_constant(c2) -> const_compare c1 c2 = 0
  | Tpat_tuple _, Tpat_tuple _ -> true
  | Tpat_lazy _, Tpat_lazy _ -> true
  | Tpat_record _ , Tpat_record _ -> true
  | Tpat_array p1s, Tpat_array p2s -> List.length p1s = List.length p2s
  | _, (Tpat_any | Tpat_var(_)) -> true
  | _, _ -> false




(* extract record fields as a whole *)
let record_arg p = match p.pat_desc with
| Tpat_any -> []
| Tpat_record (args,_) -> args
| _ -> fatal_error "Parmatch.as_record"


(* Raise Not_found when pos is not present in arg *)
let get_field pos arg =
  let _,_, p = List.find (fun (_,lbl,_) -> pos = lbl.lbl_pos) arg in
  p

let extract_fields omegas arg =
  List.map
    (fun (_,lbl,_) ->
      try
        get_field lbl.lbl_pos arg
      with Not_found -> omega)
    omegas

let all_record_args lbls = match lbls with
| (_,{lbl_all=lbl_all},_)::_ ->
    let t =
      Array.map
        (fun lbl -> mknoloc (Longident.Lident "?temp?"), lbl,omega)
        lbl_all in
    List.iter
      (fun ((_, lbl,_) as x) ->  t.(lbl.lbl_pos) <- x)
      lbls ;
    Array.to_list t
|  _ -> fatal_error "Parmatch.all_record_args"


(* Build argument list when p2 >= p1, where p1 is a simple pattern *)
let rec simple_match_args p1 p2 = match p2.pat_desc with
| Tpat_alias (p2,_,_) -> simple_match_args p1 p2
| Tpat_construct(_, cstr, args) -> args
| Tpat_variant(lab, Some arg, _) -> [arg]
| Tpat_tuple(args)  -> args
| Tpat_record(args,_) ->  extract_fields (record_arg p1) args
| Tpat_array(args) -> args
| Tpat_lazy arg -> [arg]
| (Tpat_any | Tpat_var(_)) ->
    begin match p1.pat_desc with
      Tpat_construct(_, _,args) -> omega_list args
    | Tpat_variant(_, Some _, _) -> [omega]
    | Tpat_tuple(args) -> omega_list args
    | Tpat_record(args,_) ->  omega_list args
    | Tpat_array(args) ->  omega_list args
    | Tpat_lazy _ -> [omega]
    | _ -> []
    end
| _ -> []

(*
  Normalize a pattern ->
   all arguments are omega (simple pattern) and no more variables
*)

let rec normalize_pat q = match q.pat_desc with
  | Tpat_any | Tpat_constant _ -> q
  | Tpat_var _ -> make_pat Tpat_any q.pat_type q.pat_env
  | Tpat_alias (p,_,_) -> normalize_pat p
  | Tpat_tuple (args) ->
      make_pat (Tpat_tuple (omega_list args)) q.pat_type q.pat_env
  | Tpat_construct  (lid, c,args) ->
      make_pat
        (Tpat_construct (lid, c,omega_list args))
        q.pat_type q.pat_env
  | Tpat_variant (l, arg, row) ->
      make_pat (Tpat_variant (l, may_map (fun _ -> omega) arg, row))
        q.pat_type q.pat_env
  | Tpat_array (args) ->
      make_pat (Tpat_array (omega_list args))  q.pat_type q.pat_env
  | Tpat_record (largs, closed) ->
      make_pat
        (Tpat_record (List.map (fun (lid,lbl,_) ->
                                 lid, lbl,omega) largs, closed))
        q.pat_type q.pat_env
  | Tpat_lazy _ ->
      make_pat (Tpat_lazy omega) q.pat_type q.pat_env
  | Tpat_or _ -> fatal_error "Parmatch.normalize_pat"

(*
  Build normalized (cf. supra) discriminating pattern,
  in the non-data type case
*)

let discr_pat q pss =

  let rec acc_pat acc pss = match pss with
    ({pat_desc = Tpat_alias (p,_,_)}::ps)::pss ->
        acc_pat acc ((p::ps)::pss)
  | ({pat_desc = Tpat_or (p1,p2,_)}::ps)::pss ->
        acc_pat acc ((p1::ps)::(p2::ps)::pss)
  | ({pat_desc = (Tpat_any | Tpat_var _)}::_)::pss ->
        acc_pat acc pss
  | (({pat_desc = Tpat_tuple _} as p)::_)::_ -> normalize_pat p
  | (({pat_desc = Tpat_lazy _} as p)::_)::_ -> normalize_pat p
  | (({pat_desc = Tpat_record (largs,closed)} as p)::_)::pss ->
      let new_omegas =
        List.fold_right
          (fun (lid, lbl,_) r ->
            try
              let _ = get_field lbl.lbl_pos r in
              r
            with Not_found ->
              (lid, lbl,omega)::r)
          largs (record_arg acc)
      in
      acc_pat
        (make_pat (Tpat_record (new_omegas, closed)) p.pat_type p.pat_env)
        pss
  | _ -> acc in

  match normalize_pat q with
  | {pat_desc= (Tpat_any | Tpat_record _)} as q -> acc_pat q pss
  | q -> q

(*
   In case a matching value is found, set actual arguments
   of the matching pattern.
*)

let rec read_args xs r = match xs,r with
| [],_ -> [],r
| _::xs, arg::rest ->
   let args,rest = read_args xs rest in
   arg::args,rest
| _,_ ->
    fatal_error "Parmatch.read_args"

let do_set_args erase_mutable q r = match q with
| {pat_desc = Tpat_tuple omegas} ->
    let args,rest = read_args omegas r in
    make_pat (Tpat_tuple args) q.pat_type q.pat_env::rest
| {pat_desc = Tpat_record (omegas,closed)} ->
    let args,rest = read_args omegas r in
    make_pat
      (Tpat_record
         (List.map2 (fun (lid, lbl,_) arg ->
           if
             erase_mutable &&
             (match lbl.lbl_mut with
             | Mutable -> true | Immutable -> false)
           then
             lid, lbl, omega
           else
             lid, lbl, arg)
            omegas args, closed))
      q.pat_type q.pat_env::
    rest
| {pat_desc = Tpat_construct (lid, c,omegas)} ->
    let args,rest = read_args omegas r in
    make_pat
      (Tpat_construct (lid, c,args))
      q.pat_type q.pat_env::
    rest
| {pat_desc = Tpat_variant (l, omega, row)} ->
    let arg, rest =
      match omega, r with
        Some _, a::r -> Some a, r
      | None, r -> None, r
      | _ -> assert false
    in
    make_pat
      (Tpat_variant (l, arg, row)) q.pat_type q.pat_env::
    rest
| {pat_desc = Tpat_lazy omega} ->
    begin match r with
      arg::rest ->
        make_pat (Tpat_lazy arg) q.pat_type q.pat_env::rest
    | _ -> fatal_error "Parmatch.do_set_args (lazy)"
    end
| {pat_desc = Tpat_array omegas} ->
    let args,rest = read_args omegas r in
    make_pat
      (Tpat_array args) q.pat_type q.pat_env::
    rest
| {pat_desc=Tpat_constant _|Tpat_any} ->
    q::r (* case any is used in matching.ml *)
| _ -> fatal_error "Parmatch.set_args"

let set_args q r = do_set_args false q r
and set_args_erase_mutable q r = do_set_args true q r

(* filter pss acording to pattern q *)
let filter_one q pss =
  let rec filter_rec = function
      ({pat_desc = Tpat_alias(p,_,_)}::ps)::pss ->
        filter_rec ((p::ps)::pss)
    | ({pat_desc = Tpat_or(p1,p2,_)}::ps)::pss ->
        filter_rec ((p1::ps)::(p2::ps)::pss)
    | (p::ps)::pss ->
        if simple_match q p
        then (simple_match_args q p @ ps) :: filter_rec pss
        else filter_rec pss
    | _ -> [] in
  filter_rec pss

(*
  Filter pss in the ``extra case''. This applies :
  - According to an extra constructor (datatype case, non-complete signature).
  - Acordinng to anything (all-variables case).
*)
let filter_extra pss =
  let rec filter_rec = function
      ({pat_desc = Tpat_alias(p,_,_)}::ps)::pss ->
        filter_rec ((p::ps)::pss)
    | ({pat_desc = Tpat_or(p1,p2,_)}::ps)::pss ->
        filter_rec ((p1::ps)::(p2::ps)::pss)
    | ({pat_desc = (Tpat_any | Tpat_var(_))} :: qs) :: pss ->
        qs :: filter_rec pss
    | _::pss  -> filter_rec pss
    | [] -> [] in
  filter_rec pss

(*
  Pattern p0 is the discriminating pattern,
  returns [(q0,pss0) ; ... ; (qn,pssn)]
  where the qi's are simple patterns and the pssi's are
  matched matrices.

  NOTES
   * (qi,[]) is impossible.
   * In the case when matching is useless (all-variable case),
     returns []
*)

let filter_all pat0 pss =

  let rec insert q qs env =
    match env with
      [] ->
        let q0 = normalize_pat q in
        [q0, [simple_match_args q0 q @ qs]]
    | ((q0,pss) as c)::env ->
        if simple_match q0 q
        then (q0, ((simple_match_args q0 q @ qs) :: pss)) :: env
        else c :: insert q qs env in

  let rec filter_rec env = function
    ({pat_desc = Tpat_alias(p,_,_)}::ps)::pss ->
      filter_rec env ((p::ps)::pss)
  | ({pat_desc = Tpat_or(p1,p2,_)}::ps)::pss ->
      filter_rec env ((p1::ps)::(p2::ps)::pss)
  | ({pat_desc = (Tpat_any | Tpat_var(_))}::_)::pss ->
      filter_rec env pss
  | (p::ps)::pss ->
      filter_rec (insert p ps env) pss
  | _ -> env

  and filter_omega env = function
    ({pat_desc = Tpat_alias(p,_,_)}::ps)::pss ->
      filter_omega env ((p::ps)::pss)
  | ({pat_desc = Tpat_or(p1,p2,_)}::ps)::pss ->
      filter_omega env ((p1::ps)::(p2::ps)::pss)
  | ({pat_desc = (Tpat_any | Tpat_var(_))}::ps)::pss ->
      filter_omega
        (List.map (fun (q,qss) -> (q,(simple_match_args q omega @ ps) :: qss))
           env)
        pss
  | _::pss -> filter_omega env pss
  | [] -> env in

  filter_omega
    (filter_rec
      (match pat0.pat_desc with
        (Tpat_record(_) | Tpat_tuple(_) | Tpat_lazy(_)) -> [pat0,[]]
      | _ -> [])
      pss)
    pss

(* Variant related functions *)

let rec set_last a = function
    [] -> []
  | [_] -> [a]
  | x::l -> x :: set_last a l

(* mark constructor lines for failure when they are incomplete *)
let rec mark_partial = function
    ({pat_desc = Tpat_alias(p,_,_)}::ps)::pss ->
      mark_partial ((p::ps)::pss)
  | ({pat_desc = Tpat_or(p1,p2,_)}::ps)::pss ->
      mark_partial ((p1::ps)::(p2::ps)::pss)
  | ({pat_desc = (Tpat_any | Tpat_var(_))} :: _ as ps) :: pss ->
      ps :: mark_partial pss
  | ps::pss  ->
      (set_last zero ps) :: mark_partial pss
  | [] -> []

let close_variant env row =
  let row = Btype.row_repr row in
  let nm =
    List.fold_left
      (fun nm (tag,f) ->
        match Btype.row_field_repr f with
        | Reither(_, _, false, e) ->
            (* m=false means that this tag is not explicitly matched *)
            Btype.set_row_field e Rabsent;
            None
        | Rabsent | Reither (_, _, true, _) | Rpresent _ -> nm)
      row.row_name row.row_fields in
  if not row.row_closed || nm != row.row_name then begin
    (* this unification cannot fail *)
    Ctype.unify env row.row_more
      (Btype.newgenty
         (Tvariant {row with row_fields = []; row_more = Btype.newgenvar();
                    row_closed = true; row_name = nm}))
  end

let row_of_pat pat =
  match Ctype.expand_head pat.pat_env pat.pat_type with
    {desc = Tvariant row} -> Btype.row_repr row
  | _ -> assert false

(*
  Check whether the first column of env makes up a complete signature or
  not.
*)

let generalized_constructor x =
  match x with
    ({pat_desc = Tpat_construct(_,c,_);pat_env=env},_) ->
      c.cstr_generalized
  | _ -> assert false

let clean_env env =
  let rec loop =
    function
      | [] -> []
      | x :: xs ->
          if generalized_constructor x then loop xs else x :: loop xs
  in
  loop env

let full_match ignore_generalized closing env =  match env with
| ({pat_desc = Tpat_construct(_,c,_);pat_type=typ},_) :: _ ->
    if c.cstr_consts < 0 then false (* extensions *)
    else
      if ignore_generalized then
        (* remove generalized constructors;
           those cases will be handled separately *)
        let env = clean_env env in
        List.length env = c.cstr_normal
      else
        List.length env = c.cstr_consts + c.cstr_nonconsts

| ({pat_desc = Tpat_variant _} as p,_) :: _ ->
    let fields =
      List.map
        (function ({pat_desc = Tpat_variant (tag, _, _)}, _) -> tag
          | _ -> assert false)
        env
    in
    let row = row_of_pat p in
    if closing && not (Btype.row_fixed row) then
      (* closing=true, we are considering the variant as closed *)
      List.for_all
        (fun (tag,f) ->
          match Btype.row_field_repr f with
            Rabsent | Reither(_, _, false, _) -> true
          | Reither (_, _, true, _)
              (* m=true, do not discard matched tags, rather warn *)
          | Rpresent _ -> List.mem tag fields)
        row.row_fields
    else
      row.row_closed &&
      List.for_all
        (fun (tag,f) ->
          Btype.row_field_repr f = Rabsent || List.mem tag fields)
        row.row_fields
| ({pat_desc = Tpat_constant(Const_char _)},_) :: _ ->
    List.length env = 256
| ({pat_desc = Tpat_constant(_)},_) :: _ -> false
| ({pat_desc = Tpat_tuple(_)},_) :: _ -> true
| ({pat_desc = Tpat_record(_)},_) :: _ -> true
| ({pat_desc = Tpat_array(_)},_) :: _ -> false
| ({pat_desc = Tpat_lazy(_)},_) :: _ -> true
| _ -> fatal_error "Parmatch.full_match"

let full_match_gadt env = match env with
  | ({pat_desc = Tpat_construct(_,c,_);pat_type=typ},_) :: _ ->
    List.length env = c.cstr_consts + c.cstr_nonconsts
  | _ -> true

let extendable_match env = match env with
| ({pat_desc=Tpat_construct(_,{cstr_tag=(Cstr_constant _|Cstr_block _)},_)}
     as p,_) :: _ ->
    let path = get_type_path p.pat_type p.pat_env in
    not
      (Path.same path Predef.path_bool ||
      Path.same path Predef.path_list ||
      Path.same path Predef.path_option)
| _ -> false


let should_extend ext env = match ext with
| None -> false
| Some ext -> match env with
  | ({pat_desc =
      Tpat_construct(_, {cstr_tag=(Cstr_constant _|Cstr_block _)},_)}
     as p, _) :: _ ->
      let path = get_type_path p.pat_type p.pat_env in
      Path.same path ext
  | _ -> false

(* complement constructor tags *)
let complete_tags nconsts nconstrs tags =
  let seen_const = Array.make nconsts false
  and seen_constr = Array.make nconstrs false in
  List.iter
    (function
      | Cstr_constant i -> seen_const.(i) <- true
      | Cstr_block i -> seen_constr.(i) <- true
      | _  -> assert false)
    tags ;
  let r = ref [] in
  for i = 0 to nconsts-1 do
    if not seen_const.(i) then
      r := Cstr_constant i :: !r
  done ;
  for i = 0 to nconstrs-1 do
    if not seen_constr.(i) then
      r := Cstr_block i :: !r
  done ;
  !r

(* build a pattern from a constructor list *)
let pat_of_constr ex_pat cstr =
 {ex_pat with pat_desc =
  Tpat_construct (mknoloc (Longident.Lident "?pat_of_constr?"),
                  cstr,omegas cstr.cstr_arity)}

let rec pat_of_constrs ex_pat = function
| [] -> raise Empty
| [cstr] -> pat_of_constr ex_pat cstr
| cstr::rem ->
    {ex_pat with
    pat_desc=
      Tpat_or
        (pat_of_constr ex_pat cstr,
         pat_of_constrs ex_pat rem, None)}

let rec get_variant_constructors env ty =
  match (Ctype.repr ty).desc with
  | Tconstr (path,_,_) -> begin
      match Env.find_type path env with
      | {type_kind=Type_variant _} ->
          fst (Env.find_type_descrs path env)
      | {type_manifest = Some _} ->
          get_variant_constructors env
            (Ctype.expand_head_once env (clean_copy ty))
      | _ -> fatal_error "Parmatch.get_variant_constructors"
    end
  | _ -> fatal_error "Parmatch.get_variant_constructors"

let rec map_filter f  =
  function
      [] -> []
    | x :: xs ->
        match f x with
        | None -> map_filter f xs
        | Some y -> y :: map_filter f xs

(* Sends back a pattern that complements constructor tags all_tag *)
let complete_constrs p all_tags =
  match p.pat_desc with
  | Tpat_construct (_,c,_) ->
      let not_tags = complete_tags c.cstr_consts c.cstr_nonconsts all_tags in
      let constrs = get_variant_constructors p.pat_env c.cstr_res in
        map_filter
          (fun cnstr ->
            if List.exists (fun tag -> Types.equal_tag tag cnstr.cstr_tag) not_tags then Some cnstr else None)
          constrs
  | _ -> fatal_error "Parmatch.complete_constr"


(* Auxiliary for build_other *)

let build_other_constant proj make first next p env =
  let all = List.map (fun (p, _) -> proj p.pat_desc) env in
  let rec try_const i =
    if List.mem i all
    then try_const (next i)
    else make_pat (make i) p.pat_type p.pat_env
  in try_const first

(*
  Builds a pattern that is incompatible with all patterns in
  in the first column of env
*)

let build_other ext env =  match env with
| ({pat_desc = Tpat_construct (lid,
      ({cstr_tag=Cstr_extension _} as c),_)},_) :: _ ->
    let c = {c with cstr_name = "*extension*"} in
      make_pat (Tpat_construct(lid, c, [])) Ctype.none Env.empty
| ({pat_desc = Tpat_construct (_, _,_)} as p,_) :: _ ->
    begin match ext with
    | Some ext when Path.same ext (get_type_path p.pat_type p.pat_env) ->
        extra_pat
    | _ ->
        let get_tag = function
          | {pat_desc = Tpat_construct (_,c,_)} -> c.cstr_tag
          | _ -> fatal_error "Parmatch.get_tag" in
        let all_tags =  List.map (fun (p,_) -> get_tag p) env in
        pat_of_constrs p (complete_constrs p all_tags)
    end
| ({pat_desc = Tpat_variant (_,_,r)} as p,_) :: _ ->
    let tags =
      List.map
        (function ({pat_desc = Tpat_variant (tag, _, _)}, _) -> tag
                | _ -> assert false)
        env
    in
    let row = row_of_pat p in
    let make_other_pat tag const =
      let arg = if const then None else Some omega in
      make_pat (Tpat_variant(tag, arg, r)) p.pat_type p.pat_env in
    begin match
      List.fold_left
        (fun others (tag,f) ->
          if List.mem tag tags then others else
          match Btype.row_field_repr f with
            Rabsent (* | Reither _ *) -> others
          (* This one is called after erasing pattern info *)
          | Reither (c, _, _, _) -> make_other_pat tag c :: others
          | Rpresent arg -> make_other_pat tag (arg = None) :: others)
        [] row.row_fields
    with
      [] ->
        make_other_pat "AnyExtraTag" true
    | pat::other_pats ->
        List.fold_left
          (fun p_res pat ->
            make_pat (Tpat_or (pat, p_res, None)) p.pat_type p.pat_env)
          pat other_pats
    end
| ({pat_desc = Tpat_constant(Const_char _)} as p,_) :: _ ->
    let all_chars =
      List.map
        (fun (p,_) -> match p.pat_desc with
        | Tpat_constant (Const_char c) -> c
        | _ -> assert false)
        env in

    let rec find_other i imax =
      if i > imax then raise Not_found
      else
        let ci = Char.chr i in
        if List.mem ci all_chars then
          find_other (i+1) imax
        else
          make_pat (Tpat_constant (Const_char ci)) p.pat_type p.pat_env in
    let rec try_chars = function
      | [] -> omega
      | (c1,c2) :: rest ->
          try
            find_other (Char.code c1) (Char.code c2)
          with
          | Not_found -> try_chars rest in

    try_chars
      [ 'a', 'z' ; 'A', 'Z' ; '0', '9' ;
        ' ', '~' ; Char.chr 0 , Char.chr 255]

| ({pat_desc=(Tpat_constant (Const_int _))} as p,_) :: _ ->
    build_other_constant
      (function Tpat_constant(Const_int i) -> i | _ -> assert false)
      (function i -> Tpat_constant(Const_int i))
      0 succ p env
| ({pat_desc=(Tpat_constant (Const_int32 _))} as p,_) :: _ ->
    build_other_constant
      (function Tpat_constant(Const_int32 i) -> i | _ -> assert false)
      (function i -> Tpat_constant(Const_int32 i))
      0l Int32.succ p env
| ({pat_desc=(Tpat_constant (Const_int64 _))} as p,_) :: _ ->
    build_other_constant
      (function Tpat_constant(Const_int64 i) -> i | _ -> assert false)
      (function i -> Tpat_constant(Const_int64 i))
      0L Int64.succ p env
| ({pat_desc=(Tpat_constant (Const_nativeint _))} as p,_) :: _ ->
    (* build_other_constant
      (function Tpat_constant(Const_nativeint i) -> i | _ -> assert false)
      (function i -> Tpat_constant(Const_nativeint i))
      0n Nativeint.succ p env *) assert false
| ({pat_desc=(Tpat_constant (Const_string _))} as p,_) :: _ ->
    build_other_constant
      (function Tpat_constant(Const_string (s, _)) -> String.length s
              | _ -> assert false)
      (function i -> Tpat_constant(Const_string(String.make i '*', None)))
      0 succ p env
| ({pat_desc=(Tpat_constant (Const_float _))} as p,_) :: _ ->
    build_other_constant
      (function Tpat_constant(Const_float f) -> float_of_string f
              | _ -> assert false)
      (function f -> Tpat_constant(Const_float (string_of_float f)))
      0.0 (fun f -> f +. 1.0) p env

| ({pat_desc = Tpat_array args} as p,_)::_ ->
    let all_lengths =
      List.map
        (fun (p,_) -> match p.pat_desc with
        | Tpat_array args -> List.length args
        | _ -> assert false)
        env in
    let rec try_arrays l =
      if List.mem l all_lengths then try_arrays (l+1)
      else
        make_pat
          (Tpat_array (omegas l))
          p.pat_type p.pat_env in
    try_arrays 0
| [] -> omega
| _ -> omega

let build_other_gadt ext env =
  match env with
    | ({pat_desc = Tpat_construct _} as p,_) :: _ ->
        let get_tag = function
          | {pat_desc = Tpat_construct (_,c,_)} -> c.cstr_tag
          | _ -> fatal_error "Parmatch.get_tag" in
        let all_tags =  List.map (fun (p,_) -> get_tag p) env in
        let cnstrs  = complete_constrs p all_tags in
        let pats = List.map (pat_of_constr p) cnstrs in
        (* List.iter (Format.eprintf "%a@." top_pretty) pats;
           Format.eprintf "@.@."; *)
        pats
    | _ -> assert false

(*
  Core function :
  Is the last row of pattern matrix pss + qs satisfiable ?
  That is :
    Does there exists at least one value vector, es such that :
     1- for all ps in pss ps # es (ps and es are not compatible)
     2- qs <= es                  (es matches qs)
*)

let rec has_instance p = match p.pat_desc with
  | Tpat_variant (l,_,r) when is_absent l r -> false
  | Tpat_any | Tpat_var _ | Tpat_constant _ | Tpat_variant (_,None,_) -> true
  | Tpat_alias (p,_,_) | Tpat_variant (_,Some p,_) -> has_instance p
  | Tpat_or (p1,p2,_) -> has_instance p1 || has_instance p2
  | Tpat_construct (_,_,ps) | Tpat_tuple ps | Tpat_array ps ->
      has_instances ps
  | Tpat_record (lps,_) -> has_instances (List.map (fun (_,_,x) -> x) lps)
  | Tpat_lazy p
    -> has_instance p


and has_instances = function
  | [] -> true
  | q::rem -> has_instance q && has_instances rem

let rec satisfiable pss qs = match pss with
| [] -> has_instances qs
| _  ->
    match qs with
    | [] -> false
    | {pat_desc = Tpat_or(q1,q2,_)}::qs ->
        satisfiable pss (q1::qs) || satisfiable pss (q2::qs)
    | {pat_desc = Tpat_alias(q,_,_)}::qs ->
          satisfiable pss (q::qs)
    | {pat_desc = (Tpat_any | Tpat_var(_))}::qs ->
        let q0 = discr_pat omega pss in
        begin match filter_all q0 pss with
          (* first column of pss is made of variables only *)
        | [] -> satisfiable (filter_extra pss) qs
        | constrs  ->
            if full_match false false constrs then
              List.exists
                (fun (p,pss) ->
                  not (is_absent_pat p) &&
                  satisfiable pss (simple_match_args p omega @ qs))
                constrs
            else
              satisfiable (filter_extra pss) qs
        end
    | {pat_desc=Tpat_variant (l,_,r)}::_ when is_absent l r -> false
    | q::qs ->
        let q0 = discr_pat q pss in
        satisfiable (filter_one q0 pss) (simple_match_args q0 q @ qs)

(*
  Now another satisfiable function that additionally
  supplies an example of a matching value.

  This function should be called for exhaustiveness check only.
*)

type 'a result =
  | Rnone           (* No matching value *)
  | Rsome of 'a     (* This matching value *)

let rec orify_many =
  let orify x y =
    make_pat (Tpat_or (x, y, None)) x.pat_type x.pat_env
  in
  function
    | [] -> assert false
    | [x] -> x
    | x :: xs -> orify x (orify_many xs)

let rec try_many  f = function
  | [] -> Rnone
  | (p,pss)::rest ->
      match f (p,pss) with
      | Rnone -> try_many  f rest
      | r -> r

let rappend r1 r2 =
  match r1, r2 with
  | Rnone, _ -> r2
  | _, Rnone -> r1
  | Rsome l1, Rsome l2 -> Rsome (l1 @ l2)

let rec try_many_gadt  f = function
  | [] -> Rnone
  | (p,pss)::rest ->
      rappend (f (p, pss)) (try_many_gadt f rest)

let rec exhaust ext pss n = match pss with
| []    ->  Rsome (omegas n)
| []::_ ->  Rnone
| pss   ->
    let q0 = discr_pat omega pss in
    begin match filter_all q0 pss with
          (* first column of pss is made of variables only *)
    | [] ->
        begin match exhaust ext (filter_extra pss) (n-1) with
        | Rsome r -> Rsome (q0::r)
        | r -> r
      end
    | constrs ->
        let try_non_omega (p,pss) =
          if is_absent_pat p then
            Rnone
          else
            match
              exhaust
                ext pss (List.length (simple_match_args p omega) + n - 1)
            with
            | Rsome r -> Rsome (set_args p r)
            | r       -> r in
        if
          full_match true false constrs && not (should_extend ext constrs)
        then
          try_many try_non_omega constrs
        else
          (*
             D = filter_extra pss is the default matrix
             as it is included in pss, one can avoid
             recursive calls on specialized matrices,
             Essentially :
             * D exhaustive => pss exhaustive
             * D non-exhaustive => we have a non-filtered value
          *)
          let r =  exhaust ext (filter_extra pss) (n-1) in
          match r with
          | Rnone -> Rnone
          | Rsome r ->
              try
                Rsome (build_other ext constrs::r)
              with
      (* cannot occur, since constructors don't make a full signature *)
              | Empty -> fatal_error "Parmatch.exhaust"
    end

let combinations f lst lst' =
  let rec iter2 x =
    function
        [] -> []
      | y :: ys ->
          f x y :: iter2 x ys
  in
  let rec iter =
    function
        [] -> []
      | x :: xs -> iter2 x lst' @ iter xs
  in
  iter lst

(*
let print_pat pat =
  let rec string_of_pat pat =
    match pat.pat_desc with
        Tpat_var _ -> "v"
      | Tpat_any -> "_"
      | Tpat_alias (p, x) -> Printf.sprintf "(%s) as ?"  (string_of_pat p)
      | Tpat_constant n -> "0"
      | Tpat_construct (_, lid, _) ->
        Printf.sprintf "%s" (String.concat "." (Longident.flatten lid.txt))
      | Tpat_lazy p ->
        Printf.sprintf "(lazy %s)" (string_of_pat p)
      | Tpat_or (p1,p2,_) ->
        Printf.sprintf "(%s | %s)" (string_of_pat p1) (string_of_pat p2)
      | Tpat_tuple list ->
        Printf.sprintf "(%s)" (String.concat "," (List.map string_of_pat list))
      | Tpat_variant (_, _, _) -> "variant"
      | Tpat_record (_, _) -> "record"
      | Tpat_array _ -> "array"
  in
  Printf.fprintf stderr "PAT[%s]\n%!" (string_of_pat pat)
*)

(* strictly more powerful than exhaust; however, exhaust
   was kept for backwards compatibility *)
let rec exhaust_gadt (ext:Path.t option) pss n = match pss with
| []    ->  Rsome [omegas n]
| []::_ ->  Rnone
| pss   ->
    let q0 = discr_pat omega pss in
    begin match filter_all q0 pss with
          (* first column of pss is made of variables only *)
    | [] ->
        begin match exhaust_gadt ext (filter_extra pss) (n-1) with
        | Rsome r -> Rsome (List.map (fun row -> q0::row) r)
        | r -> r
      end
    | constrs ->
        let try_non_omega (p,pss) =
          if is_absent_pat p then
            Rnone
          else
            match
              exhaust_gadt
                ext pss (List.length (simple_match_args p omega) + n - 1)
            with
            | Rsome r -> Rsome (List.map (fun row ->  (set_args p row)) r)
            | r       -> r in
        let before = try_many_gadt try_non_omega constrs in
        if
          full_match_gadt constrs && not (should_extend ext constrs)
        then
          before
        else
          (*
            D = filter_extra pss is the default matrix
            as it is included in pss, one can avoid
            recursive calls on specialized matrices,
            Essentially :
           * D exhaustive => pss exhaustive
           * D non-exhaustive => we have a non-filtered value
           *)
          let r =  exhaust_gadt ext (filter_extra pss) (n-1) in
          match r with
          | Rnone -> before
          | Rsome r ->
              try
                let missing_trailing = build_other_gadt ext constrs in
                let dug =
                  combinations
                    (fun head tail -> head :: tail)
                    missing_trailing
                    r
                in
                match before with
                | Rnone -> Rsome dug
                | Rsome x -> Rsome (x @ dug)
              with
      (* cannot occur, since constructors don't make a full signature *)
              | Empty -> fatal_error "Parmatch.exhaust"
    end

let exhaust_gadt ext pss n =
  let ret = exhaust_gadt ext pss n in
  match ret with
    Rnone -> Rnone
  | Rsome lst ->
      (* The following line is needed to compile stdlib/printf.ml *)
      if lst = [] then Rsome (omegas n) else
      let singletons =
        List.map
          (function
              [x] -> x
            | _ -> assert false)
          lst
      in
      Rsome [orify_many singletons]

(*
   Another exhaustiveness check, enforcing variant typing.
   Note that it does not check exact exhaustiveness, but whether a
   matching could be made exhaustive by closing all variant types.
   When this is true of all other columns, the current column is left
   open (even if it means that the whole matching is not exhaustive as
   a result).
   When this is false for the matrix minus the current column, and the
   current column is composed of variant tags, we close the variant
   (even if it doesn't help in making the matching exhaustive).
*)

let rec pressure_variants tdefs = function
  | []    -> false
  | []::_ -> true
  | pss   ->
      let q0 = discr_pat omega pss in
      begin match filter_all q0 pss with
        [] -> pressure_variants tdefs (filter_extra pss)
      | constrs ->
          let rec try_non_omega = function
              (p,pss) :: rem ->
                let ok = pressure_variants tdefs pss in
                try_non_omega rem && ok
            | [] -> true
          in
          if full_match true (tdefs=None) constrs then
            try_non_omega constrs
          else if tdefs = None then
            pressure_variants None (filter_extra pss)
          else
            let full = full_match true true constrs in
            let ok =
              if full then try_non_omega constrs
              else try_non_omega (filter_all q0 (mark_partial pss))
            in
            begin match constrs, tdefs with
              ({pat_desc=Tpat_variant _} as p,_):: _, Some env ->
                let row = row_of_pat p in
                if Btype.row_fixed row
                || pressure_variants None (filter_extra pss) then ()
                else close_variant env row
            | _ -> ()
            end;
            ok
      end


(* Yet another satisfiable fonction *)

(*
   This time every_satisfiable pss qs checks the
   utility of every expansion of qs.
   Expansion means expansion of or-patterns inside qs
*)

type answer =
  | Used                                (* Useful pattern *)
  | Unused                              (* Useless pattern *)
  | Upartial of Typedtree.pattern list  (* Mixed, with list of useless ones *)



(* this row type enable column processing inside the matrix
    - left  ->  elements not to be processed,
    - right ->  elements to be processed
*)
type 'a row = {no_ors : 'a list ; ors : 'a list ; active : 'a list}


let pretty_row {ors=ors ; no_ors=no_ors; active=active} =
  pretty_line ors ; prerr_string " *" ;
  pretty_line no_ors ; prerr_string " *" ;
  pretty_line active

let pretty_rows rs =
  prerr_endline "begin matrix" ;
  List.iter
    (fun r ->
      pretty_row r ;
      prerr_endline "")
    rs ;
  prerr_endline "end matrix"

(* Initial build *)
let make_row ps = {ors=[] ; no_ors=[]; active=ps}

let make_rows pss = List.map make_row pss


(* Useful to detect and expand  or pats inside as pats *)
let rec unalias p = match p.pat_desc with
| Tpat_alias (p,_,_) -> unalias p
| _ -> p


let is_var p = match (unalias p).pat_desc with
| Tpat_any|Tpat_var _ -> true
| _                   -> false

let is_var_column rs =
  List.for_all
    (fun r -> match r.active with
    | p::_ -> is_var p
    | []   -> assert false)
    rs

(* Standard or-args for left-to-right matching *)
let rec or_args p = match p.pat_desc with
| Tpat_or (p1,p2,_) -> p1,p2
| Tpat_alias (p,_,_)  -> or_args p
| _                 -> assert false

(* Just remove current column *)
let remove r = match r.active with
| _::rem -> {r with active=rem}
| []     -> assert false

let remove_column rs = List.map remove rs

(* Current column has been processed *)
let push_no_or r = match r.active with
| p::rem -> { r with no_ors = p::r.no_ors ; active=rem}
| [] -> assert false

let push_or r = match r.active with
| p::rem -> { r with ors = p::r.ors ; active=rem}
| [] -> assert false

let push_or_column rs = List.map push_or rs
and push_no_or_column rs = List.map push_no_or rs

(* Those are adaptations of the previous homonymous functions that
   work on the current column, instead of the first column
*)

let discr_pat q rs =
  discr_pat q (List.map (fun r -> r.active) rs)

let filter_one q rs =
  let rec filter_rec rs = match rs with
  | [] -> []
  | r::rem ->
      match r.active with
      | [] -> assert false
      | {pat_desc = Tpat_alias(p,_,_)}::ps ->
          filter_rec ({r with active = p::ps}::rem)
      | {pat_desc = Tpat_or(p1,p2,_)}::ps ->
          filter_rec
            ({r with active = p1::ps}::
             {r with active = p2::ps}::
             rem)
      | p::ps ->
          if simple_match q p then
            {r with active=simple_match_args q p @ ps} :: filter_rec rem
          else
            filter_rec rem in
  filter_rec rs


(* Back to normal matrices *)
let make_vector r = r.no_ors

let make_matrix rs = List.map make_vector rs


(* Standard union on answers *)
let union_res r1 r2 = match r1, r2 with
| (Unused,_)
| (_, Unused) -> Unused
| Used,_    -> r2
| _, Used   -> r1
| Upartial u1, Upartial u2 -> Upartial (u1@u2)

(* propose or pats for expansion *)
let extract_elements qs =
  let rec do_rec seen = function
    | [] -> []
    | q::rem ->
        {no_ors= List.rev_append seen rem @ qs.no_ors ;
        ors=[] ;
        active = [q]}::
        do_rec (q::seen) rem in
  do_rec [] qs.ors

(* idem for matrices *)
let transpose rs = match rs with
| [] -> assert false
| r::rem ->
    let i = List.map (fun x -> [x]) r in
    List.fold_left
      (List.map2 (fun r x -> x::r))
      i rem

let extract_columns pss qs = match pss with
| [] -> List.map (fun _ -> []) qs.ors
| _  ->
  let rows = List.map extract_elements pss in
  transpose rows

(* Core function
   The idea is to first look for or patterns (recursive case), then
   check or-patterns argument usefulness (terminal case)
*)

let rec every_satisfiables pss qs = match qs.active with
| []     ->
    (* qs is now partitionned,  check usefulness *)
    begin match qs.ors with
    | [] -> (* no or-patterns *)
        if satisfiable (make_matrix pss) (make_vector qs) then
          Used
        else
          Unused
    | _  -> (* n or-patterns -> 2n expansions *)
        List.fold_right2
          (fun pss qs r -> match r with
          | Unused -> Unused
          | _ ->
              match qs.active with
              | [q] ->
                  let q1,q2 = or_args q in
                  let r_loc = every_both pss qs q1 q2 in
                  union_res r r_loc
              | _   -> assert false)
          (extract_columns pss qs) (extract_elements qs)
          Used
    end
| q::rem ->
    let uq = unalias q in
    begin match uq.pat_desc with
    | Tpat_any | Tpat_var _ ->
        if is_var_column pss then
(* forget about ``all-variable''  columns now *)
          every_satisfiables (remove_column pss) (remove qs)
        else
(* otherwise this is direct food for satisfiable *)
          every_satisfiables (push_no_or_column pss) (push_no_or qs)
    | Tpat_or (q1,q2,_) ->
        if
          q1.pat_loc.Location.loc_ghost &&
          q2.pat_loc.Location.loc_ghost
        then
(* syntactically generated or-pats should not be expanded *)
          every_satisfiables (push_no_or_column pss) (push_no_or qs)
        else
(* this is a real or-pattern *)
          every_satisfiables (push_or_column pss) (push_or qs)
    | Tpat_variant (l,_,r) when is_absent l r -> (* Ah Jacques... *)
        Unused
    | _ ->
(* standard case, filter matrix *)
        let q0 = discr_pat q pss in
        every_satisfiables
          (filter_one q0 pss)
          {qs with active=simple_match_args q0 q @ rem}
    end

(*
  This function ``every_both'' performs the usefulness check
  of or-pat q1|q2.
  The trick is to call every_satisfied twice with
  current active columns restricted to q1 and q2,
  That way,
  - others orpats in qs.ors will not get expanded.
  - all matching work performed on qs.no_ors is not performed again.
  *)
and every_both pss qs q1 q2 =
  let qs1 = {qs with active=[q1]}
  and qs2 =  {qs with active=[q2]} in
  let r1 = every_satisfiables pss qs1
  and r2 =  every_satisfiables (if compat q1 q2 then qs1::pss else pss) qs2 in
  match r1 with
  | Unused ->
      begin match r2 with
      | Unused -> Unused
      | Used   -> Upartial [q1]
      | Upartial u2 -> Upartial (q1::u2)
      end
  | Used ->
      begin match r2 with
      | Unused -> Upartial [q2]
      | _      -> r2
      end
  | Upartial u1 ->
      begin match r2 with
      | Unused -> Upartial (u1@[q2])
      | Used   -> r1
      | Upartial u2 -> Upartial (u1 @ u2)
      end




(* le_pat p q  means, forall V,  V matches q implies V matches p *)
let rec le_pat p q =
  match (p.pat_desc, q.pat_desc) with
  | (Tpat_var _|Tpat_any),_ -> true
  | Tpat_alias(p,_,_), _ -> le_pat p q
  | _, Tpat_alias(q,_,_) -> le_pat p q
  | Tpat_constant(c1), Tpat_constant(c2) -> const_compare c1 c2 = 0
  | Tpat_construct(_,c1,ps), Tpat_construct(_,c2,qs) ->
      Types.equal_tag c1.cstr_tag  c2.cstr_tag && le_pats ps qs
  | Tpat_variant(l1,Some p1,_), Tpat_variant(l2,Some p2,_) ->
      (l1 = l2 && le_pat p1 p2)
  | Tpat_variant(l1,None,r1), Tpat_variant(l2,None,_) ->
      l1 = l2
  | Tpat_variant(_,_,_), Tpat_variant(_,_,_) -> false
  | Tpat_tuple(ps), Tpat_tuple(qs) -> le_pats ps qs
  | Tpat_lazy p, Tpat_lazy q -> le_pat p q
  | Tpat_record (l1,_), Tpat_record (l2,_) ->
      let ps,qs = records_args l1 l2 in
      le_pats ps qs
  | Tpat_array(ps), Tpat_array(qs) ->
      List.length ps = List.length qs && le_pats ps qs
(* In all other cases, enumeration is performed *)
  | _,_  -> not (satisfiable [[p]] [q])

and le_pats ps qs =
  match ps,qs with
    p::ps, q::qs -> le_pat p q && le_pats ps qs
  | _, _         -> true

let get_mins le ps =
  let rec select_rec r = function
      [] -> r
    | p::ps ->
        if List.exists (fun p0 -> le p0 p) ps
        then select_rec r ps
        else select_rec (p::r) ps in
  select_rec [] (select_rec [] ps)

(*
  lub p q is a pattern that matches all values matched by p and q
  may raise Empty, when p and q and not compatible
*)

let rec lub p q = match p.pat_desc,q.pat_desc with
| Tpat_alias (p,_,_),_      -> lub p q
| _,Tpat_alias (q,_,_)      -> lub p q
| (Tpat_any|Tpat_var _),_ -> q
| _,(Tpat_any|Tpat_var _) -> p
| Tpat_or (p1,p2,_),_     -> orlub p1 p2 q
| _,Tpat_or (q1,q2,_)     -> orlub q1 q2 p (* Thanks god, lub is commutative *)
| Tpat_constant c1, Tpat_constant c2 when const_compare c1 c2 = 0 -> p
| Tpat_tuple ps, Tpat_tuple qs ->
    let rs = lubs ps qs in
    make_pat (Tpat_tuple rs) p.pat_type p.pat_env
| Tpat_lazy p, Tpat_lazy q ->
    let r = lub p q in
    make_pat (Tpat_lazy r) p.pat_type p.pat_env
| Tpat_construct (lid, c1,ps1), Tpat_construct (_,c2,ps2)
      when  Types.equal_tag c1.cstr_tag  c2.cstr_tag  ->
        let rs = lubs ps1 ps2 in
        make_pat (Tpat_construct (lid, c1,rs))
          p.pat_type p.pat_env
| Tpat_variant(l1,Some p1,row), Tpat_variant(l2,Some p2,_)
          when  l1=l2 ->
            let r=lub p1 p2 in
            make_pat (Tpat_variant (l1,Some r,row)) p.pat_type p.pat_env
| Tpat_variant (l1,None,row), Tpat_variant(l2,None,_)
              when l1 = l2 -> p
| Tpat_record (l1,closed),Tpat_record (l2,_) ->
    let rs = record_lubs l1 l2 in
    make_pat (Tpat_record (rs, closed)) p.pat_type p.pat_env
| Tpat_array ps, Tpat_array qs
      when List.length ps = List.length qs ->
        let rs = lubs ps qs in
        make_pat (Tpat_array rs) p.pat_type p.pat_env
| _,_  ->
    raise Empty

and orlub p1 p2 q =
  try
    let r1 = lub p1 q in
    try
      {q with pat_desc=(Tpat_or (r1,lub p2 q,None))}
  with
  | Empty -> r1
with
| Empty -> lub p2 q

and record_lubs l1 l2 =
  let rec lub_rec l1 l2 = match l1,l2 with
  | [],_ -> l2
  | _,[] -> l1
  | (lid1, lbl1,p1)::rem1, (lid2, lbl2,p2)::rem2 ->
      if lbl1.lbl_pos < lbl2.lbl_pos then
        (lid1, lbl1,p1)::lub_rec rem1 l2
      else if lbl2.lbl_pos < lbl1.lbl_pos  then
        (lid2, lbl2,p2)::lub_rec l1 rem2
      else
        (lid1, lbl1,lub p1 p2)::lub_rec rem1 rem2 in
  lub_rec l1 l2

and lubs ps qs = match ps,qs with
| p::ps, q::qs -> lub p q :: lubs ps qs
| _,_ -> []


(******************************)
(* Exported variant closing   *)
(******************************)

(* Apply pressure to variants *)

let pressure_variants tdefs patl =
  let pss = List.map (fun p -> [p;omega]) patl in
  ignore (pressure_variants (Some tdefs) pss)

(*****************************)
(* Utilities for diagnostics *)
(*****************************)

(*
  Build up a working pattern matrix by forgetting
  about guarded patterns
*)

let rec initial_matrix = function
    [] -> []
  | {c_guard=Some _} :: rem -> initial_matrix rem
  | {c_guard=None; c_lhs=p} :: rem -> [p] :: initial_matrix rem

(******************************************)
(* Look for a row that matches some value *)
(******************************************)

(*
  Useful for seeing if the example of
  non-matched value can indeed be matched
  (by a guarded clause)
*)



exception NoGuard

let rec initial_all no_guard = function
  | [] ->
      if no_guard then
        raise NoGuard
      else
        []
  | {c_lhs=pat; c_guard; _} :: rem ->
      ([pat], pat.pat_loc) :: initial_all (no_guard && c_guard = None) rem


let rec do_filter_var = function
  | (_::ps,loc)::rem -> (ps,loc)::do_filter_var rem
  | _ -> []

let do_filter_one q pss =
  let rec filter_rec = function
    | ({pat_desc = Tpat_alias(p,_,_)}::ps,loc)::pss ->
        filter_rec ((p::ps,loc)::pss)
    | ({pat_desc = Tpat_or(p1,p2,_)}::ps,loc)::pss ->
        filter_rec ((p1::ps,loc)::(p2::ps,loc)::pss)
    | (p::ps,loc)::pss ->
        if simple_match q p
        then (simple_match_args q p @ ps, loc) :: filter_rec pss
        else filter_rec pss
    | _ -> [] in
  filter_rec pss

let rec do_match pss qs = match qs with
| [] ->
    begin match pss  with
    | ([],loc)::_ -> Some loc
    | _ -> None
    end
| q::qs -> match q with
  | {pat_desc = Tpat_or (q1,q2,_)} ->
      begin match do_match pss (q1::qs) with
      | None -> do_match pss (q2::qs)
      | r -> r
      end
  | {pat_desc = Tpat_any} ->
      do_match (do_filter_var pss) qs
  | _ ->
      let q0 = normalize_pat q in
      do_match (do_filter_one q0 pss) (simple_match_args q0 q @ qs)


let check_partial_all v casel =
  try
    let pss = initial_all true casel in
    do_match pss [v]
  with
  | NoGuard -> None

(************************)
(* Exhaustiveness check *)
(************************)


  let rec get_first f =
    function
      | [] -> None
      | x :: xs ->
          match f x with
          | None -> get_first f xs
          | x -> x


(* conversion from Typedtree.pattern to Parsetree.pattern list *)
module Conv = struct
  open Parsetree
  let mkpat desc = Ast_helper.Pat.mk desc

  let rec select : 'a list list -> 'a list list =
    function
      | xs :: [] -> List.map (fun y -> [y]) xs
      | (x::xs)::ys ->
          List.map
            (fun lst -> x :: lst)
            (select ys)
          @
            select (xs::ys)
      | _ -> []

  let name_counter = ref 0
  let fresh name =
    let current = !name_counter in
    name_counter := !name_counter + 1;
    "#$" ^ name ^ string_of_int current

  let conv (typed: Typedtree.pattern) :
      Parsetree.pattern list *
      (string, Types.constructor_description) Hashtbl.t *
      (string, Types.label_description) Hashtbl.t
      =
    let constrs = Hashtbl.create 0 in
    let labels = Hashtbl.create 0 in
    let rec loop pat =
      match pat.pat_desc with
        Tpat_or (a,b,_) ->
          loop a @ loop b
      | Tpat_any | Tpat_constant _ | Tpat_var _ ->
          [mkpat Ppat_any]
      | Tpat_alias (p,_,_) -> loop p
      | Tpat_tuple lst ->
          let results = select (List.map loop lst) in
          List.map
            (fun lst -> mkpat (Ppat_tuple lst))
            results
      | Tpat_construct (cstr_lid, cstr,lst) ->
          let id = fresh cstr.cstr_name in
          let lid = { cstr_lid with txt = Longident.Lident id } in
          Hashtbl.add constrs id cstr;
          let results = select (List.map loop lst) in
          begin match lst with
            [] ->
              [mkpat (Ppat_construct(lid, None))]
          | _ ->
              List.map
                (fun lst ->
                  let arg =
                    match lst with
                      [] -> assert false
                    | [x] -> Some x
                    | _ -> Some (mkpat (Ppat_tuple lst))
                  in
                  mkpat (Ppat_construct(lid, arg)))
                results
          end
      | Tpat_variant(label,p_opt,row_desc) ->
          begin match p_opt with
          | None ->
              [mkpat (Ppat_variant(label, None))]
          | Some p ->
              let results = loop p in
              List.map
                (fun p ->
                  mkpat (Ppat_variant(label, Some p)))
                results
          end
      | Tpat_record (subpatterns, _closed_flag) ->
          let pats =
            select
              (List.map (fun (_,_,x) -> loop x) subpatterns)
          in
          let label_idents =
            List.map
              (fun (_,lbl,_) ->
                let id = fresh lbl.lbl_name in
                Hashtbl.add labels id lbl;
                Longident.Lident id)
              subpatterns
          in
          List.map
            (fun lst ->
              let lst = List.map2 (fun lid pat ->
                (mknoloc lid, pat)
              )  label_idents lst in
              mkpat (Ppat_record (lst, Open)))
            pats
      | Tpat_array lst ->
          let results = select (List.map loop lst) in
          List.map (fun lst -> mkpat (Ppat_array lst)) results
      | Tpat_lazy p ->
          let results = loop p in
          List.map (fun p -> mkpat (Ppat_lazy p)) results
    in
    let ps = loop typed in
    (ps, constrs, labels)
end


let do_check_partial ?pred exhaust loc casel pss = match pss with
| [] ->
        (*
          This can occur
          - For empty matches generated by ocamlp4 (no warning)
          - when all patterns have guards (then, casel <> [])
          (specific warning)
          Then match MUST be considered non-exhaustive,
          otherwise compilation of PM is broken.
          *)
    begin match casel with
    | [] -> ()
    | _  -> Location.prerr_warning loc Warnings.All_clauses_guarded
    end ;
    Partial
| ps::_  ->
    begin match exhaust None pss (List.length ps) with
    | Rnone -> Total
    | Rsome [u] ->
        let v =
          match pred with
          | Some pred ->
              let (patterns,constrs,labels) = Conv.conv u in
(*              Hashtbl.iter (fun s (path, _) ->
                Printf.fprintf stderr "CONV: %s -> %s \n%!" s (Path.name path))
                constrs
              ; *)
              get_first (pred constrs labels) patterns
          | None -> Some u
        in
        begin match v with
          None -> Total
        | Some v ->
            let errmsg =
              match v.pat_desc with
                Tpat_construct (_, {cstr_name="*extension*"}, _) ->
                  "_\nMatching over values of extensible variant types must include\n\
                   a wild card pattern in order to be exhaustive."
              | _ -> try
                let buf = Buffer.create 16 in
                let fmt = formatter_of_buffer buf in
                top_pretty fmt v;
                begin match check_partial_all v casel with
                | None -> ()
                | Some _ ->
                    (* This is 'Some loc', where loc is the location of
                       a possibly matching clause.
                       Forget about loc, because printing two locations
                       is a pain in the top-level *)
                    Buffer.add_string buf
                      "\n(However, some guarded clause may match this value.)"
                end ;
                Buffer.contents buf
              with _ ->
                ""
            in
            Location.prerr_warning loc (Warnings.Partial_match errmsg) ;
            Partial
        end
    | _ ->
        fatal_error "Parmatch.check_partial"
    end

let do_check_partial_normal loc casel pss =
  do_check_partial exhaust loc casel pss

let do_check_partial_gadt pred loc casel pss =
  do_check_partial ~pred exhaust_gadt loc casel pss



(*****************)
(* Fragile check *)
(*****************)

(* Collect all data types in a pattern *)

let rec add_path path = function
  | [] -> [path]
  | x::rem as paths ->
      if Path.same path x then paths
      else x::add_path path rem

let extendable_path path =
  not
    (Path.same path Predef.path_bool ||
    Path.same path Predef.path_list ||
    Path.same path Predef.path_unit ||
    Path.same path Predef.path_option)

let rec collect_paths_from_pat r p = match p.pat_desc with
| Tpat_construct(_, {cstr_tag=(Cstr_constant _|Cstr_block _)},ps) ->
    let path =  get_type_path p.pat_type p.pat_env in
    List.fold_left
      collect_paths_from_pat
      (if extendable_path path then add_path path r else r)
      ps
| Tpat_any|Tpat_var _|Tpat_constant _| Tpat_variant (_,None,_) -> r
| Tpat_tuple ps | Tpat_array ps
| Tpat_construct (_, {cstr_tag=Cstr_extension _}, ps)->
    List.fold_left collect_paths_from_pat r ps
| Tpat_record (lps,_) ->
    List.fold_left
      (fun r (_, _, p) -> collect_paths_from_pat r p)
      r lps
| Tpat_variant (_, Some p, _) | Tpat_alias (p,_,_) -> collect_paths_from_pat r p
| Tpat_or (p1,p2,_) ->
    collect_paths_from_pat (collect_paths_from_pat r p1) p2
| Tpat_lazy p
    ->
    collect_paths_from_pat r p


(*
  Actual fragile check
   1. Collect data types in the patterns of the match.
   2. One exhautivity check per datatype, considering that
      the type is extended.
*)

let do_check_fragile_param exhaust loc casel pss =
  let exts =
    List.fold_left
      (fun r c -> collect_paths_from_pat r c.c_lhs)
      [] casel in
  match exts with
  | [] -> ()
  | _ -> match pss with
    | [] -> ()
    | ps::_ ->
        List.iter
          (fun ext ->
            match exhaust (Some ext) pss (List.length ps) with
            | Rnone ->
                Location.prerr_warning
                  loc
                  (Warnings.Fragile_match (Path.name ext))
            | Rsome _ -> ())
          exts

let do_check_fragile_normal = do_check_fragile_param exhaust
let do_check_fragile_gadt = do_check_fragile_param exhaust_gadt

(********************************)
(* Exported unused clause check *)
(********************************)

let check_unused tdefs casel =
  if Warnings.is_active Warnings.Unused_match then
    let rec do_rec pref = function
      | [] -> ()
      | {c_lhs=q; c_guard} :: rem ->
          let qs = [q] in
            begin try
              let pss =
                  get_mins le_pats (List.filter (compats qs) pref) in
              let r = every_satisfiables (make_rows pss) (make_row qs) in
              match r with
              | Unused ->
                  Location.prerr_warning
                    q.pat_loc Warnings.Unused_match
              | Upartial ps ->
                  List.iter
                    (fun p ->
                      Location.prerr_warning
                        p.pat_loc Warnings.Unused_pat)
                    ps
              | Used -> ()
            with Empty | Not_found | NoGuard -> assert false
            end ;

          if c_guard <> None then
            do_rec pref rem
          else
            do_rec ([q]::pref) rem in

    do_rec [] casel

(*********************************)
(* Exported irrefutability tests *)
(*********************************)

let irrefutable pat = le_pat pat omega

(* An inactive pattern is a pattern whose matching needs only
   trivial computations (tag/equality tests).
   Patterns containing (lazy _) subpatterns are active. *)

let rec inactive pat = match pat with
| Tpat_lazy _ ->
    false
| Tpat_any | Tpat_var _ | Tpat_constant _ | Tpat_variant (_, None, _) ->
    true
| Tpat_tuple ps | Tpat_construct (_, _, ps) | Tpat_array ps ->
    List.for_all (fun p -> inactive p.pat_desc) ps
| Tpat_alias (p,_,_) | Tpat_variant (_, Some p, _) ->
    inactive p.pat_desc
| Tpat_record (ldps,_) ->
    List.exists (fun (_, _, p) -> inactive p.pat_desc) ldps
| Tpat_or (p,q,_) ->
    inactive p.pat_desc && inactive q.pat_desc

(* A `fluid' pattern is both irrefutable and inactive *)

let fluid pat =  irrefutable pat && inactive pat.pat_desc








(********************************)
(* Exported exhustiveness check *)
(********************************)

(*
   Fragile check is performed when required and
   on exhaustive matches only.
*)

let check_partial_param do_check_partial do_check_fragile loc casel =
    if Warnings.is_active (Warnings.Partial_match "") then begin
      let pss = initial_matrix casel in
      let pss = get_mins le_pats pss in
      let total = do_check_partial loc casel pss in
      if
        total = Total && Warnings.is_active (Warnings.Fragile_match "")
      then begin
        do_check_fragile loc casel pss
      end ;
      total
    end else
      Partial

let check_partial =
    check_partial_param
      do_check_partial_normal
      do_check_fragile_normal

let check_partial_gadt pred loc casel =
  (*ignores GADT constructors *)
  let first_check = check_partial loc casel in
  match first_check with
  | Partial -> Partial
  | Total ->
      (* checks for missing GADT constructors *)
      (* let casel =
        match casel with [] -> [] | a :: l -> a :: l @ [a] in *)
      check_partial_param (do_check_partial_gadt pred)
        do_check_fragile_gadt loc casel

end
module Typetexp : sig
(*#1 "typetexp.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Typechecking of type expressions for the core language *)

open Types

val transl_simple_type:
        Env.t -> bool -> Parsetree.core_type -> Typedtree.core_type
val transl_simple_type_univars:
        Env.t -> Parsetree.core_type -> Typedtree.core_type
val transl_simple_type_delayed:
        Env.t -> Parsetree.core_type -> Typedtree.core_type * (unit -> unit)
        (* Translate a type, but leave type variables unbound. Returns
           the type and a function that binds the type variable. *)
val transl_type_scheme:
        Env.t -> Parsetree.core_type -> Typedtree.core_type
val reset_type_variables: unit -> unit
val type_variable: Location.t -> string -> type_expr
val transl_type_param:
  Env.t -> Parsetree.core_type -> Typedtree.core_type

type variable_context
val narrow: unit -> variable_context
val widen: variable_context -> unit

exception Already_bound

type error =
    Unbound_type_variable of string
  | Unbound_type_constructor of Longident.t
  | Unbound_type_constructor_2 of Path.t
  | Type_arity_mismatch of Longident.t * int * int
  | Bound_type_variable of string
  | Recursive_type
  | Unbound_row_variable of Longident.t
  | Type_mismatch of (type_expr * type_expr) list
  | Alias_type_mismatch of (type_expr * type_expr) list
  | Present_has_conjunction of string
  | Present_has_no_type of string
  | Constructor_mismatch of type_expr * type_expr
  | Not_a_variant of type_expr
  | Variant_tags of string * string
  | Invalid_variable_name of string
  | Cannot_quantify of string * type_expr
  | Multiple_constraints_on_type of Longident.t
  | Repeated_method_label of string
  | Unbound_value of Longident.t
  | Unbound_constructor of Longident.t
  | Unbound_label of Longident.t
  | Unbound_module of Longident.t
  | Unbound_class of Longident.t
  | Unbound_modtype of Longident.t
  | Unbound_cltype of Longident.t
  | Ill_typed_functor_application of Longident.t
  | Illegal_reference_to_recursive_module
  | Access_functor_as_structure of Longident.t

exception Error of Location.t * Env.t * error

val report_error: Env.t -> Format.formatter -> error -> unit

(* Support for first-class modules. *)
val transl_modtype_longident:  (* from Typemod *)
    (Location.t -> Env.t -> Longident.t -> Path.t) ref
val transl_modtype: (* from Typemod *)
    (Env.t -> Parsetree.module_type -> Typedtree.module_type) ref
val create_package_mty:
    Location.t -> Env.t -> Parsetree.package_type ->
    (Longident.t Asttypes.loc * Parsetree.core_type) list *
      Parsetree.module_type

val find_type:
    Env.t -> Location.t -> Longident.t -> Path.t * type_declaration
val find_constructor:
    Env.t -> Location.t -> Longident.t -> constructor_description
val find_all_constructors:
    Env.t -> Location.t -> Longident.t ->
    (constructor_description * (unit -> unit)) list
val find_label:
    Env.t -> Location.t -> Longident.t -> label_description
val find_all_labels:
    Env.t -> Location.t -> Longident.t ->
    (label_description * (unit -> unit)) list
val find_value:
    Env.t -> Location.t -> Longident.t -> Path.t * value_description
val find_class:
    Env.t -> Location.t -> Longident.t -> Path.t * class_declaration
val find_module:
    Env.t -> Location.t -> Longident.t -> Path.t * module_declaration
val lookup_module:
    ?load:bool -> Env.t -> Location.t -> Longident.t -> Path.t
val find_modtype:
    Env.t -> Location.t -> Longident.t -> Path.t * modtype_declaration
val find_class_type:
    Env.t -> Location.t -> Longident.t -> Path.t * class_type_declaration

val unbound_constructor_error: Env.t -> Longident.t Location.loc -> 'a
val unbound_label_error: Env.t -> Longident.t Location.loc -> 'a

type cd
val spellcheck_simple:
    Format.formatter ->
    (('a -> cd -> cd) -> Longident.t option -> 'b -> cd -> cd) ->
    ('a -> string) -> 'b -> Longident.t -> unit

val check_deprecated: Location.t -> Parsetree.attributes -> string -> unit

val warning_enter_scope: unit -> unit
val warning_leave_scope: unit -> unit
val warning_attribute: Parsetree.attributes -> unit

val error_of_extension: Parsetree.extension -> Location.error

val emit_external_warnings: Ast_mapper.mapper

end = struct
(*#1 "typetexp.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* typetexp.ml,v 1.34.4.9 2002/01/07 08:39:16 garrigue Exp *)

(* Typechecking of type expressions for the core language *)

open Asttypes
open Misc
open Parsetree
open Typedtree
open Types
open Ctype

exception Already_bound

type error =
    Unbound_type_variable of string
  | Unbound_type_constructor of Longident.t
  | Unbound_type_constructor_2 of Path.t
  | Type_arity_mismatch of Longident.t * int * int
  | Bound_type_variable of string
  | Recursive_type
  | Unbound_row_variable of Longident.t
  | Type_mismatch of (type_expr * type_expr) list
  | Alias_type_mismatch of (type_expr * type_expr) list
  | Present_has_conjunction of string
  | Present_has_no_type of string
  | Constructor_mismatch of type_expr * type_expr
  | Not_a_variant of type_expr
  | Variant_tags of string * string
  | Invalid_variable_name of string
  | Cannot_quantify of string * type_expr
  | Multiple_constraints_on_type of Longident.t
  | Repeated_method_label of string
  | Unbound_value of Longident.t
  | Unbound_constructor of Longident.t
  | Unbound_label of Longident.t
  | Unbound_module of Longident.t
  | Unbound_class of Longident.t
  | Unbound_modtype of Longident.t
  | Unbound_cltype of Longident.t
  | Ill_typed_functor_application of Longident.t
  | Illegal_reference_to_recursive_module
  | Access_functor_as_structure of Longident.t

exception Error of Location.t * Env.t * error
exception Error_forward of Location.error

let string_of_cst = function
  | Const_string(s, _) -> Some s
  | _ -> None

let string_of_payload = function
  | PStr[{pstr_desc=Pstr_eval({pexp_desc=Pexp_constant c},_)}] ->
      string_of_cst c
  | _ -> None

let rec error_of_extension ext =
  match ext with
  | ({txt = ("ocaml.error"|"error") as txt; loc}, p) ->
    let rec sub_from inner =
      match inner with
      | {pstr_desc=Pstr_extension (ext, _)} :: rest ->
          error_of_extension ext :: sub_from rest
      | {pstr_loc} :: rest ->
          (Location.errorf ~loc
             "Invalid syntax for sub-error of extension '%s'." txt) ::
            sub_from rest
      | [] -> []
    in
    begin match p with
    | PStr({pstr_desc=Pstr_eval
              ({pexp_desc=Pexp_constant(Const_string(msg,_))}, _)}::
           {pstr_desc=Pstr_eval
              ({pexp_desc=Pexp_constant(Const_string(if_highlight,_))}, _)}::
           inner) ->
        Location.error ~loc ~if_highlight ~sub:(sub_from inner) msg
    | PStr({pstr_desc=Pstr_eval
              ({pexp_desc=Pexp_constant(Const_string(msg,_))}, _)}::inner) ->
        Location.error ~loc ~sub:(sub_from inner) msg
    | _ -> Location.errorf ~loc "Invalid syntax for extension '%s'." txt
    end
  | ({txt; loc}, _) ->
      Location.errorf ~loc "Uninterpreted extension '%s'." txt

let check_deprecated loc attrs s =
  List.iter
    (function
    | ({txt = "ocaml.deprecated"|"deprecated"; _}, p) ->
      begin match string_of_payload p with
      | Some txt ->

if Clflags.bs_vscode then
     Location.prerr_warning loc (Warnings.Deprecated (s ^ " " ^ txt))
else
     Location.prerr_warning loc (Warnings.Deprecated (s ^ "\n" ^ txt))

      | None ->
          Location.prerr_warning loc (Warnings.Deprecated s)
      end
    | _ ->  ())
    attrs

let emit_external_warnings =
  (* Note: this is run as a preliminary pass when type-checking an
     interface or implementation.  This allows to cover all kinds of
     attributes, but the drawback is that it doesn't take local
     configuration of warnings (with '@@warning'/'@@warnerror'
     attributes) into account.  We should rather check for
     'ppwarning' attributes during the actual type-checking, making
     sure to cover all contexts (easier and more ugly alternative:
     duplicate here the logic which control warnings locally). *)
  let open Ast_mapper in
  {
    default_mapper with
    attribute = (fun _ a ->
        begin match a with
        | {txt="ocaml.ppwarning"|"ppwarning"},
          PStr[{pstr_desc=Pstr_eval({pexp_desc=Pexp_constant
                                         (Const_string (s, _))},_);
                pstr_loc}] ->
            Location.prerr_warning pstr_loc (Warnings.Preprocessor s)
        | _ -> ()
        end;
        a
      )
  }


let warning_scope = ref []

let warning_enter_scope () =
  warning_scope := (Warnings.backup ()) :: !warning_scope
let warning_leave_scope () =
  match !warning_scope with
  | [] -> assert false
  | hd :: tl ->
      Warnings.restore hd;
      warning_scope := tl

let warning_attribute attrs =
  let process loc txt errflag payload =
    match string_of_payload payload with
    | Some s ->
        begin try Warnings.parse_options errflag s
        with Arg.Bad _ ->
          Location.prerr_warning loc
            (Warnings.Attribute_payload
               (txt, "Ill-formed list of warnings"))
        end
    | None ->
        Location.prerr_warning loc
          (Warnings.Attribute_payload
             (txt, "A single string literal is expected"))
  in
  List.iter
    (function
      | ({txt = ("ocaml.warning"|"warning") as txt; loc}, payload) ->
          process loc txt false payload
      | ({txt = ("ocaml.warnerror"|"warnerror") as txt; loc}, payload) ->
          process loc txt true payload
      | _ ->
          ()
    )
    attrs

type variable_context = int * (string, type_expr) Tbl.t

(* Local definitions *)

let instance_list = Ctype.instance_list Env.empty

(* Narrowing unbound identifier errors. *)

let rec narrow_unbound_lid_error : 'a. _ -> _ -> _ -> _ -> 'a =
  fun env loc lid make_error ->
  let check_module mlid =
    try ignore (Env.lookup_module true mlid env) with
    | Not_found ->
        narrow_unbound_lid_error env loc mlid (fun lid -> Unbound_module lid)
    | Env.Recmodule ->
        raise (Error (loc, env, Illegal_reference_to_recursive_module))
  in
  begin match lid with
  | Longident.Lident _ -> ()
  | Longident.Ldot (mlid, _) ->
      check_module mlid;
      let md = Env.find_module (Env.lookup_module true mlid env) env in
      begin match Env.scrape_alias env md.md_type with
        Mty_functor _ ->
          raise (Error (loc, env, Access_functor_as_structure mlid))
      | _ -> ()
      end
  | Longident.Lapply (flid, mlid) ->
      check_module flid;
      check_module mlid;
      raise (Error (loc, env, Ill_typed_functor_application lid))
  end;
  raise (Error (loc, env, make_error lid))

let find_component lookup make_error env loc lid =
  try
    match lid with
    | Longident.Ldot (Longident.Lident "*predef*", s) ->
        lookup (Longident.Lident s) Env.initial_safe_string
    | _ -> lookup lid env
  with Not_found ->
    narrow_unbound_lid_error env loc lid make_error
  | Env.Recmodule ->
    raise (Error (loc, env, Illegal_reference_to_recursive_module))

let find_type env loc lid =
  let (path, decl) as r =
    find_component Env.lookup_type (fun lid -> Unbound_type_constructor lid)
      env loc lid
  in
  check_deprecated loc decl.type_attributes (Path.name path);
  r

let find_constructor =
  find_component Env.lookup_constructor (fun lid -> Unbound_constructor lid)
let find_all_constructors =
  find_component Env.lookup_all_constructors
    (fun lid -> Unbound_constructor lid)
let find_label =
  find_component Env.lookup_label (fun lid -> Unbound_label lid)
let find_all_labels =
  find_component Env.lookup_all_labels (fun lid -> Unbound_label lid)

let find_class env loc lid =
  let (path, decl) as r =
    find_component Env.lookup_class (fun lid -> Unbound_class lid) env loc lid
  in
  check_deprecated loc decl.cty_attributes (Path.name path);
  r

let find_value env loc lid =
  Env.check_value_name (Longident.last lid) loc;
  let (path, decl) as r =
    find_component Env.lookup_value (fun lid -> Unbound_value lid) env loc lid
  in
  check_deprecated loc decl.val_attributes (Path.name path);
  r

let lookup_module ?(load=false) env loc lid =
  let (path, decl) as r =
    find_component (fun lid env -> (Env.lookup_module ~load lid env, ()))
      (fun lid -> Unbound_module lid) env loc lid
  in path

let find_module env loc lid =
  let path = lookup_module ~load:true env loc lid in
  let decl = Env.find_module path env in
  check_deprecated loc decl.md_attributes (Path.name path);
  (path, decl)

let find_modtype env loc lid =
  let (path, decl) as r =
    find_component Env.lookup_modtype (fun lid -> Unbound_modtype lid)
      env loc lid
  in
  check_deprecated loc decl.mtd_attributes (Path.name path);
  r

let find_class_type env loc lid =
  let (path, decl) as r =
    find_component Env.lookup_cltype (fun lid -> Unbound_cltype lid)
      env loc lid
  in
  check_deprecated loc decl.clty_attributes (Path.name path);
  r

let unbound_constructor_error env lid =
  narrow_unbound_lid_error env lid.loc lid.txt
    (fun lid -> Unbound_constructor lid)

let unbound_label_error env lid =
  narrow_unbound_lid_error env lid.loc lid.txt
    (fun lid -> Unbound_label lid)

(* Support for first-class modules. *)

let transl_modtype_longident = ref (fun _ -> assert false)
let transl_modtype = ref (fun _ -> assert false)

let create_package_mty fake loc env (p, l) =
  let l =
    List.sort
      (fun (s1, t1) (s2, t2) ->
         if s1.txt = s2.txt then
           raise (Error (loc, env, Multiple_constraints_on_type s1.txt));
         compare s1.txt s2.txt)
      l
  in
  l,
  List.fold_left
    (fun mty (s, t) ->
      let d = {ptype_name = mkloc (Longident.last s.txt) s.loc;
               ptype_params = [];
               ptype_cstrs = [];
               ptype_kind = Ptype_abstract;
               ptype_private = Asttypes.Public;
               ptype_manifest = if fake then None else Some t;
               ptype_attributes = [];
               ptype_loc = loc} in
      Ast_helper.Mty.mk ~loc
        (Pmty_with (mty, [ Pwith_type ({ txt = s.txt; loc }, d) ]))
    )
    (Ast_helper.Mty.mk ~loc (Pmty_ident p))
    l

(* Translation of type expressions *)

let type_variables = ref (Tbl.empty : (string, type_expr) Tbl.t)
let univars        = ref ([] : (string * type_expr) list)
let pre_univars    = ref ([] : type_expr list)
let used_variables = ref (Tbl.empty : (string, type_expr * Location.t) Tbl.t)

let reset_type_variables () =
  reset_global_level ();
  type_variables := Tbl.empty

let narrow () =
  (increase_global_level (), !type_variables)

let widen (gl, tv) =
  restore_global_level gl;
  type_variables := tv

let strict_lowercase c = (c = '_' || c >= 'a' && c <= 'z')

let validate_name = function
    None -> None
  | Some name as s ->
      if name <> "" && strict_lowercase name.[0] then s else None

let new_global_var ?name () =
  new_global_var ?name:(validate_name name) ()
let newvar ?name () =
  newvar ?name:(validate_name name) ()

let type_variable loc name =
  try
    Tbl.find name !type_variables
  with Not_found ->
    raise(Error(loc, Env.empty, Unbound_type_variable ("'" ^ name)))

let transl_type_param env styp =
  let loc = styp.ptyp_loc in
  match styp.ptyp_desc with
    Ptyp_any ->
      let ty = new_global_var ~name:"_" () in
        { ctyp_desc = Ttyp_any; ctyp_type = ty; ctyp_env = env;
          ctyp_loc = loc; ctyp_attributes = styp.ptyp_attributes; }
  | Ptyp_var name ->
      let ty =
        try
          if name <> "" && name.[0] = '_' then
            raise (Error (loc, Env.empty, Invalid_variable_name ("'" ^ name)));
          ignore (Tbl.find name !type_variables);
          raise Already_bound
        with Not_found ->
          let v = new_global_var ~name () in
            type_variables := Tbl.add name v !type_variables;
            v
      in
        { ctyp_desc = Ttyp_var name; ctyp_type = ty; ctyp_env = env;
          ctyp_loc = loc; ctyp_attributes = styp.ptyp_attributes; }
  | _ -> assert false

let wrap_method ty =
  match (Ctype.repr ty).desc with
    Tpoly _ -> ty
  | _ -> Ctype.newty (Tpoly (ty, []))

let new_pre_univar ?name () =
  let v = newvar ?name () in pre_univars := v :: !pre_univars; v

let rec swap_list = function
    x :: y :: l -> y :: x :: swap_list l
  | l -> l

type policy = Fixed | Extensible | Univars

let rec transl_type env policy styp =
  let loc = styp.ptyp_loc in
  let ctyp ctyp_desc ctyp_type =
    { ctyp_desc; ctyp_type; ctyp_env = env;
      ctyp_loc = loc; ctyp_attributes = styp.ptyp_attributes }
  in
  match styp.ptyp_desc with
    Ptyp_any ->
      let ty =
        if policy = Univars then new_pre_univar () else
          if policy = Fixed then
            raise (Error (styp.ptyp_loc, env, Unbound_type_variable "_"))
          else newvar ()
      in
      ctyp Ttyp_any ty
  | Ptyp_var name ->
    let ty =
      if name <> "" && name.[0] = '_' then
        raise (Error (styp.ptyp_loc, env, Invalid_variable_name ("'" ^ name)));
      begin try
        instance env (List.assoc name !univars)
      with Not_found -> try
        instance env (fst(Tbl.find name !used_variables))
      with Not_found ->
        let v =
          if policy = Univars then new_pre_univar ~name () else newvar ~name ()
        in
        used_variables := Tbl.add name (v, styp.ptyp_loc) !used_variables;
        v
      end
    in
    ctyp (Ttyp_var name) ty
  | Ptyp_arrow(l, st1, st2) ->
    let cty1 = transl_type env policy st1 in
    let cty2 = transl_type env policy st2 in
    let ty = newty (Tarrow(l, cty1.ctyp_type, cty2.ctyp_type, Cok)) in
    ctyp (Ttyp_arrow (l, cty1, cty2)) ty
  | Ptyp_tuple stl ->
    if List.length stl < 2 then
      Syntaxerr.ill_formed_ast loc "Tuples must have at least 2 components.";
    let ctys = List.map (transl_type env policy) stl in
    let ty = newty (Ttuple (List.map (fun ctyp -> ctyp.ctyp_type) ctys)) in
    ctyp (Ttyp_tuple ctys) ty
  | Ptyp_constr(lid, stl) ->
      let (path, decl) = find_type env styp.ptyp_loc lid.txt in
      let stl =
        match stl with
        | [ {ptyp_desc=Ptyp_any} as t ] when decl.type_arity > 1 ->
            List.map (fun _ -> t) decl.type_params
        | _ -> stl
      in
      if List.length stl <> decl.type_arity then
        raise(Error(styp.ptyp_loc, env,
                    Type_arity_mismatch(lid.txt, decl.type_arity,
                                        List.length stl)));
      let args = List.map (transl_type env policy) stl in
      let params = instance_list decl.type_params in
      let unify_param =
        match decl.type_manifest with
          None -> unify_var
        | Some ty ->
            if (repr ty).level = Btype.generic_level then unify_var else unify
      in
      List.iter2
        (fun (sty, cty) ty' ->
           try unify_param env ty' cty.ctyp_type with Unify trace ->
             raise (Error(sty.ptyp_loc, env, Type_mismatch (swap_list trace))))
        (List.combine stl args) params;
      let constr =
        newconstr path (List.map (fun ctyp -> ctyp.ctyp_type) args) in
      begin try
        Ctype.enforce_constraints env constr
      with Unify trace ->
        raise (Error(styp.ptyp_loc, env, Type_mismatch trace))
      end;
      ctyp (Ttyp_constr (path, lid, args)) constr
  | Ptyp_object (fields, o) ->
      let fields =
        List.map (fun (s, a, t) -> (s, a, transl_poly_type env policy t))
          fields
      in
      let ty = newobj (transl_fields loc env policy [] o fields) in
      ctyp (Ttyp_object (fields, o)) ty
  | Ptyp_class(lid, stl) ->
      let (path, decl, is_variant) =
        try
          let (path, decl) = Env.lookup_type lid.txt env in
          let rec check decl =
            match decl.type_manifest with
              None -> raise Not_found
            | Some ty ->
                match (repr ty).desc with
                  Tvariant row when Btype.static_row row -> ()
                | Tconstr (path, _, _) ->
                    check (Env.find_type path env)
                | _ -> raise Not_found
          in check decl;
          Location.prerr_warning styp.ptyp_loc
            (Warnings.Deprecated "old syntax for polymorphic variant type");
          (path, decl,true)
        with Not_found -> try
          let lid2 =
            match lid.txt with
              Longident.Lident s     -> Longident.Lident ("#" ^ s)
            | Longident.Ldot(r, s)   -> Longident.Ldot (r, "#" ^ s)
            | Longident.Lapply(_, _) -> fatal_error "Typetexp.transl_type"
          in
          let (path, decl) = Env.lookup_type lid2 env in
          (path, decl, false)
        with Not_found ->
          ignore (find_class env styp.ptyp_loc lid.txt); assert false
      in
      if List.length stl <> decl.type_arity then
        raise(Error(styp.ptyp_loc, env,
                    Type_arity_mismatch(lid.txt, decl.type_arity,
                                        List.length stl)));
      let args = List.map (transl_type env policy) stl in
      let params = instance_list decl.type_params in
      List.iter2
        (fun (sty, cty) ty' ->
           try unify_var env ty' cty.ctyp_type with Unify trace ->
             raise (Error(sty.ptyp_loc, env, Type_mismatch (swap_list trace))))
        (List.combine stl args) params;
        let ty_args = List.map (fun ctyp -> ctyp.ctyp_type) args in
      let ty =
        try Ctype.expand_head env (newconstr path ty_args)
        with Unify trace ->
          raise (Error(styp.ptyp_loc, env, Type_mismatch trace))
      in
      let ty = match ty.desc with
        Tvariant row ->
          let row = Btype.row_repr row in
          let fields =
            List.map
              (fun (l,f) -> l,
                match Btype.row_field_repr f with
                | Rpresent (Some ty) ->
                    Reither(false, [ty], false, ref None)
                | Rpresent None ->
                    Reither (true, [], false, ref None)
                | _ -> f)
              row.row_fields
          in
          let row = { row_closed = true; row_fields = fields;
                      row_bound = (); row_name = Some (path, ty_args);
                      row_fixed = false; row_more = newvar () } in
          let static = Btype.static_row row in
          let row =
            if static then { row with row_more = newty Tnil }
            else if policy <> Univars then row
            else { row with row_more = new_pre_univar () }
          in
          newty (Tvariant row)
      | Tobject (fi, _) ->
          let _, tv = flatten_fields fi in
          if policy = Univars then pre_univars := tv :: !pre_univars;
          ty
      | _ ->
          assert false
      in
      ctyp (Ttyp_class (path, lid, args)) ty
  | Ptyp_alias(st, alias) ->
      let cty =
        try
          let t =
            try List.assoc alias !univars
            with Not_found ->
              instance env (fst(Tbl.find alias !used_variables))
          in
          let ty = transl_type env policy st in
          begin try unify_var env t ty.ctyp_type with Unify trace ->
            let trace = swap_list trace in
            raise(Error(styp.ptyp_loc, env, Alias_type_mismatch trace))
          end;
          ty
        with Not_found ->
          if !Clflags.principal then begin_def ();
          let t = newvar () in
          used_variables := Tbl.add alias (t, styp.ptyp_loc) !used_variables;
          let ty = transl_type env policy st in
          begin try unify_var env t ty.ctyp_type with Unify trace ->
            let trace = swap_list trace in
            raise(Error(styp.ptyp_loc, env, Alias_type_mismatch trace))
          end;
          if !Clflags.principal then begin
            end_def ();
            generalize_structure t;
          end;
          let t = instance env t in
          let px = Btype.proxy t in
          begin match px.desc with
          | Tvar None -> Btype.log_type px; px.desc <- Tvar (Some alias)
          | Tunivar None -> Btype.log_type px; px.desc <- Tunivar (Some alias)
          | _ -> ()
          end;
          { ty with ctyp_type = t }
      in
      ctyp (Ttyp_alias (cty, alias)) cty.ctyp_type
  | Ptyp_variant(fields, closed, present) ->
      let name = ref None in
      let mkfield l f =
        newty (Tvariant {row_fields=[l,f]; row_more=newvar();
                         row_bound=(); row_closed=true;
                         row_fixed=false; row_name=None}) in
      let hfields = Hashtbl.create 17 in
      let add_typed_field loc l f =
        let h = Btype.hash_variant l in
        try
          let (l',f') = Hashtbl.find hfields h in
          (* Check for tag conflicts *)
          if l <> l' then raise(Error(styp.ptyp_loc, env, Variant_tags(l, l')));
          let ty = mkfield l f and ty' = mkfield l f' in
          if equal env false [ty] [ty'] then () else
          try unify env ty ty'
          with Unify trace ->
            raise(Error(loc, env, Constructor_mismatch (ty,ty')))
        with Not_found ->
          Hashtbl.add hfields h (l,f)
      in
      let add_field = function
          Rtag (l, attrs, c, stl) ->
            name := None;
            let tl = List.map (transl_type env policy) stl in
            let f = match present with
              Some present when not (List.mem l present) ->
                let ty_tl = List.map (fun cty -> cty.ctyp_type) tl in
                Reither(c, ty_tl, false, ref None)
            | _ ->
                if List.length stl > 1 || c && stl <> [] then
                  raise(Error(styp.ptyp_loc, env, Present_has_conjunction l));
                match tl with [] -> Rpresent None
                | st :: _ ->
                      Rpresent (Some st.ctyp_type)
            in
            add_typed_field styp.ptyp_loc l f;
              Ttag (l,attrs,c,tl)
        | Rinherit sty ->
            let cty = transl_type env policy sty in
            let ty = cty.ctyp_type in
            let nm =
              match repr cty.ctyp_type with
                {desc=Tconstr(p, tl, _)} -> Some(p, tl)
              | _                        -> None
            in
            begin try
              (* Set name if there are no fields yet *)
              Hashtbl.iter (fun _ _ -> raise Exit) hfields;
              name := nm
            with Exit ->
              (* Unset it otherwise *)
              name := None
            end;
            let fl = match expand_head env cty.ctyp_type, nm with
              {desc=Tvariant row}, _ when Btype.static_row row ->
                let row = Btype.row_repr row in
                row.row_fields
            | {desc=Tvar _}, Some(p, _) ->
                raise(Error(sty.ptyp_loc, env, Unbound_type_constructor_2 p))
            | _ ->
                raise(Error(sty.ptyp_loc, env, Not_a_variant ty))
            in
            List.iter
              (fun (l, f) ->
                let f = match present with
                  Some present when not (List.mem l present) ->
                    begin match f with
                      Rpresent(Some ty) ->
                        Reither(false, [ty], false, ref None)
                    | Rpresent None ->
                        Reither(true, [], false, ref None)
                    | _ ->
                        assert false
                    end
                | _ -> f
                in
                add_typed_field sty.ptyp_loc l f)
              fl;
              Tinherit cty
      in
      let tfields = List.map add_field fields in
      let fields = Hashtbl.fold (fun _ p l -> p :: l) hfields [] in
      begin match present with None -> ()
      | Some present ->
          List.iter
            (fun l -> if not (List.mem_assoc l fields) then
              raise(Error(styp.ptyp_loc, env, Present_has_no_type l)))
            present
      end;
      let row =
        { row_fields = List.rev fields; row_more = newvar ();
          row_bound = (); row_closed = (closed = Closed);
          row_fixed = false; row_name = !name } in
      let static = Btype.static_row row in
      let row =
        if static then { row with row_more = newty Tnil }
        else if policy <> Univars then row
        else { row with row_more = new_pre_univar () }
      in
      let ty = newty (Tvariant row) in
      ctyp (Ttyp_variant (tfields, closed, present)) ty
   | Ptyp_poly(vars, st) ->
      begin_def();
      let new_univars = List.map (fun name -> name, newvar ~name ()) vars in
      let old_univars = !univars in
      univars := new_univars @ !univars;
      let cty = transl_type env policy st in
      let ty = cty.ctyp_type in
      univars := old_univars;
      end_def();
      generalize ty;
      let ty_list =
        List.fold_left
          (fun tyl (name, ty1) ->
            let v = Btype.proxy ty1 in
            if deep_occur v ty then begin
              match v.desc with
                Tvar name when v.level = Btype.generic_level ->
                  v.desc <- Tunivar name;
                  v :: tyl
              | _ ->
                raise (Error (styp.ptyp_loc, env, Cannot_quantify (name, v)))
            end else tyl)
          [] new_univars
      in
      let ty' = Btype.newgenty (Tpoly(ty, List.rev ty_list)) in
      unify_var env (newvar()) ty';
      ctyp (Ttyp_poly (vars, cty)) ty'
  | Ptyp_package (p, l) ->
      let l, mty = create_package_mty true styp.ptyp_loc env (p, l) in
      let z = narrow () in
      let mty = !transl_modtype env mty in
      widen z;
      let ptys = List.map (fun (s, pty) ->
                             s, transl_type env policy pty
                          ) l in
      let path = !transl_modtype_longident styp.ptyp_loc env p.txt in
      let ty = newty (Tpackage (path,
                       List.map (fun (s, pty) -> s.txt) l,
                       List.map (fun (_,cty) -> cty.ctyp_type) ptys))
      in
      ctyp (Ttyp_package {
            pack_path = path;
            pack_type = mty.mty_type;
            pack_fields = ptys;
            pack_txt = p;
           }) ty
  | Ptyp_extension ext ->
      raise (Error_forward (error_of_extension ext))

and transl_poly_type env policy t =
  transl_type env policy (Ast_helper.Typ.force_poly t)

and transl_fields loc env policy seen o =
  function
    [] ->
      begin match o, policy with
      | Closed, _ -> newty Tnil
      | Open, Univars -> new_pre_univar ()
      | Open, _ -> newvar ()
      end
  | (s, _attrs, ty1) :: l ->
      if List.mem s seen then raise (Error (loc, env, Repeated_method_label s));
      let ty2 = transl_fields loc env policy (s :: seen) o l in
      newty (Tfield (s, Fpresent, ty1.ctyp_type, ty2))

(* Make the rows "fixed" in this type, to make universal check easier *)
let rec make_fixed_univars ty =
  let ty = repr ty in
  if ty.level >= Btype.lowest_level then begin
    Btype.mark_type_node ty;
    match ty.desc with
    | Tvariant row ->
        let row = Btype.row_repr row in
        if Btype.is_Tunivar (Btype.row_more row) then
          ty.desc <- Tvariant
              {row with row_fixed=true;
               row_fields = List.map
                 (fun (s,f as p) -> match Btype.row_field_repr f with
                   Reither (c, tl, m, r) -> s, Reither (c, tl, true, r)
                 | _ -> p)
                 row.row_fields};
        Btype.iter_row make_fixed_univars row
    | _ ->
        Btype.iter_type_expr make_fixed_univars ty
  end

let make_fixed_univars ty =
  make_fixed_univars ty;
  Btype.unmark_type ty

let create_package_mty = create_package_mty false

let globalize_used_variables env fixed =
  let r = ref [] in
  Tbl.iter
    (fun name (ty, loc) ->
      let v = new_global_var () in
      let snap = Btype.snapshot () in
      if try unify env v ty; true with _ -> Btype.backtrack snap; false
      then try
        r := (loc, v,  Tbl.find name !type_variables) :: !r
      with Not_found ->
        if fixed && Btype.is_Tvar (repr ty) then
          raise(Error(loc, env, Unbound_type_variable ("'"^name)));
        let v2 = new_global_var () in
        r := (loc, v, v2) :: !r;
        type_variables := Tbl.add name v2 !type_variables)
    !used_variables;
  used_variables := Tbl.empty;
  fun () ->
    List.iter
      (function (loc, t1, t2) ->
        try unify env t1 t2 with Unify trace ->
          raise (Error(loc, env, Type_mismatch trace)))
      !r

let transl_simple_type env fixed styp =
  univars := []; used_variables := Tbl.empty;
  let typ = transl_type env (if fixed then Fixed else Extensible) styp in
  globalize_used_variables env fixed ();
  make_fixed_univars typ.ctyp_type;
  typ

let transl_simple_type_univars env styp =
  univars := []; used_variables := Tbl.empty; pre_univars := [];
  begin_def ();
  let typ = transl_type env Univars styp in
  (* Only keep already global variables in used_variables *)
  let new_variables = !used_variables in
  used_variables := Tbl.empty;
  Tbl.iter
    (fun name p ->
      if Tbl.mem name !type_variables then
        used_variables := Tbl.add name p !used_variables)
    new_variables;
  globalize_used_variables env false ();
  end_def ();
  generalize typ.ctyp_type;
  let univs =
    List.fold_left
      (fun acc v ->
        let v = repr v in
        match v.desc with
          Tvar name when v.level = Btype.generic_level ->
            v.desc <- Tunivar name; v :: acc
        | _ -> acc)
      [] !pre_univars
  in
  make_fixed_univars typ.ctyp_type;
    { typ with ctyp_type =
        instance env (Btype.newgenty (Tpoly (typ.ctyp_type, univs))) }

let transl_simple_type_delayed env styp =
  univars := []; used_variables := Tbl.empty;
  let typ = transl_type env Extensible styp in
  make_fixed_univars typ.ctyp_type;
  (typ, globalize_used_variables env false)

let transl_type_scheme env styp =
  reset_type_variables();
  begin_def();
  let typ = transl_simple_type env false styp in
  end_def();
  generalize typ.ctyp_type;
  typ


(* Error report *)

open Format
open Printtyp

let spellcheck ppf fold env lid =
  let cutoff =
    match String.length (Longident.last lid) with
      | 1 | 2 -> 0
      | 3 | 4 -> 1
      | 5 | 6 -> 2
      | _ -> 3
  in
  let compare target head acc =
    let (best_choice, best_dist) = acc in
    match Misc.edit_distance target head cutoff with
      | None -> (best_choice, best_dist)
      | Some dist ->
        let choice =
          if dist < best_dist then [head]
          else if dist = best_dist then head :: best_choice
          else best_choice in
        (choice, min dist best_dist)
  in
  let init = ([], max_int) in
  let handle (choice, _dist) =
    match List.rev choice with
      | [] -> ()
      | last :: rev_rest ->
        fprintf ppf "@\nHint: Did you mean %s%s%s?"
          (String.concat ", " (List.rev rev_rest))
          (if rev_rest = [] then "" else " or ")
          last
  in
  (* flush now to get the error report early, in the (unheard of) case
     where the linear search would take a bit of time; in the worst
     case, the user has seen the error, she can interrupt the process
     before the spell-checking terminates. *)
  fprintf ppf "@?";
  match lid with
    | Longident.Lapply _ -> ()
    | Longident.Lident s ->
      handle (fold (compare s) None env init)
    | Longident.Ldot (r, s) ->
      handle (fold (compare s) (Some r) env init)

let spellcheck_simple ppf fold extr =
  spellcheck ppf (fun f -> fold (fun decl x -> f (extr decl) x))

let spellcheck ppf fold =
  spellcheck ppf (fun f -> fold (fun s _ _ x -> f s x))

type cd = string list * int

let report_error env ppf = function
  | Unbound_type_variable name ->
    fprintf ppf "Unbound type parameter %s@." name
  | Unbound_type_constructor lid ->
    fprintf ppf "Unbound type constructor %a" longident lid;
    spellcheck ppf Env.fold_types env lid;
  | Unbound_type_constructor_2 p ->
    fprintf ppf "The type constructor@ %a@ is not yet completely defined"
      path p
  | Type_arity_mismatch(lid, expected, provided) ->
    fprintf ppf
      "@[The type constructor %a@ expects %i argument(s),@ \
        but is here applied to %i argument(s)@]"
      longident lid expected provided
  | Bound_type_variable name ->
    fprintf ppf "Already bound type parameter '%s" name
  | Recursive_type ->
    fprintf ppf "This type is recursive"
  | Unbound_row_variable lid ->
      (* we don't use "spellcheck" here: this error is not raised
         anywhere so it's unclear how it should be handled *)
      fprintf ppf "Unbound row variable in #%a" longident lid
  | Type_mismatch trace ->
      Printtyp.report_unification_error ppf Env.empty trace
        (function ppf ->
           fprintf ppf "This type")
        (function ppf ->
           fprintf ppf "should be an instance of type")
  | Alias_type_mismatch trace ->
      Printtyp.report_unification_error ppf Env.empty trace
        (function ppf ->
           fprintf ppf "This alias is bound to type")
        (function ppf ->
           fprintf ppf "but is used as an instance of type")
  | Present_has_conjunction l ->
      fprintf ppf "The present constructor %s has a conjunctive type" l
  | Present_has_no_type l ->
      fprintf ppf "The present constructor %s has no type" l
  | Constructor_mismatch (ty, ty') ->
      wrap_printing_env env (fun ()  ->
        Printtyp.reset_and_mark_loops_list [ty; ty'];
        fprintf ppf "@[<hov>%s %a@ %s@ %a@]"
          "This variant type contains a constructor"
          Printtyp.type_expr ty
          "which should be"
          Printtyp.type_expr ty')
  | Not_a_variant ty ->
      Printtyp.reset_and_mark_loops ty;
      fprintf ppf "@[The type %a@ is not a polymorphic variant type@]"
        Printtyp.type_expr ty
  | Variant_tags (lab1, lab2) ->
      fprintf ppf
        "@[Variant tags `%s@ and `%s have the same hash value.@ %s@]"
        lab1 lab2 "Change one of them."
  | Invalid_variable_name name ->
      fprintf ppf "The type variable name %s is not allowed in programs" name
  | Cannot_quantify (name, v) ->
      fprintf ppf
        "@[<hov>The universal type variable '%s cannot be generalized:@ %s.@]"
        name
        (if Btype.is_Tvar v then "it escapes its scope" else
         if Btype.is_Tunivar v then "it is already bound to another variable"
         else "it is not a variable")
  | Multiple_constraints_on_type s ->
      fprintf ppf "Multiple constraints for type %a" longident s
  | Repeated_method_label s ->
      fprintf ppf "@[This is the second method `%s' of this object type.@ %s@]"
        s "Multiple occurences are not allowed."
  | Unbound_value lid ->
      fprintf ppf "Unbound value %a" longident lid;
      spellcheck ppf Env.fold_values env lid;
  | Unbound_module lid ->
      fprintf ppf "Unbound module %a" longident lid;
      spellcheck ppf Env.fold_modules env lid;
  | Unbound_constructor lid ->
      fprintf ppf "Unbound constructor %a" longident lid;
      spellcheck_simple ppf Env.fold_constructors (fun d -> d.cstr_name)
        env lid;
  | Unbound_label lid ->
      fprintf ppf "Unbound record field %a" longident lid;
      spellcheck_simple ppf Env.fold_labels (fun d -> d.lbl_name) env lid;
  | Unbound_class lid ->
      fprintf ppf "Unbound class %a" longident lid;
      spellcheck ppf Env.fold_classs env lid;
  | Unbound_modtype lid ->
      fprintf ppf "Unbound module type %a" longident lid;
      spellcheck ppf Env.fold_modtypes env lid;
  | Unbound_cltype lid ->
      fprintf ppf "Unbound class type %a" longident lid;
      spellcheck ppf Env.fold_cltypes env lid;
  | Ill_typed_functor_application lid ->
      fprintf ppf "Ill-typed functor application %a" longident lid
  | Illegal_reference_to_recursive_module ->
      fprintf ppf "Illegal recursive module reference"
  | Access_functor_as_structure lid ->
      fprintf ppf "The module %a is a functor, not a structure" longident lid

let () =
  Location.register_error_of_exn
    (function
      | Error (loc, env, err) ->
        Some (Location.error_of_printer loc (report_error env) err)
      | Error_forward err ->
        Some err
      | _ ->
        None
    )

end
module Typecore : sig
(*#1 "typecore.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Type inference for the core language *)

open Asttypes
open Types
open Format

val is_nonexpansive: Typedtree.expression -> bool

val type_binding:
        Env.t -> rec_flag ->
          Parsetree.value_binding list ->
          Annot.ident option ->
          Typedtree.value_binding list * Env.t
val type_let:
        Env.t -> rec_flag ->
          Parsetree.value_binding list ->
          Annot.ident option ->
          Typedtree.value_binding list * Env.t
val type_expression:
        Env.t -> Parsetree.expression -> Typedtree.expression
val type_class_arg_pattern:
        string -> Env.t -> Env.t -> label -> Parsetree.pattern ->
        Typedtree.pattern * (Ident.t * string loc * Ident.t * type_expr) list *
        Env.t * Env.t
val type_self_pattern:
        string -> type_expr -> Env.t -> Env.t -> Env.t -> Parsetree.pattern ->
        Typedtree.pattern *
        (Ident.t * type_expr) Meths.t ref *
        (Ident.t * Asttypes.mutable_flag * Asttypes.virtual_flag * type_expr)
            Vars.t ref *
        Env.t * Env.t * Env.t
val check_partial:
        ?lev:int -> Env.t -> type_expr ->
	Location.t -> Typedtree.case list -> Typedtree.partial
val type_expect:
        ?in_function:(Location.t * type_expr) ->
        Env.t -> Parsetree.expression -> type_expr -> Typedtree.expression
val type_exp:
        Env.t -> Parsetree.expression -> Typedtree.expression
val type_approx:
        Env.t -> Parsetree.expression -> type_expr
val type_argument:
        Env.t -> Parsetree.expression ->
        type_expr -> type_expr -> Typedtree.expression

val option_some: Typedtree.expression -> Typedtree.expression
val option_none: type_expr -> Location.t -> Typedtree.expression
val extract_option_type: Env.t -> type_expr -> type_expr
val iter_pattern: (Typedtree.pattern -> unit) -> Typedtree.pattern -> unit
val generalizable: int -> type_expr -> bool
val reset_delayed_checks: unit -> unit
val force_delayed_checks: unit -> unit

val self_coercion : (Path.t * Location.t list ref) list ref

type error =
    Polymorphic_label of Longident.t
  | Constructor_arity_mismatch of Longident.t * int * int
  | Label_mismatch of Longident.t * (type_expr * type_expr) list
  | Pattern_type_clash of (type_expr * type_expr) list
  | Or_pattern_type_clash of Ident.t * (type_expr * type_expr) list
  | Multiply_bound_variable of string
  | Orpat_vars of Ident.t
  | Expr_type_clash of (type_expr * type_expr) list
  | Apply_non_function of type_expr
  | Apply_wrong_label of label * type_expr
  | Label_multiply_defined of string
  | Label_missing of Ident.t list
  | Label_not_mutable of Longident.t
  | Wrong_name of string * type_expr * string * Path.t * Longident.t
  | Name_type_mismatch of
      string * Longident.t * (Path.t * Path.t) * (Path.t * Path.t) list
  | Invalid_format of string
  | Undefined_method of type_expr * string
  | Undefined_inherited_method of string
  | Virtual_class of Longident.t
  | Private_type of type_expr
  | Private_label of Longident.t * type_expr
  | Unbound_instance_variable of string
  | Instance_variable_not_mutable of bool * string
  | Not_subtype of (type_expr * type_expr) list * (type_expr * type_expr) list
  | Outside_class
  | Value_multiply_overridden of string
  | Coercion_failure of
      type_expr * type_expr * (type_expr * type_expr) list * bool
  | Too_many_arguments of bool * type_expr
  | Abstract_wrong_label of label * type_expr
  | Scoping_let_module of string * type_expr
  | Masked_instance_variable of Longident.t
  | Not_a_variant_type of Longident.t
  | Incoherent_label_order
  | Less_general of string * (type_expr * type_expr) list
  | Modules_not_allowed
  | Cannot_infer_signature
  | Not_a_packed_module of type_expr
  | Recursive_local_constraint of (type_expr * type_expr) list
  | Unexpected_existential
  | Unqualified_gadt_pattern of Path.t * string
  | Invalid_interval
  | Invalid_for_loop_index
  | No_value_clauses
  | Exception_pattern_below_toplevel

exception Error of Location.t * Env.t * error
exception Error_forward of Location.error

val report_error: Env.t -> formatter -> error -> unit
 (* Deprecated.  Use Location.{error_of_exn, report_error}. *)

(* Forward declaration, to be filled in by Typemod.type_module *)
val type_module: (Env.t -> Parsetree.module_expr -> Typedtree.module_expr) ref
(* Forward declaration, to be filled in by Typemod.type_open *)
val type_open:
    (override_flag -> Env.t -> Location.t -> Longident.t loc -> Path.t * Env.t)
    ref
(* Forward declaration, to be filled in by Typeclass.class_structure *)
val type_object:
  (Env.t -> Location.t -> Parsetree.class_structure ->
   Typedtree.class_structure * Types.class_signature * string list) ref
val type_package:
  (Env.t -> Parsetree.module_expr -> Path.t -> Longident.t list ->
  type_expr list -> Typedtree.module_expr * type_expr list) ref

val create_package_type : Location.t -> Env.t ->
  Longident.t * (Longident.t * Parsetree.core_type) list ->
  Path.t * (Longident.t * Typedtree.core_type) list * Types.type_expr

end = struct
(*#1 "typecore.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Typechecking for the core language *)

open Misc
open Asttypes
open Parsetree
open Types
open Typedtree
open Btype
open Ctype

type error =
    Polymorphic_label of Longident.t
  | Constructor_arity_mismatch of Longident.t * int * int
  | Label_mismatch of Longident.t * (type_expr * type_expr) list
  | Pattern_type_clash of (type_expr * type_expr) list
  | Or_pattern_type_clash of Ident.t * (type_expr * type_expr) list
  | Multiply_bound_variable of string
  | Orpat_vars of Ident.t
  | Expr_type_clash of (type_expr * type_expr) list
  | Apply_non_function of type_expr
  | Apply_wrong_label of label * type_expr
  | Label_multiply_defined of string
  | Label_missing of Ident.t list
  | Label_not_mutable of Longident.t
  | Wrong_name of string * type_expr * string * Path.t * Longident.t
  | Name_type_mismatch of
      string * Longident.t * (Path.t * Path.t) * (Path.t * Path.t) list
  | Invalid_format of string
  | Undefined_method of type_expr * string
  | Undefined_inherited_method of string
  | Virtual_class of Longident.t
  | Private_type of type_expr
  | Private_label of Longident.t * type_expr
  | Unbound_instance_variable of string
  | Instance_variable_not_mutable of bool * string
  | Not_subtype of (type_expr * type_expr) list * (type_expr * type_expr) list
  | Outside_class
  | Value_multiply_overridden of string
  | Coercion_failure of
      type_expr * type_expr * (type_expr * type_expr) list * bool
  | Too_many_arguments of bool * type_expr
  | Abstract_wrong_label of label * type_expr
  | Scoping_let_module of string * type_expr
  | Masked_instance_variable of Longident.t
  | Not_a_variant_type of Longident.t
  | Incoherent_label_order
  | Less_general of string * (type_expr * type_expr) list
  | Modules_not_allowed
  | Cannot_infer_signature
  | Not_a_packed_module of type_expr
  | Recursive_local_constraint of (type_expr * type_expr) list
  | Unexpected_existential
  | Unqualified_gadt_pattern of Path.t * string
  | Invalid_interval
  | Invalid_for_loop_index
  | No_value_clauses
  | Exception_pattern_below_toplevel

exception Error of Location.t * Env.t * error
exception Error_forward of Location.error

(* Forward declaration, to be filled in by Typemod.type_module *)

let type_module =
  ref ((fun env md -> assert false) :
       Env.t -> Parsetree.module_expr -> Typedtree.module_expr)

(* Forward declaration, to be filled in by Typemod.type_open *)

let type_open =
  ref (fun _ -> assert false)

(* Forward declaration, to be filled in by Typemod.type_package *)

let type_package =
  ref (fun _ -> assert false)

(* Forward declaration, to be filled in by Typeclass.class_structure *)
let type_object =
  ref (fun env s -> assert false :
       Env.t -> Location.t -> Parsetree.class_structure ->
         Typedtree.class_structure * Types.class_signature * string list)

(*
  Saving and outputting type information.
  We keep these function names short, because they have to be
  called each time we create a record of type [Typedtree.expression]
  or [Typedtree.pattern] that will end up in the typed AST.
*)
let re node =
  Cmt_format.add_saved_type (Cmt_format.Partial_expression node);
  Stypes.record (Stypes.Ti_expr node);
  node
;;
let rp node =
  Cmt_format.add_saved_type (Cmt_format.Partial_pattern node);
  Stypes.record (Stypes.Ti_pat node);
  node
;;


let fst3 (x, _, _) = x
let snd3 (_,x,_) = x

let case lhs rhs =
  {c_lhs = lhs; c_guard = None; c_rhs = rhs}

(* Upper approximation of free identifiers on the parse tree *)

let iter_expression f e =

  let rec expr e =
    f e;
    match e.pexp_desc with
    | Pexp_extension _ (* we don't iterate under extension point *)
    | Pexp_ident _
    | Pexp_new _
    | Pexp_constant _ -> ()
    | Pexp_function pel -> List.iter case pel
    | Pexp_fun (_, eo, _, e) -> may expr eo; expr e
    | Pexp_apply (e, lel) -> expr e; List.iter (fun (_, e) -> expr e) lel
    | Pexp_let (_, pel, e) ->  expr e; List.iter binding pel
    | Pexp_match (e, pel)
    | Pexp_try (e, pel) -> expr e; List.iter case pel
    | Pexp_array el
    | Pexp_tuple el -> List.iter expr el
    | Pexp_construct (_, eo)
    | Pexp_variant (_, eo) -> may expr eo
    | Pexp_record (iel, eo) ->
        may expr eo; List.iter (fun (_, e) -> expr e) iel
    | Pexp_open (_, _, e)
    | Pexp_newtype (_, e)
    | Pexp_poly (e, _)
    | Pexp_lazy e
    | Pexp_assert e
    | Pexp_setinstvar (_, e)
    | Pexp_send (e, _)
    | Pexp_constraint (e, _)
    | Pexp_coerce (e, _, _)
    | Pexp_field (e, _) -> expr e
    | Pexp_while (e1, e2)
    | Pexp_sequence (e1, e2)
    | Pexp_setfield (e1, _, e2) -> expr e1; expr e2
    | Pexp_ifthenelse (e1, e2, eo) -> expr e1; expr e2; may expr eo
    | Pexp_for (_, e1, e2, _, e3) -> expr e1; expr e2; expr e3
    | Pexp_override sel -> List.iter (fun (_, e) -> expr e) sel
    | Pexp_letmodule (_, me, e) -> expr e; module_expr me
    | Pexp_object { pcstr_fields = fs } -> List.iter class_field fs
    | Pexp_pack me -> module_expr me

  and case {pc_lhs = _; pc_guard; pc_rhs} =
    may expr pc_guard;
    expr pc_rhs

  and binding x =
    expr x.pvb_expr

  and module_expr me =
    match me.pmod_desc with
    | Pmod_extension _
    | Pmod_ident _ -> ()
    | Pmod_structure str -> List.iter structure_item str
    | Pmod_constraint (me, _)
    | Pmod_functor (_, _, me) -> module_expr me
    | Pmod_apply (me1, me2) -> module_expr me1; module_expr me2
    | Pmod_unpack e -> expr e


  and structure_item str =
    match str.pstr_desc with
    | Pstr_eval (e, _) -> expr e
    | Pstr_value (_, pel) -> List.iter binding pel
    | Pstr_primitive _
    | Pstr_type _
    | Pstr_typext _
    | Pstr_exception _
    | Pstr_modtype _
    | Pstr_open _
    | Pstr_class_type _
    | Pstr_attribute _
    | Pstr_extension _ -> ()
    | Pstr_include {pincl_mod = me}
    | Pstr_module {pmb_expr = me} -> module_expr me
    | Pstr_recmodule l -> List.iter (fun x -> module_expr x.pmb_expr) l
    | Pstr_class cdl -> List.iter (fun c -> class_expr c.pci_expr) cdl

  and class_expr ce =
    match ce.pcl_desc with
    | Pcl_constr _ -> ()
    | Pcl_structure { pcstr_fields = fs } -> List.iter class_field fs
    | Pcl_fun (_, eo, _,  ce) -> may expr eo; class_expr ce
    | Pcl_apply (ce, lel) ->
        class_expr ce; List.iter (fun (_, e) -> expr e) lel
    | Pcl_let (_, pel, ce) ->
        List.iter binding pel; class_expr ce
    | Pcl_constraint (ce, _) -> class_expr ce
    | Pcl_extension _ -> ()

  and class_field cf =
    match cf.pcf_desc with
    | Pcf_inherit (_, ce, _) -> class_expr ce
    | Pcf_val (_, _, Cfk_virtual _)
    | Pcf_method (_, _, Cfk_virtual _ ) | Pcf_constraint _ -> ()
    | Pcf_val (_, _, Cfk_concrete (_, e))
    | Pcf_method (_, _, Cfk_concrete (_, e)) -> expr e
    | Pcf_initializer e -> expr e
    | Pcf_attribute _ | Pcf_extension _ -> ()

  in
  expr e


let all_idents_cases el =
  let idents = Hashtbl.create 8 in
  let f = function
    | {pexp_desc=Pexp_ident { txt = Longident.Lident id; _ }; _} ->
        Hashtbl.replace idents id ()
    | _ -> ()
  in
  List.iter
    (fun cp ->
      may (iter_expression f) cp.pc_guard;
      iter_expression f cp.pc_rhs
    )
    el;
  Hashtbl.fold (fun x () rest -> x :: rest) idents []


(* Typing of constants *)

let type_constant = function
    Const_int _ -> instance_def Predef.type_int
  | Const_char _ -> instance_def Predef.type_char
  | Const_string _ -> instance_def Predef.type_string
  | Const_float _ -> instance_def Predef.type_float
  | Const_int32 _ -> instance_def Predef.type_int32
  | Const_int64 _ -> instance_def Predef.type_int64
  | Const_nativeint _ -> instance_def Predef.type_nativeint

(* Specific version of type_option, using newty rather than newgenty *)

let type_option ty =
  newty (Tconstr(Predef.path_option,[ty], ref Mnil))

let mkexp exp_desc exp_type exp_loc exp_env =
  { exp_desc; exp_type; exp_loc; exp_env; exp_extra = []; exp_attributes = [] }

let option_none ty loc =
  let lid = Longident.Lident "None"
  and env = Env.initial_safe_string in
  let cnone = Env.lookup_constructor lid env in
  mkexp (Texp_construct(mknoloc lid, cnone, [])) ty loc env

let option_some texp =
  let lid = Longident.Lident "Some" in
  let csome = Env.lookup_constructor lid Env.initial_safe_string in
  mkexp ( Texp_construct(mknoloc lid , csome, [texp]) )
    (type_option texp.exp_type) texp.exp_loc texp.exp_env

let extract_option_type env ty =
  match expand_head env ty with {desc = Tconstr(path, [ty], _)}
    when Path.same path Predef.path_option -> ty
  | _ -> assert false

let extract_concrete_record env ty =
  match extract_concrete_typedecl env ty with
    (p0, p, {type_kind=Type_record (fields, _)}) -> (p0, p, fields)
  | _ -> raise Not_found

let extract_concrete_variant env ty =
  match extract_concrete_typedecl env ty with
    (p0, p, {type_kind=Type_variant cstrs}) -> (p0, p, cstrs)
  | (p0, p, {type_kind=Type_open}) -> (p0, p, [])
  | _ -> raise Not_found

let extract_label_names sexp env ty =
  try
    let (_, _,fields) = extract_concrete_record env ty in
    List.map (fun l -> l.Types.ld_id) fields
  with Not_found ->
    assert false

let explicit_arity =
  List.exists
    (function
      | ({txt="ocaml.explicit_arity"|"explicit_arity"; _}, _) -> true
      | _ -> false
    )

(* Typing of patterns *)

(* unification inside type_pat*)
let unify_pat_types loc env ty ty' =
  try
    unify env ty ty'
  with
    Unify trace ->
      raise(Error(loc, env, Pattern_type_clash(trace)))
  | Tags(l1,l2) ->
      raise(Typetexp.Error(loc, env, Typetexp.Variant_tags (l1, l2)))

(* unification inside type_exp and type_expect *)
let unify_exp_types loc env ty expected_ty =
  (* Format.eprintf "@[%a@ %a@]@." Printtyp.raw_type_expr exp.exp_type
    Printtyp.raw_type_expr expected_ty; *)
  try
    unify env ty expected_ty
  with
    Unify trace ->
      raise(Error(loc, env, Expr_type_clash(trace)))
  | Tags(l1,l2) ->
      raise(Typetexp.Error(loc, env, Typetexp.Variant_tags (l1, l2)))

(* level at which to create the local type declarations *)
let newtype_level = ref None
let get_newtype_level () =
  match !newtype_level with
    Some y -> y
  | None -> assert false

let unify_pat_types_gadt loc env ty ty' =
  let newtype_level =
    match !newtype_level with
    | None -> assert false
    | Some x -> x
  in
  try
    unify_gadt ~newtype_level env ty ty'
  with
    Unify trace ->
      raise(Error(loc, !env, Pattern_type_clash(trace)))
  | Tags(l1,l2) ->
      raise(Typetexp.Error(loc, !env, Typetexp.Variant_tags (l1, l2)))
  | Unification_recursive_abbrev trace ->
      raise(Error(loc, !env, Recursive_local_constraint trace))


(* Creating new conjunctive types is not allowed when typing patterns *)

let unify_pat env pat expected_ty =
  unify_pat_types pat.pat_loc env pat.pat_type expected_ty

(* make all Reither present in open variants *)
let finalize_variant pat =
  match pat.pat_desc with
    Tpat_variant(tag, opat, r) ->
      let row =
        match expand_head pat.pat_env pat.pat_type with
          {desc = Tvariant row} -> r := row; row_repr row
        | _ -> assert false
      in
      begin match row_field tag row with
      | Rabsent -> () (* assert false *)
      | Reither (true, [], _, e) when not row.row_closed ->
          set_row_field e (Rpresent None)
      | Reither (false, ty::tl, _, e) when not row.row_closed ->
          set_row_field e (Rpresent (Some ty));
          begin match opat with None -> assert false
          | Some pat -> List.iter (unify_pat pat.pat_env pat) (ty::tl)
          end
      | Reither (c, l, true, e) when not (row_fixed row) ->
          set_row_field e (Reither (c, [], false, ref None))
      | _ -> ()
      end;
      (* Force check of well-formedness   WHY? *)
      (* unify_pat pat.pat_env pat
        (newty(Tvariant{row_fields=[]; row_more=newvar(); row_closed=false;
                        row_bound=(); row_fixed=false; row_name=None})); *)
  | _ -> ()

let rec iter_pattern f p =
  f p;
  iter_pattern_desc (iter_pattern f) p.pat_desc

let has_variants p =
  try
    iter_pattern (function {pat_desc=Tpat_variant _} -> raise Exit | _ -> ())
      p;
    false
  with Exit ->
    true


(* pattern environment *)
let pattern_variables = ref ([] :
 (Ident.t * type_expr * string loc * Location.t * bool (* as-variable *)) list)
let pattern_force = ref ([] : (unit -> unit) list)
let pattern_scope = ref (None : Annot.ident option);;
let allow_modules = ref false
let module_variables = ref ([] : (string loc * Location.t) list)
let reset_pattern scope allow =
  pattern_variables := [];
  pattern_force := [];
  pattern_scope := scope;
  allow_modules := allow;
  module_variables := [];
;;

let enter_variable ?(is_module=false) ?(is_as_variable=false) loc name ty =
  if List.exists (fun (id, _, _, _, _) -> Ident.name id = name.txt)
      !pattern_variables
  then raise(Error(loc, Env.empty, Multiply_bound_variable name.txt));
  let id = Ident.create name.txt in
  pattern_variables :=
    (id, ty, name, loc, is_as_variable) :: !pattern_variables;
  if is_module then begin
    (* Note: unpack patterns enter a variable of the same name *)
    if not !allow_modules then
      raise (Error (loc, Env.empty, Modules_not_allowed));
    module_variables := (name, loc) :: !module_variables
  end else
    (* moved to genannot *)
    may (fun s -> Stypes.record (Stypes.An_ident (name.loc, name.txt, s)))
        !pattern_scope;
  id

let sort_pattern_variables vs =
  List.sort
    (fun (x,_,_,_,_) (y,_,_,_,_) ->
      Stdlib.compare (Ident.name x) (Ident.name y))
    vs

let enter_orpat_variables loc env  p1_vs p2_vs =
  (* unify_vars operate on sorted lists *)

  let p1_vs = sort_pattern_variables p1_vs
  and p2_vs = sort_pattern_variables p2_vs in

  let rec unify_vars p1_vs p2_vs = match p1_vs, p2_vs with
      | (x1,t1,_,l1,a1)::rem1, (x2,t2,_,l2,a2)::rem2 when Ident.equal x1 x2 ->
          if x1==x2 then
            unify_vars rem1 rem2
          else begin
            begin try
              unify env t1 t2
            with
            | Unify trace ->
                raise(Error(loc, env, Or_pattern_type_clash(x1, trace)))
            end;
          (x2,x1)::unify_vars rem1 rem2
          end
      | [],[] -> []
      | (x,_,_,_,_)::_, [] -> raise (Error (loc, env, Orpat_vars x))
      | [],(x,_,_,_,_)::_  -> raise (Error (loc, env, Orpat_vars x))
      | (x,_,_,_,_)::_, (y,_,_,_,_)::_ ->
          let min_var =
            if Ident.name x < Ident.name y then x
            else y in
          raise (Error (loc, env, Orpat_vars min_var)) in
  unify_vars p1_vs p2_vs

let rec build_as_type env p =
  match p.pat_desc with
    Tpat_alias(p1,_, _) -> build_as_type env p1
  | Tpat_tuple pl ->
      let tyl = List.map (build_as_type env) pl in
      newty (Ttuple tyl)
  | Tpat_construct(_, cstr, pl) ->
      let keep = cstr.cstr_private = Private || cstr.cstr_existentials <> [] in
      if keep then p.pat_type else
      let tyl = List.map (build_as_type env) pl in
      let ty_args, ty_res = instance_constructor cstr in
      List.iter2 (fun (p,ty) -> unify_pat env {p with pat_type = ty})
        (List.combine pl tyl) ty_args;
      ty_res
  | Tpat_variant(l, p', _) ->
      let ty = may_map (build_as_type env) p' in
      newty (Tvariant{row_fields=[l, Rpresent ty]; row_more=newvar();
                      row_bound=(); row_name=None;
                      row_fixed=false; row_closed=false})
  | Tpat_record (lpl,_) ->
      let lbl = snd3 (List.hd lpl) in
      if lbl.lbl_private = Private then p.pat_type else
      let ty = newvar () in
      let ppl = List.map (fun (_, l, p) -> l.lbl_pos, p) lpl in
      let do_label lbl =
        let _, ty_arg, ty_res = instance_label false lbl in
        unify_pat env {p with pat_type = ty} ty_res;
        let refinable =
          lbl.lbl_mut = Immutable && List.mem_assoc lbl.lbl_pos ppl &&
          match (repr lbl.lbl_arg).desc with Tpoly _ -> false | _ -> true in
        if refinable then begin
          let arg = List.assoc lbl.lbl_pos ppl in
          unify_pat env {arg with pat_type = build_as_type env arg} ty_arg
        end else begin
          let _, ty_arg', ty_res' = instance_label false lbl in
          unify env ty_arg ty_arg';
          unify_pat env p ty_res'
        end in
      Array.iter do_label lbl.lbl_all;
      ty
  | Tpat_or(p1, p2, row) ->
      begin match row with
        None ->
          let ty1 = build_as_type env p1 and ty2 = build_as_type env p2 in
          unify_pat env {p2 with pat_type = ty2} ty1;
          ty1
      | Some row ->
          let row = row_repr row in
          newty (Tvariant{row with row_closed=false; row_more=newvar()})
      end
  | Tpat_any | Tpat_var _ | Tpat_constant _
  | Tpat_array _ | Tpat_lazy _ -> p.pat_type

let build_or_pat env loc lid =
  let path, decl = Typetexp.find_type env loc lid
  in
  let tyl = List.map (fun _ -> newvar()) decl.type_params in
  let row0 =
    let ty = expand_head env (newty(Tconstr(path, tyl, ref Mnil))) in
    match ty.desc with
      Tvariant row when static_row row -> row
    | _ -> raise(Error(loc, env, Not_a_variant_type lid))
  in
  let pats, fields =
    List.fold_left
      (fun (pats,fields) (l,f) ->
        match row_field_repr f with
          Rpresent None ->
            (l,None) :: pats,
            (l, Reither(true,[], true, ref None)) :: fields
        | Rpresent (Some ty) ->
            (l, Some {pat_desc=Tpat_any; pat_loc=Location.none; pat_env=env;
                      pat_type=ty; pat_extra=[]; pat_attributes=[]})
            :: pats,
            (l, Reither(false, [ty], true, ref None)) :: fields
        | _ -> pats, fields)
      ([],[]) (row_repr row0).row_fields in
  let row =
    { row_fields = List.rev fields; row_more = newvar(); row_bound = ();
      row_closed = false; row_fixed = false; row_name = Some (path, tyl) }
  in
  let ty = newty (Tvariant row) in
  let gloc = {loc with Location.loc_ghost=true} in
  let row' = ref {row with row_more=newvar()} in
  let pats =
    List.map
      (fun (l,p) ->
        {pat_desc=Tpat_variant(l,p,row'); pat_loc=gloc;
         pat_env=env; pat_type=ty; pat_extra=[]; pat_attributes=[]})
      pats
  in
  match pats with
    [] -> raise(Error(loc, env, Not_a_variant_type lid))
  | pat :: pats ->
      let r =
        List.fold_left
          (fun pat pat0 ->
            {pat_desc=Tpat_or(pat0,pat,Some row0); pat_extra=[];
             pat_loc=gloc; pat_env=env; pat_type=ty; pat_attributes=[]})
          pat pats in
      (path, rp { r with pat_loc = loc },ty)

(* Type paths *)

let rec expand_path env p =
  let decl =
    try Some (Env.find_type p env) with Not_found -> None
  in
  match decl with
    Some {type_manifest = Some ty} ->
      begin match repr ty with
        {desc=Tconstr(p,_,_)} -> expand_path env p
      | _ -> p
         (* PR#6394: recursive module may introduce incoherent manifest *)
      end
  | _ ->
      let p' = Env.normalize_path None env p in
      if Path.same p p' then p else expand_path env p'

let compare_type_path env tpath1 tpath2 =
  Path.same (expand_path env tpath1) (expand_path env tpath2)

(* Records *)

module NameChoice(Name : sig
  type t
  val type_kind: string
  val get_name: t -> string
  val get_type: t -> type_expr
  val get_descrs: Env.type_descriptions -> t list
  val fold: (t -> 'a -> 'a) -> Longident.t option -> Env.t -> 'a -> 'a
  val unbound_name_error: Env.t -> Longident.t loc -> 'a
end) = struct
  open Name

  let get_type_path env d =
    match (get_type d).desc with
    | Tconstr(p, _, _) -> p
    | _ -> assert false

  let spellcheck ppf env p lid =
    Typetexp.spellcheck_simple ppf fold
      (fun d ->
        if compare_type_path env p (get_type_path env d)
        then get_name d else "") env lid

  let lookup_from_type env tpath lid =
    let descrs = get_descrs (Env.find_type_descrs tpath env) in
    Env.mark_type_used env (Path.last tpath) (Env.find_type tpath env);
    match lid.txt with
      Longident.Lident s -> begin
        try
          List.find (fun nd -> get_name nd = s) descrs
        with Not_found ->
          raise (Error (lid.loc, env,
                        Wrong_name ("", newvar (), type_kind, tpath, lid.txt)))
      end
    | _ -> raise Not_found

  let rec unique eq acc = function
      [] -> List.rev acc
    | x :: rem ->
        if List.exists (eq x) acc then unique eq acc rem
        else unique eq (x :: acc) rem

  let ambiguous_types env lbl others =
    let tpath = get_type_path env lbl in
    let others =
      List.map (fun (lbl, _) -> get_type_path env lbl) others in
    let tpaths = unique (compare_type_path env) [tpath] others in
    match tpaths with
      [_] -> []
    | _ -> List.map Printtyp.string_of_path tpaths

  let disambiguate_by_type env tpath lbls =
    let check_type (lbl, _) =
      let lbl_tpath = get_type_path env lbl in
      compare_type_path env tpath lbl_tpath
    in
    List.find check_type lbls

  let disambiguate ?(warn=Location.prerr_warning) ?(check_lk=fun _ _ -> ())
      ?scope lid env opath lbls =
    let scope = match scope with None -> lbls | Some l -> l in
    let lbl = match opath with
      None ->
        begin match lbls with
          [] -> unbound_name_error env lid
        | (lbl, use) :: rest ->
            use ();
            let paths = ambiguous_types env lbl rest in
            if paths <> [] then
              warn lid.loc
                (Warnings.Ambiguous_name ([Longident.last lid.txt],
                                          paths, false));
            lbl
        end
    | Some(tpath0, tpath, pr) ->
        let warn_pr () =
          let kind = if type_kind = "record" then "field" else "constructor" in
          warn lid.loc
            (Warnings.Not_principal
               ("this type-based " ^ kind ^ " disambiguation"))
        in
        try
          let lbl, use = disambiguate_by_type env tpath scope in
          use ();
          if not pr then begin
            (* Check if non-principal type is affecting result *)
            match lbls with
              [] -> warn_pr ()
            | (lbl', use') :: rest ->
                let lbl_tpath = get_type_path env lbl' in
                if not (compare_type_path env tpath lbl_tpath) then warn_pr ()
                else
                  let paths = ambiguous_types env lbl rest in
                  if paths <> [] then
                    warn lid.loc
                      (Warnings.Ambiguous_name ([Longident.last lid.txt],
                                                paths, false))
          end;
          lbl
        with Not_found -> try
          let lbl = lookup_from_type env tpath lid in
          check_lk tpath lbl;
          let s = Printtyp.string_of_path tpath in
          warn lid.loc
            (Warnings.Name_out_of_scope (s, [Longident.last lid.txt], false));
          if not pr then warn_pr ();
          lbl
        with Not_found ->
          if lbls = [] then unbound_name_error env lid else
          let tp = (tpath0, expand_path env tpath) in
          let tpl =
            List.map
              (fun (lbl, _) ->
                let tp0 = get_type_path env lbl in
                let tp = expand_path env tp0 in
                  (tp0, tp))
              lbls
          in
          raise (Error (lid.loc, env,
                        Name_type_mismatch (type_kind, lid.txt, tp, tpl)))
    in
    begin match scope with
      (lab1,_)::_ when lab1 == lbl -> ()
    | _ ->
        Location.prerr_warning lid.loc
          (Warnings.Disambiguated_name(get_name lbl))
    end;
    lbl
end

let wrap_disambiguate kind ty f x =
  try f x with Error (loc, env, Wrong_name (_,_,tk,tp,lid)) ->
    raise (Error (loc, env, Wrong_name (kind,ty,tk,tp,lid)))

module Label = NameChoice (struct
  type t = label_description
  let type_kind = "record"
  let get_name lbl = lbl.lbl_name
  let get_type lbl = lbl.lbl_res
  let get_descrs = snd
  let fold = Env.fold_labels
  let unbound_name_error = Typetexp.unbound_label_error
end)

let disambiguate_label_by_ids keep env closed ids labels =
  let check_ids (lbl, _) =
    let lbls = Hashtbl.create 8 in
    Array.iter (fun lbl -> Hashtbl.add lbls lbl.lbl_name ()) lbl.lbl_all;
    List.for_all (Hashtbl.mem lbls) ids
  and check_closed (lbl, _) =
    (not closed || List.length ids = Array.length lbl.lbl_all)
  in
  let labels' = List.filter check_ids labels in
  if keep && labels' = [] then (false, labels) else
  let labels'' = List.filter check_closed labels' in
  if keep && labels'' = [] then (false, labels') else (true, labels'')

(* Only issue warnings once per record constructor/pattern *)
let disambiguate_lid_a_list loc closed env opath lid_a_list =
  let ids = List.map (fun (lid, _) -> Longident.last lid.txt) lid_a_list in
  let w_pr = ref false and w_amb = ref []
  and w_scope = ref [] and w_scope_ty = ref "" in
  let warn loc msg =
    let open Warnings in
    match msg with
    | Not_principal _ -> w_pr := true
    | Ambiguous_name([s], l, _) -> w_amb := (s, l) :: !w_amb
    | Name_out_of_scope(ty, [s], _) ->
        w_scope := s :: !w_scope; w_scope_ty := ty
    | _ -> Location.prerr_warning loc msg
  in
  let process_label lid =
    (* Strategy for each field:
       * collect all the labels in scope for that name
       * if the type is known and principal, just eventually warn
         if the real label was not in scope
       * fail if there is no known type and no label found
       * otherwise use other fields to reduce the list of candidates
       * if there is no known type reduce it incrementally, so that
         there is still at least one candidate (for error message)
       * if the reduced list is valid, call Label.disambiguate
     *)
    let scope = Typetexp.find_all_labels env lid.loc lid.txt in
    if opath = None && scope = [] then
      Typetexp.unbound_label_error env lid;
    let (ok, labels) =
      match opath with
        Some (_, _, true) -> (true, scope) (* disambiguate only checks scope *)
      | _  -> disambiguate_label_by_ids (opath=None) env closed ids scope
    in
    if ok then Label.disambiguate lid env opath labels ~warn ~scope
          else fst (List.hd labels) (* will fail later *)
  in
  let lbl_a_list =
    List.map (fun (lid,a) -> lid, process_label lid, a) lid_a_list in
  if !w_pr then
    Location.prerr_warning loc
      (Warnings.Not_principal "this type-based record disambiguation")
  else begin
    match List.rev !w_amb with
      (_,types)::others as amb ->
        let paths =
          List.map (fun (_,lbl,_) -> Label.get_type_path env lbl) lbl_a_list in
        let path = List.hd paths in
        if List.for_all (compare_type_path env path) (List.tl paths) then
          Location.prerr_warning loc
            (Warnings.Ambiguous_name (List.map fst amb, types, true))
        else
          List.iter
            (fun (s,l) -> Location.prerr_warning loc
                (Warnings.Ambiguous_name ([s],l,false)))
            amb
    | _ -> ()
  end;
  if !w_scope <> [] then
    Location.prerr_warning loc
      (Warnings.Name_out_of_scope (!w_scope_ty, List.rev !w_scope, true));
  lbl_a_list

let rec find_record_qual = function
  | [] -> None
  | ({ txt = Longident.Ldot (modname, _) }, _) :: _ -> Some modname
  | _ :: rest -> find_record_qual rest

let type_label_a_list ?labels loc closed env type_lbl_a opath lid_a_list =
  let lbl_a_list =
    match lid_a_list, labels with
      ({txt=Longident.Lident s}, _)::_, Some labels when Hashtbl.mem labels s ->
        (* Special case for rebuilt syntax trees *)
        List.map
          (function lid, a -> match lid.txt with
            Longident.Lident s -> lid, Hashtbl.find labels s, a
          | _ -> assert false)
          lid_a_list
    | _ ->
        let lid_a_list =
          match find_record_qual lid_a_list with
            None -> lid_a_list
          | Some modname ->
              List.map
                (fun (lid, a as lid_a) ->
                  match lid.txt with Longident.Lident s ->
                    {lid with txt=Longident.Ldot (modname, s)}, a
                  | _ -> lid_a)
                lid_a_list
        in
        disambiguate_lid_a_list loc closed env opath lid_a_list
  in
  (* Invariant: records are sorted in the typed tree *)
  let lbl_a_list =
    List.sort
      (fun (_,lbl1,_) (_,lbl2,_) -> compare lbl1.lbl_pos lbl2.lbl_pos)
      lbl_a_list
  in
  List.map type_lbl_a lbl_a_list
;;

(* Checks over the labels mentioned in a record pattern:
   no duplicate definitions (error); properly closed (warning) *)

let check_recordpat_labels loc lbl_pat_list closed =
  match lbl_pat_list with
  | [] -> ()                            (* should not happen *)
  | (_, label1, _) :: _ ->
      let all = label1.lbl_all in
      let defined = Array.make (Array.length all) false in
      let check_defined (_, label, _) =
        if defined.(label.lbl_pos)
        then raise(Error(loc, Env.empty, Label_multiply_defined label.lbl_name))
        else defined.(label.lbl_pos) <- true in
      List.iter check_defined lbl_pat_list;
      if closed = Closed
      && Warnings.is_active (Warnings.Non_closed_record_pattern "")
      then begin
        let undefined = ref [] in
        for i = 0 to Array.length all - 1 do
          if not defined.(i) then undefined := all.(i).lbl_name :: !undefined
        done;
        if !undefined <> [] then begin
          let u = String.concat ", " (List.rev !undefined) in
          Location.prerr_warning loc (Warnings.Non_closed_record_pattern u)
        end
      end

(* Constructors *)

module Constructor = NameChoice (struct
  type t = constructor_description
  let type_kind = "variant"
  let get_name cstr = cstr.cstr_name
  let get_type cstr = cstr.cstr_res
  let get_descrs = fst
  let fold = Env.fold_constructors
  let unbound_name_error = Typetexp.unbound_constructor_error
end)

(* unification of a type with a tconstr with
   freshly created arguments *)
let unify_head_only loc env ty constr =
  let (_, ty_res) = instance_constructor constr in
  match (repr ty_res).desc with
  | Tconstr(p,args,m) ->
      ty_res.desc <- Tconstr(p,List.map (fun _ -> newvar ()) args,m);
      enforce_constraints env ty_res;
      unify_pat_types loc env ty_res ty
  | _ -> assert false

(* Typing of patterns *)

(* type_pat does not generate local constraints inside or patterns *)
type type_pat_mode =
  | Normal
  | Inside_or

(* type_pat propagates the expected type as well as maps for
   constructors and labels.
   Unification may update the typing environment. *)
let rec type_pat ~constrs ~labels ~no_existentials ~mode ~env sp expected_ty =
  let type_pat ?(mode=mode) ?(env=env) =
    type_pat ~constrs ~labels ~no_existentials ~mode ~env in
  let loc = sp.ppat_loc in
  match sp.ppat_desc with
    Ppat_any ->
      rp {
        pat_desc = Tpat_any;
        pat_loc = loc; pat_extra=[];
        pat_type = expected_ty;
        pat_attributes = sp.ppat_attributes;
        pat_env = !env }
  | Ppat_var name ->
      let id = enter_variable loc name expected_ty in
      rp {
        pat_desc = Tpat_var (id, name);
        pat_loc = loc; pat_extra=[];
        pat_type = expected_ty;
        pat_attributes = sp.ppat_attributes;
        pat_env = !env }
  | Ppat_unpack name ->
      let id = enter_variable loc name expected_ty ~is_module:true in
      rp {
        pat_desc = Tpat_var (id, name);
        pat_loc = sp.ppat_loc;
        pat_extra=[Tpat_unpack, loc, sp.ppat_attributes];
        pat_type = expected_ty;
        pat_attributes = [];
        pat_env = !env }
  | Ppat_constraint({ppat_desc=Ppat_var name; ppat_loc=lloc},
                    ({ptyp_desc=Ptyp_poly _} as sty)) ->
      (* explicitly polymorphic type *)
      let cty, force = Typetexp.transl_simple_type_delayed !env sty in
      let ty = cty.ctyp_type in
      unify_pat_types lloc !env ty expected_ty;
      pattern_force := force :: !pattern_force;
      begin match ty.desc with
      | Tpoly (body, tyl) ->
          begin_def ();
          let _, ty' = instance_poly ~keep_names:true false tyl body in
          end_def ();
          generalize ty';
          let id = enter_variable lloc name ty' in
          rp {
            pat_desc = Tpat_var (id, name);
            pat_loc = lloc;
            pat_extra = [Tpat_constraint cty, loc, sp.ppat_attributes];
            pat_type = ty;
            pat_attributes = [];
            pat_env = !env
          }
      | _ -> assert false
      end
  | Ppat_alias(sq, name) ->
      let q = type_pat sq expected_ty in
      begin_def ();
      let ty_var = build_as_type !env q in
      end_def ();
      generalize ty_var;
      let id = enter_variable ~is_as_variable:true loc name ty_var in
      rp {
        pat_desc = Tpat_alias(q, id, name);
        pat_loc = loc; pat_extra=[];
        pat_type = q.pat_type;
        pat_attributes = sp.ppat_attributes;
        pat_env = !env }
  | Ppat_constant cst ->
      unify_pat_types loc !env (type_constant cst) expected_ty;
      rp {
        pat_desc = Tpat_constant cst;
        pat_loc = loc; pat_extra=[];
        pat_type = expected_ty;
        pat_attributes = sp.ppat_attributes;
        pat_env = !env }
  | Ppat_interval (Const_char c1, Const_char c2) ->
      let open Ast_helper.Pat in
      let gloc = {loc with Location.loc_ghost=true} in
      let rec loop c1 c2 =
        if c1 = c2 then constant ~loc:gloc (Const_char c1)
        else
          or_ ~loc:gloc
            (constant ~loc:gloc (Const_char c1))
            (loop (Char.chr(Char.code c1 + 1)) c2)
      in
      let p = if c1 <= c2 then loop c1 c2 else loop c2 c1 in
      let p = {p with ppat_loc=loc} in
      type_pat p expected_ty
        (* TODO: record 'extra' to remember about interval *)
  | Ppat_interval _ ->
      raise (Error (loc, !env, Invalid_interval))
  | Ppat_tuple spl ->
      if List.length spl < 2 then
        Syntaxerr.ill_formed_ast loc "Tuples must have at least 2 components.";
      let spl_ann = List.map (fun p -> (p,newvar ())) spl in
      let ty = newty (Ttuple(List.map snd spl_ann)) in
      unify_pat_types loc !env ty expected_ty;
      let pl = List.map (fun (p,t) -> type_pat p t) spl_ann in
      rp {
        pat_desc = Tpat_tuple pl;
        pat_loc = loc; pat_extra=[];
        pat_type = expected_ty;
        pat_attributes = sp.ppat_attributes;
        pat_env = !env }
  | Ppat_construct(lid, sarg) ->
      let opath =
        try
          let (p0, p, _) = extract_concrete_variant !env expected_ty in
            Some (p0, p, true)
        with Not_found -> None
      in
      let constrs =
        match lid.txt, constrs with
          Longident.Lident s, Some constrs when Hashtbl.mem constrs s ->
            [Hashtbl.find constrs s, (fun () -> ())]
        | _ ->  Typetexp.find_all_constructors !env lid.loc lid.txt
      in
      let check_lk tpath constr =
        if constr.cstr_generalized then
          raise (Error (lid.loc, !env,
                        Unqualified_gadt_pattern (tpath, constr.cstr_name)))
      in
      let constr =
        wrap_disambiguate "This variant pattern is expected to have" expected_ty
          (Constructor.disambiguate lid !env opath ~check_lk) constrs
      in
      Env.mark_constructor Env.Pattern !env (Longident.last lid.txt) constr;
      Typetexp.check_deprecated loc constr.cstr_attributes constr.cstr_name;
      if no_existentials && constr.cstr_existentials <> [] then
        raise (Error (loc, !env, Unexpected_existential));
      (* if constructor is gadt, we must verify that the expected type has the
         correct head *)
      if constr.cstr_generalized then
        unify_head_only loc !env expected_ty constr;
      let sargs =
        match sarg with
          None -> []
        | Some {ppat_desc = Ppat_tuple spl} when
            constr.cstr_arity > 1 || explicit_arity sp.ppat_attributes
          -> spl
        | Some({ppat_desc = Ppat_any} as sp) when constr.cstr_arity <> 1 ->
            if constr.cstr_arity = 0 then
              Location.prerr_warning sp.ppat_loc
                                     Warnings.Wildcard_arg_to_constant_constr;
            replicate_list sp constr.cstr_arity
        | Some sp -> [sp] in
      if List.length sargs <> constr.cstr_arity then
        raise(Error(loc, !env, Constructor_arity_mismatch(lid.txt,
                                     constr.cstr_arity, List.length sargs)));
      let (ty_args, ty_res) =
        instance_constructor ~in_pattern:(env, get_newtype_level ()) constr
      in
      if constr.cstr_generalized && mode = Normal then
        unify_pat_types_gadt loc env ty_res expected_ty
      else
        unify_pat_types loc !env ty_res expected_ty;
      let args = List.map2 (fun p t -> type_pat p t) sargs ty_args in
      rp {
        pat_desc=Tpat_construct(lid, constr, args);
        pat_loc = loc; pat_extra=[];
        pat_type = expected_ty;
        pat_attributes = sp.ppat_attributes;
        pat_env = !env }
  | Ppat_variant(l, sarg) ->
      let arg_type = match sarg with None -> [] | Some _ -> [newvar()] in
      let row = { row_fields =
                    [l, Reither(sarg = None, arg_type, true, ref None)];
                  row_bound = ();
                  row_closed = false;
                  row_more = newvar ();
                  row_fixed = false;
                  row_name = None } in
      unify_pat_types loc !env (newty (Tvariant row)) expected_ty;
      let arg =
        (* PR#6235: propagate type information *)
        match sarg, arg_type with
          Some p, [ty] -> Some (type_pat p ty)
        | _            -> None
      in
      rp {
        pat_desc = Tpat_variant(l, arg, ref {row with row_more = newvar()});
        pat_loc = loc; pat_extra=[];
        pat_type =  expected_ty;
        pat_attributes = sp.ppat_attributes;
        pat_env = !env }
  | Ppat_record(lid_sp_list, closed) ->
      if lid_sp_list = [] then
        Syntaxerr.ill_formed_ast loc "Records cannot be empty.";
      let opath, record_ty =
        try
          let (p0, p,_) = extract_concrete_record !env expected_ty in
          Some (p0, p, true), expected_ty
        with Not_found -> None, newvar ()
      in
      let type_label_pat (label_lid, label, sarg) =
        begin_def ();
        let (vars, ty_arg, ty_res) = instance_label false label in
        if vars = [] then end_def ();
        begin try
          unify_pat_types loc !env ty_res record_ty
        with Unify trace ->
          raise(Error(label_lid.loc, !env,
                      Label_mismatch(label_lid.txt, trace)))
        end;
        let arg = type_pat sarg ty_arg in
        if vars <> [] then begin
          end_def ();
          generalize ty_arg;
          List.iter generalize vars;
          let instantiated tv =
            let tv = expand_head !env tv in
            not (is_Tvar tv) || tv.level <> generic_level in
          if List.exists instantiated vars then
            raise (Error(label_lid.loc, !env, Polymorphic_label label_lid.txt))
        end;
        (label_lid, label, arg)
      in
      let lbl_pat_list =
        wrap_disambiguate "This record pattern is expected to have" expected_ty
          (type_label_a_list ?labels loc false !env type_label_pat opath)
          lid_sp_list
      in
      check_recordpat_labels loc lbl_pat_list closed;
      unify_pat_types loc !env record_ty expected_ty;
      rp {
        pat_desc = Tpat_record (lbl_pat_list, closed);
        pat_loc = loc; pat_extra=[];
        pat_type = expected_ty;
        pat_attributes = sp.ppat_attributes;
        pat_env = !env }
  | Ppat_array spl ->
      let ty_elt = newvar() in
      unify_pat_types
        loc !env (instance_def (Predef.type_array ty_elt)) expected_ty;
      let spl_ann = List.map (fun p -> (p,newvar())) spl in
      let pl = List.map (fun (p,t) -> type_pat p ty_elt) spl_ann in
      rp {
        pat_desc = Tpat_array pl;
        pat_loc = loc; pat_extra=[];
        pat_type = expected_ty;
        pat_attributes = sp.ppat_attributes;
        pat_env = !env }
  | Ppat_or(sp1, sp2) ->
      let initial_pattern_variables = !pattern_variables in
      let p1 = type_pat ~mode:Inside_or sp1 expected_ty in
      let p1_variables = !pattern_variables in
      pattern_variables := initial_pattern_variables;
      let p2 = type_pat ~mode:Inside_or sp2 expected_ty in
      let p2_variables = !pattern_variables in
      let alpha_env =
        enter_orpat_variables loc !env p1_variables p2_variables in
      pattern_variables := p1_variables;
      rp {
        pat_desc = Tpat_or(p1, alpha_pat alpha_env p2, None);
        pat_loc = loc; pat_extra=[];
        pat_type = expected_ty;
        pat_attributes = sp.ppat_attributes;
        pat_env = !env }
  | Ppat_lazy sp1 ->
      let nv = newvar () in
      unify_pat_types loc !env (instance_def (Predef.type_lazy_t nv))
        expected_ty;
      let p1 = type_pat sp1 nv in
      rp {
        pat_desc = Tpat_lazy p1;
        pat_loc = loc; pat_extra=[];
        pat_type = expected_ty;
        pat_attributes = sp.ppat_attributes;
        pat_env = !env }
  | Ppat_constraint(sp, sty) ->
      (* Separate when not already separated by !principal *)
      let separate = true in
      if separate then begin_def();
      let cty, force = Typetexp.transl_simple_type_delayed !env sty in
      let ty = cty.ctyp_type in
      let ty, expected_ty' =
        if separate then begin
          end_def();
          generalize_structure ty;
          instance !env ty, instance !env ty
        end else ty, ty
      in
      unify_pat_types loc !env ty expected_ty;
      let p = type_pat sp expected_ty' in
      (*Format.printf "%a@.%a@."
        Printtyp.raw_type_expr ty
        Printtyp.raw_type_expr p.pat_type;*)
      pattern_force := force :: !pattern_force;
      let extra = (Tpat_constraint cty, loc, sp.ppat_attributes) in
      if separate then
        match p.pat_desc with
          Tpat_var (id,s) ->
            {p with pat_type = ty;
             pat_desc = Tpat_alias
               ({p with pat_desc = Tpat_any; pat_attributes = []}, id,s);
             pat_extra = [extra];
            }
        | _ -> {p with pat_type = ty;
                pat_extra = extra :: p.pat_extra}
      else p
  | Ppat_type lid ->
      let (path, p,ty) = build_or_pat !env loc lid.txt in
      unify_pat_types loc !env ty expected_ty;
      { p with pat_extra =
        (Tpat_type (path, lid), loc, sp.ppat_attributes) :: p.pat_extra }
  | Ppat_exception _ ->
      raise (Error (loc, !env, Exception_pattern_below_toplevel))
  | Ppat_extension ext ->
      raise (Error_forward (Typetexp.error_of_extension ext))

let type_pat ?(allow_existentials=false) ?constrs ?labels
    ?(lev=get_current_level()) env sp expected_ty =
  newtype_level := Some lev;
  try
    let r =
      type_pat ~no_existentials:(not allow_existentials) ~constrs ~labels
        ~mode:Normal ~env sp expected_ty in
    iter_pattern (fun p -> p.pat_env <- !env) r;
    newtype_level := None;
    r
  with e ->
    newtype_level := None;
    raise e


(* this function is passed to Partial.parmatch
   to type check gadt nonexhaustiveness *)
let partial_pred ~lev env expected_ty constrs labels p =
  let snap = snapshot () in
  try
    reset_pattern None true;
    let typed_p =
      type_pat ~allow_existentials:true ~lev
        ~constrs ~labels (ref env) p expected_ty
    in
    backtrack snap;
    (* types are invalidated but we don't need them here *)
    Some typed_p
  with _ ->
    backtrack snap;
    None

let check_partial ?(lev=get_current_level ()) env expected_ty =
  Parmatch.check_partial_gadt (partial_pred ~lev env expected_ty)

let rec iter3 f lst1 lst2 lst3 =
  match lst1,lst2,lst3 with
  | x1::xs1,x2::xs2,x3::xs3 ->
      f x1 x2 x3;
      iter3 f xs1 xs2 xs3
  | [],[],[] ->
      ()
  | _ ->
      assert false

let add_pattern_variables ?check ?check_as env =
  let pv = get_ref pattern_variables in
  (List.fold_right
     (fun (id, ty, name, loc, as_var) env ->
       let check = if as_var then check_as else check in
       Env.add_value ?check id
         {val_type = ty; val_kind = Val_reg; Types.val_loc = loc;
          val_attributes = [];
         } env
     )
     pv env,
   get_ref module_variables)

let type_pattern ~lev env spat scope expected_ty =
  reset_pattern scope true;
  let new_env = ref env in
  let pat = type_pat ~allow_existentials:true ~lev new_env spat expected_ty in
  let new_env, unpacks =
    add_pattern_variables !new_env
      ~check:(fun s -> Warnings.Unused_var_strict s)
      ~check_as:(fun s -> Warnings.Unused_var s) in
  (pat, new_env, get_ref pattern_force, unpacks)

let type_pattern_list env spatl scope expected_tys allow =
  reset_pattern scope allow;
  let new_env = ref env in
  let patl = List.map2 (type_pat new_env) spatl expected_tys in
  let new_env, unpacks = add_pattern_variables !new_env in
  (patl, new_env, get_ref pattern_force, unpacks)

let type_class_arg_pattern cl_num val_env met_env l spat =
  reset_pattern None false;
  let nv = newvar () in
  let pat = type_pat (ref val_env) spat nv in
  if has_variants pat then begin
    Parmatch.pressure_variants val_env [pat];
    iter_pattern finalize_variant pat
  end;
  List.iter (fun f -> f()) (get_ref pattern_force);
  if is_optional l then unify_pat val_env pat (type_option (newvar ()));
  let (pv, met_env) =
    List.fold_right
      (fun (id, ty, name, loc, as_var) (pv, env) ->
         let check s =
           if as_var then Warnings.Unused_var s
           else Warnings.Unused_var_strict s in
         let id' = Ident.create (Ident.name id) in
         ((id', name, id, ty)::pv,
          Env.add_value id' {val_type = ty;
                             val_kind = Val_ivar (Immutable, cl_num);
                             val_attributes = [];
                             Types.val_loc = loc;
                            } ~check
            env))
      !pattern_variables ([], met_env)
  in
  let val_env, _ = add_pattern_variables val_env in
  (pat, pv, val_env, met_env)

let type_self_pattern cl_num privty val_env met_env par_env spat =
  let open Ast_helper in
  let spat =
    Pat.mk (Ppat_alias (Pat.mk(Ppat_alias (spat, mknoloc "selfpat-*")),
                        mknoloc ("selfpat-" ^ cl_num)))
  in
  reset_pattern None false;
  let nv = newvar() in
  let pat = type_pat (ref val_env) spat nv in
  List.iter (fun f -> f()) (get_ref pattern_force);
  let meths = ref Meths.empty in
  let vars = ref Vars.empty in
  let pv = !pattern_variables in
  pattern_variables := [];
  let (val_env, met_env, par_env) =
    List.fold_right
      (fun (id, ty, name, loc, as_var) (val_env, met_env, par_env) ->
         (Env.add_value id {val_type = ty;
                            val_kind = Val_unbound;
                            val_attributes = [];
                            Types.val_loc = loc;
                           } val_env,
          Env.add_value id {val_type = ty;
                            val_kind = Val_self (meths, vars, cl_num, privty);
                            val_attributes = [];
                            Types.val_loc = loc;
                           }
            ~check:(fun s -> if as_var then Warnings.Unused_var s
                             else Warnings.Unused_var_strict s)
            met_env,
          Env.add_value id {val_type = ty; val_kind = Val_unbound;
                            val_attributes = [];
                            Types.val_loc = loc;
                           } par_env))
      pv (val_env, met_env, par_env)
  in
  (pat, meths, vars, val_env, met_env, par_env)

let delayed_checks = ref []
let reset_delayed_checks () = delayed_checks := []
let add_delayed_check f =
  delayed_checks := (f, Warnings.backup ()) :: !delayed_checks

let force_delayed_checks () =
  (* checks may change type levels *)
  let snap = Btype.snapshot () in
  let w_old = Warnings.backup () in
  List.iter
    (fun (f, w) -> Warnings.restore w; f ())
    (List.rev !delayed_checks);
  Warnings.restore w_old;
  reset_delayed_checks ();
  Btype.backtrack snap

let rec final_subexpression sexp =
  match sexp.pexp_desc with
    Pexp_let (_, _, e)
  | Pexp_sequence (_, e)
  | Pexp_try (e, _)
  | Pexp_ifthenelse (_, e, _)
  | Pexp_match (_, {pc_rhs=e} :: _)
    -> final_subexpression e
  | _ -> sexp

(* Generalization criterion for expressions *)

let rec is_nonexpansive exp =
  match exp.exp_desc with
    Texp_ident(_,_,_) -> true
  | Texp_constant _ -> true
  | Texp_let(rec_flag, pat_exp_list, body) ->
      List.for_all (fun vb -> is_nonexpansive vb.vb_expr) pat_exp_list &&
      is_nonexpansive body
  | Texp_function _ -> true
  | Texp_apply(e, (_,None,_)::el) ->
      is_nonexpansive e && List.for_all is_nonexpansive_opt (List.map snd3 el)
  | Texp_match(e, cases, [], _) ->
      is_nonexpansive e &&
      List.for_all
        (fun {c_lhs = _; c_guard; c_rhs} ->
           is_nonexpansive_opt c_guard && is_nonexpansive c_rhs
        ) cases
  | Texp_tuple el ->
      List.for_all is_nonexpansive el
  | Texp_construct( _, _, el) ->
      List.for_all is_nonexpansive el
  | Texp_variant(_, arg) -> is_nonexpansive_opt arg
  | Texp_record(lbl_exp_list, opt_init_exp) ->
      List.for_all
        (fun (_, lbl, exp) -> lbl.lbl_mut = Immutable && is_nonexpansive exp)
        lbl_exp_list
      && is_nonexpansive_opt opt_init_exp
  | Texp_field(exp, lbl, _) -> is_nonexpansive exp
  | Texp_array [] -> true
  | Texp_ifthenelse(cond, ifso, ifnot) ->
      is_nonexpansive ifso && is_nonexpansive_opt ifnot
  | Texp_sequence (e1, e2) -> is_nonexpansive e2  (* PR#4354 *)
  | Texp_new (_, _, cl_decl) when Ctype.class_type_arity cl_decl.cty_type > 0 ->
      true
  (* Note: nonexpansive only means no _observable_ side effects *)
  | Texp_lazy e -> is_nonexpansive e
  | Texp_object ({cstr_fields=fields; cstr_type = { csig_vars=vars}}, _) ->
      let count = ref 0 in
      List.for_all
        (fun field -> match field.cf_desc with
            Tcf_method _ -> true
          | Tcf_val (_, _, _, Tcfk_concrete (_, e), _) ->
              incr count; is_nonexpansive e
          | Tcf_val (_, _, _, Tcfk_virtual _, _) ->
              incr count; true
          | Tcf_initializer e -> is_nonexpansive e
          | Tcf_constraint _ -> true
          | Tcf_inherit _ -> false
          | Tcf_attribute _ -> true)
        fields &&
      Vars.fold (fun _ (mut,_,_) b -> decr count; b && mut = Immutable)
        vars true &&
      !count = 0
  | Texp_letmodule (_, _, mexp, e) ->
      is_nonexpansive_mod mexp && is_nonexpansive e
  | Texp_pack mexp ->
      is_nonexpansive_mod mexp
  | _ -> false

and is_nonexpansive_mod mexp =
  match mexp.mod_desc with
  | Tmod_ident _ -> true
  | Tmod_functor _ -> true
  | Tmod_unpack (e, _) -> is_nonexpansive e
  | Tmod_constraint (m, _, _, _) -> is_nonexpansive_mod m
  | Tmod_structure str ->
      List.for_all
        (fun item -> match item.str_desc with
          | Tstr_eval _ | Tstr_primitive _ | Tstr_type _
          | Tstr_modtype _ | Tstr_open _ | Tstr_class_type _  -> true
          | Tstr_value (_, pat_exp_list) ->
              List.for_all (fun vb -> is_nonexpansive vb.vb_expr) pat_exp_list
          | Tstr_module {mb_expr=m;_}
          | Tstr_include {incl_mod=m;_} -> is_nonexpansive_mod m
          | Tstr_recmodule id_mod_list ->
              List.for_all (fun {mb_expr=m;_} -> is_nonexpansive_mod m)
                id_mod_list
          | Tstr_exception {ext_kind = Text_decl _} ->
              false (* true would be unsound *)
          | Tstr_exception {ext_kind = Text_rebind _} -> true
          | Tstr_typext te ->
              List.for_all
                (function {ext_kind = Text_decl _} -> false
                        | {ext_kind = Text_rebind _} -> true)
                te.tyext_constructors
          | Tstr_class _ -> false (* could be more precise *)
          | Tstr_attribute _ -> true
        )
        str.str_items
  | Tmod_apply _ -> false

and is_nonexpansive_opt = function
    None -> true
  | Some e -> is_nonexpansive e

(* Approximate the type of an expression, for better recursion *)

let rec approx_type env sty =
  match sty.ptyp_desc with
    Ptyp_arrow (p, _, sty) ->
      let ty1 = if is_optional p then type_option (newvar ()) else newvar () in
      newty (Tarrow (p, ty1, approx_type env sty, Cok))
  | Ptyp_tuple args ->
      newty (Ttuple (List.map (approx_type env) args))
  | Ptyp_constr (lid, ctl) ->
      begin try
        let (path, decl) = Env.lookup_type lid.txt env in
        if List.length ctl <> decl.type_arity then raise Not_found;
        let tyl = List.map (approx_type env) ctl in
        newconstr path tyl
      with Not_found -> newvar ()
      end
  | Ptyp_poly (_, sty) ->
      approx_type env sty
  | _ -> newvar ()

let rec type_approx env sexp =
  match sexp.pexp_desc with
    Pexp_let (_, _, e) -> type_approx env e
  | Pexp_fun (p, _, _, e) when is_optional p ->
       newty (Tarrow(p, type_option (newvar ()), type_approx env e, Cok))
  | Pexp_fun (p,_,_, e) ->
       newty (Tarrow(p, newvar (), type_approx env e, Cok))
  | Pexp_function ({pc_rhs=e}::_) ->
       newty (Tarrow("", newvar (), type_approx env e, Cok))
  | Pexp_match (_, {pc_rhs=e}::_) -> type_approx env e
  | Pexp_try (e, _) -> type_approx env e
  | Pexp_tuple l -> newty (Ttuple(List.map (type_approx env) l))
  | Pexp_ifthenelse (_,e,_) -> type_approx env e
  | Pexp_sequence (_,e) -> type_approx env e
  | Pexp_constraint (e, sty) ->
      let ty = type_approx env e in
      let ty1 = approx_type env sty in
      begin try unify env ty ty1 with Unify trace ->
        raise(Error(sexp.pexp_loc, env, Expr_type_clash trace))
      end;
      ty1
  | Pexp_coerce (e, sty1, sty2) ->
      let approx_ty_opt = function
        | None -> newvar ()
        | Some sty -> approx_type env sty
      in
      let ty = type_approx env e
      and ty1 = approx_ty_opt sty1
      and ty2 = approx_type env sty2 in
      begin try unify env ty ty1 with Unify trace ->
        raise(Error(sexp.pexp_loc, env, Expr_type_clash trace))
      end;
      ty2
  | _ -> newvar ()

(* List labels in a function type, and whether return type is a variable *)
let rec list_labels_aux env visited ls ty_fun =
  let ty = expand_head env ty_fun in
  if List.memq ty visited then
    List.rev ls, false
  else match ty.desc with
    Tarrow (l, _, ty_res, _) ->
      list_labels_aux env (ty::visited) (l::ls) ty_res
  | _ ->
      List.rev ls, is_Tvar ty

let list_labels env ty =
  wrap_trace_gadt_instances env (list_labels_aux env [] []) ty

(* Check that all univars are safe in a type *)
let check_univars env expans kind exp ty_expected vars =
  if expans && not (is_nonexpansive exp) then
    generalize_expansive env exp.exp_type;
  (* need to expand twice? cf. Ctype.unify2 *)
  let vars = List.map (expand_head env) vars in
  let vars = List.map (expand_head env) vars in
  let vars' =
    List.filter
      (fun t ->
        let t = repr t in
        generalize t;
        match t.desc with
          Tvar name when t.level = generic_level ->
            log_type t; t.desc <- Tunivar name; true
        | _ -> false)
      vars in
  if List.length vars = List.length vars' then () else
  let ty = newgenty (Tpoly(repr exp.exp_type, vars'))
  and ty_expected = repr ty_expected in
  raise (Error (exp.exp_loc, env,
                Less_general(kind, [ty, ty; ty_expected, ty_expected])))

(* Check that a type is not a function *)
let check_application_result env statement exp =
  let loc = exp.exp_loc in
  match (expand_head env exp.exp_type).desc with
  | Tarrow _ ->
      Location.prerr_warning exp.exp_loc Warnings.Partial_application
  | Tvar _ -> ()
  | Tconstr (p, _, _) when Path.same p Predef.path_unit -> ()
  | _ ->
      if statement then
        Location.prerr_warning loc Warnings.Statement_type

(* Check that a type is generalizable at some level *)
let generalizable level ty =
  let rec check ty =
    let ty = repr ty in
    if ty.level < lowest_level then () else
    if ty.level <= level then raise Exit else
    (mark_type_node ty; iter_type_expr check ty)
  in
  try check ty; unmark_type ty; true
  with Exit -> unmark_type ty; false

(* Hack to allow coercion of self. Will clean-up later. *)
let self_coercion = ref ([] : (Path.t * Location.t list ref) list)

(* Helpers for packaged modules. *)
let create_package_type loc env (p, l) =
  let s = !Typetexp.transl_modtype_longident loc env p in
  let fields = List.map (fun (name, ct) ->
                           name, Typetexp.transl_simple_type env false ct) l in
  let ty = newty (Tpackage (s,
                    List.map fst l,
                   List.map (fun (_, cty) -> cty.ctyp_type) fields))
  in
   (s, fields, ty)

 let wrap_unpacks sexp unpacks =
   let open Ast_helper in
   List.fold_left
     (fun sexp (name, loc) ->
       Exp.letmodule ~loc:sexp.pexp_loc
         name
         (Mod.unpack ~loc
            (Exp.ident ~loc:name.loc (mkloc (Longident.Lident name.txt) name.loc)))
         sexp
     )
    sexp unpacks

(* Helpers for type_cases *)

let contains_variant_either ty =
  let rec loop ty =
    let ty = repr ty in
    if ty.level >= lowest_level then begin
      mark_type_node ty;
      match ty.desc with
        Tvariant row ->
          let row = row_repr row in
          if not row.row_fixed then
            List.iter
              (fun (_,f) ->
                match row_field_repr f with Reither _ -> raise Exit | _ -> ())
              row.row_fields;
          iter_row loop row
      | _ ->
          iter_type_expr loop ty
    end
  in
  try loop ty; unmark_type ty; false
  with Exit -> unmark_type ty; true

let iter_ppat f p =
  match p.ppat_desc with
  | Ppat_any | Ppat_var _ | Ppat_constant _ | Ppat_interval _
  | Ppat_extension _
  | Ppat_type _ | Ppat_unpack _ -> ()
  | Ppat_array pats -> List.iter f pats
  | Ppat_or (p1,p2) -> f p1; f p2
  | Ppat_variant (_, arg) | Ppat_construct (_, arg) -> may f arg
  | Ppat_tuple lst ->  List.iter f lst
  | Ppat_exception p | Ppat_alias (p,_)
  | Ppat_constraint (p,_) | Ppat_lazy p -> f p
  | Ppat_record (args, flag) -> List.iter (fun (_,p) -> f p) args

let contains_polymorphic_variant p =
  let rec loop p =
    match p.ppat_desc with
      Ppat_variant _ | Ppat_type _ -> raise Exit
    | _ -> iter_ppat loop p
  in
  try loop p; false with Exit -> true

let contains_gadt env p =
  let rec loop p =
    match p.ppat_desc with
      Ppat_construct (lid, _) ->
        begin try
          let cstrs = Env.lookup_all_constructors lid.txt env in
          List.iter (fun (cstr,_) -> if cstr.cstr_generalized then raise Exit)
            cstrs
        with Not_found -> ()
        end; iter_ppat loop p
    | _ -> iter_ppat loop p
  in
  try loop p; false with Exit -> true

let check_absent_variant env =
  iter_pattern
    (function {pat_desc = Tpat_variant (s, arg, row)} as pat ->
      let row = row_repr !row in
      if List.exists (fun (s',fi) -> s = s' && row_field_repr fi <> Rabsent)
          row.row_fields
      || not row.row_fixed && not (static_row row)  (* same as Ctype.poly *)
      then () else
      let ty_arg =
        match arg with None -> [] | Some p -> [correct_levels p.pat_type] in
      let row' = {row_fields = [s, Reither(arg=None,ty_arg,true,ref None)];
                  row_more = newvar (); row_bound = ();
                  row_closed = false; row_fixed = false; row_name = None} in
      (* Should fail *)
      unify_pat env {pat with pat_type = newty (Tvariant row')}
                    (correct_levels pat.pat_type)
      | _ -> ())

(* Duplicate types of values in the environment *)
(* XXX Should we do something about global type variables too? *)

let duplicate_ident_types loc caselist env =
  let caselist =
    List.filter (fun {pc_lhs} -> contains_gadt env pc_lhs) caselist in
  let idents = all_idents_cases caselist in
  List.fold_left
    (fun env s ->
      try
        (* XXX This will mark the value as being used;
           I don't think this is what we want *)
        let (path, desc) = Env.lookup_value (Longident.Lident s) env in
        match path with
          Path.Pident id ->
            let desc = {desc with val_type = correct_levels desc.val_type} in
            Env.add_value id desc env
        | _ -> env
      with Not_found -> env)
    env idents

(* Typing of expressions *)

let unify_exp env exp expected_ty =
  (* Format.eprintf "@[%a@ %a@]@." Printtyp.raw_type_expr exp.exp_type
    Printtyp.raw_type_expr expected_ty; *)
    unify_exp_types exp.exp_loc env exp.exp_type expected_ty

let rec type_exp env sexp =
  (* We now delegate everything to type_expect *)
  type_expect env sexp (newvar ())

(* Typing of an expression with an expected type.
   This provide better error messages, and allows controlled
   propagation of return type information.
   In the principal case, [type_expected'] may be at generic_level.
 *)

and type_expect ?in_function env sexp ty_expected =
  let previous_saved_types = Cmt_format.get_saved_types () in
  Typetexp.warning_enter_scope ();
  Typetexp.warning_attribute sexp.pexp_attributes;
  let exp = type_expect_ ?in_function env sexp ty_expected in
  Typetexp.warning_leave_scope ();
  Cmt_format.set_saved_types
    (Cmt_format.Partial_expression exp :: previous_saved_types);
  exp

and type_expect_ ?in_function env sexp ty_expected =
  let loc = sexp.pexp_loc in
  (* Record the expression type before unifying it with the expected type *)
  let rue exp =
    unify_exp env (re exp) (instance env ty_expected);
    exp
  in
  match sexp.pexp_desc with
  | Pexp_ident lid ->
      begin
        let (path, desc) = Typetexp.find_value env loc lid.txt in
        if !Clflags.annotations then begin
          let dloc = desc.Types.val_loc in
          let annot =
            if dloc.Location.loc_ghost then Annot.Iref_external
            else Annot.Iref_internal dloc
          in
          let name = Path.name ~paren:Oprint.parenthesized_ident path in
          Stypes.record (Stypes.An_ident (loc, name, annot))
        end;
        rue {
          exp_desc =
            begin match desc.val_kind with
              Val_ivar (_, cl_num) ->
                let (self_path, _) =
                  Env.lookup_value (Longident.Lident ("self-" ^ cl_num)) env
                in
                Texp_instvar(self_path, path,
                             match lid.txt with
                                 Longident.Lident txt -> { txt; loc = lid.loc }
                               | _ -> assert false)
            | Val_self (_, _, cl_num, _) ->
                let (path, _) =
                  Env.lookup_value (Longident.Lident ("self-" ^ cl_num)) env
                in
                Texp_ident(path, lid, desc)
            | Val_unbound ->
                raise(Error(loc, env, Masked_instance_variable lid.txt))
            (*| Val_prim _ ->
                let p = Env.normalize_path (Some loc) env path in
                Env.add_required_global (Path.head p);
                Texp_ident(path, lid, desc)*)
            | _ ->
                Texp_ident(path, lid, desc)
          end;
          exp_loc = loc; exp_extra = [];
          exp_type = instance env desc.val_type;
          exp_attributes = sexp.pexp_attributes;
          exp_env = env }
      end
  | Pexp_constant(Const_string (str, _) as cst) -> (
    (* Terrible hack for format strings *)
    let ty_exp = expand_head env ty_expected in
    let fmt6_path =
      Path.(Pdot (Pident (Ident.create_persistent "CamlinternalFormatBasics"),
                  "format6", 0)) in
    let is_format = match ty_exp.desc with
      | Tconstr(path, _, _) when Path.same path fmt6_path ->
        if !Clflags.principal && ty_exp.level <> generic_level then
          Location.prerr_warning loc
            (Warnings.Not_principal "this coercion to format6");
        true
      | _ -> false
    in
    if is_format then
      let format_parsetree =
        { (type_format loc str env) with pexp_loc = sexp.pexp_loc }  in
      type_expect ?in_function env format_parsetree ty_expected
    else
      rue {
        exp_desc = Texp_constant cst;
        exp_loc = loc; exp_extra = [];
        exp_type = instance_def Predef.type_string;
        exp_attributes = sexp.pexp_attributes;
        exp_env = env }
  )
  | Pexp_constant cst ->
      rue {
        exp_desc = Texp_constant cst;
        exp_loc = loc; exp_extra = [];
        exp_type = type_constant cst;
        exp_attributes = sexp.pexp_attributes;
        exp_env = env }
  | Pexp_let(Nonrecursive,
             [{pvb_pat=spat; pvb_expr=sval; pvb_attributes=[]}], sbody)
    when contains_gadt env spat ->
    (* TODO: allow non-empty attributes? *)
      type_expect ?in_function env
        {sexp with
         pexp_desc = Pexp_match (sval, [Ast_helper.Exp.case spat sbody])}
        ty_expected
  | Pexp_let(rec_flag, spat_sexp_list, sbody) ->
      let scp =
        match sexp.pexp_attributes, rec_flag with
        | [{txt="#default"},_], _ -> None
        | _, Recursive -> Some (Annot.Idef loc)
        | _, Nonrecursive -> Some (Annot.Idef sbody.pexp_loc)
      in
      let (pat_exp_list, new_env, unpacks) =
        type_let env rec_flag spat_sexp_list scp true in
      let body =
        type_expect new_env (wrap_unpacks sbody unpacks) ty_expected in
      re {
        exp_desc = Texp_let(rec_flag, pat_exp_list, body);
        exp_loc = loc; exp_extra = [];
        exp_type = body.exp_type;
        exp_attributes = sexp.pexp_attributes;
        exp_env = env }
  | Pexp_fun (l, Some default, spat, sexp) ->
      assert(is_optional l); (* default allowed only with optional argument *)
      let open Ast_helper in
      let default_loc = default.pexp_loc in
      let scases = [
        Exp.case
          (Pat.construct ~loc:default_loc
             (mknoloc (Longident.(Ldot (Lident "*predef*", "Some"))))
             (Some (Pat.var ~loc:default_loc (mknoloc "*sth*"))))
          (Exp.ident ~loc:default_loc (mknoloc (Longident.Lident "*sth*")));

        Exp.case
          (Pat.construct ~loc:default_loc
             (mknoloc (Longident.(Ldot (Lident "*predef*", "None"))))
             None)
          default;
       ]
      in
      let smatch =
        Exp.match_ ~loc (Exp.ident ~loc (mknoloc (Longident.Lident "*opt*")))
          scases
      in
      let sfun =
        Exp.fun_ ~loc
          l None
          (Pat.var ~loc (mknoloc "*opt*"))
          (Exp.let_ ~loc Nonrecursive ~attrs:[mknoloc "#default",PStr []]
             [Vb.mk spat smatch] sexp)
      in
      type_expect ?in_function env sfun ty_expected
        (* TODO: keep attributes, call type_function directly *)
  | Pexp_fun (l, None, spat, sexp) ->
      type_function ?in_function loc sexp.pexp_attributes env ty_expected
        l [{pc_lhs=spat; pc_guard=None; pc_rhs=sexp}]
  | Pexp_function caselist ->
      type_function ?in_function
        loc sexp.pexp_attributes env ty_expected "" caselist
  | Pexp_apply(sfunct, sargs) ->
      if sargs = [] then
        Syntaxerr.ill_formed_ast loc "Function application with no argument.";
      begin_def (); (* one more level for non-returning functions *)
      if !Clflags.principal then begin_def ();
      let funct = type_exp env sfunct in
      if !Clflags.principal then begin
          end_def ();
          generalize_structure funct.exp_type
        end;
      let rec lower_args seen ty_fun =
        let ty = expand_head env ty_fun in
        if List.memq ty seen then () else
        match ty.desc with
          Tarrow (l, ty_arg, ty_fun, com) ->
            (try unify_var env (newvar()) ty_arg with Unify _ -> assert false);
            lower_args (ty::seen) ty_fun
        | _ -> ()
      in
      let ty = instance env funct.exp_type in
      end_def ();
      wrap_trace_gadt_instances env (lower_args []) ty;
      begin_def ();
      let (args, ty_res) = type_application env funct sargs in
      end_def ();
      unify_var env (newvar()) funct.exp_type;
      rue {
        exp_desc = Texp_apply(funct, args);
        exp_loc = loc; exp_extra = [];
        exp_type = ty_res;
        exp_attributes = sexp.pexp_attributes;
        exp_env = env }
  | Pexp_match(sarg, caselist) ->
      begin_def ();
      let arg = type_exp env sarg in
      end_def ();
      if is_nonexpansive arg then generalize arg.exp_type
      else generalize_expansive env arg.exp_type;
      let rec split_cases vc ec = function
        | [] -> List.rev vc, List.rev ec
        | {pc_lhs = {ppat_desc=Ppat_exception p}} as c :: rest ->
            split_cases vc ({c with pc_lhs = p} :: ec) rest
        | c :: rest ->
            split_cases (c :: vc) ec rest
      in
      let val_caselist, exn_caselist = split_cases [] [] caselist in
      if val_caselist = [] && exn_caselist <> [] then
        raise (Error (loc, env, No_value_clauses));
      (* Note: val_caselist = [] and exn_caselist = [], i.e. a fully
         empty pattern matching can be generated by Camlp4 with its
         revised syntax.  Let's accept it for backward compatibility. *)
      let val_cases, partial =
        type_cases env arg.exp_type ty_expected true loc val_caselist in
      let exn_cases, _ =
        type_cases env Predef.type_exn ty_expected false loc exn_caselist in
      re {
        exp_desc = Texp_match(arg, val_cases, exn_cases, partial);
        exp_loc = loc; exp_extra = [];
        exp_type = instance env ty_expected;
        exp_attributes = sexp.pexp_attributes;
        exp_env = env }
  | Pexp_try(sbody, caselist) ->
      let body = type_expect env sbody ty_expected in
      let cases, _ =
        type_cases env Predef.type_exn ty_expected false loc caselist in
      re {
        exp_desc = Texp_try(body, cases);
        exp_loc = loc; exp_extra = [];
        exp_type = body.exp_type;
        exp_attributes = sexp.pexp_attributes;
        exp_env = env }
  | Pexp_tuple sexpl ->
      if List.length sexpl < 2 then
        Syntaxerr.ill_formed_ast loc "Tuples must have at least 2 components.";
      let subtypes = List.map (fun _ -> newgenvar ()) sexpl in
      let to_unify = newgenty (Ttuple subtypes) in
      unify_exp_types loc env to_unify ty_expected;
      let expl =
        List.map2 (fun body ty -> type_expect env body ty) sexpl subtypes
      in
      re {
        exp_desc = Texp_tuple expl;
        exp_loc = loc; exp_extra = [];
        (* Keep sharing *)
        exp_type = newty (Ttuple (List.map (fun e -> e.exp_type) expl));
        exp_attributes = sexp.pexp_attributes;
        exp_env = env }
  | Pexp_construct(lid, sarg) ->
      type_construct env loc lid sarg ty_expected sexp.pexp_attributes
  | Pexp_variant(l, sarg) ->
      (* Keep sharing *)
      let ty_expected0 = instance env ty_expected in
      begin try match
        sarg, expand_head env ty_expected, expand_head env ty_expected0 with
      | Some sarg, {desc = Tvariant row}, {desc = Tvariant row0} ->
          let row = row_repr row in
          begin match row_field_repr (List.assoc l row.row_fields),
          row_field_repr (List.assoc l row0.row_fields) with
            Rpresent (Some ty), Rpresent (Some ty0) ->
              let arg = type_argument env sarg ty ty0 in
              re { exp_desc = Texp_variant(l, Some arg);
                   exp_loc = loc; exp_extra = [];
                   exp_type = ty_expected0;
                   exp_attributes = sexp.pexp_attributes;
                   exp_env = env }
          | _ -> raise Not_found
          end
      | _ -> raise Not_found
      with Not_found ->
        let arg = may_map (type_exp env) sarg in
        let arg_type = may_map (fun arg -> arg.exp_type) arg in
        rue {
          exp_desc = Texp_variant(l, arg);
          exp_loc = loc; exp_extra = [];
          exp_type= newty (Tvariant{row_fields = [l, Rpresent arg_type];
                                    row_more = newvar ();
                                    row_bound = ();
                                    row_closed = false;
                                    row_fixed = false;
                                    row_name = None});
          exp_attributes = sexp.pexp_attributes;
          exp_env = env }
      end
  | Pexp_record(lid_sexp_list, opt_sexp) ->
      if lid_sexp_list = [] then
        Syntaxerr.ill_formed_ast loc "Records cannot be empty.";
      let opt_exp =
        match opt_sexp with
          None -> None
        | Some sexp ->
            if !Clflags.principal then begin_def ();
            let exp = type_exp env sexp in
            if !Clflags.principal then begin
              end_def ();
              generalize_structure exp.exp_type
            end;
            Some exp
      in
      let ty_record, opath =
        let get_path ty =
          try
            let (p0, p,_) = extract_concrete_record env ty in
            (* XXX level may be wrong *)
            Some (p0, p, ty.level = generic_level || not !Clflags.principal)
          with Not_found -> None
        in
        match get_path ty_expected with
          None ->
            begin match opt_exp with
              None -> newvar (), None
            | Some exp ->
                match get_path exp.exp_type with
                  None -> newvar (), None
                | Some (_, p', _) as op ->
                    let decl = Env.find_type p' env in
                    begin_def ();
                    let ty =
                      newconstr p' (instance_list env decl.type_params) in
                    end_def ();
                    generalize_structure ty;
                    ty, op
            end
        | op -> ty_expected, op
      in
      let closed = (opt_sexp = None) in
      let lbl_exp_list =
        wrap_disambiguate "This record expression is expected to have" ty_record
          (type_label_a_list loc closed env
             (type_label_exp true env loc ty_record)
             opath)
          lid_sexp_list
      in
      unify_exp_types loc env ty_record (instance env ty_expected);

      (* type_label_a_list returns a list of labels sorted by lbl_pos *)
      (* note: check_duplicates would better be implemented in
         type_label_a_list directly *)
      let rec check_duplicates = function
        | (_, lbl1, _) :: (_, lbl2, _) :: _ when lbl1.lbl_pos = lbl2.lbl_pos ->
          raise(Error(loc, env, Label_multiply_defined lbl1.lbl_name))
        | _ :: rem ->
            check_duplicates rem
        | [] -> ()
      in
      check_duplicates lbl_exp_list;
      let opt_exp =
        match opt_exp, lbl_exp_list with
          None, _ -> None
        | Some exp, (lid, lbl, lbl_exp) :: _ ->
            let ty_exp = instance env exp.exp_type in
            let unify_kept lbl =
              (* do not connect overridden labels *)
              if List.for_all
                  (fun (_, lbl',_) -> lbl'.lbl_pos <> lbl.lbl_pos)
                  lbl_exp_list
              then begin
                let _, ty_arg1, ty_res1 = instance_label false lbl
                and _, ty_arg2, ty_res2 = instance_label false lbl in
                unify env ty_arg1 ty_arg2;
                unify env (instance env ty_expected) ty_res2;
                unify_exp_types exp.exp_loc env ty_exp ty_res1;
              end in
            Array.iter unify_kept lbl.lbl_all;
            Some {exp with exp_type = ty_exp}
        | _ -> assert false
      in
      let num_fields =
        match lbl_exp_list with [] -> assert false
        | (_, lbl,_)::_ -> Array.length lbl.lbl_all in
      if opt_sexp = None && List.length lid_sexp_list <> num_fields then begin
        let present_indices =
          List.map (fun (_, lbl, _) -> lbl.lbl_pos) lbl_exp_list in
        let label_names = extract_label_names sexp env ty_expected in
        let rec missing_labels n = function
            [] -> []
          | lbl :: rem ->
              if List.mem n present_indices then missing_labels (n + 1) rem
              else lbl :: missing_labels (n + 1) rem
        in
        let missing = missing_labels 0 label_names in
        raise(Error(loc, env, Label_missing missing))
      end
      else if opt_sexp <> None && List.length lid_sexp_list = num_fields then
        Location.prerr_warning loc Warnings.Useless_record_with;
      re {
        exp_desc = Texp_record(lbl_exp_list, opt_exp);
        exp_loc = loc; exp_extra = [];
        exp_type = instance env ty_expected;
        exp_attributes = sexp.pexp_attributes;
        exp_env = env }
  | Pexp_field(srecord, lid) ->
      let (record, label, _) = type_label_access env loc srecord lid in
      let (_, ty_arg, ty_res) = instance_label false label in
      unify_exp env record ty_res;
      rue {
        exp_desc = Texp_field(record, lid, label);
        exp_loc = loc; exp_extra = [];
        exp_type = ty_arg;
        exp_attributes = sexp.pexp_attributes;
        exp_env = env }
  | Pexp_setfield(srecord, lid, snewval) ->
      let (record, label, opath) = type_label_access env loc srecord lid in
      let ty_record = if opath = None then newvar () else record.exp_type in
      let (label_loc, label, newval) =
        type_label_exp false env loc ty_record (lid, label, snewval) in
      unify_exp env record ty_record;
      if label.lbl_mut = Immutable then
        raise(Error(loc, env, Label_not_mutable lid.txt));
      rue {
        exp_desc = Texp_setfield(record, label_loc, label, newval);
        exp_loc = loc; exp_extra = [];
        exp_type = instance_def Predef.type_unit;
        exp_attributes = sexp.pexp_attributes;
        exp_env = env }
  | Pexp_array(sargl) ->
      let ty = newgenvar() in
      let to_unify = Predef.type_array ty in
      unify_exp_types loc env to_unify ty_expected;
      let argl = List.map (fun sarg -> type_expect env sarg ty) sargl in
      re {
        exp_desc = Texp_array argl;
        exp_loc = loc; exp_extra = [];
        exp_type = instance env ty_expected;
        exp_attributes = sexp.pexp_attributes;
        exp_env = env }
  | Pexp_ifthenelse(scond, sifso, sifnot) ->
      let cond = type_expect env scond Predef.type_bool in
      begin match sifnot with
        None ->
          let ifso = type_expect env sifso Predef.type_unit in
          rue {
            exp_desc = Texp_ifthenelse(cond, ifso, None);
            exp_loc = loc; exp_extra = [];
            exp_type = ifso.exp_type;
            exp_attributes = sexp.pexp_attributes;
            exp_env = env }
      | Some sifnot ->
          let ifso = type_expect env sifso ty_expected in
          let ifnot = type_expect env sifnot ty_expected in
          (* Keep sharing *)
          unify_exp env ifnot ifso.exp_type;
          re {
            exp_desc = Texp_ifthenelse(cond, ifso, Some ifnot);
            exp_loc = loc; exp_extra = [];
            exp_type = ifso.exp_type;
            exp_attributes = sexp.pexp_attributes;
            exp_env = env }
      end
  | Pexp_sequence(sexp1, sexp2) ->
      let exp1 = type_statement env sexp1 in
      let exp2 = type_expect env sexp2 ty_expected in
      re {
        exp_desc = Texp_sequence(exp1, exp2);
        exp_loc = loc; exp_extra = [];
        exp_type = exp2.exp_type;
        exp_attributes = sexp.pexp_attributes;
        exp_env = env }
  | Pexp_while(scond, sbody) ->
      let cond = type_expect env scond Predef.type_bool in
      let body = type_statement env sbody in
      rue {
        exp_desc = Texp_while(cond, body);
        exp_loc = loc; exp_extra = [];
        exp_type = instance_def Predef.type_unit;
        exp_attributes = sexp.pexp_attributes;
        exp_env = env }
  | Pexp_for(param, slow, shigh, dir, sbody) ->
      let low = type_expect env slow Predef.type_int in
      let high = type_expect env shigh Predef.type_int in
      let id, new_env =
        match param.ppat_desc with
        | Ppat_any -> Ident.create "_for", env
        | Ppat_var {txt} ->
            Env.enter_value txt {val_type = instance_def Predef.type_int;
                                 val_attributes = [];
                                 val_kind = Val_reg; Types.val_loc = loc; } env
              ~check:(fun s -> Warnings.Unused_for_index s)
        | _ ->
            raise (Error (param.ppat_loc, env, Invalid_for_loop_index))
      in
      let body = type_statement new_env sbody in
      rue {
        exp_desc = Texp_for(id, param, low, high, dir, body);
        exp_loc = loc; exp_extra = [];
        exp_type = instance_def Predef.type_unit;
        exp_attributes = sexp.pexp_attributes;
        exp_env = env }
  | Pexp_constraint (sarg, sty) ->
      let separate = true in (* always separate, 1% slowdown for lablgtk *)
      if separate then begin_def ();
      let cty = Typetexp.transl_simple_type env false sty in
      let ty = cty.ctyp_type in
      let (arg, ty') =
        if separate then begin
          end_def ();
          generalize_structure ty;
          (type_argument env sarg ty (instance env ty), instance env ty)
        end else
          (type_argument env sarg ty ty, ty)
      in
      rue {
        exp_desc = arg.exp_desc;
        exp_loc = arg.exp_loc;
        exp_type = ty';
        exp_attributes = arg.exp_attributes;
        exp_env = env;
        exp_extra =
          (Texp_constraint cty, loc, sexp.pexp_attributes) :: arg.exp_extra;
      }
  | Pexp_coerce(sarg, sty, sty') ->
      let separate = true (* always separate, 1% slowdown for lablgtk *)
        (* !Clflags.principal || Env.has_local_constraints env *) in
      let (arg, ty',cty,cty') =
        match sty with
        | None ->
            let (cty', force) =
              Typetexp.transl_simple_type_delayed env sty'
            in
            let ty' = cty'.ctyp_type in
            if separate then begin_def ();
            let arg = type_exp env sarg in
            let gen =
              if separate then begin
                end_def ();
                let tv = newvar () in
                let gen = generalizable tv.level arg.exp_type in
                unify_var env tv arg.exp_type;
                gen
              end else true
            in
            begin match arg.exp_desc, !self_coercion, (repr ty').desc with
              Texp_ident(_, _, {val_kind=Val_self _}), (path,r) :: _,
              Tconstr(path',_,_) when Path.same path path' ->
                (* prerr_endline "self coercion"; *)
                r := loc :: !r;
                force ()
            | _ when free_variables ~env arg.exp_type = []
                  && free_variables ~env ty' = [] ->
                if not gen && (* first try a single coercion *)
                  let snap = snapshot () in
                  let ty, b = enlarge_type env ty' in
                  try
                    force (); Ctype.unify env arg.exp_type ty; true
                  with Unify _ ->
                    backtrack snap; false
                then ()
                else begin try
                  let force' = subtype env arg.exp_type ty' in
                  force (); force' ();
                  if not gen then
                    Location.prerr_warning loc
                      (Warnings.Not_principal "this ground coercion");
                with Subtype (tr1, tr2) ->
                  (* prerr_endline "coercion failed"; *)
                  raise(Error(loc, env, Not_subtype(tr1, tr2)))
                end;
            | _ ->
                let ty, b = enlarge_type env ty' in
                force ();
                begin try Ctype.unify env arg.exp_type ty with Unify trace ->
                  raise(Error(sarg.pexp_loc, env,
                        Coercion_failure(ty', full_expand env ty', trace, b)))
                end
            end;
            (arg, ty', None, cty')
        | Some sty ->
            if separate then begin_def ();
            let (cty, force) =
              Typetexp.transl_simple_type_delayed env sty
            and (cty', force') =
              Typetexp.transl_simple_type_delayed env sty'
            in
            let ty = cty.ctyp_type in
            let ty' = cty'.ctyp_type in
            begin try
              let force'' = subtype env ty ty' in
              force (); force' (); force'' ()
            with Subtype (tr1, tr2) ->
              raise(Error(loc, env, Not_subtype(tr1, tr2)))
            end;
            if separate then begin
              end_def ();
              generalize_structure ty;
              generalize_structure ty';
              (type_argument env sarg ty (instance env ty),
               instance env ty', Some cty, cty')
            end else
              (type_argument env sarg ty ty, ty', Some cty, cty')
      in
      rue {
        exp_desc = arg.exp_desc;
        exp_loc = arg.exp_loc;
        exp_type = ty';
        exp_attributes = arg.exp_attributes;
        exp_env = env;
        exp_extra = (Texp_coerce (cty, cty'), loc, sexp.pexp_attributes) ::
                       arg.exp_extra;
      }
  | Pexp_send (e, met) ->
      if !Clflags.principal then begin_def ();
      let obj = type_exp env e in
      begin try
        let (meth, exp, typ) =
          match obj.exp_desc with
            Texp_ident(path, _, {val_kind = Val_self (meths, _, _, privty)}) ->
              let (id, typ) =
                filter_self_method env met Private meths privty
              in
              if is_Tvar (repr typ) then
                Location.prerr_warning loc
                  (Warnings.Undeclared_virtual_method met);
              (Tmeth_val id, None, typ)
          | Texp_ident(path, lid, {val_kind = Val_anc (methods, cl_num)}) ->
              let method_id =
                begin try List.assoc met methods with Not_found ->
                  raise(Error(e.pexp_loc, env, Undefined_inherited_method met))
                end
              in
              begin match
                Env.lookup_value (Longident.Lident ("selfpat-" ^ cl_num)) env,
                Env.lookup_value (Longident.Lident ("self-" ^cl_num)) env
              with
                (_, ({val_kind = Val_self (meths, _, _, privty)} as desc)),
                (path, _) ->
                  let (_, typ) =
                    filter_self_method env met Private meths privty
                  in
                  let method_type = newvar () in
                  let (obj_ty, res_ty) = filter_arrow env method_type "" in
                  unify env obj_ty desc.val_type;
                  unify env res_ty (instance env typ);
                  let exp =
                    Texp_apply({exp_desc =
                                Texp_ident(Path.Pident method_id, lid,
                                           {val_type = method_type;
                                            val_kind = Val_reg;
                                            val_attributes = [];
                                            Types.val_loc = Location.none});
                                exp_loc = loc; exp_extra = [];
                                exp_type = method_type;
                                exp_attributes = []; (* check *)
                                exp_env = env},
                          ["",
                            Some {exp_desc = Texp_ident(path, lid, desc);
                                  exp_loc = obj.exp_loc; exp_extra = [];
                                  exp_type = desc.val_type;
                                  exp_attributes = []; (* check *)
                                  exp_env = env},
                               Required])
                  in
                  (Tmeth_name met, Some (re {exp_desc = exp;
                                             exp_loc = loc; exp_extra = [];
                                             exp_type = typ;
                                             exp_attributes = []; (* check *)
                                             exp_env = env}), typ)
              |  _ ->
                  assert false
              end
          | _ ->
              (Tmeth_name met, None,
               filter_method env met Public obj.exp_type)
        in
        if !Clflags.principal then begin
          end_def ();
          generalize_structure typ;
        end;
        let typ =
          match repr typ with
            {desc = Tpoly (ty, [])} ->
              instance env ty
          | {desc = Tpoly (ty, tl); level = l} ->
              if !Clflags.principal && l <> generic_level then
                Location.prerr_warning loc
                  (Warnings.Not_principal "this use of a polymorphic method");
              snd (instance_poly false tl ty)
          | {desc = Tvar _} as ty ->
              let ty' = newvar () in
              unify env (instance_def ty) (newty(Tpoly(ty',[])));
              (* if not !Clflags.nolabels then
                 Location.prerr_warning loc (Warnings.Unknown_method met); *)
              ty'
          | _ ->
              assert false
        in
        rue {
          exp_desc = Texp_send(obj, meth, exp);
          exp_loc = loc; exp_extra = [];
          exp_type = typ;
          exp_attributes = sexp.pexp_attributes;
          exp_env = env }
      with Unify _ ->
        raise(Error(e.pexp_loc, env, Undefined_method (obj.exp_type, met)))
      end
  | Pexp_new cl ->
      let (cl_path, cl_decl) = Typetexp.find_class env loc cl.txt in
      begin match cl_decl.cty_new with
          None ->
            raise(Error(loc, env, Virtual_class cl.txt))
        | Some ty ->
            rue {
              exp_desc = Texp_new (cl_path, cl, cl_decl);
              exp_loc = loc; exp_extra = [];
              exp_type = instance_def ty;
              exp_attributes = sexp.pexp_attributes;
              exp_env = env }
        end
  | Pexp_setinstvar (lab, snewval) ->
      begin try
        let (path, desc) = Env.lookup_value (Longident.Lident lab.txt) env in
        match desc.val_kind with
          Val_ivar (Mutable, cl_num) ->
            let newval =
              type_expect env snewval (instance env desc.val_type) in
            let (path_self, _) =
              Env.lookup_value (Longident.Lident ("self-" ^ cl_num)) env
            in
            rue {
              exp_desc = Texp_setinstvar(path_self, path, lab, newval);
              exp_loc = loc; exp_extra = [];
              exp_type = instance_def Predef.type_unit;
              exp_attributes = sexp.pexp_attributes;
              exp_env = env }
        | Val_ivar _ ->
            raise(Error(loc, env, Instance_variable_not_mutable(true,lab.txt)))
        | _ ->
            raise(Error(loc, env, Instance_variable_not_mutable(false,lab.txt)))
      with
        Not_found ->
          raise(Error(loc, env, Unbound_instance_variable lab.txt))
      end
  | Pexp_override lst ->
      let _ =
       List.fold_right
        (fun (lab, _) l ->
           if List.exists (fun l -> l.txt = lab.txt) l then
             raise(Error(loc, env,
                         Value_multiply_overridden lab.txt));
           lab::l)
        lst
        [] in
      begin match
        try
          Env.lookup_value (Longident.Lident "selfpat-*") env,
          Env.lookup_value (Longident.Lident "self-*") env
        with Not_found ->
          raise(Error(loc, env, Outside_class))
      with
        (_, {val_type = self_ty; val_kind = Val_self (_, vars, _, _)}),
        (path_self, _) ->
          let type_override (lab, snewval) =
            begin try
              let (id, _, _, ty) = Vars.find lab.txt !vars in
              (Path.Pident id, lab, type_expect env snewval (instance env ty))
            with
              Not_found ->
                raise(Error(loc, env, Unbound_instance_variable lab.txt))
            end
          in
          let modifs = List.map type_override lst in
          rue {
            exp_desc = Texp_override(path_self, modifs);
            exp_loc = loc; exp_extra = [];
            exp_type = self_ty;
            exp_attributes = sexp.pexp_attributes;
            exp_env = env }
      | _ ->
          assert false
      end
  | Pexp_letmodule(name, smodl, sbody) ->
      let ty = newvar() in
      (* remember original level *)
      begin_def ();
      Ident.set_current_time ty.level;
      let context = Typetexp.narrow () in
      let modl = !type_module env smodl in
      let (id, new_env) = Env.enter_module name.txt modl.mod_type env in
      Ctype.init_def(Ident.current_time());
      Typetexp.widen context;
      let body = type_expect new_env sbody ty_expected in
      (* go back to original level *)
      end_def ();
      (* Unification of body.exp_type with the fresh variable ty
         fails if and only if the prefix condition is violated,
         i.e. if generative types rooted at id show up in the
         type body.exp_type.  Thus, this unification enforces the
         scoping condition on "let module". *)
      begin try
        Ctype.unify_var new_env ty body.exp_type
      with Unify _ ->
        raise(Error(loc, env, Scoping_let_module(name.txt, body.exp_type)))
      end;
      re {
        exp_desc = Texp_letmodule(id, name, modl, body);
        exp_loc = loc; exp_extra = [];
        exp_type = ty;
        exp_attributes = sexp.pexp_attributes;
        exp_env = env }
  | Pexp_assert (e) ->
      let cond = type_expect env e Predef.type_bool in
      let exp_type =
        match cond.exp_desc with
        | Texp_construct(_, {cstr_name="false"}, _) ->
            instance env ty_expected
        | _ ->
            instance_def Predef.type_unit
      in
      rue {
        exp_desc = Texp_assert cond;
        exp_loc = loc; exp_extra = [];
        exp_type;
        exp_attributes = sexp.pexp_attributes;
        exp_env = env;
      }
  | Pexp_lazy e ->
      let ty = newgenvar () in
      let to_unify = Predef.type_lazy_t ty in
      unify_exp_types loc env to_unify ty_expected;
      let arg = type_expect env e ty in
      re {
        exp_desc = Texp_lazy arg;
        exp_loc = loc; exp_extra = [];
        exp_type = instance env ty_expected;
        exp_attributes = sexp.pexp_attributes;
        exp_env = env;
      }
  | Pexp_object s ->
      let desc, sign, meths = !type_object env loc s in
      rue {
        exp_desc = Texp_object (desc, (*sign,*) meths);
        exp_loc = loc; exp_extra = [];
        exp_type = sign.csig_self;
        exp_attributes = sexp.pexp_attributes;
        exp_env = env;
      }
  | Pexp_poly(sbody, sty) ->
      if !Clflags.principal then begin_def ();
      let ty, cty =
        match sty with None -> repr ty_expected, None
        | Some sty ->
            let sty = Ast_helper.Typ.force_poly sty in
            let cty = Typetexp.transl_simple_type env false sty in
            repr cty.ctyp_type, Some cty
      in
      if !Clflags.principal then begin
        end_def ();
        generalize_structure ty
      end;
      if sty <> None then
        unify_exp_types loc env (instance env ty) (instance env ty_expected);
      let exp =
        match (expand_head env ty).desc with
          Tpoly (ty', []) ->
            let exp = type_expect env sbody ty' in
            { exp with exp_type = instance env ty }
        | Tpoly (ty', tl) ->
            (* One more level to generalize locally *)
            begin_def ();
            if !Clflags.principal then begin_def ();
            let vars, ty'' = instance_poly true tl ty' in
            if !Clflags.principal then begin
              end_def ();
              generalize_structure ty''
            end;
            let exp = type_expect env sbody ty'' in
            end_def ();
            check_univars env false "method" exp ty_expected vars;
            { exp with exp_type = instance env ty }
        | Tvar _ ->
            let exp = type_exp env sbody in
            let exp = {exp with exp_type = newty (Tpoly (exp.exp_type, []))} in
            unify_exp env exp ty;
            exp
        | _ -> assert false
      in
      re { exp with exp_extra =
             (Texp_poly cty, loc, sexp.pexp_attributes) :: exp.exp_extra }
  | Pexp_newtype(name, sbody) ->
      let ty = newvar () in
      (* remember original level *)
      begin_def ();
      (* Create a fake abstract type declaration for name. *)
      let level = get_current_level () in
      let decl = {
        type_params = [];
        type_arity = 0;
        type_kind = Type_abstract;
        type_private = Public;
        type_manifest = None;
        type_variance = [];
        type_newtype_level = Some (level, level);
        type_loc = loc;
        type_attributes = [];
      }
      in
      Ident.set_current_time ty.level;
      let (id, new_env) = Env.enter_type name decl env in
      Ctype.init_def(Ident.current_time());

      let body = type_exp new_env sbody in
      (* Replace every instance of this type constructor in the resulting
         type. *)
      let seen = Hashtbl.create 8 in
      let rec replace t =
        if Hashtbl.mem seen t.id then ()
        else begin
          Hashtbl.add seen t.id ();
          match t.desc with
          | Tconstr (Path.Pident id', _, _) when id == id' -> link_type t ty
          | _ -> Btype.iter_type_expr replace t
        end
      in
      let ety = Subst.type_expr Subst.identity body.exp_type in
      replace ety;
      (* back to original level *)
      end_def ();
      (* lower the levels of the result type *)
      (* unify_var env ty ety; *)

      (* non-expansive if the body is non-expansive, so we don't introduce
         any new extra node in the typed AST. *)
      rue { body with exp_loc = loc; exp_type = ety;
            exp_extra =
            (Texp_newtype name, loc, sexp.pexp_attributes) :: body.exp_extra }
  | Pexp_pack m ->
      let (p, nl, tl) =
        match Ctype.expand_head env (instance env ty_expected) with
          {desc = Tpackage (p, nl, tl)} ->
            if !Clflags.principal &&
              (Ctype.expand_head env ty_expected).level < Btype.generic_level
            then
              Location.prerr_warning loc
                (Warnings.Not_principal "this module packing");
            (p, nl, tl)
        | {desc = Tvar _} ->
            raise (Error (loc, env, Cannot_infer_signature))
        | _ ->
            raise (Error (loc, env, Not_a_packed_module ty_expected))
      in
      let (modl, tl') = !type_package env m p nl tl in
      rue {
        exp_desc = Texp_pack modl;
        exp_loc = loc; exp_extra = [];
        exp_type = newty (Tpackage (p, nl, tl'));
        exp_attributes = sexp.pexp_attributes;
        exp_env = env }
  | Pexp_open (ovf, lid, e) ->
      let (path, newenv) = !type_open ovf env sexp.pexp_loc lid in
      let exp = type_expect newenv e ty_expected in
      { exp with
        exp_extra = (Texp_open (ovf, path, lid, newenv), loc,
                     sexp.pexp_attributes) ::
                      exp.exp_extra;
      }
  | Pexp_extension ext ->
      raise (Error_forward (Typetexp.error_of_extension ext))

and type_function ?in_function loc attrs env ty_expected l caselist =
  let (loc_fun, ty_fun) =
    match in_function with Some p -> p
    | None -> (loc, instance env ty_expected)
  in
  let separate = !Clflags.principal || Env.has_local_constraints env in
  if separate then begin_def ();
  let (ty_arg, ty_res) =
    try filter_arrow env (instance env ty_expected) l
    with Unify _ ->
      match expand_head env ty_expected with
        {desc = Tarrow _} as ty ->
          raise(Error(loc, env, Abstract_wrong_label(l, ty)))
      | _ ->
          raise(Error(loc_fun, env,
                      Too_many_arguments (in_function <> None, ty_fun)))
  in
  let ty_arg =
    if is_optional l then
      let tv = newvar() in
      begin
        try unify env ty_arg (type_option tv)
        with Unify _ -> assert false
      end;
      type_option tv
    else ty_arg
  in
  if separate then begin
    end_def ();
    generalize_structure ty_arg;
    generalize_structure ty_res
  end;
  let cases, partial =
    type_cases ~in_function:(loc_fun,ty_fun) env ty_arg ty_res
      true loc caselist in
  let not_function ty =
    let ls, tvar = list_labels env ty in
    ls = [] && not tvar
  in
  if is_optional l && not_function ty_res then
    Location.prerr_warning (List.hd cases).c_lhs.pat_loc
      Warnings.Unerasable_optional_argument;
  re {
  exp_desc = Texp_function(l,cases, partial);
    exp_loc = loc; exp_extra = [];
    exp_type = instance env (newgenty (Tarrow(l, ty_arg, ty_res, Cok)));
    exp_attributes = attrs;
    exp_env = env }


and type_label_access env loc srecord lid =
  if !Clflags.principal then begin_def ();
  let record = type_exp env srecord in
  if !Clflags.principal then begin
    end_def ();
    generalize_structure record.exp_type
  end;
  let ty_exp = record.exp_type in
  let opath =
    try
      let (p0, p,_) = extract_concrete_record env ty_exp in
      Some(p0, p, ty_exp.level = generic_level || not !Clflags.principal)
    with Not_found -> None
  in
  let labels = Typetexp.find_all_labels env lid.loc lid.txt in
  let label =
    wrap_disambiguate "This expression has" ty_exp
      (Label.disambiguate lid env opath) labels in
  (record, label, opath)

(* Typing format strings for printing or reading.
   These formats are used by functions in modules Printf, Format, and Scanf.
   (Handling of * modifiers contributed by Thorsten Ohl.) *)

and type_format loc str env =
 assert false
and type_label_exp create env loc ty_expected
          (lid, label, sarg) =
  (* Here also ty_expected may be at generic_level *)
  begin_def ();
  let separate = !Clflags.principal || Env.has_local_constraints env in
  if separate then (begin_def (); begin_def ());
  let (vars, ty_arg, ty_res) = instance_label true label in
  if separate then begin
    end_def ();
    (* Generalize label information *)
    generalize_structure ty_arg;
    generalize_structure ty_res
  end;
  begin try
    unify env (instance_def ty_res) (instance env ty_expected)
  with Unify trace ->
    raise (Error(lid.loc, env, Label_mismatch(lid.txt, trace)))
  end;
  (* Instantiate so that we can generalize internal nodes *)
  let ty_arg = instance_def ty_arg in
  if separate then begin
    end_def ();
    (* Generalize information merged from ty_expected *)
    generalize_structure ty_arg
  end;
  if label.lbl_private = Private then
    if create then
      raise (Error(loc, env, Private_type ty_expected))
    else
      raise (Error(lid.loc, env, Private_label(lid.txt, ty_expected)));
  let arg =
    let snap = if vars = [] then None else Some (Btype.snapshot ()) in
    let arg = type_argument env sarg ty_arg (instance env ty_arg) in
    end_def ();
    try
      check_univars env (vars <> []) "field value" arg label.lbl_arg vars;
      arg
    with exn when not (is_nonexpansive arg) -> try
      (* Try to retype without propagating ty_arg, cf PR#4862 *)
      may Btype.backtrack snap;
      begin_def ();
      let arg = type_exp env sarg in
      end_def ();
      generalize_expansive env arg.exp_type;
      unify_exp env arg ty_arg;
      check_univars env false "field value" arg label.lbl_arg vars;
      arg
    with Error (_, _, Less_general _) as e -> raise e
    | _ -> raise exn    (* In case of failure return the first error *)
  in
  (lid, label, {arg with exp_type = instance env arg.exp_type})

and type_argument env sarg ty_expected' ty_expected =
  (* ty_expected' may be generic *)
  let no_labels ty =
    let ls, tvar = list_labels env ty in
    not tvar && List.for_all ((=) "") ls
  in
  let rec is_inferred sexp =
    match sexp.pexp_desc with
      Pexp_ident _ | Pexp_apply _ | Pexp_field _ | Pexp_constraint _
    | Pexp_coerce _ | Pexp_send _ | Pexp_new _ -> true
    | Pexp_sequence (_, e) | Pexp_open (_, _, e) -> is_inferred e
    | Pexp_ifthenelse (_, e1, Some e2) -> is_inferred e1 && is_inferred e2
    | _ -> false
  in
  match expand_head env ty_expected' with
    {desc = Tarrow("",ty_arg,ty_res,_); level = lv} when is_inferred sarg ->
      (* apply optional arguments when expected type is "" *)
      (* we must be very careful about not breaking the semantics *)
      if !Clflags.principal then begin_def ();
      let texp = type_exp env sarg in
      if !Clflags.principal then begin
        end_def ();
        generalize_structure texp.exp_type
      end;
      let rec make_args args ty_fun =
        match (expand_head env ty_fun).desc with
        | Tarrow (l,ty_arg,ty_fun,_) when is_optional l ->
            let ty = option_none (instance env ty_arg) sarg.pexp_loc in
            make_args ((l, Some ty, Optional) :: args) ty_fun
        | Tarrow (l,_,ty_res',_) when l = "" || !Clflags.classic ->
            List.rev args, ty_fun, no_labels ty_res'
        | Tvar _ ->  List.rev args, ty_fun, false
        |  _ -> [], texp.exp_type, false
      in
      let args, ty_fun', simple_res = make_args [] texp.exp_type in
      let warn = !Clflags.principal &&
        (lv <> generic_level || (repr ty_fun').level <> generic_level)
      and texp = {texp with exp_type = instance env texp.exp_type}
      and ty_fun = instance env ty_fun' in
      if not (simple_res || no_labels ty_res) then begin
        unify_exp env texp ty_expected;
        texp
      end else begin
      unify_exp env {texp with exp_type = ty_fun} ty_expected;
      if args = [] then texp else
      (* eta-expand to avoid side effects *)
      let var_pair name ty =
        let id = Ident.create name in
        {pat_desc = Tpat_var (id, mknoloc name); pat_type = ty;pat_extra=[];
         pat_attributes = [];
         pat_loc = Location.none; pat_env = env},
        {exp_type = ty; exp_loc = Location.none; exp_env = env;
         exp_extra = []; exp_attributes = [];
         exp_desc =
         Texp_ident(Path.Pident id, mknoloc (Longident.Lident name),
                    {val_type = ty; val_kind = Val_reg;
                     val_attributes = [];
                     Types.val_loc = Location.none})}
      in
      let eta_pat, eta_var = var_pair "eta" ty_arg in
      let func texp =
        let e =
          {texp with exp_type = ty_res; exp_desc =
           Texp_apply
             (texp,
              args @ ["", Some eta_var, Required])}
        in
        { texp with exp_type = ty_fun; exp_desc =
          Texp_function("", [case eta_pat e], Total) }
      in
      Location.prerr_warning texp.exp_loc
        (Warnings.Eliminated_optional_arguments (List.map (fun (l, _, _) -> l) args));
      if warn then Location.prerr_warning texp.exp_loc
          (Warnings.Without_principality "eliminated optional argument");
      if is_nonexpansive texp then func texp else
      (* let-expand to have side effects *)
      let let_pat, let_var = var_pair "arg" texp.exp_type in
      re { texp with exp_type = ty_fun; exp_desc =
           Texp_let (Nonrecursive,
                     [{vb_pat=let_pat; vb_expr=texp; vb_attributes=[];
                       vb_loc=Location.none;
                      }],
                     func let_var) }
      end
  | _ ->
      let texp = type_expect env sarg ty_expected' in
      unify_exp env texp ty_expected;
      texp

and type_application env funct sargs =
  (* funct.exp_type may be generic *)
  let result_type omitted ty_fun =
    List.fold_left
      (fun ty_fun (l,ty,lv) -> newty2 lv (Tarrow(l,ty,ty_fun,Cok)))
      ty_fun omitted
  in
  let has_label l ty_fun =
    let ls, tvar = list_labels env ty_fun in
    tvar || List.mem l ls
  in
  let ignored = ref [] in
  let rec type_unknown_args
      (args :
      (Asttypes.label * (unit -> Typedtree.expression) option *
         Typedtree.optional) list)
    omitted ty_fun = function
      [] ->
        (List.map
            (function l, None, x -> l, None, x
                | l, Some f, x -> l, Some (f ()), x)
           (List.rev args),
         instance env (result_type omitted ty_fun))
    | (l1, sarg1) :: sargl ->
        let (ty1, ty2) =
          let ty_fun = expand_head env ty_fun in
          match ty_fun.desc with
            Tvar _ ->
              let t1 = newvar () and t2 = newvar () in
              let not_identity = function
                  Texp_ident(_,_,{val_kind=Val_prim
                                  {Primitive.prim_name="%identity"}}) ->
                    false
                | _ -> true
              in
              if ty_fun.level >= t1.level && not_identity funct.exp_desc then
                Location.prerr_warning sarg1.pexp_loc Warnings.Unused_argument;
              unify env ty_fun (newty (Tarrow(l1,t1,t2,Clink(ref Cunknown))));
              (t1, t2)
          | Tarrow (l,t1,t2,_) when l = l1
            || !Clflags.classic && l1 = "" && not (is_optional l) ->
              (t1, t2)
          | td ->
              let ty_fun =
                match td with Tarrow _ -> newty td | _ -> ty_fun in
              let ty_res = result_type (omitted @ !ignored) ty_fun in
              match ty_res.desc with
                Tarrow _ ->
                  if (!Clflags.classic || not (has_label l1 ty_fun)) then
                    raise (Error(sarg1.pexp_loc, env,
                                 Apply_wrong_label(l1, ty_res)))
                  else
                    raise (Error(funct.exp_loc, env, Incoherent_label_order))
              | _ ->
                  raise(Error(funct.exp_loc, env, Apply_non_function
                                (expand_head env funct.exp_type)))
        in
        let optional = if is_optional l1 then Optional else Required in
        let arg1 () =
          let arg1 = type_expect env sarg1 ty1 in
          if optional = Optional then
            unify_exp env arg1 (type_option(newvar()));
          arg1
        in
        type_unknown_args ((l1, Some arg1, optional) :: args) omitted ty2 sargl
  in
  let ignore_labels =
    !Clflags.classic ||
    begin
      let ls, tvar = list_labels env funct.exp_type in
      not tvar &&
      let labels = List.filter (fun l -> not (is_optional l)) ls in
      List.length labels = List.length sargs &&
      List.for_all (fun (l,_) -> l = "") sargs &&
      List.exists (fun l -> l <> "") labels &&
      (Location.prerr_warning funct.exp_loc Warnings.Labels_omitted;
       true)
    end
  in
  let warned = ref false in
  let rec type_args args omitted ty_fun ty_fun0 ty_old sargs more_sargs =
    match expand_head env ty_fun, expand_head env ty_fun0 with
      {desc=Tarrow (l, ty, ty_fun, com); level=lv} as ty_fun',
      {desc=Tarrow (_, ty0, ty_fun0, _)}
      when (sargs <> [] || more_sargs <> []) && commu_repr com = Cok ->
        let may_warn loc w =
          if not !warned && !Clflags.principal && lv <> generic_level
          then begin
            warned := true;
            Location.prerr_warning loc w
          end
        in
        let name = label_name l
        and optional = if is_optional l then Optional else Required in
        let sargs, more_sargs, arg =
          if ignore_labels && not (is_optional l) then begin
            (* In classic mode, omitted = [] *)
            match sargs, more_sargs with
              (l', sarg0) :: _, _ ->
                raise(Error(sarg0.pexp_loc, env,
                            Apply_wrong_label(l', ty_old)))
            | _, (l', sarg0) :: more_sargs ->
                if l <> l' && l' <> "" then
                  raise(Error(sarg0.pexp_loc, env,
                              Apply_wrong_label(l', ty_fun')))
                else
                  ([], more_sargs,
                   Some (fun () -> type_argument env sarg0 ty ty0))
            | _ ->
                assert false
          end else try
            let (l', sarg0, sargs, more_sargs) =
              try
                let (l', sarg0, sargs1, sargs2) = extract_label name sargs in
                if sargs1 <> [] then
                  may_warn sarg0.pexp_loc
                    (Warnings.Not_principal "commuting this argument");
                (l', sarg0, sargs1 @ sargs2, more_sargs)
              with Not_found ->
                let (l', sarg0, sargs1, sargs2) =
                  extract_label name more_sargs in
                if sargs1 <> [] || sargs <> [] then
                  may_warn sarg0.pexp_loc
                    (Warnings.Not_principal "commuting this argument");
                (l', sarg0, sargs @ sargs1, sargs2)
            in
            if optional = Required && is_optional l' then
              Location.prerr_warning sarg0.pexp_loc
                (Warnings.Nonoptional_label l);
            sargs, more_sargs,
            if optional = Required || is_optional l' then
              Some (fun () -> type_argument env sarg0 ty ty0)
            else begin
              may_warn sarg0.pexp_loc
                (Warnings.Not_principal "using an optional argument here");
              Some (fun () -> option_some (type_argument env sarg0
                                             (extract_option_type env ty)
                                             (extract_option_type env ty0)))
            end
          with Not_found ->
            sargs, more_sargs,
            if optional = Optional &&
              (List.mem_assoc "" sargs || List.mem_assoc "" more_sargs)
            then begin
              may_warn funct.exp_loc
                (Warnings.Without_principality "eliminated optional argument");
              ignored := (l,ty,lv) :: !ignored;
              Some (fun () -> option_none (instance env ty) Location.none)
            end else begin
              may_warn funct.exp_loc
                (Warnings.Without_principality "commuted an argument");
              None
            end
        in
        let omitted =
          if arg = None then (l,ty,lv) :: omitted else omitted in
        let ty_old = if sargs = [] then ty_fun else ty_old in
        type_args ((l,arg,optional)::args) omitted ty_fun ty_fun0
          ty_old sargs more_sargs
    | _ ->
        match sargs with
          (l, sarg0) :: _ when ignore_labels ->
            raise(Error(sarg0.pexp_loc, env,
                        Apply_wrong_label(l, ty_old)))
        | _ ->
            type_unknown_args args omitted ty_fun0
              (sargs @ more_sargs)
  in
  match funct.exp_desc, sargs with
    (* Special case for ignore: avoid discarding warning *)
    Texp_ident (_, _, {val_kind=Val_prim{Primitive.prim_name="%ignore"}}),
    ["", sarg] ->
      let ty_arg, ty_res = filter_arrow env (instance env funct.exp_type) "" in
      let exp = type_expect env sarg ty_arg in
      begin match (expand_head env exp.exp_type).desc with
      | Tarrow _ ->
          Location.prerr_warning exp.exp_loc Warnings.Partial_application
      | Tvar _ ->
          add_delayed_check (fun () -> check_application_result env false exp)
      | _ -> ()
      end;
      (["", Some exp, Required], ty_res)
  | _ ->
      let ty = funct.exp_type in
      if ignore_labels then
        type_args [] [] ty (instance env ty) ty [] sargs
      else
        type_args [] [] ty (instance env ty) ty sargs []

and type_construct env loc lid sarg ty_expected attrs =
  let opath =
    try
      let (p0, p,_) = extract_concrete_variant env ty_expected in
      Some(p0, p, ty_expected.level = generic_level || not !Clflags.principal)
    with Not_found -> None
  in
  let constrs = Typetexp.find_all_constructors env lid.loc lid.txt in
  let constr =
    wrap_disambiguate "This variant expression is expected to have" ty_expected
      (Constructor.disambiguate lid env opath) constrs in
  Env.mark_constructor Env.Positive env (Longident.last lid.txt) constr;
  Typetexp.check_deprecated loc constr.cstr_attributes constr.cstr_name;
  let sargs =
    match sarg with
      None -> []
    | Some {pexp_desc = Pexp_tuple sel} when
        constr.cstr_arity > 1 || explicit_arity attrs
      -> sel
    | Some se -> [se] in
  if List.length sargs <> constr.cstr_arity then
    raise(Error(loc, env, Constructor_arity_mismatch
                  (lid.txt, constr.cstr_arity, List.length sargs)));
  let separate = !Clflags.principal || Env.has_local_constraints env in
  if separate then (begin_def (); begin_def ());
  let (ty_args, ty_res) = instance_constructor constr in
  let texp =
    re {
      exp_desc = Texp_construct(lid, constr, []);
      exp_loc = loc; exp_extra = [];
      exp_type = ty_res;
      exp_attributes = attrs;
      exp_env = env } in
  if separate then begin
    end_def ();
    generalize_structure ty_res;
    unify_exp env {texp with exp_type = instance_def ty_res}
                  (instance env ty_expected);
    end_def ();
    List.iter generalize_structure ty_args;
    generalize_structure ty_res;
  end;
  let ty_args0, ty_res =
    match instance_list env (ty_res :: ty_args) with
      t :: tl -> tl, t
    | _ -> assert false
  in
  let texp = {texp with exp_type = ty_res} in
  if not separate then unify_exp env texp (instance env ty_expected);
  let args = List.map2 (fun e (t,t0) -> type_argument env e t t0) sargs
      (List.combine ty_args ty_args0) in
  if constr.cstr_private = Private then
    raise(Error(loc, env, Private_type ty_res));
  (* NOTE: shouldn't we call "re" on this final expression? -- AF *)
  { texp with
    exp_desc = Texp_construct(lid, constr, args) }

(* Typing of statements (expressions whose values are discarded) *)

and type_statement env sexp =
  let loc = (final_subexpression sexp).pexp_loc in
  begin_def();
  let exp = type_exp env sexp in
  end_def();
  if !Clflags.strict_sequence then
    let expected_ty = instance_def Predef.type_unit in
    unify_exp env exp expected_ty;
    exp else
  let ty = expand_head env exp.exp_type and tv = newvar() in
  begin match ty.desc with
  | Tarrow _ ->
      Location.prerr_warning loc Warnings.Partial_application
  | Tconstr (p, _, _) when Path.same p Predef.path_unit -> ()
  | Tvar _ when ty.level > tv.level ->
      Location.prerr_warning loc Warnings.Nonreturning_statement
  | Tvar _ ->
      add_delayed_check (fun () -> check_application_result env true exp)
  | _ ->
      Location.prerr_warning loc Warnings.Statement_type
  end;
  unify_var env tv ty;
  exp

(* Typing of match cases *)

and type_cases ?in_function env ty_arg ty_res partial_flag loc caselist =
  (* ty_arg is _fully_ generalized *)
  let patterns = List.map (fun {pc_lhs=p} -> p) caselist in
  let erase_either =
    List.exists contains_polymorphic_variant patterns
    && contains_variant_either ty_arg
  and has_gadts = List.exists (contains_gadt env) patterns in
(*  prerr_endline ( if has_gadts then "contains gadt" else "no gadt"); *)
  let ty_arg =
    if (has_gadts || erase_either) && not !Clflags.principal
    then correct_levels ty_arg else ty_arg
  and ty_res, env =
    if has_gadts && not !Clflags.principal then
      correct_levels ty_res, duplicate_ident_types loc caselist env
    else ty_res, env
  in
  let lev, env =
    if has_gadts then begin
      (* raise level for existentials *)
      begin_def ();
      Ident.set_current_time (get_current_level ());
      let lev = Ident.current_time () in
      Ctype.init_def (lev+1000);                 (* up to 1000 existentials *)
      (lev, Env.add_gadt_instance_level lev env)
    end else (get_current_level (), env)
  in
(*  if has_gadts then
    Format.printf "lev = %d@.%a@." lev Printtyp.raw_type_expr ty_res; *)
  begin_def (); (* propagation of the argument *)
  let ty_arg' = newvar () in
  let pattern_force = ref [] in
(*  Format.printf "@[%i %i@ %a@]@." lev (get_current_level())
    Printtyp.raw_type_expr ty_arg; *)
  let pat_env_list =
    List.map
      (fun {pc_lhs; pc_guard; pc_rhs} ->
        let loc =
          let open Location in
          match pc_guard with
          | None -> pc_rhs.pexp_loc
          | Some g -> {pc_rhs.pexp_loc with loc_start=g.pexp_loc.loc_start}
        in
        if !Clflags.principal then begin_def (); (* propagation of pattern *)
        let scope = Some (Annot.Idef loc) in
        let (pat, ext_env, force, unpacks) =
          let partial =
            if !Clflags.principal || erase_either
            then Some false else None in
          let ty_arg = instance ?partial env ty_arg in
          type_pattern ~lev env pc_lhs scope ty_arg
        in
        pattern_force := force @ !pattern_force;
        let pat =
          if !Clflags.principal then begin
            end_def ();
            iter_pattern (fun {pat_type=t} -> generalize_structure t) pat;
            { pat with pat_type = instance env pat.pat_type }
          end else pat
        in
        (pat, (ext_env, unpacks)))
      caselist in
  (* Unify cases (delayed to keep it order-free) *)
  let patl = List.map fst pat_env_list in
  List.iter (fun pat -> unify_pat env pat ty_arg') patl;
  (* Check for polymorphic variants to close *)
  if List.exists has_variants patl then begin
    Parmatch.pressure_variants env patl;
    List.iter (iter_pattern finalize_variant) patl
  end;
  (* `Contaminating' unifications start here *)
  List.iter (fun f -> f()) !pattern_force;
  (* Post-processing and generalization *)
  List.iter (iter_pattern (fun {pat_type=t} -> unify_var env t (newvar())))
    patl;
  List.iter (fun pat -> unify_pat env pat (instance env ty_arg)) patl;
  end_def ();
  List.iter (iter_pattern (fun {pat_type=t} -> generalize t)) patl;
  (* type bodies *)
  let in_function = if List.length caselist = 1 then in_function else None in
  let cases =
    List.map2
      (fun (pat, (ext_env, unpacks)) {pc_lhs; pc_guard; pc_rhs} ->
        let sexp = wrap_unpacks pc_rhs unpacks in
        let ty_res' =
          if !Clflags.principal then begin
            begin_def ();
            let ty = instance ~partial:true env ty_res in
            end_def ();
            generalize_structure ty; ty
          end
          else if contains_gadt env pc_lhs then correct_levels ty_res
          else ty_res in
(*        Format.printf "@[%i %i, ty_res' =@ %a@]@." lev (get_current_level())
          Printtyp.raw_type_expr ty_res'; *)
        let guard =
          match pc_guard with
          | None -> None
          | Some scond ->
              Some
                (type_expect ext_env (wrap_unpacks scond unpacks)
                   Predef.type_bool)
        in
        let exp = type_expect ?in_function ext_env sexp ty_res' in
        {
         c_lhs = pat;
         c_guard = guard;
         c_rhs = {exp with exp_type = instance env ty_res'}
        }
      )
      pat_env_list caselist
  in
  if !Clflags.principal || has_gadts then begin
    let ty_res' = instance env ty_res in
    List.iter (fun c -> unify_exp env c.c_rhs ty_res') cases
  end;
  let partial =
    if partial_flag then
      check_partial ~lev env ty_arg loc cases
    else
      Partial
  in
  add_delayed_check
    (fun () ->
      List.iter (fun (pat, (env, _)) -> check_absent_variant env pat)
        pat_env_list;
      Parmatch.check_unused env cases);
  if has_gadts then begin
    end_def ();
    (* Ensure that existential types do not escape *)
    unify_exp_types loc env (instance env ty_res) (newvar ()) ;
  end;
  cases, partial

(* Typing of let bindings *)

and type_let ?(check = fun s -> Warnings.Unused_var s)
             ?(check_strict = fun s -> Warnings.Unused_var_strict s)
    env rec_flag spat_sexp_list scope allow =
  let open Ast_helper in
  begin_def();
  if !Clflags.principal then begin_def ();

  let is_fake_let =
    match spat_sexp_list with
    | [{pvb_expr={pexp_desc=Pexp_match(
           {pexp_desc=Pexp_ident({ txt = Longident.Lident "*opt*"})},_)}}] ->
        true (* the fake let-declaration introduced by fun ?(x = e) -> ... *)
    | _ ->
        false
  in
  let check = if is_fake_let then check_strict else check in

  let spatl =
    List.map
      (fun {pvb_pat=spat; pvb_expr=sexp; pvb_attributes=_} ->
        match spat.ppat_desc, sexp.pexp_desc with
          (Ppat_any | Ppat_constraint _), _ -> spat
        | _, Pexp_coerce (_, _, sty)
        | _, Pexp_constraint (_, sty) when !Clflags.principal ->
            (* propagate type annotation to pattern,
               to allow it to be generalized in -principal mode *)
            Pat.constraint_
              ~loc:{spat.ppat_loc with Location.loc_ghost=true}
              spat
              sty
        | _ -> spat)
      spat_sexp_list in
  let nvs = List.map (fun _ -> newvar ()) spatl in
  let (pat_list, new_env, force, unpacks) =
    type_pattern_list env spatl scope nvs allow in
  let is_recursive = (rec_flag = Recursive) in
  (* If recursive, first unify with an approximation of the expression *)
  if is_recursive then
    List.iter2
      (fun pat binding ->
        let pat =
          match pat.pat_type.desc with
          | Tpoly (ty, tl) ->
              {pat with pat_type =
               snd (instance_poly ~keep_names:true false tl ty)}
          | _ -> pat
        in unify_pat env pat (type_approx env binding.pvb_expr))
      pat_list spat_sexp_list;
  (* Polymorphic variant processing *)
  List.iter
    (fun pat ->
      if has_variants pat then begin
        Parmatch.pressure_variants env [pat];
        iter_pattern finalize_variant pat
      end)
    pat_list;
  (* Generalize the structure *)
  let pat_list =
    if !Clflags.principal then begin
      end_def ();
      List.map
        (fun pat ->
          iter_pattern (fun pat -> generalize_structure pat.pat_type) pat;
          {pat with pat_type = instance env pat.pat_type})
        pat_list
    end else pat_list in
  (* Only bind pattern variables after generalizing *)
  List.iter (fun f -> f()) force;
  let exp_env =
    if is_recursive then new_env else env in

  let current_slot = ref None in
  let rec_needed = ref false in
  let warn_unused =
    Warnings.is_active (check "") || Warnings.is_active (check_strict "") ||
    (is_recursive && (Warnings.is_active Warnings.Unused_rec_flag))
  in
  let pat_slot_list =
    (* Algorithm to detect unused declarations in recursive bindings:
       - During type checking of the definitions, we capture the 'value_used'
         events on the bound identifiers and record them in a slot corresponding
         to the current definition (!current_slot).
         In effect, this creates a dependency graph between definitions.

       - After type checking the definition (!current_slot = None),
         when one of the bound identifier is effectively used, we trigger
         again all the events recorded in the corresponding slot.
         The effect is to traverse the transitive closure of the graph created
         in the first step.

       We also keep track of whether *all* variables in a given pattern
       are unused. If this is the case, for local declarations, the issued
       warning is 26, not 27.
     *)
    List.map
      (fun pat ->
        if not warn_unused then pat, None
        else
          let some_used = ref false in
            (* has one of the identifier of this pattern been used? *)
          let slot = ref [] in
          List.iter
            (fun (id,_) ->
              let vd = Env.find_value (Path.Pident id) new_env in
              (* note: Env.find_value does not trigger the value_used event *)
              let name = Ident.name id in
              let used = ref false in
              if not (name = "" || name.[0] = '_' || name.[0] = '#') then
                add_delayed_check
                  (fun () ->
                    if not !used then
                      Location.prerr_warning vd.Types.val_loc
                        ((if !some_used then check_strict else check) name)
                  );
              Env.set_value_used_callback
                name vd
                (fun () ->
                  match !current_slot with
                  | Some slot ->
                      slot := (name, vd) :: !slot; rec_needed := true
                  | None ->
                      List.iter
                        (fun (name, vd) -> Env.mark_value_used env name vd)
                        (get_ref slot);
                      used := true;
                      some_used := true
                )
            )
            (Typedtree.pat_bound_idents pat);
          pat, Some slot
        )
      pat_list
  in
  let exp_list =
    List.map2
      (fun {pvb_expr=sexp; _} (pat, slot) ->
        let sexp =
          if rec_flag = Recursive then wrap_unpacks sexp unpacks else sexp in
        if is_recursive then current_slot := slot;
        match pat.pat_type.desc with
        | Tpoly (ty, tl) ->
            begin_def ();
            if !Clflags.principal then begin_def ();
            let vars, ty' = instance_poly ~keep_names:true true tl ty in
            if !Clflags.principal then begin
              end_def ();
              generalize_structure ty'
            end;
            let exp = type_expect exp_env sexp ty' in
            end_def ();
            check_univars env true "definition" exp pat.pat_type vars;
            {exp with exp_type = instance env exp.exp_type}
        | _ -> type_expect exp_env sexp pat.pat_type)
      spat_sexp_list pat_slot_list in
  current_slot := None;
  if is_recursive && not !rec_needed
  && Warnings.is_active Warnings.Unused_rec_flag then
    Location.prerr_warning (List.hd spat_sexp_list).pvb_pat.ppat_loc
      Warnings.Unused_rec_flag;
  List.iter2
    (fun pat exp ->
      ignore(check_partial env pat.pat_type pat.pat_loc [case pat exp]))
    pat_list exp_list;
  end_def();
  List.iter2
    (fun pat exp ->
       if not (is_nonexpansive exp) then
         iter_pattern (fun pat -> generalize_expansive env pat.pat_type) pat)
    pat_list exp_list;
  List.iter
    (fun pat -> iter_pattern (fun pat -> generalize pat.pat_type) pat)
    pat_list;
  let l = List.combine pat_list exp_list in
  let l =
    List.map2
      (fun (p, e) pvb ->
        {vb_pat=p; vb_expr=e; vb_attributes=pvb.pvb_attributes;
         vb_loc=pvb.pvb_loc;
        })
      l spat_sexp_list
  in
  (l, new_env, unpacks)

(* Typing of toplevel bindings *)

let type_binding env rec_flag spat_sexp_list scope =
  Typetexp.reset_type_variables();
  let (pat_exp_list, new_env, unpacks) =
    type_let
      ~check:(fun s -> Warnings.Unused_value_declaration s)
      ~check_strict:(fun s -> Warnings.Unused_value_declaration s)
      env rec_flag spat_sexp_list scope false
  in
  (pat_exp_list, new_env)

let type_let env rec_flag spat_sexp_list scope =
  let (pat_exp_list, new_env, unpacks) =
    type_let env rec_flag spat_sexp_list scope false in
  (pat_exp_list, new_env)

(* Typing of toplevel expressions *)

let type_expression env sexp =
  Typetexp.reset_type_variables();
  begin_def();
  let exp = type_exp env sexp in
  end_def();
  if is_nonexpansive exp then generalize exp.exp_type
  else generalize_expansive env exp.exp_type;
  match sexp.pexp_desc with
    Pexp_ident lid ->
      (* Special case for keeping type variables when looking-up a variable *)
      let (path, desc) = Env.lookup_value lid.txt env in
      {exp with exp_type = desc.val_type}
  | _ -> exp

(* Error report *)

open Format
open Printtyp

let report_error env ppf = function
  | Polymorphic_label lid ->
      fprintf ppf "@[The record field %a is polymorphic.@ %s@]"
        longident lid "You cannot instantiate it in a pattern."
  | Constructor_arity_mismatch(lid, expected, provided) ->
      fprintf ppf
       "@[The constructor %a@ expects %i argument(s),@ \
        but is applied here to %i argument(s)@]"
       longident lid expected provided
  | Label_mismatch(lid, trace) ->
      report_unification_error ppf env trace
        (function ppf ->
           fprintf ppf "The record field %a@ belongs to the type"
                   longident lid)
        (function ppf ->
           fprintf ppf "but is mixed here with fields of type")
  | Pattern_type_clash trace ->
      report_unification_error ppf env trace
        (function ppf ->
          fprintf ppf "This pattern matches values of type")
        (function ppf ->
          fprintf ppf "but a pattern was expected which matches values of type")
  | Or_pattern_type_clash (id, trace) ->
      report_unification_error ppf env trace
        (function ppf ->
          fprintf ppf "The variable %s on the left-hand side of this or-pattern has type" (Ident.name id))
        (function ppf ->
          fprintf ppf "but on the right-hand side it has type")
  | Multiply_bound_variable name ->
      fprintf ppf "Variable %s is bound several times in this matching" name
  | Orpat_vars id ->
      fprintf ppf "Variable %s must occur on both sides of this | pattern"
        (Ident.name id)
  | Expr_type_clash trace ->
      report_unification_error ppf env trace
        (function ppf ->
           fprintf ppf "This expression has type")
        (function ppf ->
           fprintf ppf "but an expression was expected of type")
  | Apply_non_function typ ->
      reset_and_mark_loops typ;
      begin match (repr typ).desc with
        Tarrow _ ->
          fprintf ppf "@[<v>@[<2>This function has type@ %a@]"
            type_expr typ;
          fprintf ppf "@ @[It is applied to too many arguments;@ %s@]@]"
                      "maybe you forgot a `;'."
      | _ ->
          fprintf ppf "@[<v>@[<2>This expression has type@ %a@]@ %s@]"
            type_expr typ
            "This is not a function; it cannot be applied."
      end
  | Apply_wrong_label (l, ty) ->
      let print_label ppf = function
        | "" -> fprintf ppf "without label"
        | l ->
            fprintf ppf "with label %s" (prefixed_label_name l)
      in
      reset_and_mark_loops ty;
      fprintf ppf
        "@[<v>@[<2>The function applied to this argument has type@ %a@]@.\
          This argument cannot be applied %a@]"
        type_expr ty print_label l
  | Label_multiply_defined s ->
      fprintf ppf "The record field label %s is defined several times" s
  | Label_missing labels ->
      let print_labels ppf =
        List.iter (fun lbl -> fprintf ppf "@ %s" (Ident.name lbl)) in
      fprintf ppf "@[<hov>Some record fields are undefined:%a@]"
        print_labels labels
  | Label_not_mutable lid ->
      fprintf ppf "The record field %a is not mutable" longident lid
  | Wrong_name (eorp, ty, kind, p, lid) ->
      reset_and_mark_loops ty;
      fprintf ppf "@[@[<2>%s type@ %a@]@ "
        eorp type_expr ty;
      fprintf ppf "The %s %a does not belong to type %a@]"
        (if kind = "record" then "field" else "constructor")
        longident lid (*kind*) path p;
      if kind = "record" then Label.spellcheck ppf env p lid
                         else Constructor.spellcheck ppf env p lid
  | Name_type_mismatch (kind, lid, tp, tpl) ->
      let name = if kind = "record" then "field" else "constructor" in
      report_ambiguous_type_error ppf env tp tpl
        (function ppf ->
           fprintf ppf "The %s %a@ belongs to the %s type"
             name longident lid kind)
        (function ppf ->
           fprintf ppf "The %s %a@ belongs to one of the following %s types:"
             name longident lid kind)
        (function ppf ->
           fprintf ppf "but a %s was expected belonging to the %s type"
             name kind)
  | Invalid_format msg ->
      fprintf ppf "%s" msg
  | Undefined_method (ty, me) ->
      reset_and_mark_loops ty;
      fprintf ppf
        "@[<v>@[This expression has type@;<1 2>%a@]@,\
         It has no method %s@]" type_expr ty me
  | Undefined_inherited_method me ->
      fprintf ppf "This expression has no method %s" me
  | Virtual_class cl ->
      fprintf ppf "Cannot instantiate the virtual class %a"
        longident cl
  | Unbound_instance_variable v ->
      fprintf ppf "Unbound instance variable %s" v
  | Instance_variable_not_mutable (b, v) ->
      if b then
        fprintf ppf "The instance variable %s is not mutable" v
      else
        fprintf ppf "The value %s is not an instance variable" v
  | Not_subtype(tr1, tr2) ->
      report_subtyping_error ppf env tr1 "is not a subtype of" tr2
  | Outside_class ->
      fprintf ppf "This object duplication occurs outside a method definition"
  | Value_multiply_overridden v ->
      fprintf ppf "The instance variable %s is overridden several times" v
  | Coercion_failure (ty, ty', trace, b) ->
      report_unification_error ppf env trace
        (function ppf ->
           let ty, ty' = prepare_expansion (ty, ty') in
           fprintf ppf
             "This expression cannot be coerced to type@;<1 2>%a;@ it has type"
           (type_expansion ty) ty')
        (function ppf ->
           fprintf ppf "but is here used with type");
      if b then
        fprintf ppf ".@.@[<hov>%s@ %s@]"
          "This simple coercion was not fully general."
          "Consider using a double coercion."
  | Too_many_arguments (in_function, ty) ->
      reset_and_mark_loops ty;
      if in_function then begin
        fprintf ppf "This function expects too many arguments,@ ";
        fprintf ppf "it should have type@ %a"
          type_expr ty
      end else begin
        fprintf ppf "This expression should not be a function,@ ";
        fprintf ppf "the expected type is@ %a"
          type_expr ty
      end
  | Abstract_wrong_label (l, ty) ->
      let label_mark = function
        | "" -> "but its first argument is not labelled"
        |  l -> sprintf "but its first argument is labelled %s"
          (prefixed_label_name l) in
      reset_and_mark_loops ty;
      fprintf ppf "@[<v>@[<2>This function should have type@ %a@]@,%s@]"
      type_expr ty (label_mark l)
  | Scoping_let_module(id, ty) ->
      reset_and_mark_loops ty;
      fprintf ppf
       "This `let module' expression has type@ %a@ " type_expr ty;
      fprintf ppf
       "In this type, the locally bound module name %s escapes its scope" id
  | Masked_instance_variable lid ->
      fprintf ppf
        "The instance variable %a@ \
         cannot be accessed from the definition of another instance variable"
        longident lid
  | Private_type ty ->
      fprintf ppf "Cannot create values of the private type %a" type_expr ty
  | Private_label (lid, ty) ->
      fprintf ppf "Cannot assign field %a of the private type %a"
        longident lid type_expr ty
  | Not_a_variant_type lid ->
      fprintf ppf "The type %a@ is not a variant type" longident lid
  | Incoherent_label_order ->
      fprintf ppf "This function is applied to arguments@ ";
      fprintf ppf "in an order different from other calls.@ ";
      fprintf ppf "This is only allowed when the real type is known."
  | Less_general (kind, trace) ->
      report_unification_error ppf env trace
        (fun ppf -> fprintf ppf "This %s has type" kind)
        (fun ppf -> fprintf ppf "which is less general than")
  | Modules_not_allowed ->
      fprintf ppf "Modules are not allowed in this pattern."
  | Cannot_infer_signature ->
      fprintf ppf
        "The signature for this packaged module couldn't be inferred."
  | Not_a_packed_module ty ->
      fprintf ppf
        "This expression is packed module, but the expected type is@ %a"
        type_expr ty
  | Recursive_local_constraint trace ->
      report_unification_error ppf env trace
        (function ppf ->
           fprintf ppf "Recursive local constraint when unifying")
        (function ppf ->
           fprintf ppf "with")
  | Unexpected_existential ->
      fprintf ppf
        "Unexpected existential"
  | Unqualified_gadt_pattern (tpath, name) ->
      fprintf ppf "@[The GADT constructor %s of type %a@ %s.@]"
        name path tpath
        "must be qualified in this pattern"
  | Invalid_interval ->
      fprintf ppf "@[Only character intervals are supported in patterns.@]"
  | Invalid_for_loop_index ->
      fprintf ppf
        "@[Invalid for-loop index: only variables and _ are allowed.@]"
  | No_value_clauses ->
      fprintf ppf
        "None of the patterns in this 'match' expression match values."
  | Exception_pattern_below_toplevel ->
      fprintf ppf
        "@[Exception patterns must be at the top level of a match case.@]"

let report_error env ppf err =
  wrap_printing_env env (fun () -> report_error env ppf err)

let () =
  Location.register_error_of_exn
    (function
      | Error (loc, env, err) ->
        Some (Location.error_of_printer loc (report_error env) err)
      | Error_forward err ->
        Some err
      | _ ->
        None
    )

let () =
  Env.add_delayed_check_forward := add_delayed_check

end
module Typedecl : sig
(*#1 "typedecl.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Typing of type definitions and primitive definitions *)

open Types
open Format

val transl_type_decl:
    Env.t -> Asttypes.rec_flag -> Parsetree.type_declaration list ->
    Typedtree.type_declaration list * Env.t

val transl_exception:
    Env.t ->
    Parsetree.extension_constructor -> Typedtree.extension_constructor * Env.t

val transl_type_extension:
    bool -> Env.t -> Location.t -> Parsetree.type_extension ->
    Typedtree.type_extension * Env.t

val transl_value_decl:
    Env.t -> Location.t ->
    Parsetree.value_description -> Typedtree.value_description * Env.t

val transl_with_constraint:
    Env.t -> Ident.t -> Path.t option -> Types.type_declaration ->
    Parsetree.type_declaration -> Typedtree.type_declaration

val abstract_type_decl: int -> type_declaration
val approx_type_decl:
    Env.t -> Parsetree.type_declaration list ->
                                  (Ident.t * type_declaration) list
val check_recmod_typedecl:
    Env.t -> Location.t -> Ident.t list -> Path.t -> type_declaration -> unit
val check_coherence:
    Env.t -> Location.t -> Ident.t -> type_declaration -> unit

(* for fixed types *)
val is_fixed_type : Parsetree.type_declaration -> bool

(* for typeclass.ml *)
val compute_variance_decls:
    Env.t ->
    (Ident.t * Types.type_declaration * Types.type_declaration *
     Types.class_declaration * Types.class_type_declaration *
     'a Typedtree.class_infos) list ->
    (Types.type_declaration * Types.type_declaration *
     Types.class_declaration * Types.class_type_declaration) list

type error =
    Repeated_parameter
  | Duplicate_constructor of string
  | Too_many_constructors
  | Duplicate_label of string
  | Recursive_abbrev of string
  | Cycle_in_def of string * type_expr
  | Definition_mismatch of type_expr * Includecore.type_mismatch list
  | Constraint_failed of type_expr * type_expr
  | Inconsistent_constraint of Env.t * (type_expr * type_expr) list
  | Type_clash of Env.t * (type_expr * type_expr) list
  | Parameters_differ of Path.t * type_expr * type_expr
  | Null_arity_external
  | Missing_native_external
  | Unbound_type_var of type_expr * type_declaration
  | Not_open_type of Path.t
  | Not_extensible_type of Path.t
  | Extension_mismatch of Path.t * Includecore.type_mismatch list
  | Rebind_wrong_type of Longident.t * Env.t * (type_expr * type_expr) list
  | Rebind_mismatch of Longident.t * Path.t * Path.t
  | Rebind_private of Longident.t
  | Bad_variance of int * (bool*bool*bool) * (bool*bool*bool)
  | Unavailable_type_constructor of Path.t
  | Bad_fixed_type of string
  | Unbound_type_var_ext of type_expr * extension_constructor
  | Varying_anonymous

exception Error of Location.t * error

val report_error: formatter -> error -> unit

end = struct
(*#1 "typedecl.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(* Xavier Leroy and Jerome Vouillon, projet Cristal, INRIA Rocquencourt*)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(**** Typing of type definitions ****)

open Misc
open Asttypes
open Parsetree
open Primitive
open Types
open Typetexp

type error =
    Repeated_parameter
  | Duplicate_constructor of string
  | Too_many_constructors
  | Duplicate_label of string
  | Recursive_abbrev of string
  | Cycle_in_def of string * type_expr
  | Definition_mismatch of type_expr * Includecore.type_mismatch list
  | Constraint_failed of type_expr * type_expr
  | Inconsistent_constraint of Env.t * (type_expr * type_expr) list
  | Type_clash of Env.t * (type_expr * type_expr) list
  | Parameters_differ of Path.t * type_expr * type_expr
  | Null_arity_external
  | Missing_native_external
  | Unbound_type_var of type_expr * type_declaration
  | Not_open_type of Path.t
  | Not_extensible_type of Path.t
  | Extension_mismatch of Path.t * Includecore.type_mismatch list
  | Rebind_wrong_type of Longident.t * Env.t * (type_expr * type_expr) list
  | Rebind_mismatch of Longident.t * Path.t * Path.t
  | Rebind_private of Longident.t
  | Bad_variance of int * (bool * bool * bool) * (bool * bool * bool)
  | Unavailable_type_constructor of Path.t
  | Bad_fixed_type of string
  | Unbound_type_var_ext of type_expr * extension_constructor
  | Varying_anonymous

open Typedtree

exception Error of Location.t * error

(* Enter all declared types in the environment as abstract types *)

let enter_type env sdecl id =
  let decl =
    { type_params =
        List.map (fun _ -> Btype.newgenvar ()) sdecl.ptype_params;
      type_arity = List.length sdecl.ptype_params;
      type_kind = Type_abstract;
      type_private = sdecl.ptype_private;
      type_manifest =
        begin match sdecl.ptype_manifest with None -> None
        | Some _ -> Some(Ctype.newvar ()) end;
      type_variance = List.map (fun _ -> Variance.full) sdecl.ptype_params;
      type_newtype_level = None;
      type_loc = sdecl.ptype_loc;
      type_attributes = sdecl.ptype_attributes;
    }
  in
  Env.add_type ~check:true id decl env

let update_type temp_env env id loc =
  let path = Path.Pident id in
  let decl = Env.find_type path temp_env in
  match decl.type_manifest with None -> ()
  | Some ty ->
      let params = List.map (fun _ -> Ctype.newvar ()) decl.type_params in
      try Ctype.unify env (Ctype.newconstr path params) ty
      with Ctype.Unify trace ->
        raise (Error(loc, Type_clash (env, trace)))

(* Determine if a type is (an abbreviation for) the type "float" *)
(* We use the Ctype.expand_head_opt version of expand_head to get access
   to the manifest type of private abbreviations. *)
let is_float env ty =
  match Ctype.repr (Ctype.expand_head_opt env ty) with
    {desc = Tconstr(p, _, _)} -> Path.same p Predef.path_float
  | _ -> false

(* Determine if a type definition defines a fixed type. (PW) *)
let is_fixed_type sd =
  let rec has_row_var sty =
    match sty.ptyp_desc with
      Ptyp_alias (sty, _) -> has_row_var sty
    | Ptyp_class _
    | Ptyp_object (_, Open)
    | Ptyp_variant (_, Open, _)
    | Ptyp_variant (_, Closed, Some _) -> true
    | _ -> false
  in
  match sd.ptype_manifest with
    None -> false
  | Some sty ->
      sd.ptype_kind = Ptype_abstract &&
      sd.ptype_private = Private &&
      has_row_var sty

(* Set the row variable in a fixed type *)
let set_fixed_row env loc p decl =
  let tm =
    match decl.type_manifest with
      None -> assert false
    | Some t -> Ctype.expand_head env t
  in
  let rv =
    match tm.desc with
      Tvariant row ->
        let row = Btype.row_repr row in
        tm.desc <- Tvariant {row with row_fixed = true};
        if Btype.static_row row then Btype.newgenty Tnil
        else row.row_more
    | Tobject (ty, _) ->
        snd (Ctype.flatten_fields ty)
    | _ ->
        raise (Error (loc, Bad_fixed_type "is not an object or variant"))
  in
  if not (Btype.is_Tvar rv) then
    raise (Error (loc, Bad_fixed_type "has no row variable"));
  rv.desc <- Tconstr (p, decl.type_params, ref Mnil)

(* Translate one type declaration *)

module StringSet =
  Set.Make(struct
    type t = string
    let compare (x:t) y = compare x y
  end)

let make_params env params =
  let make_param (sty, v) =
    try
      (transl_type_param env sty, v)
    with Already_bound ->
      raise(Error(sty.ptyp_loc, Repeated_parameter))
  in
    List.map make_param params

let make_constructor env type_path type_params sargs sret_type =
  match sret_type with
  | None ->
      let targs = List.map (transl_simple_type env true) sargs in
      let args = List.map (fun cty -> cty.ctyp_type) targs in
        targs, None, args, None
  | Some sret_type ->
      (* if it's a generalized constructor we must first narrow and
         then widen so as to not introduce any new constraints *)
      let z = narrow () in
      reset_type_variables ();
      let targs = List.map (transl_simple_type env false) sargs in
      let args = List.map (fun cty -> cty.ctyp_type) targs in
      let tret_type = transl_simple_type env false sret_type in
      let ret_type = tret_type.ctyp_type in
      begin
        match (Ctype.repr ret_type).desc with
          Tconstr (p', _, _) when Path.same type_path p' -> ()
        | _ ->
            raise (Error (sret_type.ptyp_loc, Constraint_failed
                            (ret_type, Ctype.newconstr type_path type_params)))
      end;
      widen z;
      targs, Some tret_type, args, Some ret_type

let transl_declaration env sdecl id =
  (* Bind type parameters *)
  reset_type_variables();
  Ctype.begin_def ();
  let tparams = make_params env sdecl.ptype_params in
  let params = List.map (fun (cty, _) -> cty.ctyp_type) tparams in
  let cstrs = List.map
    (fun (sty, sty', loc) ->
      transl_simple_type env false sty,
      transl_simple_type env false sty', loc)
    sdecl.ptype_cstrs
  in
  let (tkind, kind) =
    match sdecl.ptype_kind with
        Ptype_abstract -> Ttype_abstract, Type_abstract
      | Ptype_variant scstrs ->
        if scstrs = [] then
          Syntaxerr.ill_formed_ast sdecl.ptype_loc
            "Variant types cannot be empty.";
        let all_constrs = ref StringSet.empty in
        List.iter
          (fun {pcd_name = {txt = name}} ->
            if StringSet.mem name !all_constrs then
              raise(Error(sdecl.ptype_loc, Duplicate_constructor name));
            all_constrs := StringSet.add name !all_constrs)
          scstrs;
        if List.length
          (List.filter (fun cd -> cd.pcd_args <> []) scstrs)
          > (Config.max_tag + 1) then
          raise(Error(sdecl.ptype_loc, Too_many_constructors));
        let make_cstr scstr =
          let name = Ident.create scstr.pcd_name.txt in
          let targs, tret_type, args, ret_type =
            make_constructor env (Path.Pident id) params
                             scstr.pcd_args scstr.pcd_res
          in
          let tcstr =
            { cd_id = name;
              cd_name = scstr.pcd_name;
              cd_args = targs;
              cd_res = tret_type;
              cd_loc = scstr.pcd_loc;
              cd_attributes = scstr.pcd_attributes }
          in
          let cstr =
            { Types.cd_id = name;
              cd_args = args;
              cd_res = ret_type;
              cd_loc = scstr.pcd_loc;
              cd_attributes = scstr.pcd_attributes }
          in
            tcstr, cstr
        in
        let tcstrs, cstrs = List.split (List.map make_cstr scstrs) in
          Ttype_variant tcstrs, Type_variant cstrs
      | Ptype_record lbls ->
        if lbls = [] then
          Syntaxerr.ill_formed_ast sdecl.ptype_loc "Records cannot be empty.";
        let all_labels = ref StringSet.empty in
        List.iter
          (fun {pld_name = {txt=name}} ->
            if StringSet.mem name !all_labels then
              raise(Error(sdecl.ptype_loc, Duplicate_label name));
            all_labels := StringSet.add name !all_labels)
          lbls;
        let lbls = List.map (fun {pld_name=name;
                                  pld_mutable=mut;
                                  pld_type=arg;
                                  pld_loc=loc;
                                  pld_attributes=attrs} ->
          let arg = Ast_helper.Typ.force_poly arg in
          let cty = transl_simple_type env true arg in
          {ld_id = Ident.create name.txt; ld_name = name; ld_mutable = mut;
           ld_type = cty; ld_loc = loc; ld_attributes = attrs}
          ) lbls in
        let lbls' =
          List.map
            (fun ld ->
              let ty = ld.ld_type.ctyp_type in
              let ty = match ty.desc with Tpoly(t,[]) -> t | _ -> ty in
              {Types.ld_id = ld.ld_id;
               ld_mutable = ld.ld_mutable;
               ld_type = ty;
               ld_loc = ld.ld_loc;
               ld_attributes = ld.ld_attributes
              }
            )
            lbls in
        let rep =
          if List.for_all (fun l -> is_float env l.Types.ld_type) lbls'
          then Record_float
          else Record_regular in
        Ttype_record lbls, Type_record(lbls', rep)
      | Ptype_open -> Ttype_open, Type_open
      in
    let (tman, man) = match sdecl.ptype_manifest with
        None -> None, None
      | Some sty ->
        let no_row = not (is_fixed_type sdecl) in
        let cty = transl_simple_type env no_row sty in
        Some cty, Some cty.ctyp_type
    in
    let decl =
      { type_params = params;
        type_arity = List.length params;
        type_kind = kind;
        type_private = sdecl.ptype_private;
        type_manifest = man;
        type_variance = List.map (fun _ -> Variance.full) params;
        type_newtype_level = None;
        type_loc = sdecl.ptype_loc;
        type_attributes = sdecl.ptype_attributes;
      } in

  (* Check constraints *)
    List.iter
      (fun (cty, cty', loc) ->
        let ty = cty.ctyp_type in
        let ty' = cty'.ctyp_type in
        try Ctype.unify env ty ty' with Ctype.Unify tr ->
          raise(Error(loc, Inconsistent_constraint (env, tr))))
      cstrs;
    Ctype.end_def ();
  (* Add abstract row *)
    if is_fixed_type sdecl then begin
      let (p, _) =
        try Env.lookup_type (Longident.Lident(Ident.name id ^ "#row")) env
        with Not_found -> assert false in
      set_fixed_row env sdecl.ptype_loc p decl
    end;
  (* Check for cyclic abbreviations *)
    begin match decl.type_manifest with None -> ()
      | Some ty ->
        if Ctype.cyclic_abbrev env id ty then
          raise(Error(sdecl.ptype_loc, Recursive_abbrev sdecl.ptype_name.txt));
    end;
    {
      typ_id = id;
      typ_name = sdecl.ptype_name;
      typ_params = tparams;
      typ_type = decl;
      typ_cstrs = cstrs;
      typ_loc = sdecl.ptype_loc;
      typ_manifest = tman;
      typ_kind = tkind;
      typ_private = sdecl.ptype_private;
      typ_attributes = sdecl.ptype_attributes;
    }

(* Generalize a type declaration *)

let generalize_decl decl =
  List.iter Ctype.generalize decl.type_params;
  begin match decl.type_kind with
    Type_abstract ->
      ()
  | Type_variant v ->
      List.iter
        (fun c ->
          List.iter Ctype.generalize c.Types.cd_args;
          may Ctype.generalize c.Types.cd_res)
        v
  | Type_record(r, rep) ->
      List.iter (fun l -> Ctype.generalize l.Types.ld_type) r
  | Type_open ->
      ()
  end;
  begin match decl.type_manifest with
  | None    -> ()
  | Some ty -> Ctype.generalize ty
  end

(* Check that all constraints are enforced *)

module TypeSet = Btype.TypeSet
module TypeMap = Btype.TypeMap

let rec check_constraints_rec env loc visited ty =
  let ty = Ctype.repr ty in
  if TypeSet.mem ty !visited then () else begin
  visited := TypeSet.add ty !visited;
  match ty.desc with
  | Tconstr (path, args, _) ->
      let args' = List.map (fun _ -> Ctype.newvar ()) args in
      let ty' = Ctype.newconstr path args' in
      begin try Ctype.enforce_constraints env ty'
      with Ctype.Unify _ -> assert false
      | Not_found -> raise (Error(loc, Unavailable_type_constructor path))
      end;
      if not (Ctype.matches env ty ty') then
        raise (Error(loc, Constraint_failed (ty, ty')));
      List.iter (check_constraints_rec env loc visited) args
  | Tpoly (ty, tl) ->
      let _, ty = Ctype.instance_poly false tl ty in
      check_constraints_rec env loc visited ty
  | _ ->
      Btype.iter_type_expr (check_constraints_rec env loc visited) ty
  end

module SMap = Map.Make(String)

let check_constraints env sdecl (_, decl) =
  let visited = ref TypeSet.empty in
  begin match decl.type_kind with
  | Type_abstract -> ()
  | Type_variant l ->
      let find_pl = function
          Ptype_variant pl -> pl
        | Ptype_record _ | Ptype_abstract | Ptype_open -> assert false
      in
      let pl = find_pl sdecl.ptype_kind in
      let pl_index =
        let foldf acc x =
          SMap.add x.pcd_name.txt x acc
        in
        List.fold_left foldf SMap.empty pl
      in
      List.iter
        (fun {Types.cd_id=name; cd_args=tyl; cd_res=ret_type} ->
          let {pcd_args = styl; pcd_res = sret_type; _} =
            try SMap.find (Ident.name name) pl_index
            with Not_found -> assert false in
          List.iter2
            (fun sty ty ->
              check_constraints_rec env sty.ptyp_loc visited ty)
            styl tyl;
          match sret_type, ret_type with
          | Some sr, Some r ->
              check_constraints_rec env sr.ptyp_loc visited r
          | _ ->
              () )
        l
  | Type_record (l, _) ->
      let find_pl = function
          Ptype_record pl -> pl
        | Ptype_variant _ | Ptype_abstract | Ptype_open -> assert false
      in
      let pl = find_pl sdecl.ptype_kind in
      let rec get_loc name = function
          [] -> assert false
        | pld :: tl ->
            if name = pld.pld_name.txt then pld.pld_type.ptyp_loc
            else get_loc name tl
      in
      List.iter
        (fun {Types.ld_id=name; ld_type=ty} ->
          check_constraints_rec env (get_loc (Ident.name name) pl) visited ty)
        l
  | Type_open -> ()
  end;
  begin match decl.type_manifest with
  | None -> ()
  | Some ty ->
      let sty =
        match sdecl.ptype_manifest with Some sty -> sty | _ -> assert false
      in
      check_constraints_rec env sty.ptyp_loc visited ty
  end

(*
   If both a variant/record definition and a type equation are given,
   need to check that the equation refers to a type of the same kind
   with the same constructors and labels.
*)
let check_coherence env loc id decl =
  match decl with
    { type_kind = (Type_variant _ | Type_record _| Type_open);
      type_manifest = Some ty } ->
      begin match (Ctype.repr ty).desc with
        Tconstr(path, args, _) ->
          begin try
            let decl' = Env.find_type path env in
            let err =
              if List.length args <> List.length decl.type_params
              then [Includecore.Arity]
              else if not (Ctype.equal env false args decl.type_params)
              then [Includecore.Constraint]
              else
                Includecore.type_declarations ~equality:true env
                  (Path.last path)
                  decl'
                  id
                  (Subst.type_declaration
                     (Subst.add_type id path Subst.identity) decl)
            in
            if err <> [] then
              raise(Error(loc, Definition_mismatch (ty, err)))
          with Not_found ->
            raise(Error(loc, Unavailable_type_constructor path))
          end
      | _ -> raise(Error(loc, Definition_mismatch (ty, [])))
      end
  | _ -> ()

let check_abbrev env sdecl (id, decl) =
  check_coherence env sdecl.ptype_loc id decl

(* Check that recursion is well-founded *)

let check_well_founded env loc path to_check ty =
  let visited = ref TypeMap.empty in
  let rec check ty0 exp_nodes ty =
    let ty = Btype.repr ty in
    if TypeSet.mem ty exp_nodes then begin
      (*Format.eprintf "@[%a@]@." Printtyp.raw_type_expr ty;*)
      if match ty0.desc with
      | Tconstr (p, _, _) -> Path.same p path
      | _ -> false
      then raise (Error (loc, Recursive_abbrev (Path.name path)))
      else raise (Error (loc, Cycle_in_def (Path.name path, ty0)))
    end;
    let (fini, exp_nodes) =
      try
        let prev = TypeMap.find ty !visited in
        if TypeSet.subset exp_nodes prev then (true, exp_nodes) else
        (false, TypeSet.union exp_nodes prev)
      with Not_found ->
        (false, exp_nodes)
    in
    let snap = Btype.snapshot () in
    if fini then () else try
      visited := TypeMap.add ty exp_nodes !visited;
      match ty.desc with
      | Tconstr(p, args, _)
        when not (TypeSet.is_empty exp_nodes) || to_check p ->
          let ty' = Ctype.try_expand_once_opt env ty in
          let ty0 = if TypeSet.is_empty exp_nodes then ty else ty0 in
          check ty0 (TypeSet.add ty exp_nodes) ty'
      | _ -> raise Ctype.Cannot_expand
    with
    | Ctype.Cannot_expand ->
        let nodes =
          if !Clflags.recursive_types && Ctype.is_contractive env ty
          || match ty.desc with Tobject _ | Tvariant _ -> true | _ -> false
          then TypeSet.empty
          else exp_nodes in
        Btype.iter_type_expr (check ty0 nodes) ty
    | Ctype.Unify _ ->
        (* Will be detected by check_recursion *)
        Btype.backtrack snap
  in
  Ctype.wrap_trace_gadt_instances env (check ty TypeSet.empty) ty

let check_well_founded_manifest env loc path decl =
  if decl.type_manifest = None then () else
  let args = List.map (fun _ -> Ctype.newvar()) decl.type_params in
  check_well_founded env loc path (Path.same path) (Ctype.newconstr path args)

let check_well_founded_decl env loc path decl to_check =
  let open Btype in
  let it =
    {type_iterators with
     it_type_expr = (fun _ -> check_well_founded env loc path to_check)} in
  it.it_type_declaration it (Ctype.instance_declaration decl)

(* Check for ill-defined abbrevs *)

let check_recursion env loc path decl to_check =
  (* to_check is true for potentially mutually recursive paths.
     (path, decl) is the type declaration to be checked. *)

  if decl.type_params = [] then () else

  let visited = ref [] in

  let rec check_regular cpath args prev_exp ty =
    let ty = Ctype.repr ty in
    if not (List.memq ty !visited) then begin
      visited := ty :: !visited;
      match ty.desc with
      | Tconstr(path', args', _) ->
          if Path.same path path' then begin
            if not (Ctype.equal env false args args') then
              raise (Error(loc,
                     Parameters_differ(cpath, ty, Ctype.newconstr path args)))
          end
          (* Attempt to expand a type abbreviation if:
              1- [to_check path'] holds
                 (otherwise the expansion cannot involve [path]);
              2- we haven't expanded this type constructor before
                 (otherwise we could loop if [path'] is itself
                 a non-regular abbreviation). *)
          else if to_check path' && not (List.mem path' prev_exp) then begin
            try
              (* Attempt expansion *)
              let (params0, body0, _) = Env.find_type_expansion path' env in
              let (params, body) =
                Ctype.instance_parameterized_type params0 body0 in
              begin
                try List.iter2 (Ctype.unify env) params args'
                with Ctype.Unify _ ->
                  raise (Error(loc, Constraint_failed
                                 (ty, Ctype.newconstr path' params0)));
              end;
              check_regular path' args (path' :: prev_exp) body
            with Not_found -> ()
          end;
          List.iter (check_regular cpath args prev_exp) args'
      | Tpoly (ty, tl) ->
          let (_, ty) = Ctype.instance_poly ~keep_names:true false tl ty in
          check_regular cpath args prev_exp ty
      | _ ->
          Btype.iter_type_expr (check_regular cpath args prev_exp) ty
    end in

  Misc.may
    (fun body ->
      let (args, body) =
        Ctype.instance_parameterized_type
          ~keep_names:true decl.type_params body in
      check_regular path args [] body)
    decl.type_manifest

let check_abbrev_recursion env id_loc_list to_check tdecl =
  let decl = tdecl.typ_type in
  let id = tdecl.typ_id in
  check_recursion env (List.assoc id id_loc_list) (Path.Pident id) decl to_check

(* Compute variance *)

let get_variance ty visited =
  try TypeMap.find ty !visited with Not_found -> Variance.null

let compute_variance env visited vari ty =
  let rec compute_variance_rec vari ty =
    (* Format.eprintf "%a: %x@." Printtyp.type_expr ty (Obj.magic vari); *)
    let ty = Ctype.repr ty in
    let vari' = get_variance ty visited in
    if Variance.subset vari vari' then () else
    let vari = Variance.union vari vari' in
    visited := TypeMap.add ty vari !visited;
    let compute_same = compute_variance_rec vari in
    match ty.desc with
      Tarrow (_, ty1, ty2, _) ->
        let open Variance in
        let v = conjugate vari in
        let v1 =
          if mem May_pos v || mem May_neg v
          then set May_weak true v else v
        in
        compute_variance_rec v1 ty1;
        compute_same ty2
    | Ttuple tl ->
        List.iter compute_same tl
    | Tconstr (path, tl, _) ->
        let open Variance in
        if tl = [] then () else begin
          try
            let decl = Env.find_type path env in
            let cvari f = mem f vari in
            List.iter2
              (fun ty v ->
                let cv f = mem f v in
                let strict =
                  cvari Inv && cv Inj || (cvari Pos || cvari Neg) && cv Inv
                in
                if strict then compute_variance_rec full ty else
                let p1 = inter v vari
                and n1 = inter v (conjugate vari) in
                let v1 =
                  union (inter covariant (union p1 (conjugate p1)))
                    (inter (conjugate covariant) (union n1 (conjugate n1)))
                and weak =
                  cvari May_weak && (cv May_pos || cv May_neg) ||
                  (cvari May_pos || cvari May_neg) && cv May_weak
                in
                let v2 = set May_weak weak v1 in
                compute_variance_rec v2 ty)
              tl decl.type_variance
          with Not_found ->
            List.iter (compute_variance_rec may_inv) tl
        end
    | Tobject (ty, _) ->
        compute_same ty
    | Tfield (_, _, ty1, ty2) ->
        compute_same ty1;
        compute_same ty2
    | Tsubst ty ->
        compute_same ty
    | Tvariant row ->
        let row = Btype.row_repr row in
        List.iter
          (fun (_,f) ->
            match Btype.row_field_repr f with
              Rpresent (Some ty) ->
                compute_same ty
            | Reither (_, tyl, _, _) ->
                let open Variance in
                let upper =
                  List.fold_left (fun s f -> set f true s)
                    null [May_pos; May_neg; May_weak]
                in
                let v = inter vari upper in
                List.iter (compute_variance_rec v) tyl
            | _ -> ())
          row.row_fields;
        compute_same row.row_more
    | Tpoly (ty, _) ->
        compute_same ty
    | Tvar _ | Tnil | Tlink _ | Tunivar _ -> ()
    | Tpackage (_, _, tyl) ->
        let v =
          Variance.(if mem Pos vari || mem Neg vari then full else may_inv)
        in
        List.iter (compute_variance_rec v) tyl
  in
  compute_variance_rec vari ty

let make_variance ty = (ty, ref Variance.null)

let make p n i =
  let open Variance in
  set May_pos p (set May_neg n (set May_weak n (set Inj i null)))

let compute_variance_type env check (required, loc) decl tyl =
  (* Requirements *)
  let required =
    List.map (fun (c,n,i) -> if c || n then (c,n,i) else (true,true,i))
      required
  in
  (* Prepare *)
  let params = List.map Btype.repr decl.type_params in
  let tvl = ref TypeMap.empty in
  (* Compute occurences in body *)
  let open Variance in
  List.iter
    (fun (cn,ty) ->
      compute_variance env tvl (if cn then full else covariant) ty)
    tyl;
  if check then begin
    (* Check variance of parameters *)
    let pos = ref 0 in
    List.iter2
      (fun ty (c, n, i) ->
        incr pos;
        let var = get_variance ty tvl in
        let (co,cn) = get_upper var and ij = mem Inj var in
        if Btype.is_Tvar ty && (co && not c || cn && not n || not ij && i)
        then raise (Error(loc, Bad_variance (!pos, (co,cn,ij), (c,n,i)))))
      params required;
    (* Check propagation from constrained parameters *)
    let args = Btype.newgenty (Ttuple params) in
    let fvl = Ctype.free_variables args in
    let fvl = List.filter (fun v -> not (List.memq v params)) fvl in
    (* If there are no extra variables there is nothing to do *)
    if fvl = [] then () else
    let tvl2 = ref TypeMap.empty in
    List.iter2
      (fun ty (p,n,i) ->
        if Btype.is_Tvar ty then () else
        let v =
          if p then if n then full else covariant else conjugate covariant in
        compute_variance env tvl2 v ty)
      params required;
    let visited = ref TypeSet.empty in
    let rec check ty =
      let ty = Ctype.repr ty in
      if TypeSet.mem ty !visited then () else
      let visited' = TypeSet.add ty !visited in
      visited := visited';
      let v1 = get_variance ty tvl in
      let snap = Btype.snapshot () in
      let v2 =
        TypeMap.fold
          (fun t vt v ->
            if Ctype.equal env false [ty] [t] then union vt v else v)
          !tvl2 null in
      Btype.backtrack snap;
      let (c1,n1) = get_upper v1 and (c2,n2,_,i2) = get_lower v2 in
      if c1 && not c2 || n1 && not n2 then
        if List.memq ty fvl then
          let code = if not i2 then -2 else if c2 || n2 then -1 else -3 in
          raise (Error (loc, Bad_variance (code, (c1,n1,false), (c2,n2,false))))
        else
          Btype.iter_type_expr check ty
    in
    List.iter (fun (_,ty) -> check ty) tyl;
  end;
  List.map2
    (fun ty (p, n, i) ->
      let v = get_variance ty tvl in
      let tr = decl.type_private in
      (* Use required variance where relevant *)
      let concr = decl.type_kind <> Type_abstract (*|| tr = Type_new*) in
      let (p, n) =
        if tr = Private || not (Btype.is_Tvar ty) then (p, n) (* set *)
        else (false, false) (* only check *)
      and i = concr  || i && tr = Private in
      let v = union v (make p n i) in
      let v =
        if not concr then v else
        if mem Pos v && mem Neg v then full else
        if Btype.is_Tvar ty then v else
        union v
          (if p then if n then full else covariant else conjugate covariant)
      in
      if decl.type_kind = Type_abstract && tr = Public then v else
      set May_weak (mem May_neg v) v)
    params required

let add_false = List.map (fun ty -> false, ty)

(* A parameter is constrained if either is is instantiated,
   or it is a variable appearing in another parameter *)
let constrained env vars ty =
  match ty.desc with
  | Tvar _ -> List.exists (fun tl -> List.memq ty tl) vars
  | _ -> true

let compute_variance_gadt env check (required, loc as rloc) decl
    (tl, ret_type_opt) =
  match ret_type_opt with
  | None ->
      compute_variance_type env check rloc {decl with type_private = Private}
        (add_false tl)
  | Some ret_type ->
      match Ctype.repr ret_type with
      | {desc=Tconstr (path, tyl, _)} ->
          (* let tyl = List.map (Ctype.expand_head env) tyl in *)
          let tyl = List.map Ctype.repr tyl in
          let fvl = List.map (Ctype.free_variables ?env:None) tyl in
          let _ =
            List.fold_left2
              (fun (fv1,fv2) ty (c,n,i) ->
                match fv2 with [] -> assert false
                | fv :: fv2 ->
                    (* fv1 @ fv2 = free_variables of other parameters *)
                    if (c||n) && constrained env (fv1 @ fv2) ty then
                      raise (Error(loc, Varying_anonymous));
                    (fv :: fv1, fv2))
              ([], fvl) tyl required
          in
          compute_variance_type env check rloc
            {decl with type_params = tyl; type_private = Private}
            (add_false tl)
      | _ -> assert false

let compute_variance_extension env check decl ext rloc =
  compute_variance_gadt env check rloc
    {decl with type_params = ext.ext_type_params}
    (ext.ext_args, ext.ext_ret_type)

let compute_variance_decl env check decl (required, loc as rloc) =
  if (decl.type_kind = Type_abstract || decl.type_kind = Type_open)
       && decl.type_manifest = None then
    List.map
      (fun (c, n, i) ->
        make (not n) (not c) (decl.type_kind <> Type_abstract || i))
      required
  else
  let mn =
    match decl.type_manifest with
      None -> []
    | Some ty -> [false, ty]
  in
  match decl.type_kind with
    Type_abstract | Type_open ->
      compute_variance_type env check rloc decl mn
  | Type_variant tll ->
      if List.for_all (fun c -> c.Types.cd_res = None) tll then
        compute_variance_type env check rloc decl
          (mn @
           add_false (List.flatten (List.map (fun c -> c.Types.cd_args) tll)))
      else begin
        let mn =
          List.map (fun (_,ty) -> ([ty],None)) mn in
        let tll =
          mn @ List.map (fun c -> c.Types.cd_args, c.Types.cd_res) tll in
        match List.map (compute_variance_gadt env check rloc decl) tll with
        | vari :: rem ->
            let varl = List.fold_left (List.map2 Variance.union) vari rem in
            List.map
              Variance.(fun v -> if mem Pos v && mem Neg v then full else v)
              varl
        | _ -> assert false
      end
  | Type_record (ftl, _) ->
      compute_variance_type env check rloc decl
        (mn @ List.map (fun {Types.ld_mutable; ld_type} ->
             (ld_mutable = Mutable, ld_type)) ftl)

let is_sharp id =
  let s = Ident.name id in
  String.length s > 0 && s.[0] = '#'

let rec compute_variance_fixpoint env decls required variances =
  let new_decls =
    List.map2
      (fun (id, decl) variance -> id, {decl with type_variance = variance})
      decls variances
  in
  let new_env =
    List.fold_right
      (fun (id, decl) env -> Env.add_type ~check:true id decl env)
      new_decls env
  in
  let new_variances =
    List.map2
      (fun (id, decl) -> compute_variance_decl new_env false decl)
      new_decls required
  in
  let new_variances =
    List.map2 (List.map2 Variance.union) new_variances variances in
  if new_variances <> variances then
    compute_variance_fixpoint env decls required new_variances
  else begin
    (* List.iter (fun (id, decl) ->
      Printf.eprintf "%s:" (Ident.name id);
      List.iter (fun (v : Variance.t) ->
        Printf.eprintf " %x" (Obj.magic v : int))
        decl.type_variance;
      prerr_endline "")
      new_decls; *)
    List.iter2
      (fun (id, decl) req -> if not (is_sharp id) then
        ignore (compute_variance_decl new_env true decl req))
      new_decls required;
    new_decls, new_env
  end

let init_variance (id, decl) =
  List.map (fun _ -> Variance.null) decl.type_params

let add_injectivity =
  List.map
    (function
      | Covariant -> (true, false, false)
      | Contravariant -> (false, true, false)
      | Invariant -> (false, false, false)
    )

(* for typeclass.ml *)
let compute_variance_decls env cldecls =
  let decls, required =
    List.fold_right
      (fun (obj_id, obj_abbr, cl_abbr, clty, cltydef, ci) (decls, req) ->
        let variance = List.map snd ci.ci_params in
        (obj_id, obj_abbr) :: decls,
        (add_injectivity variance, ci.ci_loc) :: req)
      cldecls ([],[])
  in
  let variances = List.map init_variance decls in
  let (decls, _) = compute_variance_fixpoint env decls required variances in
  List.map2
    (fun (_,decl) (_, _, cl_abbr, clty, cltydef, _) ->
      let variance = decl.type_variance in
      (decl, {cl_abbr with type_variance = variance},
       {clty with cty_variance = variance},
       {cltydef with clty_variance = variance}))
    decls cldecls

(* Check multiple declarations of labels/constructors *)

let check_duplicates sdecl_list =
  let labels = Hashtbl.create 7 and constrs = Hashtbl.create 7 in
  List.iter
    (fun sdecl -> match sdecl.ptype_kind with
      Ptype_variant cl ->
        List.iter
          (fun pcd ->
            try
              let name' = Hashtbl.find constrs pcd.pcd_name.txt in
              Location.prerr_warning pcd.pcd_loc
                (Warnings.Duplicate_definitions
                   ("constructor", pcd.pcd_name.txt, name',
                    sdecl.ptype_name.txt))
            with Not_found ->
              Hashtbl.add constrs pcd.pcd_name.txt sdecl.ptype_name.txt)
          cl
    | Ptype_record fl ->
        List.iter
          (fun {pld_name=cname;pld_loc=loc} ->
            try
              let name' = Hashtbl.find labels cname.txt in
              Location.prerr_warning loc
                (Warnings.Duplicate_definitions
                   ("label", cname.txt, name', sdecl.ptype_name.txt))
            with Not_found -> Hashtbl.add labels cname.txt sdecl.ptype_name.txt)
          fl
    | Ptype_abstract -> ()
    | Ptype_open -> ())
    sdecl_list

(* Force recursion to go through id for private types*)
let name_recursion sdecl id decl =
  match decl with
  | { type_kind = Type_abstract;
      type_manifest = Some ty;
      type_private = Private; } when is_fixed_type sdecl ->
    let ty = Ctype.repr ty in
    let ty' = Btype.newty2 ty.level ty.desc in
    if Ctype.deep_occur ty ty' then
      let td = Tconstr(Path.Pident id, decl.type_params, ref Mnil) in
      Btype.link_type ty (Btype.newty2 ty.level td);
      {decl with type_manifest = Some ty'}
    else decl
  | _ -> decl

(* Translate a set of type declarations, mutually recursive or not *)
let transl_type_decl env rec_flag sdecl_list =
  (* Add dummy types for fixed rows *)
  let fixed_types = List.filter is_fixed_type sdecl_list in
  let sdecl_list =
    List.map
      (fun sdecl ->
        let ptype_name =
          mkloc (sdecl.ptype_name.txt ^"#row") sdecl.ptype_name.loc in
        {sdecl with
         ptype_name; ptype_kind = Ptype_abstract; ptype_manifest = None})
      fixed_types
    @ sdecl_list
  in
  (* Create identifiers. *)
  let id_list =
    List.map (fun sdecl -> Ident.create sdecl.ptype_name.txt) sdecl_list
  in
  (*
     Since we've introduced fresh idents, make sure the definition
     level is at least the binding time of these events. Otherwise,
     passing one of the recursively-defined type constrs as argument
     to an abbreviation may fail.
  *)
  Ctype.init_def(Ident.current_time());
  Ctype.begin_def();
  (* Enter types. *)
  let temp_env =
    match rec_flag with
    | Asttypes.Nonrecursive -> env
    | Asttypes.Recursive -> List.fold_left2 enter_type env sdecl_list id_list
  in
  (* Translate each declaration. *)
  let current_slot = ref None in
  let warn_unused = Warnings.is_active (Warnings.Unused_type_declaration "") in
  let id_slots id =
    match rec_flag with
    | Asttypes.Recursive when warn_unused ->
        (* See typecore.ml for a description of the algorithm used
             to detect unused declarations in a set of recursive definitions. *)
        let slot = ref [] in
        let td = Env.find_type (Path.Pident id) temp_env in
        let name = Ident.name id in
        Env.set_type_used_callback
          name td
          (fun old_callback ->
             match !current_slot with
             | Some slot -> slot := (name, td) :: !slot
             | None ->
                 List.iter (fun (name, d) -> Env.mark_type_used env name d)
                   (get_ref slot);
                 old_callback ()
          );
        id, Some slot
    | Asttypes.Recursive | Asttypes.Nonrecursive ->
        id, None
  in
  let transl_declaration name_sdecl (id, slot) =
    current_slot := slot; transl_declaration temp_env name_sdecl id in
  let tdecls =
    List.map2 transl_declaration sdecl_list (List.map id_slots id_list) in
  let decls =
    List.map (fun tdecl -> (tdecl.typ_id, tdecl.typ_type)) tdecls in
  current_slot := None;
  (* Check for duplicates *)
  check_duplicates sdecl_list;
  (* Build the final env. *)
  let newenv =
    List.fold_right
      (fun (id, decl) env -> Env.add_type ~check:true id decl env)
      decls env
  in
  (* Update stubs *)
  begin match rec_flag with
    | Asttypes.Nonrecursive -> ()
    | Asttypes.Recursive ->
      List.iter2
        (fun id sdecl -> update_type temp_env newenv id sdecl.ptype_loc)
        id_list sdecl_list
  end;
  (* Generalize type declarations. *)
  Ctype.end_def();
  List.iter (fun (_, decl) -> generalize_decl decl) decls;
  (* Check for ill-formed abbrevs *)
  let id_loc_list =
    List.map2 (fun id sdecl -> (id, sdecl.ptype_loc))
      id_list sdecl_list
  in
  List.iter (fun (id, decl) ->
    check_well_founded_manifest newenv (List.assoc id id_loc_list)
      (Path.Pident id) decl)
    decls;
  let to_check =
    function Path.Pident id -> List.mem_assoc id id_loc_list | _ -> false in
  List.iter (fun (id, decl) ->
    check_well_founded_decl newenv (List.assoc id id_loc_list) (Path.Pident id)
      decl to_check)
    decls;
  List.iter (check_abbrev_recursion newenv id_loc_list to_check) tdecls;
  (* Check that all type variable are closed *)
  List.iter2
    (fun sdecl tdecl ->
      let decl = tdecl.typ_type in
       match Ctype.closed_type_decl decl with
         Some ty -> raise(Error(sdecl.ptype_loc, Unbound_type_var(ty,decl)))
       | None   -> ())
    sdecl_list tdecls;
  (* Check that constraints are enforced *)
  List.iter2 (check_constraints newenv) sdecl_list decls;
  (* Name recursion *)
  let decls =
    List.map2 (fun sdecl (id, decl) -> id, name_recursion sdecl id decl)
      sdecl_list decls
  in
  (* Add variances to the environment *)
  let required =
    List.map
      (fun sdecl ->
         add_injectivity (List.map snd sdecl.ptype_params),
         sdecl.ptype_loc
      )
      sdecl_list
  in
  let final_decls, final_env =
    compute_variance_fixpoint env decls required (List.map init_variance decls)
  in
  (* Check re-exportation *)
  List.iter2 (check_abbrev final_env) sdecl_list final_decls;
  (* Keep original declaration *)
  let final_decls =
    List.map2
      (fun tdecl (id2, decl) ->
        { tdecl with typ_type = decl }
      ) tdecls final_decls
  in
  (* Done *)
  (final_decls, final_env)

(* Translating type extensions *)

let transl_extension_constructor env check_open type_path type_params
                                 typext_params priv sext =
  let id = Ident.create sext.pext_name.txt in
  let args, ret_type, kind =
    match sext.pext_kind with
      Pext_decl(sargs, sret_type) ->
        let targs, tret_type, args, ret_type =
          make_constructor env type_path typext_params sargs sret_type
        in
          args, ret_type, Text_decl(targs, tret_type)
    | Pext_rebind lid ->
        let cdescr = Typetexp.find_constructor env sext.pext_loc lid.txt in
        let usage =
          if cdescr.cstr_private = Private || priv = Public
          then Env.Positive else Env.Privatize
        in
        Env.mark_constructor usage env (Longident.last lid.txt) cdescr;
        let (args, cstr_res) = Ctype.instance_constructor cdescr in
        let res, ret_type =
          if cdescr.cstr_generalized then
            let params = Ctype.instance_list env type_params in
            let res = Ctype.newconstr type_path params in
            let ret_type = Some (Ctype.newconstr type_path params) in
              res, ret_type
          else (Ctype.newconstr type_path typext_params), None
        in
        begin
          try
            Ctype.unify env cstr_res res
          with Ctype.Unify trace ->
            raise (Error(lid.loc,
                     Rebind_wrong_type(lid.txt, env, trace)))
        end;
        (* Remove "_" names from parameters used in the constructor *)
        if not cdescr.cstr_generalized then begin
          let vars =
            Ctype.free_variables (Btype.newgenty (Ttuple args))
          in
            List.iter
              (function {desc = Tvar (Some "_")} as ty ->
                          if List.memq ty vars then ty.desc <- Tvar None
                        | _ -> ())
              typext_params
        end;
        (* Ensure that constructor's type matches the type being extended *)
        let cstr_type_path, cstr_type_params =
          match cdescr.cstr_res.desc with
            Tconstr (p, _, _) ->
              let decl = Env.find_type p env in
                p, decl.type_params
          | _ -> assert false
        in
        let cstr_types =
          (Btype.newgenty
             (Tconstr(cstr_type_path, cstr_type_params, ref Mnil)))
          :: cstr_type_params
        in
        let ext_types =
          (Btype.newgenty
             (Tconstr(type_path, type_params, ref Mnil)))
          :: type_params
        in
        if not (Ctype.equal env true cstr_types ext_types) then
          raise (Error(lid.loc,
                       Rebind_mismatch(lid.txt, cstr_type_path, type_path)));
        (* Disallow rebinding private constructors to non-private *)
        begin
          match cdescr.cstr_private, priv with
            Private, Public ->
              raise (Error(lid.loc, Rebind_private lid.txt))
          | _ -> ()
        end;
        let path =
          match cdescr.cstr_tag with
            Cstr_extension(path, _) -> path
          | _ -> assert false
        in
          args, ret_type, Text_rebind(path, lid)
  in
  let ext =
    { ext_type_path = type_path;
      ext_type_params = typext_params;
      ext_args = args;
      ext_ret_type = ret_type;
      ext_private = priv;
      Types.ext_loc = sext.pext_loc;
      Types.ext_attributes = sext.pext_attributes; }
  in
    { ext_id = id;
      ext_name = sext.pext_name;
      ext_type = ext;
      ext_kind = kind;
      Typedtree.ext_loc = sext.pext_loc;
      Typedtree.ext_attributes = sext.pext_attributes; }

let transl_type_extension check_open env loc styext =
  reset_type_variables();
  Ctype.begin_def();
  let (type_path, type_decl) =
    Typetexp.find_type env loc styext.ptyext_path.txt
  in
  begin
    match type_decl.type_kind with
      Type_open -> ()
    | Type_abstract ->
        if check_open then begin
          try
            let {pext_loc} =
              List.find (function {pext_kind = Pext_decl _} -> true
                                | {pext_kind = Pext_rebind _} -> false)
                        styext.ptyext_constructors
            in
              raise (Error(pext_loc, Not_open_type type_path))
          with Not_found -> ()
        end
    | _ -> raise (Error(loc, Not_extensible_type type_path))
  end;
  let type_variance =
    List.map (fun v ->
                let (co, cn) = Variance.get_upper v in
                  (not cn, not co, false))
             type_decl.type_variance
  in
  let err =
    if type_decl.type_arity <> List.length styext.ptyext_params then
      [Includecore.Arity]
    else
      if List.for_all2
           (fun (c1, n1, _) (c2, n2, _) -> (not c2 || c1) && (not n2 || n1))
           type_variance
           (add_injectivity (List.map snd styext.ptyext_params))
      then [] else [Includecore.Variance]
  in
  if err <> [] then
    raise (Error(loc, Extension_mismatch (type_path, err)));
  let ttype_params = make_params env styext.ptyext_params in
  let type_params = List.map (fun (cty, _) -> cty.ctyp_type) ttype_params in
  List.iter2 (Ctype.unify_var env)
    (Ctype.instance_list env type_decl.type_params)
    type_params;
  let constructors =
    List.map (transl_extension_constructor env check_open type_path
               type_decl.type_params type_params styext.ptyext_private)
      styext.ptyext_constructors
  in
  Ctype.end_def();
  (* Generalize types *)
  List.iter Ctype.generalize type_params;
  List.iter
    (fun ext ->
       List.iter Ctype.generalize ext.ext_type.ext_args;
       may Ctype.generalize ext.ext_type.ext_ret_type)
    constructors;
  (* Check that all type variable are closed *)
  List.iter
    (fun ext ->
       match Ctype.closed_extension_constructor ext.ext_type with
         Some ty ->
           raise(Error(ext.ext_loc, Unbound_type_var_ext(ty, ext.ext_type)))
       | None -> ())
    constructors;
  (* Check variances are correct *)
  List.iter
    (fun ext->
      ignore (compute_variance_extension env true type_decl
                ext.ext_type (type_variance, loc)))
    constructors;
  (* Add extension constructors to the environment *)
  let newenv =
    List.fold_left
      (fun env ext ->
         Env.add_extension ~check:true ext.ext_id ext.ext_type env)
      env constructors
  in
  let tyext =
    { tyext_path = type_path;
      tyext_txt = styext.ptyext_path;
      tyext_params = ttype_params;
      tyext_constructors = constructors;
      tyext_private = styext.ptyext_private;
      tyext_attributes = styext.ptyext_attributes; }
  in
    (tyext, newenv)

let transl_exception env sext =
  reset_type_variables();
  Ctype.begin_def();
  let ext =
    transl_extension_constructor env false
      Predef.path_exn [] [] Asttypes.Public sext
  in
  Ctype.end_def();
  (* Generalize types *)
  List.iter Ctype.generalize ext.ext_type.ext_args;
  may Ctype.generalize ext.ext_type.ext_ret_type;
  (* Check that all type variable are closed *)
  begin match Ctype.closed_extension_constructor ext.ext_type with
    Some ty ->
      raise (Error(ext.ext_loc, Unbound_type_var_ext(ty, ext.ext_type)))
  | None -> ()
  end;
  let newenv = Env.add_extension ~check:true ext.ext_id ext.ext_type env in
    ext, newenv

 let customize_arity arity pval_attributes =
  let cur_arity = ref arity in
  List.iter (fun (x:Parsetree.attribute) ->
    match x with
    | {txt = "internal.arity";_},
      PStr [ {pstr_desc = Pstr_eval
                  (
                    ({pexp_desc = Pexp_constant (Const_int i)} :
                       Parsetree.expression) ,_)}]
      -> if i < !cur_arity then cur_arity := i
    | _ -> ()
  ) pval_attributes ;
  !cur_arity

(* Translate a value declaration *)
let transl_value_decl env loc valdecl =
  let cty = Typetexp.transl_type_scheme env valdecl.pval_type in
  let ty = cty.ctyp_type in
  let v =
  match valdecl.pval_prim with
    [] ->
      { val_type = ty; val_kind = Val_reg; Types.val_loc = loc;
        val_attributes = valdecl.pval_attributes }
  | decl ->
      let arity = customize_arity (Ctype.arity ty) valdecl.pval_attributes in
      let prim = Primitive.parse_declaration  arity decl in
      let prim_native_name = prim.prim_native_name in
      if arity = 0 && not ( String.length prim_native_name > 3 &&
                            String.unsafe_get prim_native_name 0 = 'B' &&
                            String.unsafe_get prim_native_name 1 = 'S' &&
                            String.unsafe_get prim_native_name 2 = ':'
                          ) && (String.length prim.prim_name = 0 || (prim.prim_name.[0] <> '%' && prim.prim_name.[0] <> '#')) then
        raise(Error(valdecl.pval_type.ptyp_loc, Null_arity_external));
      if !Clflags.native_code
      && prim.prim_arity > 5
      && prim_native_name = ""
      then raise(Error(valdecl.pval_type.ptyp_loc, Missing_native_external));
      { val_type = ty; val_kind = Val_prim prim; Types.val_loc = loc;
        val_attributes = valdecl.pval_attributes }
  in
  let (id, newenv) =
    Env.enter_value valdecl.pval_name.txt v env
      ~check:(fun s -> Warnings.Unused_value_declaration s)
  in
  let desc =
    {
     val_id = id;
     val_name = valdecl.pval_name;
     val_desc = cty; val_val = v;
     val_prim = valdecl.pval_prim;
     val_loc = valdecl.pval_loc;
     val_attributes = valdecl.pval_attributes;
    }
  in
  desc, newenv

(* Translate a "with" constraint -- much simplified version of
    transl_type_decl. *)
let transl_with_constraint env id row_path orig_decl sdecl =
  Env.mark_type_used env (Ident.name id) orig_decl;
  reset_type_variables();
  Ctype.begin_def();
  let tparams = make_params env sdecl.ptype_params in
  let params = List.map (fun (cty, _) -> cty.ctyp_type) tparams in
  let orig_decl = Ctype.instance_declaration orig_decl in
  let arity_ok = List.length params = orig_decl.type_arity in
  if arity_ok then
    List.iter2 (Ctype.unify_var env) params orig_decl.type_params;
  let constraints = List.map
    (function (ty, ty', loc) ->
       try
         let cty = transl_simple_type env false ty in
         let cty' = transl_simple_type env false ty' in
         let ty = cty.ctyp_type in
         let ty' = cty'.ctyp_type in
         Ctype.unify env ty ty';
         (cty, cty', loc)
       with Ctype.Unify tr ->
         raise(Error(loc, Inconsistent_constraint (env, tr))))
    sdecl.ptype_cstrs
  in
  let no_row = not (is_fixed_type sdecl) in
  let (tman, man) =  match sdecl.ptype_manifest with
      None -> None, None
    | Some sty ->
        let cty = transl_simple_type env no_row sty in
        Some cty, Some cty.ctyp_type
  in
  let priv =
    if sdecl.ptype_private = Private then Private else
    if arity_ok && orig_decl.type_kind <> Type_abstract
    then orig_decl.type_private else sdecl.ptype_private
  in
  if arity_ok && orig_decl.type_kind <> Type_abstract
  && sdecl.ptype_private = Private then
    Location.prerr_warning sdecl.ptype_loc
      (Warnings.Deprecated "spurious use of private");
  let decl =
    { type_params = params;
      type_arity = List.length params;
      type_kind =
        if arity_ok && man <> None then orig_decl.type_kind else Type_abstract;
      type_private = priv;
      type_manifest = man;
      type_variance = [];
      type_newtype_level = None;
      type_loc = sdecl.ptype_loc;
      type_attributes = sdecl.ptype_attributes;
    }
  in
  begin match row_path with None -> ()
  | Some p -> set_fixed_row env sdecl.ptype_loc p decl
  end;
  begin match Ctype.closed_type_decl decl with None -> ()
  | Some ty -> raise(Error(sdecl.ptype_loc, Unbound_type_var(ty,decl)))
  end;
  let decl = name_recursion sdecl id decl in
  let decl =
    {decl with type_variance =
     compute_variance_decl env false decl
       (add_injectivity (List.map snd sdecl.ptype_params), sdecl.ptype_loc)} in
  Ctype.end_def();
  generalize_decl decl;
  {
    typ_id = id;
    typ_name = sdecl.ptype_name;
    typ_params = tparams;
    typ_type = decl;
    typ_cstrs = constraints;
    typ_loc = sdecl.ptype_loc;
    typ_manifest = tman;
    typ_kind = Ttype_abstract;
    typ_private = sdecl.ptype_private;
    typ_attributes = sdecl.ptype_attributes;
  }

(* Approximate a type declaration: just make all types abstract *)

let abstract_type_decl arity =
  let rec make_params n =
    if n <= 0 then [] else Ctype.newvar() :: make_params (n-1) in
  Ctype.begin_def();
  let decl =
    { type_params = make_params arity;
      type_arity = arity;
      type_kind = Type_abstract;
      type_private = Public;
      type_manifest = None;
      type_variance = replicate_list Variance.full arity;
      type_newtype_level = None;
      type_loc = Location.none;
      type_attributes = [];
     } in
  Ctype.end_def();
  generalize_decl decl;
  decl

let approx_type_decl env sdecl_list =
  List.map
    (fun sdecl ->
      (Ident.create sdecl.ptype_name.txt,
       abstract_type_decl (List.length sdecl.ptype_params)))
    sdecl_list

(* Variant of check_abbrev_recursion to check the well-formedness
   conditions on type abbreviations defined within recursive modules. *)

let check_recmod_typedecl env loc recmod_ids path decl =
  (* recmod_ids is the list of recursively-defined module idents.
     (path, decl) is the type declaration to be checked. *)
  let to_check path =
    List.exists (fun id -> Path.isfree id path) recmod_ids in
  check_well_founded_decl env loc path decl to_check;
  check_recursion env loc path decl to_check


(**** Error report ****)

open Format

let explain_unbound ppf tv tl typ kwd lab =
  try
    let ti = List.find (fun ti -> Ctype.deep_occur tv (typ ti)) tl in
    let ty0 = (* Hack to force aliasing when needed *)
      Btype.newgenty (Tobject(tv, ref None)) in
    Printtyp.reset_and_mark_loops_list [typ ti; ty0];
    fprintf ppf
      ".@.@[<hov2>In %s@ %s%a@;<1 -2>the variable %a is unbound@]"
      kwd (lab ti) Printtyp.type_expr (typ ti) Printtyp.type_expr tv
  with Not_found -> ()

let explain_unbound_single ppf tv ty =
  let trivial ty =
    explain_unbound ppf tv [ty] (fun t -> t) "type" (fun _ -> "") in
  match (Ctype.repr ty).desc with
    Tobject(fi,_) ->
      let (tl, rv) = Ctype.flatten_fields fi in
      if rv == tv then trivial ty else
      explain_unbound ppf tv tl (fun (_,_,t) -> t)
        "method" (fun (lab,_,_) -> lab ^ ": ")
  | Tvariant row ->
      let row = Btype.row_repr row in
      if row.row_more == tv then trivial ty else
      explain_unbound ppf tv row.row_fields
        (fun (l,f) -> match Btype.row_field_repr f with
          Rpresent (Some t) -> t
        | Reither (_,[t],_,_) -> t
        | Reither (_,tl,_,_) -> Btype.newgenty (Ttuple tl)
        | _ -> Btype.newgenty (Ttuple[]))
        "case" (fun (lab,_) -> "`" ^ lab ^ " of ")
  | _ -> trivial ty

let report_error ppf = function
  | Repeated_parameter ->
      fprintf ppf "A type parameter occurs several times"
  | Duplicate_constructor s ->
      fprintf ppf "Two constructors are named %s" s
  | Too_many_constructors ->
      fprintf ppf
        "@[Too many non-constant constructors@ -- maximum is %i %s@]"
        (Config.max_tag + 1) "non-constant constructors"
  | Duplicate_label s ->
      fprintf ppf "Two labels are named %s" s
  | Recursive_abbrev s ->
      fprintf ppf "The type abbreviation %s is cyclic" s
  | Cycle_in_def (s, ty) ->
      Printtyp.reset_and_mark_loops ty;
      fprintf ppf "@[<v>The definition of %s contains a cycle:@ %a@]"
        s Printtyp.type_expr ty
  | Definition_mismatch (ty, errs) ->
      Printtyp.reset_and_mark_loops ty;
      fprintf ppf "@[<v>@[<hov>%s@ %s@;<1 2>%a@]%a@]"
        "This variant or record definition" "does not match that of type"
        Printtyp.type_expr ty
        (Includecore.report_type_mismatch "the original" "this" "definition")
        errs
  | Constraint_failed (ty, ty') ->
      Printtyp.reset_and_mark_loops ty;
      Printtyp.mark_loops ty';
      fprintf ppf "@[%s@ @[<hv>Type@ %a@ should be an instance of@ %a@]@]"
        "Constraints are not satisfied in this type."
        Printtyp.type_expr ty Printtyp.type_expr ty'
  | Parameters_differ (path, ty, ty') ->
      Printtyp.reset_and_mark_loops ty;
      Printtyp.mark_loops ty';
      fprintf ppf
        "@[<hv>In the definition of %s, type@ %a@ should be@ %a@]"
        (Path.name path) Printtyp.type_expr ty Printtyp.type_expr ty'
  | Inconsistent_constraint (env, trace) ->
      fprintf ppf "The type constraints are not consistent.@.";
      Printtyp.report_unification_error ppf env trace
        (fun ppf -> fprintf ppf "Type")
        (fun ppf -> fprintf ppf "is not compatible with type")
  | Type_clash (env, trace) ->
      Printtyp.report_unification_error ppf env trace
        (function ppf ->
           fprintf ppf "This type constructor expands to type")
        (function ppf ->
           fprintf ppf "but is used here with type")
  | Null_arity_external ->
      fprintf ppf "External identifiers must be functions"
  | Missing_native_external ->
      fprintf ppf "@[<hv>An external function with more than 5 arguments \
                   requires a second stub function@ \
                   for native-code compilation@]"
  | Unbound_type_var (ty, decl) ->
      fprintf ppf "A type variable is unbound in this type declaration";
      let ty = Ctype.repr ty in
      begin match decl.type_kind, decl.type_manifest with
      | Type_variant tl, _ ->
          explain_unbound ppf ty tl (fun c ->
            Btype.newgenty (Ttuple c.Types.cd_args))
            "case" (fun c -> Ident.name c.Types.cd_id ^ " of ")
      | Type_record (tl, _), _ ->
          explain_unbound ppf ty tl (fun l -> l.Types.ld_type)
            "field" (fun l -> Ident.name l.Types.ld_id ^ ": ")
      | Type_abstract, Some ty' ->
          explain_unbound_single ppf ty ty'
      | _ -> ()
      end
  | Unbound_type_var_ext (ty, ext) ->
      fprintf ppf "A type variable is unbound in this extension constructor";
      explain_unbound ppf ty ext.ext_args (fun c -> c) "type" (fun _ -> "")
  | Not_open_type path ->
      fprintf ppf "@[%s@ %a@]"
        "Cannot extend type definition"
        Printtyp.path path
  | Not_extensible_type path ->
      fprintf ppf "@[%s@ %a@ %s@]"
        "Type"
        Printtyp.path path
        "is not extensible"
  | Extension_mismatch (path, errs) ->
      fprintf ppf "@[<v>@[<hov>%s@ %s@;<1 2>%s@]%a@]"
        "This extension" "does not match the definition of type"
        (Path.name path)
        (Includecore.report_type_mismatch
           "the type" "this extension" "definition")
        errs
  | Rebind_wrong_type (lid, env, trace) ->
      Printtyp.report_unification_error ppf env trace
        (function ppf ->
          fprintf ppf "The constructor %a@ has type"
            Printtyp.longident lid)
        (function ppf ->
           fprintf ppf "but was expected to be of type")
  | Rebind_mismatch (lid, p, p') ->
      fprintf ppf
        "@[%s@ %a@ %s@ %s@ %s@ %s@ %s@]"
        "The constructor" Printtyp.longident lid
        "extends type" (Path.name p)
        "whose declaration does not match"
        "the declaration of type" (Path.name p')
  | Rebind_private lid ->
      fprintf ppf "@[%s@ %a@ %s@]"
        "The constructor"
        Printtyp.longident lid
        "is private"
  | Bad_variance (n, v1, v2) ->
      let variance (p,n,i) =
        let inj = if i then "injective " else "" in
        match p, n with
          true,  true  -> inj ^ "invariant"
        | true,  false -> inj ^ "covariant"
        | false, true  -> inj ^ "contravariant"
        | false, false -> if inj = "" then "unrestricted" else inj
      in
      let suffix n =
        let teen = (n mod 100)/10 = 1 in
        match n mod 10 with
        | 1 when not teen -> "st"
        | 2 when not teen -> "nd"
        | 3 when not teen -> "rd"
        | _ -> "th"
      in
      if n = -1 then
        fprintf ppf "@[%s@ %s@ It"
          "In this definition, a type variable has a variance that"
          "is not reflected by its occurrence in type parameters."
      else if n = -2 then
        fprintf ppf "@[%s@ %s@]"
          "In this definition, a type variable cannot be deduced"
          "from the type parameters."
      else if n = -3 then
        fprintf ppf "@[%s@ %s@ It"
          "In this definition, a type variable has a variance that"
          "cannot be deduced from the type parameters."
      else
        fprintf ppf "@[%s@ %s@ The %d%s type parameter"
          "In this definition, expected parameter"
          "variances are not satisfied."
          n (suffix n);
      if n <> -2 then
        fprintf ppf " was expected to be %s,@ but it is %s.@]"
          (variance v2) (variance v1)
  | Unavailable_type_constructor p ->
      fprintf ppf "The definition of type %a@ is unavailable" Printtyp.path p
  | Bad_fixed_type r ->
      fprintf ppf "This fixed type %s" r
  | Varying_anonymous ->
      fprintf ppf "@[%s@ %s@ %s@]"
        "In this GADT definition," "the variance of some parameter"
        "cannot be checked"

let () =
  Location.register_error_of_exn
    (function
      | Error (loc, err) ->
        Some (Location.error_of_printer loc report_error err)
      | _ ->
        None
    )

end
module Typeclass : sig
(*#1 "typeclass.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*         Jerome Vouillon, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Asttypes
open Types
open Format

val class_declarations:
  Env.t -> Parsetree.class_declaration list ->
  (Ident.t * string loc * class_declaration *
   Ident.t * class_type_declaration *
   Ident.t * type_declaration *
   Ident.t * type_declaration *
   int * string list * Typedtree.class_declaration) list * Env.t

(*
and class_declaration =
  (class_expr, Types.class_declaration) class_infos
*)

val class_descriptions:
  Env.t -> Parsetree.class_description list ->
  (Ident.t * string loc * class_declaration *
   Ident.t * class_type_declaration *
   Ident.t * type_declaration *
   Ident.t * type_declaration *
   int * string list * Typedtree.class_description) list * Env.t

(*
and class_description =
  (class_type, unit) class_infos
*)

val class_type_declarations:
  Env.t -> Parsetree.class_description list ->
  (Ident.t * string loc * class_type_declaration *
   Ident.t * type_declaration *
   Ident.t * type_declaration *
  Typedtree.class_type_declaration) list * Env.t

(*
and class_type_declaration =
  (class_type, Types.class_type_declaration) class_infos
*)

val approx_class_declarations:
  Env.t -> Parsetree.class_description list ->
  (Ident.t * string loc * class_type_declaration *
   Ident.t * type_declaration *
   Ident.t * type_declaration *
  Typedtree.class_type_declaration) list

val virtual_methods: Types.class_signature -> label list

(*
val type_classes :
           bool ->
           ('a -> Types.type_expr) ->
           (Env.t -> 'a -> 'b * Types.class_type) ->
           Env.t ->
           'a Parsetree.class_infos list ->
  (  Ident.t * Types.class_declaration *
     Ident.t * Types.class_type_declaration *
     Ident.t * Types.type_declaration *
     Ident.t * Types.type_declaration *
     int * string list * 'b * 'b Typedtree.class_infos)
           list * Env.t
*)

type error =
    Unconsistent_constraint of (type_expr * type_expr) list
  | Field_type_mismatch of string * string * (type_expr * type_expr) list
  | Structure_expected of class_type
  | Cannot_apply of class_type
  | Apply_wrong_label of label
  | Pattern_type_clash of type_expr
  | Repeated_parameter
  | Unbound_class_2 of Longident.t
  | Unbound_class_type_2 of Longident.t
  | Abbrev_type_clash of type_expr * type_expr * type_expr
  | Constructor_type_mismatch of string * (type_expr * type_expr) list
  | Virtual_class of bool * bool * string list * string list
  | Parameter_arity_mismatch of Longident.t * int * int
  | Parameter_mismatch of (type_expr * type_expr) list
  | Bad_parameters of Ident.t * type_expr * type_expr
  | Class_match_failure of Ctype.class_match_failure list
  | Unbound_val of string
  | Unbound_type_var of (formatter -> unit) * Ctype.closed_class_failure
  | Make_nongen_seltype of type_expr
  | Non_generalizable_class of Ident.t * Types.class_declaration
  | Cannot_coerce_self of type_expr
  | Non_collapsable_conjunction of
      Ident.t * Types.class_declaration * (type_expr * type_expr) list
  | Final_self_clash of (type_expr * type_expr) list
  | Mutability_mismatch of string * mutable_flag
  | No_overriding of string * string
  | Duplicate of string * string

exception Error of Location.t * Env.t * error
exception Error_forward of Location.error

val report_error : Env.t -> formatter -> error -> unit

end = struct
(*#1 "typeclass.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*         Jerome Vouillon, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Parsetree
open Asttypes
open Path
open Types
open Typecore
open Typetexp
open Format

type error =
    Unconsistent_constraint of (type_expr * type_expr) list
  | Field_type_mismatch of string * string * (type_expr * type_expr) list
  | Structure_expected of class_type
  | Cannot_apply of class_type
  | Apply_wrong_label of label
  | Pattern_type_clash of type_expr
  | Repeated_parameter
  | Unbound_class_2 of Longident.t
  | Unbound_class_type_2 of Longident.t
  | Abbrev_type_clash of type_expr * type_expr * type_expr
  | Constructor_type_mismatch of string * (type_expr * type_expr) list
  | Virtual_class of bool * bool * string list * string list
  | Parameter_arity_mismatch of Longident.t * int * int
  | Parameter_mismatch of (type_expr * type_expr) list
  | Bad_parameters of Ident.t * type_expr * type_expr
  | Class_match_failure of Ctype.class_match_failure list
  | Unbound_val of string
  | Unbound_type_var of (formatter -> unit) * Ctype.closed_class_failure
  | Make_nongen_seltype of type_expr
  | Non_generalizable_class of Ident.t * Types.class_declaration
  | Cannot_coerce_self of type_expr
  | Non_collapsable_conjunction of
      Ident.t * Types.class_declaration * (type_expr * type_expr) list
  | Final_self_clash of (type_expr * type_expr) list
  | Mutability_mismatch of string * mutable_flag
  | No_overriding of string * string
  | Duplicate of string * string

exception Error of Location.t * Env.t * error
exception Error_forward of Location.error

open Typedtree

let ctyp desc typ env loc =
  { ctyp_desc = desc; ctyp_type = typ; ctyp_loc = loc; ctyp_env = env; ctyp_attributes = [] }

                       (**********************)
                       (*  Useful constants  *)
                       (**********************)


(*
   Self type have a dummy private method, thus preventing it to become
   closed.
*)
let dummy_method = Btype.dummy_method

(*
   Path associated to the temporary class type of a class being typed
   (its constructor is not available).
*)
let unbound_class = Path.Pident (Ident.create "")


                (************************************)
                (*  Some operations on class types  *)
                (************************************)


(* Fully expand the head of a class type *)
let rec scrape_class_type =
  function
    Cty_constr (_, _, cty) -> scrape_class_type cty
  | cty                     -> cty

(* Generalize a class type *)
let rec generalize_class_type gen =
  function
    Cty_constr (_, params, cty) ->
      List.iter gen params;
      generalize_class_type gen cty
  | Cty_signature {csig_self = sty; csig_vars = vars; csig_inher = inher} ->
      gen sty;
      Vars.iter (fun _ (_, _, ty) -> gen ty) vars;
      List.iter (fun (_,tl) -> List.iter gen tl) inher
  | Cty_arrow (_, ty, cty) ->
      gen ty;
      generalize_class_type gen cty

let generalize_class_type vars =
  let gen = if vars then Ctype.generalize else Ctype.generalize_structure in
  generalize_class_type gen

(* Return the virtual methods of a class type *)
let virtual_methods sign =
  let (fields, _) =
    Ctype.flatten_fields (Ctype.object_fields sign.Types.csig_self)
  in
  List.fold_left
    (fun virt (lab, _, _) ->
       if lab = dummy_method then virt else
       if Concr.mem lab sign.csig_concr then virt else
       lab::virt)
    [] fields

(* Return the constructor type associated to a class type *)
let rec constructor_type constr cty =
  match cty with
    Cty_constr (_, _, cty) ->
      constructor_type constr cty
  | Cty_signature sign ->
      constr
  | Cty_arrow (l, ty, cty) ->
      Ctype.newty (Tarrow (l, ty, constructor_type constr cty, Cok))

let rec class_body cty =
  match cty with
    Cty_constr (_, _, cty') ->
      cty (* Only class bodies can be abbreviated *)
  | Cty_signature sign ->
      cty
  | Cty_arrow (_, ty, cty) ->
      class_body cty

let extract_constraints cty =
  let sign = Ctype.signature_of_class_type cty in
  (Vars.fold (fun lab _ vars -> lab :: vars) sign.csig_vars [],
   begin let (fields, _) =
     Ctype.flatten_fields (Ctype.object_fields sign.csig_self)
   in
   List.fold_left
     (fun meths (lab, _, _) ->
        if lab = dummy_method then meths else lab::meths)
     [] fields
   end,
   sign.csig_concr)

let rec abbreviate_class_type path params cty =
  match cty with
    Cty_constr (_, _, _) | Cty_signature _ ->
      Cty_constr (path, params, cty)
  | Cty_arrow (l, ty, cty) ->
      Cty_arrow (l, ty, abbreviate_class_type path params cty)

let rec closed_class_type =
  function
    Cty_constr (_, params, _) ->
      List.for_all Ctype.closed_schema params
  | Cty_signature sign ->
      Ctype.closed_schema sign.csig_self
        &&
      Vars.fold (fun _ (_, _, ty) cc -> Ctype.closed_schema ty && cc)
        sign.csig_vars
        true
  | Cty_arrow (_, ty, cty) ->
      Ctype.closed_schema ty
        &&
      closed_class_type cty

let closed_class cty =
  List.for_all Ctype.closed_schema cty.cty_params
    &&
  closed_class_type cty.cty_type

let rec limited_generalize rv =
  function
    Cty_constr (path, params, cty) ->
      List.iter (Ctype.limited_generalize rv) params;
      limited_generalize rv cty
  | Cty_signature sign ->
      Ctype.limited_generalize rv sign.csig_self;
      Vars.iter (fun _ (_, _, ty) -> Ctype.limited_generalize rv ty)
        sign.csig_vars;
      List.iter (fun (_, tl) -> List.iter (Ctype.limited_generalize rv) tl)
        sign.csig_inher
  | Cty_arrow (_, ty, cty) ->
      Ctype.limited_generalize rv ty;
      limited_generalize rv cty

(* Record a class type *)
let rc node =
  Cmt_format.add_saved_type (Cmt_format.Partial_class_expr node);
  Stypes.record (Stypes.Ti_class node); (* moved to genannot *)
  node


                (***********************************)
                (*  Primitives for typing classes  *)
                (***********************************)


(* Enter a value in the method environment only *)
let enter_met_env ?check loc lab kind ty val_env met_env par_env =
  let (id, val_env) =
    Env.enter_value lab {val_type = ty; val_kind = Val_unbound;
                         val_attributes = [];
                         Types.val_loc = loc} val_env
  in
  (id, val_env,
   Env.add_value ?check id {val_type = ty; val_kind = kind;
                            val_attributes = [];
                            Types.val_loc = loc} met_env,
   Env.add_value id {val_type = ty; val_kind = Val_unbound;
                     val_attributes = [];
                     Types.val_loc = loc} par_env)

(* Enter an instance variable in the environment *)
let enter_val cl_num vars inh lab mut virt ty val_env met_env par_env loc =
  let instance = Ctype.instance val_env in
  let (id, virt) =
    try
      let (id, mut', virt', ty') = Vars.find lab !vars in
      if mut' <> mut then
        raise (Error(loc, val_env, Mutability_mismatch(lab, mut)));
      Ctype.unify val_env (instance ty) (instance ty');
      (if not inh then Some id else None),
      (if virt' = Concrete then virt' else virt)
    with
      Ctype.Unify tr ->
        raise (Error(loc, val_env,
                     Field_type_mismatch("instance variable", lab, tr)))
    | Not_found -> None, virt
  in
  let (id, _, _, _) as result =
    match id with Some id -> (id, val_env, met_env, par_env)
    | None ->
        enter_met_env Location.none lab (Val_ivar (mut, cl_num))
          ty val_env met_env par_env
  in
  vars := Vars.add lab (id, mut, virt, ty) !vars;
  result

let concr_vals vars =
  Vars.fold
    (fun id (_, vf, _) s -> if vf = Virtual then s else Concr.add id s)
    vars Concr.empty

let inheritance self_type env ovf concr_meths warn_vals loc parent =
  match scrape_class_type parent with
    Cty_signature cl_sig ->

      (* Methods *)
      begin try
        Ctype.unify env self_type cl_sig.csig_self
      with Ctype.Unify trace ->
        match trace with
          _::_::_::({desc = Tfield(n, _, _, _)}, _)::rem ->
            raise(Error(loc, env, Field_type_mismatch ("method", n, rem)))
        | _ ->
            assert false
      end;

      (* Overriding *)
      let over_meths = Concr.inter cl_sig.csig_concr concr_meths in
      let concr_vals = concr_vals cl_sig.csig_vars in
      let over_vals = Concr.inter concr_vals warn_vals in
      begin match ovf with
        Some Fresh ->
          let cname =
            match parent with
              Cty_constr (p, _, _) -> Path.name p
            | _ -> "inherited"
          in
          if not (Concr.is_empty over_meths) then
            Location.prerr_warning loc
              (Warnings.Method_override (cname :: Concr.elements over_meths));
          if not (Concr.is_empty over_vals) then
            Location.prerr_warning loc
              (Warnings.Instance_variable_override
                 (cname :: Concr.elements over_vals));
      | Some Override
        when Concr.is_empty over_meths && Concr.is_empty over_vals ->
        raise (Error(loc, env, No_overriding ("","")))
      | _ -> ()
      end;

      let concr_meths = Concr.union cl_sig.csig_concr concr_meths
      and warn_vals = Concr.union concr_vals warn_vals in

      (cl_sig, concr_meths, warn_vals)

  | _ ->
      raise(Error(loc, env, Structure_expected parent))

let virtual_method val_env meths self_type lab priv sty loc =
  let (_, ty') =
     Ctype.filter_self_method val_env lab priv meths self_type
  in
  let sty = Ast_helper.Typ.force_poly sty in
  let cty = transl_simple_type val_env false sty in
  let ty = cty.ctyp_type in
  begin
    try Ctype.unify val_env ty ty' with Ctype.Unify trace ->
        raise(Error(loc, val_env, Field_type_mismatch ("method", lab, trace)));
  end;
  cty

let delayed_meth_specs = ref []

let declare_method val_env meths self_type lab priv sty loc =
  let (_, ty') =
     Ctype.filter_self_method val_env lab priv meths self_type
  in
  let unif ty =
    try Ctype.unify val_env ty ty' with Ctype.Unify trace ->
      raise(Error(loc, val_env, Field_type_mismatch ("method", lab, trace)))
  in
  let sty = Ast_helper.Typ.force_poly sty in
  match sty.ptyp_desc, priv with
    Ptyp_poly ([],sty'), Public ->
(* TODO: we moved the [transl_simple_type_univars] outside of the lazy,
so that we can get an immediate value. Is that correct ? Ask Jacques. *)
      let returned_cty = ctyp Ttyp_any (Ctype.newty Tnil) val_env loc in
      delayed_meth_specs :=
      lazy (
        let cty = transl_simple_type_univars val_env sty' in
        let ty = cty.ctyp_type in
        unif ty;
        returned_cty.ctyp_desc <- Ttyp_poly ([], cty);
        returned_cty.ctyp_type <- ty;
        ) ::
      !delayed_meth_specs;
      returned_cty
  | _ ->
      let cty = transl_simple_type val_env false sty in
      let ty = cty.ctyp_type in
      unif ty;
      cty

let type_constraint val_env sty sty' loc =
  let cty  = transl_simple_type val_env false sty in
  let ty = cty.ctyp_type in
  let cty' = transl_simple_type val_env false sty' in
  let ty' = cty'.ctyp_type in
  begin
    try Ctype.unify val_env ty ty' with Ctype.Unify trace ->
        raise(Error(loc, val_env, Unconsistent_constraint trace));
  end;
  (cty, cty')

let make_method loc cl_num expr =
  let open Ast_helper in
  let mkid s = mkloc s loc in
  Exp.fun_ ~loc:expr.pexp_loc "" None
    (Pat.alias ~loc (Pat.var ~loc (mkid "self-*")) (mkid ("self-" ^ cl_num)))
    expr

(*******************************)

let add_val env loc lab (mut, virt, ty) val_sig =
  let virt =
    try
      let (mut', virt', ty') = Vars.find lab val_sig in
      if virt' = Concrete then virt' else virt
    with Not_found -> virt
  in
  Vars.add lab (mut, virt, ty) val_sig

let rec class_type_field env self_type meths
    (fields, val_sig, concr_meths, inher) ctf =
  let loc = ctf.pctf_loc in
  let mkctf desc = { ctf_desc = desc; ctf_loc = loc; ctf_attributes = ctf.pctf_attributes } in
  match ctf.pctf_desc with
    Pctf_inherit sparent ->
      let parent = class_type env sparent in
      let inher =
        match parent.cltyp_type with
          Cty_constr (p, tl, _) -> (p, tl) :: inher
        | _ -> inher
      in
      let (cl_sig, concr_meths, _) =
        inheritance self_type env None concr_meths Concr.empty sparent.pcty_loc
          parent.cltyp_type
      in
      let val_sig =
        Vars.fold (add_val env sparent.pcty_loc) cl_sig.csig_vars val_sig in
      (mkctf (Tctf_inherit parent) :: fields,
       val_sig, concr_meths, inher)

  | Pctf_val (lab, mut, virt, sty) ->
      let cty = transl_simple_type env false sty in
      let ty = cty.ctyp_type in
      (mkctf (Tctf_val (lab, mut, virt, cty)) :: fields,
      add_val env ctf.pctf_loc lab (mut, virt, ty) val_sig, concr_meths, inher)

  | Pctf_method (lab, priv, virt, sty)  ->
      let cty =
        declare_method env meths self_type lab priv sty  ctf.pctf_loc in
      let concr_meths =
        match virt with
        | Concrete -> Concr.add lab concr_meths
        | Virtual -> concr_meths
      in
      (mkctf (Tctf_method (lab, priv, virt, cty)) :: fields,
        val_sig, concr_meths, inher)

  | Pctf_constraint (sty, sty') ->
      let (cty, cty') = type_constraint env sty sty'  ctf.pctf_loc in
      (mkctf (Tctf_constraint (cty, cty')) :: fields,
        val_sig, concr_meths, inher)

  | Pctf_attribute x ->
      Typetexp.warning_attribute [x];
      (mkctf (Tctf_attribute x) :: fields,
        val_sig, concr_meths, inher)

  | Pctf_extension ext ->
      raise (Error_forward (Typetexp.error_of_extension ext))

and class_signature env {pcsig_self=sty; pcsig_fields=sign} =
  let meths = ref Meths.empty in
  let self_cty = transl_simple_type env false sty in
  let self_cty = { self_cty with
    ctyp_type = Ctype.expand_head env self_cty.ctyp_type } in
  let self_type =  self_cty.ctyp_type in

  (* Check that the binder is a correct type, and introduce a dummy
     method preventing self type from being closed. *)
  let dummy_obj = Ctype.newvar () in
  Ctype.unify env (Ctype.filter_method env dummy_method Private dummy_obj)
    (Ctype.newty (Ttuple []));
  begin try
    Ctype.unify env self_type dummy_obj
  with Ctype.Unify _ ->
    raise(Error(sty.ptyp_loc, env, Pattern_type_clash self_type))
  end;

  (* Class type fields *)
  Typetexp.warning_enter_scope ();
  let (rev_fields, val_sig, concr_meths, inher) =
    List.fold_left (class_type_field env self_type meths)
      ([], Vars.empty, Concr.empty, [])
      sign
  in
  Typetexp.warning_leave_scope ();
  let cty =   {csig_self = self_type;
   csig_vars = val_sig;
   csig_concr = concr_meths;
   csig_inher = inher}
  in
  { csig_self = self_cty;
    csig_fields = List.rev rev_fields;
    csig_type = cty;
  }

and class_type env scty =
  let cltyp desc typ =
    {
     cltyp_desc = desc;
     cltyp_type = typ;
     cltyp_loc = scty.pcty_loc;
     cltyp_env = env;
     cltyp_attributes = scty.pcty_attributes;
    }
  in
  match scty.pcty_desc with
    Pcty_constr (lid, styl) ->
      let (path, decl) = Typetexp.find_class_type env scty.pcty_loc lid.txt in
      if Path.same decl.clty_path unbound_class then
        raise(Error(scty.pcty_loc, env, Unbound_class_type_2 lid.txt));
      let (params, clty) =
        Ctype.instance_class decl.clty_params decl.clty_type
      in
      if List.length params <> List.length styl then
        raise(Error(scty.pcty_loc, env,
                    Parameter_arity_mismatch (lid.txt, List.length params,
                                                   List.length styl)));
      let ctys = List.map2
        (fun sty ty ->
          let cty' = transl_simple_type env false sty in
          let ty' = cty'.ctyp_type in
          begin
           try Ctype.unify env ty' ty with Ctype.Unify trace ->
                  raise(Error(sty.ptyp_loc, env, Parameter_mismatch trace))
            end;
            cty'
        )       styl params
      in
      let typ = Cty_constr (path, params, clty) in
      cltyp (Tcty_constr ( path, lid , ctys)) typ

  | Pcty_signature pcsig ->
      let clsig = class_signature env pcsig in
      let typ = Cty_signature clsig.csig_type in
      cltyp (Tcty_signature clsig) typ

  | Pcty_arrow (l, sty, scty) ->
      let cty = transl_simple_type env false sty in
      let ty = cty.ctyp_type in
      let clty = class_type env scty in
      let typ = Cty_arrow (l, ty, clty.cltyp_type) in
      cltyp (Tcty_arrow (l, cty, clty)) typ
  | Pcty_extension ext ->
      raise (Error_forward (Typetexp.error_of_extension ext))

let class_type env scty =
  delayed_meth_specs := [];
  let cty = class_type env scty in
  List.iter Lazy.force (List.rev !delayed_meth_specs);
  delayed_meth_specs := [];
  cty

(*******************************)

let rec class_field self_loc cl_num self_type meths vars
    (val_env, met_env, par_env, fields, concr_meths, warn_vals, inher,
     local_meths, local_vals)
  cf =
  let loc = cf.pcf_loc in
  let mkcf desc = { cf_desc = desc; cf_loc = loc; cf_attributes = cf.pcf_attributes } in
  match cf.pcf_desc with
    Pcf_inherit (ovf, sparent, super) ->
      let parent = class_expr cl_num val_env par_env sparent in
      let inher =
        match parent.cl_type with
          Cty_constr (p, tl, _) -> (p, tl) :: inher
        | _ -> inher
      in
      let (cl_sig, concr_meths, warn_vals) =
        inheritance self_type val_env (Some ovf) concr_meths warn_vals
          sparent.pcl_loc parent.cl_type
      in
      (* Variables *)
      let (val_env, met_env, par_env, inh_vars) =
        Vars.fold
          (fun lab info (val_env, met_env, par_env, inh_vars) ->
             let mut, vr, ty = info in
             let (id, val_env, met_env, par_env) =
               enter_val cl_num vars true lab mut vr ty val_env met_env par_env
                 sparent.pcl_loc
             in
             (val_env, met_env, par_env, (lab, id) :: inh_vars))
          cl_sig.csig_vars (val_env, met_env, par_env, [])
      in
      (* Inherited concrete methods *)
      let inh_meths =
        Concr.fold (fun lab rem -> (lab, Ident.create lab)::rem)
          cl_sig.csig_concr []
      in
      (* Super *)
      let (val_env, met_env, par_env) =
        match super with
          None ->
            (val_env, met_env, par_env)
        | Some name ->
            let (id, val_env, met_env, par_env) =
              enter_met_env ~check:(fun s -> Warnings.Unused_ancestor s)
                sparent.pcl_loc name (Val_anc (inh_meths, cl_num)) self_type
                val_env met_env par_env
            in
            (val_env, met_env, par_env)
      in
      (val_env, met_env, par_env,
       lazy (mkcf (Tcf_inherit (ovf, parent, super, inh_vars, inh_meths)))
       :: fields,
       concr_meths, warn_vals, inher, local_meths, local_vals)

  | Pcf_val (lab, mut, Cfk_virtual styp) ->
      if !Clflags.principal then Ctype.begin_def ();
      let cty = Typetexp.transl_simple_type val_env false styp in
      let ty = cty.ctyp_type in
      if !Clflags.principal then begin
        Ctype.end_def ();
        Ctype.generalize_structure ty
      end;
      let (id, val_env, met_env', par_env) =
        enter_val cl_num vars false lab.txt mut Virtual ty
          val_env met_env par_env loc
      in
      (val_env, met_env', par_env,
       lazy (mkcf (Tcf_val (lab, mut, id, Tcfk_virtual cty,
                            met_env == met_env')))
             :: fields,
             concr_meths, warn_vals, inher, local_meths, local_vals)

  | Pcf_val (lab, mut, Cfk_concrete (ovf, sexp)) ->
      if Concr.mem lab.txt local_vals then
        raise(Error(loc, val_env, Duplicate ("instance variable", lab.txt)));
      if Concr.mem lab.txt warn_vals then begin
        if ovf = Fresh then
          Location.prerr_warning lab.loc
            (Warnings.Instance_variable_override[lab.txt])
      end else begin
        if ovf = Override then
          raise(Error(loc, val_env,
                      No_overriding ("instance variable", lab.txt)))
      end;
      if !Clflags.principal then Ctype.begin_def ();
      let exp =
        try type_exp val_env sexp with Ctype.Unify [(ty, _)] ->
          raise(Error(loc, val_env, Make_nongen_seltype ty))
      in
      if !Clflags.principal then begin
        Ctype.end_def ();
        Ctype.generalize_structure exp.exp_type
       end;
      let (id, val_env, met_env', par_env) =
        enter_val cl_num vars false lab.txt mut Concrete exp.exp_type
          val_env met_env par_env loc
      in
      (val_env, met_env', par_env,
       lazy (mkcf (Tcf_val (lab, mut, id,
                            Tcfk_concrete (ovf, exp), met_env == met_env')))
       :: fields,
       concr_meths, Concr.add lab.txt warn_vals, inher, local_meths,
       Concr.add lab.txt local_vals)

  | Pcf_method (lab, priv, Cfk_virtual sty) ->
      let cty = virtual_method val_env meths self_type lab.txt priv sty loc in
      (val_env, met_env, par_env,
        lazy (mkcf(Tcf_method (lab, priv, Tcfk_virtual cty)))
       ::fields,
        concr_meths, warn_vals, inher, local_meths, local_vals)

  | Pcf_method (lab, priv, Cfk_concrete (ovf, expr))  ->
      let expr =
        match expr.pexp_desc with
        | Pexp_poly _ -> expr
        | _ -> Ast_helper.Exp.poly ~loc:expr.pexp_loc expr None
      in
      if Concr.mem lab.txt local_meths then
        raise(Error(loc, val_env, Duplicate ("method", lab.txt)));
      if Concr.mem lab.txt concr_meths then begin
        if ovf = Fresh then
          Location.prerr_warning loc (Warnings.Method_override [lab.txt])
      end else begin
        if ovf = Override then
          raise(Error(loc, val_env, No_overriding("method", lab.txt)))
      end;
      let (_, ty) =
        Ctype.filter_self_method val_env lab.txt priv meths self_type
      in
      begin try match expr.pexp_desc with
        Pexp_poly (sbody, sty) ->
          begin match sty with None -> ()
                | Some sty ->
                    let sty = Ast_helper.Typ.force_poly sty in
                    let cty' = Typetexp.transl_simple_type val_env false sty in
                    let ty' = cty'.ctyp_type in
              Ctype.unify val_env ty' ty
          end;
          begin match (Ctype.repr ty).desc with
            Tvar _ ->
              let ty' = Ctype.newvar () in
              Ctype.unify val_env (Ctype.newty (Tpoly (ty', []))) ty;
              Ctype.unify val_env (type_approx val_env sbody) ty'
          | Tpoly (ty1, tl) ->
              let _, ty1' = Ctype.instance_poly false tl ty1 in
              let ty2 = type_approx val_env sbody in
              Ctype.unify val_env ty2 ty1'
          | _ -> assert false
          end
      | _ -> assert false
      with Ctype.Unify trace ->
        raise(Error(loc, val_env,
                    Field_type_mismatch ("method", lab.txt, trace)))
      end;
      let meth_expr = make_method self_loc cl_num expr in
      (* backup variables for Pexp_override *)
      let vars_local = !vars in

      let field =
        lazy begin
          let meth_type =
            Btype.newgenty (Tarrow("", self_type, ty, Cok)) in
          Ctype.raise_nongen_level ();
          vars := vars_local;
          let texp = type_expect met_env meth_expr meth_type in
          Ctype.end_def ();
          mkcf (Tcf_method (lab, priv, Tcfk_concrete (ovf, texp)))
        end in
      (val_env, met_env, par_env, field::fields,
       Concr.add lab.txt concr_meths, warn_vals, inher,
       Concr.add lab.txt local_meths, local_vals)

  | Pcf_constraint (sty, sty') ->
      let (cty, cty') = type_constraint val_env sty sty' loc in
      (val_env, met_env, par_env,
        lazy (mkcf (Tcf_constraint (cty, cty'))) :: fields,
        concr_meths, warn_vals, inher, local_meths, local_vals)

  | Pcf_initializer expr ->
      let expr = make_method self_loc cl_num expr in
      let vars_local = !vars in
      let field =
        lazy begin
          Ctype.raise_nongen_level ();
          let meth_type =
            Ctype.newty
              (Tarrow ("", self_type,
                       Ctype.instance_def Predef.type_unit, Cok)) in
          vars := vars_local;
          let texp = type_expect met_env expr meth_type in
          Ctype.end_def ();
          mkcf (Tcf_initializer texp)
        end in
      (val_env, met_env, par_env, field::fields, concr_meths, warn_vals,
       inher, local_meths, local_vals)
  | Pcf_attribute x ->
      Typetexp.warning_attribute [x];
      (val_env, met_env, par_env,
        lazy (mkcf (Tcf_attribute x)) :: fields,
        concr_meths, warn_vals, inher, local_meths, local_vals)
  | Pcf_extension ext ->
      raise (Error_forward (Typetexp.error_of_extension ext))

and class_structure cl_num final val_env met_env loc
  { pcstr_self = spat; pcstr_fields = str } =
  (* Environment for substructures *)
  let par_env = met_env in

  (* Location of self. Used for locations of self arguments *)
  let self_loc = {spat.ppat_loc with Location.loc_ghost = true} in

  (* Self type, with a dummy method preventing it from being closed/escaped. *)
  let self_type = Ctype.newvar () in
  Ctype.unify val_env
    (Ctype.filter_method val_env dummy_method Private self_type)
    (Ctype.newty (Ttuple []));

  (* Private self is used for private method calls *)
  let private_self = if final then Ctype.newvar () else self_type in

  (* Self binder *)
  let (pat, meths, vars, val_env, meth_env, par_env) =
    type_self_pattern cl_num private_self val_env met_env par_env spat
  in
  let public_self = pat.pat_type in

  (* Check that the binder has a correct type *)
  let ty =
    if final then Ctype.newty (Tobject (Ctype.newvar(), ref None))
    else self_type in
  begin try Ctype.unify val_env public_self ty with
    Ctype.Unify _ ->
      raise(Error(spat.ppat_loc, val_env, Pattern_type_clash public_self))
  end;
  let get_methods ty =
    (fst (Ctype.flatten_fields
            (Ctype.object_fields (Ctype.expand_head val_env ty)))) in
  if final then begin
    (* Copy known information to still empty self_type *)
    List.iter
      (fun (lab,kind,ty) ->
        let k =
          if Btype.field_kind_repr kind = Fpresent then Public else Private in
        try Ctype.unify val_env ty
            (Ctype.filter_method val_env lab k self_type)
        with _ -> assert false)
      (get_methods public_self)
  end;

  (* Typing of class fields *)
  Typetexp.warning_enter_scope ();
  let (_, _, _, fields, concr_meths, _, inher, _local_meths, _local_vals) =
    List.fold_left (class_field self_loc cl_num self_type meths vars)
      (val_env, meth_env, par_env, [], Concr.empty, Concr.empty, [],
       Concr.empty, Concr.empty)
      str
  in
  Typetexp.warning_leave_scope ();
  Ctype.unify val_env self_type (Ctype.newvar ());
  let sign =
    {csig_self = public_self;
     csig_vars = Vars.map (fun (id, mut, vr, ty) -> (mut, vr, ty)) !vars;
     csig_concr = concr_meths;
      csig_inher = inher} in
  let methods = get_methods self_type in
  let priv_meths =
    List.filter (fun (_,kind,_) -> Btype.field_kind_repr kind <> Fpresent)
      methods in
  if final then begin
    (* Unify private_self and a copy of self_type. self_type will not
       be modified after this point *)
    Ctype.close_object self_type;
    let mets = virtual_methods {sign with csig_self = self_type} in
    let vals =
      Vars.fold
        (fun name (mut, vr, ty) l -> if vr = Virtual then name :: l else l)
        sign.csig_vars [] in
    if mets <> [] || vals <> [] then
      raise(Error(loc, val_env, Virtual_class(true, final, mets, vals)));
    let self_methods =
      List.fold_right
        (fun (lab,kind,ty) rem ->
          if lab = dummy_method then
            (* allow public self and private self to be unified *)
            match Btype.field_kind_repr kind with
              Fvar r -> Btype.set_kind r Fabsent; rem
            | _ -> rem
          else
            Ctype.newty(Tfield(lab, Btype.copy_kind kind, ty, rem)))
        methods (Ctype.newty Tnil) in
    begin try
      Ctype.unify val_env private_self
        (Ctype.newty (Tobject(self_methods, ref None)));
      Ctype.unify val_env public_self self_type
    with Ctype.Unify trace -> raise(Error(loc, val_env, Final_self_clash trace))
    end;
  end;

  (* Typing of method bodies *)
  if !Clflags.principal then
    List.iter (fun (_,_,ty) -> Ctype.generalize_spine ty) methods;
  let fields = List.map Lazy.force (List.rev fields) in
  if !Clflags.principal then
    List.iter (fun (_,_,ty) -> Ctype.unify val_env ty (Ctype.newvar ()))
      methods;
  let meths = Meths.map (function (id, ty) -> id) !meths in

  (* Check for private methods made public *)
  let pub_meths' =
    List.filter (fun (_,kind,_) -> Btype.field_kind_repr kind = Fpresent)
      (get_methods public_self) in
  let names = List.map (fun (x,_,_) -> x) in
  let l1 = names priv_meths and l2 = names pub_meths' in
  let added = List.filter (fun x -> List.mem x l1) l2 in
  if added <> [] then
    Location.prerr_warning loc (Warnings.Implicit_public_methods added);
  let sign = if final then sign else
      {sign with csig_self = Ctype.expand_head val_env public_self} in
  {
    cstr_self = pat;
    cstr_fields = fields;
    cstr_type = sign;
    cstr_meths = meths}, sign (* redondant, since already in cstr_type *)

and class_expr cl_num val_env met_env scl =
  match scl.pcl_desc with
    Pcl_constr (lid, styl) ->
      let (path, decl) = Typetexp.find_class val_env scl.pcl_loc lid.txt in
      if Path.same decl.cty_path unbound_class then
        raise(Error(scl.pcl_loc, val_env, Unbound_class_2 lid.txt));
      let tyl = List.map
          (fun sty -> transl_simple_type val_env false sty)
          styl
      in
      let (params, clty) =
        Ctype.instance_class decl.cty_params decl.cty_type
      in
      let clty' = abbreviate_class_type path params clty in
      if List.length params <> List.length tyl then
        raise(Error(scl.pcl_loc, val_env,
                    Parameter_arity_mismatch (lid.txt, List.length params,
                                                   List.length tyl)));
      List.iter2
        (fun cty' ty ->
          let ty' = cty'.ctyp_type in
           try Ctype.unify val_env ty' ty with Ctype.Unify trace ->
             raise(Error(cty'.ctyp_loc, val_env, Parameter_mismatch trace)))
        tyl params;
      let cl =
        rc {cl_desc = Tcl_ident (path, lid, tyl);
            cl_loc = scl.pcl_loc;
            cl_type = clty';
            cl_env = val_env;
            cl_attributes = scl.pcl_attributes;
           }
      in
      let (vals, meths, concrs) = extract_constraints clty in
      rc {cl_desc = Tcl_constraint (cl, None, vals, meths, concrs);
          cl_loc = scl.pcl_loc;
          cl_type = clty';
          cl_env = val_env;
          cl_attributes = []; (* attributes are kept on the inner cl node *)
         }
  | Pcl_structure cl_str ->
      let (desc, ty) =
        class_structure cl_num false val_env met_env scl.pcl_loc cl_str in
      rc {cl_desc = Tcl_structure desc;
          cl_loc = scl.pcl_loc;
          cl_type = Cty_signature ty;
          cl_env = val_env;
          cl_attributes = scl.pcl_attributes;
         }
  | Pcl_fun (l, Some default, spat, sbody) ->
      let loc = default.pexp_loc in
      let open Ast_helper in
      let scases = [
        Exp.case
          (Pat.construct ~loc
             (mknoloc (Longident.(Ldot (Lident "*predef*", "Some"))))
             (Some (Pat.var ~loc (mknoloc "*sth*"))))
          (Exp.ident ~loc (mknoloc (Longident.Lident "*sth*")));

        Exp.case
          (Pat.construct ~loc
             (mknoloc (Longident.(Ldot (Lident "*predef*", "None"))))
             None)
          default;
       ]
      in
      let smatch =
        Exp.match_ ~loc (Exp.ident ~loc (mknoloc (Longident.Lident "*opt*")))
          scases
      in
      let sfun =
        Cl.fun_ ~loc:scl.pcl_loc
          l None
          (Pat.var ~loc (mknoloc "*opt*"))
          (Cl.let_ ~loc:scl.pcl_loc Nonrecursive [Vb.mk spat smatch] sbody)
          (* Note: we don't put the '#default' attribute, as it
             is not detected for class-level let bindings.  See #5975.*)
      in
      class_expr cl_num val_env met_env sfun
  | Pcl_fun (l, None, spat, scl') ->
      if !Clflags.principal then Ctype.begin_def ();
      let (pat, pv, val_env', met_env) =
        Typecore.type_class_arg_pattern cl_num val_env met_env l spat
      in
      if !Clflags.principal then begin
        Ctype.end_def ();
        iter_pattern (fun {pat_type=ty} -> Ctype.generalize_structure ty) pat
      end;
      let pv =
        List.map
          begin fun (id, id_loc, id', ty) ->
            let path = Pident id' in
            (* do not mark the value as being used *)
            let vd = Env.find_value path val_env' in
            (id, id_loc,
             {exp_desc =
              Texp_ident(path, mknoloc (Longident.Lident (Ident.name id)), vd);
              exp_loc = Location.none; exp_extra = [];
              exp_type = Ctype.instance val_env' vd.val_type;
              exp_attributes = []; (* check *)
              exp_env = val_env'})
          end
          pv
      in
      let not_function = function
          Cty_arrow _ -> false
        | _ -> true
      in
      let partial =
        Typecore.check_partial val_env pat.pat_type pat.pat_loc
          [{c_lhs=pat;
            c_guard=None;
            c_rhs = (* Dummy expression *)
            {exp_desc = Texp_constant (Asttypes.Const_int 1);
             exp_loc = Location.none; exp_extra = [];
             exp_type = Ctype.none;
             exp_attributes = [];
             exp_env = Env.empty }}]
      in
      Ctype.raise_nongen_level ();
      let cl = class_expr cl_num val_env' met_env scl' in
      Ctype.end_def ();
      if Btype.is_optional l && not_function cl.cl_type then
        Location.prerr_warning pat.pat_loc
          Warnings.Unerasable_optional_argument;
      rc {cl_desc = Tcl_fun (l, pat, pv, cl, partial);
          cl_loc = scl.pcl_loc;
          cl_type = Cty_arrow
            (l, Ctype.instance_def pat.pat_type, cl.cl_type);
          cl_env = val_env;
          cl_attributes = scl.pcl_attributes;
         }
  | Pcl_apply (scl', sargs) ->
      if sargs = [] then
        Syntaxerr.ill_formed_ast scl.pcl_loc
          "Function application with no argument.";
      if !Clflags.principal then Ctype.begin_def ();
      let cl = class_expr cl_num val_env met_env scl' in
      if !Clflags.principal then begin
        Ctype.end_def ();
        generalize_class_type false cl.cl_type;
      end;
      let rec nonopt_labels ls ty_fun =
        match ty_fun with
        | Cty_arrow (l, _, ty_res) ->
            if Btype.is_optional l then nonopt_labels ls ty_res
            else nonopt_labels (l::ls) ty_res
        | _    -> ls
      in
      let ignore_labels =
        !Clflags.classic ||
        let labels = nonopt_labels [] cl.cl_type in
        List.length labels = List.length sargs &&
        List.for_all (fun (l,_) -> l = "") sargs &&
        List.exists (fun l -> l <> "") labels &&
        begin
          Location.prerr_warning cl.cl_loc Warnings.Labels_omitted;
          true
        end
      in
      let rec type_args args omitted ty_fun ty_fun0 sargs more_sargs =
        match ty_fun, ty_fun0 with
        | Cty_arrow (l, ty, ty_fun), Cty_arrow (_, ty0, ty_fun0)
          when sargs <> [] || more_sargs <> [] ->
            let name = Btype.label_name l
            and optional =
              if Btype.is_optional l then Optional else Required in
            let sargs, more_sargs, arg =
              if ignore_labels && not (Btype.is_optional l) then begin
                match sargs, more_sargs with
                  (l', sarg0)::_, _ ->
                    raise(Error(sarg0.pexp_loc, val_env, Apply_wrong_label l'))
                | _, (l', sarg0)::more_sargs ->
                    if l <> l' && l' <> "" then
                      raise(Error(sarg0.pexp_loc, val_env,
                                  Apply_wrong_label l'))
                    else ([], more_sargs,
                          Some (type_argument val_env sarg0 ty ty0))
                | _ ->
                    assert false
              end else try
                let (l', sarg0, sargs, more_sargs) =
                  try
                    let (l', sarg0, sargs1, sargs2) =
                      Btype.extract_label name sargs
                    in (l', sarg0, sargs1 @ sargs2, more_sargs)
                  with Not_found ->
                    let (l', sarg0, sargs1, sargs2) =
                      Btype.extract_label name more_sargs
                    in (l', sarg0, sargs @ sargs1, sargs2)
                in
                if optional = Required && Btype.is_optional l' then
                  Location.prerr_warning sarg0.pexp_loc
                    (Warnings.Nonoptional_label l);
                sargs, more_sargs,
                if optional = Required || Btype.is_optional l' then
                  Some (type_argument val_env sarg0 ty ty0)
                else
                  let ty' = extract_option_type val_env ty
                  and ty0' = extract_option_type val_env ty0 in
                  let arg = type_argument val_env sarg0 ty' ty0' in
                  Some (option_some arg)
              with Not_found ->
                sargs, more_sargs,
                if Btype.is_optional l &&
                  (List.mem_assoc "" sargs || List.mem_assoc "" more_sargs)
                then
                  Some (option_none ty0 Location.none)
                else None
            in
            let omitted = if arg = None then (l,ty0) :: omitted else omitted in
            type_args ((l,arg,optional)::args) omitted ty_fun ty_fun0
              sargs more_sargs
        | _ ->
            match sargs @ more_sargs with
              (l, sarg0)::_ ->
                if omitted <> [] then
                  raise(Error(sarg0.pexp_loc, val_env, Apply_wrong_label l))
                else
                  raise(Error(cl.cl_loc, val_env, Cannot_apply cl.cl_type))
            | [] ->
                (List.rev args,
                 List.fold_left
                   (fun ty_fun (l,ty) -> Cty_arrow(l,ty,ty_fun))
                   ty_fun0 omitted)
      in
      let (args, cty) =
        let (_, ty_fun0) = Ctype.instance_class [] cl.cl_type in
        if ignore_labels then
          type_args [] [] cl.cl_type ty_fun0 [] sargs
        else
          type_args [] [] cl.cl_type ty_fun0 sargs []
      in
      rc {cl_desc = Tcl_apply (cl, args);
          cl_loc = scl.pcl_loc;
          cl_type = cty;
          cl_env = val_env;
          cl_attributes = scl.pcl_attributes;
         }
  | Pcl_let (rec_flag, sdefs, scl') ->
      let (defs, val_env) =
        try
          Typecore.type_let val_env rec_flag sdefs None
        with Ctype.Unify [(ty, _)] ->
          raise(Error(scl.pcl_loc, val_env, Make_nongen_seltype ty))
      in
      let (vals, met_env) =
        List.fold_right
          (fun (id, id_loc) (vals, met_env) ->
             let path = Pident id in
             (* do not mark the value as used *)
             let vd = Env.find_value path val_env in
             Ctype.begin_def ();
             let expr =
               {exp_desc =
                Texp_ident(path, mknoloc(Longident.Lident (Ident.name id)),vd);
                exp_loc = Location.none; exp_extra = [];
                exp_type = Ctype.instance val_env vd.val_type;
                exp_attributes = [];
                exp_env = val_env;
               }
             in
             Ctype.end_def ();
             Ctype.generalize expr.exp_type;
             let desc =
               {val_type = expr.exp_type; val_kind = Val_ivar (Immutable,
                                                               cl_num);
                val_attributes = [];
                Types.val_loc = vd.Types.val_loc;
               }
             in
             let id' = Ident.create (Ident.name id) in
             ((id', id_loc, expr)
              :: vals,
              Env.add_value id' desc met_env))
          (let_bound_idents_with_loc defs)
          ([], met_env)
      in
      let cl = class_expr cl_num val_env met_env scl' in
      rc {cl_desc = Tcl_let (rec_flag, defs, vals, cl);
          cl_loc = scl.pcl_loc;
          cl_type = cl.cl_type;
          cl_env = val_env;
          cl_attributes = scl.pcl_attributes;
         }
  | Pcl_constraint (scl', scty) ->
      Ctype.begin_class_def ();
      let context = Typetexp.narrow () in
      let cl = class_expr cl_num val_env met_env scl' in
      Typetexp.widen context;
      let context = Typetexp.narrow () in
      let clty = class_type val_env scty in
      Typetexp.widen context;
      Ctype.end_def ();

      limited_generalize (Ctype.row_variable (Ctype.self_type cl.cl_type))
          cl.cl_type;
      limited_generalize (Ctype.row_variable (Ctype.self_type clty.cltyp_type))
        clty.cltyp_type;

      begin match
        Includeclass.class_types val_env cl.cl_type clty.cltyp_type
      with
        []    -> ()
      | error -> raise(Error(cl.cl_loc, val_env, Class_match_failure error))
      end;
      let (vals, meths, concrs) = extract_constraints clty.cltyp_type in
      rc {cl_desc = Tcl_constraint (cl, Some clty, vals, meths, concrs);
          cl_loc = scl.pcl_loc;
          cl_type = snd (Ctype.instance_class [] clty.cltyp_type);
          cl_env = val_env;
          cl_attributes = scl.pcl_attributes;
         }
  | Pcl_extension ext ->
      raise (Error_forward (Typetexp.error_of_extension ext))

(*******************************)

(* Approximate the type of the constructor to allow recursive use *)
(* of optional parameters                                         *)

let var_option = Predef.type_option (Btype.newgenvar ())

let rec approx_declaration cl =
  match cl.pcl_desc with
    Pcl_fun (l, _, _, cl) ->
      let arg =
        if Btype.is_optional l then Ctype.instance_def var_option
        else Ctype.newvar () in
      Ctype.newty (Tarrow (l, arg, approx_declaration cl, Cok))
  | Pcl_let (_, _, cl) ->
      approx_declaration cl
  | Pcl_constraint (cl, _) ->
      approx_declaration cl
  | _ -> Ctype.newvar ()

let rec approx_description ct =
  match ct.pcty_desc with
    Pcty_arrow (l, _, ct) ->
      let arg =
        if Btype.is_optional l then Ctype.instance_def var_option
        else Ctype.newvar () in
      Ctype.newty (Tarrow (l, arg, approx_description ct, Cok))
  | _ -> Ctype.newvar ()

(*******************************)

let temp_abbrev loc env id arity =
  let params = ref [] in
  for _i = 1 to arity do
    params := Ctype.newvar () :: !params
  done;
  let ty = Ctype.newobj (Ctype.newvar ()) in
  let env =
    Env.add_type ~check:true id
      {type_params = !params;
       type_arity = arity;
       type_kind = Type_abstract;
       type_private = Public;
       type_manifest = Some ty;
       type_variance = Misc.replicate_list Variance.full arity;
       type_newtype_level = None;
       type_loc = loc;
       type_attributes = []; (* or keep attrs from the class decl? *)
      }
      env
  in
  (!params, ty, env)

let initial_env define_class approx
    (res, env) (cl, id, ty_id, obj_id, cl_id) =
  (* Temporary abbreviations *)
  let arity = List.length cl.pci_params in
  let (obj_params, obj_ty, env) = temp_abbrev cl.pci_loc env obj_id arity in
  let (cl_params, cl_ty, env) = temp_abbrev cl.pci_loc env cl_id arity in

  (* Temporary type for the class constructor *)
  let constr_type = approx cl.pci_expr in
  if !Clflags.principal then Ctype.generalize_spine constr_type;
  let dummy_cty =
    Cty_signature
      { csig_self = Ctype.newvar ();
        csig_vars = Vars.empty;
        csig_concr = Concr.empty;
        csig_inher = [] }
  in
  let dummy_class =
    {Types.cty_params = [];             (* Dummy value *)
     cty_variance = [];
     cty_type = dummy_cty;        (* Dummy value *)
     cty_path = unbound_class;
     cty_new =
       begin match cl.pci_virt with
       | Virtual  -> None
       | Concrete -> Some constr_type
       end;
     cty_loc = Location.none;
     cty_attributes = [];
    }
  in
  let env =
    Env.add_cltype ty_id
      {clty_params = [];            (* Dummy value *)
       clty_variance = [];
       clty_type = dummy_cty;       (* Dummy value *)
       clty_path = unbound_class;
       clty_loc = Location.none;
       clty_attributes = [];
      }
      (
        if define_class then
          Env.add_class id dummy_class env
        else
          env
      )
  in
  ((cl, id, ty_id,
    obj_id, obj_params, obj_ty,
    cl_id, cl_params, cl_ty,
    constr_type, dummy_class)::res,
   env)

let class_infos define_class kind
    (cl, id, ty_id,
     obj_id, obj_params, obj_ty,
     cl_id, cl_params, cl_ty,
     constr_type, dummy_class)
    (res, env) =

  reset_type_variables ();
  Ctype.begin_class_def ();

  (* Introduce class parameters *)
  let ci_params =
    let make_param (sty, v) =
      try
          (transl_type_param env sty, v)
      with Already_bound ->
        raise(Error(sty.ptyp_loc, env, Repeated_parameter))
    in
      List.map make_param cl.pci_params
  in
  let params = List.map (fun (cty, _) -> cty.ctyp_type) ci_params in

  (* Allow self coercions (only for class declarations) *)
  let coercion_locs = ref [] in

  (* Type the class expression *)
  let (expr, typ) =
    try
      Typecore.self_coercion :=
        (Path.Pident obj_id, coercion_locs) :: !Typecore.self_coercion;
      let res = kind env cl.pci_expr in
      Typecore.self_coercion := List.tl !Typecore.self_coercion;
      res
    with exn ->
      Typecore.self_coercion := []; raise exn
  in

  Ctype.end_def ();

  let sty = Ctype.self_type typ in

  (* First generalize the type of the dummy method (cf PR#6123) *)
  let (fields, _) = Ctype.flatten_fields (Ctype.object_fields sty) in
  List.iter (fun (met, _, ty) -> if met = dummy_method then Ctype.generalize ty)
    fields;
  (* Generalize the row variable *)
  let rv = Ctype.row_variable sty in
  List.iter (Ctype.limited_generalize rv) params;
  limited_generalize rv typ;

  (* Check the abbreviation for the object type *)
  let (obj_params', obj_type) = Ctype.instance_class params typ in
  let constr = Ctype.newconstr (Path.Pident obj_id) obj_params in
  begin
    let ty = Ctype.self_type obj_type in
    Ctype.hide_private_methods ty;
    Ctype.close_object ty;
    begin try
      List.iter2 (Ctype.unify env) obj_params obj_params'
    with Ctype.Unify _ ->
      raise(Error(cl.pci_loc, env,
            Bad_parameters (obj_id, constr,
                            Ctype.newconstr (Path.Pident obj_id)
                                            obj_params')))
    end;
    begin try
      Ctype.unify env ty constr
    with Ctype.Unify _ ->
      raise(Error(cl.pci_loc, env,
        Abbrev_type_clash (constr, ty, Ctype.expand_head env constr)))
    end
  end;

  (* Check the other temporary abbreviation (#-type) *)
  begin
    let (cl_params', cl_type) = Ctype.instance_class params typ in
    let ty = Ctype.self_type cl_type in
    Ctype.hide_private_methods ty;
    Ctype.set_object_name obj_id (Ctype.row_variable ty) cl_params ty;
    begin try
      List.iter2 (Ctype.unify env) cl_params cl_params'
    with Ctype.Unify _ ->
      raise(Error(cl.pci_loc, env,
            Bad_parameters (cl_id,
                            Ctype.newconstr (Path.Pident cl_id)
                                            cl_params,
                            Ctype.newconstr (Path.Pident cl_id)
                                            cl_params')))
    end;
    begin try
      Ctype.unify env ty cl_ty
    with Ctype.Unify _ ->
      let constr = Ctype.newconstr (Path.Pident cl_id) params in
      raise(Error(cl.pci_loc, env, Abbrev_type_clash (constr, ty, cl_ty)))
    end
  end;

  (* Type of the class constructor *)
  begin try
    Ctype.unify env
      (constructor_type constr obj_type)
      (Ctype.instance env constr_type)
  with Ctype.Unify trace ->
    raise(Error(cl.pci_loc, env,
                Constructor_type_mismatch (cl.pci_name.txt, trace)))
  end;

  (* Class and class type temporary definitions *)
  let cty_variance = List.map (fun _ -> Variance.full) params in
  let cltydef =
    {clty_params = params; clty_type = class_body typ;
     clty_variance = cty_variance;
     clty_path = Path.Pident obj_id;
     clty_loc = cl.pci_loc;
     clty_attributes = cl.pci_attributes;
    }
  and clty =
    {cty_params = params; cty_type = typ;
     cty_variance = cty_variance;
     cty_path = Path.Pident obj_id;
     cty_new =
       begin match cl.pci_virt with
       | Virtual  -> None
       | Concrete -> Some constr_type
       end;
     cty_loc = cl.pci_loc;
     cty_attributes = cl.pci_attributes;
    }
  in
  dummy_class.cty_type <- typ;
  let env =
    Env.add_cltype ty_id cltydef (
    if define_class then Env.add_class id clty env else env)
  in

  if cl.pci_virt = Concrete then begin
    let sign = Ctype.signature_of_class_type typ in
    let mets = virtual_methods sign in
    let vals =
      Vars.fold
        (fun name (mut, vr, ty) l -> if vr = Virtual then name :: l else l)
        sign.csig_vars [] in
    if mets <> []  || vals <> [] then
      raise(Error(cl.pci_loc, env, Virtual_class(define_class, false, mets, vals)));
  end;

  (* Misc. *)
  let arity = Ctype.class_type_arity typ in
  let pub_meths =
    let (fields, _) =
      Ctype.flatten_fields (Ctype.object_fields (Ctype.expand_head env obj_ty))
    in
    List.map (function (lab, _, _) -> lab) fields
  in

  (* Final definitions *)
  let (params', typ') = Ctype.instance_class params typ in
  let cltydef =
    {clty_params = params'; clty_type = class_body typ';
     clty_variance = cty_variance;
     clty_path = Path.Pident obj_id;
     clty_loc = cl.pci_loc;
     clty_attributes = cl.pci_attributes;
    }
  and clty =
    {cty_params = params'; cty_type = typ';
     cty_variance = cty_variance;
     cty_path = Path.Pident obj_id;
     cty_new =
       begin match cl.pci_virt with
       | Virtual  -> None
       | Concrete -> Some (Ctype.instance env constr_type)
       end;
     cty_loc = cl.pci_loc;
     cty_attributes = cl.pci_attributes;
    }
  in
  let obj_abbr =
    {type_params = obj_params;
     type_arity = List.length obj_params;
     type_kind = Type_abstract;
     type_private = Public;
     type_manifest = Some obj_ty;
     type_variance = List.map (fun _ -> Variance.full) obj_params;
     type_newtype_level = None;
     type_loc = cl.pci_loc;
     type_attributes = []; (* or keep attrs from cl? *)
    }
  in
  let (cl_params, cl_ty) =
    Ctype.instance_parameterized_type params (Ctype.self_type typ)
  in
  Ctype.hide_private_methods cl_ty;
  Ctype.set_object_name obj_id (Ctype.row_variable cl_ty) cl_params cl_ty;
  let cl_abbr =
    {type_params = cl_params;
     type_arity = List.length cl_params;
     type_kind = Type_abstract;
     type_private = Public;
     type_manifest = Some cl_ty;
     type_variance = List.map (fun _ -> Variance.full) cl_params;
     type_newtype_level = None;
     type_loc = cl.pci_loc;
     type_attributes = []; (* or keep attrs from cl? *)
    }
  in
  ((cl, id, clty, ty_id, cltydef, obj_id, obj_abbr, cl_id, cl_abbr, ci_params,
    arity, pub_meths, List.rev !coercion_locs, expr) :: res,
   env)

let final_decl env define_class
    (cl, id, clty, ty_id, cltydef, obj_id, obj_abbr, cl_id, cl_abbr, ci_params,
     arity, pub_meths, coe, expr) =

  begin try Ctype.collapse_conj_params env clty.cty_params
  with Ctype.Unify trace ->
    raise(Error(cl.pci_loc, env, Non_collapsable_conjunction (id, clty, trace)))
  end;

  List.iter Ctype.generalize clty.cty_params;
  generalize_class_type true clty.cty_type;
  Misc.may  Ctype.generalize clty.cty_new;
  List.iter Ctype.generalize obj_abbr.type_params;
  Misc.may  Ctype.generalize obj_abbr.type_manifest;
  List.iter Ctype.generalize cl_abbr.type_params;
  Misc.may  Ctype.generalize cl_abbr.type_manifest;

  if not (closed_class clty) then
    raise(Error(cl.pci_loc, env, Non_generalizable_class (id, clty)));

  begin match
    Ctype.closed_class clty.cty_params
      (Ctype.signature_of_class_type clty.cty_type)
  with
    None        -> ()
  | Some reason ->
      let printer =
        if define_class
        then function ppf -> Printtyp.class_declaration id ppf clty
        else function ppf -> Printtyp.cltype_declaration id ppf cltydef
      in
      raise(Error(cl.pci_loc, env, Unbound_type_var(printer, reason)))
  end;

  (id, cl.pci_name, clty, ty_id, cltydef, obj_id, obj_abbr, cl_id, cl_abbr,
   arity, pub_meths, coe, expr,
   { ci_loc = cl.pci_loc;
     ci_virt = cl.pci_virt;
     ci_params = ci_params;
(* TODO : check that we have the correct use of identifiers *)
     ci_id_name = cl.pci_name;
     ci_id_class = id;
     ci_id_class_type = ty_id;
     ci_id_object = obj_id;
     ci_id_typesharp = cl_id;
     ci_expr = expr;
     ci_decl = clty;
     ci_type_decl = cltydef;
     ci_attributes = cl.pci_attributes;
 })
(*   (cl.pci_variance, cl.pci_loc)) *)

let extract_type_decls
    (id, id_loc, clty, ty_id, cltydef, obj_id, obj_abbr, cl_id, cl_abbr,
     arity, pub_meths, coe, expr, required) decls =
  (obj_id, obj_abbr, cl_abbr, clty, cltydef, required) :: decls

let merge_type_decls
    (id, id_loc, _clty, ty_id, _cltydef, obj_id, _obj_abbr, cl_id, _cl_abbr,
     arity, pub_meths, coe, expr, req) (obj_abbr, cl_abbr, clty, cltydef) =
  (id, id_loc, clty, ty_id, cltydef, obj_id, obj_abbr, cl_id, cl_abbr,
   arity, pub_meths, coe, expr, req)

let final_env define_class env
    (id, id_loc, clty, ty_id, cltydef, obj_id, obj_abbr, cl_id, cl_abbr,
     arity, pub_meths, coe, expr, req) =
  (* Add definitions after cleaning them *)
  Env.add_type ~check:true obj_id
    (Subst.type_declaration Subst.identity obj_abbr) (
  Env.add_type ~check:true cl_id
    (Subst.type_declaration Subst.identity cl_abbr) (
  Env.add_cltype ty_id (Subst.cltype_declaration Subst.identity cltydef) (
  if define_class then
    Env.add_class id (Subst.class_declaration Subst.identity clty) env
  else env)))

(* Check that #c is coercible to c if there is a self-coercion *)
let check_coercions env
    (id, id_loc, clty, ty_id, cltydef, obj_id, obj_abbr, cl_id, cl_abbr,
     arity, pub_meths, coercion_locs, expr, req) =
  begin match coercion_locs with [] -> ()
  | loc :: _ ->
      let cl_ty, obj_ty =
        match cl_abbr.type_manifest, obj_abbr.type_manifest with
          Some cl_ab, Some obj_ab ->
            let cl_params, cl_ty =
              Ctype.instance_parameterized_type cl_abbr.type_params cl_ab
            and obj_params, obj_ty =
              Ctype.instance_parameterized_type obj_abbr.type_params obj_ab
            in
            List.iter2 (Ctype.unify env) cl_params obj_params;
            cl_ty, obj_ty
        | _ -> assert false
      in
      begin try Ctype.subtype env cl_ty obj_ty ()
      with Ctype.Subtype (tr1, tr2) ->
        raise(Typecore.Error(loc, env, Typecore.Not_subtype(tr1, tr2)))
      end;
      if not (Ctype.opened_object cl_ty) then
        raise(Error(loc, env, Cannot_coerce_self obj_ty))
  end;
  (id, id_loc, clty, ty_id, cltydef, obj_id, obj_abbr, cl_id, cl_abbr,
   arity, pub_meths, req)

(*******************************)

let type_classes define_class approx kind env cls =
  let cls =
    List.map
      (function cl ->
         (cl,
          Ident.create cl.pci_name.txt, Ident.create cl.pci_name.txt,
          Ident.create cl.pci_name.txt, Ident.create ("#" ^ cl.pci_name.txt)))
      cls
  in
  Ctype.init_def (Ident.current_time ());
  Ctype.begin_class_def ();
  let (res, env) =
    List.fold_left (initial_env define_class approx) ([], env) cls
  in
  let (res, env) =
    List.fold_right (class_infos define_class kind) res ([], env)
  in
  Ctype.end_def ();
  let res = List.rev_map (final_decl env define_class) res in
  let decls = List.fold_right extract_type_decls res [] in
  let decls = Typedecl.compute_variance_decls env decls in
  let res = List.map2 merge_type_decls res decls in
  let env = List.fold_left (final_env define_class) env res in
  let res = List.map (check_coercions env) res in
  (res, env)

let class_num = ref 0
let class_declaration env sexpr =
  incr class_num;
  let expr = class_expr (string_of_int !class_num) env env sexpr in
  (expr, expr.cl_type)

let class_description env sexpr =
  let expr = class_type env sexpr in
  (expr, expr.cltyp_type)

let class_declarations env cls =
  type_classes true approx_declaration class_declaration env cls

let class_descriptions env cls =
  type_classes true approx_description class_description env cls

let class_type_declarations env cls =
  let (decl, env) =
    type_classes false approx_description class_description env cls
  in
  (List.map
     (function
       (_, id_loc, _, ty_id, cltydef, obj_id, obj_abbr, cl_id, cl_abbr,
        _, _, ci) ->
       (ty_id, id_loc, cltydef, obj_id, obj_abbr, cl_id, cl_abbr, ci))
     decl,
   env)

let rec unify_parents env ty cl =
  match cl.cl_desc with
    Tcl_ident (p, _, _) ->
      begin try
        let decl = Env.find_class p env in
        let _, body = Ctype.find_cltype_for_path env decl.cty_path in
        Ctype.unify env ty (Ctype.instance env body)
      with
        Not_found -> ()
      | exn -> assert false
      end
  | Tcl_structure st -> unify_parents_struct env ty st
  | Tcl_fun (_, _, _, cl, _)
  | Tcl_apply (cl, _)
  | Tcl_let (_, _, _, cl)
  | Tcl_constraint (cl, _, _, _, _) -> unify_parents env ty cl
and unify_parents_struct env ty st =
  List.iter
    (function {cf_desc = Tcf_inherit (_, cl, _, _, _)} -> unify_parents env ty cl
      | _ -> ())
    st.cstr_fields

let type_object env loc s =
  incr class_num;
  let (desc, sign) =
    class_structure (string_of_int !class_num) true env env loc s in
  let sty = Ctype.expand_head env sign.csig_self in
  Ctype.hide_private_methods sty;
  let (fields, _) = Ctype.flatten_fields (Ctype.object_fields sty) in
  let meths = List.map (fun (s,_,_) -> s) fields in
  unify_parents_struct env sign.csig_self desc;
  (desc, sign, meths)

let () =
  Typecore.type_object := type_object

(*******************************)

(* Approximate the class declaration as class ['params] id = object end *)
let approx_class sdecl =
  let open Ast_helper in
  let self' = Typ.any () in
  let clty' = Cty.signature ~loc:sdecl.pci_expr.pcty_loc (Csig.mk self' []) in
  { sdecl with pci_expr = clty' }

let approx_class_declarations env sdecls =
  fst (class_type_declarations env (List.map approx_class sdecls))

(*******************************)

(* Error report *)

open Format

let report_error env ppf = function
  | Repeated_parameter ->
      fprintf ppf "A type parameter occurs several times"
  | Unconsistent_constraint trace ->
      fprintf ppf "The class constraints are not consistent.@.";
      Printtyp.report_unification_error ppf env trace
        (fun ppf -> fprintf ppf "Type")
        (fun ppf -> fprintf ppf "is not compatible with type")
  | Field_type_mismatch (k, m, trace) ->
      Printtyp.report_unification_error ppf env trace
        (function ppf ->
           fprintf ppf "The %s %s@ has type" k m)
        (function ppf ->
           fprintf ppf "but is expected to have type")
  | Structure_expected clty ->
      fprintf ppf
        "@[This class expression is not a class structure; it has type@ %a@]"
        Printtyp.class_type clty
  | Cannot_apply clty ->
      fprintf ppf
        "This class expression is not a class function, it cannot be applied"
  | Apply_wrong_label l ->
      let mark_label = function
        | "" -> "out label"
        |  l -> sprintf " label ~%s" l in
      fprintf ppf "This argument cannot be applied with%s" (mark_label l)
  | Pattern_type_clash ty ->
      (* XXX Trace *)
      (* XXX Revoir message d'erreur *)
      Printtyp.reset_and_mark_loops ty;
      fprintf ppf "@[%s@ %a@]"
        "This pattern cannot match self: it only matches values of type"
        Printtyp.type_expr ty
  | Unbound_class_2 cl ->
      fprintf ppf "@[The class@ %a@ is not yet completely defined@]"
      Printtyp.longident cl
  | Unbound_class_type_2 cl ->
      fprintf ppf "@[The class type@ %a@ is not yet completely defined@]"
      Printtyp.longident cl
  | Abbrev_type_clash (abbrev, actual, expected) ->
      (* XXX Afficher une trace ? *)
      Printtyp.reset_and_mark_loops_list [abbrev; actual; expected];
      fprintf ppf "@[The abbreviation@ %a@ expands to type@ %a@ \
       but is used with type@ %a@]"
       Printtyp.type_expr abbrev
       Printtyp.type_expr actual
       Printtyp.type_expr expected
  | Constructor_type_mismatch (c, trace) ->
      Printtyp.report_unification_error ppf env trace
        (function ppf ->
           fprintf ppf "The expression \"new %s\" has type" c)
        (function ppf ->
           fprintf ppf "but is used with type")
  | Virtual_class (cl, imm, mets, vals) ->
      let print_mets ppf mets =
        List.iter (function met -> fprintf ppf "@ %s" met) mets in
      let missings =
        match mets, vals with
          [], _ -> "variables"
        | _, [] -> "methods"
        | _ -> "methods and variables"
      in
      let print_msg ppf =
        if imm then fprintf ppf "This object has virtual %s" missings
        else if cl then fprintf ppf "This class should be virtual"
        else fprintf ppf "This class type should be virtual"
      in
      fprintf ppf
        "@[%t.@ @[<2>The following %s are undefined :%a@]@]"
        print_msg missings print_mets (mets @ vals)
  | Parameter_arity_mismatch(lid, expected, provided) ->
      fprintf ppf
        "@[The class constructor %a@ expects %i type argument(s),@ \
           but is here applied to %i type argument(s)@]"
        Printtyp.longident lid expected provided
  | Parameter_mismatch trace ->
      Printtyp.report_unification_error ppf env trace
        (function ppf ->
           fprintf ppf "The type parameter")
        (function ppf ->
           fprintf ppf "does not meet its constraint: it should be")
  | Bad_parameters (id, params, cstrs) ->
      Printtyp.reset_and_mark_loops_list [params; cstrs];
      fprintf ppf
        "@[The abbreviation %a@ is used with parameters@ %a@ \
           wich are incompatible with constraints@ %a@]"
        Printtyp.ident id Printtyp.type_expr params Printtyp.type_expr cstrs
  | Class_match_failure error ->
      Includeclass.report_error ppf error
  | Unbound_val lab ->
      fprintf ppf "Unbound instance variable %s" lab
  | Unbound_type_var (printer, reason) ->
      let print_common ppf kind ty0 real lab ty =
        let ty1 =
          if real then ty0 else Btype.newgenty(Tobject(ty0, ref None)) in
        Printtyp.mark_loops ty1;
        fprintf ppf
          "The %s %s@ has type@;<1 2>%a@ where@ %a@ is unbound"
            kind lab Printtyp.type_expr ty Printtyp.type_expr ty0
      in
      let print_reason ppf = function
      | Ctype.CC_Method (ty0, real, lab, ty) ->
          print_common ppf "method" ty0 real lab ty
      | Ctype.CC_Value (ty0, real, lab, ty) ->
          print_common ppf "instance variable" ty0 real lab ty
      in
      Printtyp.reset ();
      fprintf ppf
        "@[<v>@[Some type variables are unbound in this type:@;<1 2>%t@]@ \
              @[%a@]@]"
       printer print_reason reason
  | Make_nongen_seltype ty ->
      fprintf ppf
        "@[<v>@[Self type should not occur in the non-generic type@;<1 2>\
                %a@]@,\
           It would escape the scope of its class@]"
        Printtyp.type_scheme ty
  | Non_generalizable_class (id, clty) ->
      fprintf ppf
        "@[The type of this class,@ %a,@ \
           contains type variables that cannot be generalized@]"
        (Printtyp.class_declaration id) clty
  | Cannot_coerce_self ty ->
      fprintf ppf
        "@[The type of self cannot be coerced to@ \
           the type of the current class:@ %a.@.\
           Some occurrences are contravariant@]"
        Printtyp.type_scheme ty
  | Non_collapsable_conjunction (id, clty, trace) ->
      fprintf ppf
        "@[The type of this class,@ %a,@ \
           contains non-collapsible conjunctive types in constraints@]"
        (Printtyp.class_declaration id) clty;
      Printtyp.report_unification_error ppf env trace
        (fun ppf -> fprintf ppf "Type")
        (fun ppf -> fprintf ppf "is not compatible with type")
  | Final_self_clash trace ->
      Printtyp.report_unification_error ppf env trace
        (function ppf ->
           fprintf ppf "This object is expected to have type")
        (function ppf ->
           fprintf ppf "but actually has type")
  | Mutability_mismatch (lab, mut) ->
      let mut1, mut2 =
        if mut = Immutable then "mutable", "immutable"
        else "immutable", "mutable" in
      fprintf ppf
        "@[The instance variable is %s;@ it cannot be redefined as %s@]"
        mut1 mut2
  | No_overriding (_, "") ->
      fprintf ppf "@[This inheritance does not override any method@ %s@]"
        "instance variable"
  | No_overriding (kind, name) ->
      fprintf ppf "@[The %s `%s'@ has no previous definition@]" kind name
  | Duplicate (kind, name) ->
      fprintf ppf "@[The %s `%s'@ has multiple definitions in this object@]"
                    kind name

let report_error env ppf err =
  Printtyp.wrap_printing_env env (fun () -> report_error env ppf err)

let () =
  Location.register_error_of_exn
    (function
      | Error (loc, env, err) ->
        Some (Location.error_of_printer loc (report_error env) err)
      | Error_forward err ->
        Some err
      | _ ->
        None
    )

end
module Typemod : sig
(*#1 "typemod.mli"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Type-checking of the module language *)

open Types
open Format

val type_module:
        Env.t -> Parsetree.module_expr -> Typedtree.module_expr
val type_structure:
        Env.t -> Parsetree.structure -> Location.t ->
         Typedtree.structure * Types.signature * Env.t
val type_toplevel_phrase:
        Env.t -> Parsetree.structure ->
         Typedtree.structure * Types.signature * Env.t
val type_implementation_more:
  string -> string -> string -> Env.t -> Parsetree.structure ->
  Typedtree.structure * Typedtree.module_coercion * Env.t * Types.signature

val type_implementation:
  string -> string -> string -> Env.t -> Parsetree.structure ->
  Typedtree.structure * Typedtree.module_coercion

val type_interface:
        Env.t -> Parsetree.signature -> Typedtree.signature
val transl_signature:
        Env.t -> Parsetree.signature -> Typedtree.signature
val check_nongen_schemes:
        Env.t -> Typedtree.structure_item list -> unit
val type_open_:
        ?toplevel:bool -> Asttypes.override_flag ->
        Env.t -> Location.t -> Longident.t Asttypes.loc -> Path.t * Env.t
val modtype_of_package:
        Env.t -> Location.t ->
        Path.t -> Longident.t list -> type_expr list -> module_type
val simplify_signature: signature -> signature

val path_of_module : Typedtree.module_expr -> Path.t option

val save_signature:
  string -> Typedtree.signature -> string -> string ->
  Env.t -> Types.signature_item list -> unit

val package_units:
  Env.t -> string list -> string -> string -> Typedtree.module_coercion

type error =
    Cannot_apply of module_type
  | Not_included of Includemod.error list
  | Cannot_eliminate_dependency of module_type
  | Signature_expected
  | Structure_expected of module_type
  | With_no_component of Longident.t
  | With_mismatch of Longident.t * Includemod.error list
  | Repeated_name of string * string
  | Non_generalizable of type_expr
  | Non_generalizable_class of Ident.t * class_declaration
  | Non_generalizable_module of module_type
  | Implementation_is_required of string
  | Interface_not_compiled of string
  | Not_allowed_in_functor_body
  | With_need_typeconstr
  | Not_a_packed_module of type_expr
  | Incomplete_packed_module of type_expr
  | Scoping_pack of Longident.t * type_expr
  | Recursive_module_require_explicit_type
  | Apply_generative

exception Error of Location.t * Env.t * error
exception Error_forward of Location.error

val report_error: Env.t -> formatter -> error -> unit

end = struct
(*#1 "typemod.ml"*)
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Misc
open Longident
open Path
open Asttypes
open Parsetree
open Types
open Format

type error =
    Cannot_apply of module_type
  | Not_included of Includemod.error list
  | Cannot_eliminate_dependency of module_type
  | Signature_expected
  | Structure_expected of module_type
  | With_no_component of Longident.t
  | With_mismatch of Longident.t * Includemod.error list
  | Repeated_name of string * string
  | Non_generalizable of type_expr
  | Non_generalizable_class of Ident.t * class_declaration
  | Non_generalizable_module of module_type
  | Implementation_is_required of string
  | Interface_not_compiled of string
  | Not_allowed_in_functor_body
  | With_need_typeconstr
  | Not_a_packed_module of type_expr
  | Incomplete_packed_module of type_expr
  | Scoping_pack of Longident.t * type_expr
  | Recursive_module_require_explicit_type
  | Apply_generative

exception Error of Location.t * Env.t * error
exception Error_forward of Location.error

open Typedtree

let fst3 (x,_,_) = x

let rec path_concat head p =
  match p with
    Pident tail -> Pdot (Pident head, Ident.name tail, 0)
  | Pdot (pre, s, pos) -> Pdot (path_concat head pre, s, pos)
  | Papply _ -> assert false

(* Extract a signature from a module type *)

let extract_sig env loc mty =
  match Env.scrape_alias env mty with
    Mty_signature sg -> sg
  | _ -> raise(Error(loc, env, Signature_expected))

let extract_sig_open env loc mty =
  match Env.scrape_alias env mty with
    Mty_signature sg -> sg
  | _ -> raise(Error(loc, env, Structure_expected mty))

(* Compute the environment after opening a module *)

let type_open_ ?toplevel ovf env loc lid =
  let path, md = Typetexp.find_module env lid.loc lid.txt in
  let sg = extract_sig_open env lid.loc md.md_type in
  path, Env.open_signature ~loc ?toplevel ovf path sg env

let type_open ?toplevel env sod =
  let (path, newenv) =
    type_open_ ?toplevel sod.popen_override env sod.popen_loc sod.popen_lid
  in
  let od =
    {
      open_override = sod.popen_override;
      open_path = path;
      open_txt = sod.popen_lid;
      open_attributes = sod.popen_attributes;
      open_loc = sod.popen_loc;
    }
  in
  (path, newenv, od)

(* Record a module type *)
let rm node =
  Stypes.record (Stypes.Ti_mod node);
  node

(* Forward declaration, to be filled in by type_module_type_of *)
let type_module_type_of_fwd :
    (Env.t -> Parsetree.module_expr ->
      Typedtree.module_expr * Types.module_type) ref
  = ref (fun env m -> assert false)

(* Merge one "with" constraint in a signature *)

let rec add_rec_types env = function
    Sig_type(id, decl, Trec_next) :: rem ->
      add_rec_types (Env.add_type ~check:true id decl env) rem
  | _ -> env

let check_type_decl env loc id row_id newdecl decl rs rem =
  let env = Env.add_type ~check:true id newdecl env in
  let env =
    match row_id with
    | None -> env
    | Some id -> Env.add_type ~check:true id newdecl env
  in
  let env = if rs = Trec_not then env else add_rec_types env rem in
  Includemod.type_declarations env id newdecl decl;
  Typedecl.check_coherence env loc id newdecl

let rec make_params n = function
    [] -> []
  | _ :: l -> ("a" ^ string_of_int n) :: make_params (n+1) l

let update_rec_next rs rem =
  match rs with
    Trec_next -> rem
  | Trec_first | Trec_not ->
      match rem with
        Sig_type (id, decl, Trec_next) :: rem ->
          Sig_type (id, decl, rs) :: rem
      | Sig_module (id, mty, Trec_next) :: rem ->
          Sig_module (id, mty, rs) :: rem
      | _ -> rem

let sig_item desc typ env loc = {
  Typedtree.sig_desc = desc; sig_loc = loc; sig_env = env
}

let make p n i =
  let open Variance in
  set May_pos p (set May_neg n (set May_weak n (set Inj i null)))

let merge_constraint initial_env loc sg constr =
  let lid =
    match constr with
    | Pwith_type (lid, _) | Pwith_module (lid, _) -> lid
    | Pwith_typesubst {ptype_name=s} | Pwith_modsubst (s, _) ->
        {loc = s.loc; txt=Lident s.txt}
  in
  let real_id = ref None in
  let rec merge env sg namelist row_id =
    match (sg, namelist, constr) with
      ([], _, _) ->
        raise(Error(loc, env, With_no_component lid.txt))
    | (Sig_type(id, decl, rs) :: rem, [s],
       Pwith_type (_, ({ptype_kind = Ptype_abstract} as sdecl)))
      when Ident.name id = s && Typedecl.is_fixed_type sdecl ->
        let decl_row =
          { type_params =
              List.map (fun _ -> Btype.newgenvar()) sdecl.ptype_params;
            type_arity = List.length sdecl.ptype_params;
            type_kind = Type_abstract;
            type_private = Private;
            type_manifest = None;
            type_variance =
              List.map
                (fun (_, v) ->
                   let (c, n) =
                     match v with
                     | Covariant -> true, false
                     | Contravariant -> false, true
                     | Invariant -> false, false
                   in
                   make (not n) (not c) false
                )
                sdecl.ptype_params;
            type_loc = sdecl.ptype_loc;
            type_newtype_level = None;
            type_attributes = [];
          }
        and id_row = Ident.create (s^"#row") in
        let initial_env =
          Env.add_type ~check:true id_row decl_row initial_env
        in
        let tdecl = Typedecl.transl_with_constraint
                        initial_env id (Some(Pident id_row)) decl sdecl in
        let newdecl = tdecl.typ_type in
        check_type_decl env sdecl.ptype_loc id row_id newdecl decl rs rem;
        let decl_row = {decl_row with type_params = newdecl.type_params} in
        let rs' = if rs = Trec_first then Trec_not else rs in
        (Pident id, lid, Twith_type tdecl),
        Sig_type(id_row, decl_row, rs') :: Sig_type(id, newdecl, rs) :: rem
    | (Sig_type(id, decl, rs) :: rem , [s], Pwith_type (_, sdecl))
      when Ident.name id = s ->
        let tdecl =
          Typedecl.transl_with_constraint initial_env id None decl sdecl in
        let newdecl = tdecl.typ_type in
        check_type_decl env sdecl.ptype_loc id row_id newdecl decl rs rem;
        (Pident id, lid, Twith_type tdecl), Sig_type(id, newdecl, rs) :: rem
    | (Sig_type(id, decl, rs) :: rem, [s], (Pwith_type _ | Pwith_typesubst _))
      when Ident.name id = s ^ "#row" ->
        merge env rem namelist (Some id)
    | (Sig_type(id, decl, rs) :: rem, [s], Pwith_typesubst sdecl)
      when Ident.name id = s ->
        (* Check as for a normal with constraint, but discard definition *)
        let tdecl =
          Typedecl.transl_with_constraint initial_env id None decl sdecl in
        let newdecl = tdecl.typ_type in
        check_type_decl env sdecl.ptype_loc id row_id newdecl decl rs rem;
        real_id := Some id;
        (Pident id, lid, Twith_typesubst tdecl),
        update_rec_next rs rem
    | (Sig_module(id, md, rs) :: rem, [s], Pwith_module (_, lid'))
      when Ident.name id = s ->
        let path, md' = Typetexp.find_module initial_env loc lid'.txt in
        let md'' = {md' with md_type = Mtype.remove_aliases env md'.md_type} in
        let newmd = Mtype.strengthen_decl env md'' path in
        ignore(Includemod.modtypes env newmd.md_type md.md_type);
        (Pident id, lid, Twith_module (path, lid')),
        Sig_module(id, newmd, rs) :: rem
    | (Sig_module(id, md, rs) :: rem, [s], Pwith_modsubst (_, lid'))
      when Ident.name id = s ->
        let path, md' = Typetexp.find_module initial_env loc lid'.txt in
        let newmd = Mtype.strengthen_decl env md' path in
        ignore(Includemod.modtypes env newmd.md_type md.md_type);
        real_id := Some id;
        (Pident id, lid, Twith_modsubst (path, lid')),
        update_rec_next rs rem
    | (Sig_module(id, md, rs) :: rem, s :: namelist, _)
      when Ident.name id = s ->
        let ((path, path_loc, tcstr), newsg) =
          merge env (extract_sig env loc md.md_type) namelist None in
        (path_concat id path, lid, tcstr),
        Sig_module(id, {md with md_type=Mty_signature newsg}, rs) :: rem
    | (item :: rem, _, _) ->
        let (cstr, items) = merge (Env.add_item item env) rem namelist row_id
        in
        cstr, item :: items
  in
  try
    let names = Longident.flatten lid.txt in
    let (tcstr, sg) = merge initial_env sg names None in
    let sg =
    match names, constr with
      [s], Pwith_typesubst sdecl ->
        let id =
          match !real_id with None -> assert false | Some id -> id in
        let lid =
          try match sdecl.ptype_manifest with
          | Some {ptyp_desc = Ptyp_constr (lid, stl)}
            when List.length stl = List.length sdecl.ptype_params ->
              List.iter2 (fun x (y, _) ->
                match x, y with
                  {ptyp_desc=Ptyp_var sx}, {ptyp_desc=Ptyp_var sy}
                    when sx = sy -> ()
                | _, _ -> raise Exit)
                stl sdecl.ptype_params;
              lid
          | _ -> raise Exit
          with Exit ->
            raise(Error(sdecl.ptype_loc, initial_env, With_need_typeconstr))
        in
        let (path, _) =
          try Env.lookup_type lid.txt initial_env with Not_found -> assert false
        in
        let sub = Subst.add_type id path Subst.identity in
        Subst.signature sub sg
    | [s], Pwith_modsubst (_, lid) ->
        let id =
          match !real_id with None -> assert false | Some id -> id in
        let path = Typetexp.lookup_module initial_env loc lid.txt in
        let sub = Subst.add_module id path Subst.identity in
        Subst.signature sub sg
    | _ ->
          sg
    in
    (tcstr, sg)
  with Includemod.Error explanation ->
    raise(Error(loc, initial_env, With_mismatch(lid.txt, explanation)))

(* Add recursion flags on declarations arising from a mutually recursive
   block. *)

let map_rec fn decls rem =
  match decls with
  | [] -> rem
  | d1 :: dl -> fn Trec_first d1 :: map_end (fn Trec_next) dl rem

let map_rec_type ~rec_flag fn decls rem =
  match decls with
  | [] -> rem
  | d1 :: dl ->
      let first =
        match rec_flag with
        | Recursive -> Trec_first
        | Nonrecursive -> Trec_not
      in
      fn first d1 :: map_end (fn Trec_next) dl rem

let rec map_rec_type_with_row_types ~rec_flag fn decls rem =
  match decls with
  | [] -> rem
  | d1 :: dl ->
      if Btype.is_row_name (Ident.name d1.typ_id) then
        fn Trec_not d1 :: map_rec_type_with_row_types ~rec_flag fn dl rem
      else
        map_rec_type ~rec_flag fn decls rem

let rec_flag_of_ptype_declarations tds =
  let is_nonrec =
    List.exists
      (fun td ->
         List.exists (fun (n, _) -> n.txt = "nonrec")
           td.ptype_attributes)
      tds
  in
  if is_nonrec then Nonrecursive else Recursive

(* Add type extension flags to extension contructors *)
let map_ext fn exts rem =
  match exts with
  | [] -> rem
  | d1 :: dl -> fn Text_first d1 :: map_end (fn Text_next) dl rem

(* Auxiliary for translating recursively-defined module types.
   Return a module type that approximates the shape of the given module
   type AST.  Retain only module, type, and module type
   components of signatures.  For types, retain only their arity,
   making them abstract otherwise. *)

let rec approx_modtype env smty =
  match smty.pmty_desc with
    Pmty_ident lid ->
      let (path, info) = Typetexp.find_modtype env smty.pmty_loc lid.txt in
      Mty_ident path
  | Pmty_alias lid ->
      let path = Typetexp.lookup_module env smty.pmty_loc lid.txt in
      Mty_alias path
  | Pmty_signature ssg ->
      Mty_signature(approx_sig env ssg)
  | Pmty_functor(param, sarg, sres) ->
      let arg = may_map (approx_modtype env) sarg in
      let (id, newenv) =
        Env.enter_module ~arg:true param.txt (Btype.default_mty arg) env in
      let res = approx_modtype newenv sres in
      Mty_functor(id, arg, res)
  | Pmty_with(sbody, constraints) ->
      approx_modtype env sbody
  | Pmty_typeof smod ->
      let (_, mty) = !type_module_type_of_fwd env smod in
      mty
  | Pmty_extension ext ->
      raise (Error_forward (Typetexp.error_of_extension ext))

and approx_module_declaration env pmd =
  {
    Types.md_type = approx_modtype env pmd.pmd_type;
    md_attributes = pmd.pmd_attributes;
    md_loc = pmd.pmd_loc;
  }

and approx_sig env ssg =
  match ssg with
    [] -> []
  | item :: srem ->
      match item.psig_desc with
      | Psig_type sdecls ->
          let rec_flag = rec_flag_of_ptype_declarations sdecls in
          let decls = Typedecl.approx_type_decl env sdecls in
          let rem = approx_sig env srem in
          map_rec_type ~rec_flag
            (fun rs (id, info) -> Sig_type(id, info, rs)) decls rem
      | Psig_module pmd ->
          let md = approx_module_declaration env pmd in
          let (id, newenv) =
            Env.enter_module_declaration pmd.pmd_name.txt md env
          in
          Sig_module(id, md, Trec_not) :: approx_sig newenv srem
      | Psig_recmodule sdecls ->
          let decls =
            List.map
              (fun pmd ->
                 (Ident.create pmd.pmd_name.txt,
                  approx_module_declaration env pmd)
              )
              sdecls
          in
          let newenv =
            List.fold_left
              (fun env (id, md) -> Env.add_module_declaration id md env)
              env decls in
          map_rec (fun rs (id, md) -> Sig_module(id, md, rs)) decls
                  (approx_sig newenv srem)
      | Psig_modtype d ->
          let info = approx_modtype_info env d in
          let (id, newenv) = Env.enter_modtype d.pmtd_name.txt info env in
          Sig_modtype(id, info) :: approx_sig newenv srem
      | Psig_open sod ->
          let (path, mty, _od) = type_open env sod in
          approx_sig mty srem
      | Psig_include sincl ->
          let smty = sincl.pincl_mod in
          let mty = approx_modtype env smty in
          let sg = Subst.signature Subst.identity
                     (extract_sig env smty.pmty_loc mty) in
          let newenv = Env.add_signature sg env in
          sg @ approx_sig newenv srem
      | Psig_class sdecls | Psig_class_type sdecls ->
          let decls = Typeclass.approx_class_declarations env sdecls in
          let rem = approx_sig env srem in
          List.flatten
            (map_rec
              (fun rs (i1, _, d1, i2, d2, i3, d3, _) ->
                [Sig_class_type(i1, d1, rs);
                 Sig_type(i2, d2, rs);
                 Sig_type(i3, d3, rs)])
              decls [rem])
      | _ ->
          approx_sig env srem

and approx_modtype_info env sinfo =
  {
   mtd_type = may_map (approx_modtype env) sinfo.pmtd_type;
   mtd_attributes = sinfo.pmtd_attributes;
   mtd_loc = sinfo.pmtd_loc;
  }

(* Additional validity checks on type definitions arising from
   recursive modules *)

let check_recmod_typedecls env sdecls decls =
  let recmod_ids = List.map fst3 decls in
  List.iter2
    (fun pmd (id, _, mty) ->
       let mty = mty.mty_type in
      List.iter
        (fun path ->
          Typedecl.check_recmod_typedecl env pmd.pmd_type.pmty_loc recmod_ids
                                         path (Env.find_type path env))
        (Mtype.type_paths env (Pident id) mty))
    sdecls decls

(* Auxiliaries for checking uniqueness of names in signatures and structures *)

module StringSet =
  Set.Make(struct type t = string let compare (x:t) y = compare x y end)

let check cl loc set_ref name =
  if StringSet.mem name !set_ref
  then raise(Error(loc, Env.empty, Repeated_name(cl, name)))
  else set_ref := StringSet.add name !set_ref

let check_name cl set_ref name =
  check cl name.loc set_ref name.txt

let check_sig_item type_names module_names modtype_names loc = function
    Sig_type(id, _, _) ->
      check "type" loc type_names (Ident.name id)
  | Sig_module(id, _, _) ->
      check "module" loc module_names (Ident.name id)
  | Sig_modtype(id, _) ->
      check "module type" loc modtype_names (Ident.name id)
  | _ -> ()

let rec remove_duplicates val_ids ext_ids = function
    [] -> []
  | Sig_value (id, _) :: rem
    when List.exists (Ident.equal id) val_ids ->
      remove_duplicates val_ids ext_ids rem
  | Sig_typext (id, _, Text_first) :: Sig_typext (id2, ext2, Text_next) :: rem
    when List.exists (Ident.equal id) ext_ids ->
      (* #6510 *)
      remove_duplicates val_ids ext_ids
        (Sig_typext (id2, ext2, Text_first) :: rem)
  | Sig_typext (id, _, _) :: rem
    when List.exists (Ident.equal id) ext_ids ->
      remove_duplicates val_ids ext_ids rem
  | f :: rem -> f :: remove_duplicates val_ids ext_ids rem

let rec get_values = function
    [] -> []
  | Sig_value (id, _) :: rem -> id :: get_values rem
  | f :: rem -> get_values rem

let rec get_extension_constructors = function
    [] -> []
  | Sig_typext (id, _, _) :: rem -> id :: get_extension_constructors rem
  | f :: rem -> get_extension_constructors rem

(* Check and translate a module type expression *)

let transl_modtype_longident loc env lid =
  let (path, info) = Typetexp.find_modtype env loc lid in
  path

let transl_module_alias loc env lid =
  Typetexp.lookup_module env loc lid

let mkmty desc typ env loc attrs =
  let mty = {
    mty_desc = desc;
    mty_type = typ;
    mty_loc = loc;
    mty_env = env;
    mty_attributes = attrs;
    } in
  Cmt_format.add_saved_type (Cmt_format.Partial_module_type mty);
  mty

let mksig desc env loc =
  let sg = { sig_desc = desc; sig_loc = loc; sig_env = env } in
  Cmt_format.add_saved_type (Cmt_format.Partial_signature_item sg);
  sg

(* let signature sg = List.map (fun item -> item.sig_type) sg *)

let rec transl_modtype env smty =
  let loc = smty.pmty_loc in
  match smty.pmty_desc with
    Pmty_ident lid ->
      let path = transl_modtype_longident loc env lid.txt in
      mkmty (Tmty_ident (path, lid)) (Mty_ident path) env loc
        smty.pmty_attributes
  | Pmty_alias lid ->
      let path = transl_module_alias loc env lid.txt in
      mkmty (Tmty_alias (path, lid)) (Mty_alias path) env loc
        smty.pmty_attributes
  | Pmty_signature ssg ->
      let sg = transl_signature env ssg in
      mkmty (Tmty_signature sg) (Mty_signature sg.sig_type) env loc
        smty.pmty_attributes
  | Pmty_functor(param, sarg, sres) ->
      let arg = Misc.may_map (transl_modtype env) sarg in
      let ty_arg = Misc.may_map (fun m -> m.mty_type) arg in
      let (id, newenv) =
        Env.enter_module ~arg:true param.txt (Btype.default_mty ty_arg) env in
      Ctype.init_def(Ident.current_time()); (* PR#6513 *)
      let res = transl_modtype newenv sres in
      mkmty (Tmty_functor (id, param, arg, res))
      (Mty_functor(id, ty_arg, res.mty_type)) env loc
        smty.pmty_attributes
  | Pmty_with(sbody, constraints) ->
      let body = transl_modtype env sbody in
      let init_sg = extract_sig env sbody.pmty_loc body.mty_type in
      let (rev_tcstrs, final_sg) =
        List.fold_left
          (fun (rev_tcstrs,sg) sdecl ->
            let (tcstr, sg) = merge_constraint env smty.pmty_loc sg sdecl
            in
            (tcstr :: rev_tcstrs, sg)
        )
        ([],init_sg) constraints in
      mkmty (Tmty_with ( body, List.rev rev_tcstrs))
        (Mtype.freshen (Mty_signature final_sg)) env loc
        smty.pmty_attributes
  | Pmty_typeof smod ->
      let tmty, mty = !type_module_type_of_fwd env smod in
      mkmty (Tmty_typeof tmty) mty env loc smty.pmty_attributes
  | Pmty_extension ext ->
      raise (Error_forward (Typetexp.error_of_extension ext))


and transl_signature env sg =
  let type_names = ref StringSet.empty
  and module_names = ref StringSet.empty
  and modtype_names = ref StringSet.empty in
  let rec transl_sig env sg =
    Ctype.init_def(Ident.current_time());
    match sg with
      [] -> [], [], env
    | item :: srem ->
        let loc = item.psig_loc in
        match item.psig_desc with
        | Psig_value sdesc ->
            let (tdesc, newenv) =
              Typedecl.transl_value_decl env item.psig_loc sdesc in
            let (trem,rem, final_env) = transl_sig newenv srem in
            mksig (Tsig_value tdesc) env loc :: trem,
            (if List.exists (Ident.equal tdesc.val_id) (get_values rem) then rem
            else Sig_value(tdesc.val_id, tdesc.val_val) :: rem),
              final_env
        | Psig_type sdecls ->
            let rec_flag = rec_flag_of_ptype_declarations sdecls in
            List.iter
              (fun decl ->
                check_name "type" type_names decl.ptype_name)
              sdecls;
            let (decls, newenv) = Typedecl.transl_type_decl env rec_flag sdecls in
            let (trem, rem, final_env) = transl_sig newenv srem in
            mksig (Tsig_type decls) env loc :: trem,
            map_rec_type_with_row_types ~rec_flag
              (fun rs td -> Sig_type(td.typ_id, td.typ_type, rs)) decls rem,
            final_env
        | Psig_typext styext ->
            let (tyext, newenv) =
              Typedecl.transl_type_extension false env item.psig_loc styext
            in
            let (trem, rem, final_env) = transl_sig newenv srem in
            let constructors =
              List.filter
                (fun ext -> not
                  (List.exists (Ident.equal ext.ext_id)
                               (get_extension_constructors rem)))
                tyext.tyext_constructors
            in
              mksig (Tsig_typext tyext) env loc :: trem,
              map_ext (fun es ext ->
                Sig_typext(ext.ext_id, ext.ext_type, es)) constructors rem,
              final_env
        | Psig_exception sext ->
            let (ext, newenv) = Typedecl.transl_exception env sext in
            let (trem, rem, final_env) = transl_sig newenv srem in
            let shadowed =
              List.exists
                (Ident.equal ext.ext_id)
                (get_extension_constructors rem)
            in
            mksig (Tsig_exception ext) env loc :: trem,
            (if shadowed then rem else
               Sig_typext(ext.ext_id, ext.ext_type, Text_exception) :: rem),
            final_env
        | Psig_module pmd ->
            check_name "module" module_names pmd.pmd_name;
            let tmty = transl_modtype env pmd.pmd_type in
            let md = {
              md_type=tmty.mty_type;
              md_attributes=pmd.pmd_attributes;
              md_loc=pmd.pmd_loc;
            }
            in
            let (id, newenv) =
              Env.enter_module_declaration pmd.pmd_name.txt md env in
            let (trem, rem, final_env) = transl_sig newenv srem in
            mksig (Tsig_module {md_id=id; md_name=pmd.pmd_name; md_type=tmty;
                                md_loc=pmd.pmd_loc;
                                md_attributes=pmd.pmd_attributes})
              env loc :: trem,
            Sig_module(id, md, Trec_not) :: rem,
            final_env
        | Psig_recmodule sdecls ->
            List.iter
              (fun pmd -> check_name "module" module_names pmd.pmd_name)
              sdecls;
            let (decls, newenv) =
              transl_recmodule_modtypes item.psig_loc env sdecls in
            let (trem, rem, final_env) = transl_sig newenv srem in
            mksig (Tsig_recmodule decls) env loc :: trem,
            map_rec (fun rs md ->
                let d = {Types.md_type = md.md_type.mty_type;
                         md_attributes = md.md_attributes;
                         md_loc = md.md_loc;
                        } in
                Sig_module(md.md_id, d, rs))
              decls rem,
            final_env
        | Psig_modtype pmtd ->
            let newenv, mtd, sg =
              transl_modtype_decl modtype_names env item.psig_loc pmtd
            in
            let (trem, rem, final_env) = transl_sig newenv srem in
            mksig (Tsig_modtype mtd) env loc :: trem,
            sg :: rem,
            final_env
        | Psig_open sod ->
            let (path, newenv, od) = type_open env sod in
            let (trem, rem, final_env) = transl_sig newenv srem in
            mksig (Tsig_open od) env loc :: trem,
            rem, final_env
        | Psig_include sincl ->
            let smty = sincl.pincl_mod in
            let tmty = transl_modtype env smty in
            let mty = tmty.mty_type in
            let sg = Subst.signature Subst.identity
                       (extract_sig env smty.pmty_loc mty) in
            List.iter
              (check_sig_item type_names module_names modtype_names
                              item.psig_loc)
              sg;
            let newenv = Env.add_signature sg env in
            let incl =
              { incl_mod = tmty;
                incl_type = sg;
                incl_attributes = sincl.pincl_attributes;
                incl_loc = sincl.pincl_loc;
              }
            in
            let (trem, rem, final_env) = transl_sig newenv srem in
            mksig (Tsig_include incl) env loc :: trem,
            remove_duplicates (get_values rem)
              (get_extension_constructors rem) sg @ rem,
            final_env
        | Psig_class cl ->
            List.iter
              (fun {pci_name = name} -> check_name "type" type_names name)
              cl;
            let (classes, newenv) = Typeclass.class_descriptions env cl in
            let (trem, rem, final_env) = transl_sig newenv srem in
            mksig (Tsig_class
                     (List.map2
                        (fun pcl tcl ->
                          let (_, _, _, _, _, _, _, _, _, _, _, tcl) = tcl in
                          tcl)
                        cl classes)) env loc
            :: trem,
            List.flatten
              (map_rec
                 (fun rs (i, _, d, i', d', i'', d'', i''', d''', _, _, _) ->
                   [Sig_class(i, d, rs);
                    Sig_class_type(i', d', rs);
                    Sig_type(i'', d'', rs);
                    Sig_type(i''', d''', rs)])
                 classes [rem]),
            final_env
        | Psig_class_type cl ->
            List.iter
              (fun {pci_name = name} -> check_name "type" type_names name)
              cl;
            let (classes, newenv) = Typeclass.class_type_declarations env cl in
            let (trem,rem, final_env) = transl_sig newenv srem in
            mksig (Tsig_class_type (List.map2 (fun pcl tcl ->
              let (_, _, _, _, _, _, _, tcl) = tcl in
              tcl
            ) cl classes)) env loc :: trem,
            List.flatten
              (map_rec
                 (fun rs (i, _, d, i', d', i'', d'', _) ->
                   [Sig_class_type(i, d, rs);
                    Sig_type(i', d', rs);
                    Sig_type(i'', d'', rs)])
                 classes [rem]),
            final_env
        | Psig_attribute x ->
            Typetexp.warning_attribute [x];
            let (trem,rem, final_env) = transl_sig env srem in
            mksig (Tsig_attribute x) env loc :: trem, rem, final_env
        | Psig_extension (ext, _attrs) ->
            raise (Error_forward (Typetexp.error_of_extension ext))
  in
  let previous_saved_types = Cmt_format.get_saved_types () in
  Typetexp.warning_enter_scope ();
  let (trem, rem, final_env) = transl_sig (Env.in_signature env) sg in
  let sg = { sig_items = trem; sig_type =  rem; sig_final_env = final_env } in
  Typetexp.warning_leave_scope ();
  Cmt_format.set_saved_types
    ((Cmt_format.Partial_signature sg) :: previous_saved_types);
  sg

and transl_modtype_decl modtype_names env loc
    {pmtd_name; pmtd_type; pmtd_attributes; pmtd_loc} =
  check_name "module type" modtype_names pmtd_name;
  let tmty = Misc.may_map (transl_modtype env) pmtd_type in
  let decl =
    {
     Types.mtd_type=may_map (fun t -> t.mty_type) tmty;
     mtd_attributes=pmtd_attributes;
     mtd_loc=pmtd_loc;
    }
  in
  let (id, newenv) = Env.enter_modtype pmtd_name.txt decl env in
  let mtd =
    {
     mtd_id=id;
     mtd_name=pmtd_name;
     mtd_type=tmty;
     mtd_attributes=pmtd_attributes;
     mtd_loc=pmtd_loc;
    }
  in
  newenv, mtd, Sig_modtype(id, decl)

and transl_recmodule_modtypes loc env sdecls =
  let make_env curr =
    List.fold_left
      (fun env (id, _, mty) -> Env.add_module ~arg:true id mty env)
      env curr in
  let make_env2 curr =
    List.fold_left
      (fun env (id, _, mty) -> Env.add_module ~arg:true id mty.mty_type env)
      env curr in
  let transition env_c curr =
    List.map2
      (fun pmd (id, id_loc, mty) ->
        (id, id_loc, transl_modtype env_c pmd.pmd_type))
      sdecls curr in
  let ids = List.map (fun x -> Ident.create x.pmd_name.txt) sdecls in
  let approx_env =
    (*
       cf #5965
       We use a dummy module type in order to detect a reference to one
       of the module being defined during the call to approx_modtype.
       It will be detected in Env.lookup_module.
    *)
    List.fold_left
      (fun env id ->
         let dummy = Mty_ident (Path.Pident (Ident.create "#recmod#")) in
         Env.add_module ~arg:true id dummy env
      )
      env ids
  in
  let init =
    List.map2
      (fun id pmd ->
        (id, pmd.pmd_name, approx_modtype approx_env pmd.pmd_type))
      ids sdecls
  in
  let env0 = make_env init in
  let dcl1 = transition env0 init in
  let env1 = make_env2 dcl1 in
  check_recmod_typedecls env1 sdecls dcl1;
  let dcl2 = transition env1 dcl1 in
(*
  List.iter
    (fun (id, mty) ->
      Format.printf "%a: %a@." Printtyp.ident id Printtyp.modtype mty)
    dcl2;
*)
  let env2 = make_env2 dcl2 in
  check_recmod_typedecls env2 sdecls dcl2;
  let dcl2 =
    List.map2
      (fun pmd (id, id_loc, mty) ->
        {md_id=id; md_name=id_loc; md_type=mty;
         md_loc=pmd.pmd_loc;
         md_attributes=pmd.pmd_attributes})
      sdecls dcl2
  in
  (dcl2, env2)

(* Simplify multiple specifications of a value or an extension in a signature.
   (Other signature components, e.g. types, modules, etc, are checked for
   name uniqueness.)  If multiple specifications with the same name,
   keep only the last (rightmost) one. *)

let simplify_signature sg =
  let rec aux = function
    | [] -> [], StringSet.empty, StringSet.empty
    | (Sig_value(id, descr) as component) :: sg ->
        let (sg, val_names, ext_names) as k = aux sg in
        let name = Ident.name id in
        if StringSet.mem name val_names then k
        else (component :: sg, StringSet.add name val_names, ext_names)
    | (Sig_typext(id, ext, es) as component) :: sg ->
        let (sg, val_names, ext_names) as k = aux sg in
        let name = Ident.name id in
        if StringSet.mem name ext_names then
          (* #6510 *)
          match es, sg with
          | Text_first, Sig_typext(id2, ext2, Text_next) :: rest ->
              (Sig_typext(id2, ext2, Text_first) :: rest,
               val_names, ext_names)
          | _ -> k
        else
          (component :: sg, val_names, StringSet.add name ext_names)
    | component :: sg ->
        let (sg, val_names, ext_names) = aux sg in
        (component :: sg, val_names, ext_names)
  in
  let (sg, _, _) = aux sg in
  sg

(* Try to convert a module expression to a module path. *)

exception Not_a_path

let rec path_of_module mexp =
  match mexp.mod_desc with
    Tmod_ident (p,_) -> p
  | Tmod_apply(funct, arg, coercion) when !Clflags.applicative_functors ->
      Papply(path_of_module funct, path_of_module arg)
  | Tmod_constraint (mexp, _, _, _) ->
      path_of_module mexp
  | _ -> raise Not_a_path

let path_of_module mexp =
 try Some (path_of_module mexp) with Not_a_path -> None

(* Check that all core type schemes in a structure are closed *)

let rec closed_modtype = function
    Mty_ident p -> true
  | Mty_alias p -> true
  | Mty_signature sg -> List.for_all closed_signature_item sg
  | Mty_functor(id, param, body) -> closed_modtype body

and closed_signature_item = function
    Sig_value(id, desc) -> Ctype.closed_schema desc.val_type
  | Sig_module(id, md, _) -> closed_modtype md.md_type
  | _ -> true

let check_nongen_scheme env str =
  match str.str_desc with
    Tstr_value(rec_flag, pat_exp_list) ->
      List.iter
        (fun {vb_expr=exp} ->
          if not (Ctype.closed_schema exp.exp_type) then
            raise(Error(exp.exp_loc, env, Non_generalizable exp.exp_type)))
        pat_exp_list
  | Tstr_module {mb_expr=md;_} ->
      if not (closed_modtype md.mod_type) then
        raise(Error(md.mod_loc, env, Non_generalizable_module md.mod_type))
  | _ -> ()

let check_nongen_schemes env str =
  List.iter (check_nongen_scheme env) str

(* Helpers for typing recursive modules *)

let anchor_submodule name anchor =
  match anchor with None -> None | Some p -> Some(Pdot(p, name, nopos))
let anchor_recmodule id anchor =
  Some (Pident id)

let enrich_type_decls anchor decls oldenv newenv =
  match anchor with
    None -> newenv
  | Some p ->
      List.fold_left
        (fun e info ->
          let id = info.typ_id in
          let info' =
            Mtype.enrich_typedecl oldenv (Pdot(p, Ident.name id, nopos))
              info.typ_type
          in
            Env.add_type ~check:true id info' e)
        oldenv decls

let enrich_module_type anchor name mty env =
  match anchor with
    None -> mty
  | Some p -> Mtype.enrich_modtype env (Pdot(p, name, nopos)) mty

let check_recmodule_inclusion env bindings =
  (* PR#4450, PR#4470: consider
        module rec X : DECL = MOD  where MOD has inferred type ACTUAL
     The "natural" typing condition
        E, X: ACTUAL |- ACTUAL <: DECL
     leads to circularities through manifest types.
     Instead, we "unroll away" the potential circularities a finite number
     of times.  The (weaker) condition we implement is:
        E, X: DECL,
           X1: ACTUAL,
           X2: ACTUAL{X <- X1}/X1
           ...
           Xn: ACTUAL{X <- X(n-1)}/X(n-1)
        |- ACTUAL{X <- Xn}/Xn <: DECL{X <- Xn}
     so that manifest types rooted at X(n+1) are expanded in terms of X(n),
     avoiding circularities.  The strengthenings ensure that
     Xn.t = X(n-1).t = ... = X2.t = X1.t.
     N can be chosen arbitrarily; larger values of N result in more
     recursive definitions being accepted.  A good choice appears to be
     the number of mutually recursive declarations. *)

  let subst_and_strengthen env s id mty =
    Mtype.strengthen env (Subst.modtype s mty)
                         (Subst.module_path s (Pident id)) in

  let rec check_incl first_time n env s =
    if n > 0 then begin
      (* Generate fresh names Y_i for the rec. bound module idents X_i *)
      let bindings1 =
        List.map
          (fun (id, _, mty_decl, modl, mty_actual, _attrs, _loc) ->
             (id, Ident.rename id, mty_actual))
          bindings in
      (* Enter the Y_i in the environment with their actual types substituted
         by the input substitution s *)
      let env' =
        List.fold_left
          (fun env (id, id', mty_actual) ->
             let mty_actual' =
               if first_time
               then mty_actual
               else subst_and_strengthen env s id mty_actual in
             Env.add_module ~arg:false id' mty_actual' env)
          env bindings1 in
      (* Build the output substitution Y_i <- X_i *)
      let s' =
        List.fold_left
          (fun s (id, id', mty_actual) ->
             Subst.add_module id (Pident id') s)
          Subst.identity bindings1 in
      (* Recurse with env' and s' *)
      check_incl false (n-1) env' s'
    end else begin
      (* Base case: check inclusion of s(mty_actual) in s(mty_decl)
         and insert coercion if needed *)
      let check_inclusion (id, id_loc, mty_decl, modl, mty_actual, attrs, loc) =
        let mty_decl' = Subst.modtype s mty_decl.mty_type
        and mty_actual' = subst_and_strengthen env s id mty_actual in
        let coercion =
          try
            Includemod.modtypes env mty_actual' mty_decl'
          with Includemod.Error msg ->
            raise(Error(modl.mod_loc, env, Not_included msg)) in
        let modl' =
            { mod_desc = Tmod_constraint(modl, mty_decl.mty_type,
                Tmodtype_explicit mty_decl, coercion);
              mod_type = mty_decl.mty_type;
              mod_env = env;
              mod_loc = modl.mod_loc;
              mod_attributes = [];
             } in
        {
         mb_id = id;
         mb_name = id_loc;
         mb_expr = modl';
         mb_attributes = attrs;
         mb_loc = loc;
        }
      in
      List.map check_inclusion bindings
    end
  in check_incl true (List.length bindings) env Subst.identity

(* Helper for unpack *)

let rec package_constraints env loc mty constrs =
  if constrs = [] then mty
  else let sg = extract_sig env loc mty in
  let sg' =
    List.map
      (function
        | Sig_type (id, ({type_params=[]} as td), rs)
          when List.mem_assoc [Ident.name id] constrs ->
            let ty = List.assoc [Ident.name id] constrs in
            Sig_type (id, {td with type_manifest = Some ty}, rs)
        | Sig_module (id, md, rs) ->
            let rec aux = function
              | (m :: ((_ :: _) as l), t) :: rest when m = Ident.name id ->
                  (l, t) :: aux rest
              | _ :: rest -> aux rest
              | [] -> []
            in
            let md =
              {md with
               md_type = package_constraints env loc md.md_type (aux constrs)
              }
            in
            Sig_module (id, md, rs)
        | item -> item
      )
      sg
  in
  Mty_signature sg'

let modtype_of_package env loc p nl tl =
  try match (Env.find_modtype p env).mtd_type with
  | Some mty when nl <> [] ->
      package_constraints env loc mty
        (List.combine (List.map Longident.flatten nl) tl)
  | _ ->
      if nl = [] then Mty_ident p
      else raise(Error(loc, env, Signature_expected))
  with Not_found ->
    let error = Typetexp.Unbound_modtype (Ctype.lid_of_path p) in
    raise(Typetexp.Error(loc, env, error))

let package_subtype env p1 nl1 tl1 p2 nl2 tl2 =
  let mkmty p nl tl =
    let ntl =
      List.filter (fun (n,t) -> Ctype.free_variables t = [])
        (List.combine nl tl) in
    let (nl, tl) = List.split ntl in
    modtype_of_package env Location.none p nl tl
  in
  let mty1 = mkmty p1 nl1 tl1 and mty2 = mkmty p2 nl2 tl2 in
  try Includemod.modtypes env mty1 mty2 = Tcoerce_none
  with Includemod.Error msg -> false
    (* raise(Error(Location.none, env, Not_included msg)) *)

let () = Ctype.package_subtype := package_subtype

let wrap_constraint env arg mty explicit =
  let coercion =
    try
      Includemod.modtypes env arg.mod_type mty
    with Includemod.Error msg ->
      raise(Error(arg.mod_loc, env, Not_included msg)) in
  { mod_desc = Tmod_constraint(arg, mty, explicit, coercion);
    mod_type = mty;
    mod_env = env;
    mod_attributes = [];
    mod_loc = arg.mod_loc }

(* Type a module value expression *)

let rec type_module ?(alias=false) sttn funct_body anchor env smod =
  match smod.pmod_desc with
    Pmod_ident lid ->
      let path =
        Typetexp.lookup_module ~load:(not alias) env smod.pmod_loc lid.txt in
      let md = { mod_desc = Tmod_ident (path, lid);
                 mod_type = Mty_alias path;
                 mod_env = env;
                 mod_attributes = smod.pmod_attributes;
                 mod_loc = smod.pmod_loc } in
      let md =
        if alias && not (Env.is_functor_arg path env) then
          (Env.add_required_global (Path.head path); md)
        else match (Env.find_module path env).md_type with
          Mty_alias p1 when not alias ->
            let p1 = Env.normalize_path (Some smod.pmod_loc) env p1 in
            let mty = Includemod.expand_module_alias env [] p1 in
            { md with
              mod_desc = Tmod_constraint (md, mty, Tmodtype_implicit,
                                          Tcoerce_alias (p1, Tcoerce_none));
              mod_type = if sttn then Mtype.strengthen env mty p1 else mty }
        | mty ->
            let mty =
              if sttn then Mtype.strengthen env mty path else mty in
            { md with mod_type = mty }
      in rm md
  | Pmod_structure sstr ->
      let (str, sg, finalenv) =
        type_structure funct_body anchor env sstr smod.pmod_loc in
      let md =
        rm { mod_desc = Tmod_structure str;
             mod_type = Mty_signature sg;
             mod_env = env;
             mod_attributes = smod.pmod_attributes;
             mod_loc = smod.pmod_loc }
      in
      let sg' = simplify_signature sg in
      if List.length sg' = List.length sg then md else
      wrap_constraint (Env.implicit_coercion env) md (Mty_signature sg')
        Tmodtype_implicit
  | Pmod_functor(name, smty, sbody) ->
      let mty = may_map (transl_modtype env) smty in
      let ty_arg = may_map (fun m -> m.mty_type) mty in
      let (id, newenv), funct_body =
        match ty_arg with None -> (Ident.create "*", env), false
        | Some mty -> Env.enter_module ~arg:true name.txt mty env, true in
      let body = type_module sttn funct_body None newenv sbody in
      rm { mod_desc = Tmod_functor(id, name, mty, body);
           mod_type = Mty_functor(id, ty_arg, body.mod_type);
           mod_env = env;
           mod_attributes = smod.pmod_attributes;
           mod_loc = smod.pmod_loc }
  | Pmod_apply(sfunct, sarg) ->
      let arg = type_module true funct_body None env sarg in
      let path = path_of_module arg in
      let funct =
        type_module (sttn && path <> None) funct_body None env sfunct in
      begin match Env.scrape_alias env funct.mod_type with
        Mty_functor(param, mty_param, mty_res) as mty_functor ->
          let generative, mty_param =
            (mty_param = None, Btype.default_mty mty_param) in
          if generative then begin
            if sarg.pmod_desc <> Pmod_structure [] then
              raise (Error (sfunct.pmod_loc, env, Apply_generative));
            if funct_body && Mtype.contains_type env funct.mod_type then
              raise (Error (smod.pmod_loc, env, Not_allowed_in_functor_body));
          end;
          let coercion =
            try
              Includemod.modtypes env arg.mod_type mty_param
            with Includemod.Error msg ->
              raise(Error(sarg.pmod_loc, env, Not_included msg)) in
          let mty_appl =
            match path with
              Some path ->
                Subst.modtype (Subst.add_module param path Subst.identity)
                              mty_res
            | None ->
                if generative then mty_res else
                try
                  Mtype.nondep_supertype
                    (Env.add_module ~arg:true param arg.mod_type env)
                    param mty_res
                with Not_found ->
                  raise(Error(smod.pmod_loc, env,
                              Cannot_eliminate_dependency mty_functor))
          in
          rm { mod_desc = Tmod_apply(funct, arg, coercion);
               mod_type = mty_appl;
               mod_env = env;
               mod_attributes = smod.pmod_attributes;
               mod_loc = smod.pmod_loc }
      | _ ->
          raise(Error(sfunct.pmod_loc, env, Cannot_apply funct.mod_type))
      end
  | Pmod_constraint(sarg, smty) ->
      let arg = type_module ~alias true funct_body anchor env sarg in
      let mty = transl_modtype env smty in
      rm {(wrap_constraint env arg mty.mty_type (Tmodtype_explicit mty)) with
          mod_loc = smod.pmod_loc;
          mod_attributes = smod.pmod_attributes;
         }

  | Pmod_unpack sexp ->
      if !Clflags.principal then Ctype.begin_def ();
      let exp = Typecore.type_exp env sexp in
      if !Clflags.principal then begin
        Ctype.end_def ();
        Ctype.generalize_structure exp.exp_type
      end;
      let mty =
        match Ctype.expand_head env exp.exp_type with
          {desc = Tpackage (p, nl, tl)} ->
            if List.exists (fun t -> Ctype.free_variables t <> []) tl then
              raise (Error (smod.pmod_loc, env,
                            Incomplete_packed_module exp.exp_type));
            if !Clflags.principal &&
              not (Typecore.generalizable (Btype.generic_level-1) exp.exp_type)
            then
              Location.prerr_warning smod.pmod_loc
                (Warnings.Not_principal "this module unpacking");
            modtype_of_package env smod.pmod_loc p nl tl
        | {desc = Tvar _} ->
            raise (Typecore.Error
                     (smod.pmod_loc, env, Typecore.Cannot_infer_signature))
        | _ ->
            raise (Error(smod.pmod_loc, env, Not_a_packed_module exp.exp_type))
      in
      if funct_body && Mtype.contains_type env mty then
        raise (Error (smod.pmod_loc, env, Not_allowed_in_functor_body));
      rm { mod_desc = Tmod_unpack(exp, mty);
           mod_type = mty;
           mod_env = env;
           mod_attributes = smod.pmod_attributes;
           mod_loc = smod.pmod_loc }
  | Pmod_extension ext ->
      raise (Error_forward (Typetexp.error_of_extension ext))

and type_structure ?(toplevel = false) funct_body anchor env sstr scope =
  let type_names = ref StringSet.empty
  and module_names = ref StringSet.empty
  and modtype_names = ref StringSet.empty in

  let type_str_item env srem {pstr_loc = loc; pstr_desc = desc} =
    match desc with
    | Pstr_eval (sexpr, attrs) ->
        let expr = Typecore.type_expression env sexpr in
        Tstr_eval (expr, attrs), [], env
    | Pstr_value(rec_flag, sdefs) ->
        let scope =
          match rec_flag with
          | Recursive ->
              Some (Annot.Idef {scope with
                                Location.loc_start = loc.Location.loc_start})
          | Nonrecursive ->
              let start =
                match srem with
                | [] -> loc.Location.loc_end
                | {pstr_loc = loc2} :: _ -> loc2.Location.loc_start
              in
              Some (Annot.Idef {scope with Location.loc_start = start})
        in
        let (defs, newenv) =
          Typecore.type_binding env rec_flag sdefs scope in
        (* Note: Env.find_value does not trigger the value_used event. Values
           will be marked as being used during the signature inclusion test. *)
        Tstr_value(rec_flag, defs),
        List.map (fun id -> Sig_value(id, Env.find_value (Pident id) newenv))
          (let_bound_idents defs),
        newenv
    | Pstr_primitive sdesc ->
        let (desc, newenv) = Typedecl.transl_value_decl env loc sdesc in
        Tstr_primitive desc, [Sig_value(desc.val_id, desc.val_val)], newenv
    | Pstr_type sdecls ->
        let rec_flag = rec_flag_of_ptype_declarations sdecls in
        List.iter
          (fun decl -> check_name "type" type_names decl.ptype_name)
          sdecls;
        let (decls, newenv) = Typedecl.transl_type_decl env rec_flag sdecls in
        Tstr_type decls,
        map_rec_type_with_row_types ~rec_flag
          (fun rs info -> Sig_type(info.typ_id, info.typ_type, rs))
          decls [],
        enrich_type_decls anchor decls env newenv
    | Pstr_typext styext ->
        let (tyext, newenv) =
          Typedecl.transl_type_extension true env loc styext
        in
        (Tstr_typext tyext,
         map_ext
           (fun es ext -> Sig_typext(ext.ext_id, ext.ext_type, es))
           tyext.tyext_constructors [],
         newenv)
    | Pstr_exception sext ->
        let (ext, newenv) = Typedecl.transl_exception env sext in
        Tstr_exception ext,
        [Sig_typext(ext.ext_id, ext.ext_type, Text_exception)],
        newenv
    | Pstr_module {pmb_name = name; pmb_expr = smodl; pmb_attributes = attrs;
                   pmb_loc;
                  } ->
        check_name "module" module_names name;
        let modl =
          type_module ~alias:true true funct_body
            (anchor_submodule name.txt anchor) env smodl in
        let md =
          { md_type = enrich_module_type anchor name.txt modl.mod_type env;
            md_attributes = attrs;
            md_loc = pmb_loc;
          }
        in
        let (id, newenv) = Env.enter_module_declaration name.txt md env in
        Tstr_module {mb_id=id; mb_name=name; mb_expr=modl;
                     mb_attributes=attrs;  mb_loc=pmb_loc;
                    },
        [Sig_module(id,
                    {md_type = modl.mod_type;
                     md_attributes = attrs;
                     md_loc = pmb_loc;
                    }, Trec_not)],
        newenv
    | Pstr_recmodule sbind ->
        let sbind =
          List.map
            (function
              | {pmb_name = name;
                 pmb_expr = {pmod_desc=Pmod_constraint(expr, typ)};
                 pmb_attributes = attrs;
                 pmb_loc = loc;
                } ->
                  name, typ, expr, attrs, loc
              | mb ->
                  raise (Error (mb.pmb_expr.pmod_loc, env,
                                Recursive_module_require_explicit_type))
            )
            sbind
        in
        List.iter
          (fun (name, _, _, _, _) -> check_name "module" module_names name)
          sbind;
        let (decls, newenv) =
          transl_recmodule_modtypes loc env
            (List.map (fun (name, smty, smodl, attrs, loc) ->
                 {pmd_name=name; pmd_type=smty;
                  pmd_attributes=attrs; pmd_loc=loc}) sbind
            ) in
        let bindings1 =
          List.map2
            (fun {md_id=id; md_type=mty} (name, _, smodl, attrs, loc) ->
               let modl =
                 type_module true funct_body (anchor_recmodule id anchor) newenv
                   smodl in
               let mty' =
                 enrich_module_type anchor (Ident.name id) modl.mod_type newenv
               in
               (id, name, mty, modl, mty', attrs, loc))
            decls sbind in
        let newenv = (* allow aliasing recursive modules from outside *)
          List.fold_left
            (fun env md ->
               let mdecl =
                 {
                   md_type = md.md_type.mty_type;
                   md_attributes = md.md_attributes;
                   md_loc = md.md_loc;
                 }
               in
               Env.add_module_declaration md.md_id mdecl env
            )
            env decls
        in
        let bindings2 =
          check_recmodule_inclusion newenv bindings1 in
        Tstr_recmodule bindings2,
        map_rec (fun rs mb ->
            Sig_module(mb.mb_id, {
                md_type=mb.mb_expr.mod_type;
                md_attributes=mb.mb_attributes;
                md_loc=mb.mb_loc;
              }, rs))
           bindings2 [],
        newenv
    | Pstr_modtype pmtd ->
        (* check that it is non-abstract *)
        let newenv, mtd, sg =
          transl_modtype_decl modtype_names env loc pmtd
        in
        Tstr_modtype mtd, [sg], newenv
    | Pstr_open sod ->
        let (path, newenv, od) = type_open ~toplevel env sod in
        Tstr_open od, [], newenv
    | Pstr_class cl ->
        List.iter
          (fun {pci_name = name} -> check_name "type" type_names name)
          cl;
        let (classes, new_env) = Typeclass.class_declarations env cl in
        Tstr_class
          (List.map (fun (i, _, d, _,_,_,_,_,_, s, m, c) ->
               let vf = if d.cty_new = None then Virtual else Concrete in
               (* (i, s, m, c, vf) *) (c, m, vf))
              classes),
(* TODO: check with Jacques why this is here
      Tstr_class_type
          (List.map (fun (_,_, i, d, _,_,_,_,_,_,c) -> (i, c)) classes) ::
      Tstr_type
          (List.map (fun (_,_,_,_, i, d, _,_,_,_,_) -> (i, d)) classes) ::
      Tstr_type
          (List.map (fun (_,_,_,_,_,_, i, d, _,_,_) -> (i, d)) classes) ::
*)
        List.flatten
          (map_rec
             (fun rs (i, _, d, i', d', i'', d'', i''', d''', _, _, _) ->
                [Sig_class(i, d, rs);
                 Sig_class_type(i', d', rs);
                 Sig_type(i'', d'', rs);
                 Sig_type(i''', d''', rs)])
             classes []),
        new_env
    | Pstr_class_type cl ->
        List.iter
          (fun {pci_name = name} -> check_name "type" type_names name)
          cl;
        let (classes, new_env) = Typeclass.class_type_declarations env cl in
        Tstr_class_type
          (List.map (fun (i, i_loc, d, _, _, _, _, c) ->
               (i, i_loc, c)) classes),
(*  TODO: check with Jacques why this is here
           Tstr_type
             (List.map (fun (_, _, i, d, _, _) -> (i, d)) classes) ::
           Tstr_type
             (List.map (fun (_, _, _, _, i, d) -> (i, d)) classes) :: *)
        List.flatten
          (map_rec
             (fun rs (i, _, d, i', d', i'', d'', _) ->
                [Sig_class_type(i, d, rs);
                 Sig_type(i', d', rs);
                 Sig_type(i'', d'', rs)])
             classes []),
        new_env
    | Pstr_include sincl ->
        let smodl = sincl.pincl_mod in
        let modl = type_module true funct_body None env smodl in
        (* Rename all identifiers bound by this signature to avoid clashes *)
        let sg = Subst.signature Subst.identity
            (extract_sig_open env smodl.pmod_loc modl.mod_type) in
        let sg =
          match modl.mod_desc with
            Tmod_ident (p, _) when not (Env.is_functor_arg p env) ->
              Env.add_required_global (Path.head p);
              let pos = ref 0 in
              List.map
                (function
                  | Sig_module (id, md, rs) ->
                      let n = !pos in incr pos;
                      Sig_module (id, {md with md_type =
                                       Mty_alias (Pdot(p,Ident.name id,n))},
                                  rs)
                  | Sig_value (_, {val_kind=Val_reg})
                  | Sig_typext _ | Sig_class _ as it ->
                      incr pos; it
                  | Sig_value _ | Sig_type _ | Sig_modtype _
                  | Sig_class_type _ as it ->
                      it)
                sg
          | _ -> sg
        in
        List.iter
          (check_sig_item type_names module_names modtype_names loc) sg;
        let new_env = Env.add_signature sg env in
        let incl =
          { incl_mod = modl;
            incl_type = sg;
            incl_attributes = sincl.pincl_attributes;
            incl_loc = sincl.pincl_loc;
          }
        in
        Tstr_include incl, sg, new_env
    | Pstr_extension (ext, _attrs) ->
        raise (Error_forward (Typetexp.error_of_extension ext))
    | Pstr_attribute x ->
        Typetexp.warning_attribute [x];
        Tstr_attribute x, [], env
  in
  let rec type_struct env sstr =
    Ctype.init_def(Ident.current_time());
    match sstr with
    | [] -> ([], [], env)
    | pstr :: srem ->
        let previous_saved_types = Cmt_format.get_saved_types () in
        let desc, sg, new_env = type_str_item env srem pstr in
        let str = { str_desc = desc; str_loc = pstr.pstr_loc; str_env = env } in
        Cmt_format.set_saved_types (Cmt_format.Partial_structure_item str
                                    :: previous_saved_types);
        let (str_rem, sig_rem, final_env) = type_struct new_env srem in
        (str :: str_rem, sg @ sig_rem, final_env)
  in
  if !Clflags.annotations then
    (* moved to genannot *)
    List.iter (function {pstr_loc = l} -> Stypes.record_phrase l) sstr;
  let previous_saved_types = Cmt_format.get_saved_types () in
  Typetexp.warning_enter_scope ();
  let (items, sg, final_env) = type_struct env sstr in
  let str = { str_items = items; str_type = sg; str_final_env = final_env } in
  Typetexp.warning_leave_scope ();
  Cmt_format.set_saved_types
    (Cmt_format.Partial_structure str :: previous_saved_types);
  str, sg, final_env

let type_toplevel_phrase env s =
  Env.reset_required_globals ();
  type_structure ~toplevel:true false None env s Location.none
(*let type_module_alias = type_module ~alias:true true false None*)
let type_module = type_module true false None
let type_structure = type_structure false None

(* Normalize types in a signature *)

let rec normalize_modtype env = function
    Mty_ident p -> ()
  | Mty_alias p -> ()
  | Mty_signature sg -> normalize_signature env sg
  | Mty_functor(id, param, body) -> normalize_modtype env body

and normalize_signature env = List.iter (normalize_signature_item env)

and normalize_signature_item env = function
    Sig_value(id, desc) -> Ctype.normalize_type env desc.val_type
  | Sig_module(id, md, _) -> normalize_modtype env md.md_type
  | _ -> ()

(* Extract the module type of a module expression *)

let type_module_type_of env smod =
  let tmty =
    match smod.pmod_desc with
    | Pmod_ident lid -> (* turn off strengthening in this case *)
        let path, md = Typetexp.find_module env smod.pmod_loc lid.txt in
        rm { mod_desc = Tmod_ident (path, lid);
             mod_type = md.md_type;
             mod_env = env;
             mod_attributes = smod.pmod_attributes;
             mod_loc = smod.pmod_loc }
    | _ -> type_module env smod in
  let mty = tmty.mod_type in
  (* PR#6307: expand aliases at root and submodules *)
  let mty = Mtype.remove_aliases env mty in
  (* PR#5036: must not contain non-generalized type variables *)
  if not (closed_modtype mty) then
    raise(Error(smod.pmod_loc, env, Non_generalizable_module mty));
  tmty, mty

(* For Typecore *)

let rec get_manifest_types = function
    [] -> []
  | Sig_type (id, {type_params=[]; type_manifest=Some ty}, _) :: rem ->
      (Ident.name id, ty) :: get_manifest_types rem
  | _ :: rem -> get_manifest_types rem

let type_package env m p nl tl =
  (* Same as Pexp_letmodule *)
  (* remember original level *)
  let lv = Ctype.get_current_level () in
  Ctype.begin_def ();
  Ident.set_current_time lv;
  let context = Typetexp.narrow () in
  let modl = type_module env m in
  Ctype.init_def(Ident.current_time());
  Typetexp.widen context;
  let (mp, env) =
    match modl.mod_desc with
      Tmod_ident (mp,_) -> (mp, env)
    | _ ->
      let (id, new_env) = Env.enter_module ~arg:true "%M" modl.mod_type env in
      (Pident id, new_env)
  in
  let rec mkpath mp = function
    | Lident name -> Pdot(mp, name, nopos)
    | Ldot (m, name) -> Pdot(mkpath mp m, name, nopos)
    | _ -> assert false
  in
  let tl' =
    List.map
      (fun name -> Btype.newgenty (Tconstr (mkpath mp name,[],ref Mnil)))
      nl in
  (* go back to original level *)
  Ctype.end_def ();
  if nl = [] then
    (wrap_constraint env modl (Mty_ident p) Tmodtype_implicit, [])
  else let mty = modtype_of_package env modl.mod_loc p nl tl' in
  List.iter2
    (fun n ty ->
      try Ctype.unify env ty (Ctype.newvar ())
      with Ctype.Unify _ ->
        raise (Error(m.pmod_loc, env, Scoping_pack (n,ty))))
    nl tl';
  (wrap_constraint env modl mty Tmodtype_implicit, tl')

(* Fill in the forward declarations *)
let () =
  Typecore.type_module := type_module;
  Typetexp.transl_modtype_longident := transl_modtype_longident;
  Typetexp.transl_modtype := transl_modtype;
  Typecore.type_open := type_open_ ?toplevel:None;
  Typecore.type_package := type_package;
  type_module_type_of_fwd := type_module_type_of


(* Typecheck an implementation file *)

let type_implementation_more sourcefile outputprefix modulename initial_env ast =
  Cmt_format.clear ();
  try
  Typecore.reset_delayed_checks ();
  Env.reset_required_globals ();
  begin
    let map = Typetexp.emit_external_warnings in
    ignore (map.Ast_mapper.structure map ast)
  end;

  let (str, sg, finalenv) =
    type_structure initial_env ast (Location.in_file sourcefile) in
  let simple_sg = simplify_signature sg in
  if !Clflags.print_types then begin
    Printtyp.wrap_printing_env initial_env
      (fun () -> fprintf std_formatter "%a@." Printtyp.signature simple_sg);
    (str, Tcoerce_none,finalenv, simple_sg)   (* result is ignored by Compile.implementation *)
  end else begin
    let sourceintf =
      Misc.chop_extension_if_any sourcefile ^ !Config.interface_suffix in

    let mli_status = !Clflags.assume_no_mli in
    if (mli_status = Clflags.Mli_na && Sys.file_exists sourceintf) || (mli_status = Clflags.Mli_exists) then begin

      let intf_file =
        try
          find_in_path_uncap !Config.load_path (modulename ^ ".cmi")
        with Not_found ->
          raise(Error(Location.in_file sourcefile, Env.empty,
                      Interface_not_compiled sourceintf)) in
      let dclsig = Env.read_signature modulename intf_file in
      let coercion =
        Includemod.compunit initial_env sourcefile sg intf_file dclsig in
      Typecore.force_delayed_checks ();
      (* It is important to run these checks after the inclusion test above,
         so that value declarations which are not used internally but exported
         are not reported as being unused. *)
      Cmt_format.save_cmt (outputprefix ^ ".cmt") modulename
        (Cmt_format.Implementation str) (Some sourcefile) initial_env None;
      (str, coercion, finalenv, dclsig)
        (* identifier is useless might read from serialized cmi files*)
    end else begin
      check_nongen_schemes finalenv str.str_items;
      normalize_signature finalenv simple_sg;
      let coercion =
        Includemod.compunit initial_env sourcefile sg
                            "(inferred signature)" simple_sg in
      Typecore.force_delayed_checks ();
      (* See comment above. Here the target signature contains all
         the value being exported. We can still capture unused
         declarations like "let x = true;; let x = 1;;", because in this
         case, the inferred signature contains only the last declaration. *)
      if not !Clflags.dont_write_files then begin
        let sg =
          Env.save_signature simple_sg modulename (outputprefix ^ ".cmi") in
        Cmt_format.save_cmt  (outputprefix ^ ".cmt") modulename
          (Cmt_format.Implementation str)
          (Some sourcefile) initial_env (Some sg);
      end;
      (str, coercion,finalenv, simple_sg)
    end
    end
  with e ->
    Cmt_format.save_cmt  (outputprefix ^ ".cmt") modulename
      (Cmt_format.Partial_implementation
         (Array.of_list (Cmt_format.get_saved_types ())))
      (Some sourcefile) initial_env None;
    raise e
let type_implementation sourcefile outputprefix modulename initial_env ast =
  let (a,b,_,_) =
    type_implementation_more sourcefile outputprefix modulename initial_env ast in
  a,b

let save_signature modname tsg outputprefix source_file initial_env cmi =
  Cmt_format.save_cmt  (outputprefix ^ ".cmti") modname
    (Cmt_format.Interface tsg) (Some source_file) initial_env (Some cmi)

let type_interface env ast =
  begin
    let map = Typetexp.emit_external_warnings in
    ignore (map.Ast_mapper.signature map ast)
  end;
  transl_signature env ast

(* "Packaging" of several compilation units into one unit
   having them as sub-modules.  *)

let rec package_signatures subst = function
    [] -> []
  | (name, sg) :: rem ->
      let sg' = Subst.signature subst sg in
      let oldid = Ident.create_persistent name
      and newid = Ident.create name in
      Sig_module(newid, {md_type=Mty_signature sg';
                         md_attributes=[];
                         md_loc=Location.none;
                        },
                 Trec_not) ::
      package_signatures (Subst.add_module oldid (Pident newid) subst) rem

let package_units initial_env objfiles cmifile modulename =
  (* Read the signatures of the units *)
  let units =
    List.map
      (fun f ->
         let pref = chop_extensions f in
         let modname = String.capitalize_ascii(Filename.basename pref) in
         let sg = Env.read_signature modname (pref ^ ".cmi") in
         if Filename.check_suffix f ".cmi" &&
            not(Mtype.no_code_needed_sig Env.initial_safe_string sg)
         then raise(Error(Location.none, Env.empty,
                          Implementation_is_required f));
         (modname, Env.read_signature modname (pref ^ ".cmi")))
      objfiles in
  (* Compute signature of packaged unit *)
  Ident.reinit();
  let sg = package_signatures Subst.identity units in
  (* See if explicit interface is provided *)
  let prefix = chop_extension_if_any cmifile in
  let mlifile = prefix ^ !Config.interface_suffix in

  let mli_status = !Clflags.assume_no_mli in
  if (mli_status = Clflags.Mli_na && Sys.file_exists mlifile) || (mli_status = Clflags.Mli_exists) then begin

    if not (Sys.file_exists cmifile) then begin
      raise(Error(Location.in_file mlifile, Env.empty,
                  Interface_not_compiled mlifile))
    end;
    let dclsig = Env.read_signature modulename cmifile in
    Cmt_format.save_cmt  (prefix ^ ".cmt") modulename
      (Cmt_format.Packed (sg, objfiles)) None initial_env  None ;
    Includemod.compunit initial_env "(obtained by packing)" sg mlifile dclsig
  end else begin
    (* Determine imports *)
    let unit_names = List.map fst units in
    let imports =
      List.filter
        (fun (name, crc) -> not (List.mem name unit_names))
        (Env.imports()) in
    (* Write packaged signature *)
    if not !Clflags.dont_write_files then begin
      let sg =
        Env.save_signature_with_imports sg modulename
          (prefix ^ ".cmi") imports in
      Cmt_format.save_cmt (prefix ^ ".cmt")  modulename
        (Cmt_format.Packed (sg, objfiles)) None initial_env (Some sg)
    end;
    Tcoerce_none
  end

(* Error report *)

open Printtyp

let report_error ppf = function
    Cannot_apply mty ->
      fprintf ppf
        "@[This module is not a functor; it has type@ %a@]" modtype mty
  | Not_included errs ->
      fprintf ppf
        "@[<v>Signature mismatch:@ %a@]" Includemod.report_error errs
  | Cannot_eliminate_dependency mty ->
      fprintf ppf
        "@[This functor has type@ %a@ \
           The parameter cannot be eliminated in the result type.@  \
           Please bind the argument to a module identifier.@]" modtype mty
  | Signature_expected -> fprintf ppf "This module type is not a signature"
  | Structure_expected mty ->
      fprintf ppf
        "@[This module is not a structure; it has type@ %a" modtype mty
  | With_no_component lid ->
      fprintf ppf
        "@[The signature constrained by `with' has no component named %a@]"
        longident lid
  | With_mismatch(lid, explanation) ->
      fprintf ppf
        "@[<v>\
           @[In this `with' constraint, the new definition of %a@ \
             does not match its original definition@ \
             in the constrained signature:@]@ \
           %a@]"
        longident lid Includemod.report_error explanation
  | Repeated_name(kind, name) ->
      fprintf ppf
        "@[Multiple definition of the %s name %s.@ \
           Names must be unique in a given structure or signature.@]" kind name
  | Non_generalizable typ ->
      fprintf ppf
        "@[The type of this expression,@ %a,@ \
           contains type variables that cannot be generalized@]" type_scheme typ
  | Non_generalizable_class (id, desc) ->
      fprintf ppf
        "@[The type of this class,@ %a,@ \
           contains type variables that cannot be generalized@]"
        (class_declaration id) desc
  | Non_generalizable_module mty ->
      fprintf ppf
        "@[The type of this module,@ %a,@ \
           contains type variables that cannot be generalized@]" modtype mty
  | Implementation_is_required intf_name ->
      fprintf ppf
        "@[The interface %a@ declares values, not just types.@ \
           An implementation must be provided.@]"
        Location.print_filename intf_name
  | Interface_not_compiled intf_name ->
      fprintf ppf
        "@[Could not find the .cmi file for interface@ %a.@]"
        Location.print_filename intf_name
  | Not_allowed_in_functor_body ->
      fprintf ppf
        "@[This expression creates fresh types.@ %s@]"
        "It is not allowed inside applicative functors."
  | With_need_typeconstr ->
      fprintf ppf
        "Only type constructors with identical parameters can be substituted."
  | Not_a_packed_module ty ->
      fprintf ppf
        "This expression is not a packed module. It has type@ %a"
        type_expr ty
  | Incomplete_packed_module ty ->
      fprintf ppf
        "The type of this packed module contains variables:@ %a"
        type_expr ty
  | Scoping_pack (lid, ty) ->
      fprintf ppf
        "The type %a in this module cannot be exported.@ " longident lid;
      fprintf ppf
        "Its type contains local dependencies:@ %a" type_expr ty
  | Recursive_module_require_explicit_type ->
      fprintf ppf "Recursive modules require an explicit module type."
  | Apply_generative ->
      fprintf ppf "This is a generative functor. It can only be applied to ()"

let report_error env ppf err =
  Printtyp.wrap_printing_env env (fun () -> report_error ppf err)

let () =
  Location.register_error_of_exn
    (function
      | Error (loc, env, err) ->
        Some (Location.error_of_printer loc (report_error env) err)
      | Error_forward err ->
        Some err
      | _ ->
        None
    )

end
module Ocaml_typed_tree_main
= struct
(*#1 "ocaml_typed_tree_main.ml"*)
let suites :  Mt.pair_suites ref  = ref []
let test_id = ref 0
let eq loc x y =
  incr test_id ;
  suites :=
    (loc ^" id " ^ (string_of_int !test_id), (fun _ -> Mt.Eq(x,y))) :: !suites

let v str =
  str
  |> Lexing.from_string
  |> Parse.implementation

let ( ) =
  begin
    Clflags.dont_write_files := true;
    Clflags.unsafe_string := false;
    Clflags.debug := true;
    Clflags.record_event_when_debug := false;
    Clflags.binary_annotations := false;
    Clflags.nopervasives := true;
    Clflags.assume_no_mli := Mli_non_exists
  end

let x =
  let modulename = "Test" in
  Typemod.type_implementation modulename modulename modulename Env.empty (v {|
type int
external ( ~- ) : int -> int = "%negint"
external ( ~+ ) : int -> int = "%identity"
external succ : int -> int = "%succint"
external pred : int -> int = "%predint"
external ( + ) : int -> int -> int = "%addint"
external ( - ) : int -> int -> int = "%subint"
external ( * ) : int -> int -> int = "%mulint"
external ( / ) : int -> int -> int = "%divint"
external ( mod ) : int -> int -> int = "%modint"
 let f x y = x + y|});;


let () =
  match x with
  | ({Typedtree.str_items =
        {Typedtree.str_desc =
           Typedtree.Tstr_type
             [{Typedtree.typ_id = { name = "int"; flags = 0};
               typ_name =
                 {Asttypes.txt = "int";
                  loc =
                    {Location.loc_start =
                       {Lexing.pos_fname = ""; pos_lnum = 2; pos_bol = 1;
                        pos_cnum = 6};
                     loc_end =
                       {Lexing.pos_fname = ""; pos_lnum = 2; pos_bol = 1;
                        pos_cnum = 9};
                     loc_ghost = false}};
               typ_params = [];
               typ_type =
                 {Types.type_params = []; type_arity = 0;
                  type_kind = Types.Type_abstract; type_private = Asttypes.Public;
                  type_manifest = None; type_variance = [];
                  type_newtype_level = None;
                  type_loc =
                    {Location.loc_start =
                       {Lexing.pos_fname = ""; pos_lnum = 2; pos_bol = 1;
                        pos_cnum = 1};
                     loc_end =
                       {Lexing.pos_fname = ""; pos_lnum = 2; pos_bol = 1;
                        pos_cnum = 9};
                     loc_ghost = false};
                  type_attributes = []};
               typ_cstrs = []; typ_kind = Typedtree.Ttype_abstract;
               typ_private = Asttypes.Public; typ_manifest = None;
               typ_loc =
                 {Location.loc_start =
                    {Lexing.pos_fname = ""; pos_lnum = 2; pos_bol = 1; pos_cnum = 1};
                  loc_end =
                    {Lexing.pos_fname = ""; pos_lnum = 2; pos_bol = 1; pos_cnum = 9};
                  loc_ghost = false};
               typ_attributes = []}];
         str_loc =
           {Location.loc_start =
              {Lexing.pos_fname = ""; pos_lnum = 2; pos_bol = 1; pos_cnum = 1};
            loc_end =
              {Lexing.pos_fname = ""; pos_lnum = 2; pos_bol = 1; pos_cnum = 9};
            loc_ghost = false};
         str_env = _} ::
      {Typedtree.str_desc =
         Typedtree.Tstr_primitive
           {Typedtree.val_id = { name = "~-"; flags = 0};
            val_name =
              {Asttypes.txt = "~-";
               loc =
                 {Location.loc_start =
                    {Lexing.pos_fname = ""; pos_lnum = 3; pos_bol = 10;
                     pos_cnum = 19};
                  loc_end =
                    {Lexing.pos_fname = ""; pos_lnum = 3; pos_bol = 10;
                     pos_cnum = 25};
                  loc_ghost = false}};
            val_desc =
              {Typedtree.ctyp_desc =
                 Typedtree.Ttyp_arrow ("",
                                       {Typedtree.ctyp_desc =
                                          Typedtree.Ttyp_constr
                                            (Path.Pident { name = "int"; flags = 0},
                                             {Asttypes.txt = Longident.Lident "int";
                                              loc =
                                                {Location.loc_start =
                                                   {Lexing.pos_fname = ""; pos_lnum = 3; pos_bol = 10;
                                                    pos_cnum = 28};
                                                 loc_end =
                                                   {Lexing.pos_fname = ""; pos_lnum = 3; pos_bol = 10;
                                                    pos_cnum = 31};
                                                 loc_ghost = false}},
                                             []);
                                        ctyp_type =
                                          {Types.desc =
                                             Types.Tconstr
                                               (Path.Pident {name = "int"; flags = 0},
                                                [], {contents = Types.Mnil});
                                           };
                                        ctyp_env = _;
                                                   ctyp_loc =
                                                   {Location.loc_start =
                                                      {Lexing.pos_fname = ""; pos_lnum = 3; pos_bol = 10;
                                                       pos_cnum = 28};
                                                    loc_end =
                                                      {Lexing.pos_fname = ""; pos_lnum = 3; pos_bol = 10;
                                                       pos_cnum = 31};
                                                    loc_ghost = false};
                                        ctyp_attributes = []},
                                       {Typedtree.ctyp_desc =
                                          Typedtree.Ttyp_constr
                                            (Path.Pident { name = "int"; flags = 0},
                                             {Asttypes.txt = Longident.Lident "int";
                                              loc =
                                                {Location.loc_start =
                                                   {Lexing.pos_fname = ""; pos_lnum = 3; pos_bol = 10;
                                                    pos_cnum = 35};
                                                 loc_end =
                                                   {Lexing.pos_fname = ""; pos_lnum = 3; pos_bol = 10;
                                                    pos_cnum = 38};
                                                 loc_ghost = false}},
                                             []);
                                        ctyp_type =
                                          {Types.desc =
                                             Types.Tconstr
                                               (Path.Pident { name = "int"; flags = 0},
                                                [], {contents = Types.Mnil});
                                          };
                                        ctyp_env = _;
                                                   ctyp_loc =
                                                   {Location.loc_start =
                                                      {Lexing.pos_fname = ""; pos_lnum = 3; pos_bol = 10;
                                                       pos_cnum = 35};
                                                    loc_end =
                                                      {Lexing.pos_fname = ""; pos_lnum = 3; pos_bol = 10;
                                                       pos_cnum = 38};
                                                    loc_ghost = false};
                                        ctyp_attributes = []});
               ctyp_type =
                 {Types.desc =
                    Types.Tarrow ("",
                                  {Types.desc =
                                     Types.Tconstr
                                       (Path.Pident { name = "int"; flags = 0},
                                        [], {contents = Types.Mnil});
                                    },
                                  {Types.desc =
                                     Types.Tconstr
                                       (Path.Pident {name = "int"; flags = 0},
                                        [], {contents = Types.Mnil});
                                   },
                                  Types.Cok);
                   };
               ctyp_env = _;
                          ctyp_loc =
                          {Location.loc_start =
                             {Lexing.pos_fname = ""; pos_lnum = 3; pos_bol = 10;
                              pos_cnum = 28};
                           loc_end =
                             {Lexing.pos_fname = ""; pos_lnum = 3; pos_bol = 10;
                              pos_cnum = 38};
                           loc_ghost = false};
               ctyp_attributes = []};
            val_val =
              {Types.val_type =
                 {Types.desc =
                    Types.Tarrow ("",
                                  {Types.desc =
                                     Types.Tconstr
                                       (Path.Pident { name = "int"; flags = 0},
                                        [], {contents = Types.Mnil});
                                  },
                                  {Types.desc =
                                     Types.Tconstr
                                       (Path.Pident { name = "int"; flags = 0},
                                        [], {contents = Types.Mnil});
                                   },
                                  Types.Cok);
                  };
               val_kind =
                 Types.Val_prim
                   {Primitive.prim_name = "%negint"; prim_arity = 1;
                    prim_alloc = true; prim_native_name = "";
                    prim_native_float = false};
               val_loc =
                 {Location.loc_start =
                    {Lexing.pos_fname = ""; pos_lnum = 3; pos_bol = 10;
                     pos_cnum = 10};
                  loc_end =
                    {Lexing.pos_fname = ""; pos_lnum = 3; pos_bol = 10;
                     pos_cnum = 50};
                  loc_ghost = false};
               val_attributes = []};
            val_prim = _; val_loc = _ ; val_attributes = _};
       str_loc = _ ; str_env = _} :: _
     ;
      str_type = _; str_final_env = _},
     _) -> eq __LOC__ true true
  | _ -> eq __LOC__ true false
    (* [%debugger] ; Js.log x *)

let () =
  Mt.from_pair_suites __MODULE__ !suites
(* local variables: *)
(* compile-command: "ocamlc.opt -c -I +compiler-libs ocaml_typed_tree_main.ml" *)
(* end: *)

end
