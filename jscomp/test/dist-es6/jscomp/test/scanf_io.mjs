// Generated by Melange

import * as List from "melange/jscomp/stdlib-412/stdlib_modules/list.mjs";
import * as Bytes from "melange/jscomp/stdlib-412/stdlib_modules/bytes.mjs";
import * as Curry from "melange/lib/es6/curry.mjs";
import * as Scanf from "melange/jscomp/stdlib-412/stdlib_modules/scanf.mjs";
import * as $$Buffer from "melange/jscomp/stdlib-412/stdlib_modules/buffer.mjs";
import * as Digest from "melange/jscomp/stdlib-412/stdlib_modules/digest.mjs";
import * as Printf from "melange/jscomp/stdlib-412/stdlib_modules/printf.mjs";
import * as Stdlib from "melange.stdlib/jscomp/stdlib-412/stdlib.mjs";
import * as Caml_io from "melange/lib/es6/caml_io.mjs";
import * as Caml_obj from "melange/lib/es6/caml_obj.mjs";
import * as Caml_bytes from "melange/lib/es6/caml_bytes.mjs";
import * as Caml_js_exceptions from "melange/lib/es6/caml_js_exceptions.mjs";
import * as Caml_external_polyfill from "melange/lib/es6/caml_external_polyfill.mjs";

var tscanf_data_file = "tscanf_data";

var tscanf_data_file_lines = {
  hd: [
    "Objective",
    "Caml"
  ],
  tl: /* [] */0
};

function create_tscanf_data(ob, lines) {
  var add_line = function (param) {
    $$Buffer.add_string(ob, Curry._1(Printf.sprintf(/* Format */{
                  _0: {
                    TAG: /* Caml_string */3,
                    _0: /* No_padding */0,
                    _1: /* End_of_format */0
                  },
                  _1: "%S"
                }), param[0]));
    $$Buffer.add_string(ob, " -> ");
    $$Buffer.add_string(ob, Curry._1(Printf.sprintf(/* Format */{
                  _0: {
                    TAG: /* Caml_string */3,
                    _0: /* No_padding */0,
                    _1: /* End_of_format */0
                  },
                  _1: "%S"
                }), param[1]));
    $$Buffer.add_string(ob, ";\n");
  };
  List.iter(add_line, lines);
}

function write_tscanf_data_file(fname, lines) {
  var oc = Stdlib.open_out(fname);
  var ob = $$Buffer.create(42);
  create_tscanf_data(ob, lines);
  $$Buffer.output_buffer(oc, ob);
  Caml_io.caml_ml_flush(oc);
  Caml_external_polyfill.resolve("caml_ml_close_channel")(oc);
}

function get_lines(fname) {
  var ib = Scanf.Scanning.from_file(fname);
  var l = {
    contents: /* [] */0
  };
  try {
    while(!Scanf.Scanning.end_of_input(ib)) {
      Curry._1(Scanf.bscanf(ib, /* Format */{
                _0: {
                  TAG: /* Char_literal */12,
                  _0: /* ' ' */32,
                  _1: {
                    TAG: /* Caml_string */3,
                    _0: /* No_padding */0,
                    _1: {
                      TAG: /* String_literal */11,
                      _0: " -> ",
                      _1: {
                        TAG: /* Caml_string */3,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* String_literal */11,
                          _0: "; ",
                          _1: /* End_of_format */0
                        }
                      }
                    }
                  }
                },
                _1: " %S -> %S; "
              }), (function (x, y) {
              l.contents = {
                hd: [
                  x,
                  y
                ],
                tl: l.contents
              };
            }));
    };
    return List.rev(l.contents);
  }
  catch (raw_s){
    var s = Caml_js_exceptions.internalToOCamlException(raw_s);
    if (s.RE_EXN_ID === Scanf.Scan_failure) {
      var s$1 = Curry._2(Printf.sprintf(/* Format */{
                _0: {
                  TAG: /* String_literal */11,
                  _0: "in file ",
                  _1: {
                    TAG: /* String */2,
                    _0: /* No_padding */0,
                    _1: {
                      TAG: /* String_literal */11,
                      _0: ", ",
                      _1: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: /* End_of_format */0
                      }
                    }
                  }
                },
                _1: "in file %s, %s"
              }), fname, s._1);
      throw {
            RE_EXN_ID: "Failure",
            _1: s$1,
            Error: new Error()
          };
    }
    if (s.RE_EXN_ID === Stdlib.End_of_file) {
      var s$2 = Curry._1(Printf.sprintf(/* Format */{
                _0: {
                  TAG: /* String_literal */11,
                  _0: "in file ",
                  _1: {
                    TAG: /* String */2,
                    _0: /* No_padding */0,
                    _1: {
                      TAG: /* String_literal */11,
                      _0: ", unexpected end of file",
                      _1: /* End_of_format */0
                    }
                  }
                },
                _1: "in file %s, unexpected end of file"
              }), fname);
      throw {
            RE_EXN_ID: "Failure",
            _1: s$2,
            Error: new Error()
          };
    }
    throw s;
  }
}

function add_digest_ib(ob, ib) {
  var scan_line = function (ib, f) {
    return Curry._1(Scanf.bscanf(ib, /* Format */{
                    _0: {
                      TAG: /* Scan_char_set */20,
                      _0: undefined,
                      _1: "\xff\xdb\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff",
                      _2: {
                        TAG: /* Char_literal */12,
                        _0: /* '\n' */10,
                        _1: /* End_of_format */0
                      }
                    },
                    _1: "%[^\n\r]\n"
                  }), f);
  };
  var output_line_digest = function (s) {
    $$Buffer.add_string(ob, s);
    $$Buffer.add_char(ob, /* '#' */35);
    var s$1 = Digest.to_hex(Digest.string(s));
    $$Buffer.add_string(ob, Caml_bytes.bytes_to_string(Bytes.uppercase(Caml_bytes.bytes_of_string(s$1))));
    $$Buffer.add_char(ob, /* '\n' */10);
  };
  try {
    while(true) {
      scan_line(ib, output_line_digest);
    };
    return ;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Stdlib.End_of_file) {
      return ;
    }
    throw exn;
  }
}

function digest_file(fname) {
  var ib = Scanf.Scanning.from_file(fname);
  var ob = $$Buffer.create(42);
  add_digest_ib(ob, ib);
  return $$Buffer.contents(ob);
}

function test54(param) {
  return Caml_obj.caml_equal(get_lines(tscanf_data_file), tscanf_data_file_lines);
}

function test55(param) {
  var ob = $$Buffer.create(42);
  create_tscanf_data(ob, tscanf_data_file_lines);
  var s = $$Buffer.contents(ob);
  ob.position = 0;
  var ib = Scanf.Scanning.from_string(s);
  add_digest_ib(ob, ib);
  var tscanf_data_file_lines_digest = $$Buffer.contents(ob);
  return digest_file(tscanf_data_file) === tscanf_data_file_lines_digest;
}

export {
  tscanf_data_file ,
  tscanf_data_file_lines ,
  create_tscanf_data ,
  write_tscanf_data_file ,
  get_lines ,
  add_digest_ib ,
  digest_file ,
  test54 ,
  test55 ,
}
/* Scanf Not a pure module */
