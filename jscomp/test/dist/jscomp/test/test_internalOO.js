// Generated by Melange
'use strict';

const Caml = require("melange.js/caml.js");
const Caml_array = require("melange.js/caml_array.js");
const Caml_int32 = require("melange.js/caml_int32.js");
const Caml_js_exceptions = require("melange.js/caml_js_exceptions.js");
const Caml_obj = require("melange.js/caml_obj.js");
const Caml_oo = require("melange.js/caml_oo.js");
const Caml_option = require("melange.js/caml_option.js");
const Caml_string = require("melange.js/caml_string.js");
const Curry = require("melange.js/curry.js");
const Stdlib = require("melange/stdlib.js");
const Stdlib__Array = require("melange/array.js");
const Stdlib__List = require("melange/list.js");
const Stdlib__Seq = require("melange/seq.js");
const Stdlib__Sys = require("melange/sys.js");

function copy(o) {
  return Caml_oo.caml_set_oo_id(Caml_obj.caml_obj_dup(o));
}

const params = {
  compact_table: true,
  copy_parent: true,
  clean_when_copying: true,
  retry_count: 3,
  bucket_small_size: 16
};

const step = Stdlib__Sys.word_size / 16 | 0;

function public_method_label(s) {
  let accu = 0;
  for (let i = 0 ,i_finish = s.length; i < i_finish; ++i) {
    accu = Math.imul(223, accu) + Caml_string.get(s, i) | 0;
  }
  accu = accu & 2147483647;
  if (accu > 1073741823) {
    return accu - -2147483648 | 0;
  } else {
    return accu;
  }
}

const compare = Caml.caml_string_compare;

const funarg = {
  compare: compare
};

function height(param) {
  if (/* tag */typeof param === "number" || typeof param === "string") {
    return 0;
  } else {
    return param.h;
  }
}

function create(l, x, d, r) {
  const hl = height(l);
  const hr = height(r);
  return {
          TAG: /* Node */0,
          l: l,
          v: x,
          d: d,
          r: r,
          h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        };
}

function singleton(x, d) {
  return {
          TAG: /* Node */0,
          l: /* Empty */0,
          v: x,
          d: d,
          r: /* Empty */0,
          h: 1
        };
}

function bal(l, x, d, r) {
  let hl;
  hl = /* tag */typeof l === "number" || typeof l === "string" ? 0 : l.h;
  let hr;
  hr = /* tag */typeof r === "number" || typeof r === "string" ? 0 : r.h;
  if (hl > (hr + 2 | 0)) {
    if (/* tag */typeof l === "number" || typeof l === "string") {
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
                MEL_EXN_ID: "Invalid_argument",
                _1: "Map.bal"
              });
    }
    const lr = l.r;
    const ld = l.d;
    const lv = l.v;
    const ll = l.l;
    if (height(ll) >= height(lr)) {
      return create(ll, lv, ld, create(lr, x, d, r));
    }
    if (!/* tag */(typeof lr === "number" || typeof lr === "string")) {
      return create(create(ll, lv, ld, lr.l), lr.v, lr.d, create(lr.r, x, d, r));
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Map.bal"
            });
  }
  if (hr <= (hl + 2 | 0)) {
    return {
            TAG: /* Node */0,
            l: l,
            v: x,
            d: d,
            r: r,
            h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          };
  }
  if (/* tag */typeof r === "number" || typeof r === "string") {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Map.bal"
            });
  }
  const rr = r.r;
  const rd = r.d;
  const rv = r.v;
  const rl = r.l;
  if (height(rr) >= height(rl)) {
    return create(create(l, x, d, rl), rv, rd, rr);
  }
  if (!/* tag */(typeof rl === "number" || typeof rl === "string")) {
    return create(create(l, x, d, rl.l), rl.v, rl.d, create(rl.r, rv, rd, rr));
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Map.bal"
          });
}

function is_empty(param) {
  if (/* tag */typeof param === "number" || typeof param === "string") {
    return true;
  } else {
    return false;
  }
}

function add(x, data, m) {
  if (/* tag */typeof m === "number" || typeof m === "string") {
    return {
            TAG: /* Node */0,
            l: /* Empty */0,
            v: x,
            d: data,
            r: /* Empty */0,
            h: 1
          };
  }
  const r = m.r;
  const d = m.d;
  const v = m.v;
  const l = m.l;
  const c = Curry._2(funarg.compare, x, v);
  if (c === 0) {
    if (d === data) {
      return m;
    } else {
      return {
              TAG: /* Node */0,
              l: l,
              v: x,
              d: data,
              r: r,
              h: m.h
            };
    }
  }
  if (c < 0) {
    const ll = add(x, data, l);
    if (l === ll) {
      return m;
    } else {
      return bal(ll, v, d, r);
    }
  }
  const rr = add(x, data, r);
  if (r === rr) {
    return m;
  } else {
    return bal(l, v, d, rr);
  }
}

function find(x, _param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
    }
    const c = Curry._2(funarg.compare, x, param.v);
    if (c === 0) {
      return param.d;
    }
    _param = c < 0 ? param.l : param.r;
    continue ;
  };
}

function find_first(f, _param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
    }
    const v = param.v;
    if (Curry._1(f, v)) {
      let _v0 = v;
      let _d0 = param.d;
      let _param$1 = param.l;
      while(true) {
        const param$1 = _param$1;
        const d0 = _d0;
        const v0 = _v0;
        if (/* tag */typeof param$1 === "number" || typeof param$1 === "string") {
          return [
                  v0,
                  d0
                ];
        }
        const v$1 = param$1.v;
        if (Curry._1(f, v$1)) {
          _param$1 = param$1.l;
          _d0 = param$1.d;
          _v0 = v$1;
          continue ;
        }
        _param$1 = param$1.r;
        continue ;
      };
    }
    _param = param.r;
    continue ;
  };
}

function find_first_opt(f, _param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      return ;
    }
    const v = param.v;
    if (Curry._1(f, v)) {
      let _v0 = v;
      let _d0 = param.d;
      let _param$1 = param.l;
      while(true) {
        const param$1 = _param$1;
        const d0 = _d0;
        const v0 = _v0;
        if (/* tag */typeof param$1 === "number" || typeof param$1 === "string") {
          return [
                  v0,
                  d0
                ];
        }
        const v$1 = param$1.v;
        if (Curry._1(f, v$1)) {
          _param$1 = param$1.l;
          _d0 = param$1.d;
          _v0 = v$1;
          continue ;
        }
        _param$1 = param$1.r;
        continue ;
      };
    }
    _param = param.r;
    continue ;
  };
}

function find_last(f, _param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
    }
    const v = param.v;
    if (Curry._1(f, v)) {
      let _v0 = v;
      let _d0 = param.d;
      let _param$1 = param.r;
      while(true) {
        const param$1 = _param$1;
        const d0 = _d0;
        const v0 = _v0;
        if (/* tag */typeof param$1 === "number" || typeof param$1 === "string") {
          return [
                  v0,
                  d0
                ];
        }
        const v$1 = param$1.v;
        if (Curry._1(f, v$1)) {
          _param$1 = param$1.r;
          _d0 = param$1.d;
          _v0 = v$1;
          continue ;
        }
        _param$1 = param$1.l;
        continue ;
      };
    }
    _param = param.l;
    continue ;
  };
}

function find_last_opt(f, _param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      return ;
    }
    const v = param.v;
    if (Curry._1(f, v)) {
      let _v0 = v;
      let _d0 = param.d;
      let _param$1 = param.r;
      while(true) {
        const param$1 = _param$1;
        const d0 = _d0;
        const v0 = _v0;
        if (/* tag */typeof param$1 === "number" || typeof param$1 === "string") {
          return [
                  v0,
                  d0
                ];
        }
        const v$1 = param$1.v;
        if (Curry._1(f, v$1)) {
          _param$1 = param$1.r;
          _d0 = param$1.d;
          _v0 = v$1;
          continue ;
        }
        _param$1 = param$1.l;
        continue ;
      };
    }
    _param = param.l;
    continue ;
  };
}

function find_opt(x, _param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      return ;
    }
    const c = Curry._2(funarg.compare, x, param.v);
    if (c === 0) {
      return Caml_option.some(param.d);
    }
    _param = c < 0 ? param.l : param.r;
    continue ;
  };
}

function mem(x, _param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      return false;
    }
    const c = Curry._2(funarg.compare, x, param.v);
    if (c === 0) {
      return true;
    }
    _param = c < 0 ? param.l : param.r;
    continue ;
  };
}

function min_binding(_param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
    }
    const l = param.l;
    if (/* tag */typeof l === "number" || typeof l === "string") {
      return [
              param.v,
              param.d
            ];
    }
    _param = l;
    continue ;
  };
}

function min_binding_opt(_param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      return ;
    }
    const l = param.l;
    if (/* tag */typeof l === "number" || typeof l === "string") {
      return [
              param.v,
              param.d
            ];
    }
    _param = l;
    continue ;
  };
}

function max_binding(_param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
    }
    let tmp = param.r;
    if (/* tag */typeof tmp === "number" || typeof tmp === "string") {
      return [
              param.v,
              param.d
            ];
    }
    _param = param.r;
    continue ;
  };
}

function max_binding_opt(_param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      return ;
    }
    let tmp = param.r;
    if (/* tag */typeof tmp === "number" || typeof tmp === "string") {
      return [
              param.v,
              param.d
            ];
    }
    _param = param.r;
    continue ;
  };
}

function remove_min_binding(param) {
  if (/* tag */typeof param === "number" || typeof param === "string") {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Map.remove_min_elt"
            });
  }
  const l = param.l;
  if (/* tag */typeof l === "number" || typeof l === "string") {
    return param.r;
  } else {
    return bal(remove_min_binding(l), param.v, param.d, param.r);
  }
}

function merge(t1, t2) {
  if (/* tag */typeof t1 === "number" || typeof t1 === "string") {
    return t2;
  }
  if (/* tag */typeof t2 === "number" || typeof t2 === "string") {
    return t1;
  }
  const match = min_binding(t2);
  return bal(t1, match[0], match[1], remove_min_binding(t2));
}

function remove(x, m) {
  if (/* tag */typeof m === "number" || typeof m === "string") {
    return /* Empty */0;
  }
  const r = m.r;
  const d = m.d;
  const v = m.v;
  const l = m.l;
  const c = Curry._2(funarg.compare, x, v);
  if (c === 0) {
    return merge(l, r);
  }
  if (c < 0) {
    const ll = remove(x, l);
    if (l === ll) {
      return m;
    } else {
      return bal(ll, v, d, r);
    }
  }
  const rr = remove(x, r);
  if (r === rr) {
    return m;
  } else {
    return bal(l, v, d, rr);
  }
}

function update(x, f, m) {
  if (/* tag */typeof m === "number" || typeof m === "string") {
    const data = Curry._1(f, undefined);
    if (data !== undefined) {
      return {
              TAG: /* Node */0,
              l: /* Empty */0,
              v: x,
              d: Caml_option.valFromOption(data),
              r: /* Empty */0,
              h: 1
            };
    } else {
      return /* Empty */0;
    }
  }
  const r = m.r;
  const d = m.d;
  const v = m.v;
  const l = m.l;
  const c = Curry._2(funarg.compare, x, v);
  if (c === 0) {
    const data$1 = Curry._1(f, Caml_option.some(d));
    if (data$1 === undefined) {
      return merge(l, r);
    }
    const data$2 = Caml_option.valFromOption(data$1);
    if (d === data$2) {
      return m;
    } else {
      return {
              TAG: /* Node */0,
              l: l,
              v: x,
              d: data$2,
              r: r,
              h: m.h
            };
    }
  }
  if (c < 0) {
    const ll = update(x, f, l);
    if (l === ll) {
      return m;
    } else {
      return bal(ll, v, d, r);
    }
  }
  const rr = update(x, f, r);
  if (r === rr) {
    return m;
  } else {
    return bal(l, v, d, rr);
  }
}

function add_to_list(x, data, m) {
  const add = function (l) {
    if (l !== undefined) {
      return {
              hd: data,
              tl: l
            };
    } else {
      return {
              hd: data,
              tl: /* [] */0
            };
    }
  };
  return update(x, add, m);
}

function iter(f, _param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      return ;
    }
    iter(f, param.l);
    Curry._2(f, param.v, param.d);
    _param = param.r;
    continue ;
  };
}

function map(f, param) {
  if (/* tag */typeof param === "number" || typeof param === "string") {
    return /* Empty */0;
  }
  const l$p = map(f, param.l);
  const d$p = Curry._1(f, param.d);
  const r$p = map(f, param.r);
  return {
          TAG: /* Node */0,
          l: l$p,
          v: param.v,
          d: d$p,
          r: r$p,
          h: param.h
        };
}

function mapi(f, param) {
  if (/* tag */typeof param === "number" || typeof param === "string") {
    return /* Empty */0;
  }
  const v = param.v;
  const l$p = mapi(f, param.l);
  const d$p = Curry._2(f, v, param.d);
  const r$p = mapi(f, param.r);
  return {
          TAG: /* Node */0,
          l: l$p,
          v: v,
          d: d$p,
          r: r$p,
          h: param.h
        };
}

function fold(f, _m, _accu) {
  while(true) {
    const accu = _accu;
    const m = _m;
    if (/* tag */typeof m === "number" || typeof m === "string") {
      return accu;
    }
    _accu = Curry._3(f, m.v, m.d, fold(f, m.l, accu));
    _m = m.r;
    continue ;
  };
}

function for_all(p, _param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      return true;
    }
    if (!Curry._2(p, param.v, param.d)) {
      return false;
    }
    if (!for_all(p, param.l)) {
      return false;
    }
    _param = param.r;
    continue ;
  };
}

function exists(p, _param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      return false;
    }
    if (Curry._2(p, param.v, param.d)) {
      return true;
    }
    if (exists(p, param.l)) {
      return true;
    }
    _param = param.r;
    continue ;
  };
}

function add_min_binding(k, x, param) {
  if (/* tag */typeof param === "number" || typeof param === "string") {
    return singleton(k, x);
  } else {
    return bal(add_min_binding(k, x, param.l), param.v, param.d, param.r);
  }
}

function add_max_binding(k, x, param) {
  if (/* tag */typeof param === "number" || typeof param === "string") {
    return singleton(k, x);
  } else {
    return bal(param.l, param.v, param.d, add_max_binding(k, x, param.r));
  }
}

function join(l, v, d, r) {
  if (/* tag */typeof l === "number" || typeof l === "string") {
    return add_min_binding(v, d, r);
  }
  const lh = l.h;
  if (/* tag */typeof r === "number" || typeof r === "string") {
    return add_max_binding(v, d, l);
  }
  const rh = r.h;
  if (lh > (rh + 2 | 0)) {
    return bal(l.l, l.v, l.d, join(l.r, v, d, r));
  } else if (rh > (lh + 2 | 0)) {
    return bal(join(l, v, d, r.l), r.v, r.d, r.r);
  } else {
    return create(l, v, d, r);
  }
}

function concat(t1, t2) {
  if (/* tag */typeof t1 === "number" || typeof t1 === "string") {
    return t2;
  }
  if (/* tag */typeof t2 === "number" || typeof t2 === "string") {
    return t1;
  }
  const match = min_binding(t2);
  return join(t1, match[0], match[1], remove_min_binding(t2));
}

function concat_or_join(t1, v, d, t2) {
  if (d !== undefined) {
    return join(t1, v, Caml_option.valFromOption(d), t2);
  } else {
    return concat(t1, t2);
  }
}

function split(x, param) {
  if (/* tag */typeof param === "number" || typeof param === "string") {
    return [
            /* Empty */0,
            undefined,
            /* Empty */0
          ];
  }
  const r = param.r;
  const d = param.d;
  const v = param.v;
  const l = param.l;
  const c = Curry._2(funarg.compare, x, v);
  if (c === 0) {
    return [
            l,
            Caml_option.some(d),
            r
          ];
  }
  if (c < 0) {
    const match = split(x, l);
    return [
            match[0],
            match[1],
            join(match[2], v, d, r)
          ];
  }
  const match$1 = split(x, r);
  return [
          join(l, v, d, match$1[0]),
          match$1[1],
          match$1[2]
        ];
}

function merge$1(f, s1, s2) {
  if (/* tag */typeof s1 === "number" || typeof s1 === "string") {
    if (/* tag */typeof s2 === "number" || typeof s2 === "string") {
      return /* Empty */0;
    }
    
  } else {
    const v1 = s1.v;
    if (s1.h >= height(s2)) {
      const match = split(v1, s2);
      return concat_or_join(merge$1(f, s1.l, match[0]), v1, Curry._3(f, v1, Caml_option.some(s1.d), match[1]), merge$1(f, s1.r, match[2]));
    }
    
  }
  if (/* tag */typeof s2 === "number" || typeof s2 === "string") {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/stdlib/map.ml",
                408,
                10
              ]
            });
  }
  const v2 = s2.v;
  const match$1 = split(v2, s1);
  return concat_or_join(merge$1(f, match$1[0], s2.l), v2, Curry._3(f, v2, match$1[1], Caml_option.some(s2.d)), merge$1(f, match$1[2], s2.r));
}

function union(f, s1, s2) {
  if (/* tag */typeof s1 === "number" || typeof s1 === "string") {
    return s2;
  }
  const d1 = s1.d;
  const v1 = s1.v;
  if (/* tag */typeof s2 === "number" || typeof s2 === "string") {
    return s1;
  }
  const d2 = s2.d;
  const v2 = s2.v;
  if (s1.h >= s2.h) {
    const match = split(v1, s2);
    const d2$1 = match[1];
    const l = union(f, s1.l, match[0]);
    const r = union(f, s1.r, match[2]);
    if (d2$1 !== undefined) {
      return concat_or_join(l, v1, Curry._3(f, v1, d1, Caml_option.valFromOption(d2$1)), r);
    } else {
      return join(l, v1, d1, r);
    }
  }
  const match$1 = split(v2, s1);
  const d1$1 = match$1[1];
  const l$1 = union(f, match$1[0], s2.l);
  const r$1 = union(f, match$1[2], s2.r);
  if (d1$1 !== undefined) {
    return concat_or_join(l$1, v2, Curry._3(f, v2, Caml_option.valFromOption(d1$1), d2), r$1);
  } else {
    return join(l$1, v2, d2, r$1);
  }
}

function filter(p, m) {
  if (/* tag */typeof m === "number" || typeof m === "string") {
    return /* Empty */0;
  }
  const r = m.r;
  const d = m.d;
  const v = m.v;
  const l = m.l;
  const l$p = filter(p, l);
  const pvd = Curry._2(p, v, d);
  const r$p = filter(p, r);
  if (pvd) {
    if (l === l$p && r === r$p) {
      return m;
    } else {
      return join(l$p, v, d, r$p);
    }
  } else {
    return concat(l$p, r$p);
  }
}

function filter_map(f, param) {
  if (/* tag */typeof param === "number" || typeof param === "string") {
    return /* Empty */0;
  }
  const v = param.v;
  const l$p = filter_map(f, param.l);
  const fvd = Curry._2(f, v, param.d);
  const r$p = filter_map(f, param.r);
  if (fvd !== undefined) {
    return join(l$p, v, Caml_option.valFromOption(fvd), r$p);
  } else {
    return concat(l$p, r$p);
  }
}

function partition(p, param) {
  if (/* tag */typeof param === "number" || typeof param === "string") {
    return [
            /* Empty */0,
            /* Empty */0
          ];
  }
  const d = param.d;
  const v = param.v;
  const match = partition(p, param.l);
  const lf = match[1];
  const lt = match[0];
  const pvd = Curry._2(p, v, d);
  const match$1 = partition(p, param.r);
  const rf = match$1[1];
  const rt = match$1[0];
  if (pvd) {
    return [
            join(lt, v, d, rt),
            concat(lf, rf)
          ];
  } else {
    return [
            concat(lt, rt),
            join(lf, v, d, rf)
          ];
  }
}

function cons_enum(_m, _e) {
  while(true) {
    const e = _e;
    const m = _m;
    if (/* tag */typeof m === "number" || typeof m === "string") {
      return e;
    }
    _e = {
      TAG: /* More */0,
      _0: m.v,
      _1: m.d,
      _2: m.r,
      _3: e
    };
    _m = m.l;
    continue ;
  };
}

function compare$1(cmp, m1, m2) {
  let _e1 = cons_enum(m1, /* End */0);
  let _e2 = cons_enum(m2, /* End */0);
  while(true) {
    const e2 = _e2;
    const e1 = _e1;
    if (/* tag */typeof e1 === "number" || typeof e1 === "string") {
      if (/* tag */typeof e2 === "number" || typeof e2 === "string") {
        return 0;
      } else {
        return -1;
      }
    }
    if (/* tag */typeof e2 === "number" || typeof e2 === "string") {
      return 1;
    }
    const c = Curry._2(funarg.compare, e1._0, e2._0);
    if (c !== 0) {
      return c;
    }
    const c$1 = Curry._2(cmp, e1._1, e2._1);
    if (c$1 !== 0) {
      return c$1;
    }
    _e2 = cons_enum(e2._2, e2._3);
    _e1 = cons_enum(e1._2, e1._3);
    continue ;
  };
}

function equal(cmp, m1, m2) {
  let _e1 = cons_enum(m1, /* End */0);
  let _e2 = cons_enum(m2, /* End */0);
  while(true) {
    const e2 = _e2;
    const e1 = _e1;
    if (/* tag */typeof e1 === "number" || typeof e1 === "string") {
      if (/* tag */typeof e2 === "number" || typeof e2 === "string") {
        return true;
      } else {
        return false;
      }
    }
    if (/* tag */typeof e2 === "number" || typeof e2 === "string") {
      return false;
    }
    if (Curry._2(funarg.compare, e1._0, e2._0) !== 0) {
      return false;
    }
    if (!Curry._2(cmp, e1._1, e2._1)) {
      return false;
    }
    _e2 = cons_enum(e2._2, e2._3);
    _e1 = cons_enum(e1._2, e1._3);
    continue ;
  };
}

function cardinal(param) {
  if (/* tag */typeof param === "number" || typeof param === "string") {
    return 0;
  } else {
    return (cardinal(param.l) + 1 | 0) + cardinal(param.r) | 0;
  }
}

function bindings_aux(_accu, _param) {
  while(true) {
    const param = _param;
    const accu = _accu;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      return accu;
    }
    _param = param.l;
    _accu = {
      hd: [
        param.v,
        param.d
      ],
      tl: bindings_aux(accu, param.r)
    };
    continue ;
  };
}

function bindings(s) {
  return bindings_aux(/* [] */0, s);
}

function of_list(bs) {
  return Stdlib__List.fold_left((function (m, param) {
                return add(param[0], param[1], m);
              }), /* Empty */0, bs);
}

function add_seq(i, m) {
  return Stdlib__Seq.fold_left((function (m, param) {
                return add(param[0], param[1], m);
              }), m, i);
}

function of_seq(i) {
  return add_seq(i, /* Empty */0);
}

function seq_of_enum_(c, param) {
  if (/* tag */typeof c === "number" || typeof c === "string") {
    return /* Nil */0;
  }
  const partial_arg = cons_enum(c._2, c._3);
  return {
          TAG: /* Cons */0,
          _0: [
            c._0,
            c._1
          ],
          _1: (function (param) {
              return seq_of_enum_(partial_arg, param);
            })
        };
}

function to_seq(m) {
  const partial_arg = cons_enum(m, /* End */0);
  return function (param) {
    return seq_of_enum_(partial_arg, param);
  };
}

function snoc_enum(_s, _e) {
  while(true) {
    const e = _e;
    const s = _s;
    if (/* tag */typeof s === "number" || typeof s === "string") {
      return e;
    }
    _e = {
      TAG: /* More */0,
      _0: s.v,
      _1: s.d,
      _2: s.l,
      _3: e
    };
    _s = s.r;
    continue ;
  };
}

function rev_seq_of_enum_(c, param) {
  if (/* tag */typeof c === "number" || typeof c === "string") {
    return /* Nil */0;
  }
  const partial_arg = snoc_enum(c._2, c._3);
  return {
          TAG: /* Cons */0,
          _0: [
            c._0,
            c._1
          ],
          _1: (function (param) {
              return rev_seq_of_enum_(partial_arg, param);
            })
        };
}

function to_rev_seq(c) {
  const partial_arg = snoc_enum(c, /* End */0);
  return function (param) {
    return rev_seq_of_enum_(partial_arg, param);
  };
}

function to_seq_from(low, m) {
  const aux = function (low, _m, _c) {
    while(true) {
      const c = _c;
      const m = _m;
      if (/* tag */typeof m === "number" || typeof m === "string") {
        return c;
      }
      const r = m.r;
      const d = m.d;
      const v = m.v;
      const n = Curry._2(funarg.compare, v, low);
      if (n === 0) {
        return {
                TAG: /* More */0,
                _0: v,
                _1: d,
                _2: r,
                _3: c
              };
      }
      if (n < 0) {
        _m = r;
        continue ;
      }
      _c = {
        TAG: /* More */0,
        _0: v,
        _1: d,
        _2: r,
        _3: c
      };
      _m = m.l;
      continue ;
    };
  };
  const partial_arg = aux(low, m, /* End */0);
  return function (param) {
    return seq_of_enum_(partial_arg, param);
  };
}

const Vars = {
  empty: /* Empty */0,
  add: add,
  add_to_list: add_to_list,
  update: update,
  singleton: singleton,
  remove: remove,
  merge: merge$1,
  union: union,
  cardinal: cardinal,
  bindings: bindings,
  min_binding: min_binding,
  min_binding_opt: min_binding_opt,
  max_binding: max_binding,
  max_binding_opt: max_binding_opt,
  choose: min_binding,
  choose_opt: min_binding_opt,
  find: find,
  find_opt: find_opt,
  find_first: find_first,
  find_first_opt: find_first_opt,
  find_last: find_last,
  find_last_opt: find_last_opt,
  iter: iter,
  fold: fold,
  map: map,
  mapi: mapi,
  filter: filter,
  filter_map: filter_map,
  partition: partition,
  split: split,
  is_empty: is_empty,
  mem: mem,
  equal: equal,
  compare: compare$1,
  for_all: for_all,
  exists: exists,
  to_list: bindings,
  of_list: of_list,
  to_seq: to_seq,
  to_rev_seq: to_rev_seq,
  to_seq_from: to_seq_from,
  add_seq: add_seq,
  of_seq: of_seq
};

const compare$2 = Caml.caml_string_compare;

const funarg$1 = {
  compare: compare$2
};

function height$1(param) {
  if (/* tag */typeof param === "number" || typeof param === "string") {
    return 0;
  } else {
    return param.h;
  }
}

function create$1(l, x, d, r) {
  const hl = height$1(l);
  const hr = height$1(r);
  return {
          TAG: /* Node */0,
          l: l,
          v: x,
          d: d,
          r: r,
          h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        };
}

function singleton$1(x, d) {
  return {
          TAG: /* Node */0,
          l: /* Empty */0,
          v: x,
          d: d,
          r: /* Empty */0,
          h: 1
        };
}

function bal$1(l, x, d, r) {
  let hl;
  hl = /* tag */typeof l === "number" || typeof l === "string" ? 0 : l.h;
  let hr;
  hr = /* tag */typeof r === "number" || typeof r === "string" ? 0 : r.h;
  if (hl > (hr + 2 | 0)) {
    if (/* tag */typeof l === "number" || typeof l === "string") {
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
                MEL_EXN_ID: "Invalid_argument",
                _1: "Map.bal"
              });
    }
    const lr = l.r;
    const ld = l.d;
    const lv = l.v;
    const ll = l.l;
    if (height$1(ll) >= height$1(lr)) {
      return create$1(ll, lv, ld, create$1(lr, x, d, r));
    }
    if (!/* tag */(typeof lr === "number" || typeof lr === "string")) {
      return create$1(create$1(ll, lv, ld, lr.l), lr.v, lr.d, create$1(lr.r, x, d, r));
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Map.bal"
            });
  }
  if (hr <= (hl + 2 | 0)) {
    return {
            TAG: /* Node */0,
            l: l,
            v: x,
            d: d,
            r: r,
            h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          };
  }
  if (/* tag */typeof r === "number" || typeof r === "string") {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Map.bal"
            });
  }
  const rr = r.r;
  const rd = r.d;
  const rv = r.v;
  const rl = r.l;
  if (height$1(rr) >= height$1(rl)) {
    return create$1(create$1(l, x, d, rl), rv, rd, rr);
  }
  if (!/* tag */(typeof rl === "number" || typeof rl === "string")) {
    return create$1(create$1(l, x, d, rl.l), rl.v, rl.d, create$1(rl.r, rv, rd, rr));
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Map.bal"
          });
}

function is_empty$1(param) {
  if (/* tag */typeof param === "number" || typeof param === "string") {
    return true;
  } else {
    return false;
  }
}

function add$1(x, data, m) {
  if (/* tag */typeof m === "number" || typeof m === "string") {
    return {
            TAG: /* Node */0,
            l: /* Empty */0,
            v: x,
            d: data,
            r: /* Empty */0,
            h: 1
          };
  }
  const r = m.r;
  const d = m.d;
  const v = m.v;
  const l = m.l;
  const c = Curry._2(funarg$1.compare, x, v);
  if (c === 0) {
    if (d === data) {
      return m;
    } else {
      return {
              TAG: /* Node */0,
              l: l,
              v: x,
              d: data,
              r: r,
              h: m.h
            };
    }
  }
  if (c < 0) {
    const ll = add$1(x, data, l);
    if (l === ll) {
      return m;
    } else {
      return bal$1(ll, v, d, r);
    }
  }
  const rr = add$1(x, data, r);
  if (r === rr) {
    return m;
  } else {
    return bal$1(l, v, d, rr);
  }
}

function find$1(x, _param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
    }
    const c = Curry._2(funarg$1.compare, x, param.v);
    if (c === 0) {
      return param.d;
    }
    _param = c < 0 ? param.l : param.r;
    continue ;
  };
}

function find_first$1(f, _param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
    }
    const v = param.v;
    if (Curry._1(f, v)) {
      let _v0 = v;
      let _d0 = param.d;
      let _param$1 = param.l;
      while(true) {
        const param$1 = _param$1;
        const d0 = _d0;
        const v0 = _v0;
        if (/* tag */typeof param$1 === "number" || typeof param$1 === "string") {
          return [
                  v0,
                  d0
                ];
        }
        const v$1 = param$1.v;
        if (Curry._1(f, v$1)) {
          _param$1 = param$1.l;
          _d0 = param$1.d;
          _v0 = v$1;
          continue ;
        }
        _param$1 = param$1.r;
        continue ;
      };
    }
    _param = param.r;
    continue ;
  };
}

function find_first_opt$1(f, _param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      return ;
    }
    const v = param.v;
    if (Curry._1(f, v)) {
      let _v0 = v;
      let _d0 = param.d;
      let _param$1 = param.l;
      while(true) {
        const param$1 = _param$1;
        const d0 = _d0;
        const v0 = _v0;
        if (/* tag */typeof param$1 === "number" || typeof param$1 === "string") {
          return [
                  v0,
                  d0
                ];
        }
        const v$1 = param$1.v;
        if (Curry._1(f, v$1)) {
          _param$1 = param$1.l;
          _d0 = param$1.d;
          _v0 = v$1;
          continue ;
        }
        _param$1 = param$1.r;
        continue ;
      };
    }
    _param = param.r;
    continue ;
  };
}

function find_last$1(f, _param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
    }
    const v = param.v;
    if (Curry._1(f, v)) {
      let _v0 = v;
      let _d0 = param.d;
      let _param$1 = param.r;
      while(true) {
        const param$1 = _param$1;
        const d0 = _d0;
        const v0 = _v0;
        if (/* tag */typeof param$1 === "number" || typeof param$1 === "string") {
          return [
                  v0,
                  d0
                ];
        }
        const v$1 = param$1.v;
        if (Curry._1(f, v$1)) {
          _param$1 = param$1.r;
          _d0 = param$1.d;
          _v0 = v$1;
          continue ;
        }
        _param$1 = param$1.l;
        continue ;
      };
    }
    _param = param.l;
    continue ;
  };
}

function find_last_opt$1(f, _param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      return ;
    }
    const v = param.v;
    if (Curry._1(f, v)) {
      let _v0 = v;
      let _d0 = param.d;
      let _param$1 = param.r;
      while(true) {
        const param$1 = _param$1;
        const d0 = _d0;
        const v0 = _v0;
        if (/* tag */typeof param$1 === "number" || typeof param$1 === "string") {
          return [
                  v0,
                  d0
                ];
        }
        const v$1 = param$1.v;
        if (Curry._1(f, v$1)) {
          _param$1 = param$1.r;
          _d0 = param$1.d;
          _v0 = v$1;
          continue ;
        }
        _param$1 = param$1.l;
        continue ;
      };
    }
    _param = param.l;
    continue ;
  };
}

function find_opt$1(x, _param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      return ;
    }
    const c = Curry._2(funarg$1.compare, x, param.v);
    if (c === 0) {
      return Caml_option.some(param.d);
    }
    _param = c < 0 ? param.l : param.r;
    continue ;
  };
}

function mem$1(x, _param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      return false;
    }
    const c = Curry._2(funarg$1.compare, x, param.v);
    if (c === 0) {
      return true;
    }
    _param = c < 0 ? param.l : param.r;
    continue ;
  };
}

function min_binding$1(_param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
    }
    const l = param.l;
    if (/* tag */typeof l === "number" || typeof l === "string") {
      return [
              param.v,
              param.d
            ];
    }
    _param = l;
    continue ;
  };
}

function min_binding_opt$1(_param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      return ;
    }
    const l = param.l;
    if (/* tag */typeof l === "number" || typeof l === "string") {
      return [
              param.v,
              param.d
            ];
    }
    _param = l;
    continue ;
  };
}

function max_binding$1(_param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
    }
    let tmp = param.r;
    if (/* tag */typeof tmp === "number" || typeof tmp === "string") {
      return [
              param.v,
              param.d
            ];
    }
    _param = param.r;
    continue ;
  };
}

function max_binding_opt$1(_param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      return ;
    }
    let tmp = param.r;
    if (/* tag */typeof tmp === "number" || typeof tmp === "string") {
      return [
              param.v,
              param.d
            ];
    }
    _param = param.r;
    continue ;
  };
}

function remove_min_binding$1(param) {
  if (/* tag */typeof param === "number" || typeof param === "string") {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Map.remove_min_elt"
            });
  }
  const l = param.l;
  if (/* tag */typeof l === "number" || typeof l === "string") {
    return param.r;
  } else {
    return bal$1(remove_min_binding$1(l), param.v, param.d, param.r);
  }
}

function merge$2(t1, t2) {
  if (/* tag */typeof t1 === "number" || typeof t1 === "string") {
    return t2;
  }
  if (/* tag */typeof t2 === "number" || typeof t2 === "string") {
    return t1;
  }
  const match = min_binding$1(t2);
  return bal$1(t1, match[0], match[1], remove_min_binding$1(t2));
}

function remove$1(x, m) {
  if (/* tag */typeof m === "number" || typeof m === "string") {
    return /* Empty */0;
  }
  const r = m.r;
  const d = m.d;
  const v = m.v;
  const l = m.l;
  const c = Curry._2(funarg$1.compare, x, v);
  if (c === 0) {
    return merge$2(l, r);
  }
  if (c < 0) {
    const ll = remove$1(x, l);
    if (l === ll) {
      return m;
    } else {
      return bal$1(ll, v, d, r);
    }
  }
  const rr = remove$1(x, r);
  if (r === rr) {
    return m;
  } else {
    return bal$1(l, v, d, rr);
  }
}

function update$1(x, f, m) {
  if (/* tag */typeof m === "number" || typeof m === "string") {
    const data = Curry._1(f, undefined);
    if (data !== undefined) {
      return {
              TAG: /* Node */0,
              l: /* Empty */0,
              v: x,
              d: Caml_option.valFromOption(data),
              r: /* Empty */0,
              h: 1
            };
    } else {
      return /* Empty */0;
    }
  }
  const r = m.r;
  const d = m.d;
  const v = m.v;
  const l = m.l;
  const c = Curry._2(funarg$1.compare, x, v);
  if (c === 0) {
    const data$1 = Curry._1(f, Caml_option.some(d));
    if (data$1 === undefined) {
      return merge$2(l, r);
    }
    const data$2 = Caml_option.valFromOption(data$1);
    if (d === data$2) {
      return m;
    } else {
      return {
              TAG: /* Node */0,
              l: l,
              v: x,
              d: data$2,
              r: r,
              h: m.h
            };
    }
  }
  if (c < 0) {
    const ll = update$1(x, f, l);
    if (l === ll) {
      return m;
    } else {
      return bal$1(ll, v, d, r);
    }
  }
  const rr = update$1(x, f, r);
  if (r === rr) {
    return m;
  } else {
    return bal$1(l, v, d, rr);
  }
}

function add_to_list$1(x, data, m) {
  const add = function (l) {
    if (l !== undefined) {
      return {
              hd: data,
              tl: l
            };
    } else {
      return {
              hd: data,
              tl: /* [] */0
            };
    }
  };
  return update$1(x, add, m);
}

function iter$1(f, _param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      return ;
    }
    iter$1(f, param.l);
    Curry._2(f, param.v, param.d);
    _param = param.r;
    continue ;
  };
}

function map$1(f, param) {
  if (/* tag */typeof param === "number" || typeof param === "string") {
    return /* Empty */0;
  }
  const l$p = map$1(f, param.l);
  const d$p = Curry._1(f, param.d);
  const r$p = map$1(f, param.r);
  return {
          TAG: /* Node */0,
          l: l$p,
          v: param.v,
          d: d$p,
          r: r$p,
          h: param.h
        };
}

function mapi$1(f, param) {
  if (/* tag */typeof param === "number" || typeof param === "string") {
    return /* Empty */0;
  }
  const v = param.v;
  const l$p = mapi$1(f, param.l);
  const d$p = Curry._2(f, v, param.d);
  const r$p = mapi$1(f, param.r);
  return {
          TAG: /* Node */0,
          l: l$p,
          v: v,
          d: d$p,
          r: r$p,
          h: param.h
        };
}

function fold$1(f, _m, _accu) {
  while(true) {
    const accu = _accu;
    const m = _m;
    if (/* tag */typeof m === "number" || typeof m === "string") {
      return accu;
    }
    _accu = Curry._3(f, m.v, m.d, fold$1(f, m.l, accu));
    _m = m.r;
    continue ;
  };
}

function for_all$1(p, _param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      return true;
    }
    if (!Curry._2(p, param.v, param.d)) {
      return false;
    }
    if (!for_all$1(p, param.l)) {
      return false;
    }
    _param = param.r;
    continue ;
  };
}

function exists$1(p, _param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      return false;
    }
    if (Curry._2(p, param.v, param.d)) {
      return true;
    }
    if (exists$1(p, param.l)) {
      return true;
    }
    _param = param.r;
    continue ;
  };
}

function add_min_binding$1(k, x, param) {
  if (/* tag */typeof param === "number" || typeof param === "string") {
    return singleton$1(k, x);
  } else {
    return bal$1(add_min_binding$1(k, x, param.l), param.v, param.d, param.r);
  }
}

function add_max_binding$1(k, x, param) {
  if (/* tag */typeof param === "number" || typeof param === "string") {
    return singleton$1(k, x);
  } else {
    return bal$1(param.l, param.v, param.d, add_max_binding$1(k, x, param.r));
  }
}

function join$1(l, v, d, r) {
  if (/* tag */typeof l === "number" || typeof l === "string") {
    return add_min_binding$1(v, d, r);
  }
  const lh = l.h;
  if (/* tag */typeof r === "number" || typeof r === "string") {
    return add_max_binding$1(v, d, l);
  }
  const rh = r.h;
  if (lh > (rh + 2 | 0)) {
    return bal$1(l.l, l.v, l.d, join$1(l.r, v, d, r));
  } else if (rh > (lh + 2 | 0)) {
    return bal$1(join$1(l, v, d, r.l), r.v, r.d, r.r);
  } else {
    return create$1(l, v, d, r);
  }
}

function concat$1(t1, t2) {
  if (/* tag */typeof t1 === "number" || typeof t1 === "string") {
    return t2;
  }
  if (/* tag */typeof t2 === "number" || typeof t2 === "string") {
    return t1;
  }
  const match = min_binding$1(t2);
  return join$1(t1, match[0], match[1], remove_min_binding$1(t2));
}

function concat_or_join$1(t1, v, d, t2) {
  if (d !== undefined) {
    return join$1(t1, v, Caml_option.valFromOption(d), t2);
  } else {
    return concat$1(t1, t2);
  }
}

function split$1(x, param) {
  if (/* tag */typeof param === "number" || typeof param === "string") {
    return [
            /* Empty */0,
            undefined,
            /* Empty */0
          ];
  }
  const r = param.r;
  const d = param.d;
  const v = param.v;
  const l = param.l;
  const c = Curry._2(funarg$1.compare, x, v);
  if (c === 0) {
    return [
            l,
            Caml_option.some(d),
            r
          ];
  }
  if (c < 0) {
    const match = split$1(x, l);
    return [
            match[0],
            match[1],
            join$1(match[2], v, d, r)
          ];
  }
  const match$1 = split$1(x, r);
  return [
          join$1(l, v, d, match$1[0]),
          match$1[1],
          match$1[2]
        ];
}

function merge$3(f, s1, s2) {
  if (/* tag */typeof s1 === "number" || typeof s1 === "string") {
    if (/* tag */typeof s2 === "number" || typeof s2 === "string") {
      return /* Empty */0;
    }
    
  } else {
    const v1 = s1.v;
    if (s1.h >= height$1(s2)) {
      const match = split$1(v1, s2);
      return concat_or_join$1(merge$3(f, s1.l, match[0]), v1, Curry._3(f, v1, Caml_option.some(s1.d), match[1]), merge$3(f, s1.r, match[2]));
    }
    
  }
  if (/* tag */typeof s2 === "number" || typeof s2 === "string") {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/stdlib/map.ml",
                408,
                10
              ]
            });
  }
  const v2 = s2.v;
  const match$1 = split$1(v2, s1);
  return concat_or_join$1(merge$3(f, match$1[0], s2.l), v2, Curry._3(f, v2, match$1[1], Caml_option.some(s2.d)), merge$3(f, match$1[2], s2.r));
}

function union$1(f, s1, s2) {
  if (/* tag */typeof s1 === "number" || typeof s1 === "string") {
    return s2;
  }
  const d1 = s1.d;
  const v1 = s1.v;
  if (/* tag */typeof s2 === "number" || typeof s2 === "string") {
    return s1;
  }
  const d2 = s2.d;
  const v2 = s2.v;
  if (s1.h >= s2.h) {
    const match = split$1(v1, s2);
    const d2$1 = match[1];
    const l = union$1(f, s1.l, match[0]);
    const r = union$1(f, s1.r, match[2]);
    if (d2$1 !== undefined) {
      return concat_or_join$1(l, v1, Curry._3(f, v1, d1, Caml_option.valFromOption(d2$1)), r);
    } else {
      return join$1(l, v1, d1, r);
    }
  }
  const match$1 = split$1(v2, s1);
  const d1$1 = match$1[1];
  const l$1 = union$1(f, match$1[0], s2.l);
  const r$1 = union$1(f, match$1[2], s2.r);
  if (d1$1 !== undefined) {
    return concat_or_join$1(l$1, v2, Curry._3(f, v2, Caml_option.valFromOption(d1$1), d2), r$1);
  } else {
    return join$1(l$1, v2, d2, r$1);
  }
}

function filter$1(p, m) {
  if (/* tag */typeof m === "number" || typeof m === "string") {
    return /* Empty */0;
  }
  const r = m.r;
  const d = m.d;
  const v = m.v;
  const l = m.l;
  const l$p = filter$1(p, l);
  const pvd = Curry._2(p, v, d);
  const r$p = filter$1(p, r);
  if (pvd) {
    if (l === l$p && r === r$p) {
      return m;
    } else {
      return join$1(l$p, v, d, r$p);
    }
  } else {
    return concat$1(l$p, r$p);
  }
}

function filter_map$1(f, param) {
  if (/* tag */typeof param === "number" || typeof param === "string") {
    return /* Empty */0;
  }
  const v = param.v;
  const l$p = filter_map$1(f, param.l);
  const fvd = Curry._2(f, v, param.d);
  const r$p = filter_map$1(f, param.r);
  if (fvd !== undefined) {
    return join$1(l$p, v, Caml_option.valFromOption(fvd), r$p);
  } else {
    return concat$1(l$p, r$p);
  }
}

function partition$1(p, param) {
  if (/* tag */typeof param === "number" || typeof param === "string") {
    return [
            /* Empty */0,
            /* Empty */0
          ];
  }
  const d = param.d;
  const v = param.v;
  const match = partition$1(p, param.l);
  const lf = match[1];
  const lt = match[0];
  const pvd = Curry._2(p, v, d);
  const match$1 = partition$1(p, param.r);
  const rf = match$1[1];
  const rt = match$1[0];
  if (pvd) {
    return [
            join$1(lt, v, d, rt),
            concat$1(lf, rf)
          ];
  } else {
    return [
            concat$1(lt, rt),
            join$1(lf, v, d, rf)
          ];
  }
}

function cons_enum$1(_m, _e) {
  while(true) {
    const e = _e;
    const m = _m;
    if (/* tag */typeof m === "number" || typeof m === "string") {
      return e;
    }
    _e = {
      TAG: /* More */0,
      _0: m.v,
      _1: m.d,
      _2: m.r,
      _3: e
    };
    _m = m.l;
    continue ;
  };
}

function compare$3(cmp, m1, m2) {
  let _e1 = cons_enum$1(m1, /* End */0);
  let _e2 = cons_enum$1(m2, /* End */0);
  while(true) {
    const e2 = _e2;
    const e1 = _e1;
    if (/* tag */typeof e1 === "number" || typeof e1 === "string") {
      if (/* tag */typeof e2 === "number" || typeof e2 === "string") {
        return 0;
      } else {
        return -1;
      }
    }
    if (/* tag */typeof e2 === "number" || typeof e2 === "string") {
      return 1;
    }
    const c = Curry._2(funarg$1.compare, e1._0, e2._0);
    if (c !== 0) {
      return c;
    }
    const c$1 = Curry._2(cmp, e1._1, e2._1);
    if (c$1 !== 0) {
      return c$1;
    }
    _e2 = cons_enum$1(e2._2, e2._3);
    _e1 = cons_enum$1(e1._2, e1._3);
    continue ;
  };
}

function equal$1(cmp, m1, m2) {
  let _e1 = cons_enum$1(m1, /* End */0);
  let _e2 = cons_enum$1(m2, /* End */0);
  while(true) {
    const e2 = _e2;
    const e1 = _e1;
    if (/* tag */typeof e1 === "number" || typeof e1 === "string") {
      if (/* tag */typeof e2 === "number" || typeof e2 === "string") {
        return true;
      } else {
        return false;
      }
    }
    if (/* tag */typeof e2 === "number" || typeof e2 === "string") {
      return false;
    }
    if (Curry._2(funarg$1.compare, e1._0, e2._0) !== 0) {
      return false;
    }
    if (!Curry._2(cmp, e1._1, e2._1)) {
      return false;
    }
    _e2 = cons_enum$1(e2._2, e2._3);
    _e1 = cons_enum$1(e1._2, e1._3);
    continue ;
  };
}

function cardinal$1(param) {
  if (/* tag */typeof param === "number" || typeof param === "string") {
    return 0;
  } else {
    return (cardinal$1(param.l) + 1 | 0) + cardinal$1(param.r) | 0;
  }
}

function bindings_aux$1(_accu, _param) {
  while(true) {
    const param = _param;
    const accu = _accu;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      return accu;
    }
    _param = param.l;
    _accu = {
      hd: [
        param.v,
        param.d
      ],
      tl: bindings_aux$1(accu, param.r)
    };
    continue ;
  };
}

function bindings$1(s) {
  return bindings_aux$1(/* [] */0, s);
}

function of_list$1(bs) {
  return Stdlib__List.fold_left((function (m, param) {
                return add$1(param[0], param[1], m);
              }), /* Empty */0, bs);
}

function add_seq$1(i, m) {
  return Stdlib__Seq.fold_left((function (m, param) {
                return add$1(param[0], param[1], m);
              }), m, i);
}

function of_seq$1(i) {
  return add_seq$1(i, /* Empty */0);
}

function seq_of_enum_$1(c, param) {
  if (/* tag */typeof c === "number" || typeof c === "string") {
    return /* Nil */0;
  }
  const partial_arg = cons_enum$1(c._2, c._3);
  return {
          TAG: /* Cons */0,
          _0: [
            c._0,
            c._1
          ],
          _1: (function (param) {
              return seq_of_enum_$1(partial_arg, param);
            })
        };
}

function to_seq$1(m) {
  const partial_arg = cons_enum$1(m, /* End */0);
  return function (param) {
    return seq_of_enum_$1(partial_arg, param);
  };
}

function snoc_enum$1(_s, _e) {
  while(true) {
    const e = _e;
    const s = _s;
    if (/* tag */typeof s === "number" || typeof s === "string") {
      return e;
    }
    _e = {
      TAG: /* More */0,
      _0: s.v,
      _1: s.d,
      _2: s.l,
      _3: e
    };
    _s = s.r;
    continue ;
  };
}

function rev_seq_of_enum_$1(c, param) {
  if (/* tag */typeof c === "number" || typeof c === "string") {
    return /* Nil */0;
  }
  const partial_arg = snoc_enum$1(c._2, c._3);
  return {
          TAG: /* Cons */0,
          _0: [
            c._0,
            c._1
          ],
          _1: (function (param) {
              return rev_seq_of_enum_$1(partial_arg, param);
            })
        };
}

function to_rev_seq$1(c) {
  const partial_arg = snoc_enum$1(c, /* End */0);
  return function (param) {
    return rev_seq_of_enum_$1(partial_arg, param);
  };
}

function to_seq_from$1(low, m) {
  const aux = function (low, _m, _c) {
    while(true) {
      const c = _c;
      const m = _m;
      if (/* tag */typeof m === "number" || typeof m === "string") {
        return c;
      }
      const r = m.r;
      const d = m.d;
      const v = m.v;
      const n = Curry._2(funarg$1.compare, v, low);
      if (n === 0) {
        return {
                TAG: /* More */0,
                _0: v,
                _1: d,
                _2: r,
                _3: c
              };
      }
      if (n < 0) {
        _m = r;
        continue ;
      }
      _c = {
        TAG: /* More */0,
        _0: v,
        _1: d,
        _2: r,
        _3: c
      };
      _m = m.l;
      continue ;
    };
  };
  const partial_arg = aux(low, m, /* End */0);
  return function (param) {
    return seq_of_enum_$1(partial_arg, param);
  };
}

const Meths = {
  empty: /* Empty */0,
  add: add$1,
  add_to_list: add_to_list$1,
  update: update$1,
  singleton: singleton$1,
  remove: remove$1,
  merge: merge$3,
  union: union$1,
  cardinal: cardinal$1,
  bindings: bindings$1,
  min_binding: min_binding$1,
  min_binding_opt: min_binding_opt$1,
  max_binding: max_binding$1,
  max_binding_opt: max_binding_opt$1,
  choose: min_binding$1,
  choose_opt: min_binding_opt$1,
  find: find$1,
  find_opt: find_opt$1,
  find_first: find_first$1,
  find_first_opt: find_first_opt$1,
  find_last: find_last$1,
  find_last_opt: find_last_opt$1,
  iter: iter$1,
  fold: fold$1,
  map: map$1,
  mapi: mapi$1,
  filter: filter$1,
  filter_map: filter_map$1,
  partition: partition$1,
  split: split$1,
  is_empty: is_empty$1,
  mem: mem$1,
  equal: equal$1,
  compare: compare$3,
  for_all: for_all$1,
  exists: exists$1,
  to_list: bindings$1,
  of_list: of_list$1,
  to_seq: to_seq$1,
  to_rev_seq: to_rev_seq$1,
  to_seq_from: to_seq_from$1,
  add_seq: add_seq$1,
  of_seq: of_seq$1
};

const compare$4 = Caml.caml_int_compare;

const funarg$2 = {
  compare: compare$4
};

function height$2(param) {
  if (/* tag */typeof param === "number" || typeof param === "string") {
    return 0;
  } else {
    return param.h;
  }
}

function create$2(l, x, d, r) {
  const hl = height$2(l);
  const hr = height$2(r);
  return {
          TAG: /* Node */0,
          l: l,
          v: x,
          d: d,
          r: r,
          h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        };
}

function singleton$2(x, d) {
  return {
          TAG: /* Node */0,
          l: /* Empty */0,
          v: x,
          d: d,
          r: /* Empty */0,
          h: 1
        };
}

function bal$2(l, x, d, r) {
  let hl;
  hl = /* tag */typeof l === "number" || typeof l === "string" ? 0 : l.h;
  let hr;
  hr = /* tag */typeof r === "number" || typeof r === "string" ? 0 : r.h;
  if (hl > (hr + 2 | 0)) {
    if (/* tag */typeof l === "number" || typeof l === "string") {
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
                MEL_EXN_ID: "Invalid_argument",
                _1: "Map.bal"
              });
    }
    const lr = l.r;
    const ld = l.d;
    const lv = l.v;
    const ll = l.l;
    if (height$2(ll) >= height$2(lr)) {
      return create$2(ll, lv, ld, create$2(lr, x, d, r));
    }
    if (!/* tag */(typeof lr === "number" || typeof lr === "string")) {
      return create$2(create$2(ll, lv, ld, lr.l), lr.v, lr.d, create$2(lr.r, x, d, r));
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Map.bal"
            });
  }
  if (hr <= (hl + 2 | 0)) {
    return {
            TAG: /* Node */0,
            l: l,
            v: x,
            d: d,
            r: r,
            h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          };
  }
  if (/* tag */typeof r === "number" || typeof r === "string") {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Map.bal"
            });
  }
  const rr = r.r;
  const rd = r.d;
  const rv = r.v;
  const rl = r.l;
  if (height$2(rr) >= height$2(rl)) {
    return create$2(create$2(l, x, d, rl), rv, rd, rr);
  }
  if (!/* tag */(typeof rl === "number" || typeof rl === "string")) {
    return create$2(create$2(l, x, d, rl.l), rl.v, rl.d, create$2(rl.r, rv, rd, rr));
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Map.bal"
          });
}

function is_empty$2(param) {
  if (/* tag */typeof param === "number" || typeof param === "string") {
    return true;
  } else {
    return false;
  }
}

function add$2(x, data, m) {
  if (/* tag */typeof m === "number" || typeof m === "string") {
    return {
            TAG: /* Node */0,
            l: /* Empty */0,
            v: x,
            d: data,
            r: /* Empty */0,
            h: 1
          };
  }
  const r = m.r;
  const d = m.d;
  const v = m.v;
  const l = m.l;
  const c = Curry._2(funarg$2.compare, x, v);
  if (c === 0) {
    if (d === data) {
      return m;
    } else {
      return {
              TAG: /* Node */0,
              l: l,
              v: x,
              d: data,
              r: r,
              h: m.h
            };
    }
  }
  if (c < 0) {
    const ll = add$2(x, data, l);
    if (l === ll) {
      return m;
    } else {
      return bal$2(ll, v, d, r);
    }
  }
  const rr = add$2(x, data, r);
  if (r === rr) {
    return m;
  } else {
    return bal$2(l, v, d, rr);
  }
}

function find$2(x, _param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
    }
    const c = Curry._2(funarg$2.compare, x, param.v);
    if (c === 0) {
      return param.d;
    }
    _param = c < 0 ? param.l : param.r;
    continue ;
  };
}

function find_first$2(f, _param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
    }
    const v = param.v;
    if (Curry._1(f, v)) {
      let _v0 = v;
      let _d0 = param.d;
      let _param$1 = param.l;
      while(true) {
        const param$1 = _param$1;
        const d0 = _d0;
        const v0 = _v0;
        if (/* tag */typeof param$1 === "number" || typeof param$1 === "string") {
          return [
                  v0,
                  d0
                ];
        }
        const v$1 = param$1.v;
        if (Curry._1(f, v$1)) {
          _param$1 = param$1.l;
          _d0 = param$1.d;
          _v0 = v$1;
          continue ;
        }
        _param$1 = param$1.r;
        continue ;
      };
    }
    _param = param.r;
    continue ;
  };
}

function find_first_opt$2(f, _param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      return ;
    }
    const v = param.v;
    if (Curry._1(f, v)) {
      let _v0 = v;
      let _d0 = param.d;
      let _param$1 = param.l;
      while(true) {
        const param$1 = _param$1;
        const d0 = _d0;
        const v0 = _v0;
        if (/* tag */typeof param$1 === "number" || typeof param$1 === "string") {
          return [
                  v0,
                  d0
                ];
        }
        const v$1 = param$1.v;
        if (Curry._1(f, v$1)) {
          _param$1 = param$1.l;
          _d0 = param$1.d;
          _v0 = v$1;
          continue ;
        }
        _param$1 = param$1.r;
        continue ;
      };
    }
    _param = param.r;
    continue ;
  };
}

function find_last$2(f, _param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
    }
    const v = param.v;
    if (Curry._1(f, v)) {
      let _v0 = v;
      let _d0 = param.d;
      let _param$1 = param.r;
      while(true) {
        const param$1 = _param$1;
        const d0 = _d0;
        const v0 = _v0;
        if (/* tag */typeof param$1 === "number" || typeof param$1 === "string") {
          return [
                  v0,
                  d0
                ];
        }
        const v$1 = param$1.v;
        if (Curry._1(f, v$1)) {
          _param$1 = param$1.r;
          _d0 = param$1.d;
          _v0 = v$1;
          continue ;
        }
        _param$1 = param$1.l;
        continue ;
      };
    }
    _param = param.l;
    continue ;
  };
}

function find_last_opt$2(f, _param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      return ;
    }
    const v = param.v;
    if (Curry._1(f, v)) {
      let _v0 = v;
      let _d0 = param.d;
      let _param$1 = param.r;
      while(true) {
        const param$1 = _param$1;
        const d0 = _d0;
        const v0 = _v0;
        if (/* tag */typeof param$1 === "number" || typeof param$1 === "string") {
          return [
                  v0,
                  d0
                ];
        }
        const v$1 = param$1.v;
        if (Curry._1(f, v$1)) {
          _param$1 = param$1.r;
          _d0 = param$1.d;
          _v0 = v$1;
          continue ;
        }
        _param$1 = param$1.l;
        continue ;
      };
    }
    _param = param.l;
    continue ;
  };
}

function find_opt$2(x, _param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      return ;
    }
    const c = Curry._2(funarg$2.compare, x, param.v);
    if (c === 0) {
      return Caml_option.some(param.d);
    }
    _param = c < 0 ? param.l : param.r;
    continue ;
  };
}

function mem$2(x, _param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      return false;
    }
    const c = Curry._2(funarg$2.compare, x, param.v);
    if (c === 0) {
      return true;
    }
    _param = c < 0 ? param.l : param.r;
    continue ;
  };
}

function min_binding$2(_param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
    }
    const l = param.l;
    if (/* tag */typeof l === "number" || typeof l === "string") {
      return [
              param.v,
              param.d
            ];
    }
    _param = l;
    continue ;
  };
}

function min_binding_opt$2(_param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      return ;
    }
    const l = param.l;
    if (/* tag */typeof l === "number" || typeof l === "string") {
      return [
              param.v,
              param.d
            ];
    }
    _param = l;
    continue ;
  };
}

function max_binding$2(_param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
    }
    let tmp = param.r;
    if (/* tag */typeof tmp === "number" || typeof tmp === "string") {
      return [
              param.v,
              param.d
            ];
    }
    _param = param.r;
    continue ;
  };
}

function max_binding_opt$2(_param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      return ;
    }
    let tmp = param.r;
    if (/* tag */typeof tmp === "number" || typeof tmp === "string") {
      return [
              param.v,
              param.d
            ];
    }
    _param = param.r;
    continue ;
  };
}

function remove_min_binding$2(param) {
  if (/* tag */typeof param === "number" || typeof param === "string") {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Map.remove_min_elt"
            });
  }
  const l = param.l;
  if (/* tag */typeof l === "number" || typeof l === "string") {
    return param.r;
  } else {
    return bal$2(remove_min_binding$2(l), param.v, param.d, param.r);
  }
}

function merge$4(t1, t2) {
  if (/* tag */typeof t1 === "number" || typeof t1 === "string") {
    return t2;
  }
  if (/* tag */typeof t2 === "number" || typeof t2 === "string") {
    return t1;
  }
  const match = min_binding$2(t2);
  return bal$2(t1, match[0], match[1], remove_min_binding$2(t2));
}

function remove$2(x, m) {
  if (/* tag */typeof m === "number" || typeof m === "string") {
    return /* Empty */0;
  }
  const r = m.r;
  const d = m.d;
  const v = m.v;
  const l = m.l;
  const c = Curry._2(funarg$2.compare, x, v);
  if (c === 0) {
    return merge$4(l, r);
  }
  if (c < 0) {
    const ll = remove$2(x, l);
    if (l === ll) {
      return m;
    } else {
      return bal$2(ll, v, d, r);
    }
  }
  const rr = remove$2(x, r);
  if (r === rr) {
    return m;
  } else {
    return bal$2(l, v, d, rr);
  }
}

function update$2(x, f, m) {
  if (/* tag */typeof m === "number" || typeof m === "string") {
    const data = Curry._1(f, undefined);
    if (data !== undefined) {
      return {
              TAG: /* Node */0,
              l: /* Empty */0,
              v: x,
              d: Caml_option.valFromOption(data),
              r: /* Empty */0,
              h: 1
            };
    } else {
      return /* Empty */0;
    }
  }
  const r = m.r;
  const d = m.d;
  const v = m.v;
  const l = m.l;
  const c = Curry._2(funarg$2.compare, x, v);
  if (c === 0) {
    const data$1 = Curry._1(f, Caml_option.some(d));
    if (data$1 === undefined) {
      return merge$4(l, r);
    }
    const data$2 = Caml_option.valFromOption(data$1);
    if (d === data$2) {
      return m;
    } else {
      return {
              TAG: /* Node */0,
              l: l,
              v: x,
              d: data$2,
              r: r,
              h: m.h
            };
    }
  }
  if (c < 0) {
    const ll = update$2(x, f, l);
    if (l === ll) {
      return m;
    } else {
      return bal$2(ll, v, d, r);
    }
  }
  const rr = update$2(x, f, r);
  if (r === rr) {
    return m;
  } else {
    return bal$2(l, v, d, rr);
  }
}

function add_to_list$2(x, data, m) {
  const add = function (l) {
    if (l !== undefined) {
      return {
              hd: data,
              tl: l
            };
    } else {
      return {
              hd: data,
              tl: /* [] */0
            };
    }
  };
  return update$2(x, add, m);
}

function iter$2(f, _param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      return ;
    }
    iter$2(f, param.l);
    Curry._2(f, param.v, param.d);
    _param = param.r;
    continue ;
  };
}

function map$2(f, param) {
  if (/* tag */typeof param === "number" || typeof param === "string") {
    return /* Empty */0;
  }
  const l$p = map$2(f, param.l);
  const d$p = Curry._1(f, param.d);
  const r$p = map$2(f, param.r);
  return {
          TAG: /* Node */0,
          l: l$p,
          v: param.v,
          d: d$p,
          r: r$p,
          h: param.h
        };
}

function mapi$2(f, param) {
  if (/* tag */typeof param === "number" || typeof param === "string") {
    return /* Empty */0;
  }
  const v = param.v;
  const l$p = mapi$2(f, param.l);
  const d$p = Curry._2(f, v, param.d);
  const r$p = mapi$2(f, param.r);
  return {
          TAG: /* Node */0,
          l: l$p,
          v: v,
          d: d$p,
          r: r$p,
          h: param.h
        };
}

function fold$2(f, _m, _accu) {
  while(true) {
    const accu = _accu;
    const m = _m;
    if (/* tag */typeof m === "number" || typeof m === "string") {
      return accu;
    }
    _accu = Curry._3(f, m.v, m.d, fold$2(f, m.l, accu));
    _m = m.r;
    continue ;
  };
}

function for_all$2(p, _param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      return true;
    }
    if (!Curry._2(p, param.v, param.d)) {
      return false;
    }
    if (!for_all$2(p, param.l)) {
      return false;
    }
    _param = param.r;
    continue ;
  };
}

function exists$2(p, _param) {
  while(true) {
    const param = _param;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      return false;
    }
    if (Curry._2(p, param.v, param.d)) {
      return true;
    }
    if (exists$2(p, param.l)) {
      return true;
    }
    _param = param.r;
    continue ;
  };
}

function add_min_binding$2(k, x, param) {
  if (/* tag */typeof param === "number" || typeof param === "string") {
    return singleton$2(k, x);
  } else {
    return bal$2(add_min_binding$2(k, x, param.l), param.v, param.d, param.r);
  }
}

function add_max_binding$2(k, x, param) {
  if (/* tag */typeof param === "number" || typeof param === "string") {
    return singleton$2(k, x);
  } else {
    return bal$2(param.l, param.v, param.d, add_max_binding$2(k, x, param.r));
  }
}

function join$2(l, v, d, r) {
  if (/* tag */typeof l === "number" || typeof l === "string") {
    return add_min_binding$2(v, d, r);
  }
  const lh = l.h;
  if (/* tag */typeof r === "number" || typeof r === "string") {
    return add_max_binding$2(v, d, l);
  }
  const rh = r.h;
  if (lh > (rh + 2 | 0)) {
    return bal$2(l.l, l.v, l.d, join$2(l.r, v, d, r));
  } else if (rh > (lh + 2 | 0)) {
    return bal$2(join$2(l, v, d, r.l), r.v, r.d, r.r);
  } else {
    return create$2(l, v, d, r);
  }
}

function concat$2(t1, t2) {
  if (/* tag */typeof t1 === "number" || typeof t1 === "string") {
    return t2;
  }
  if (/* tag */typeof t2 === "number" || typeof t2 === "string") {
    return t1;
  }
  const match = min_binding$2(t2);
  return join$2(t1, match[0], match[1], remove_min_binding$2(t2));
}

function concat_or_join$2(t1, v, d, t2) {
  if (d !== undefined) {
    return join$2(t1, v, Caml_option.valFromOption(d), t2);
  } else {
    return concat$2(t1, t2);
  }
}

function split$2(x, param) {
  if (/* tag */typeof param === "number" || typeof param === "string") {
    return [
            /* Empty */0,
            undefined,
            /* Empty */0
          ];
  }
  const r = param.r;
  const d = param.d;
  const v = param.v;
  const l = param.l;
  const c = Curry._2(funarg$2.compare, x, v);
  if (c === 0) {
    return [
            l,
            Caml_option.some(d),
            r
          ];
  }
  if (c < 0) {
    const match = split$2(x, l);
    return [
            match[0],
            match[1],
            join$2(match[2], v, d, r)
          ];
  }
  const match$1 = split$2(x, r);
  return [
          join$2(l, v, d, match$1[0]),
          match$1[1],
          match$1[2]
        ];
}

function merge$5(f, s1, s2) {
  if (/* tag */typeof s1 === "number" || typeof s1 === "string") {
    if (/* tag */typeof s2 === "number" || typeof s2 === "string") {
      return /* Empty */0;
    }
    
  } else {
    const v1 = s1.v;
    if (s1.h >= height$2(s2)) {
      const match = split$2(v1, s2);
      return concat_or_join$2(merge$5(f, s1.l, match[0]), v1, Curry._3(f, v1, Caml_option.some(s1.d), match[1]), merge$5(f, s1.r, match[2]));
    }
    
  }
  if (/* tag */typeof s2 === "number" || typeof s2 === "string") {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/stdlib/map.ml",
                408,
                10
              ]
            });
  }
  const v2 = s2.v;
  const match$1 = split$2(v2, s1);
  return concat_or_join$2(merge$5(f, match$1[0], s2.l), v2, Curry._3(f, v2, match$1[1], Caml_option.some(s2.d)), merge$5(f, match$1[2], s2.r));
}

function union$2(f, s1, s2) {
  if (/* tag */typeof s1 === "number" || typeof s1 === "string") {
    return s2;
  }
  const d1 = s1.d;
  const v1 = s1.v;
  if (/* tag */typeof s2 === "number" || typeof s2 === "string") {
    return s1;
  }
  const d2 = s2.d;
  const v2 = s2.v;
  if (s1.h >= s2.h) {
    const match = split$2(v1, s2);
    const d2$1 = match[1];
    const l = union$2(f, s1.l, match[0]);
    const r = union$2(f, s1.r, match[2]);
    if (d2$1 !== undefined) {
      return concat_or_join$2(l, v1, Curry._3(f, v1, d1, Caml_option.valFromOption(d2$1)), r);
    } else {
      return join$2(l, v1, d1, r);
    }
  }
  const match$1 = split$2(v2, s1);
  const d1$1 = match$1[1];
  const l$1 = union$2(f, match$1[0], s2.l);
  const r$1 = union$2(f, match$1[2], s2.r);
  if (d1$1 !== undefined) {
    return concat_or_join$2(l$1, v2, Curry._3(f, v2, Caml_option.valFromOption(d1$1), d2), r$1);
  } else {
    return join$2(l$1, v2, d2, r$1);
  }
}

function filter$2(p, m) {
  if (/* tag */typeof m === "number" || typeof m === "string") {
    return /* Empty */0;
  }
  const r = m.r;
  const d = m.d;
  const v = m.v;
  const l = m.l;
  const l$p = filter$2(p, l);
  const pvd = Curry._2(p, v, d);
  const r$p = filter$2(p, r);
  if (pvd) {
    if (l === l$p && r === r$p) {
      return m;
    } else {
      return join$2(l$p, v, d, r$p);
    }
  } else {
    return concat$2(l$p, r$p);
  }
}

function filter_map$2(f, param) {
  if (/* tag */typeof param === "number" || typeof param === "string") {
    return /* Empty */0;
  }
  const v = param.v;
  const l$p = filter_map$2(f, param.l);
  const fvd = Curry._2(f, v, param.d);
  const r$p = filter_map$2(f, param.r);
  if (fvd !== undefined) {
    return join$2(l$p, v, Caml_option.valFromOption(fvd), r$p);
  } else {
    return concat$2(l$p, r$p);
  }
}

function partition$2(p, param) {
  if (/* tag */typeof param === "number" || typeof param === "string") {
    return [
            /* Empty */0,
            /* Empty */0
          ];
  }
  const d = param.d;
  const v = param.v;
  const match = partition$2(p, param.l);
  const lf = match[1];
  const lt = match[0];
  const pvd = Curry._2(p, v, d);
  const match$1 = partition$2(p, param.r);
  const rf = match$1[1];
  const rt = match$1[0];
  if (pvd) {
    return [
            join$2(lt, v, d, rt),
            concat$2(lf, rf)
          ];
  } else {
    return [
            concat$2(lt, rt),
            join$2(lf, v, d, rf)
          ];
  }
}

function cons_enum$2(_m, _e) {
  while(true) {
    const e = _e;
    const m = _m;
    if (/* tag */typeof m === "number" || typeof m === "string") {
      return e;
    }
    _e = {
      TAG: /* More */0,
      _0: m.v,
      _1: m.d,
      _2: m.r,
      _3: e
    };
    _m = m.l;
    continue ;
  };
}

function compare$5(cmp, m1, m2) {
  let _e1 = cons_enum$2(m1, /* End */0);
  let _e2 = cons_enum$2(m2, /* End */0);
  while(true) {
    const e2 = _e2;
    const e1 = _e1;
    if (/* tag */typeof e1 === "number" || typeof e1 === "string") {
      if (/* tag */typeof e2 === "number" || typeof e2 === "string") {
        return 0;
      } else {
        return -1;
      }
    }
    if (/* tag */typeof e2 === "number" || typeof e2 === "string") {
      return 1;
    }
    const c = Curry._2(funarg$2.compare, e1._0, e2._0);
    if (c !== 0) {
      return c;
    }
    const c$1 = Curry._2(cmp, e1._1, e2._1);
    if (c$1 !== 0) {
      return c$1;
    }
    _e2 = cons_enum$2(e2._2, e2._3);
    _e1 = cons_enum$2(e1._2, e1._3);
    continue ;
  };
}

function equal$2(cmp, m1, m2) {
  let _e1 = cons_enum$2(m1, /* End */0);
  let _e2 = cons_enum$2(m2, /* End */0);
  while(true) {
    const e2 = _e2;
    const e1 = _e1;
    if (/* tag */typeof e1 === "number" || typeof e1 === "string") {
      if (/* tag */typeof e2 === "number" || typeof e2 === "string") {
        return true;
      } else {
        return false;
      }
    }
    if (/* tag */typeof e2 === "number" || typeof e2 === "string") {
      return false;
    }
    if (Curry._2(funarg$2.compare, e1._0, e2._0) !== 0) {
      return false;
    }
    if (!Curry._2(cmp, e1._1, e2._1)) {
      return false;
    }
    _e2 = cons_enum$2(e2._2, e2._3);
    _e1 = cons_enum$2(e1._2, e1._3);
    continue ;
  };
}

function cardinal$2(param) {
  if (/* tag */typeof param === "number" || typeof param === "string") {
    return 0;
  } else {
    return (cardinal$2(param.l) + 1 | 0) + cardinal$2(param.r) | 0;
  }
}

function bindings_aux$2(_accu, _param) {
  while(true) {
    const param = _param;
    const accu = _accu;
    if (/* tag */typeof param === "number" || typeof param === "string") {
      return accu;
    }
    _param = param.l;
    _accu = {
      hd: [
        param.v,
        param.d
      ],
      tl: bindings_aux$2(accu, param.r)
    };
    continue ;
  };
}

function bindings$2(s) {
  return bindings_aux$2(/* [] */0, s);
}

function of_list$2(bs) {
  return Stdlib__List.fold_left((function (m, param) {
                return add$2(param[0], param[1], m);
              }), /* Empty */0, bs);
}

function add_seq$2(i, m) {
  return Stdlib__Seq.fold_left((function (m, param) {
                return add$2(param[0], param[1], m);
              }), m, i);
}

function of_seq$2(i) {
  return add_seq$2(i, /* Empty */0);
}

function seq_of_enum_$2(c, param) {
  if (/* tag */typeof c === "number" || typeof c === "string") {
    return /* Nil */0;
  }
  const partial_arg = cons_enum$2(c._2, c._3);
  return {
          TAG: /* Cons */0,
          _0: [
            c._0,
            c._1
          ],
          _1: (function (param) {
              return seq_of_enum_$2(partial_arg, param);
            })
        };
}

function to_seq$2(m) {
  const partial_arg = cons_enum$2(m, /* End */0);
  return function (param) {
    return seq_of_enum_$2(partial_arg, param);
  };
}

function snoc_enum$2(_s, _e) {
  while(true) {
    const e = _e;
    const s = _s;
    if (/* tag */typeof s === "number" || typeof s === "string") {
      return e;
    }
    _e = {
      TAG: /* More */0,
      _0: s.v,
      _1: s.d,
      _2: s.l,
      _3: e
    };
    _s = s.r;
    continue ;
  };
}

function rev_seq_of_enum_$2(c, param) {
  if (/* tag */typeof c === "number" || typeof c === "string") {
    return /* Nil */0;
  }
  const partial_arg = snoc_enum$2(c._2, c._3);
  return {
          TAG: /* Cons */0,
          _0: [
            c._0,
            c._1
          ],
          _1: (function (param) {
              return rev_seq_of_enum_$2(partial_arg, param);
            })
        };
}

function to_rev_seq$2(c) {
  const partial_arg = snoc_enum$2(c, /* End */0);
  return function (param) {
    return rev_seq_of_enum_$2(partial_arg, param);
  };
}

function to_seq_from$2(low, m) {
  const aux = function (low, _m, _c) {
    while(true) {
      const c = _c;
      const m = _m;
      if (/* tag */typeof m === "number" || typeof m === "string") {
        return c;
      }
      const r = m.r;
      const d = m.d;
      const v = m.v;
      const n = Curry._2(funarg$2.compare, v, low);
      if (n === 0) {
        return {
                TAG: /* More */0,
                _0: v,
                _1: d,
                _2: r,
                _3: c
              };
      }
      if (n < 0) {
        _m = r;
        continue ;
      }
      _c = {
        TAG: /* More */0,
        _0: v,
        _1: d,
        _2: r,
        _3: c
      };
      _m = m.l;
      continue ;
    };
  };
  const partial_arg = aux(low, m, /* End */0);
  return function (param) {
    return seq_of_enum_$2(partial_arg, param);
  };
}

const Labs = {
  empty: /* Empty */0,
  add: add$2,
  add_to_list: add_to_list$2,
  update: update$2,
  singleton: singleton$2,
  remove: remove$2,
  merge: merge$5,
  union: union$2,
  cardinal: cardinal$2,
  bindings: bindings$2,
  min_binding: min_binding$2,
  min_binding_opt: min_binding_opt$2,
  max_binding: max_binding$2,
  max_binding_opt: max_binding_opt$2,
  choose: min_binding$2,
  choose_opt: min_binding_opt$2,
  find: find$2,
  find_opt: find_opt$2,
  find_first: find_first$2,
  find_first_opt: find_first_opt$2,
  find_last: find_last$2,
  find_last_opt: find_last_opt$2,
  iter: iter$2,
  fold: fold$2,
  map: map$2,
  mapi: mapi$2,
  filter: filter$2,
  filter_map: filter_map$2,
  partition: partition$2,
  split: split$2,
  is_empty: is_empty$2,
  mem: mem$2,
  equal: equal$2,
  compare: compare$5,
  for_all: for_all$2,
  exists: exists$2,
  to_list: bindings$2,
  of_list: of_list$2,
  to_seq: to_seq$2,
  to_rev_seq: to_rev_seq$2,
  to_seq_from: to_seq_from$2,
  add_seq: add_seq$2,
  of_seq: of_seq$2
};

const dummy_table = {
  size: 0,
  methods: [undefined],
  methods_by_name: /* Empty */0,
  methods_by_label: /* Empty */0,
  previous_states: /* [] */0,
  hidden_meths: /* [] */0,
  vars: /* Empty */0,
  initializers: /* [] */0
};

const table_count = {
  contents: 0
};

function fit_size(n) {
  if (n <= 2) {
    return n;
  } else {
    return (fit_size((n + 1 | 0) / 2 | 0) << 1);
  }
}

function new_table(pub_labels) {
  table_count.contents = table_count.contents + 1 | 0;
  const len = pub_labels.length;
  const methods = Caml_array.make((len << 1) + 2 | 0, /* DummyA */0);
  Caml_array.set(methods, 0, len);
  Caml_array.set(methods, 1, (Math.imul(fit_size(len), Stdlib__Sys.word_size) / 8 | 0) - 1 | 0);
  for (let i = 0; i < len; ++i) {
    Caml_array.set(methods, (i << 1) + 3 | 0, Caml_array.get(pub_labels, i));
  }
  return {
          size: 2,
          methods: methods,
          methods_by_name: /* Empty */0,
          methods_by_label: /* Empty */0,
          previous_states: /* [] */0,
          hidden_meths: /* [] */0,
          vars: /* Empty */0,
          initializers: /* [] */0
        };
}

function resize(array, new_size) {
  const old_size = array.methods.length;
  if (new_size <= old_size) {
    return ;
  }
  const new_buck = Caml_array.make(new_size, /* DummyA */0);
  Stdlib__Array.blit(array.methods, 0, new_buck, 0, old_size);
  array.methods = new_buck;
}

function put(array, label, element) {
  resize(array, label + 1 | 0);
  Caml_array.set(array.methods, label, element);
}

const method_count = {
  contents: 0
};

const inst_var_count = {
  contents: 0
};

function new_method(table) {
  const index = table.methods.length;
  resize(table, index + 1 | 0);
  return index;
}

function get_method_label(table, name) {
  try {
    return Curry._2(find$1, name, table.methods_by_name);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      const label = new_method(table);
      table.methods_by_name = Curry._3(add$1, name, label, table.methods_by_name);
      table.methods_by_label = Curry._3(add$2, label, true, table.methods_by_label);
      return label;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function get_method_labels(table, names) {
  return Stdlib__Array.map((function (param) {
                return get_method_label(table, param);
              }), names);
}

function set_method(table, label, element) {
  method_count.contents = method_count.contents + 1 | 0;
  if (Curry._2(find$2, label, table.methods_by_label)) {
    return put(table, label, element);
  } else {
    table.hidden_meths = {
      hd: [
        label,
        element
      ],
      tl: table.hidden_meths
    };
    return ;
  }
}

function get_method(table, label) {
  try {
    return Stdlib__List.assoc(label, table.hidden_meths);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return Caml_array.get(table.methods, label);
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function to_list(arr) {
  if (arr === 0) {
    return /* [] */0;
  } else {
    return Stdlib__Array.to_list(arr);
  }
}

function narrow(table, vars, virt_meths, concr_meths) {
  const vars$1 = to_list(vars);
  const virt_meths$1 = to_list(virt_meths);
  const concr_meths$1 = to_list(concr_meths);
  const virt_meth_labs = Stdlib__List.map((function (param) {
          return get_method_label(table, param);
        }), virt_meths$1);
  const concr_meth_labs = Stdlib__List.map((function (param) {
          return get_method_label(table, param);
        }), concr_meths$1);
  table.previous_states = {
    hd: [
      table.methods_by_name,
      table.methods_by_label,
      table.hidden_meths,
      table.vars,
      virt_meth_labs,
      vars$1
    ],
    tl: table.previous_states
  };
  table.vars = Curry._3(fold, (function (lab, info, tvars) {
          if (Stdlib__List.mem(lab, vars$1)) {
            return Curry._3(add, lab, info, tvars);
          } else {
            return tvars;
          }
        }), table.vars, /* Empty */0);
  const by_name = {
    contents: /* Empty */0
  };
  const by_label = {
    contents: /* Empty */0
  };
  Stdlib__List.iter2((function (met, label) {
          by_name.contents = Curry._3(add$1, met, label, by_name.contents);
          let tmp;
          try {
            tmp = Curry._2(find$2, label, table.methods_by_label);
          }
          catch (raw_exn){
            const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.MEL_EXN_ID === Stdlib.Not_found) {
              tmp = true;
            } else {
              throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
            }
          }
          by_label.contents = Curry._3(add$2, label, tmp, by_label.contents);
        }), concr_meths$1, concr_meth_labs);
  Stdlib__List.iter2((function (met, label) {
          by_name.contents = Curry._3(add$1, met, label, by_name.contents);
          by_label.contents = Curry._3(add$2, label, false, by_label.contents);
        }), virt_meths$1, virt_meth_labs);
  table.methods_by_name = by_name.contents;
  table.methods_by_label = by_label.contents;
  table.hidden_meths = Stdlib__List.fold_right((function (met, hm) {
          if (Stdlib__List.mem(met[0], virt_meth_labs)) {
            return hm;
          } else {
            return {
                    hd: met,
                    tl: hm
                  };
          }
        }), table.hidden_meths, /* [] */0);
}

function widen(table) {
  const match = Stdlib__List.hd(table.previous_states);
  const virt_meths = match[4];
  table.previous_states = Stdlib__List.tl(table.previous_states);
  table.vars = Stdlib__List.fold_left((function (s, v) {
          return Curry._3(add, v, Curry._2(find, v, table.vars), s);
        }), match[3], match[5]);
  table.methods_by_name = match[0];
  table.methods_by_label = match[1];
  table.hidden_meths = Stdlib__List.fold_right((function (met, hm) {
          if (Stdlib__List.mem(met[0], virt_meths)) {
            return hm;
          } else {
            return {
                    hd: met,
                    tl: hm
                  };
          }
        }), table.hidden_meths, match[2]);
}

function new_slot(table) {
  const index = table.size;
  table.size = index + 1 | 0;
  return index;
}

function new_variable(table, name) {
  try {
    return Curry._2(find, name, table.vars);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      const index = new_slot(table);
      if (name !== "") {
        table.vars = Curry._3(add, name, index, table.vars);
      }
      return index;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function to_array(arr) {
  if (Caml_obj.caml_equal(arr, 0)) {
    return [];
  } else {
    return arr;
  }
}

function new_methods_variables(table, meths, vals) {
  const meths$1 = to_array(meths);
  const nmeths = meths$1.length;
  const nvals = vals.length;
  const res = Caml_array.make(nmeths + nvals | 0, 0);
  for (let i = 0; i < nmeths; ++i) {
    Caml_array.set(res, i, get_method_label(table, Caml_array.get(meths$1, i)));
  }
  for (let i$1 = 0; i$1 < nvals; ++i$1) {
    Caml_array.set(res, i$1 + nmeths | 0, new_variable(table, Caml_array.get(vals, i$1)));
  }
  return res;
}

function get_variable(table, name) {
  try {
    return Curry._2(find, name, table.vars);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/test_internalOO.ml",
                  280,
                  50
                ]
              });
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function get_variables(table, names) {
  return Stdlib__Array.map((function (param) {
                return get_variable(table, param);
              }), names);
}

function add_initializer(table, f) {
  table.initializers = {
    hd: f,
    tl: table.initializers
  };
}

function create_table(public_methods) {
  if (public_methods === 0) {
    return new_table([]);
  }
  const tags = Stdlib__Array.map(public_method_label, public_methods);
  const table = new_table(tags);
  Stdlib__Array.iteri((function (i, met) {
          const lab = (i << 1) + 2 | 0;
          table.methods_by_name = Curry._3(add$1, met, lab, table.methods_by_name);
          table.methods_by_label = Curry._3(add$2, lab, true, table.methods_by_label);
        }), public_methods);
  return table;
}

function init_class(table) {
  inst_var_count.contents = (inst_var_count.contents + table.size | 0) - 1 | 0;
  table.initializers = Stdlib__List.rev(table.initializers);
  resize(table, 3 + Caml_int32.div((Caml_array.get(table.methods, 1) << 4), Stdlib__Sys.word_size) | 0);
}

function inherits(cla, vals, virt_meths, concr_meths, param, top) {
  const $$super = param[1];
  narrow(cla, vals, virt_meths, concr_meths);
  const init = top ? Curry._2($$super, cla, param[3]) : Curry._1($$super, cla);
  widen(cla);
  return Caml_array.concat({
              hd: [init],
              tl: {
                hd: Stdlib__Array.map((function (param) {
                        return get_variable(cla, param);
                      }), to_array(vals)),
                tl: {
                  hd: Stdlib__Array.map((function (nm) {
                          return get_method(cla, get_method_label(cla, nm));
                        }), to_array(concr_meths)),
                  tl: /* [] */0
                }
              }
            });
}

function make_class(pub_meths, class_init) {
  const table = create_table(pub_meths);
  const env_init = Curry._1(class_init, table);
  init_class(table);
  return [
          Curry._1(env_init, 0),
          class_init,
          env_init,
          0
        ];
}

function make_class_store(pub_meths, class_init, init_table) {
  const table = create_table(pub_meths);
  const env_init = Curry._1(class_init, table);
  init_class(table);
  init_table.class_init = class_init;
  init_table.env_init = env_init;
}

function dummy_class(loc) {
  const undef = function (param) {
    throw new Caml_js_exceptions.MelangeError(Stdlib.Undefined_recursive_module, {
              MEL_EXN_ID: Stdlib.Undefined_recursive_module,
              _1: loc
            });
  };
  return [
          undef,
          undef,
          undef,
          0
        ];
}

function iter_f(obj, _param) {
  while(true) {
    const param = _param;
    if (!param) {
      return ;
    }
    Curry._1(param.hd, obj);
    _param = param.tl;
    continue ;
  };
}

function run_initializers(obj, table) {
  const inits = table.initializers;
  if (Caml_obj.caml_notequal(inits, /* [] */0)) {
    return iter_f(obj, inits);
  }
  
}

function run_initializers_opt(obj_0, obj, table) {
  if (obj_0) {
    return obj;
  }
  const inits = table.initializers;
  if (Caml_obj.caml_notequal(inits, /* [] */0)) {
    iter_f(obj, inits);
  }
  return obj;
}

function build_path(n, keys, tables) {
  const res = {
    key: 0,
    data: /* Empty */0,
    next: /* Empty */0
  };
  let r = res;
  for (let i = 0; i <= n; ++i) {
    r = {
      TAG: /* Cons */0,
      _0: Caml_array.get(keys, i),
      _1: r,
      _2: /* Empty */0
    };
  }
  tables.data = r;
  return res;
}

function lookup_keys(i, keys, tables) {
  if (i < 0) {
    return tables;
  }
  const key = Caml_array.get(keys, i);
  let _tables = tables;
  while(true) {
    const tables$1 = _tables;
    if (tables$1.key === key) {
      return lookup_keys(i - 1 | 0, keys, tables$1.data);
    }
    if (Caml_obj.caml_notequal(tables$1.next, /* Empty */0)) {
      _tables = tables$1.next;
      continue ;
    }
    const next = {
      TAG: /* Cons */0,
      _0: key,
      _1: /* Empty */0,
      _2: /* Empty */0
    };
    tables$1.next = next;
    return build_path(i - 1 | 0, keys, next);
  };
}

function lookup_tables(root, keys) {
  if (Caml_obj.caml_notequal(root.data, /* Empty */0)) {
    return lookup_keys(keys.length - 1 | 0, keys, root.data);
  } else {
    return build_path(keys.length - 1 | 0, keys, root);
  }
}

function get_const(x) {
  return function (obj) {
    return x;
  };
}

function get_var(n) {
  return function (obj) {
    return obj[n];
  };
}

function get_env(e, n) {
  return function (obj) {
    return obj[e][n];
  };
}

function get_meth(n) {
  return function (obj) {
    return Curry._1(obj[0][n], obj);
  };
}

function set_var(n) {
  return function (obj, x) {
    obj[n] = x;
  };
}

function app_const(f, x) {
  return function (obj) {
    return Curry._1(f, x);
  };
}

function app_var(f, n) {
  return function (obj) {
    return Curry._1(f, obj[n]);
  };
}

function app_env(f, e, n) {
  return function (obj) {
    return Curry._1(f, obj[e][n]);
  };
}

function app_meth(f, n) {
  return function (obj) {
    return Curry._1(f, Curry._1(obj[0][n], obj));
  };
}

function app_const_const(f, x, y) {
  return function (obj) {
    return Curry._2(f, x, y);
  };
}

function app_const_var(f, x, n) {
  return function (obj) {
    return Curry._2(f, x, obj[n]);
  };
}

function app_const_meth(f, x, n) {
  return function (obj) {
    return Curry._2(f, x, Curry._1(obj[0][n], obj));
  };
}

function app_var_const(f, n, x) {
  return function (obj) {
    return Curry._2(f, obj[n], x);
  };
}

function app_meth_const(f, n, x) {
  return function (obj) {
    return Curry._2(f, Curry._1(obj[0][n], obj), x);
  };
}

function app_const_env(f, x, e, n) {
  return function (obj) {
    return Curry._2(f, x, obj[e][n]);
  };
}

function app_env_const(f, e, n, x) {
  return function (obj) {
    return Curry._2(f, obj[e][n], x);
  };
}

function meth_app_const(n, x) {
  return function (obj) {
    return Curry._2(obj[0][n], obj, x);
  };
}

function meth_app_var(n, m) {
  return function (obj) {
    return Curry._2(obj[0][n], obj, obj[m]);
  };
}

function meth_app_env(n, e, m) {
  return function (obj) {
    return Curry._2(obj[0][n], obj, obj[e][m]);
  };
}

function meth_app_meth(n, m) {
  return function (obj) {
    return Curry._2(obj[0][n], obj, Curry._1(obj[0][m], obj));
  };
}

function send_const(m, x, c) {
  return function (obj) {
    return Curry._3(Curry._3(Caml_oo.caml_get_public_method, x, m, 1), x, obj[0], c);
  };
}

function send_var(m, n, c) {
  return function (obj) {
    const tmp = obj[n];
    return Curry._3(Curry._3(Caml_oo.caml_get_public_method, tmp, m, 2), tmp, obj[0], c);
  };
}

function send_env(m, e, n, c) {
  return function (obj) {
    const tmp = obj[e][n];
    return Curry._3(Curry._3(Caml_oo.caml_get_public_method, tmp, m, 3), tmp, obj[0], c);
  };
}

function send_meth(m, n, c) {
  return function (obj) {
    const tmp = Curry._1(obj[0][n], obj);
    return Curry._3(Curry._3(Caml_oo.caml_get_public_method, tmp, m, 4), tmp, obj[0], c);
  };
}

function new_cache(table) {
  const n = new_method(table);
  const n$1 = n % 2 === 0 || n > (2 + Caml_int32.div((Caml_array.get(table.methods, 1) << 4), Stdlib__Sys.word_size) | 0) ? n : new_method(table);
  Caml_array.set(table.methods, n$1, 0);
  return n$1;
}

function method_impl(table, i, arr) {
  const next = function (param) {
    i.contents = i.contents + 1 | 0;
    return Caml_array.get(arr, i.contents);
  };
  const clo = next(undefined);
  if (!/* tag */(typeof clo === "number" || typeof clo === "string")) {
    return clo;
  }
  switch (clo) {
    case /* GetConst */0 :
        const x = next(undefined);
        return function (obj) {
          return x;
        };
    case /* GetVar */1 :
        const n = next(undefined);
        return function (obj) {
          return obj[n];
        };
    case /* GetEnv */2 :
        const e = next(undefined);
        const n$1 = next(undefined);
        return get_env(e, n$1);
    case /* GetMeth */3 :
        return get_meth(next(undefined));
    case /* SetVar */4 :
        const n$2 = next(undefined);
        return function (obj, x) {
          obj[n$2] = x;
        };
    case /* AppConst */5 :
        const f = next(undefined);
        const x$1 = next(undefined);
        return function (obj) {
          return Curry._1(f, x$1);
        };
    case /* AppVar */6 :
        const f$1 = next(undefined);
        const n$3 = next(undefined);
        return function (obj) {
          return Curry._1(f$1, obj[n$3]);
        };
    case /* AppEnv */7 :
        const f$2 = next(undefined);
        const e$1 = next(undefined);
        const n$4 = next(undefined);
        return app_env(f$2, e$1, n$4);
    case /* AppMeth */8 :
        const f$3 = next(undefined);
        const n$5 = next(undefined);
        return app_meth(f$3, n$5);
    case /* AppConstConst */9 :
        const f$4 = next(undefined);
        const x$2 = next(undefined);
        const y = next(undefined);
        return function (obj) {
          return Curry._2(f$4, x$2, y);
        };
    case /* AppConstVar */10 :
        const f$5 = next(undefined);
        const x$3 = next(undefined);
        const n$6 = next(undefined);
        return app_const_var(f$5, x$3, n$6);
    case /* AppConstEnv */11 :
        const f$6 = next(undefined);
        const x$4 = next(undefined);
        const e$2 = next(undefined);
        const n$7 = next(undefined);
        return app_const_env(f$6, x$4, e$2, n$7);
    case /* AppConstMeth */12 :
        const f$7 = next(undefined);
        const x$5 = next(undefined);
        const n$8 = next(undefined);
        return app_const_meth(f$7, x$5, n$8);
    case /* AppVarConst */13 :
        const f$8 = next(undefined);
        const n$9 = next(undefined);
        const x$6 = next(undefined);
        return app_var_const(f$8, n$9, x$6);
    case /* AppEnvConst */14 :
        const f$9 = next(undefined);
        const e$3 = next(undefined);
        const n$10 = next(undefined);
        const x$7 = next(undefined);
        return app_env_const(f$9, e$3, n$10, x$7);
    case /* AppMethConst */15 :
        const f$10 = next(undefined);
        const n$11 = next(undefined);
        const x$8 = next(undefined);
        return app_meth_const(f$10, n$11, x$8);
    case /* MethAppConst */16 :
        const n$12 = next(undefined);
        const x$9 = next(undefined);
        return meth_app_const(n$12, x$9);
    case /* MethAppVar */17 :
        const n$13 = next(undefined);
        const m = next(undefined);
        return meth_app_var(n$13, m);
    case /* MethAppEnv */18 :
        const n$14 = next(undefined);
        const e$4 = next(undefined);
        const m$1 = next(undefined);
        return meth_app_env(n$14, e$4, m$1);
    case /* MethAppMeth */19 :
        const n$15 = next(undefined);
        const m$2 = next(undefined);
        return meth_app_meth(n$15, m$2);
    case /* SendConst */20 :
        const m$3 = next(undefined);
        const x$10 = next(undefined);
        return send_const(m$3, x$10, new_cache(table));
    case /* SendVar */21 :
        const m$4 = next(undefined);
        const n$16 = next(undefined);
        return send_var(m$4, n$16, new_cache(table));
    case /* SendEnv */22 :
        const m$5 = next(undefined);
        const e$5 = next(undefined);
        const n$17 = next(undefined);
        return send_env(m$5, e$5, n$17, new_cache(table));
    case /* SendMeth */23 :
        const m$6 = next(undefined);
        const n$18 = next(undefined);
        return send_meth(m$6, n$18, new_cache(table));
    
  }
}

function set_methods(table, methods) {
  const len = methods.length;
  const i = {
    contents: 0
  };
  while(i.contents < len) {
    const label = Caml_array.get(methods, i.contents);
    const clo = method_impl(table, i, methods);
    set_method(table, label, clo);
    i.contents = i.contents + 1 | 0;
  };
}

function stats(param) {
  return {
          classes: table_count.contents,
          methods: method_count.contents,
          inst_vars: inst_var_count.contents
        };
}

const initial_object_size = 2;

let dummy_item;

const dummy_met = /* DummyA */0;

exports.copy = copy;
exports.params = params;
exports.step = step;
exports.initial_object_size = initial_object_size;
exports.dummy_item = dummy_item;
exports.public_method_label = public_method_label;
exports.Vars = Vars;
exports.Meths = Meths;
exports.Labs = Labs;
exports.dummy_table = dummy_table;
exports.table_count = table_count;
exports.dummy_met = dummy_met;
exports.fit_size = fit_size;
exports.new_table = new_table;
exports.resize = resize;
exports.put = put;
exports.method_count = method_count;
exports.inst_var_count = inst_var_count;
exports.new_method = new_method;
exports.get_method_label = get_method_label;
exports.get_method_labels = get_method_labels;
exports.set_method = set_method;
exports.get_method = get_method;
exports.to_list = to_list;
exports.narrow = narrow;
exports.widen = widen;
exports.new_slot = new_slot;
exports.new_variable = new_variable;
exports.to_array = to_array;
exports.new_methods_variables = new_methods_variables;
exports.get_variable = get_variable;
exports.get_variables = get_variables;
exports.add_initializer = add_initializer;
exports.create_table = create_table;
exports.init_class = init_class;
exports.inherits = inherits;
exports.make_class = make_class;
exports.make_class_store = make_class_store;
exports.dummy_class = dummy_class;
exports.iter_f = iter_f;
exports.run_initializers = run_initializers;
exports.run_initializers_opt = run_initializers_opt;
exports.build_path = build_path;
exports.lookup_keys = lookup_keys;
exports.lookup_tables = lookup_tables;
exports.get_const = get_const;
exports.get_var = get_var;
exports.get_env = get_env;
exports.get_meth = get_meth;
exports.set_var = set_var;
exports.app_const = app_const;
exports.app_var = app_var;
exports.app_env = app_env;
exports.app_meth = app_meth;
exports.app_const_const = app_const_const;
exports.app_const_var = app_const_var;
exports.app_const_meth = app_const_meth;
exports.app_var_const = app_var_const;
exports.app_meth_const = app_meth_const;
exports.app_const_env = app_const_env;
exports.app_env_const = app_env_const;
exports.meth_app_const = meth_app_const;
exports.meth_app_var = meth_app_var;
exports.meth_app_env = meth_app_env;
exports.meth_app_meth = meth_app_meth;
exports.send_const = send_const;
exports.send_var = send_var;
exports.send_env = send_env;
exports.send_meth = send_meth;
exports.new_cache = new_cache;
exports.method_impl = method_impl;
exports.set_methods = set_methods;
exports.stats = stats;
/* Vars Not a pure module */
