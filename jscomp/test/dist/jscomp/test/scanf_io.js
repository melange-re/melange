// Generated by Melange
'use strict';

const Caml_bytes = require("melange.js/caml_bytes.js");
const Caml_external_polyfill = require("melange.js/caml_external_polyfill.js");
const Caml_io = require("melange.js/caml_io.js");
const Caml_js_exceptions = require("melange.js/caml_js_exceptions.js");
const Caml_obj = require("melange.js/caml_obj.js");
const Curry = require("melange.js/curry.js");
const Stdlib = require("melange/stdlib.js");
const Stdlib__Buffer = require("melange/buffer.js");
const Stdlib__Bytes = require("melange/bytes.js");
const Stdlib__Digest = require("melange/digest.js");
const Stdlib__List = require("melange/list.js");
const Stdlib__Printf = require("melange/printf.js");
const Stdlib__Scanf = require("melange/scanf.js");

const tscanf_data_file = "tscanf_data";

const tscanf_data_file_lines = {
  hd: [
    "Objective",
    "Caml"
  ],
  tl: /* [] */ 0
};

function create_tscanf_data(ob, lines) {
  const add_line = function (param) {
    Stdlib__Buffer.add_string(ob, Curry._1(Stdlib__Printf.sprintf({
                TAG: /* Format */ 0,
                _0: {
                  TAG: /* Caml_string */ 3,
                  _0: /* No_padding */ 0,
                  _1: /* End_of_format */ 0
                },
                _1: "%S"
              }), param[0]));
    Stdlib__Buffer.add_string(ob, " -> ");
    Stdlib__Buffer.add_string(ob, Curry._1(Stdlib__Printf.sprintf({
                TAG: /* Format */ 0,
                _0: {
                  TAG: /* Caml_string */ 3,
                  _0: /* No_padding */ 0,
                  _1: /* End_of_format */ 0
                },
                _1: "%S"
              }), param[1]));
    Stdlib__Buffer.add_string(ob, ";\n");
  };
  Stdlib__List.iter(add_line, lines);
}

function write_tscanf_data_file(fname, lines) {
  const oc = Stdlib.open_out(fname);
  const ob = Stdlib__Buffer.create(42);
  create_tscanf_data(ob, lines);
  Stdlib__Buffer.output_buffer(oc, ob);
  Caml_io.caml_ml_flush(oc);
  Caml_external_polyfill.resolve("caml_ml_close_channel")(oc);
}

function get_lines(fname) {
  const ib = Stdlib__Scanf.Scanning.from_file(fname);
  const l = {
    contents: /* [] */ 0
  };
  try {
    while (!Stdlib__Scanf.Scanning.end_of_input(ib)) {
      Curry._1(Stdlib__Scanf.bscanf(ib, {
              TAG: /* Format */ 0,
              _0: {
                TAG: /* Char_literal */ 12,
                _0: /* ' ' */32,
                _1: {
                  TAG: /* Caml_string */ 3,
                  _0: /* No_padding */ 0,
                  _1: {
                    TAG: /* String_literal */ 11,
                    _0: " -> ",
                    _1: {
                      TAG: /* Caml_string */ 3,
                      _0: /* No_padding */ 0,
                      _1: {
                        TAG: /* String_literal */ 11,
                        _0: "; ",
                        _1: /* End_of_format */ 0
                      }
                    }
                  }
                }
              },
              _1: " %S -> %S; "
            }), (function (x, y) {
          l.contents = {
            hd: [
              x,
              y
            ],
            tl: l.contents
          };
        }));
    };
    return Stdlib__List.rev(l.contents);
  }
  catch (raw_s){
    const s = Caml_js_exceptions.internalToOCamlException(raw_s);
    if (s.MEL_EXN_ID === Stdlib__Scanf.Scan_failure) {
      const s$1 = Curry._2(Stdlib__Printf.sprintf({
              TAG: /* Format */ 0,
              _0: {
                TAG: /* String_literal */ 11,
                _0: "in file ",
                _1: {
                  TAG: /* String */ 2,
                  _0: /* No_padding */ 0,
                  _1: {
                    TAG: /* String_literal */ 11,
                    _0: ", ",
                    _1: {
                      TAG: /* String */ 2,
                      _0: /* No_padding */ 0,
                      _1: /* End_of_format */ 0
                    }
                  }
                }
              },
              _1: "in file %s, %s"
            }), fname, s._1);
      throw new Caml_js_exceptions.MelangeError("Failure", {
            MEL_EXN_ID: "Failure",
            _1: s$1
          });
    }
    if (s.MEL_EXN_ID === Stdlib.End_of_file) {
      const s$2 = Curry._1(Stdlib__Printf.sprintf({
              TAG: /* Format */ 0,
              _0: {
                TAG: /* String_literal */ 11,
                _0: "in file ",
                _1: {
                  TAG: /* String */ 2,
                  _0: /* No_padding */ 0,
                  _1: {
                    TAG: /* String_literal */ 11,
                    _0: ", unexpected end of file",
                    _1: /* End_of_format */ 0
                  }
                }
              },
              _1: "in file %s, unexpected end of file"
            }), fname);
      throw new Caml_js_exceptions.MelangeError("Failure", {
            MEL_EXN_ID: "Failure",
            _1: s$2
          });
    }
    throw new Caml_js_exceptions.MelangeError(s.MEL_EXN_ID, s);
  }
}

function add_digest_ib(ob, ib) {
  const scan_line = function (ib, f) {
    return Curry._1(Stdlib__Scanf.bscanf(ib, {
            TAG: /* Format */ 0,
            _0: {
              TAG: /* Scan_char_set */ 20,
              _0: undefined,
              _1: "\xff\xdb\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff",
              _2: {
                TAG: /* Char_literal */ 12,
                _0: /* '\n' */10,
                _1: /* End_of_format */ 0
              }
            },
            _1: "%[^\n\r]\n"
          }), f);
  };
  const output_line_digest = function (s) {
    Stdlib__Buffer.add_string(ob, s);
    Stdlib__Buffer.add_char(ob, /* '#' */35);
    const s$1 = Stdlib__Digest.to_hex(Stdlib__Digest.string(s));
    Stdlib__Buffer.add_string(ob, Caml_bytes.bytes_to_string(Stdlib__Bytes.uppercase_ascii(Caml_bytes.bytes_of_string(s$1))));
    Stdlib__Buffer.add_char(ob, /* '\n' */10);
  };
  try {
    while (true) {
      scan_line(ib, output_line_digest);
    };
    return;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
      return;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function digest_file(fname) {
  const ib = Stdlib__Scanf.Scanning.from_file(fname);
  const ob = Stdlib__Buffer.create(42);
  add_digest_ib(ob, ib);
  return Stdlib__Buffer.contents(ob);
}

function test54(param) {
  return Caml_obj.caml_equal(get_lines(tscanf_data_file), tscanf_data_file_lines);
}

function test55(param) {
  const ob = Stdlib__Buffer.create(42);
  create_tscanf_data(ob, tscanf_data_file_lines);
  const s = Stdlib__Buffer.contents(ob);
  ob.position = 0;
  const ib = Stdlib__Scanf.Scanning.from_string(s);
  add_digest_ib(ob, ib);
  const tscanf_data_file_lines_digest = Stdlib__Buffer.contents(ob);
  return digest_file(tscanf_data_file) === tscanf_data_file_lines_digest;
}

module.exports = {
  tscanf_data_file,
  tscanf_data_file_lines,
  create_tscanf_data,
  write_tscanf_data_file,
  get_lines,
  add_digest_ib,
  digest_file,
  test54,
  test55,
}
/* Stdlib__Digest Not a pure module */
