// Generated by Melange
'use strict';

const Caml_array = require("melange.js/caml_array.js");
const Caml_bytes = require("melange.js/caml_bytes.js");
const Caml_external_polyfill = require("melange.js/caml_external_polyfill.js");
const Caml_io = require("melange.js/caml_io.js");
const Caml_js_exceptions = require("melange.js/caml_js_exceptions.js");
const Caml_obj = require("melange.js/caml_obj.js");
const Caml_option = require("melange.js/caml_option.js");
const Caml_string = require("melange.js/caml_string.js");
const Caml_sys = require("melange.js/caml_sys.js");
const Curry = require("melange.js/curry.js");
const Stdlib = require("melange/stdlib.js");
const Stdlib__Bytes = require("melange/bytes.js");
const Stdlib__Char = require("melange/char.js");
const Stdlib__List = require("melange/list.js");
const Stdlib__Printf = require("melange/printf.js");
const Stdlib__String = require("melange/string.js");

const dbg = {
  contents: true
};

const inch = {
  contents: Stdlib.stdin
};

function bufferize(f) {
  const buf = {
    contents: undefined
  };
  return [
    (function (param) {
      const x = buf.contents;
      if (x !== undefined) {
        buf.contents = undefined;
        return Caml_option.valFromOption(x);
      } else {
        return Curry._1(f, undefined);
      }
    }),
    (function (x) {
      if (buf.contents !== undefined) {
        throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/qcc.ml",
                17,
                4
              ]
            });
      }
      buf.contents = Caml_option.some(x);
    })
  ];
}

const match = bufferize(function (param) {
      return Caml_external_polyfill.resolve("caml_ml_input_char")(inch.contents);
    });

const ungetch = match[1];

const getch = match[0];

function peekch(param) {
  const ch = Curry._1(getch, undefined);
  Curry._1(ungetch, ch);
  return ch;
}

const symtab = Caml_array.make(100, "");

const syms = {
  contents: 0
};

function find(s, _n) {
  while (true) {
    const n = _n;
    if (n >= syms.contents) {
      syms.contents = syms.contents + 1 | 0;
      return n;
    }
    if (Caml_array.get(symtab, n) === s) {
      return n;
    }
    _n = n + 1 | 0;
    continue;
  };
}

function addsym(s) {
  const sid = find(s, 0);
  Caml_array.set(symtab, sid, s);
  return sid;
}

function symstr(n) {
  if (n >= syms.contents) {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "jscomp/test/qcc.ml",
            40,
            4
          ]
        });
  }
  return Caml_array.get(symtab, n);
}

function symitr(f) {
  for (let i = 0, i_finish = syms.contents; i < i_finish; ++i) {
    Curry._2(f, i, Caml_array.get(symtab, i));
  }
}

const glo = Stdlib__Bytes.make(4096, /* '\000' */0);

const gpos = {
  contents: 0
};

const s = Caml_bytes.caml_create_bytes(100);

function getq(param) {
  const c = Curry._1(getch, undefined);
  if (c !== 92 || peekch(undefined) !== /* 'n' */110) {
    return c;
  } else {
    Curry._1(getch, undefined);
    return /* '\n' */10;
  }
}

function isid(param) {
  if (param > 96 || param < 91) {
    return !(param > 122 || param < 65);
  } else {
    return param === 95;
  }
}

function skip(_param) {
  while (true) {
    const ch = Curry._1(getch, undefined);
    if (ch >= 14) {
      if (ch !== 32) {
        if (ch !== 47 || peekch(undefined) !== /* '*' */42) {
          return ch;
        } else {
          let _param$1 = (Curry._1(getch, undefined), undefined);
          while (true) {
            const match = Curry._1(getch, undefined);
            if (match !== 42) {
              _param$1 = undefined;
              continue;
            }
            if (peekch(undefined) === /* '/' */47) {
              return skip((Curry._1(getch, undefined), undefined));
            }
            _param$1 = undefined;
            continue;
          };
        }
      }
      _param = undefined;
      continue;
    }
    if (ch >= 11) {
      if (ch < 13) {
        return ch;
      }
      _param = undefined;
      continue;
    }
    if (ch < 9) {
      return ch;
    }
    _param = undefined;
    continue;
  };
}

function next(param) {
  let c;
  try {
    c = skip(undefined);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
      c = undefined;
    } else {
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  }
  if (c === undefined) {
    return {
      TAG: /* Op */ 0,
      _0: "EOF!"
    };
  }
  if (c === 34) {
    let b = gpos.contents;
    let _e = gpos.contents;
    while (true) {
      const e = _e;
      const match = peekch(undefined);
      if (match !== 34) {
        Caml_bytes.set(glo, e, getq(undefined));
        _e = e + 1 | 0;
        continue;
      }
      Curry._1(getch, undefined);
      gpos.contents = e + 8 & -8;
      return {
        TAG: /* SLit */ 2,
        _0: (b + 232 | 0) + 4194304 | 0,
        _1: Stdlib__Bytes.to_string(Stdlib__Bytes.sub(glo, b, e - b | 0))
      };
    };
  }
  if (c >= 48) {
    if (c < 58) {
      let _n = c - 48 | 0;
      while (true) {
        const n = _n;
        const match$1 = peekch(undefined);
        if (match$1 > 57 || match$1 < 48) {
          return {
            TAG: /* ILit */ 1,
            _0: n
          };
        }
        _n = (Math.imul(10, n) + Curry._1(getch, undefined) | 0) - 48 | 0;
        continue;
      };
    }
    
  } else if (c === 39) {
    const ch = getq(undefined);
    const qt = Curry._1(getch, undefined);
    if (qt !== /* '\'' */39) {
      throw new Caml_js_exceptions.MelangeError("Failure", {
            MEL_EXN_ID: "Failure",
            _1: "syntax error"
          });
    }
    return {
      TAG: /* ILit */ 1,
      _0: ch
    };
  }
  if (isid(c)) {
    let _n$1 = 0;
    let _ch = c;
    while (true) {
      const ch$1 = _ch;
      const n$1 = _n$1;
      Caml_bytes.set(s, n$1, ch$1);
      if (!isid(peekch(undefined))) {
        return {
          TAG: /* Sym */ 3,
          _0: addsym(Stdlib__Bytes.to_string(Stdlib__Bytes.sub(s, 0, n$1 + 1 | 0)))
        };
      }
      _ch = Curry._1(getch, undefined);
      _n$1 = n$1 + 1 | 0;
      continue;
    };
  } else {
    let _param = {
      hd: "++",
      tl: {
        hd: "--",
        tl: {
          hd: "&&",
          tl: {
            hd: "||",
            tl: {
              hd: "==",
              tl: {
                hd: "<=",
                tl: {
                  hd: ">=",
                  tl: {
                    hd: "!=",
                    tl: {
                      hd: ">>",
                      tl: {
                        hd: "<<",
                        tl: /* [] */ 0
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
    while (true) {
      const param$1 = _param;
      if (!param$1) {
        return {
          TAG: /* Op */ 0,
          _0: Caml_bytes.bytes_to_string(Stdlib__Bytes.make(1, c))
        };
      }
      const lop = param$1.hd;
      if (Caml_string.get(lop, 0) === c && Caml_string.get(lop, 1) === peekch(undefined)) {
        Curry._1(getch, undefined);
        return {
          TAG: /* Op */ 0,
          _0: lop
        };
      }
      _param = param$1.tl;
      continue;
    };
  }
}

const match$1 = bufferize(next);

const unnext = match$1[1];

const next$1 = match$1[0];

function nextis(t) {
  const nt = Curry._1(next$1, undefined);
  Curry._1(unnext, nt);
  return Caml_obj.caml_equal(t, nt);
}

const obuf = Stdlib__Bytes.make(1048576, /* '\000' */0);

const opos = {
  contents: 0
};

function out(x) {
  if (x !== 0) {
    out(x / 256 | 0);
    Caml_bytes.set(obuf, opos.contents, Stdlib__Char.chr(x & 255));
    opos.contents = opos.contents + 1 | 0;
    return;
  }
  
}

function le(n, x) {
  for (let i = 0, i_finish = n / 8 | 0; i < i_finish; ++i) {
    const $$byte = (x >>> (i << 3)) & 255;
    Caml_bytes.set(obuf, opos.contents, Stdlib__Char.chr($$byte));
    opos.contents = opos.contents + 1 | 0;
  }
}

function get32(l) {
  return ((Caml_bytes.get(obuf, l) + (Caml_bytes.get(obuf, l + 1 | 0) << 8) | 0) + (Caml_bytes.get(obuf, l + 2 | 0) << 16) | 0) + (Caml_bytes.get(obuf, l + 3 | 0) << 24) | 0;
}

function patch(rel, loc, n) {
  if (n >= 0) {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "jscomp/test/qcc.ml",
            157,
            2
          ]
        });
  }
  if (loc === 0) {
    return;
  }
  const i = opos.contents;
  const loc$p = get32(loc);
  const x = rel ? n - (loc + 4 | 0) | 0 : n;
  if (dbg.contents) {
    Curry._3(Stdlib__Printf.eprintf({
            TAG: /* Format */ 0,
            _0: {
              TAG: /* String_literal */ 11,
              _0: "patching at ",
              _1: {
                TAG: /* Int */ 4,
                _0: /* Int_d */ 0,
                _1: /* No_padding */ 0,
                _2: /* No_precision */ 0,
                _3: {
                  TAG: /* String_literal */ 11,
                  _0: " to ",
                  _1: {
                    TAG: /* Int */ 4,
                    _0: /* Int_d */ 0,
                    _1: /* No_padding */ 0,
                    _2: /* No_precision */ 0,
                    _3: {
                      TAG: /* String_literal */ 11,
                      _0: " (n=",
                      _1: {
                        TAG: /* Int */ 4,
                        _0: /* Int_d */ 0,
                        _1: /* No_padding */ 0,
                        _2: /* No_precision */ 0,
                        _3: {
                          TAG: /* String_literal */ 11,
                          _0: ")\n",
                          _1: /* End_of_format */ 0
                        }
                      }
                    }
                  }
                }
              }
            },
            _1: "patching at %d to %d (n=%d)\n"
          }), loc, x, n);
  }
  opos.contents = loc;
  le(32, x);
  patch(rel, loc$p, n);
  opos.contents = i;
}

function load(r, n) {
  out(184 + r | 0);
  le(32, n);
}

function cmp(n) {
  load(0, 0);
  out(1020608 + (n << 8) | 0);
}

function test(n, l) {
  out(4752832);
  out(3972 + n | 0);
  const loc = opos.contents;
  le(32, l);
  return loc;
}

const align = {
  contents: 0
};

function push(r) {
  align.contents = align.contents + 1 | 0;
  if (r < 8) {
    return out(80 + r | 0);
  } else {
    return out((16720 + r | 0) - 8 | 0);
  }
}

function pop(r) {
  align.contents = align.contents - 1 | 0;
  if (r < 8) {
    return out(88 + r | 0);
  } else {
    return out((16728 + r | 0) - 8 | 0);
  }
}

const lval = {
  contents: [
    {
      TAG: /* Mov */ 0,
      _0: 0
    },
    /* Int */ 0
  ]
};

function patchlval(param) {
  const n = lval.contents[0];
  if (n.TAG === /* Mov */ 0) {
    return Caml_bytes.set(obuf, opos.contents - n._0 | 0, /* '\141' */141);
  } else {
    opos.contents = opos.contents - n._0 | 0;
    return;
  }
}

function read(param) {
  if (param === /* Int */ 0) {
    out(18571);
    le(8, 0);
    lval.contents = [
      {
        TAG: /* Del */ 1,
        _0: 3
      },
      /* Int */ 0
    ];
    return;
  }
  out(4722614);
  le(8, 0);
  lval.contents = [
    {
      TAG: /* Del */ 1,
      _0: 4
    },
    /* Chr */ 1
  ];
}

const globs = Caml_array.make(100, {
      loc: 0,
      va: -1
    });

const lvls = {
  hd: [
    "*",
    0
  ],
  tl: {
    hd: [
      "/",
      0
    ],
    tl: {
      hd: [
        "%",
        0
      ],
      tl: {
        hd: [
          "+",
          1
        ],
        tl: {
          hd: [
            "-",
            1
          ],
          tl: {
            hd: [
              "<<",
              2
            ],
            tl: {
              hd: [
                ">>",
                2
              ],
              tl: {
                hd: [
                  "<",
                  3
                ],
                tl: {
                  hd: [
                    "<=",
                    3
                  ],
                  tl: {
                    hd: [
                      ">",
                      3
                    ],
                    tl: {
                      hd: [
                        ">=",
                        3
                      ],
                      tl: {
                        hd: [
                          "==",
                          4
                        ],
                        tl: {
                          hd: [
                            "!=",
                            4
                          ],
                          tl: {
                            hd: [
                              "&",
                              5
                            ],
                            tl: {
                              hd: [
                                "^",
                                6
                              ],
                              tl: {
                                hd: [
                                  "|",
                                  7
                                ],
                                tl: {
                                  hd: [
                                    "&&",
                                    8
                                  ],
                                  tl: {
                                    hd: [
                                      "||",
                                      9
                                    ],
                                    tl: /* [] */ 0
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
};

const inss = {
  hd: [
    "*",
    {
      TAG: /* Bin */ 0,
      _0: {
        hd: 1208987585,
        tl: /* [] */ 0
      }
    }
  ],
  tl: {
    hd: [
      "/",
      {
        TAG: /* Bin */ 0,
        _0: {
          hd: 18577,
          tl: {
            hd: 18585,
            tl: {
              hd: 4782073,
              tl: /* [] */ 0
            }
          }
        }
      }
    ],
    tl: {
      hd: [
        "%",
        {
          TAG: /* Bin */ 0,
          _0: {
            hd: 18577,
            tl: {
              hd: 18585,
              tl: {
                hd: 4782073,
                tl: {
                  hd: 18578,
                  tl: /* [] */ 0
                }
              }
            }
          }
        }
      ],
      tl: {
        hd: [
          "+",
          {
            TAG: /* Bin */ 0,
            _0: {
              hd: 4719048,
              tl: /* [] */ 0
            }
          }
        ],
        tl: {
          hd: [
            "-",
            {
              TAG: /* Bin */ 0,
              _0: {
                hd: 18577,
                tl: {
                  hd: 4729288,
                  tl: /* [] */ 0
                }
              }
            }
          ],
          tl: {
            hd: [
              "<<",
              {
                TAG: /* Bin */ 0,
                _0: {
                  hd: 18577,
                  tl: {
                    hd: 4772832,
                    tl: /* [] */ 0
                  }
                }
              }
            ],
            tl: {
              hd: [
                ">>",
                {
                  TAG: /* Bin */ 0,
                  _0: {
                    hd: 18577,
                    tl: {
                      hd: 4772856,
                      tl: /* [] */ 0
                    }
                  }
                }
              ],
              tl: {
                hd: [
                  "<",
                  {
                    TAG: /* Cmp */ 1,
                    _0: 10
                  }
                ],
                tl: {
                  hd: [
                    "<=",
                    {
                      TAG: /* Cmp */ 1,
                      _0: 12
                    }
                  ],
                  tl: {
                    hd: [
                      ">",
                      {
                        TAG: /* Cmp */ 1,
                        _0: 13
                      }
                    ],
                    tl: {
                      hd: [
                        ">=",
                        {
                          TAG: /* Cmp */ 1,
                          _0: 11
                        }
                      ],
                      tl: {
                        hd: [
                          "==",
                          {
                            TAG: /* Cmp */ 1,
                            _0: 2
                          }
                        ],
                        tl: {
                          hd: [
                            "!=",
                            {
                              TAG: /* Cmp */ 1,
                              _0: 3
                            }
                          ],
                          tl: {
                            hd: [
                              "&",
                              {
                                TAG: /* Bin */ 0,
                                _0: {
                                  hd: 4727240,
                                  tl: /* [] */ 0
                                }
                              }
                            ],
                            tl: {
                              hd: [
                                "^",
                                {
                                  TAG: /* Bin */ 0,
                                  _0: {
                                    hd: 4731336,
                                    tl: /* [] */ 0
                                  }
                                }
                              ],
                              tl: {
                                hd: [
                                  "|",
                                  {
                                    TAG: /* Bin */ 0,
                                    _0: {
                                      hd: 4721096,
                                      tl: /* [] */ 0
                                    }
                                  }
                                ],
                                tl: /* [] */ 0
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
};

const tokint = {
  TAG: /* Sym */ 3,
  _0: addsym("int")
};

const tokchar = {
  TAG: /* Sym */ 3,
  _0: addsym("char")
};

const tokret = {
  TAG: /* Sym */ 3,
  _0: addsym("return")
};

const tokif = {
  TAG: /* Sym */ 3,
  _0: addsym("if")
};

const tokelse = {
  TAG: /* Sym */ 3,
  _0: addsym("else")
};

const tokwhile = {
  TAG: /* Sym */ 3,
  _0: addsym("while")
};

const tokfor = {
  TAG: /* Sym */ 3,
  _0: addsym("for")
};

const tokbreak = {
  TAG: /* Sym */ 3,
  _0: addsym("break")
};

function binary(stk, lvl) {
  if (lvl === -1) {
    return unary(stk);
  }
  const lvlof = function (o) {
    if (Stdlib__List.mem_assoc(o, lvls)) {
      return Stdlib__List.assoc(o, lvls);
    } else {
      return -1;
    }
  };
  const foldtst = function (_loc) {
    while (true) {
      const loc = _loc;
      const o = Curry._1(next$1, undefined);
      if (o.TAG === /* Op */ 0) {
        if (lvlof(o._0) === lvl) {
          const loc$p = test(lvl - 8 | 0, loc);
          binary(stk, lvl - 1 | 0);
          _loc = loc$p;
          continue;
        }
        Curry._1(unnext, o);
        return loc;
      }
      Curry._1(unnext, o);
      return loc;
    };
  };
  binary(stk, lvl - 1 | 0);
  if (lvl < 8) {
    let _param;
    while (true) {
      const o = Curry._1(next$1, undefined);
      if (o.TAG !== /* Op */ 0) {
        return Curry._1(unnext, o);
      }
      const o$1 = o._0;
      if (lvlof(o$1) !== lvl) {
        return Curry._1(unnext, o);
      }
      push(0);
      binary(stk, lvl - 1 | 0);
      pop(1);
      const ops = Stdlib__List.assoc(o$1, inss);
      if (ops.TAG === /* Bin */ 0) {
        Stdlib__List.iter(out, ops._0);
      } else {
        out(4733377);
        cmp(ops._0);
      }
      _param = undefined;
      continue;
    };
  }
  const loc = foldtst(0);
  patch(true, loc, opos.contents);
}

function unary(stk) {
  const i = Curry._1(next$1, undefined);
  switch (i.TAG) {
    case /* Op */ 0 :
      const o = i._0;
      switch (o) {
        case "&" :
          unary(stk);
          return patchlval(undefined);
        case "(" :
          expr(stk);
          Curry._1(next$1, undefined);
          return postfix(stk);
        case "*" :
          Curry._1(next$1, undefined);
          const t = Curry._1(next$1, undefined);
          let match;
          if (Caml_obj.caml_equal(t, tokint)) {
            match = Caml_obj.caml_equal(Curry._1(next$1, undefined), {
                  TAG: /* Op */ 0,
                  _0: "*"
                }) ? [
                /* Int */ 0,
                1
              ] : [
                /* Int */ 0,
                5
              ];
          } else if (Caml_obj.caml_equal(t, tokchar)) {
            match = [
              /* Chr */ 1,
              2
            ];
          } else {
            throw new Caml_js_exceptions.MelangeError("Failure", {
                  MEL_EXN_ID: "Failure",
                  _1: "[cast] expected"
                });
          }
          for (let _k = 1, _k_finish = match[1]; _k <= _k_finish; ++_k) {
            Curry._1(next$1, undefined);
          }
          unary(stk);
          return read(match[0]);
        default:
          const unops = {
            hd: [
              "+",
              0
            ],
            tl: {
              hd: [
                "-",
                4782040
              ],
              tl: {
                hd: [
                  "~",
                  4782032
                ],
                tl: {
                  hd: [
                    "!",
                    4752832
                  ],
                  tl: /* [] */ 0
                }
              }
            }
          };
          unary(stk);
          if (!Stdlib__List.mem_assoc(o, unops)) {
            const s = Curry._1(Stdlib__Printf.sprintf({
                    TAG: /* Format */ 0,
                    _0: {
                      TAG: /* String_literal */ 11,
                      _0: "unknown operator ",
                      _1: {
                        TAG: /* String */ 2,
                        _0: /* No_padding */ 0,
                        _1: /* End_of_format */ 0
                      }
                    },
                    _1: "unknown operator %s"
                  }), o);
            throw new Caml_js_exceptions.MelangeError("Failure", {
                  MEL_EXN_ID: "Failure",
                  _1: s
                });
          }
          out(Stdlib__List.assoc(o, unops));
          if (o === "!") {
            return cmp(2);
          } else {
            return;
          }
      }
    case /* ILit */ 1 :
      return load(0, i._0);
    case /* SLit */ 2 :
      out(18616);
      return le(64, i._0);
    case /* Sym */ 3 :
      const i$1 = i._0;
      if (Stdlib__List.mem_assoc(i$1, stk)) {
        const l = Stdlib__List.assoc(i$1, stk);
        if (l <= -256) {
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/qcc.ml",
                  295,
                  6
                ]
              });
        }
        out(4754245);
        out(l & 255);
        lval.contents = [
          {
            TAG: /* Mov */ 0,
            _0: 3
          },
          /* Int */ 0
        ];
      } else {
        out(18616);
        const g = Caml_array.get(globs, i$1);
        const loc = opos.contents;
        le(64, g.loc);
        Caml_array.set(globs, i$1, {
              loc: loc,
              va: g.va
            });
        read(/* Int */ 0);
      }
      return postfix(stk);
  }
}

function postfix(stk) {
  const op = Curry._1(next$1, undefined);
  if (op.TAG !== /* Op */ 0) {
    return Curry._1(unnext, op);
  }
  const op$1 = op._0;
  switch (op$1) {
    case "(" :
      const emitargs = function (_l, _rl) {
        while (true) {
          const rl = _rl;
          const l = _l;
          if (nextis({
                  TAG: /* Op */ 0,
                  _0: ")"
                })) {
            Curry._1(next$1, undefined);
            return Stdlib__List.iter(pop, l);
          }
          expr(stk);
          push(0);
          if (nextis({
                  TAG: /* Op */ 0,
                  _0: ","
                })) {
            Curry._1(next$1, undefined);
          }
          _rl = Stdlib__List.tl(rl);
          _l = {
            hd: Stdlib__List.hd(rl),
            tl: l
          };
          continue;
        };
      };
      patchlval(undefined);
      push(0);
      emitargs(/* [] */ 0, {
            hd: 7,
            tl: {
              hd: 6,
              tl: {
                hd: 2,
                tl: {
                  hd: 1,
                  tl: {
                    hd: 8,
                    tl: {
                      hd: 9,
                      tl: /* [] */ 0
                    }
                  }
                }
              }
            }
          });
      pop(0);
      if (align.contents % 2 !== 0) {
        out(1216605192);
      }
      out(65488);
      if (align.contents % 2 !== 0) {
        return out(1216594952);
      } else {
        return;
      }
    case "++" :
    case "--" :
      break;
    default:
      return Curry._1(unnext, op);
  }
  patchlval(undefined);
  out(4753857);
  read(lval.contents[1]);
  out(Stdlib__List.assoc([
            op$1,
            lval.contents[1]
          ], {
            hd: [
              [
                "++",
                /* Int */ 0
              ],
              4783873
            ],
            tl: {
              hd: [
                [
                  "--",
                  /* Int */ 0
                ],
                4783881
              ],
              tl: {
                hd: [
                  [
                    "++",
                    /* Chr */ 1
                  ],
                  65025
                ],
                tl: {
                  hd: [
                    [
                      "--",
                      /* Chr */ 1
                    ],
                    65033
                  ],
                  tl: /* [] */ 0
                }
              }
            }
          }));
}

function expr(stk) {
  binary(stk, 10);
  let _param;
  while (true) {
    const t = Curry._1(next$1, undefined);
    if (t.TAG !== /* Op */ 0) {
      return Curry._1(unnext, t);
    }
    if (t._0 !== "=") {
      return Curry._1(unnext, t);
    }
    patchlval(undefined);
    const ty = lval.contents[1];
    push(0);
    expr(stk);
    pop(1);
    if (ty === /* Int */ 0) {
      out(4753665);
    } else {
      out(34817);
    }
    _param = undefined;
    continue;
  };
}

function decl(g, _n, _stk) {
  while (true) {
    const stk = _stk;
    const n = _n;
    const t = Curry._1(next$1, undefined);
    if (Caml_obj.caml_equal(t, tokint)) {
      const top = stk ? stk.hd[1] : 0;
      const vars = function (_n, _stk) {
        while (true) {
          const stk = _stk;
          const n = _n;
          while (nextis({
                  TAG: /* Op */ 0,
                  _0: "*"
                })) {
            Curry._1(next$1, undefined);
          };
          if (nextis({
                  TAG: /* Op */ 0,
                  _0: ";"
                })) {
            return [
              n,
              stk
            ];
          }
          const s = Curry._1(next$1, undefined);
          if (s.TAG === /* Sym */ 3) {
            const s$1 = s._0;
            const n$p = n + 1 | 0;
            let stk$p;
            if (g) {
              const glo = Caml_array.get(globs, s$1);
              if (glo.va >= 0) {
                throw new Caml_js_exceptions.MelangeError("Failure", {
                      MEL_EXN_ID: "Failure",
                      _1: "symbol defined twice"
                    });
              }
              const va = (gpos.contents + 232 | 0) + 4194304 | 0;
              Caml_array.set(globs, s$1, {
                    loc: glo.loc,
                    va: va
                  });
              gpos.contents = gpos.contents + 8 | 0;
              stk$p = stk;
            } else {
              stk$p = {
                hd: [
                  s$1,
                  top - (n$p << 3) | 0
                ],
                tl: stk
              };
            }
            if (!nextis({
                    TAG: /* Op */ 0,
                    _0: ","
                  })) {
              return [
                n$p,
                stk$p
              ];
            }
            Curry._1(next$1, undefined);
            _stk = stk$p;
            _n = n$p;
            continue;
          }
          throw new Caml_js_exceptions.MelangeError("Failure", {
                MEL_EXN_ID: "Failure",
                _1: "[var] expected in [decl]"
              });
        };
      };
      const match = vars(0, stk);
      Curry._1(next$1, undefined);
      if (dbg.contents) {
        Curry._1(Stdlib__Printf.eprintf({
                TAG: /* Format */ 0,
                _0: {
                  TAG: /* String_literal */ 11,
                  _0: "end of decl (",
                  _1: {
                    TAG: /* Int */ 4,
                    _0: /* Int_d */ 0,
                    _1: /* No_padding */ 0,
                    _2: /* No_precision */ 0,
                    _3: {
                      TAG: /* String_literal */ 11,
                      _0: " vars)\n",
                      _1: /* End_of_format */ 0
                    }
                  }
                },
                _1: "end of decl (%d vars)\n"
              }), n);
      }
      _stk = match[1];
      _n = n + match[0] | 0;
      continue;
    }
    Curry._1(unnext, t);
    if (!g && n !== 0) {
      if ((n << 3) >= 256) {
        throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/qcc.ml",
                436,
                6
              ]
            });
      }
      out(4752364);
      out((n << 3));
      align.contents = align.contents + n | 0;
    }
    if (dbg.contents && !g) {
      console.error("end of blk decls");
    }
    return [
      n,
      stk
    ];
  };
}

const retl = {
  contents: 0
};

function stmt(brk, stk) {
  const pexpr = function (stk) {
    Curry._1(next$1, undefined);
    expr(stk);
    Curry._1(next$1, undefined);
  };
  const t = Curry._1(next$1, undefined);
  if (Caml_obj.caml_equal(t, tokif)) {
    pexpr(stk);
    const loc = test(0, 0);
    stmt(brk, stk);
    let loc$1;
    if (nextis(tokelse)) {
      Curry._1(next$1, undefined);
      out(233);
      const l = opos.contents;
      le(32, 0);
      patch(true, loc, opos.contents);
      stmt(brk, stk);
      loc$1 = l;
    } else {
      loc$1 = loc;
    }
    return patch(true, loc$1, opos.contents);
  }
  if (Caml_obj.caml_equal(t, tokwhile) || Caml_obj.caml_equal(t, tokfor)) {
    const bl = {
      contents: 0
    };
    const ba = align.contents;
    let match;
    if (Caml_obj.caml_equal(t, tokwhile)) {
      const loc$2 = opos.contents;
      pexpr(stk);
      bl.contents = test(0, 0);
      match = [
        0,
        loc$2
      ];
    } else {
      Curry._1(next$1, undefined);
      if (!nextis({
              TAG: /* Op */ 0,
              _0: ";"
            })) {
        expr(stk);
      }
      Curry._1(next$1, undefined);
      const top = opos.contents;
      if (nextis({
              TAG: /* Op */ 0,
              _0: ";"
            })) {
        bl.contents = 0;
      } else {
        expr(stk);
        bl.contents = test(0, 0);
      }
      Curry._1(next$1, undefined);
      out(233);
      const bdy = opos.contents;
      le(32, 0);
      const itr = opos.contents;
      expr(stk);
      Curry._1(next$1, undefined);
      out(233);
      le(32, (top - opos.contents | 0) - 4 | 0);
      match = [
        bdy,
        itr
      ];
    }
    patch(true, match[0], opos.contents);
    stmt([
          bl,
          ba
        ], stk);
    out(233);
    le(32, (match[1] - opos.contents | 0) - 4 | 0);
    return patch(true, bl.contents, opos.contents);
  }
  if (Caml_obj.caml_equal(t, tokret)) {
    if (!nextis({
            TAG: /* Op */ 0,
            _0: ";"
          })) {
      expr(stk);
    }
    Curry._1(next$1, undefined);
    out(233);
    const loc$3 = opos.contents;
    le(32, retl.contents);
    retl.contents = loc$3;
    return;
  }
  if (Caml_obj.caml_equal(t, tokbreak)) {
    Curry._1(next$1, undefined);
    const brkl = brk[0];
    const n = align.contents - brk[1] | 0;
    if (n < 0) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/qcc.ml",
              515,
              4
            ]
          });
    }
    if (n !== 0) {
      out(4752324);
      out((n << 3));
    }
    out(233);
    const loc$4 = opos.contents;
    le(32, brkl.contents);
    brkl.contents = loc$4;
    return;
  }
  if (t.TAG === /* Op */ 0) {
    switch (t._0) {
      case ";" :
        return;
      case "{" :
        return block(brk, stk);
    }
  }
  Curry._1(unnext, t);
  expr(stk);
  Curry._1(next$1, undefined);
}

function block(brk, stk) {
  const match = decl(false, 0, stk);
  const stk$p = match[1];
  const n = match[0];
  while (!nextis({
          TAG: /* Op */ 0,
          _0: "}"
        })) {
    stmt(brk, stk$p);
  };
  Curry._1(next$1, undefined);
  if (n !== 0) {
    out(4752324);
    out((n << 3));
    align.contents = align.contents - n | 0;
    return;
  }
  
}

function top(_param) {
  while (true) {
    if (nextis({
            TAG: /* Op */ 0,
            _0: "EOF!"
          })) {
      return;
    }
    if (nextis(tokint)) {
      decl(true, 0, /* [] */ 0);
      _param = undefined;
      continue;
    }
    const f = Curry._1(next$1, undefined);
    if (f.TAG === /* Sym */ 3) {
      const f$1 = f._0;
      const g = Caml_array.get(globs, f$1);
      if (g.va >= 0) {
        throw new Caml_js_exceptions.MelangeError("Failure", {
              MEL_EXN_ID: "Failure",
              _1: "symbol defined twice"
            });
      }
      Caml_array.set(globs, f$1, {
            loc: g.loc,
            va: opos.contents
          });
      const emitargs = function (_regs, _n, _stk) {
        while (true) {
          const stk = _stk;
          const n = _n;
          const regs = _regs;
          const i = Curry._1(next$1, undefined);
          switch (i.TAG) {
            case /* Op */ 0 :
              if (i._0 === ")") {
                return stk;
              }
              throw new Caml_js_exceptions.MelangeError("Failure", {
                    MEL_EXN_ID: "Failure",
                    _1: "[var] or ) expected"
                  });
            case /* ILit */ 1 :
            case /* SLit */ 2 :
              throw new Caml_js_exceptions.MelangeError("Failure", {
                    MEL_EXN_ID: "Failure",
                    _1: "[var] or ) expected"
                  });
            case /* Sym */ 3 :
              const r = Stdlib__List.hd(regs);
              push(r);
              if (nextis({
                      TAG: /* Op */ 0,
                      _0: ","
                    })) {
                Curry._1(next$1, undefined);
              }
              const stk$p_0 = [
                i._0,
                ((-n | 0) << 3)
              ];
              const stk$p = {
                hd: stk$p_0,
                tl: stk
              };
              _stk = stk$p;
              _n = n + 1 | 0;
              _regs = Stdlib__List.tl(regs);
              continue;
          }
        };
      };
      Curry._1(next$1, undefined);
      align.contents = 0;
      out(85);
      out(4753893);
      const stk = emitargs({
            hd: 7,
            tl: {
              hd: 6,
              tl: {
                hd: 2,
                tl: {
                  hd: 1,
                  tl: {
                    hd: 8,
                    tl: {
                      hd: 9,
                      tl: /* [] */ 0
                    }
                  }
                }
              }
            }
          }, 1, /* [] */ 0);
      while (Caml_obj.caml_notequal(Curry._1(next$1, undefined), {
              TAG: /* Op */ 0,
              _0: "{"
            })) {
        
      };
      retl.contents = 0;
      block([
            {
              contents: 0
            },
            0
          ], stk);
      patch(true, retl.contents, opos.contents);
      out(51651);
      if (dbg.contents) {
        Curry._1(Stdlib__Printf.eprintf({
                TAG: /* Format */ 0,
                _0: {
                  TAG: /* String_literal */ 11,
                  _0: "done with function ",
                  _1: {
                    TAG: /* String */ 2,
                    _0: /* No_padding */ 0,
                    _1: {
                      TAG: /* Char_literal */ 12,
                      _0: /* '\n' */10,
                      _1: /* End_of_format */ 0
                    }
                  }
                },
                _1: "done with function %s\n"
              }), symstr(f$1));
      }
      _param = undefined;
      continue;
    }
    throw new Caml_js_exceptions.MelangeError("Failure", {
          MEL_EXN_ID: "Failure",
          _1: "[decl] or [fun] expected"
        });
  };
}

const elfhdr = Stdlib__Bytes.of_string(Stdlib__String.concat("", {
          hd: "\x7fELF\x02\x01\x01\0",
          tl: {
            hd: "\0\0\0\0\0\0\0\0",
            tl: {
              hd: "\x02\0",
              tl: {
                hd: ">\0",
                tl: {
                  hd: "\x01\0\0\0",
                  tl: {
                    hd: "\0\0\0\0\0\0\0\0",
                    tl: {
                      hd: "@\0\0\0\0\0\0\0",
                      tl: {
                        hd: "\0\0\0\0\0\0\0\0",
                        tl: {
                          hd: "\0\0\0\0",
                          tl: {
                            hd: "@\0",
                            tl: {
                              hd: "8\0",
                              tl: {
                                hd: "\x03\0",
                                tl: {
                                  hd: "@\0",
                                  tl: {
                                    hd: "\0\0",
                                    tl: {
                                      hd: "\0\0",
                                      tl: /* [] */ 0
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }));

function elfphdr(ty, off, sz, align) {
  le(32, ty);
  le(32, 7);
  le(64, off);
  le(64, off + 4194304 | 0);
  le(64, off + 4194304 | 0);
  le(64, sz);
  le(64, sz);
  le(64, align);
}

function elfgen(outf) {
  const entry = opos.contents;
  const main = addsym("main");
  const gmain = Caml_array.get(globs, main);
  out(1217084452);
  out(-1921768440);
  out(18616);
  le(64, gmain.loc);
  Caml_array.set(globs, main, {
        loc: opos.contents - 8 | 0,
        va: gmain.va
      });
  out(65488);
  out(35271);
  load(0, 60);
  out(3845);
  const off = 232 + gpos.contents | 0;
  const itr = function (f) {
    symitr(function (i, s) {
          const g = Caml_array.get(globs, i);
          if (g.va < 0 && g.loc !== 0) {
            return Curry._3(f, s, s.length, g.loc);
          }
          
        });
  };
  const va = function (x) {
    return (x + off | 0) + 4194304 | 0;
  };
  const patchloc = function (i, param) {
    const g = Caml_array.get(globs, i);
    if (g.va >= 0 && g.va < 4194304) {
      return patch(false, g.loc, va(g.va));
    } else if (g.va >= 0) {
      return patch(false, g.loc, g.va);
    } else {
      return;
    }
  };
  symitr(patchloc);
  const strtab = opos.contents;
  opos.contents = opos.contents + 1 | 0;
  Stdlib__String.blit("/lib64/ld-linux-x86-64.so.2\0libc.so.6", 0, obuf, opos.contents, 37);
  opos.contents = (opos.contents + 37 | 0) + 1 | 0;
  itr(function (s, sl, param) {
        Stdlib__String.blit(s, 0, obuf, opos.contents, sl);
        opos.contents = (opos.contents + sl | 0) + 1 | 0;
      });
  opos.contents = opos.contents + 7 & -8;
  const symtab = opos.contents;
  const n = {
    contents: 39
  };
  opos.contents = opos.contents + 24 | 0;
  itr(function (param, sl, param$1) {
        le(32, n.contents);
        le(32, 16);
        le(64, 0);
        le(64, 0);
        n.contents = (n.contents + sl | 0) + 1 | 0;
      });
  const rel = opos.contents;
  const n$1 = {
    contents: 1
  };
  itr(function (param, param$1, l) {
        const genrel = function (_l) {
          while (true) {
            const l = _l;
            if (l === 0) {
              return;
            }
            le(64, va(l));
            le(64, 1 + (n$1.contents << 32) | 0);
            le(64, 0);
            _l = get32(l);
            continue;
          };
        };
        genrel(l);
        n$1.contents = n$1.contents + 1 | 0;
      });
  const hash = opos.contents;
  const n$2 = ((rel - symtab | 0) / 24 | 0) - 1 | 0;
  le(32, 1);
  le(32, n$2 + 1 | 0);
  le(32, n$2 > 0 ? 1 : 0);
  for (let i = 1; i <= n$2; ++i) {
    le(32, i);
  }
  le(32, 0);
  const dyn = opos.contents;
  Stdlib__List.iter((function (param) {
        return le(64, param);
      }), {
        hd: 1,
        tl: {
          hd: 29,
          tl: {
            hd: 4,
            tl: {
              hd: va(hash),
              tl: {
                hd: 5,
                tl: {
                  hd: va(strtab),
                  tl: {
                    hd: 6,
                    tl: {
                      hd: va(symtab),
                      tl: {
                        hd: 7,
                        tl: {
                          hd: va(rel),
                          tl: {
                            hd: 8,
                            tl: {
                              hd: hash - rel | 0,
                              tl: {
                                hd: 9,
                                tl: {
                                  hd: 24,
                                  tl: {
                                    hd: 10,
                                    tl: {
                                      hd: symtab - strtab | 0,
                                      tl: {
                                        hd: 11,
                                        tl: {
                                          hd: 24,
                                          tl: {
                                            hd: 0,
                                            tl: /* [] */ 0
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      });
  const tend = opos.contents;
  Stdlib__Bytes.blit(obuf, 0, obuf, off, tend);
  Stdlib__Bytes.blit(glo, 0, obuf, 232, gpos.contents);
  Stdlib__Bytes.blit(elfhdr, 0, obuf, 0, 64);
  opos.contents = 64;
  elfphdr(3, (strtab + 1 | 0) + off | 0, 28, 1);
  elfphdr(1, 0, tend + off | 0, 2097152);
  elfphdr(2, dyn + off | 0, tend - dyn | 0, 8);
  if (opos.contents !== 232) {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "jscomp/test/qcc.ml",
            698,
            2
          ]
        });
  }
  patch(false, 24, va(entry));
  Stdlib.output_bytes(outf, Stdlib__Bytes.sub(obuf, 0, tend + off | 0));
}

function main(param) {
  const ppsym = function (s) {
    switch (s.TAG) {
      case /* Op */ 0 :
        return Curry._1(Stdlib__Printf.printf({
                TAG: /* Format */ 0,
                _0: {
                  TAG: /* String_literal */ 11,
                  _0: "Operator '",
                  _1: {
                    TAG: /* String */ 2,
                    _0: /* No_padding */ 0,
                    _1: {
                      TAG: /* String_literal */ 11,
                      _0: "'\n",
                      _1: /* End_of_format */ 0
                    }
                  }
                },
                _1: "Operator '%s'\n"
              }), s._0);
      case /* ILit */ 1 :
        return Curry._1(Stdlib__Printf.printf({
                TAG: /* Format */ 0,
                _0: {
                  TAG: /* String_literal */ 11,
                  _0: "Int literal ",
                  _1: {
                    TAG: /* Int */ 4,
                    _0: /* Int_d */ 0,
                    _1: /* No_padding */ 0,
                    _2: /* No_precision */ 0,
                    _3: {
                      TAG: /* Char_literal */ 12,
                      _0: /* '\n' */10,
                      _1: /* End_of_format */ 0
                    }
                  }
                },
                _1: "Int literal %d\n"
              }), s._0);
      case /* SLit */ 2 :
        return Curry._1(Stdlib__Printf.printf({
                TAG: /* Format */ 0,
                _0: {
                  TAG: /* String_literal */ 11,
                  _0: "Str literal ",
                  _1: {
                    TAG: /* Caml_string */ 3,
                    _0: /* No_padding */ 0,
                    _1: {
                      TAG: /* Char_literal */ 12,
                      _0: /* '\n' */10,
                      _1: /* End_of_format */ 0
                    }
                  }
                },
                _1: "Str literal %S\n"
              }), s._1);
      case /* Sym */ 3 :
        const i = s._0;
        return Curry._2(Stdlib__Printf.printf({
                TAG: /* Format */ 0,
                _0: {
                  TAG: /* String_literal */ 11,
                  _0: "Symbol '",
                  _1: {
                    TAG: /* String */ 2,
                    _0: /* No_padding */ 0,
                    _1: {
                      TAG: /* String_literal */ 11,
                      _0: "' (",
                      _1: {
                        TAG: /* Int */ 4,
                        _0: /* Int_d */ 0,
                        _1: /* No_padding */ 0,
                        _2: /* No_precision */ 0,
                        _3: {
                          TAG: /* String_literal */ 11,
                          _0: ")\n",
                          _1: /* End_of_format */ 0
                        }
                      }
                    }
                  }
                },
                _1: "Symbol '%s' (%d)\n"
              }), symstr(i), i);
    }
  };
  const f = Caml_sys.caml_sys_argv(0).length < 2 ? "-blk" : Caml_array.get(Caml_sys.caml_sys_argv(0), 1);
  switch (f) {
    case "-blk" :
      const partial_arg_0 = {
        contents: 0
      };
      const partial_arg = [
        partial_arg_0,
        0
      ];
      const c = function (param) {
        return block(partial_arg, param);
      };
      let stk = /* [] */ 0;
      opos.contents = 0;
      Curry._1(c, stk);
      return Stdlib.print_bytes(Stdlib__Bytes.sub(obuf, 0, opos.contents));
    case "-lex" :
      let _param;
      while (true) {
        const tok = Curry._1(next$1, undefined);
        if (tok.TAG === /* Op */ 0) {
          if (tok._0 === "EOF!") {
            return Stdlib__Printf.printf({
                  TAG: /* Format */ 0,
                  _0: {
                    TAG: /* String_literal */ 11,
                    _0: "End of input stream\n",
                    _1: /* End_of_format */ 0
                  },
                  _1: "End of input stream\n"
                });
          }
          ppsym(tok);
          _param = undefined;
          continue;
        }
        ppsym(tok);
        _param = undefined;
        continue;
      };
    default:
      const oc = Stdlib.open_out("a.out");
      inch.contents = Stdlib.open_in_bin(f);
      top(undefined);
      elfgen(oc);
      Caml_io.caml_ml_flush(oc);
      return Caml_external_polyfill.resolve("caml_ml_close_channel")(oc);
  }
}

main(undefined);

const base = 4194304;

const textoff = 232;

module.exports = {
  dbg,
  inch,
  bufferize,
  getch,
  ungetch,
  peekch,
  addsym,
  symstr,
  symitr,
  glo,
  gpos,
  base,
  textoff,
  next: next$1,
  unnext,
  nextis,
  obuf,
  opos,
  out,
  le,
  get32,
  patch,
  load,
  cmp,
  test,
  align,
  push,
  pop,
  lval,
  patchlval,
  read,
  globs,
  lvls,
  inss,
  tokint,
  tokchar,
  tokret,
  tokif,
  tokelse,
  tokwhile,
  tokfor,
  tokbreak,
  binary,
  unary,
  postfix,
  expr,
  decl,
  retl,
  stmt,
  block,
  top,
  elfhdr,
  elfphdr,
  elfgen,
  main,
}
/* match Not a pure module */
