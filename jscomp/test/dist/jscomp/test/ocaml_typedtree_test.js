// Generated by Melange
'use strict';

const Caml = require("melange.js/caml.js");
const Caml_array = require("melange.js/caml_array.js");
const Caml_bytes = require("melange.js/caml_bytes.js");
const Caml_exceptions = require("melange.js/caml_exceptions.js");
const Caml_external_polyfill = require("melange.js/caml_external_polyfill.js");
const Caml_format = require("melange.js/caml_format.js");
const Caml_int64 = require("melange.js/caml_int64.js");
const Caml_io = require("melange.js/caml_io.js");
const Caml_js_exceptions = require("melange.js/caml_js_exceptions.js");
const Caml_obj = require("melange.js/caml_obj.js");
const Caml_option = require("melange.js/caml_option.js");
const Caml_string = require("melange.js/caml_string.js");
const Caml_sys = require("melange.js/caml_sys.js");
const CamlinternalLazy = require("melange/camlinternalLazy.js");
const Curry = require("melange.js/curry.js");
const Stdlib = require("melange/stdlib.js");
const Stdlib__Arg = require("melange/arg.js");
const Stdlib__Array = require("melange/array.js");
const Stdlib__Buffer = require("melange/buffer.js");
const Stdlib__Bytes = require("melange/bytes.js");
const Stdlib__Char = require("melange/char.js");
const Stdlib__Digest = require("melange/digest.js");
const Stdlib__Filename = require("melange/filename.js");
const Stdlib__Format = require("melange/format.js");
const Stdlib__Hashtbl = require("melange/hashtbl.js");
const Stdlib__Int32 = require("melange/int32.js");
const Stdlib__Int64 = require("melange/int64.js");
const Stdlib__Lexing = require("melange/lexing.js");
const Stdlib__List = require("melange/list.js");
const Stdlib__Marshal = require("melange/marshal.js");
const Stdlib__Parsing = require("melange/parsing.js");
const Stdlib__Printexc = require("melange/printexc.js");
const Stdlib__Printf = require("melange/printf.js");
const Stdlib__Seq = require("melange/seq.js");
const Stdlib__String = require("melange/string.js");
const Stdlib__Sys = require("melange/sys.js");
const Assert = require("assert");
const Path = require("path");
const Process = require("process");

try {
  Caml_sys.caml_sys_getenv("BSLIB");
}
catch (raw_exn){
  const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
  if (exn.MEL_EXN_ID !== Stdlib.Not_found) {
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
  
}

const cmi_magic_number = "Caml1999I017";

const load_path = {
  contents: /* [] */0
};

const interface_suffix = {
  contents: ".mli"
};

const print_types = {
  contents: false
};

let debug = false;

const fast = {
  contents: false
};

const classic = {
  contents: false
};

let nopervasives = false;

const annotations = {
  contents: false
};

const binary_annotations = {
  contents: false
};

const principal = {
  contents: false
};

const real_paths = {
  contents: true
};

const recursive_types = {
  contents: false
};

const strict_sequence = {
  contents: false
};

const applicative_functors = {
  contents: true
};

const error_size = {
  contents: 500
};

const transparent_modules = {
  contents: false
};

const native_code = {
  contents: false
};

const dont_write_files = {
  contents: false
};

const keep_docs = {
  contents: false
};

const keep_locs = {
  contents: false
};

let unsafe_string = true;

const assume_no_mli = {
  contents: /* Mli_na */0
};

let record_event_when_debug = true;

let bs_vscode;

try {
  Caml_sys.caml_sys_getenv("BS_VSCODE");
  bs_vscode = true;
}
catch (exn$1){
  bs_vscode = false;
}

const dont_record_crc_unit = {
  contents: undefined
};

const bs_only = {
  contents: false
};

const color = {
  contents: undefined
};

const Fatal_error = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Misc.Fatal_error");

function fatal_error(msg) {
  Stdlib.prerr_string(">> Fatal error: ");
  console.error(msg);
  throw new Caml_js_exceptions.MelangeError(Fatal_error, {
            MEL_EXN_ID: Fatal_error
          });
}

function try_finally(work, cleanup) {
  let result;
  try {
    result = Curry._1(work, undefined);
  }
  catch (e){
    Curry._1(cleanup, undefined);
    throw new Caml_js_exceptions.MelangeError(e.MEL_EXN_ID, e);
  }
  Curry._1(cleanup, undefined);
  return result;
}

function map_end(f, l1, l2) {
  if (l1) {
    return {
            hd: Curry._1(f, l1.hd),
            tl: map_end(f, l1.tl, l2)
          };
  } else {
    return l2;
  }
}

function for_all2(pred, _l1, _l2) {
  while(true) {
    const l2 = _l2;
    const l1 = _l1;
    if (!l1) {
      if (l2) {
        return false;
      } else {
        return true;
      }
    }
    if (!l2) {
      return false;
    }
    if (!Curry._2(pred, l1.hd, l2.hd)) {
      return false;
    }
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue ;
  };
}

function replicate_list(elem, n) {
  if (n <= 0) {
    return /* [] */0;
  } else {
    return {
            hd: elem,
            tl: replicate_list(elem, n - 1 | 0)
          };
  }
}

function split_last(param) {
  if (param) {
    const x = param.hd;
    if (!param.tl) {
      return [
              /* [] */0,
              x
            ];
    }
    const match = split_last(param.tl);
    return [
            {
              hd: x,
              tl: match[0]
            },
            match[1]
          ];
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              817,
              10
            ]
          });
}

function may(f, x) {
  if (x !== undefined) {
    return Curry._1(f, Caml_option.valFromOption(x));
  }
  
}

function may_map(f, x) {
  if (x !== undefined) {
    return Caml_option.some(Curry._1(f, Caml_option.valFromOption(x)));
  }
  
}

function find_in_path_uncap(path, name) {
  const uname = Caml_bytes.bytes_to_string(Stdlib__Bytes.uncapitalize_ascii(Caml_bytes.bytes_of_string(name)));
  let _param = path;
  while(true) {
    const param = _param;
    if (param) {
      const dir = param.hd;
      const fullname = Stdlib__Filename.concat(dir, name);
      const ufullname = Stdlib__Filename.concat(dir, uname);
      if (Caml_external_polyfill.resolve("caml_sys_file_exists")(ufullname)) {
        return ufullname;
      }
      if (Caml_external_polyfill.resolve("caml_sys_file_exists")(fullname)) {
        return fullname;
      }
      _param = param.tl;
      continue ;
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
  };
}

function remove_file(filename) {
  try {
    return Caml_external_polyfill.resolve("caml_sys_remove")(filename);
  }
  catch (raw_msg){
    const msg = Caml_js_exceptions.internalToOCamlException(raw_msg);
    if (msg.MEL_EXN_ID === Stdlib.Sys_error) {
      return ;
    }
    throw new Caml_js_exceptions.MelangeError(msg.MEL_EXN_ID, msg);
  }
}

function create_hashtable(size, init) {
  const tbl = Stdlib__Hashtbl.create(undefined, size);
  Stdlib__List.iter((function (param) {
          Stdlib__Hashtbl.add(tbl, param[0], param[1]);
        }), init);
  return tbl;
}

function chop_extension_if_any(fname) {
  try {
    return Stdlib__Filename.chop_extension(fname);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Invalid_argument) {
      return fname;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function get_ref(r) {
  const v = r.contents;
  r.contents = /* [] */0;
  return v;
}

function edit_distance(a, b, cutoff) {
  const la = a.length;
  const lb = b.length;
  const cutoff$1 = Caml.caml_int_min(la > lb ? la : lb, cutoff);
  if (Stdlib.abs(la - lb | 0) > cutoff$1) {
    return ;
  }
  const m = Stdlib__Array.make_matrix(la + 1 | 0, lb + 1 | 0, cutoff$1 + 1 | 0);
  Caml_array.set(Caml_array.get(m, 0), 0, 0);
  for(let i = 1; i <= la; ++i){
    Caml_array.set(Caml_array.get(m, i), 0, i);
  }
  for(let j = 1; j <= lb; ++j){
    Caml_array.set(Caml_array.get(m, 0), j, j);
  }
  for(let i$1 = 1; i$1 <= la; ++i$1){
    for(let j$1 = Caml.caml_int_max(1, (i$1 - cutoff$1 | 0) - 1 | 0) ,j_finish = Caml.caml_int_min(lb, (i$1 + cutoff$1 | 0) + 1 | 0); j$1 <= j_finish; ++j$1){
      const cost = Caml_string.get(a, i$1 - 1 | 0) === Caml_string.get(b, j$1 - 1 | 0) ? 0 : 1;
      const best = Caml.caml_int_min(1 + Caml.caml_int_min(Caml_array.get(Caml_array.get(m, i$1 - 1 | 0), j$1), Caml_array.get(Caml_array.get(m, i$1), j$1 - 1 | 0)) | 0, Caml_array.get(Caml_array.get(m, i$1 - 1 | 0), j$1 - 1 | 0) + cost | 0);
      const best$1 = i$1 > 1 && j$1 > 1 && Caml_string.get(a, i$1 - 1 | 0) === Caml_string.get(b, j$1 - 2 | 0) && Caml_string.get(a, i$1 - 2 | 0) === Caml_string.get(b, j$1 - 1 | 0) ? Caml.caml_int_min(best, Caml_array.get(Caml_array.get(m, i$1 - 2 | 0), j$1 - 2 | 0) + cost | 0) : best;
      Caml_array.set(Caml_array.get(m, i$1), j$1, best$1);
    }
  }
  const result = Caml_array.get(Caml_array.get(m, la), lb);
  if (result > cutoff$1) {
    return ;
  } else {
    return result;
  }
}

function ansi_of_color(param) {
  switch (param) {
    case /* Black */0 :
        return "0";
    case /* Red */1 :
        return "1";
    case /* Green */2 :
        return "2";
    case /* Yellow */3 :
        return "3";
    case /* Blue */4 :
        return "4";
    case /* Magenta */5 :
        return "5";
    case /* Cyan */6 :
        return "6";
    case /* White */7 :
        return "7";
    
  }
}

function code_of_style(c) {
  if (typeof c !== "number") {
    if (c.TAG === /* FG */0) {
      return "3" + ansi_of_color(c._0);
    } else {
      return "4" + ansi_of_color(c._0);
    }
  }
  switch (c) {
    case /* Bold */0 :
        return "1";
    case /* Reset */1 :
        return "0";
    case /* Dim */2 :
        return "2";
    
  }
}

function ansi_of_style_l(l) {
  const s = l ? (
      l.tl ? Stdlib__String.concat(";", Stdlib__List.map(code_of_style, l)) : code_of_style(l.hd)
    ) : "0";
  return "\x1b[" + (s + "m");
}

const default_styles = {
  error: {
    hd: /* Bold */0,
    tl: {
      hd: {
        TAG: /* FG */0,
        _0: /* Red */1
      },
      tl: /* [] */0
    }
  },
  warning: {
    hd: /* Bold */0,
    tl: {
      hd: {
        TAG: /* FG */0,
        _0: /* Magenta */5
      },
      tl: /* [] */0
    }
  },
  loc: {
    hd: /* Bold */0,
    tl: /* [] */0
  }
};

const cur_styles = {
  contents: default_styles
};

function get_styles(param) {
  return cur_styles.contents;
}

function set_styles(s) {
  cur_styles.contents = s;
}

function style_of_tag(s) {
  if (s.MEL_EXN_ID === Stdlib__Format.String_tag) {
    switch (s._1) {
      case "dim" :
          return {
                  hd: /* Dim */2,
                  tl: /* [] */0
                };
      case "error" :
          return cur_styles.contents.error;
      case "filename" :
          return {
                  hd: {
                    TAG: /* FG */0,
                    _0: /* Cyan */6
                  },
                  tl: /* [] */0
                };
      case "info" :
          return {
                  hd: /* Bold */0,
                  tl: {
                    hd: {
                      TAG: /* FG */0,
                      _0: /* Yellow */3
                    },
                    tl: /* [] */0
                  }
                };
      case "loc" :
          return cur_styles.contents.loc;
      case "warning" :
          return cur_styles.contents.warning;
      default:
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                  MEL_EXN_ID: Stdlib.Not_found
                });
    }
  } else {
    throw new Caml_js_exceptions.MelangeError("Match_failure", {
              MEL_EXN_ID: "Match_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                1191,
                19
              ]
            });
  }
}

const color_enabled = {
  contents: true
};

function set_color_tag_handling(ppf) {
  const functions = Stdlib__Format.pp_get_formatter_stag_functions(ppf, undefined);
  const partial_arg = functions.mark_open_stag;
  const partial_arg$1 = functions.mark_close_stag;
  const functions$p_mark_open_stag = function (param) {
    try {
      const style = style_of_tag(param);
      if (color_enabled.contents) {
        return ansi_of_style_l(style);
      } else {
        return "";
      }
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        return Curry._1(partial_arg, param);
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  };
  const functions$p_mark_close_stag = function (param) {
    try {
      style_of_tag(param);
      if (color_enabled.contents) {
        return ansi_of_style_l({
                    hd: /* Reset */1,
                    tl: /* [] */0
                  });
      } else {
        return "";
      }
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        return Curry._1(partial_arg$1, param);
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  };
  const functions$p_print_open_stag = functions.print_open_stag;
  const functions$p_print_close_stag = functions.print_close_stag;
  const functions$p = {
    mark_open_stag: functions$p_mark_open_stag,
    mark_close_stag: functions$p_mark_close_stag,
    print_open_stag: functions$p_print_open_stag,
    print_close_stag: functions$p_print_close_stag
  };
  ppf.pp_mark_tags = true;
  Stdlib__Format.pp_set_formatter_stag_functions(ppf, functions$p);
}

const first = {
  contents: true
};

const formatter_l_1 = {
  hd: Stdlib__Format.err_formatter,
  tl: {
    hd: Stdlib__Format.str_formatter,
    tl: /* [] */0
  }
};

const formatter_l = {
  hd: Stdlib__Format.std_formatter,
  tl: formatter_l_1
};

function setup(o) {
  if (first.contents) {
    first.contents = false;
    Stdlib__Format.set_mark_tags(true);
    Stdlib__List.iter(set_color_tag_handling, formatter_l);
    let tmp;
    if (o !== undefined) {
      switch (o) {
        case /* Always */1 :
            tmp = true;
            break;
        case /* Auto */0 :
        case /* Never */2 :
            tmp = false;
            break;
        
      }
    } else {
      tmp = false;
    }
    color_enabled.contents = tmp;
  }
  
}

const Misc_Color = {
  ansi_of_style_l: ansi_of_style_l,
  default_styles: default_styles,
  get_styles: get_styles,
  set_styles: set_styles,
  setup: setup,
  set_color_tag_handling: set_color_tag_handling
};

function number(param) {
  if (typeof param === "number") {
    switch (param) {
      case /* Comment_start */0 :
          return 1;
      case /* Comment_not_end */1 :
          return 2;
      case /* Partial_application */2 :
          return 5;
      case /* Labels_omitted */3 :
          return 6;
      case /* Statement_type */4 :
          return 10;
      case /* Unused_match */5 :
          return 11;
      case /* Unused_pat */6 :
          return 12;
      case /* Illegal_backslash */7 :
          return 14;
      case /* Unerasable_optional_argument */8 :
          return 16;
      case /* Unused_argument */9 :
          return 20;
      case /* Nonreturning_statement */10 :
          return 21;
      case /* Useless_record_with */11 :
          return 23;
      case /* All_clauses_guarded */12 :
          return 25;
      case /* Wildcard_arg_to_constant_constr */13 :
          return 28;
      case /* Eol_in_string */14 :
          return 29;
      case /* Unused_rec_flag */15 :
          return 39;
      case /* Bs_polymorphic_comparison */16 :
          return 102;
      
    }
  } else {
    switch (param.TAG | 0) {
      case /* Deprecated */0 :
          return 3;
      case /* Fragile_match */1 :
          return 4;
      case /* Method_override */2 :
          return 7;
      case /* Partial_match */3 :
          return 8;
      case /* Non_closed_record_pattern */4 :
          return 9;
      case /* Instance_variable_override */5 :
          return 13;
      case /* Implicit_public_methods */6 :
          return 15;
      case /* Undeclared_virtual_method */7 :
          return 17;
      case /* Not_principal */8 :
          return 18;
      case /* Without_principality */9 :
          return 19;
      case /* Preprocessor */10 :
          return 22;
      case /* Bad_module_name */11 :
          return 24;
      case /* Unused_var */12 :
          return 26;
      case /* Unused_var_strict */13 :
          return 27;
      case /* Duplicate_definitions */14 :
          return 30;
      case /* Multiple_definition */15 :
          return 31;
      case /* Unused_value_declaration */16 :
          return 32;
      case /* Unused_open */17 :
          return 33;
      case /* Unused_type_declaration */18 :
          return 34;
      case /* Unused_for_index */19 :
          return 35;
      case /* Unused_ancestor */20 :
          return 36;
      case /* Unused_constructor */21 :
          return 37;
      case /* Unused_extension */22 :
          return 38;
      case /* Name_out_of_scope */23 :
          return 40;
      case /* Ambiguous_name */24 :
          return 41;
      case /* Disambiguated_name */25 :
          return 42;
      case /* Nonoptional_label */26 :
          return 43;
      case /* Open_shadow_identifier */27 :
          return 44;
      case /* Open_shadow_label_constructor */28 :
          return 45;
      case /* Bad_env_variable */29 :
          return 46;
      case /* Attribute_payload */30 :
          return 47;
      case /* Eliminated_optional_arguments */31 :
          return 48;
      case /* No_cmi_file */32 :
          return 49;
      case /* Bad_docstring */33 :
          return 50;
      case /* Bs_unused_attribute */34 :
          return 101;
      case /* Bs_ffi_warning */35 :
          return 103;
      case /* Bs_derive_warning */36 :
          return 104;
      
    }
  }
}

function loop(i) {
  if (i === 0) {
    return /* [] */0;
  } else {
    return {
            hd: i,
            tl: loop(i - 1 | 0)
          };
  }
}

const letter_all = loop(104);

function letter(param) {
  switch (param) {
    case 97 :
        return letter_all;
    case 99 :
        return {
                hd: 1,
                tl: {
                  hd: 2,
                  tl: /* [] */0
                }
              };
    case 100 :
        return {
                hd: 3,
                tl: /* [] */0
              };
    case 101 :
        return {
                hd: 4,
                tl: /* [] */0
              };
    case 102 :
        return {
                hd: 5,
                tl: /* [] */0
              };
    case 107 :
        return {
                hd: 32,
                tl: {
                  hd: 33,
                  tl: {
                    hd: 34,
                    tl: {
                      hd: 35,
                      tl: {
                        hd: 36,
                        tl: {
                          hd: 37,
                          tl: {
                            hd: 38,
                            tl: {
                              hd: 39,
                              tl: /* [] */0
                            }
                          }
                        }
                      }
                    }
                  }
                }
              };
    case 108 :
        return {
                hd: 6,
                tl: /* [] */0
              };
    case 109 :
        return {
                hd: 7,
                tl: /* [] */0
              };
    case 112 :
        return {
                hd: 8,
                tl: /* [] */0
              };
    case 114 :
        return {
                hd: 9,
                tl: /* [] */0
              };
    case 115 :
        return {
                hd: 10,
                tl: /* [] */0
              };
    case 117 :
        return {
                hd: 11,
                tl: {
                  hd: 12,
                  tl: /* [] */0
                }
              };
    case 118 :
        return {
                hd: 13,
                tl: /* [] */0
              };
    case 98 :
    case 103 :
    case 104 :
    case 105 :
    case 106 :
    case 110 :
    case 111 :
    case 113 :
    case 116 :
    case 119 :
        return /* [] */0;
    case 120 :
        return {
                hd: 14,
                tl: {
                  hd: 15,
                  tl: {
                    hd: 16,
                    tl: {
                      hd: 17,
                      tl: {
                        hd: 18,
                        tl: {
                          hd: 19,
                          tl: {
                            hd: 20,
                            tl: {
                              hd: 21,
                              tl: {
                                hd: 22,
                                tl: {
                                  hd: 23,
                                  tl: {
                                    hd: 24,
                                    tl: {
                                      hd: 25,
                                      tl: {
                                        hd: 30,
                                        tl: /* [] */0
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              };
    case 121 :
        return {
                hd: 26,
                tl: /* [] */0
              };
    case 122 :
        return {
                hd: 27,
                tl: /* [] */0
              };
    default:
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  1587,
                  9
                ]
              });
  }
}

const current = {
  contents: {
    active: Caml_array.make(105, true),
    error: Caml_array.make(105, false)
  }
};

function is_active(x) {
  return Caml_array.get(current.contents.active, number(x));
}

function parse_opt(error, active, flags, s) {
  const set = function (i) {
    Caml_array.set(flags, i, true);
  };
  const clear = function (i) {
    Caml_array.set(flags, i, false);
  };
  const set_all = function (i) {
    Caml_array.set(active, i, true);
    Caml_array.set(error, i, true);
  };
  const get_num = function (_n, _i) {
    while(true) {
      const i = _i;
      const n = _n;
      if (i >= s.length) {
        return [
                i,
                n
              ];
      }
      const match = Caml_string.get(s, i);
      if (match > 57 || match < 48) {
        return [
                i,
                n
              ];
      }
      _i = i + 1 | 0;
      _n = (Math.imul(10, n) + Caml_string.get(s, i) | 0) - /* '0' */48 | 0;
      continue ;
    };
  };
  const get_range = function (i) {
    const match = get_num(0, i);
    const n1 = match[1];
    const i$1 = match[0];
    if (!((i$1 + 2 | 0) < s.length && Caml_string.get(s, i$1) === /* '.' */46 && Caml_string.get(s, i$1 + 1 | 0) === /* '.' */46)) {
      return [
              i$1,
              n1,
              n1
            ];
    }
    const match$1 = get_num(0, i$1 + 2 | 0);
    const n2 = match$1[1];
    if (n2 < n1) {
      throw new Caml_js_exceptions.MelangeError(Stdlib__Arg.Bad, {
                MEL_EXN_ID: Stdlib__Arg.Bad,
                _1: "Ill-formed list of warnings"
              });
    }
    return [
            match$1[0],
            n1,
            n2
          ];
  };
  const loop = function (_i) {
    while(true) {
      const i = _i;
      if (i >= s.length) {
        return ;
      }
      const c = Caml_string.get(s, i);
      if (c >= 65) {
        if (c >= 97) {
          if (c >= 123) {
            throw new Caml_js_exceptions.MelangeError(Stdlib__Arg.Bad, {
                      MEL_EXN_ID: Stdlib__Arg.Bad,
                      _1: "Ill-formed list of warnings"
                    });
          }
          Stdlib__List.iter(clear, letter(Caml_string.get(s, i)));
          _i = i + 1 | 0;
          continue ;
        }
        if (c >= 91) {
          throw new Caml_js_exceptions.MelangeError(Stdlib__Arg.Bad, {
                    MEL_EXN_ID: Stdlib__Arg.Bad,
                    _1: "Ill-formed list of warnings"
                  });
        }
        Stdlib__List.iter(set, letter(Stdlib__Char.lowercase_ascii(Caml_string.get(s, i))));
        _i = i + 1 | 0;
        continue ;
      }
      if (c >= 46) {
        if (c >= 64) {
          return loop_letter_num(set_all, i + 1 | 0);
        }
        throw new Caml_js_exceptions.MelangeError(Stdlib__Arg.Bad, {
                  MEL_EXN_ID: Stdlib__Arg.Bad,
                  _1: "Ill-formed list of warnings"
                });
      }
      if (c >= 43) {
        switch (c) {
          case 43 :
              return loop_letter_num(set, i + 1 | 0);
          case 44 :
              throw new Caml_js_exceptions.MelangeError(Stdlib__Arg.Bad, {
                        MEL_EXN_ID: Stdlib__Arg.Bad,
                        _1: "Ill-formed list of warnings"
                      });
          case 45 :
              return loop_letter_num(clear, i + 1 | 0);
          
        }
      } else {
        throw new Caml_js_exceptions.MelangeError(Stdlib__Arg.Bad, {
                  MEL_EXN_ID: Stdlib__Arg.Bad,
                  _1: "Ill-formed list of warnings"
                });
      }
    };
  };
  const loop_letter_num = function (myset, i) {
    if (i >= s.length) {
      throw new Caml_js_exceptions.MelangeError(Stdlib__Arg.Bad, {
                MEL_EXN_ID: Stdlib__Arg.Bad,
                _1: "Ill-formed list of warnings"
              });
    }
    const match = Caml_string.get(s, i);
    if (match >= 65) {
      if (match >= 97) {
        if (match >= 123) {
          throw new Caml_js_exceptions.MelangeError(Stdlib__Arg.Bad, {
                    MEL_EXN_ID: Stdlib__Arg.Bad,
                    _1: "Ill-formed list of warnings"
                  });
        }
        Stdlib__List.iter(myset, letter(Caml_string.get(s, i)));
        return loop(i + 1 | 0);
      }
      if (match >= 91) {
        throw new Caml_js_exceptions.MelangeError(Stdlib__Arg.Bad, {
                  MEL_EXN_ID: Stdlib__Arg.Bad,
                  _1: "Ill-formed list of warnings"
                });
      }
      Stdlib__List.iter(myset, letter(Stdlib__Char.lowercase_ascii(Caml_string.get(s, i))));
      return loop(i + 1 | 0);
    }
    if (match > 57 || match < 48) {
      throw new Caml_js_exceptions.MelangeError(Stdlib__Arg.Bad, {
                MEL_EXN_ID: Stdlib__Arg.Bad,
                _1: "Ill-formed list of warnings"
              });
    }
    const match$1 = get_range(i);
    for(let n = match$1[1] ,n_finish = Caml.caml_int_min(match$1[2], 104); n <= n_finish; ++n){
      Curry._1(myset, n);
    }
    loop(match$1[0]);
  };
  loop(0);
}

function parse_options(errflag, s) {
  const error = Stdlib__Array.copy(current.contents.error);
  const active = Stdlib__Array.copy(current.contents.active);
  parse_opt(error, active, errflag ? error : active, s);
  current.contents = {
    active: active,
    error: error
  };
}

parse_options(false, "+a-4-6-7-9-27-29-32..39-41..42-44-45-48-50-102");

parse_options(true, "-a");

function message(s) {
  if (typeof s === "number") {
    switch (s) {
      case /* Comment_start */0 :
          return "this is the start of a comment.";
      case /* Comment_not_end */1 :
          return "this is not the end of a comment.";
      case /* Partial_application */2 :
          return "this function application is partial,\nmaybe some arguments are missing.";
      case /* Labels_omitted */3 :
          return "labels were omitted in the application of this function.";
      case /* Statement_type */4 :
          return "this expression should have type unit.";
      case /* Unused_match */5 :
          return "this match case is unused.";
      case /* Unused_pat */6 :
          return "this sub-pattern is unused.";
      case /* Illegal_backslash */7 :
          return "illegal backslash escape in string.";
      case /* Unerasable_optional_argument */8 :
          return "this optional argument cannot be erased.";
      case /* Unused_argument */9 :
          return "this argument will not be used by the function.";
      case /* Nonreturning_statement */10 :
          return "this statement never returns (or has an unsound type.)";
      case /* Useless_record_with */11 :
          return "all the fields are explicitly listed in this record:\nthe 'with' clause is useless.";
      case /* All_clauses_guarded */12 :
          return "bad style, all clauses in this pattern-matching are guarded.";
      case /* Wildcard_arg_to_constant_constr */13 :
          return "wildcard pattern given as argument to a constant constructor";
      case /* Eol_in_string */14 :
          return "unescaped end-of-line in a string constant (non-portable code)";
      case /* Unused_rec_flag */15 :
          return "unused rec flag.";
      case /* Bs_polymorphic_comparison */16 :
          return "polymorphic comparison introduced (maybe unsafe)";
      
    }
  } else {
    switch (s.TAG | 0) {
      case /* Deprecated */0 :
          return "deprecated: " + s._0;
      case /* Fragile_match */1 :
          const s$1 = s._0;
          if (s$1 === "") {
            return "this pattern-matching is fragile.";
          } else {
            return "this pattern-matching is fragile.\nIt will remain exhaustive when constructors are added to type " + (s$1 + ".");
          }
      case /* Method_override */2 :
          const match = s._0;
          if (match) {
            const lab = match.hd;
            if (match.tl) {
              return Stdlib__String.concat(" ", {
                          hd: "the following methods are overridden by the class",
                          tl: {
                            hd: lab,
                            tl: {
                              hd: ":\n ",
                              tl: match.tl
                            }
                          }
                        });
            } else {
              return "the method " + (lab + " is overridden.");
            }
          }
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                    MEL_EXN_ID: "Assert_failure",
                    _1: [
                      "jscomp/test/ocaml_typedtree_test.ml",
                      1694,
                      26
                    ]
                  });
      case /* Partial_match */3 :
          const s$2 = s._0;
          if (s$2 === "") {
            return "this pattern-matching is not exhaustive.";
          } else {
            return "this pattern-matching is not exhaustive.\nHere is an example of a value that is not matched:\n" + s$2;
          }
      case /* Non_closed_record_pattern */4 :
          return "the following labels are not bound in this record pattern:\n" + (s._0 + "\nEither bind these labels explicitly or add '; _' to the pattern.");
      case /* Instance_variable_override */5 :
          const match$1 = s._0;
          if (match$1) {
            const lab$1 = match$1.hd;
            if (match$1.tl) {
              return Stdlib__String.concat(" ", {
                          hd: "the following instance variables are overridden by the class",
                          tl: {
                            hd: lab$1,
                            tl: {
                              hd: ":\n ",
                              tl: match$1.tl
                            }
                          }
                        }) + "\nThe behaviour changed in ocaml 3.10 (previous behaviour was hiding.)";
            } else {
              return "the instance variable " + (lab$1 + " is overridden.\nThe behaviour changed in ocaml 3.10 (previous behaviour was hiding.)");
            }
          }
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                    MEL_EXN_ID: "Assert_failure",
                    _1: [
                      "jscomp/test/ocaml_typedtree_test.ml",
                      1714,
                      37
                    ]
                  });
      case /* Implicit_public_methods */6 :
          return "the following private methods were made public implicitly:\n " + (Stdlib__String.concat(" ", s._0) + ".");
      case /* Undeclared_virtual_method */7 :
          return "the virtual method " + (s._0 + " is not declared.");
      case /* Not_principal */8 :
          return s._0 + " is not principal.";
      case /* Without_principality */9 :
          return s._0 + " without principality.";
      case /* Preprocessor */10 :
          return s._0;
      case /* Bad_module_name */11 :
          return "bad source file name: \"" + (s._0 + "\" is not a valid module name.");
      case /* Unused_var */12 :
      case /* Unused_var_strict */13 :
          return "unused variable " + (s._0 + ".");
      case /* Duplicate_definitions */14 :
          return Curry._4(Stdlib__Printf.sprintf(/* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "the ",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Char_literal */12,
                                _0: /* ' ' */32,
                                _1: {
                                  TAG: /* String */2,
                                  _0: /* No_padding */0,
                                  _1: {
                                    TAG: /* String_literal */11,
                                    _0: " is defined in both types ",
                                    _1: {
                                      TAG: /* String */2,
                                      _0: /* No_padding */0,
                                      _1: {
                                        TAG: /* String_literal */11,
                                        _0: " and ",
                                        _1: {
                                          TAG: /* String */2,
                                          _0: /* No_padding */0,
                                          _1: {
                                            TAG: /* Char_literal */12,
                                            _0: /* '.' */46,
                                            _1: /* End_of_format */0
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          },
                          _1: "the %s %s is defined in both types %s and %s."
                        }), s._0, s._1, s._2, s._3);
      case /* Multiple_definition */15 :
          return Curry._3(Stdlib__Printf.sprintf(/* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "files ",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* String_literal */11,
                                _0: " and ",
                                _1: {
                                  TAG: /* String */2,
                                  _0: /* No_padding */0,
                                  _1: {
                                    TAG: /* String_literal */11,
                                    _0: " both define a module named ",
                                    _1: {
                                      TAG: /* String */2,
                                      _0: /* No_padding */0,
                                      _1: /* End_of_format */0
                                    }
                                  }
                                }
                              }
                            }
                          },
                          _1: "files %s and %s both define a module named %s"
                        }), s._1, s._2, s._0);
      case /* Unused_value_declaration */16 :
          return "unused value " + (s._0 + ".");
      case /* Unused_open */17 :
          return "unused open " + (s._0 + ".");
      case /* Unused_type_declaration */18 :
          return "unused type " + (s._0 + ".");
      case /* Unused_for_index */19 :
          return "unused for-loop index " + (s._0 + ".");
      case /* Unused_ancestor */20 :
          return "unused ancestor variable " + (s._0 + ".");
      case /* Unused_constructor */21 :
          const s$3 = s._0;
          if (s._1) {
            return "constructor " + (s$3 + " is never used to build values.\n(However, this constructor appears in patterns.)");
          } else if (s._2) {
            return "constructor " + (s$3 + " is never used to build values.\nIts type is exported as a private type.");
          } else {
            return "unused constructor " + (s$3 + ".");
          }
      case /* Unused_extension */22 :
          const s$4 = s._0;
          if (s._1) {
            return "extension constructor " + (s$4 + " is never used to build values.\n(However, this constructor appears in patterns.)");
          } else if (s._2) {
            return "extension constructor " + (s$4 + " is never used to build values.\nIt is exported or rebound as a private extension.");
          } else {
            return "unused extension constructor " + (s$4 + ".");
          }
      case /* Name_out_of_scope */23 :
          const slist = s._1;
          const ty = s._0;
          if (slist && !slist.tl && !s._2) {
            return slist.hd + (" was selected from type " + (ty + ".\nIt is not visible in the current scope, and will not \nbe selected if the type becomes unknown."));
          }
          if (s._2) {
            return "this record of type " + (ty + (" contains fields that are \nnot visible in the current scope: " + (Stdlib__String.concat(" ", slist) + ".\nThey will not be selected if the type becomes unknown.")));
          }
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                    MEL_EXN_ID: "Assert_failure",
                    _1: [
                      "jscomp/test/ocaml_typedtree_test.ml",
                      1776,
                      39
                    ]
                  });
          break;
      case /* Ambiguous_name */24 :
          const slist$1 = s._0;
          if (slist$1 && !slist$1.tl && !s._2) {
            return slist$1.hd + (" belongs to several types: " + (Stdlib__String.concat(" ", s._1) + "\nThe first one was selected. Please disambiguate if this is wrong."));
          }
          if (s._2) {
            return "these field labels belong to several types: " + (Stdlib__String.concat(" ", s._1) + "\nThe first one was selected. Please disambiguate if this is wrong.");
          }
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                    MEL_EXN_ID: "Assert_failure",
                    _1: [
                      "jscomp/test/ocaml_typedtree_test.ml",
                      1785,
                      36
                    ]
                  });
          break;
      case /* Disambiguated_name */25 :
          return "this use of " + (s._0 + " required disambiguation.");
      case /* Nonoptional_label */26 :
          return "the label " + (s._0 + " is not optional.");
      case /* Open_shadow_identifier */27 :
          return Curry._2(Stdlib__Printf.sprintf(/* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "this open statement shadows the ",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* String_literal */11,
                                _0: " identifier ",
                                _1: {
                                  TAG: /* String */2,
                                  _0: /* No_padding */0,
                                  _1: {
                                    TAG: /* String_literal */11,
                                    _0: " (which is later used)",
                                    _1: /* End_of_format */0
                                  }
                                }
                              }
                            }
                          },
                          _1: "this open statement shadows the %s identifier %s (which is later used)"
                        }), s._0, s._1);
      case /* Open_shadow_label_constructor */28 :
          return Curry._2(Stdlib__Printf.sprintf(/* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "this open statement shadows the ",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Char_literal */12,
                                _0: /* ' ' */32,
                                _1: {
                                  TAG: /* String */2,
                                  _0: /* No_padding */0,
                                  _1: {
                                    TAG: /* String_literal */11,
                                    _0: " (which is later used)",
                                    _1: /* End_of_format */0
                                  }
                                }
                              }
                            }
                          },
                          _1: "this open statement shadows the %s %s (which is later used)"
                        }), s._0, s._1);
      case /* Bad_env_variable */29 :
          return Curry._2(Stdlib__Printf.sprintf(/* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "illegal environment variable ",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* String_literal */11,
                                _0: " : ",
                                _1: {
                                  TAG: /* String */2,
                                  _0: /* No_padding */0,
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          },
                          _1: "illegal environment variable %s : %s"
                        }), s._0, s._1);
      case /* Attribute_payload */30 :
          return Curry._2(Stdlib__Printf.sprintf(/* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "illegal payload for attribute '",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* String_literal */11,
                                _0: "'.\n",
                                _1: {
                                  TAG: /* String */2,
                                  _0: /* No_padding */0,
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          },
                          _1: "illegal payload for attribute '%s'.\n%s"
                        }), s._0, s._1);
      case /* Eliminated_optional_arguments */31 :
          const sl = s._0;
          return Curry._2(Stdlib__Printf.sprintf(/* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "implicit elimination of optional argument",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Char_literal */12,
                                _0: /* ' ' */32,
                                _1: {
                                  TAG: /* String */2,
                                  _0: /* No_padding */0,
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          },
                          _1: "implicit elimination of optional argument%s %s"
                        }), Stdlib__List.length(sl) === 1 ? "" : "s", Stdlib__String.concat(", ", sl));
      case /* No_cmi_file */32 :
          return "no cmi file was found in path for module " + s._0;
      case /* Bad_docstring */33 :
          if (s._0) {
            return "unattached documentation comment (ignored)";
          } else {
            return "ambiguous documentation comment";
          }
      case /* Bs_unused_attribute */34 :
          return "Unused BuckleScript attribute: " + s._0;
      case /* Bs_ffi_warning */35 :
          return "BuckleScript FFI warning: " + s._0;
      case /* Bs_derive_warning */36 :
          return "BuckleScript bs.deriving warning: " + s._0;
      
    }
  }
}

const nerrors = {
  contents: 0
};

function print(ppf, w) {
  const msg = message(w);
  const num = number(w);
  Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
            _0: {
              TAG: /* Int */4,
              _0: /* Int_d */0,
              _1: /* No_padding */0,
              _2: /* No_precision */0,
              _3: {
                TAG: /* String_literal */11,
                _0: ": ",
                _1: {
                  TAG: /* String */2,
                  _0: /* No_padding */0,
                  _1: /* End_of_format */0
                }
              }
            },
            _1: "%d: %s"
          }), num, msg);
  Stdlib__Format.pp_print_flush(ppf, undefined);
  if (Caml_array.get(current.contents.error, num)) {
    nerrors.contents = nerrors.contents + 1 | 0;
    return ;
  }
  
}

const Errors = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Warnings.Errors");

const absname = {
  contents: false
};

function in_file(name) {
  const loc = {
    pos_fname: name,
    pos_lnum: 1,
    pos_bol: 0,
    pos_cnum: -1
  };
  return {
          loc_start: loc,
          loc_end: loc,
          loc_ghost: true
        };
}

const none = in_file("_none_");

function curr(lexbuf) {
  return {
          loc_start: lexbuf.lex_start_p,
          loc_end: lexbuf.lex_curr_p,
          loc_ghost: false
        };
}

function symbol_rloc(param) {
  return {
          loc_start: Stdlib__Parsing.symbol_start_pos(undefined),
          loc_end: Stdlib__Parsing.symbol_end_pos(undefined),
          loc_ghost: false
        };
}

function symbol_gloc(param) {
  return {
          loc_start: Stdlib__Parsing.symbol_start_pos(undefined),
          loc_end: Stdlib__Parsing.symbol_end_pos(undefined),
          loc_ghost: true
        };
}

function rhs_loc(n) {
  return {
          loc_start: Stdlib__Parsing.rhs_start_pos(n),
          loc_end: Stdlib__Parsing.rhs_end_pos(n),
          loc_ghost: false
        };
}

const input_name = {
  contents: "_none_"
};

const input_lexbuf = {
  contents: undefined
};

const status = {
  contents: /* Uninitialised */0
};

const num_loc_lines = {
  contents: 0
};

function highlight_terminfo(ppf, num_lines, lb, locs) {
  Stdlib__Format.pp_print_flush(ppf, undefined);
  const pos0 = -lb.lex_abs_pos | 0;
  if (pos0 < 0) {
    throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
              MEL_EXN_ID: Stdlib.Exit
            });
  }
  let lines = num_loc_lines.contents;
  for(let i = pos0 ,i_finish = lb.lex_buffer_len; i < i_finish; ++i){
    if (Caml_bytes.get(lb.lex_buffer, i) === /* '\n' */10) {
      lines = lines + 1 | 0;
    }
    
  }
  if (lines >= (num_lines - 2 | 0)) {
    throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
              MEL_EXN_ID: Stdlib.Exit
            });
  }
  Caml_io.caml_ml_flush(Stdlib.stdout);
  Caml_external_polyfill.resolve("caml_terminfo_backup")(lines);
  let bol = false;
  Stdlib.print_string("# ");
  for(let pos = 0 ,pos_finish = lb.lex_buffer_len - pos0 | 0; pos < pos_finish; ++pos){
    if (bol) {
      Stdlib.print_string("  ");
      bol = false;
    }
    if (Stdlib__List.exists((function (loc) {
              return pos === loc.loc_start.pos_cnum;
            }), locs)) {
      Caml_external_polyfill.resolve("caml_terminfo_standout")(true);
    }
    if (Stdlib__List.exists((function (loc) {
              return pos === loc.loc_end.pos_cnum;
            }), locs)) {
      Caml_external_polyfill.resolve("caml_terminfo_standout")(false);
    }
    const c = Caml_bytes.get(lb.lex_buffer, pos + pos0 | 0);
    Stdlib.print_char(c);
    bol = c === /* '\n' */10;
  }
  Caml_external_polyfill.resolve("caml_terminfo_standout")(false);
  Caml_external_polyfill.resolve("caml_terminfo_resume")(num_loc_lines.contents);
  Caml_io.caml_ml_flush(Stdlib.stdout);
}

function highlight_dumb(ppf, lb, loc) {
  const pos0 = -lb.lex_abs_pos | 0;
  if (pos0 < 0) {
    throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
              MEL_EXN_ID: Stdlib.Exit
            });
  }
  const end_pos = (lb.lex_buffer_len - pos0 | 0) - 1 | 0;
  let line_start = 0;
  let line_end = 0;
  for(let pos = 0; pos <= end_pos; ++pos){
    if (Caml_bytes.get(lb.lex_buffer, pos + pos0 | 0) === /* '\n' */10) {
      if (loc.loc_start.pos_cnum > pos) {
        line_start = line_start + 1 | 0;
      }
      if (loc.loc_end.pos_cnum > pos) {
        line_end = line_end + 1 | 0;
      }
      
    }
    
  }
  Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
            _0: {
              TAG: /* String_literal */11,
              _0: "Characters ",
              _1: {
                TAG: /* Int */4,
                _0: /* Int_i */3,
                _1: /* No_padding */0,
                _2: /* No_precision */0,
                _3: {
                  TAG: /* Char_literal */12,
                  _0: /* '-' */45,
                  _1: {
                    TAG: /* Int */4,
                    _0: /* Int_i */3,
                    _1: /* No_padding */0,
                    _2: /* No_precision */0,
                    _3: {
                      TAG: /* Char_literal */12,
                      _0: /* ':' */58,
                      _1: {
                        TAG: /* Formatting_lit */17,
                        _0: /* Flush_newline */4,
                        _1: /* End_of_format */0
                      }
                    }
                  }
                }
              }
            },
            _1: "Characters %i-%i:@."
          }), loc.loc_start.pos_cnum, loc.loc_end.pos_cnum);
  Stdlib__Format.pp_print_string(ppf, "  ");
  let line = 0;
  let pos_at_bol = 0;
  for(let pos$1 = 0; pos$1 <= end_pos; ++pos$1){
    const c = Caml_bytes.get(lb.lex_buffer, pos$1 + pos0 | 0);
    if (c !== 10) {
      if (c !== 13) {
        if (line === line_start && line === line_end) {
          Stdlib__Format.pp_print_char(ppf, c);
        } else if (line === line_start) {
          if (pos$1 < loc.loc_start.pos_cnum) {
            Stdlib__Format.pp_print_char(ppf, /* '.' */46);
          } else {
            Stdlib__Format.pp_print_char(ppf, c);
          }
        } else if (line === line_end) {
          if (pos$1 < loc.loc_end.pos_cnum) {
            Stdlib__Format.pp_print_char(ppf, c);
          } else {
            Stdlib__Format.pp_print_char(ppf, /* '.' */46);
          }
        } else if (line > line_start && line < line_end) {
          Stdlib__Format.pp_print_char(ppf, c);
        }
        
      }
      
    } else {
      if (line === line_start && line === line_end) {
        Stdlib__Format.fprintf(ppf)(/* Format */{
              _0: {
                TAG: /* Formatting_lit */17,
                _0: /* Flush_newline */4,
                _1: {
                  TAG: /* String_literal */11,
                  _0: "  ",
                  _1: /* End_of_format */0
                }
              },
              _1: "@.  "
            });
        for(let _i = pos_at_bol ,_i_finish = loc.loc_start.pos_cnum; _i < _i_finish; ++_i){
          Stdlib__Format.pp_print_char(ppf, /* ' ' */32);
        }
        for(let _i$1 = loc.loc_start.pos_cnum ,_i_finish$1 = loc.loc_end.pos_cnum; _i$1 < _i_finish$1; ++_i$1){
          Stdlib__Format.pp_print_char(ppf, /* '^' */94);
        }
      }
      if (line >= line_start && line <= line_end) {
        Stdlib__Format.fprintf(ppf)(/* Format */{
              _0: {
                TAG: /* Formatting_lit */17,
                _0: /* Flush_newline */4,
                _1: /* End_of_format */0
              },
              _1: "@."
            });
        if (pos$1 < loc.loc_end.pos_cnum) {
          Stdlib__Format.pp_print_string(ppf, "  ");
        }
        
      }
      line = line + 1 | 0;
      pos_at_bol = pos$1 + 1 | 0;
    }
  }
}

function highlight_locations(ppf, locs) {
  while(true) {
    const num_lines = status.contents;
    if (typeof num_lines === "number") {
      if (num_lines) {
        const lb = input_lexbuf.contents;
        if (lb === undefined) {
          return false;
        }
        let norepeat;
        try {
          norepeat = Caml_sys.caml_sys_getenv("TERM") === "norepeat";
        }
        catch (raw_exn){
          const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.MEL_EXN_ID === Stdlib.Not_found) {
            norepeat = false;
          } else {
            throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
          }
        }
        if (norepeat) {
          return false;
        }
        const loc1 = Stdlib__List.hd(locs);
        try {
          highlight_dumb(ppf, lb, loc1);
          return true;
        }
        catch (raw_exn$1){
          const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
          if (exn$1.MEL_EXN_ID === Stdlib.Exit) {
            return false;
          }
          throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
        }
      } else {
        status.contents = Caml_external_polyfill.resolve("caml_terminfo_setup")(Stdlib.stdout);
        continue ;
      }
    } else {
      const lb$1 = input_lexbuf.contents;
      if (lb$1 === undefined) {
        return false;
      }
      try {
        highlight_terminfo(ppf, num_lines._0, lb$1, locs);
        return true;
      }
      catch (raw_exn$2){
        const exn$2 = Caml_js_exceptions.internalToOCamlException(raw_exn$2);
        if (exn$2.MEL_EXN_ID === Stdlib.Exit) {
          return false;
        }
        throw new Caml_js_exceptions.MelangeError(exn$2.MEL_EXN_ID, exn$2);
      }
    }
  };
}

function show_filename(file) {
  if (absname.contents) {
    const s = Curry._1(Stdlib__Filename.is_relative, file) ? Stdlib__Filename.concat(Caml_sys.caml_sys_getcwd(undefined), file) : file;
    const aux = function (_s) {
      while(true) {
        const s = _s;
        const base = Curry._1(Stdlib__Filename.basename, s);
        const dir = Curry._1(Stdlib__Filename.dirname, s);
        if (dir === s) {
          return dir;
        }
        if (base !== Stdlib__Filename.current_dir_name) {
          if (base === Stdlib__Filename.parent_dir_name) {
            return Curry._1(Stdlib__Filename.dirname, aux(dir));
          } else {
            return Stdlib__Filename.concat(aux(dir), base);
          }
        }
        _s = dir;
        continue ;
      };
    };
    return aux(s);
  } else {
    return file;
  }
}

function print_filename(ppf, file) {
  Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
            _0: {
              TAG: /* String */2,
              _0: /* No_padding */0,
              _1: /* End_of_format */0
            },
            _1: "%s"
          }), show_filename(file));
}

function get_pos_info(pos) {
  return [
          pos.pos_fname,
          pos.pos_lnum,
          pos.pos_cnum - pos.pos_bol | 0
        ];
}

function print_loc(ppf, loc) {
  Curry._1(Misc_Color.setup, color.contents);
  const match = get_pos_info(loc.loc_start);
  const startchar = match[2];
  const file = match[0];
  const startchar$1 = bs_vscode ? startchar + 1 | 0 : startchar;
  const endchar = (loc.loc_end.pos_cnum - loc.loc_start.pos_cnum | 0) + startchar$1 | 0;
  if (file === "//toplevel//") {
    if (highlight_locations(ppf, {
            hd: loc,
            tl: /* [] */0
          })) {
      return ;
    } else {
      return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "Characters ",
                        _1: {
                          TAG: /* Int */4,
                          _0: /* Int_i */3,
                          _1: /* No_padding */0,
                          _2: /* No_precision */0,
                          _3: {
                            TAG: /* Char_literal */12,
                            _0: /* '-' */45,
                            _1: {
                              TAG: /* Int */4,
                              _0: /* Int_i */3,
                              _1: /* No_padding */0,
                              _2: /* No_precision */0,
                              _3: /* End_of_format */0
                            }
                          }
                        }
                      },
                      _1: "Characters %i-%i"
                    }), loc.loc_start.pos_cnum, loc.loc_end.pos_cnum);
    }
  } else {
    Curry._5(Stdlib__Format.fprintf(ppf)(/* Format */{
              _0: {
                TAG: /* String */2,
                _0: /* No_padding */0,
                _1: {
                  TAG: /* Formatting_gen */18,
                  _0: {
                    TAG: /* Open_tag */0,
                    _0: /* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "<loc>",
                        _1: /* End_of_format */0
                      },
                      _1: "<loc>"
                    }
                  },
                  _1: {
                    TAG: /* Alpha */15,
                    _0: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* Int */4,
                        _0: /* Int_i */3,
                        _1: /* No_padding */0,
                        _2: /* No_precision */0,
                        _3: /* End_of_format */0
                      }
                    }
                  }
                }
              },
              _1: "%s@{<loc>%a%s%i"
            }), "File \"", print_filename, file, "\", line ", match[1]);
    if (startchar$1 >= 0) {
      Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                _0: {
                  TAG: /* String */2,
                  _0: /* No_padding */0,
                  _1: {
                    TAG: /* Int */4,
                    _0: /* Int_i */3,
                    _1: /* No_padding */0,
                    _2: /* No_precision */0,
                    _3: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* Int */4,
                        _0: /* Int_i */3,
                        _1: /* No_padding */0,
                        _2: /* No_precision */0,
                        _3: /* End_of_format */0
                      }
                    }
                  }
                },
                _1: "%s%i%s%i"
              }), ", characters ", startchar$1, "-", endchar);
    }
    return Stdlib__Format.fprintf(ppf)(/* Format */{
                _0: {
                  TAG: /* Formatting_lit */17,
                  _0: /* Close_tag */1,
                  _1: /* End_of_format */0
                },
                _1: "@}"
              });
  }
}

function print$1(ppf, loc) {
  Curry._1(Misc_Color.setup, color.contents);
  if (loc.loc_start.pos_fname === "//toplevel//" && highlight_locations(ppf, {
          hd: loc,
          tl: /* [] */0
        })) {
    return ;
  } else {
    return Curry._3(Stdlib__Format.fprintf(ppf)(/* Format */{
                    _0: {
                      TAG: /* Formatting_gen */18,
                      _0: {
                        TAG: /* Open_tag */0,
                        _0: /* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "<loc>",
                            _1: /* End_of_format */0
                          },
                          _1: "<loc>"
                        }
                      },
                      _1: {
                        TAG: /* Alpha */15,
                        _0: {
                          TAG: /* Formatting_lit */17,
                          _0: /* Close_tag */1,
                          _1: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: {
                              TAG: /* Formatting_lit */17,
                              _0: /* Flush_newline */4,
                              _1: /* End_of_format */0
                            }
                          }
                        }
                      }
                    },
                    _1: "@{<loc>%a@}%s@."
                  }), print_loc, loc, ":");
  }
}

const error_prefix = "Error";

function print_error(ppf, loc) {
  print$1(ppf, loc);
  Curry._1(Misc_Color.setup, color.contents);
  Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
            _0: {
              TAG: /* Formatting_gen */18,
              _0: {
                TAG: /* Open_tag */0,
                _0: /* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "<error>",
                    _1: /* End_of_format */0
                  },
                  _1: "<error>"
                }
              },
              _1: {
                TAG: /* String */2,
                _0: /* No_padding */0,
                _1: {
                  TAG: /* Formatting_lit */17,
                  _0: /* Close_tag */1,
                  _1: {
                    TAG: /* Char_literal */12,
                    _0: /* ':' */58,
                    _1: /* End_of_format */0
                  }
                }
              }
            },
            _1: "@{<error>%s@}:"
          }), error_prefix);
}

function default_warning_printer(loc, ppf, w) {
  if (is_active(w)) {
    Curry._1(Misc_Color.setup, color.contents);
    print$1(ppf, loc);
    return Curry._3(Stdlib__Format.fprintf(ppf)(/* Format */{
                    _0: {
                      TAG: /* Formatting_gen */18,
                      _0: {
                        TAG: /* Open_tag */0,
                        _0: /* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "<warning>",
                            _1: /* End_of_format */0
                          },
                          _1: "<warning>"
                        }
                      },
                      _1: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* Formatting_lit */17,
                          _0: /* Close_tag */1,
                          _1: {
                            TAG: /* Char_literal */12,
                            _0: /* ' ' */32,
                            _1: {
                              TAG: /* Alpha */15,
                              _0: {
                                TAG: /* Formatting_lit */17,
                                _0: /* Flush_newline */4,
                                _1: /* End_of_format */0
                              }
                            }
                          }
                        }
                      }
                    },
                    _1: "@{<warning>%s@} %a@."
                  }), "Warning", print, w);
  }
  
}

const warning_printer = {
  contents: default_warning_printer
};

const formatter_for_warnings = {
  contents: Stdlib__Format.err_formatter
};

function prerr_warning(loc, w) {
  let ppf = formatter_for_warnings.contents;
  let f = Curry._1(warning_printer.contents, loc);
  const out_functions = Stdlib__Format.pp_get_formatter_out_functions(ppf, undefined);
  const out_string = function (str, start, len) {
    const count = function (_i, _c) {
      while(true) {
        const c = _c;
        const i = _i;
        if (i === (start + len | 0)) {
          return c;
        }
        if (Caml_string.get(str, i) === /* '\n' */10) {
          _c = c + 1 | 0;
          _i = i + 1 | 0;
          continue ;
        }
        _i = i + 1 | 0;
        continue ;
      };
    };
    num_loc_lines.contents = num_loc_lines.contents + count(start, 0) | 0;
    Curry._3(out_functions.out_string, str, start, len);
  };
  Stdlib__Format.pp_set_formatter_out_functions(ppf, {
        out_string: out_string,
        out_flush: out_functions.out_flush,
        out_newline: out_functions.out_newline,
        out_spaces: out_functions.out_spaces,
        out_indent: out_functions.out_indent
      });
  Curry._2(f, ppf, w);
  Stdlib__Format.pp_print_flush(ppf, undefined);
  Stdlib__Format.pp_set_formatter_out_functions(ppf, out_functions);
}

function print_phanton_error_prefix(ppf) {
  Stdlib__Format.pp_print_as(ppf, error_prefix.length + 2 | 0, "");
}

function errorf(locOpt, subOpt, if_highlightOpt, fmt) {
  const loc = locOpt !== undefined ? locOpt : none;
  const sub = subOpt !== undefined ? subOpt : /* [] */0;
  const if_highlight = if_highlightOpt !== undefined ? if_highlightOpt : "";
  let before = print_phanton_error_prefix;
  const k = function (msg) {
    return {
            loc: loc,
            msg: msg,
            sub: sub,
            if_highlight: if_highlight
          };
  };
  const buf = Stdlib__Buffer.create(64);
  const ppf = Stdlib__Format.formatter_of_buffer(buf);
  Curry._1(Misc_Color.set_color_tag_handling, ppf);
  if (before !== undefined) {
    Curry._1(before, ppf);
  }
  return Stdlib__Format.kfprintf((function (param) {
                Stdlib__Format.pp_print_flush(ppf, undefined);
                return Curry._1(k, Stdlib__Buffer.contents(buf));
              }), ppf, fmt);
}

function error(locOpt, subOpt, if_highlightOpt, msg) {
  const loc = locOpt !== undefined ? locOpt : none;
  const sub = subOpt !== undefined ? subOpt : /* [] */0;
  const if_highlight = if_highlightOpt !== undefined ? if_highlightOpt : "";
  return {
          loc: loc,
          msg: msg,
          sub: sub,
          if_highlight: if_highlight
        };
}

const error_of_exn = {
  contents: /* [] */0
};

function register_error_of_exn(f) {
  error_of_exn.contents = {
    hd: f,
    tl: error_of_exn.contents
  };
}

function error_of_printer(loc, print, x) {
  return Curry._2(errorf(loc, undefined, undefined, /* Format */{
                  _0: {
                    TAG: /* Alpha */15,
                    _0: {
                      TAG: /* Formatting_lit */17,
                      _0: /* FFlush */2,
                      _1: /* End_of_format */0
                    }
                  },
                  _1: "%a@?"
                }), print, x);
}

function error_of_printer_file(print, x) {
  return error_of_printer(in_file(input_name.contents), print, x);
}

register_error_of_exn(function (msg) {
      if (msg.MEL_EXN_ID === Stdlib.Sys_error) {
        return Curry._1(errorf(in_file(input_name.contents), undefined, undefined, /* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "I/O error: ",
                          _1: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: /* End_of_format */0
                          }
                        },
                        _1: "I/O error: %s"
                      }), msg._1);
      } else if (msg.MEL_EXN_ID === Errors) {
        return Curry._1(errorf(in_file(input_name.contents), undefined, undefined, /* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "Some fatal warnings were triggered (",
                          _1: {
                            TAG: /* Int */4,
                            _0: /* Int_d */0,
                            _1: /* No_padding */0,
                            _2: /* No_precision */0,
                            _3: {
                              TAG: /* String_literal */11,
                              _0: " occurrences)",
                              _1: /* End_of_format */0
                            }
                          }
                        },
                        _1: "Some fatal warnings were triggered (%d occurrences)"
                      }), msg._1);
      } else {
        return ;
      }
    });

const $$Error = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Location.Error");

register_error_of_exn(function (e) {
      if (e.MEL_EXN_ID === $$Error) {
        return e._1;
      }
      
    });

const currentstamp = {
  contents: 0
};

function create(s) {
  currentstamp.contents = currentstamp.contents + 1 | 0;
  return {
          stamp: currentstamp.contents,
          name: s,
          flags: 0
        };
}

function create_predef_exn(s) {
  currentstamp.contents = currentstamp.contents + 1 | 0;
  return {
          stamp: currentstamp.contents,
          name: s,
          flags: 2
        };
}

function rename(i) {
  currentstamp.contents = currentstamp.contents + 1 | 0;
  return {
          stamp: currentstamp.contents,
          name: i.name,
          flags: i.flags
        };
}

function unique_toplevel_name(i) {
  return i.name + ("/" + String(i.stamp));
}

function equal(i1, i2) {
  return i1.name === i2.name;
}

function set_current_time(t) {
  currentstamp.contents = currentstamp.contents > t ? currentstamp.contents : t;
}

function hide(i) {
  return {
          stamp: -1,
          name: i.name,
          flags: i.flags
        };
}

function make_global(i) {
  i.flags = i.flags | 1;
}

function $$global(i) {
  return (i.flags & 1) !== 0;
}

function print$2(ppf, i) {
  const n = i.stamp;
  if (n !== -1) {
    if (n !== 0) {
      return Curry._3(Stdlib__Format.fprintf(ppf)(/* Format */{
                      _0: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* Char_literal */12,
                          _0: /* '/' */47,
                          _1: {
                            TAG: /* Int */4,
                            _0: /* Int_i */3,
                            _1: /* No_padding */0,
                            _2: /* No_precision */0,
                            _3: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: /* End_of_format */0
                            }
                          }
                        }
                      },
                      _1: "%s/%i%s"
                    }), i.name, n, $$global(i) ? "g" : "");
    } else {
      return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                      _0: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* Char_literal */12,
                          _0: /* '!' */33,
                          _1: /* End_of_format */0
                        }
                      },
                      _1: "%s!"
                    }), i.name);
    }
  } else {
    return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                    _0: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* Char_literal */12,
                        _0: /* '#' */35,
                        _1: /* End_of_format */0
                      }
                    },
                    _1: "%s#"
                  }), i.name);
  }
}

function mknode(l, d, r) {
  const hl = l ? l._3 : 0;
  const hr = r ? r._3 : 0;
  return /* Node */{
          _0: l,
          _1: d,
          _2: r,
          _3: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        };
}

function balance(l, d, r) {
  const hl = l ? l._3 : 0;
  const hr = r ? r._3 : 0;
  if (hl > (hr + 1 | 0)) {
    if (l) {
      const lr = l._2;
      const ld = l._1;
      const ll = l._0;
      if ((
          ll ? ll._3 : 0
        ) >= (
          lr ? lr._3 : 0
        )) {
        return mknode(ll, ld, mknode(lr, d, r));
      }
      if (lr) {
        return mknode(mknode(ll, ld, lr._0), lr._1, mknode(lr._2, d, r));
      }
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  2781,
                  11
                ]
              });
    }
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                2781,
                11
              ]
            });
  }
  if (hr <= (hl + 1 | 0)) {
    return mknode(l, d, r);
  }
  if (r) {
    const rl = r._0;
    const rr = r._2;
    if ((
        rr ? rr._3 : 0
      ) >= (
        rl ? rl._3 : 0
      )) {
      return mknode(mknode(l, d, rl), r._1, rr);
    }
    if (rl) {
      return mknode(mknode(l, d, rl._0), rl._1, mknode(rl._2, r._1, r._2));
    }
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                2790,
                11
              ]
            });
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              2790,
              11
            ]
          });
}

function add(id, data, param) {
  if (!param) {
    return /* Node */{
            _0: /* Empty */0,
            _1: {
              ident: id,
              data: data,
              previous: undefined
            },
            _2: /* Empty */0,
            _3: 1
          };
  }
  const r = param._2;
  const k = param._1;
  const l = param._0;
  const c = Caml.caml_string_compare(id.name, k.ident.name);
  if (c === 0) {
    return /* Node */{
            _0: l,
            _1: {
              ident: id,
              data: data,
              previous: k
            },
            _2: r,
            _3: param._3
          };
  } else if (c < 0) {
    return balance(add(id, data, l), k, r);
  } else {
    return balance(l, k, add(id, data, r));
  }
}

function find_same(id, _param) {
  while(true) {
    const param = _param;
    if (param) {
      const k = param._1;
      const c = Caml.caml_string_compare(id.name, k.ident.name);
      if (c === 0) {
        if (id.stamp === k.ident.stamp) {
          return k.data;
        } else {
          let s = id.stamp;
          let _k = k.previous;
          while(true) {
            const k$1 = _k;
            if (k$1 !== undefined) {
              if (k$1.ident.stamp === s) {
                return k$1.data;
              }
              _k = k$1.previous;
              continue ;
            }
            throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                      MEL_EXN_ID: Stdlib.Not_found
                    });
          };
        }
      }
      _param = c < 0 ? param._0 : param._2;
      continue ;
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
  };
}

function find_name(name, _param) {
  while(true) {
    const param = _param;
    if (param) {
      const k = param._1;
      const c = Caml.caml_string_compare(name, k.ident.name);
      if (c === 0) {
        return k.data;
      }
      _param = c < 0 ? param._0 : param._2;
      continue ;
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
  };
}

function get_all(k) {
  if (k !== undefined) {
    return {
            hd: k.data,
            tl: get_all(k.previous)
          };
  } else {
    return /* [] */0;
  }
}

function find_all(name, _param) {
  while(true) {
    const param = _param;
    if (!param) {
      return /* [] */0;
    }
    const k = param._1;
    const c = Caml.caml_string_compare(name, k.ident.name);
    if (c === 0) {
      return {
              hd: k.data,
              tl: get_all(k.previous)
            };
    }
    _param = c < 0 ? param._0 : param._2;
    continue ;
  };
}

function iter(f, _param) {
  while(true) {
    const param = _param;
    if (!param) {
      return ;
    }
    const k = param._1;
    iter(f, param._0);
    Curry._2(f, k.ident, k.data);
    _param = param._2;
    continue ;
  };
}

function same(_p1, _p2) {
  while(true) {
    const p2 = _p2;
    const p1 = _p1;
    switch (p1.TAG | 0) {
      case /* Pident */0 :
          switch (p2.TAG | 0) {
            case /* Pident */0 :
                return Caml_obj.caml_equal(p1._0, p2._0);
            case /* Pdot */1 :
            case /* Papply */2 :
                return false;
            
          }
      case /* Pdot */1 :
          switch (p2.TAG | 0) {
            case /* Pdot */1 :
                if (p1._1 !== p2._1) {
                  return false;
                }
                _p2 = p2._0;
                _p1 = p1._0;
                continue ;
            case /* Pident */0 :
            case /* Papply */2 :
                return false;
            
          }
      case /* Papply */2 :
          switch (p2.TAG | 0) {
            case /* Pident */0 :
            case /* Pdot */1 :
                return false;
            case /* Papply */2 :
                if (!same(p1._0, p2._0)) {
                  return false;
                }
                _p2 = p2._1;
                _p1 = p1._1;
                continue ;
            
          }
      
    }
  };
}

function isfree(id, _id$p) {
  while(true) {
    const id$p = _id$p;
    switch (id$p.TAG | 0) {
      case /* Pident */0 :
          return Caml_obj.caml_equal(id, id$p._0);
      case /* Pdot */1 :
          _id$p = id$p._0;
          continue ;
      case /* Papply */2 :
          if (isfree(id, id$p._0)) {
            return true;
          }
          _id$p = id$p._1;
          continue ;
      
    }
  };
}

function binding_time(_id) {
  while(true) {
    const id = _id;
    switch (id.TAG | 0) {
      case /* Pident */0 :
          return id._0.stamp;
      case /* Pdot */1 :
          _id = id._0;
          continue ;
      case /* Papply */2 :
          return Caml.caml_int_max(binding_time(id._0), binding_time(id._1));
      
    }
  };
}

function kfalse(x) {
  return false;
}

function name(parenOpt, id) {
  const paren = parenOpt !== undefined ? parenOpt : kfalse;
  switch (id.TAG | 0) {
    case /* Pident */0 :
        return id._0.name;
    case /* Pdot */1 :
        const s = id._1;
        return name(paren, id._0) + (
                Curry._1(paren, s) ? ".( " + (s + " )") : "." + s
              );
    case /* Papply */2 :
        return name(paren, id._0) + ("(" + (name(paren, id._1) + ")"));
    
  }
}

function head(_id) {
  while(true) {
    const id = _id;
    switch (id.TAG | 0) {
      case /* Pident */0 :
          return id._0;
      case /* Pdot */1 :
          _id = id._0;
          continue ;
      case /* Papply */2 :
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                    MEL_EXN_ID: "Assert_failure",
                    _1: [
                      "jscomp/test/ocaml_typedtree_test.ml",
                      2970,
                      22
                    ]
                  });
      
    }
  };
}

function last(_id) {
  while(true) {
    const id = _id;
    switch (id.TAG | 0) {
      case /* Pident */0 :
          return id._0.name;
      case /* Pdot */1 :
          return id._1;
      case /* Papply */2 :
          _id = id._1;
          continue ;
      
    }
  };
}

function flat(_accu, _s) {
  while(true) {
    const s = _s;
    const accu = _accu;
    switch (s.TAG | 0) {
      case /* Lident */0 :
          return {
                  hd: s._0,
                  tl: accu
                };
      case /* Ldot */1 :
          _s = s._0;
          _accu = {
            hd: s._1,
            tl: accu
          };
          continue ;
      case /* Lapply */2 :
          return fatal_error("Longident.flat");
      
    }
  };
}

function flatten(lid) {
  return flat(/* [] */0, lid);
}

function last$1(s) {
  switch (s.TAG | 0) {
    case /* Lident */0 :
        return s._0;
    case /* Ldot */1 :
        return s._1;
    case /* Lapply */2 :
        return fatal_error("Longident.last");
    
  }
}

function parse_declaration(arity, decl) {
  if (!decl) {
    return fatal_error("Primitive.parse_declaration");
  }
  const name = decl.hd;
  const match = decl.tl;
  if (!match) {
    return {
            prim_name: name,
            prim_arity: arity,
            prim_alloc: true,
            prim_native_name: "",
            prim_native_float: false
          };
  }
  const name2 = match.hd;
  if (name2 === "noalloc") {
    const match$1 = match.tl;
    if (match$1) {
      const name2$1 = match$1.hd;
      const match$2 = match$1.tl;
      if (match$2 && match$2.hd === "float") {
        return {
                prim_name: name,
                prim_arity: arity,
                prim_alloc: false,
                prim_native_name: name2$1,
                prim_native_float: true
              };
      } else {
        return {
                prim_name: name,
                prim_arity: arity,
                prim_alloc: false,
                prim_native_name: name2$1,
                prim_native_float: false
              };
      }
    }
    
  } else {
    const match$3 = match.tl;
    if (match$3 && match$3.hd === "float") {
      return {
              prim_name: name,
              prim_arity: arity,
              prim_alloc: true,
              prim_native_name: name2,
              prim_native_float: true
            };
    }
    
  }
  if (name2 === "noalloc") {
    return {
            prim_name: name,
            prim_arity: arity,
            prim_alloc: false,
            prim_native_name: "",
            prim_native_float: false
          };
  } else {
    return {
            prim_name: name,
            prim_arity: arity,
            prim_alloc: true,
            prim_native_name: name2,
            prim_native_float: false
          };
  }
}

function description_list(p) {
  const list_0 = p.prim_name;
  const list = {
    hd: list_0,
    tl: /* [] */0
  };
  const list$1 = p.prim_alloc ? list : ({
        hd: "noalloc",
        tl: list
      });
  const list$2 = p.prim_native_name !== "" ? ({
        hd: p.prim_native_name,
        tl: list$1
      }) : list$1;
  return Stdlib__List.rev(p.prim_native_float ? ({
                  hd: "float",
                  tl: list$2
                }) : list$2);
}

function compare(t1, t2) {
  return t1.id - t2.id | 0;
}

function hash(t) {
  return t.id;
}

function equal$1(t1, t2) {
  return t1 === t2;
}

const compare$1 = Caml.caml_string_compare;

const OrderedString = {
  compare: compare$1
};

function height(param) {
  if (param) {
    return param.h;
  } else {
    return 0;
  }
}

function create$1(l, x, d, r) {
  const hl = height(l);
  const hr = height(r);
  return /* Node */{
          l: l,
          v: x,
          d: d,
          r: r,
          h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        };
}

function singleton(x, d) {
  return /* Node */{
          l: /* Empty */0,
          v: x,
          d: d,
          r: /* Empty */0,
          h: 1
        };
}

function bal(l, x, d, r) {
  const hl = l ? l.h : 0;
  const hr = r ? r.h : 0;
  if (hl > (hr + 2 | 0)) {
    if (l) {
      const lr = l.r;
      const ld = l.d;
      const lv = l.v;
      const ll = l.l;
      if (height(ll) >= height(lr)) {
        return create$1(ll, lv, ld, create$1(lr, x, d, r));
      }
      if (lr) {
        return create$1(create$1(ll, lv, ld, lr.l), lr.v, lr.d, create$1(lr.r, x, d, r));
      }
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
                MEL_EXN_ID: "Invalid_argument",
                _1: "Map.bal"
              });
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Map.bal"
            });
  }
  if (hr <= (hl + 2 | 0)) {
    return /* Node */{
            l: l,
            v: x,
            d: d,
            r: r,
            h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          };
  }
  if (r) {
    const rr = r.r;
    const rd = r.d;
    const rv = r.v;
    const rl = r.l;
    if (height(rr) >= height(rl)) {
      return create$1(create$1(l, x, d, rl), rv, rd, rr);
    }
    if (rl) {
      return create$1(create$1(l, x, d, rl.l), rl.v, rl.d, create$1(rl.r, rv, rd, rr));
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Map.bal"
            });
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Map.bal"
          });
}

function is_empty(param) {
  if (param) {
    return false;
  } else {
    return true;
  }
}

function add$1(x, data, m) {
  if (!m) {
    return /* Node */{
            l: /* Empty */0,
            v: x,
            d: data,
            r: /* Empty */0,
            h: 1
          };
  }
  const r = m.r;
  const d = m.d;
  const v = m.v;
  const l = m.l;
  const c = Curry._2(OrderedString.compare, x, v);
  if (c === 0) {
    if (d === data) {
      return m;
    } else {
      return /* Node */{
              l: l,
              v: x,
              d: data,
              r: r,
              h: m.h
            };
    }
  }
  if (c < 0) {
    const ll = add$1(x, data, l);
    if (l === ll) {
      return m;
    } else {
      return bal(ll, v, d, r);
    }
  }
  const rr = add$1(x, data, r);
  if (r === rr) {
    return m;
  } else {
    return bal(l, v, d, rr);
  }
}

function find(x, _param) {
  while(true) {
    const param = _param;
    if (param) {
      const c = Curry._2(OrderedString.compare, x, param.v);
      if (c === 0) {
        return param.d;
      }
      _param = c < 0 ? param.l : param.r;
      continue ;
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
  };
}

function find_first(f, _param) {
  while(true) {
    const param = _param;
    if (param) {
      const v = param.v;
      if (Curry._1(f, v)) {
        let _v0 = v;
        let _d0 = param.d;
        let _param$1 = param.l;
        while(true) {
          const param$1 = _param$1;
          const d0 = _d0;
          const v0 = _v0;
          if (!param$1) {
            return [
                    v0,
                    d0
                  ];
          }
          const v$1 = param$1.v;
          if (Curry._1(f, v$1)) {
            _param$1 = param$1.l;
            _d0 = param$1.d;
            _v0 = v$1;
            continue ;
          }
          _param$1 = param$1.r;
          continue ;
        };
      }
      _param = param.r;
      continue ;
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
  };
}

function find_first_opt(f, _param) {
  while(true) {
    const param = _param;
    if (!param) {
      return ;
    }
    const v = param.v;
    if (Curry._1(f, v)) {
      let _v0 = v;
      let _d0 = param.d;
      let _param$1 = param.l;
      while(true) {
        const param$1 = _param$1;
        const d0 = _d0;
        const v0 = _v0;
        if (!param$1) {
          return [
                  v0,
                  d0
                ];
        }
        const v$1 = param$1.v;
        if (Curry._1(f, v$1)) {
          _param$1 = param$1.l;
          _d0 = param$1.d;
          _v0 = v$1;
          continue ;
        }
        _param$1 = param$1.r;
        continue ;
      };
    }
    _param = param.r;
    continue ;
  };
}

function find_last(f, _param) {
  while(true) {
    const param = _param;
    if (param) {
      const v = param.v;
      if (Curry._1(f, v)) {
        let _v0 = v;
        let _d0 = param.d;
        let _param$1 = param.r;
        while(true) {
          const param$1 = _param$1;
          const d0 = _d0;
          const v0 = _v0;
          if (!param$1) {
            return [
                    v0,
                    d0
                  ];
          }
          const v$1 = param$1.v;
          if (Curry._1(f, v$1)) {
            _param$1 = param$1.r;
            _d0 = param$1.d;
            _v0 = v$1;
            continue ;
          }
          _param$1 = param$1.l;
          continue ;
        };
      }
      _param = param.l;
      continue ;
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
  };
}

function find_last_opt(f, _param) {
  while(true) {
    const param = _param;
    if (!param) {
      return ;
    }
    const v = param.v;
    if (Curry._1(f, v)) {
      let _v0 = v;
      let _d0 = param.d;
      let _param$1 = param.r;
      while(true) {
        const param$1 = _param$1;
        const d0 = _d0;
        const v0 = _v0;
        if (!param$1) {
          return [
                  v0,
                  d0
                ];
        }
        const v$1 = param$1.v;
        if (Curry._1(f, v$1)) {
          _param$1 = param$1.r;
          _d0 = param$1.d;
          _v0 = v$1;
          continue ;
        }
        _param$1 = param$1.l;
        continue ;
      };
    }
    _param = param.l;
    continue ;
  };
}

function find_opt(x, _param) {
  while(true) {
    const param = _param;
    if (!param) {
      return ;
    }
    const c = Curry._2(OrderedString.compare, x, param.v);
    if (c === 0) {
      return Caml_option.some(param.d);
    }
    _param = c < 0 ? param.l : param.r;
    continue ;
  };
}

function mem(x, _param) {
  while(true) {
    const param = _param;
    if (!param) {
      return false;
    }
    const c = Curry._2(OrderedString.compare, x, param.v);
    if (c === 0) {
      return true;
    }
    _param = c < 0 ? param.l : param.r;
    continue ;
  };
}

function min_binding(_param) {
  while(true) {
    const param = _param;
    if (param) {
      const l = param.l;
      if (!l) {
        return [
                param.v,
                param.d
              ];
      }
      _param = l;
      continue ;
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
  };
}

function min_binding_opt(_param) {
  while(true) {
    const param = _param;
    if (!param) {
      return ;
    }
    const l = param.l;
    if (!l) {
      return [
              param.v,
              param.d
            ];
    }
    _param = l;
    continue ;
  };
}

function max_binding(_param) {
  while(true) {
    const param = _param;
    if (param) {
      if (!param.r) {
        return [
                param.v,
                param.d
              ];
      }
      _param = param.r;
      continue ;
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
  };
}

function max_binding_opt(_param) {
  while(true) {
    const param = _param;
    if (!param) {
      return ;
    }
    if (!param.r) {
      return [
              param.v,
              param.d
            ];
    }
    _param = param.r;
    continue ;
  };
}

function remove_min_binding(param) {
  if (param) {
    const l = param.l;
    if (l) {
      return bal(remove_min_binding(l), param.v, param.d, param.r);
    } else {
      return param.r;
    }
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Map.remove_min_elt"
          });
}

function merge(t1, t2) {
  if (!t1) {
    return t2;
  }
  if (!t2) {
    return t1;
  }
  const match = min_binding(t2);
  return bal(t1, match[0], match[1], remove_min_binding(t2));
}

function remove(x, m) {
  if (!m) {
    return /* Empty */0;
  }
  const r = m.r;
  const d = m.d;
  const v = m.v;
  const l = m.l;
  const c = Curry._2(OrderedString.compare, x, v);
  if (c === 0) {
    return merge(l, r);
  }
  if (c < 0) {
    const ll = remove(x, l);
    if (l === ll) {
      return m;
    } else {
      return bal(ll, v, d, r);
    }
  }
  const rr = remove(x, r);
  if (r === rr) {
    return m;
  } else {
    return bal(l, v, d, rr);
  }
}

function update(x, f, m) {
  if (m) {
    const r = m.r;
    const d = m.d;
    const v = m.v;
    const l = m.l;
    const c = Curry._2(OrderedString.compare, x, v);
    if (c === 0) {
      const data = Curry._1(f, Caml_option.some(d));
      if (data === undefined) {
        return merge(l, r);
      }
      const data$1 = Caml_option.valFromOption(data);
      if (d === data$1) {
        return m;
      } else {
        return /* Node */{
                l: l,
                v: x,
                d: data$1,
                r: r,
                h: m.h
              };
      }
    }
    if (c < 0) {
      const ll = update(x, f, l);
      if (l === ll) {
        return m;
      } else {
        return bal(ll, v, d, r);
      }
    }
    const rr = update(x, f, r);
    if (r === rr) {
      return m;
    } else {
      return bal(l, v, d, rr);
    }
  }
  const data$2 = Curry._1(f, undefined);
  if (data$2 !== undefined) {
    return /* Node */{
            l: /* Empty */0,
            v: x,
            d: Caml_option.valFromOption(data$2),
            r: /* Empty */0,
            h: 1
          };
  } else {
    return /* Empty */0;
  }
}

function add_to_list(x, data, m) {
  const add = function (l) {
    if (l !== undefined) {
      return {
              hd: data,
              tl: l
            };
    } else {
      return {
              hd: data,
              tl: /* [] */0
            };
    }
  };
  return update(x, add, m);
}

function iter$1(f, _param) {
  while(true) {
    const param = _param;
    if (!param) {
      return ;
    }
    iter$1(f, param.l);
    Curry._2(f, param.v, param.d);
    _param = param.r;
    continue ;
  };
}

function map(f, param) {
  if (!param) {
    return /* Empty */0;
  }
  const l$p = map(f, param.l);
  const d$p = Curry._1(f, param.d);
  const r$p = map(f, param.r);
  return /* Node */{
          l: l$p,
          v: param.v,
          d: d$p,
          r: r$p,
          h: param.h
        };
}

function mapi(f, param) {
  if (!param) {
    return /* Empty */0;
  }
  const v = param.v;
  const l$p = mapi(f, param.l);
  const d$p = Curry._2(f, v, param.d);
  const r$p = mapi(f, param.r);
  return /* Node */{
          l: l$p,
          v: v,
          d: d$p,
          r: r$p,
          h: param.h
        };
}

function fold(f, _m, _accu) {
  while(true) {
    const accu = _accu;
    const m = _m;
    if (!m) {
      return accu;
    }
    _accu = Curry._3(f, m.v, m.d, fold(f, m.l, accu));
    _m = m.r;
    continue ;
  };
}

function for_all(p, _param) {
  while(true) {
    const param = _param;
    if (!param) {
      return true;
    }
    if (!Curry._2(p, param.v, param.d)) {
      return false;
    }
    if (!for_all(p, param.l)) {
      return false;
    }
    _param = param.r;
    continue ;
  };
}

function exists(p, _param) {
  while(true) {
    const param = _param;
    if (!param) {
      return false;
    }
    if (Curry._2(p, param.v, param.d)) {
      return true;
    }
    if (exists(p, param.l)) {
      return true;
    }
    _param = param.r;
    continue ;
  };
}

function add_min_binding(k, x, param) {
  if (param) {
    return bal(add_min_binding(k, x, param.l), param.v, param.d, param.r);
  } else {
    return singleton(k, x);
  }
}

function add_max_binding(k, x, param) {
  if (param) {
    return bal(param.l, param.v, param.d, add_max_binding(k, x, param.r));
  } else {
    return singleton(k, x);
  }
}

function join(l, v, d, r) {
  if (!l) {
    return add_min_binding(v, d, r);
  }
  if (!r) {
    return add_max_binding(v, d, l);
  }
  const rh = r.h;
  const lh = l.h;
  if (lh > (rh + 2 | 0)) {
    return bal(l.l, l.v, l.d, join(l.r, v, d, r));
  } else if (rh > (lh + 2 | 0)) {
    return bal(join(l, v, d, r.l), r.v, r.d, r.r);
  } else {
    return create$1(l, v, d, r);
  }
}

function concat(t1, t2) {
  if (!t1) {
    return t2;
  }
  if (!t2) {
    return t1;
  }
  const match = min_binding(t2);
  return join(t1, match[0], match[1], remove_min_binding(t2));
}

function concat_or_join(t1, v, d, t2) {
  if (d !== undefined) {
    return join(t1, v, Caml_option.valFromOption(d), t2);
  } else {
    return concat(t1, t2);
  }
}

function split(x, param) {
  if (!param) {
    return [
            /* Empty */0,
            undefined,
            /* Empty */0
          ];
  }
  const r = param.r;
  const d = param.d;
  const v = param.v;
  const l = param.l;
  const c = Curry._2(OrderedString.compare, x, v);
  if (c === 0) {
    return [
            l,
            Caml_option.some(d),
            r
          ];
  }
  if (c < 0) {
    const match = split(x, l);
    return [
            match[0],
            match[1],
            join(match[2], v, d, r)
          ];
  }
  const match$1 = split(x, r);
  return [
          join(l, v, d, match$1[0]),
          match$1[1],
          match$1[2]
        ];
}

function merge$1(f, s1, s2) {
  if (s1) {
    const v1 = s1.v;
    if (s1.h >= height(s2)) {
      const match = split(v1, s2);
      return concat_or_join(merge$1(f, s1.l, match[0]), v1, Curry._3(f, v1, Caml_option.some(s1.d), match[1]), merge$1(f, s1.r, match[2]));
    }
    
  } else if (!s2) {
    return /* Empty */0;
  }
  if (s2) {
    const v2 = s2.v;
    const match$1 = split(v2, s1);
    return concat_or_join(merge$1(f, match$1[0], s2.l), v2, Curry._3(f, v2, match$1[1], Caml_option.some(s2.d)), merge$1(f, match$1[2], s2.r));
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/stdlib/map.ml",
              408,
              10
            ]
          });
}

function union(f, s1, s2) {
  if (!s1) {
    return s2;
  }
  if (!s2) {
    return s1;
  }
  const d2 = s2.d;
  const v2 = s2.v;
  const d1 = s1.d;
  const v1 = s1.v;
  if (s1.h >= s2.h) {
    const match = split(v1, s2);
    const d2$1 = match[1];
    const l = union(f, s1.l, match[0]);
    const r = union(f, s1.r, match[2]);
    if (d2$1 !== undefined) {
      return concat_or_join(l, v1, Curry._3(f, v1, d1, Caml_option.valFromOption(d2$1)), r);
    } else {
      return join(l, v1, d1, r);
    }
  }
  const match$1 = split(v2, s1);
  const d1$1 = match$1[1];
  const l$1 = union(f, match$1[0], s2.l);
  const r$1 = union(f, match$1[2], s2.r);
  if (d1$1 !== undefined) {
    return concat_or_join(l$1, v2, Curry._3(f, v2, Caml_option.valFromOption(d1$1), d2), r$1);
  } else {
    return join(l$1, v2, d2, r$1);
  }
}

function filter(p, m) {
  if (!m) {
    return /* Empty */0;
  }
  const r = m.r;
  const d = m.d;
  const v = m.v;
  const l = m.l;
  const l$p = filter(p, l);
  const pvd = Curry._2(p, v, d);
  const r$p = filter(p, r);
  if (pvd) {
    if (l === l$p && r === r$p) {
      return m;
    } else {
      return join(l$p, v, d, r$p);
    }
  } else {
    return concat(l$p, r$p);
  }
}

function filter_map(f, param) {
  if (!param) {
    return /* Empty */0;
  }
  const v = param.v;
  const l$p = filter_map(f, param.l);
  const fvd = Curry._2(f, v, param.d);
  const r$p = filter_map(f, param.r);
  if (fvd !== undefined) {
    return join(l$p, v, Caml_option.valFromOption(fvd), r$p);
  } else {
    return concat(l$p, r$p);
  }
}

function partition(p, param) {
  if (!param) {
    return [
            /* Empty */0,
            /* Empty */0
          ];
  }
  const d = param.d;
  const v = param.v;
  const match = partition(p, param.l);
  const lf = match[1];
  const lt = match[0];
  const pvd = Curry._2(p, v, d);
  const match$1 = partition(p, param.r);
  const rf = match$1[1];
  const rt = match$1[0];
  if (pvd) {
    return [
            join(lt, v, d, rt),
            concat(lf, rf)
          ];
  } else {
    return [
            concat(lt, rt),
            join(lf, v, d, rf)
          ];
  }
}

function cons_enum(_m, _e) {
  while(true) {
    const e = _e;
    const m = _m;
    if (!m) {
      return e;
    }
    _e = /* More */{
      _0: m.v,
      _1: m.d,
      _2: m.r,
      _3: e
    };
    _m = m.l;
    continue ;
  };
}

function compare$2(cmp, m1, m2) {
  let _e1 = cons_enum(m1, /* End */0);
  let _e2 = cons_enum(m2, /* End */0);
  while(true) {
    const e2 = _e2;
    const e1 = _e1;
    if (!e1) {
      if (e2) {
        return -1;
      } else {
        return 0;
      }
    }
    if (!e2) {
      return 1;
    }
    const c = Curry._2(OrderedString.compare, e1._0, e2._0);
    if (c !== 0) {
      return c;
    }
    const c$1 = Curry._2(cmp, e1._1, e2._1);
    if (c$1 !== 0) {
      return c$1;
    }
    _e2 = cons_enum(e2._2, e2._3);
    _e1 = cons_enum(e1._2, e1._3);
    continue ;
  };
}

function equal$2(cmp, m1, m2) {
  let _e1 = cons_enum(m1, /* End */0);
  let _e2 = cons_enum(m2, /* End */0);
  while(true) {
    const e2 = _e2;
    const e1 = _e1;
    if (!e1) {
      if (e2) {
        return false;
      } else {
        return true;
      }
    }
    if (!e2) {
      return false;
    }
    if (Curry._2(OrderedString.compare, e1._0, e2._0) !== 0) {
      return false;
    }
    if (!Curry._2(cmp, e1._1, e2._1)) {
      return false;
    }
    _e2 = cons_enum(e2._2, e2._3);
    _e1 = cons_enum(e1._2, e1._3);
    continue ;
  };
}

function cardinal(param) {
  if (param) {
    return (cardinal(param.l) + 1 | 0) + cardinal(param.r) | 0;
  } else {
    return 0;
  }
}

function bindings_aux(_accu, _param) {
  while(true) {
    const param = _param;
    const accu = _accu;
    if (!param) {
      return accu;
    }
    _param = param.l;
    _accu = {
      hd: [
        param.v,
        param.d
      ],
      tl: bindings_aux(accu, param.r)
    };
    continue ;
  };
}

function bindings(s) {
  return bindings_aux(/* [] */0, s);
}

function of_list(bs) {
  return Stdlib__List.fold_left((function (m, param) {
                return add$1(param[0], param[1], m);
              }), /* Empty */0, bs);
}

function add_seq(i, m) {
  return Stdlib__Seq.fold_left((function (m, param) {
                return add$1(param[0], param[1], m);
              }), m, i);
}

function of_seq(i) {
  return add_seq(i, /* Empty */0);
}

function seq_of_enum_(c, param) {
  if (!c) {
    return /* Nil */0;
  }
  const partial_arg = cons_enum(c._2, c._3);
  return /* Cons */{
          _0: [
            c._0,
            c._1
          ],
          _1: (function (param) {
              return seq_of_enum_(partial_arg, param);
            })
        };
}

function to_seq(m) {
  const partial_arg = cons_enum(m, /* End */0);
  return function (param) {
    return seq_of_enum_(partial_arg, param);
  };
}

function snoc_enum(_s, _e) {
  while(true) {
    const e = _e;
    const s = _s;
    if (!s) {
      return e;
    }
    _e = /* More */{
      _0: s.v,
      _1: s.d,
      _2: s.l,
      _3: e
    };
    _s = s.r;
    continue ;
  };
}

function rev_seq_of_enum_(c, param) {
  if (!c) {
    return /* Nil */0;
  }
  const partial_arg = snoc_enum(c._2, c._3);
  return /* Cons */{
          _0: [
            c._0,
            c._1
          ],
          _1: (function (param) {
              return rev_seq_of_enum_(partial_arg, param);
            })
        };
}

function to_rev_seq(c) {
  const partial_arg = snoc_enum(c, /* End */0);
  return function (param) {
    return rev_seq_of_enum_(partial_arg, param);
  };
}

function to_seq_from(low, m) {
  const aux = function (low, _m, _c) {
    while(true) {
      const c = _c;
      const m = _m;
      if (!m) {
        return c;
      }
      const r = m.r;
      const d = m.d;
      const v = m.v;
      const n = Curry._2(OrderedString.compare, v, low);
      if (n === 0) {
        return /* More */{
                _0: v,
                _1: d,
                _2: r,
                _3: c
              };
      }
      if (n < 0) {
        _m = r;
        continue ;
      }
      _c = /* More */{
        _0: v,
        _1: d,
        _2: r,
        _3: c
      };
      _m = m.l;
      continue ;
    };
  };
  const partial_arg = aux(low, m, /* End */0);
  return function (param) {
    return seq_of_enum_(partial_arg, param);
  };
}

const Meths = {
  empty: /* Empty */0,
  add: add$1,
  add_to_list: add_to_list,
  update: update,
  singleton: singleton,
  remove: remove,
  merge: merge$1,
  union: union,
  cardinal: cardinal,
  bindings: bindings,
  min_binding: min_binding,
  min_binding_opt: min_binding_opt,
  max_binding: max_binding,
  max_binding_opt: max_binding_opt,
  choose: min_binding,
  choose_opt: min_binding_opt,
  find: find,
  find_opt: find_opt,
  find_first: find_first,
  find_first_opt: find_first_opt,
  find_last: find_last,
  find_last_opt: find_last_opt,
  iter: iter$1,
  fold: fold,
  map: map,
  mapi: mapi,
  filter: filter,
  filter_map: filter_map,
  partition: partition,
  split: split,
  is_empty: is_empty,
  mem: mem,
  equal: equal$2,
  compare: compare$2,
  for_all: for_all,
  exists: exists,
  to_list: bindings,
  of_list: of_list,
  to_seq: to_seq,
  to_rev_seq: to_rev_seq,
  to_seq_from: to_seq_from,
  add_seq: add_seq,
  of_seq: of_seq
};

function single(param) {
  switch (param) {
    case /* May_pos */0 :
        return 1;
    case /* May_neg */1 :
        return 2;
    case /* May_weak */2 :
        return 4;
    case /* Inj */3 :
        return 8;
    case /* Pos */4 :
        return 16;
    case /* Neg */5 :
        return 32;
    case /* Inv */6 :
        return 64;
    
  }
}

function union$1(v1, v2) {
  return v1 | v2;
}

function inter(v1, v2) {
  return v1 & v2;
}

function subset(v1, v2) {
  return (v1 & v2) === v1;
}

function set(x, b, v) {
  if (b) {
    return v | single(x);
  } else {
    return v & (single(x) ^ -1);
  }
}

function mem$1(x) {
  const partial_arg = single(x);
  return function (param) {
    return subset(partial_arg, param);
  };
}

function swap(f1, f2, v) {
  const v$p = set(f1, mem$1(f2)(v), v);
  return set(f2, mem$1(f1)(v), v$p);
}

function conjugate(v) {
  return swap(/* May_pos */0, /* May_neg */1, swap(/* Pos */4, /* Neg */5, v));
}

function get_upper(v) {
  return [
          mem$1(/* May_pos */0)(v),
          mem$1(/* May_neg */1)(v)
        ];
}

function get_lower(v) {
  return [
          mem$1(/* Pos */4)(v),
          mem$1(/* Neg */5)(v),
          mem$1(/* Inv */6)(v),
          mem$1(/* Inj */3)(v)
        ];
}

function height$1(param) {
  if (param) {
    return param.h;
  } else {
    return 0;
  }
}

function create$2(l, v, r) {
  const hl = l ? l.h : 0;
  const hr = r ? r.h : 0;
  return /* Node */{
          l: l,
          v: v,
          r: r,
          h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        };
}

function bal$1(l, v, r) {
  const hl = l ? l.h : 0;
  const hr = r ? r.h : 0;
  if (hl > (hr + 2 | 0)) {
    if (l) {
      const lr = l.r;
      const lv = l.v;
      const ll = l.l;
      if (height$1(ll) >= height$1(lr)) {
        return create$2(ll, lv, create$2(lr, v, r));
      }
      if (lr) {
        return create$2(create$2(ll, lv, lr.l), lr.v, create$2(lr.r, v, r));
      }
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
                MEL_EXN_ID: "Invalid_argument",
                _1: "Set.bal"
              });
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Set.bal"
            });
  }
  if (hr <= (hl + 2 | 0)) {
    return /* Node */{
            l: l,
            v: v,
            r: r,
            h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          };
  }
  if (r) {
    const rr = r.r;
    const rv = r.v;
    const rl = r.l;
    if (height$1(rr) >= height$1(rl)) {
      return create$2(create$2(l, v, rl), rv, rr);
    }
    if (rl) {
      return create$2(create$2(l, v, rl.l), rl.v, create$2(rl.r, rv, rr));
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Set.bal"
            });
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Set.bal"
          });
}

function add$2(x, t) {
  if (!t) {
    return /* Node */{
            l: /* Empty */0,
            v: x,
            r: /* Empty */0,
            h: 1
          };
  }
  const r = t.r;
  const v = t.v;
  const l = t.l;
  const c = Curry._2(OrderedString.compare, x, v);
  if (c === 0) {
    return t;
  }
  if (c < 0) {
    const ll = add$2(x, l);
    if (l === ll) {
      return t;
    } else {
      return bal$1(ll, v, r);
    }
  }
  const rr = add$2(x, r);
  if (r === rr) {
    return t;
  } else {
    return bal$1(l, v, rr);
  }
}

function singleton$1(x) {
  return /* Node */{
          l: /* Empty */0,
          v: x,
          r: /* Empty */0,
          h: 1
        };
}

function add_min_element(x, param) {
  if (param) {
    return bal$1(add_min_element(x, param.l), param.v, param.r);
  } else {
    return singleton$1(x);
  }
}

function add_max_element(x, param) {
  if (param) {
    return bal$1(param.l, param.v, add_max_element(x, param.r));
  } else {
    return singleton$1(x);
  }
}

function join$1(l, v, r) {
  if (!l) {
    return add_min_element(v, r);
  }
  if (!r) {
    return add_max_element(v, l);
  }
  const rh = r.h;
  const lh = l.h;
  if (lh > (rh + 2 | 0)) {
    return bal$1(l.l, l.v, join$1(l.r, v, r));
  } else if (rh > (lh + 2 | 0)) {
    return bal$1(join$1(l, v, r.l), r.v, r.r);
  } else {
    return create$2(l, v, r);
  }
}

function min_elt(_param) {
  while(true) {
    const param = _param;
    if (param) {
      const l = param.l;
      if (!l) {
        return param.v;
      }
      _param = l;
      continue ;
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
  };
}

function remove_min_elt(param) {
  if (param) {
    const l = param.l;
    if (l) {
      return bal$1(remove_min_elt(l), param.v, param.r);
    } else {
      return param.r;
    }
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Set.remove_min_elt"
          });
}

function concat$1(t1, t2) {
  if (t1) {
    if (t2) {
      return join$1(t1, min_elt(t2), remove_min_elt(t2));
    } else {
      return t1;
    }
  } else {
    return t2;
  }
}

function split$1(x, param) {
  if (!param) {
    return [
            /* Empty */0,
            false,
            /* Empty */0
          ];
  }
  const r = param.r;
  const v = param.v;
  const l = param.l;
  const c = Curry._2(OrderedString.compare, x, v);
  if (c === 0) {
    return [
            l,
            true,
            r
          ];
  }
  if (c < 0) {
    const match = split$1(x, l);
    return [
            match[0],
            match[1],
            join$1(match[2], v, r)
          ];
  }
  const match$1 = split$1(x, r);
  return [
          join$1(l, v, match$1[0]),
          match$1[1],
          match$1[2]
        ];
}

function is_empty$1(param) {
  if (param) {
    return false;
  } else {
    return true;
  }
}

function mem$2(x, _param) {
  while(true) {
    const param = _param;
    if (!param) {
      return false;
    }
    const c = Curry._2(OrderedString.compare, x, param.v);
    if (c === 0) {
      return true;
    }
    _param = c < 0 ? param.l : param.r;
    continue ;
  };
}

function union$2(s1, s2) {
  if (!s1) {
    return s2;
  }
  if (!s2) {
    return s1;
  }
  const h2 = s2.h;
  const v2 = s2.v;
  const h1 = s1.h;
  const v1 = s1.v;
  if (h1 >= h2) {
    if (h2 === 1) {
      return add$2(v2, s1);
    }
    const match = split$1(v1, s2);
    return join$1(union$2(s1.l, match[0]), v1, union$2(s1.r, match[2]));
  }
  if (h1 === 1) {
    return add$2(v1, s2);
  }
  const match$1 = split$1(v2, s1);
  return join$1(union$2(match$1[0], s2.l), v2, union$2(match$1[2], s2.r));
}

function inter$1(s1, s2) {
  if (!s1) {
    return /* Empty */0;
  }
  if (!s2) {
    return /* Empty */0;
  }
  const r1 = s1.r;
  const v1 = s1.v;
  const l1 = s1.l;
  const match = split$1(v1, s2);
  const l2 = match[0];
  if (match[1]) {
    return join$1(inter$1(l1, l2), v1, inter$1(r1, match[2]));
  } else {
    return concat$1(inter$1(l1, l2), inter$1(r1, match[2]));
  }
}

function diff(s1, s2) {
  if (!s1) {
    return /* Empty */0;
  }
  if (!s2) {
    return s1;
  }
  const r1 = s1.r;
  const v1 = s1.v;
  const l1 = s1.l;
  const match = split$1(v1, s2);
  const l2 = match[0];
  if (match[1]) {
    return concat$1(diff(l1, l2), diff(r1, match[2]));
  } else {
    return join$1(diff(l1, l2), v1, diff(r1, match[2]));
  }
}

function cons_enum$1(_s, _e) {
  while(true) {
    const e = _e;
    const s = _s;
    if (!s) {
      return e;
    }
    _e = /* More */{
      _0: s.v,
      _1: s.r,
      _2: e
    };
    _s = s.l;
    continue ;
  };
}

function compare$3(s1, s2) {
  let _e1 = cons_enum$1(s1, /* End */0);
  let _e2 = cons_enum$1(s2, /* End */0);
  while(true) {
    const e2 = _e2;
    const e1 = _e1;
    if (!e1) {
      if (e2) {
        return -1;
      } else {
        return 0;
      }
    }
    if (!e2) {
      return 1;
    }
    const c = Curry._2(OrderedString.compare, e1._0, e2._0);
    if (c !== 0) {
      return c;
    }
    _e2 = cons_enum$1(e2._1, e2._2);
    _e1 = cons_enum$1(e1._1, e1._2);
    continue ;
  };
}

function equal$3(s1, s2) {
  return compare$3(s1, s2) === 0;
}

function fold$1(f, _s, _accu) {
  while(true) {
    const accu = _accu;
    const s = _s;
    if (!s) {
      return accu;
    }
    _accu = Curry._2(f, s.v, fold$1(f, s.l, accu));
    _s = s.r;
    continue ;
  };
}

function elements_aux(_accu, _param) {
  while(true) {
    const param = _param;
    const accu = _accu;
    if (!param) {
      return accu;
    }
    _param = param.l;
    _accu = {
      hd: param.v,
      tl: elements_aux(accu, param.r)
    };
    continue ;
  };
}

function elements(s) {
  return elements_aux(/* [] */0, s);
}

function equal_tag(t1, t2) {
  switch (t1.TAG | 0) {
    case /* Cstr_constant */0 :
        switch (t2.TAG | 0) {
          case /* Cstr_constant */0 :
              return t2._0 === t1._0;
          case /* Cstr_block */1 :
          case /* Cstr_extension */2 :
              return false;
          
        }
    case /* Cstr_block */1 :
        switch (t2.TAG | 0) {
          case /* Cstr_block */1 :
              return t2._0 === t1._0;
          case /* Cstr_constant */0 :
          case /* Cstr_extension */2 :
              return false;
          
        }
    case /* Cstr_extension */2 :
        switch (t2.TAG | 0) {
          case /* Cstr_constant */0 :
          case /* Cstr_block */1 :
              return false;
          case /* Cstr_extension */2 :
              if (same(t1._0, t2._0)) {
                return t1._1 === t2._1;
              } else {
                return false;
              }
          
        }
    
  }
}

const Types_TypeOps = {
  compare: compare,
  equal: equal$1,
  hash: hash
};

const Types_Variance = {
  $$null: 0,
  full: 127,
  covariant: 25,
  may_inv: 7,
  union: union$1,
  inter: inter,
  subset: subset,
  set: set,
  mem: mem$1,
  conjugate: conjugate,
  get_upper: get_upper,
  get_lower: get_lower
};

const funarg = Types_TypeOps;

function height$2(param) {
  if (param) {
    return param.h;
  } else {
    return 0;
  }
}

function create$3(l, v, r) {
  const hl = l ? l.h : 0;
  const hr = r ? r.h : 0;
  return /* Node */{
          l: l,
          v: v,
          r: r,
          h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        };
}

function bal$2(l, v, r) {
  const hl = l ? l.h : 0;
  const hr = r ? r.h : 0;
  if (hl > (hr + 2 | 0)) {
    if (l) {
      const lr = l.r;
      const lv = l.v;
      const ll = l.l;
      if (height$2(ll) >= height$2(lr)) {
        return create$3(ll, lv, create$3(lr, v, r));
      }
      if (lr) {
        return create$3(create$3(ll, lv, lr.l), lr.v, create$3(lr.r, v, r));
      }
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
                MEL_EXN_ID: "Invalid_argument",
                _1: "Set.bal"
              });
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Set.bal"
            });
  }
  if (hr <= (hl + 2 | 0)) {
    return /* Node */{
            l: l,
            v: v,
            r: r,
            h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          };
  }
  if (r) {
    const rr = r.r;
    const rv = r.v;
    const rl = r.l;
    if (height$2(rr) >= height$2(rl)) {
      return create$3(create$3(l, v, rl), rv, rr);
    }
    if (rl) {
      return create$3(create$3(l, v, rl.l), rl.v, create$3(rl.r, rv, rr));
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Set.bal"
            });
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Set.bal"
          });
}

function add$3(x, t) {
  if (!t) {
    return /* Node */{
            l: /* Empty */0,
            v: x,
            r: /* Empty */0,
            h: 1
          };
  }
  const r = t.r;
  const v = t.v;
  const l = t.l;
  const c = Curry._2(funarg.compare, x, v);
  if (c === 0) {
    return t;
  }
  if (c < 0) {
    const ll = add$3(x, l);
    if (l === ll) {
      return t;
    } else {
      return bal$2(ll, v, r);
    }
  }
  const rr = add$3(x, r);
  if (r === rr) {
    return t;
  } else {
    return bal$2(l, v, rr);
  }
}

function singleton$2(x) {
  return /* Node */{
          l: /* Empty */0,
          v: x,
          r: /* Empty */0,
          h: 1
        };
}

function add_min_element$1(x, param) {
  if (param) {
    return bal$2(add_min_element$1(x, param.l), param.v, param.r);
  } else {
    return singleton$2(x);
  }
}

function add_max_element$1(x, param) {
  if (param) {
    return bal$2(param.l, param.v, add_max_element$1(x, param.r));
  } else {
    return singleton$2(x);
  }
}

function join$2(l, v, r) {
  if (!l) {
    return add_min_element$1(v, r);
  }
  if (!r) {
    return add_max_element$1(v, l);
  }
  const rh = r.h;
  const lh = l.h;
  if (lh > (rh + 2 | 0)) {
    return bal$2(l.l, l.v, join$2(l.r, v, r));
  } else if (rh > (lh + 2 | 0)) {
    return bal$2(join$2(l, v, r.l), r.v, r.r);
  } else {
    return create$3(l, v, r);
  }
}

function min_elt$1(_param) {
  while(true) {
    const param = _param;
    if (param) {
      const l = param.l;
      if (!l) {
        return param.v;
      }
      _param = l;
      continue ;
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
  };
}

function remove_min_elt$1(param) {
  if (param) {
    const l = param.l;
    if (l) {
      return bal$2(remove_min_elt$1(l), param.v, param.r);
    } else {
      return param.r;
    }
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Set.remove_min_elt"
          });
}

function concat$2(t1, t2) {
  if (t1) {
    if (t2) {
      return join$2(t1, min_elt$1(t2), remove_min_elt$1(t2));
    } else {
      return t1;
    }
  } else {
    return t2;
  }
}

function split$2(x, param) {
  if (!param) {
    return [
            /* Empty */0,
            false,
            /* Empty */0
          ];
  }
  const r = param.r;
  const v = param.v;
  const l = param.l;
  const c = Curry._2(funarg.compare, x, v);
  if (c === 0) {
    return [
            l,
            true,
            r
          ];
  }
  if (c < 0) {
    const match = split$2(x, l);
    return [
            match[0],
            match[1],
            join$2(match[2], v, r)
          ];
  }
  const match$1 = split$2(x, r);
  return [
          join$2(l, v, match$1[0]),
          match$1[1],
          match$1[2]
        ];
}

function is_empty$2(param) {
  if (param) {
    return false;
  } else {
    return true;
  }
}

function mem$3(x, _param) {
  while(true) {
    const param = _param;
    if (!param) {
      return false;
    }
    const c = Curry._2(funarg.compare, x, param.v);
    if (c === 0) {
      return true;
    }
    _param = c < 0 ? param.l : param.r;
    continue ;
  };
}

function union$3(s1, s2) {
  if (!s1) {
    return s2;
  }
  if (!s2) {
    return s1;
  }
  const h2 = s2.h;
  const v2 = s2.v;
  const h1 = s1.h;
  const v1 = s1.v;
  if (h1 >= h2) {
    if (h2 === 1) {
      return add$3(v2, s1);
    }
    const match = split$2(v1, s2);
    return join$2(union$3(s1.l, match[0]), v1, union$3(s1.r, match[2]));
  }
  if (h1 === 1) {
    return add$3(v1, s2);
  }
  const match$1 = split$2(v2, s1);
  return join$2(union$3(match$1[0], s2.l), v2, union$3(match$1[2], s2.r));
}

function inter$2(s1, s2) {
  if (!s1) {
    return /* Empty */0;
  }
  if (!s2) {
    return /* Empty */0;
  }
  const r1 = s1.r;
  const v1 = s1.v;
  const l1 = s1.l;
  const match = split$2(v1, s2);
  const l2 = match[0];
  if (match[1]) {
    return join$2(inter$2(l1, l2), v1, inter$2(r1, match[2]));
  } else {
    return concat$2(inter$2(l1, l2), inter$2(r1, match[2]));
  }
}

function diff$1(s1, s2) {
  if (!s1) {
    return /* Empty */0;
  }
  if (!s2) {
    return s1;
  }
  const r1 = s1.r;
  const v1 = s1.v;
  const l1 = s1.l;
  const match = split$2(v1, s2);
  const l2 = match[0];
  if (match[1]) {
    return concat$2(diff$1(l1, l2), diff$1(r1, match[2]));
  } else {
    return join$2(diff$1(l1, l2), v1, diff$1(r1, match[2]));
  }
}

function subset$1(_s1, _s2) {
  while(true) {
    const s2 = _s2;
    const s1 = _s1;
    if (!s1) {
      return true;
    }
    if (!s2) {
      return false;
    }
    const r2 = s2.r;
    const l2 = s2.l;
    const r1 = s1.r;
    const v1 = s1.v;
    const l1 = s1.l;
    const c = Curry._2(funarg.compare, v1, s2.v);
    if (c === 0) {
      if (!subset$1(l1, l2)) {
        return false;
      }
      _s2 = r2;
      _s1 = r1;
      continue ;
    }
    if (c < 0) {
      if (!subset$1(/* Node */{
              l: l1,
              v: v1,
              r: /* Empty */0,
              h: 0
            }, l2)) {
        return false;
      }
      _s1 = r1;
      continue ;
    }
    if (!subset$1(/* Node */{
            l: /* Empty */0,
            v: v1,
            r: r1,
            h: 0
          }, r2)) {
      return false;
    }
    _s1 = l1;
    continue ;
  };
}

function fold$2(f, _s, _accu) {
  while(true) {
    const accu = _accu;
    const s = _s;
    if (!s) {
      return accu;
    }
    _accu = Curry._2(f, s.v, fold$2(f, s.l, accu));
    _s = s.r;
    continue ;
  };
}

function exists$1(p, _param) {
  while(true) {
    const param = _param;
    if (!param) {
      return false;
    }
    if (Curry._1(p, param.v)) {
      return true;
    }
    if (exists$1(p, param.l)) {
      return true;
    }
    _param = param.r;
    continue ;
  };
}

function elements_aux$1(_accu, _param) {
  while(true) {
    const param = _param;
    const accu = _accu;
    if (!param) {
      return accu;
    }
    _param = param.l;
    _accu = {
      hd: param.v,
      tl: elements_aux$1(accu, param.r)
    };
    continue ;
  };
}

function elements$1(s) {
  return elements_aux$1(/* [] */0, s);
}

const funarg$1 = Types_TypeOps;

function height$3(param) {
  if (param) {
    return param.h;
  } else {
    return 0;
  }
}

function create$4(l, x, d, r) {
  const hl = height$3(l);
  const hr = height$3(r);
  return /* Node */{
          l: l,
          v: x,
          d: d,
          r: r,
          h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        };
}

function bal$3(l, x, d, r) {
  const hl = l ? l.h : 0;
  const hr = r ? r.h : 0;
  if (hl > (hr + 2 | 0)) {
    if (l) {
      const lr = l.r;
      const ld = l.d;
      const lv = l.v;
      const ll = l.l;
      if (height$3(ll) >= height$3(lr)) {
        return create$4(ll, lv, ld, create$4(lr, x, d, r));
      }
      if (lr) {
        return create$4(create$4(ll, lv, ld, lr.l), lr.v, lr.d, create$4(lr.r, x, d, r));
      }
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
                MEL_EXN_ID: "Invalid_argument",
                _1: "Map.bal"
              });
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Map.bal"
            });
  }
  if (hr <= (hl + 2 | 0)) {
    return /* Node */{
            l: l,
            v: x,
            d: d,
            r: r,
            h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          };
  }
  if (r) {
    const rr = r.r;
    const rd = r.d;
    const rv = r.v;
    const rl = r.l;
    if (height$3(rr) >= height$3(rl)) {
      return create$4(create$4(l, x, d, rl), rv, rd, rr);
    }
    if (rl) {
      return create$4(create$4(l, x, d, rl.l), rl.v, rl.d, create$4(rl.r, rv, rd, rr));
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Map.bal"
            });
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Map.bal"
          });
}

function add$4(x, data, m) {
  if (!m) {
    return /* Node */{
            l: /* Empty */0,
            v: x,
            d: data,
            r: /* Empty */0,
            h: 1
          };
  }
  const r = m.r;
  const d = m.d;
  const v = m.v;
  const l = m.l;
  const c = Curry._2(funarg$1.compare, x, v);
  if (c === 0) {
    if (d === data) {
      return m;
    } else {
      return /* Node */{
              l: l,
              v: x,
              d: data,
              r: r,
              h: m.h
            };
    }
  }
  if (c < 0) {
    const ll = add$4(x, data, l);
    if (l === ll) {
      return m;
    } else {
      return bal$3(ll, v, d, r);
    }
  }
  const rr = add$4(x, data, r);
  if (r === rr) {
    return m;
  } else {
    return bal$3(l, v, d, rr);
  }
}

function find$1(x, _param) {
  while(true) {
    const param = _param;
    if (param) {
      const c = Curry._2(funarg$1.compare, x, param.v);
      if (c === 0) {
        return param.d;
      }
      _param = c < 0 ? param.l : param.r;
      continue ;
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
  };
}

function fold$3(f, _m, _accu) {
  while(true) {
    const accu = _accu;
    const m = _m;
    if (!m) {
      return accu;
    }
    _accu = Curry._3(f, m.v, m.d, fold$3(f, m.l, accu));
    _m = m.r;
    continue ;
  };
}

const $$let = Types_TypeOps;

const TypeHash = Stdlib__Hashtbl.Make({
      equal: $$let.equal,
      hash: $$let.hash
    });

function print_raw(param) {
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              4836,
              16
            ]
          });
}

const pivot_level = -1;

const new_id = {
  contents: -1
};

function newty2(level, desc) {
  new_id.contents = new_id.contents + 1 | 0;
  return {
          desc: desc,
          level: level,
          id: new_id.contents
        };
}

function is_Tvar(param) {
  const match = param.desc;
  if (typeof match === "number" || match.TAG !== /* Tvar */0) {
    return false;
  } else {
    return true;
  }
}

function is_Tunivar(param) {
  const match = param.desc;
  if (typeof match === "number" || match.TAG !== /* Tunivar */9) {
    return false;
  } else {
    return true;
  }
}

const dummy_method = "*dummy method*";

function field_kind_repr(_kind) {
  while(true) {
    const kind = _kind;
    if (typeof kind === "number") {
      return kind;
    }
    const kind$1 = kind._0.contents;
    if (kind$1 === undefined) {
      return kind;
    }
    _kind = kind$1;
    continue ;
  };
}

function repr(_t) {
  while(true) {
    const t = _t;
    const t$p = t.desc;
    if (typeof t$p === "number") {
      return t;
    }
    switch (t$p.TAG | 0) {
      case /* Tfield */5 :
          if (!Caml_obj.caml_equal(field_kind_repr(t$p._1), /* Fabsent */1)) {
            return t;
          }
          _t = t$p._3;
          continue ;
      case /* Tlink */6 :
          _t = t$p._0;
          continue ;
      default:
        return t;
    }
  };
}

function commu_repr(_r) {
  while(true) {
    const r = _r;
    if (typeof r === "number") {
      return r;
    }
    const r$1 = r._0;
    if (!Caml_obj.caml_notequal(r$1.contents, /* Cunknown */1)) {
      return r;
    }
    _r = r$1.contents;
    continue ;
  };
}

function row_field_repr_aux(_tl, _fi) {
  while(true) {
    const fi = _fi;
    const tl = _tl;
    if (typeof fi === "number") {
      return fi;
    }
    if (fi.TAG === /* Rpresent */0) {
      if (fi._0 !== undefined && Caml_obj.caml_notequal(tl, /* [] */0)) {
        return {
                TAG: /* Rpresent */0,
                _0: Stdlib__List.hd(tl)
              };
      } else {
        return fi;
      }
    }
    const fi$1 = fi._3.contents;
    if (fi$1 === undefined) {
      return {
              TAG: /* Reither */1,
              _0: fi._0,
              _1: Stdlib.$at(tl, fi._1),
              _2: fi._2,
              _3: fi._3
            };
    }
    _fi = fi$1;
    _tl = Stdlib.$at(tl, fi._1);
    continue ;
  };
}

function rev_concat(_l, _ll) {
  while(true) {
    const ll = _ll;
    const l = _l;
    if (!ll) {
      return l;
    }
    _ll = ll.tl;
    _l = Stdlib.$at(ll.hd, l);
    continue ;
  };
}

function row_repr_aux(_ll, _row) {
  while(true) {
    const row = _row;
    const ll = _ll;
    const row$p = repr(row.row_more).desc;
    if (typeof row$p !== "number" && row$p.TAG === /* Tvariant */8) {
      const f = row.row_fields;
      _row = row$p._0;
      _ll = Caml_obj.caml_equal(f, /* [] */0) ? ll : ({
            hd: f,
            tl: ll
          });
      continue ;
    }
    if (Caml_obj.caml_equal(ll, /* [] */0)) {
      return row;
    } else {
      return {
              row_fields: rev_concat(row.row_fields, ll),
              row_more: row.row_more,
              row_bound: row.row_bound,
              row_closed: row.row_closed,
              row_fixed: row.row_fixed,
              row_name: row.row_name
            };
    }
  };
}

function row_field(tag, row) {
  let _param = row.row_fields;
  while(true) {
    const param = _param;
    if (param) {
      const match = param.hd;
      if (tag === match[0]) {
        return row_field_repr_aux(/* [] */0, match[1]);
      }
      _param = param.tl;
      continue ;
    }
    const match$1 = repr(row.row_more);
    const row$p = match$1.desc;
    if (typeof row$p === "number" || row$p.TAG !== /* Tvariant */8) {
      return /* Rabsent */0;
    } else {
      return row_field(tag, row$p._0);
    }
  };
}

function row_more(_row) {
  while(true) {
    const row = _row;
    const ty = repr(row.row_more);
    const row$p = ty.desc;
    if (typeof row$p === "number") {
      return ty;
    }
    if (row$p.TAG !== /* Tvariant */8) {
      return ty;
    }
    _row = row$p._0;
    continue ;
  };
}

function row_fixed(row) {
  const row$1 = row_repr_aux(/* [] */0, row);
  if (row$1.row_fixed) {
    return true;
  }
  const match = repr(row$1.row_more).desc;
  if (typeof match === "number") {
    return false;
  }
  switch (match.TAG | 0) {
    case /* Tvar */0 :
        return false;
    case /* Tconstr */3 :
    case /* Tunivar */9 :
        return true;
    default:
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  4946,
                  9
                ]
              });
  }
}

function static_row(row) {
  const row$1 = row_repr_aux(/* [] */0, row);
  if (row$1.row_closed) {
    return Stdlib__List.for_all((function (param) {
                  const match = row_field_repr_aux(/* [] */0, param[1]);
                  if (typeof match === "number" || match.TAG === /* Rpresent */0) {
                    return true;
                  } else {
                    return false;
                  }
                }), row$1.row_fields);
  } else {
    return false;
  }
}

function hash_variant(s) {
  let accu = 0;
  for(let i = 0 ,i_finish = s.length; i < i_finish; ++i){
    accu = Math.imul(223, accu) + Caml_string.get(s, i) | 0;
  }
  accu = accu & 2147483647;
  if (accu > 1073741823) {
    return accu - -2147483648 | 0;
  } else {
    return accu;
  }
}

function proxy(ty) {
  const ty0 = repr(ty);
  const row = ty0.desc;
  if (typeof row === "number") {
    return ty0;
  }
  switch (row.TAG | 0) {
    case /* Tobject */4 :
        let _ty = row._0;
        while(true) {
          const ty$1 = _ty;
          const match = ty$1.desc;
          if (typeof match === "number") {
            return ty0;
          }
          switch (match.TAG | 0) {
            case /* Tfield */5 :
                _ty = match._3;
                continue ;
            case /* Tlink */6 :
                _ty = match._0;
                continue ;
            case /* Tvar */0 :
            case /* Tconstr */3 :
            case /* Tunivar */9 :
                return ty$1;
            default:
              throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                        MEL_EXN_ID: "Assert_failure",
                        _1: [
                          "jscomp/test/ocaml_typedtree_test.ml",
                          4976,
                          15
                        ]
                      });
          }
        };
    case /* Tvariant */8 :
        const row$1 = row._0;
        if (static_row(row$1)) {
          return ty0;
        } else {
          return row_more(row$1);
        }
    default:
      return ty0;
  }
}

function has_constr_row(t) {
  const row = repr(t).desc;
  if (typeof row === "number") {
    return false;
  }
  switch (row.TAG | 0) {
    case /* Tobject */4 :
        let _t = row._0;
        while(true) {
          const t$1 = _t;
          const match = repr(t$1).desc;
          if (typeof match === "number") {
            return false;
          }
          switch (match.TAG | 0) {
            case /* Tconstr */3 :
                return true;
            case /* Tfield */5 :
                _t = match._3;
                continue ;
            default:
              return false;
          }
        };
    case /* Tvariant */8 :
        const match$1 = row_more(row._0);
        const match$2 = match$1.desc;
        if (typeof match$2 === "number" || match$2.TAG !== /* Tconstr */3) {
          return false;
        } else {
          return true;
        }
    default:
      return false;
  }
}

function is_row_name(s) {
  const l = s.length;
  if (l < 4) {
    return false;
  } else {
    return Stdlib__String.sub(s, l - 4 | 0, 4) === "#row";
  }
}

function is_constr_row(t) {
  const match = t.desc;
  if (typeof match === "number") {
    return false;
  }
  if (match.TAG !== /* Tconstr */3) {
    return false;
  }
  const id = match._0;
  switch (id.TAG | 0) {
    case /* Pident */0 :
        return is_row_name(id._0.name);
    case /* Pdot */1 :
        return is_row_name(id._1);
    case /* Papply */2 :
        return false;
    
  }
}

function iter_row(f, _row) {
  while(true) {
    const row = _row;
    Stdlib__List.iter((function (param) {
            const match = row_field_repr_aux(/* [] */0, param[1]);
            if (typeof match === "number") {
              return ;
            }
            if (match.TAG !== /* Rpresent */0) {
              return Stdlib__List.iter(f, match._1);
            }
            const ty = match._0;
            if (ty !== undefined) {
              return Curry._1(f, ty);
            }
            
          }), row.row_fields);
    const row$1 = repr(row.row_more).desc;
    if (typeof row$1 !== "number") {
      switch (row$1.TAG | 0) {
        case /* Tvariant */8 :
            _row = row$1._0;
            continue ;
        case /* Tvar */0 :
        case /* Tconstr */3 :
        case /* Tsubst */7 :
        case /* Tunivar */9 :
            break;
        default:
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                    MEL_EXN_ID: "Assert_failure",
                    _1: [
                      "jscomp/test/ocaml_typedtree_test.ml",
                      5023,
                      9
                    ]
                  });
      }
    }
    return may((function (param) {
                  Stdlib__List.iter(f, param[1]);
                }), row.row_name);
  };
}

function iter_type_expr(f, ty) {
  const l = ty.desc;
  if (typeof l === "number") {
    return ;
  }
  switch (l.TAG | 0) {
    case /* Tarrow */1 :
        Curry._1(f, l._1);
        return Curry._1(f, l._2);
    case /* Ttuple */2 :
        return Stdlib__List.iter(f, l._0);
    case /* Tconstr */3 :
        return Stdlib__List.iter(f, l._1);
    case /* Tobject */4 :
        const ty$1 = l._0;
        const match = l._1.contents;
        if (match !== undefined) {
          Curry._1(f, ty$1);
          return Stdlib__List.iter(f, match[1]);
        } else {
          return Curry._1(f, ty$1);
        }
    case /* Tfield */5 :
        Curry._1(f, l._2);
        return Curry._1(f, l._3);
    case /* Tlink */6 :
    case /* Tsubst */7 :
        return Curry._1(f, l._0);
    case /* Tvariant */8 :
        const row = l._0;
        iter_row(f, row);
        return Curry._1(f, row_more(row));
    case /* Tpoly */10 :
        Curry._1(f, l._0);
        return Stdlib__List.iter(f, l._1);
    case /* Tpackage */11 :
        return Stdlib__List.iter(f, l._2);
    default:
      return ;
  }
}

function iter_abbrev(f, _rem) {
  while(true) {
    const rem = _rem;
    if (typeof rem === "number") {
      return ;
    }
    if (rem.TAG === /* Mcons */0) {
      Curry._1(f, rem._2);
      Curry._1(f, rem._3);
      _rem = rem._4;
      continue ;
    }
    _rem = rem._0.contents;
    continue ;
  };
}

function it_signature(it) {
  const partial_arg = Curry._1(it.it_signature_item, it);
  return function (param) {
    return Stdlib__List.iter(partial_arg, param);
  };
}

function it_signature_item(it, param) {
  switch (param.TAG | 0) {
    case /* Sig_value */0 :
        return Curry._2(it.it_value_description, it, param._1);
    case /* Sig_type */1 :
        return Curry._2(it.it_type_declaration, it, param._1);
    case /* Sig_typext */2 :
        return Curry._2(it.it_extension_constructor, it, param._1);
    case /* Sig_module */3 :
        return Curry._2(it.it_module_declaration, it, param._1);
    case /* Sig_modtype */4 :
        return Curry._2(it.it_modtype_declaration, it, param._1);
    case /* Sig_class */5 :
        return Curry._2(it.it_class_declaration, it, param._1);
    case /* Sig_class_type */6 :
        return Curry._2(it.it_class_type_declaration, it, param._1);
    
  }
}

function it_value_description(it, vd) {
  Curry._2(it.it_type_expr, it, vd.val_type);
}

function it_type_declaration(it, td) {
  Stdlib__List.iter(Curry._1(it.it_type_expr, it), td.type_params);
  may(Curry._1(it.it_type_expr, it), td.type_manifest);
  Curry._2(it.it_type_kind, it, td.type_kind);
}

function it_extension_constructor(it, td) {
  Curry._1(it.it_path, td.ext_type_path);
  Stdlib__List.iter(Curry._1(it.it_type_expr, it), td.ext_type_params);
  Stdlib__List.iter(Curry._1(it.it_type_expr, it), td.ext_args);
  may(Curry._1(it.it_type_expr, it), td.ext_ret_type);
}

function it_module_declaration(it, md) {
  Curry._2(it.it_module_type, it, md.md_type);
}

function it_modtype_declaration(it, mtd) {
  may(Curry._1(it.it_module_type, it), mtd.mtd_type);
}

function it_class_declaration(it, cd) {
  Stdlib__List.iter(Curry._1(it.it_type_expr, it), cd.cty_params);
  Curry._2(it.it_class_type, it, cd.cty_type);
  may(Curry._1(it.it_type_expr, it), cd.cty_new);
  Curry._1(it.it_path, cd.cty_path);
}

function it_class_type_declaration(it, ctd) {
  Stdlib__List.iter(Curry._1(it.it_type_expr, it), ctd.clty_params);
  Curry._2(it.it_class_type, it, ctd.clty_type);
  Curry._1(it.it_path, ctd.clty_path);
}

function it_module_type(it, sg) {
  switch (sg.TAG | 0) {
    case /* Mty_signature */1 :
        return Curry._2(it.it_signature, it, sg._0);
    case /* Mty_functor */2 :
        may(Curry._1(it.it_module_type, it), sg._1);
        return Curry._2(it.it_module_type, it, sg._2);
    case /* Mty_ident */0 :
    case /* Mty_alias */3 :
        return Curry._1(it.it_path, sg._0);
    
  }
}

function it_class_type(it, cs) {
  switch (cs.TAG | 0) {
    case /* Cty_constr */0 :
        Curry._1(it.it_path, cs._0);
        Stdlib__List.iter(Curry._1(it.it_type_expr, it), cs._1);
        return Curry._2(it.it_class_type, it, cs._2);
    case /* Cty_signature */1 :
        const cs$1 = cs._0;
        Curry._2(it.it_type_expr, it, cs$1.csig_self);
        Curry._2(Meths.iter, (function (param, param$1) {
                Curry._2(it.it_type_expr, it, param$1[2]);
              }), cs$1.csig_vars);
        return Stdlib__List.iter((function (param) {
                      Curry._1(it.it_path, param[0]);
                      Stdlib__List.iter(Curry._1(it.it_type_expr, it), param[1]);
                    }), cs$1.csig_inher);
    case /* Cty_arrow */2 :
        Curry._2(it.it_type_expr, it, cs._1);
        return Curry._2(it.it_class_type, it, cs._2);
    
  }
}

function it_type_kind(it, cl) {
  if (typeof cl === "number") {
    return ;
  } else if (cl.TAG === /* Type_record */0) {
    return Stdlib__List.iter((function (ld) {
                  Curry._2(it.it_type_expr, it, ld.ld_type);
                }), cl._0);
  } else {
    return Stdlib__List.iter((function (cd) {
                  Stdlib__List.iter(Curry._1(it.it_type_expr, it), cd.cd_args);
                  may(Curry._1(it.it_type_expr, it), cd.cd_res);
                }), cl._0);
  }
}

function it_do_type_expr(it, ty) {
  iter_type_expr(Curry._1(it.it_type_expr, it), ty);
  const row = ty.desc;
  if (typeof row === "number") {
    return ;
  }
  switch (row.TAG | 0) {
    case /* Tobject */4 :
        const match = row._1.contents;
        if (match !== undefined) {
          return Curry._1(it.it_path, match[0]);
        } else {
          return ;
        }
    case /* Tvariant */8 :
        return may((function (param) {
                      Curry._1(it.it_path, param[0]);
                    }), row_repr_aux(/* [] */0, row._0).row_name);
    case /* Tconstr */3 :
    case /* Tpackage */11 :
        return Curry._1(it.it_path, row._0);
    default:
      return ;
  }
}

function it_path(p) {
  
}

function copy_row(f, fixed, row, keep, more) {
  const fields = Stdlib__List.map((function (param) {
          const fi = param[1];
          const match = row_field_repr_aux(/* [] */0, fi);
          let tmp;
          if (typeof match === "number") {
            tmp = fi;
          } else if (match.TAG === /* Rpresent */0) {
            const ty = match._0;
            tmp = ty !== undefined ? ({
                  TAG: /* Rpresent */0,
                  _0: Curry._1(f, ty)
                }) : fi;
          } else {
            const e = keep ? match._3 : ({
                  contents: undefined
                });
            const m = row.row_fixed ? fixed : match._2;
            const tl = Stdlib__List.map(f, match._1);
            tmp = {
              TAG: /* Reither */1,
              _0: match._0,
              _1: tl,
              _2: m,
              _3: e
            };
          }
          return [
                  param[0],
                  tmp
                ];
        }), row.row_fields);
  const match = row.row_name;
  const name = match !== undefined ? [
      match[0],
      Stdlib__List.map(f, match[1])
    ] : undefined;
  return {
          row_fields: fields,
          row_more: more,
          row_bound: undefined,
          row_closed: row.row_closed,
          row_fixed: row.row_fixed && fixed,
          row_name: name
        };
}

function copy_kind(_param) {
  while(true) {
    const param = _param;
    if (typeof param === "number") {
      if (!param) {
        return /* Fpresent */0;
      }
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  5172,
                  16
                ]
              });
    }
    const k = param._0.contents;
    if (k === undefined) {
      return /* Fvar */{
              _0: {
                contents: undefined
              }
            };
    }
    _param = k;
    continue ;
  };
}

function copy_commu(c) {
  if (Caml_obj.caml_equal(commu_repr(c), /* Cok */0)) {
    return /* Cok */0;
  } else {
    return /* Clink */{
            _0: {
              contents: /* Cunknown */1
            }
          };
  }
}

function copy_type_desc(_keep_namesOpt, f, _ty) {
  while(true) {
    const keep_namesOpt = _keep_namesOpt;
    const ty = _ty;
    const keep_names = keep_namesOpt !== undefined ? keep_namesOpt : false;
    if (typeof ty === "number") {
      return /* Tnil */0;
    }
    switch (ty.TAG | 0) {
      case /* Tvar */0 :
          if (keep_names) {
            return ty;
          } else {
            return {
                    TAG: /* Tvar */0,
                    _0: undefined
                  };
          }
      case /* Tarrow */1 :
          return {
                  TAG: /* Tarrow */1,
                  _0: ty._0,
                  _1: Curry._1(f, ty._1),
                  _2: Curry._1(f, ty._2),
                  _3: copy_commu(ty._3)
                };
      case /* Ttuple */2 :
          return {
                  TAG: /* Ttuple */2,
                  _0: Stdlib__List.map(f, ty._0)
                };
      case /* Tconstr */3 :
          return {
                  TAG: /* Tconstr */3,
                  _0: ty._0,
                  _1: Stdlib__List.map(f, ty._1),
                  _2: {
                    contents: /* Mnil */0
                  }
                };
      case /* Tobject */4 :
          const ty$1 = ty._0;
          const match = ty._1.contents;
          if (match !== undefined) {
            return {
                    TAG: /* Tobject */4,
                    _0: Curry._1(f, ty$1),
                    _1: {
                      contents: [
                        match[0],
                        Stdlib__List.map(f, match[1])
                      ]
                    }
                  };
          } else {
            return {
                    TAG: /* Tobject */4,
                    _0: Curry._1(f, ty$1),
                    _1: {
                      contents: undefined
                    }
                  };
          }
      case /* Tfield */5 :
          return {
                  TAG: /* Tfield */5,
                  _0: ty._0,
                  _1: field_kind_repr(ty._1),
                  _2: Curry._1(f, ty._2),
                  _3: Curry._1(f, ty._3)
                };
      case /* Tlink */6 :
          _ty = ty._0.desc;
          _keep_namesOpt = undefined;
          continue ;
      case /* Tsubst */7 :
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                    MEL_EXN_ID: "Assert_failure",
                    _1: [
                      "jscomp/test/ocaml_typedtree_test.ml",
                      5199,
                      27
                    ]
                  });
      case /* Tvariant */8 :
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                    MEL_EXN_ID: "Assert_failure",
                    _1: [
                      "jscomp/test/ocaml_typedtree_test.ml",
                      5194,
                      27
                    ]
                  });
      case /* Tunivar */9 :
          return ty;
      case /* Tpoly */10 :
          const tyl = Stdlib__List.map((function (x) {
                  let _ty = Curry._1(f, x);
                  while(true) {
                    const ty = _ty;
                    const ty$1 = ty.desc;
                    if (typeof ty$1 !== "number") {
                      switch (ty$1.TAG | 0) {
                        case /* Ttuple */2 :
                            const match = ty$1._0;
                            if (match) {
                              _ty = match.hd;
                              continue ;
                            }
                            break;
                        case /* Tlink */6 :
                            _ty = ty$1._0;
                            continue ;
                        case /* Tsubst */7 :
                        case /* Tunivar */9 :
                            return ty;
                        default:
                          
                      }
                    }
                    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                              MEL_EXN_ID: "Assert_failure",
                              _1: [
                                "jscomp/test/ocaml_typedtree_test.ml",
                                5184,
                                26
                              ]
                            });
                  };
                }), ty._1);
          return {
                  TAG: /* Tpoly */10,
                  _0: Curry._1(f, ty._0),
                  _1: tyl
                };
      case /* Tpackage */11 :
          return {
                  TAG: /* Tpackage */11,
                  _0: ty._0,
                  _1: ty._1,
                  _2: Stdlib__List.map(f, ty._2)
                };
      
    }
  };
}

const saved_desc = {
  contents: /* [] */0
};

function save_desc(ty, desc) {
  saved_desc.contents = {
    hd: [
      ty,
      desc
    ],
    tl: saved_desc.contents
  };
}

const saved_kinds = {
  contents: /* [] */0
};

const new_kinds = {
  contents: /* [] */0
};

function dup_kind(r) {
  const match = r.contents;
  if (match !== undefined) {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                5217,
                40
              ]
            });
  }
  if (Stdlib__List.memq(r, new_kinds.contents)) {
    return ;
  }
  saved_kinds.contents = {
    hd: r,
    tl: saved_kinds.contents
  };
  const r$p = {
    contents: undefined
  };
  new_kinds.contents = {
    hd: r$p,
    tl: new_kinds.contents
  };
  r.contents = /* Fvar */{
    _0: r$p
  };
}

function cleanup_types(param) {
  Stdlib__List.iter((function (param) {
          param[0].desc = param[1];
        }), saved_desc.contents);
  Stdlib__List.iter((function (r) {
          r.contents = undefined;
        }), saved_kinds.contents);
  saved_desc.contents = /* [] */0;
  saved_kinds.contents = /* [] */0;
  new_kinds.contents = /* [] */0;
}

function mark_type(ty) {
  const ty$1 = repr(ty);
  if (ty$1.level >= 0) {
    ty$1.level = pivot_level - ty$1.level | 0;
    return iter_type_expr(mark_type, ty$1);
  }
  
}

function mark_type_node(ty) {
  const ty$1 = repr(ty);
  if (ty$1.level >= 0) {
    ty$1.level = pivot_level - ty$1.level | 0;
    return ;
  }
  
}

function it_type_expr(it, ty) {
  const ty$1 = repr(ty);
  if (ty$1.level >= 0) {
    mark_type_node(ty$1);
    return Curry._2(it.it_do_type_expr, it, ty$1);
  }
  
}

function unmark_type(ty) {
  const ty$1 = repr(ty);
  if (ty$1.level < 0) {
    ty$1.level = pivot_level - ty$1.level | 0;
    return iter_type_expr(unmark_type, ty$1);
  }
  
}

function it_type_expr$1(it, ty) {
  unmark_type(ty);
}

const unmark_iterators = {
  it_signature: it_signature,
  it_signature_item: it_signature_item,
  it_value_description: it_value_description,
  it_type_declaration: it_type_declaration,
  it_extension_constructor: it_extension_constructor,
  it_module_declaration: it_module_declaration,
  it_modtype_declaration: it_modtype_declaration,
  it_class_declaration: it_class_declaration,
  it_class_type_declaration: it_class_type_declaration,
  it_module_type: it_module_type,
  it_class_type: it_class_type,
  it_type_kind: it_type_kind,
  it_do_type_expr: it_do_type_expr,
  it_type_expr: it_type_expr$1,
  it_path: it_path
};

function unmark_extension_constructor(ext) {
  Stdlib__List.iter(unmark_type, ext.ext_type_params);
  Stdlib__List.iter(unmark_type, ext.ext_args);
  may(unmark_type, ext.ext_ret_type);
}

function unmark_class_signature(sign) {
  unmark_type(sign.csig_self);
  Curry._2(Meths.iter, (function (l, param) {
          unmark_type(param[2]);
        }), sign.csig_vars);
}

function find_expans(priv, p1, _param) {
  while(true) {
    const param = _param;
    if (typeof param === "number") {
      return ;
    }
    if (param.TAG === /* Mcons */0) {
      if (param._0 >= priv && same(p1, param._1)) {
        return param._3;
      }
      _param = param._4;
      continue ;
    }
    const rem = param._0.contents;
    _param = rem;
    continue ;
  };
}

const memo = {
  contents: /* [] */0
};

function cleanup_abbrev(param) {
  Stdlib__List.iter((function (abbr) {
          abbr.contents = /* Mnil */0;
        }), memo.contents);
  memo.contents = /* [] */0;
}

function memorize_abbrev(mem, priv, path, v, v$p) {
  mem.contents = {
    TAG: /* Mcons */0,
    _0: priv,
    _1: path,
    _2: v,
    _3: v$p,
    _4: mem.contents
  };
  memo.contents = {
    hd: mem,
    tl: memo.contents
  };
}

function forget_abbrev_rec(mem, path) {
  if (typeof mem === "number") {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                5329,
                6
              ]
            });
  }
  if (mem.TAG === /* Mcons */0) {
    if (same(path, mem._1)) {
      return mem._4;
    } else {
      return {
              TAG: /* Mcons */0,
              _0: mem._0,
              _1: mem._1,
              _2: mem._2,
              _3: mem._3,
              _4: forget_abbrev_rec(mem._4, path)
            };
    }
  }
  const mem$p = mem._0;
  mem$p.contents = forget_abbrev_rec(mem$p.contents, path);
  throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
            MEL_EXN_ID: Stdlib.Exit
          });
}

function forget_abbrev(mem, path) {
  try {
    mem.contents = forget_abbrev_rec(mem.contents, path);
    return ;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Exit) {
      return ;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function is_optional(l) {
  if (l.length !== 0) {
    return Caml_string.get(l, 0) === /* '?' */63;
  } else {
    return false;
  }
}

function label_name(l) {
  if (is_optional(l)) {
    return Stdlib__String.sub(l, 1, l.length - 1 | 0);
  } else {
    return l;
  }
}

function prefixed_label_name(l) {
  if (is_optional(l)) {
    return l;
  } else {
    return "~" + l;
  }
}

function extract_label_aux(_hd, l, _param) {
  while(true) {
    const param = _param;
    const hd = _hd;
    if (param) {
      const ls = param.tl;
      const p = param.hd;
      const l$p = p[0];
      if (label_name(l$p) === l) {
        return [
                l$p,
                p[1],
                Stdlib__List.rev(hd),
                ls
              ];
      }
      _param = ls;
      _hd = {
        hd: p,
        tl: hd
      };
      continue ;
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
  };
}

function undo_change(param) {
  switch (param.TAG | 0) {
    case /* Ctype */0 :
        param._0.desc = param._1;
        return ;
    case /* Clevel */1 :
        param._0.level = param._1;
        return ;
    default:
      param._0.contents = param._1;
      return ;
  }
}

const trail = Caml_array.make(1, undefined);

const last_snapshot = {
  contents: 0
};

function log_change(ch) {
  const r = Caml_array.get(trail, 0);
  if (r === undefined) {
    return ;
  }
  const r$p = {
    contents: /* Unchanged */0
  };
  r.contents = /* Change */{
    _0: ch,
    _1: r$p
  };
  Caml_array.set(trail, 0, r$p);
}

function log_type(ty) {
  if (ty.id <= last_snapshot.contents) {
    return log_change({
                TAG: /* Ctype */0,
                _0: ty,
                _1: ty.desc
              });
  }
  
}

function link_type(ty, ty$p) {
  log_type(ty);
  const desc = ty.desc;
  ty.desc = {
    TAG: /* Tlink */6,
    _0: ty$p
  };
  const match = ty$p.desc;
  if (typeof desc === "number") {
    return ;
  }
  if (desc.TAG !== /* Tvar */0) {
    return ;
  }
  if (typeof match === "number") {
    return ;
  }
  if (match.TAG !== /* Tvar */0) {
    return ;
  }
  const name = desc._0;
  if (name !== undefined && !(match._0 !== undefined && ty.level >= ty$p.level)) {
    log_type(ty$p);
    ty$p.desc = {
      TAG: /* Tvar */0,
      _0: name
    };
    return ;
  }
  
}

function set_level(ty, level) {
  if (ty.id <= last_snapshot.contents) {
    log_change({
          TAG: /* Clevel */1,
          _0: ty,
          _1: ty.level
        });
  }
  ty.level = level;
}

function set_univar(rty, ty) {
  log_change({
        TAG: /* Cuniv */6,
        _0: rty,
        _1: rty.contents
      });
  rty.contents = ty;
}

function set_name(nm, v) {
  log_change({
        TAG: /* Cname */2,
        _0: nm,
        _1: nm.contents
      });
  nm.contents = v;
}

function set_row_field(e, v) {
  log_change({
        TAG: /* Crow */3,
        _0: e,
        _1: e.contents
      });
  e.contents = v;
}

function set_kind(rk, k) {
  log_change({
        TAG: /* Ckind */4,
        _0: rk,
        _1: rk.contents
      });
  rk.contents = k;
}

function set_commu(rc, c) {
  log_change({
        TAG: /* Ccommu */5,
        _0: rc,
        _1: rc.contents
      });
  rc.contents = c;
}

function set_typeset(rs, s) {
  log_change({
        TAG: /* Ctypeset */7,
        _0: rs,
        _1: rs.contents
      });
  rs.contents = s;
}

function snapshot(param) {
  const old = last_snapshot.contents;
  last_snapshot.contents = new_id.contents;
  const r = Caml_array.get(trail, 0);
  if (r !== undefined) {
    return [
            r,
            old
          ];
  }
  const r$1 = {
    contents: /* Unchanged */0
  };
  Caml_array.set(trail, 0, r$1);
  return [
          r$1,
          old
        ];
}

function rev_log(_accu, _param) {
  while(true) {
    const param = _param;
    const accu = _accu;
    if (typeof param === "number") {
      if (param) {
        throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                  MEL_EXN_ID: "Assert_failure",
                  _1: [
                    "jscomp/test/ocaml_typedtree_test.ml",
                    5465,
                    15
                  ]
                });
      }
      return accu;
    }
    const next = param._1;
    const d = next.contents;
    next.contents = /* Invalid */1;
    _param = d;
    _accu = {
      hd: param._0,
      tl: accu
    };
    continue ;
  };
}

function backtrack(param) {
  const old = param[1];
  const changes = param[0];
  const change = changes.contents;
  if (typeof change === "number") {
    if (change) {
      throw new Caml_js_exceptions.MelangeError("Failure", {
                MEL_EXN_ID: "Failure",
                _1: "Btype.backtrack"
              });
    }
    last_snapshot.contents = old;
    return ;
  }
  cleanup_abbrev(undefined);
  const backlog = rev_log(/* [] */0, change);
  Stdlib__List.iter(undo_change, backlog);
  changes.contents = /* Unchanged */0;
  last_snapshot.contents = old;
  Caml_array.set(trail, 0, changes);
}

const $$Error$1 = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Cmi_format.Error");

function input_cmi(ic) {
  const match = Caml_external_polyfill.resolve("caml_input_value")(ic);
  const crcs = Caml_external_polyfill.resolve("caml_input_value")(ic);
  const flags = Caml_external_polyfill.resolve("caml_input_value")(ic);
  return {
          cmi_name: match[0],
          cmi_sign: match[1],
          cmi_crcs: crcs,
          cmi_flags: flags
        };
}

function read_cmi(filename) {
  const ic = Stdlib.open_in_bin(filename);
  try {
    const buffer = Stdlib.really_input_string(ic, cmi_magic_number.length);
    if (buffer !== cmi_magic_number) {
      Caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
      const pre_len = cmi_magic_number.length - 3 | 0;
      if (Stdlib__String.sub(buffer, 0, pre_len) === Stdlib__String.sub(cmi_magic_number, 0, pre_len)) {
        const msg = buffer < cmi_magic_number ? "an older" : "a newer";
        throw new Caml_js_exceptions.MelangeError($$Error$1, {
                  MEL_EXN_ID: $$Error$1,
                  _1: {
                    TAG: /* Wrong_version_interface */1,
                    _0: filename,
                    _1: msg
                  }
                });
      }
      throw new Caml_js_exceptions.MelangeError($$Error$1, {
                MEL_EXN_ID: $$Error$1,
                _1: {
                  TAG: /* Not_an_interface */0,
                  _0: filename
                }
              });
    }
    const cmi = input_cmi(ic);
    Caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
    return cmi;
  }
  catch (raw_e){
    const e = Caml_js_exceptions.internalToOCamlException(raw_e);
    if (e.MEL_EXN_ID === Stdlib.End_of_file) {
      Caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
      throw new Caml_js_exceptions.MelangeError($$Error$1, {
                MEL_EXN_ID: $$Error$1,
                _1: {
                  TAG: /* Corrupted_interface */2,
                  _0: filename
                }
              });
    }
    if (e.MEL_EXN_ID === Stdlib.Failure) {
      Caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
      throw new Caml_js_exceptions.MelangeError($$Error$1, {
                MEL_EXN_ID: $$Error$1,
                _1: {
                  TAG: /* Corrupted_interface */2,
                  _0: filename
                }
              });
    }
    if (e.MEL_EXN_ID === $$Error$1) {
      Caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
      throw new Caml_js_exceptions.MelangeError($$Error$1, {
                MEL_EXN_ID: $$Error$1,
                _1: e._1
              });
    }
    throw new Caml_js_exceptions.MelangeError(e.MEL_EXN_ID, e);
  }
}

function output_cmi(filename, oc, cmi) {
  Stdlib.output_string(oc, cmi_magic_number);
  Caml_external_polyfill.resolve("caml_output_value")(oc, [
        cmi.cmi_name,
        cmi.cmi_sign
      ], /* [] */0);
  Caml_io.caml_ml_flush(oc);
  const crc = Stdlib__Digest.file(filename);
  const crcs_0 = [
    cmi.cmi_name,
    crc
  ];
  const crcs_1 = cmi.cmi_crcs;
  const crcs = {
    hd: crcs_0,
    tl: crcs_1
  };
  Caml_external_polyfill.resolve("caml_output_value")(oc, crcs, /* [] */0);
  Caml_external_polyfill.resolve("caml_output_value")(oc, cmi.cmi_flags, /* [] */0);
  return crc;
}

function report_error(ppf, filename) {
  switch (filename.TAG | 0) {
    case /* Not_an_interface */0 :
        return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Alpha */15,
                          _0: {
                            TAG: /* Formatting_lit */17,
                            _0: {
                              TAG: /* Break */0,
                              _0: "@ ",
                              _1: 1,
                              _2: 0
                            },
                            _1: {
                              TAG: /* String_literal */11,
                              _0: "is not a compiled interface",
                              _1: /* End_of_format */0
                            }
                          }
                        },
                        _1: "%a@ is not a compiled interface"
                      }), print_filename, filename._0);
    case /* Wrong_version_interface */1 :
        return Curry._3(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Alpha */15,
                          _0: {
                            TAG: /* Formatting_lit */17,
                            _0: {
                              TAG: /* Break */0,
                              _0: "@ ",
                              _1: 1,
                              _2: 0
                            },
                            _1: {
                              TAG: /* String_literal */11,
                              _0: "is not a compiled interface for this version of OCaml.",
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: /* Flush_newline */4,
                                _1: {
                                  TAG: /* String_literal */11,
                                  _0: "It seems to be for ",
                                  _1: {
                                    TAG: /* String */2,
                                    _0: /* No_padding */0,
                                    _1: {
                                      TAG: /* String_literal */11,
                                      _0: " version of OCaml.",
                                      _1: /* End_of_format */0
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "%a@ is not a compiled interface for this version of OCaml.@.It seems to be for %s version of OCaml."
                      }), print_filename, filename._0, filename._1);
    case /* Corrupted_interface */2 :
        return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "Corrupted compiled interface",
                          _1: {
                            TAG: /* Formatting_lit */17,
                            _0: {
                              TAG: /* Break */0,
                              _0: "@ ",
                              _1: 1,
                              _2: 0
                            },
                            _1: {
                              TAG: /* Alpha */15,
                              _0: /* End_of_format */0
                            }
                          }
                        },
                        _1: "Corrupted compiled interface@ %a"
                      }), print_filename, filename._0);
    
  }
}

register_error_of_exn(function (err) {
      if (err.MEL_EXN_ID === $$Error$1) {
        return error_of_printer_file(report_error, err._1);
      }
      
    });

const Inconsistency = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Consistbl.Inconsistency");

function set$1(tbl, name, crc, source) {
  Stdlib__Hashtbl.add(tbl, name, [
        crc,
        source
      ]);
}

function extract(l, tbl) {
  const l$1 = Stdlib__List.sort_uniq(Stdlib__String.compare, l);
  return Stdlib__List.fold_left((function (assc, name) {
                try {
                  const match = Stdlib__Hashtbl.find(tbl, name);
                  return {
                          hd: [
                            name,
                            Caml_option.some(match[0])
                          ],
                          tl: assc
                        };
                }
                catch (raw_exn){
                  const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                  if (exn.MEL_EXN_ID === Stdlib.Not_found) {
                    return {
                            hd: [
                              name,
                              undefined
                            ],
                            tl: assc
                          };
                  }
                  throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
                }
              }), /* [] */0, l$1);
}

function free_vars(ty) {
  const ret = {
    contents: /* Empty */0
  };
  const loop = function (_ty) {
    while(true) {
      const ty = _ty;
      const ty$1 = repr(ty);
      if (ty$1.level < 0) {
        return ;
      }
      ty$1.level = pivot_level - ty$1.level | 0;
      const row = ty$1.desc;
      if (typeof row === "number") {
        return iter_type_expr(loop, ty$1);
      }
      switch (row.TAG | 0) {
        case /* Tvar */0 :
            ret.contents = Curry._2(add$3, ty$1, ret.contents);
            return ;
        case /* Tvariant */8 :
            const row$1 = row_repr_aux(/* [] */0, row._0);
            iter_row(loop, row$1);
            if (static_row(row$1)) {
              return ;
            }
            _ty = row$1.row_more;
            continue ;
        default:
          return iter_type_expr(loop, ty$1);
      }
    };
  };
  loop(ty);
  unmark_type(ty);
  return ret.contents;
}

const optional_shape_0 = {
  txt: "internal.optional",
  loc: none
};

const optional_shape_1 = {
  TAG: /* PStr */0,
  _0: /* [] */0
};

const optional_shape = [
  optional_shape_0,
  optional_shape_1
];

function extension_descr(path_ext, ext) {
  const type_ret = ext.ext_ret_type;
  const ty_res = type_ret !== undefined ? type_ret : newty2(100000000, {
          TAG: /* Tconstr */3,
          _0: ext.ext_type_path,
          _1: ext.ext_type_params,
          _2: {
            contents: /* Mnil */0
          }
        });
  const tag_1 = Caml_obj.caml_equal(ext.ext_args, /* [] */0);
  const tag = {
    TAG: /* Cstr_extension */2,
    _0: path_ext,
    _1: tag_1
  };
  const type_ret$1 = ext.ext_ret_type;
  let existentials;
  if (type_ret$1 !== undefined) {
    const ret_vars = free_vars(type_ret$1);
    const arg_vars = free_vars(newty2(100000000, {
              TAG: /* Ttuple */2,
              _0: ext.ext_args
            }));
    existentials = Curry._1(elements$1, Curry._2(diff$1, arg_vars, ret_vars));
  } else {
    existentials = /* [] */0;
  }
  return {
          cstr_name: last(path_ext),
          cstr_res: ty_res,
          cstr_existentials: existentials,
          cstr_args: ext.ext_args,
          cstr_arity: Stdlib__List.length(ext.ext_args),
          cstr_tag: tag,
          cstr_consts: -1,
          cstr_nonconsts: -1,
          cstr_normal: -1,
          cstr_generalized: ext.ext_ret_type !== undefined,
          cstr_private: ext.ext_private,
          cstr_loc: ext.ext_loc,
          cstr_attributes: ext.ext_attributes
        };
}

const none$1 = {
  desc: {
    TAG: /* Ttuple */2,
    _0: /* [] */0
  },
  level: -1,
  id: -1
};

const dummy_label_lbl_all = [];

const dummy_label = {
  lbl_name: "",
  lbl_res: none$1,
  lbl_arg: none$1,
  lbl_mut: /* Immutable */0,
  lbl_pos: -1,
  lbl_all: dummy_label_lbl_all,
  lbl_repres: /* Record_regular */0,
  lbl_private: /* Public */1,
  lbl_loc: none,
  lbl_attributes: /* [] */0
};

const builtin_idents = {
  contents: /* [] */0
};

function wrap(create, s) {
  const id = Curry._1(create, s);
  builtin_idents.contents = {
    hd: [
      s,
      id
    ],
    tl: builtin_idents.contents
  };
  return id;
}

const ident_int = wrap(create, "int");

const ident_char = wrap(create, "char");

const ident_string = wrap(create, "string");

const ident_float = wrap(create, "float");

const ident_bool = wrap(create, "bool");

const ident_unit = wrap(create, "unit");

const ident_exn = wrap(create, "exn");

const ident_array = wrap(create, "array");

const ident_list = wrap(create, "list");

const ident_option = wrap(create, "option");

const ident_nativeint = wrap(create, "nativeint");

const ident_int32 = wrap(create, "int32");

const ident_int64 = wrap(create, "int64");

const ident_lazy_t = wrap(create, "lazy_t");

const ident_bytes = wrap(create, "bytes");

const path_int = {
  TAG: /* Pident */0,
  _0: ident_int
};

const path_char = {
  TAG: /* Pident */0,
  _0: ident_char
};

const path_string = {
  TAG: /* Pident */0,
  _0: ident_string
};

const path_float = {
  TAG: /* Pident */0,
  _0: ident_float
};

const path_bool = {
  TAG: /* Pident */0,
  _0: ident_bool
};

const path_unit = {
  TAG: /* Pident */0,
  _0: ident_unit
};

const path_exn = {
  TAG: /* Pident */0,
  _0: ident_exn
};

const path_array = {
  TAG: /* Pident */0,
  _0: ident_array
};

const path_list = {
  TAG: /* Pident */0,
  _0: ident_list
};

const path_option = {
  TAG: /* Pident */0,
  _0: ident_option
};

const path_nativeint = {
  TAG: /* Pident */0,
  _0: ident_nativeint
};

const path_int32 = {
  TAG: /* Pident */0,
  _0: ident_int32
};

const path_int64 = {
  TAG: /* Pident */0,
  _0: ident_int64
};

const path_lazy_t = {
  TAG: /* Pident */0,
  _0: ident_lazy_t
};

const path_bytes = {
  TAG: /* Pident */0,
  _0: ident_bytes
};

const type_int = newty2(100000000, {
      TAG: /* Tconstr */3,
      _0: path_int,
      _1: /* [] */0,
      _2: {
        contents: /* Mnil */0
      }
    });

const type_char = newty2(100000000, {
      TAG: /* Tconstr */3,
      _0: path_char,
      _1: /* [] */0,
      _2: {
        contents: /* Mnil */0
      }
    });

const type_string = newty2(100000000, {
      TAG: /* Tconstr */3,
      _0: path_string,
      _1: /* [] */0,
      _2: {
        contents: /* Mnil */0
      }
    });

const type_float = newty2(100000000, {
      TAG: /* Tconstr */3,
      _0: path_float,
      _1: /* [] */0,
      _2: {
        contents: /* Mnil */0
      }
    });

const type_bool = newty2(100000000, {
      TAG: /* Tconstr */3,
      _0: path_bool,
      _1: /* [] */0,
      _2: {
        contents: /* Mnil */0
      }
    });

const type_unit = newty2(100000000, {
      TAG: /* Tconstr */3,
      _0: path_unit,
      _1: /* [] */0,
      _2: {
        contents: /* Mnil */0
      }
    });

const type_exn = newty2(100000000, {
      TAG: /* Tconstr */3,
      _0: path_exn,
      _1: /* [] */0,
      _2: {
        contents: /* Mnil */0
      }
    });

function type_array(t) {
  return newty2(100000000, {
              TAG: /* Tconstr */3,
              _0: path_array,
              _1: {
                hd: t,
                tl: /* [] */0
              },
              _2: {
                contents: /* Mnil */0
              }
            });
}

function type_list(t) {
  return newty2(100000000, {
              TAG: /* Tconstr */3,
              _0: path_list,
              _1: {
                hd: t,
                tl: /* [] */0
              },
              _2: {
                contents: /* Mnil */0
              }
            });
}

function type_option(t) {
  return newty2(100000000, {
              TAG: /* Tconstr */3,
              _0: path_option,
              _1: {
                hd: t,
                tl: /* [] */0
              },
              _2: {
                contents: /* Mnil */0
              }
            });
}

const type_nativeint = newty2(100000000, {
      TAG: /* Tconstr */3,
      _0: path_nativeint,
      _1: /* [] */0,
      _2: {
        contents: /* Mnil */0
      }
    });

const type_int32 = newty2(100000000, {
      TAG: /* Tconstr */3,
      _0: path_int32,
      _1: /* [] */0,
      _2: {
        contents: /* Mnil */0
      }
    });

const type_int64 = newty2(100000000, {
      TAG: /* Tconstr */3,
      _0: path_int64,
      _1: /* [] */0,
      _2: {
        contents: /* Mnil */0
      }
    });

function type_lazy_t(t) {
  return newty2(100000000, {
              TAG: /* Tconstr */3,
              _0: path_lazy_t,
              _1: {
                hd: t,
                tl: /* [] */0
              },
              _2: {
                contents: /* Mnil */0
              }
            });
}

newty2(100000000, {
      TAG: /* Tconstr */3,
      _0: path_bytes,
      _1: /* [] */0,
      _2: {
        contents: /* Mnil */0
      }
    });

const ident_match_failure = wrap(create_predef_exn, "Match_failure");

const ident_out_of_memory = wrap(create_predef_exn, "Out_of_memory");

const ident_invalid_argument = wrap(create_predef_exn, "Invalid_argument");

const ident_failure = wrap(create_predef_exn, "Failure");

const ident_not_found = wrap(create_predef_exn, "Not_found");

const ident_sys_error = wrap(create_predef_exn, "Sys_error");

const ident_end_of_file = wrap(create_predef_exn, "End_of_file");

const ident_division_by_zero = wrap(create_predef_exn, "Division_by_zero");

const ident_stack_overflow = wrap(create_predef_exn, "Stack_overflow");

const ident_sys_blocked_io = wrap(create_predef_exn, "Sys_blocked_io");

const ident_assert_failure = wrap(create_predef_exn, "Assert_failure");

const ident_undefined_recursive_module = wrap(create_predef_exn, "Undefined_recursive_module");

const decl_abstr = {
  type_params: /* [] */0,
  type_arity: 0,
  type_kind: /* Type_abstract */0,
  type_private: /* Public */1,
  type_manifest: undefined,
  type_variance: /* [] */0,
  type_newtype_level: undefined,
  type_loc: none,
  type_attributes: /* [] */0
};

function cstr(id, args) {
  return {
          cd_id: id,
          cd_args: args,
          cd_res: undefined,
          cd_loc: none,
          cd_attributes: /* [] */0
        };
}

const ident_false = wrap(create, "false");

const ident_true = wrap(create, "true");

const ident_void = wrap(create, "()");

const ident_nil = wrap(create, "[]");

const ident_cons = wrap(create, "::");

const ident_none = wrap(create, "None");

const ident_some = wrap(create, "Some");

function common_initial_env(add_type, add_extension, empty_env) {
  const decl_bool_type_kind = {
    TAG: /* Type_variant */1,
    _0: {
      hd: cstr(ident_false, /* [] */0),
      tl: {
        hd: cstr(ident_true, /* [] */0),
        tl: /* [] */0
      }
    }
  };
  const decl_bool = {
    type_params: /* [] */0,
    type_arity: 0,
    type_kind: decl_bool_type_kind,
    type_private: /* Public */1,
    type_manifest: undefined,
    type_variance: /* [] */0,
    type_newtype_level: undefined,
    type_loc: none,
    type_attributes: /* [] */0
  };
  const decl_unit_type_kind = {
    TAG: /* Type_variant */1,
    _0: {
      hd: cstr(ident_void, /* [] */0),
      tl: /* [] */0
    }
  };
  const decl_unit = {
    type_params: /* [] */0,
    type_arity: 0,
    type_kind: decl_unit_type_kind,
    type_private: /* Public */1,
    type_manifest: undefined,
    type_variance: /* [] */0,
    type_newtype_level: undefined,
    type_loc: none,
    type_attributes: /* [] */0
  };
  const decl_exn = {
    type_params: /* [] */0,
    type_arity: 0,
    type_kind: /* Type_open */1,
    type_private: /* Public */1,
    type_manifest: undefined,
    type_variance: /* [] */0,
    type_newtype_level: undefined,
    type_loc: none,
    type_attributes: /* [] */0
  };
  const tvar = newty2(100000000, {
        TAG: /* Tvar */0,
        _0: undefined
      });
  const decl_array_type_params = {
    hd: tvar,
    tl: /* [] */0
  };
  const decl_array_type_variance = {
    hd: Types_Variance.full,
    tl: /* [] */0
  };
  const decl_array = {
    type_params: decl_array_type_params,
    type_arity: 1,
    type_kind: /* Type_abstract */0,
    type_private: /* Public */1,
    type_manifest: undefined,
    type_variance: decl_array_type_variance,
    type_newtype_level: undefined,
    type_loc: none,
    type_attributes: /* [] */0
  };
  const tvar$1 = newty2(100000000, {
        TAG: /* Tvar */0,
        _0: undefined
      });
  const decl_list_type_params = {
    hd: tvar$1,
    tl: /* [] */0
  };
  const decl_list_type_kind = {
    TAG: /* Type_variant */1,
    _0: {
      hd: cstr(ident_nil, /* [] */0),
      tl: {
        hd: cstr(ident_cons, {
              hd: tvar$1,
              tl: {
                hd: type_list(tvar$1),
                tl: /* [] */0
              }
            }),
        tl: /* [] */0
      }
    }
  };
  const decl_list_type_variance = {
    hd: Types_Variance.covariant,
    tl: /* [] */0
  };
  const decl_list = {
    type_params: decl_list_type_params,
    type_arity: 1,
    type_kind: decl_list_type_kind,
    type_private: /* Public */1,
    type_manifest: undefined,
    type_variance: decl_list_type_variance,
    type_newtype_level: undefined,
    type_loc: none,
    type_attributes: /* [] */0
  };
  const tvar$2 = newty2(100000000, {
        TAG: /* Tvar */0,
        _0: undefined
      });
  const decl_option_type_params = {
    hd: tvar$2,
    tl: /* [] */0
  };
  const decl_option_type_kind = {
    TAG: /* Type_variant */1,
    _0: {
      hd: cstr(ident_none, /* [] */0),
      tl: {
        hd: cstr(ident_some, {
              hd: tvar$2,
              tl: /* [] */0
            }),
        tl: /* [] */0
      }
    }
  };
  const decl_option_type_variance = {
    hd: Types_Variance.covariant,
    tl: /* [] */0
  };
  const decl_option = {
    type_params: decl_option_type_params,
    type_arity: 1,
    type_kind: decl_option_type_kind,
    type_private: /* Public */1,
    type_manifest: undefined,
    type_variance: decl_option_type_variance,
    type_newtype_level: undefined,
    type_loc: none,
    type_attributes: /* [] */0
  };
  const tvar$3 = newty2(100000000, {
        TAG: /* Tvar */0,
        _0: undefined
      });
  const decl_lazy_t_type_params = {
    hd: tvar$3,
    tl: /* [] */0
  };
  const decl_lazy_t_type_variance = {
    hd: Types_Variance.covariant,
    tl: /* [] */0
  };
  const decl_lazy_t = {
    type_params: decl_lazy_t_type_params,
    type_arity: 1,
    type_kind: /* Type_abstract */0,
    type_private: /* Public */1,
    type_manifest: undefined,
    type_variance: decl_lazy_t_type_variance,
    type_newtype_level: undefined,
    type_loc: none,
    type_attributes: /* [] */0
  };
  const add_extension$1 = function (id, l) {
    return Curry._2(add_extension, id, {
                ext_type_path: path_exn,
                ext_type_params: /* [] */0,
                ext_args: l,
                ext_ret_type: undefined,
                ext_private: /* Public */1,
                ext_loc: none,
                ext_attributes: /* [] */0
              });
  };
  return Curry._1(add_extension$1(ident_match_failure, {
                  hd: newty2(100000000, {
                        TAG: /* Ttuple */2,
                        _0: {
                          hd: type_string,
                          tl: {
                            hd: type_int,
                            tl: {
                              hd: type_int,
                              tl: /* [] */0
                            }
                          }
                        }
                      }),
                  tl: /* [] */0
                }), Curry._1(add_extension$1(ident_out_of_memory, /* [] */0), Curry._1(add_extension$1(ident_stack_overflow, /* [] */0), Curry._1(add_extension$1(ident_invalid_argument, {
                              hd: type_string,
                              tl: /* [] */0
                            }), Curry._1(add_extension$1(ident_failure, {
                                  hd: type_string,
                                  tl: /* [] */0
                                }), Curry._1(add_extension$1(ident_not_found, /* [] */0), Curry._1(add_extension$1(ident_sys_blocked_io, /* [] */0), Curry._1(add_extension$1(ident_sys_error, {
                                              hd: type_string,
                                              tl: /* [] */0
                                            }), Curry._1(add_extension$1(ident_end_of_file, /* [] */0), Curry._1(add_extension$1(ident_division_by_zero, /* [] */0), Curry._1(add_extension$1(ident_assert_failure, {
                                                          hd: newty2(100000000, {
                                                                TAG: /* Ttuple */2,
                                                                _0: {
                                                                  hd: type_string,
                                                                  tl: {
                                                                    hd: type_int,
                                                                    tl: {
                                                                      hd: type_int,
                                                                      tl: /* [] */0
                                                                    }
                                                                  }
                                                                }
                                                              }),
                                                          tl: /* [] */0
                                                        }), Curry._1(add_extension$1(ident_undefined_recursive_module, {
                                                              hd: newty2(100000000, {
                                                                    TAG: /* Ttuple */2,
                                                                    _0: {
                                                                      hd: type_string,
                                                                      tl: {
                                                                        hd: type_int,
                                                                        tl: {
                                                                          hd: type_int,
                                                                          tl: /* [] */0
                                                                        }
                                                                      }
                                                                    }
                                                                  }),
                                                              tl: /* [] */0
                                                            }), Curry._3(add_type, ident_int64, decl_abstr, Curry._3(add_type, ident_int32, decl_abstr, Curry._3(add_type, ident_nativeint, decl_abstr, Curry._3(add_type, ident_lazy_t, decl_lazy_t, Curry._3(add_type, ident_option, decl_option, Curry._3(add_type, ident_list, decl_list, Curry._3(add_type, ident_array, decl_array, Curry._3(add_type, ident_exn, decl_exn, Curry._3(add_type, ident_unit, decl_unit, Curry._3(add_type, ident_bool, decl_bool, Curry._3(add_type, ident_float, decl_abstr, Curry._3(add_type, ident_string, decl_abstr, Curry._3(add_type, ident_char, decl_abstr, Curry._3(add_type, ident_int, decl_abstr, empty_env))))))))))))))))))))))))));
}

function build_initial_env(add_type, add_exception, empty_env) {
  const common = common_initial_env(add_type, add_exception, empty_env);
  const safe_string = Curry._3(add_type, ident_bytes, decl_abstr, common);
  const decl_bytes_unsafe_type_manifest = type_string;
  const decl_bytes_unsafe = {
    type_params: /* [] */0,
    type_arity: 0,
    type_kind: /* Type_abstract */0,
    type_private: /* Public */1,
    type_manifest: decl_bytes_unsafe_type_manifest,
    type_variance: /* [] */0,
    type_newtype_level: undefined,
    type_loc: none,
    type_attributes: /* [] */0
  };
  const unsafe_string = Curry._3(add_type, ident_bytes, decl_bytes_unsafe, common);
  return [
          safe_string,
          unsafe_string
        ];
}

Stdlib__List.map((function (id) {
        make_global(id);
        return [
                id.name,
                id
              ];
      }), {
      hd: ident_match_failure,
      tl: {
        hd: ident_out_of_memory,
        tl: {
          hd: ident_stack_overflow,
          tl: {
            hd: ident_invalid_argument,
            tl: {
              hd: ident_failure,
              tl: {
                hd: ident_not_found,
                tl: {
                  hd: ident_sys_error,
                  tl: {
                    hd: ident_end_of_file,
                    tl: {
                      hd: ident_division_by_zero,
                      tl: {
                        hd: ident_sys_blocked_io,
                        tl: {
                          hd: ident_assert_failure,
                          tl: {
                            hd: ident_undefined_recursive_module,
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    });

set_current_time(999);

Stdlib__List.rev(builtin_idents.contents);

const docstrings = {
  contents: /* [] */0
};

function warn_bad_docstrings(param) {
  if (is_active({
          TAG: /* Bad_docstring */33,
          _0: true
        })) {
    return Stdlib__List.iter((function (ds) {
                  const match = ds.ds_attached;
                  switch (match) {
                    case /* Unattached */0 :
                        return prerr_warning(ds.ds_loc, {
                                    TAG: /* Bad_docstring */33,
                                    _0: true
                                  });
                    case /* Info */1 :
                        return ;
                    case /* Docs */2 :
                        const match$1 = ds.ds_associated;
                        if (match$1 >= 2) {
                          return prerr_warning(ds.ds_loc, {
                                      TAG: /* Bad_docstring */33,
                                      _0: false
                                    });
                        } else {
                          return ;
                        }
                    
                  }
                }), Stdlib__List.rev(docstrings.contents));
  }
  
}

function docstring(body, loc) {
  const ds = {
    ds_body: body,
    ds_loc: loc,
    ds_attached: /* Unattached */0,
    ds_associated: /* Zero */0
  };
  docstrings.contents = {
    hd: ds,
    tl: docstrings.contents
  };
  return ds;
}

const empty_docs = {
  docs_pre: undefined,
  docs_post: undefined
};

const doc_loc = {
  txt: "ocaml.doc",
  loc: none
};

function docs_attr(ds) {
  const exp_pexp_desc = {
    TAG: /* Pexp_constant */1,
    _0: {
      TAG: /* Const_string */2,
      _0: ds.ds_body,
      _1: undefined
    }
  };
  const exp_pexp_loc = ds.ds_loc;
  const exp = {
    pexp_desc: exp_pexp_desc,
    pexp_loc: exp_pexp_loc,
    pexp_attributes: /* [] */0
  };
  const item_pstr_desc = {
    TAG: /* Pstr_eval */0,
    _0: exp,
    _1: /* [] */0
  };
  const item_pstr_loc = exp_pexp_loc;
  const item = {
    pstr_desc: item_pstr_desc,
    pstr_loc: item_pstr_loc
  };
  return [
          doc_loc,
          {
            TAG: /* PStr */0,
            _0: {
              hd: item,
              tl: /* [] */0
            }
          }
        ];
}

function add_docs_attrs(docs, attrs) {
  const ds = docs.docs_pre;
  const attrs$1 = ds !== undefined ? ({
        hd: docs_attr(ds),
        tl: attrs
      }) : attrs;
  const ds$1 = docs.docs_post;
  if (ds$1 !== undefined) {
    return Stdlib.$at(attrs$1, {
                hd: docs_attr(ds$1),
                tl: /* [] */0
              });
  } else {
    return attrs$1;
  }
}

function add_info_attrs(info, attrs) {
  if (info !== undefined) {
    return Stdlib.$at(attrs, {
                hd: docs_attr(info),
                tl: /* [] */0
              });
  } else {
    return attrs;
  }
}

const text_loc = {
  txt: "ocaml.text",
  loc: none
};

function text_attr(ds) {
  const exp_pexp_desc = {
    TAG: /* Pexp_constant */1,
    _0: {
      TAG: /* Const_string */2,
      _0: ds.ds_body,
      _1: undefined
    }
  };
  const exp_pexp_loc = ds.ds_loc;
  const exp = {
    pexp_desc: exp_pexp_desc,
    pexp_loc: exp_pexp_loc,
    pexp_attributes: /* [] */0
  };
  const item_pstr_desc = {
    TAG: /* Pstr_eval */0,
    _0: exp,
    _1: /* [] */0
  };
  const item_pstr_loc = exp_pexp_loc;
  const item = {
    pstr_desc: item_pstr_desc,
    pstr_loc: item_pstr_loc
  };
  return [
          text_loc,
          {
            TAG: /* PStr */0,
            _0: {
              hd: item,
              tl: /* [] */0
            }
          }
        ];
}

function add_text_attrs(dsl, attrs) {
  return Stdlib.$at(Stdlib__List.map(text_attr, dsl), attrs);
}

function get_docstring(info, dsl) {
  let _param = dsl;
  while(true) {
    const param = _param;
    if (!param) {
      return ;
    }
    const ds = param.hd;
    const match = ds.ds_attached;
    if (match !== 1) {
      ds.ds_attached = info ? /* Info */1 : /* Docs */2;
      return ds;
    }
    _param = param.tl;
    continue ;
  };
}

function get_docstrings(dsl) {
  let _acc = /* [] */0;
  let _param = dsl;
  while(true) {
    const param = _param;
    const acc = _acc;
    if (!param) {
      return Stdlib__List.rev(acc);
    }
    const ds = param.hd;
    const match = ds.ds_attached;
    if (match !== 1) {
      ds.ds_attached = /* Docs */2;
      _param = param.tl;
      _acc = {
        hd: ds,
        tl: acc
      };
      continue ;
    }
    _param = param.tl;
    continue ;
  };
}

function associate_docstrings(dsl) {
  Stdlib__List.iter((function (ds) {
          const match = ds.ds_associated;
          if (match) {
            ds.ds_associated = /* Many */2;
          } else {
            ds.ds_associated = /* One */1;
          }
        }), dsl);
}

const pre_table = Stdlib__Hashtbl.create(undefined, 50);

function set_pre_docstrings(pos, dsl) {
  if (Caml_obj.caml_notequal(dsl, /* [] */0)) {
    return Stdlib__Hashtbl.add(pre_table, pos, dsl);
  }
  
}

function get_pre_docs(pos) {
  try {
    const dsl = Stdlib__Hashtbl.find(pre_table, pos);
    associate_docstrings(dsl);
    return get_docstring(false, dsl);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return ;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function mark_pre_docs(pos) {
  try {
    return associate_docstrings(Stdlib__Hashtbl.find(pre_table, pos));
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return ;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

const post_table = Stdlib__Hashtbl.create(undefined, 50);

function set_post_docstrings(pos, dsl) {
  if (Caml_obj.caml_notequal(dsl, /* [] */0)) {
    return Stdlib__Hashtbl.add(post_table, pos, dsl);
  }
  
}

function get_post_docs(pos) {
  try {
    const dsl = Stdlib__Hashtbl.find(post_table, pos);
    associate_docstrings(dsl);
    return get_docstring(false, dsl);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return ;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function mark_post_docs(pos) {
  try {
    return associate_docstrings(Stdlib__Hashtbl.find(post_table, pos));
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return ;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function get_info(pos) {
  try {
    const dsl = Stdlib__Hashtbl.find(post_table, pos);
    return get_docstring(true, dsl);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return ;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

const floating_table = Stdlib__Hashtbl.create(undefined, 50);

function set_floating_docstrings(pos, dsl) {
  if (Caml_obj.caml_notequal(dsl, /* [] */0)) {
    return Stdlib__Hashtbl.add(floating_table, pos, dsl);
  }
  
}

function get_text(pos) {
  try {
    return get_docstrings(Stdlib__Hashtbl.find(floating_table, pos));
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return /* [] */0;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

const pre_extra_table = Stdlib__Hashtbl.create(undefined, 50);

function set_pre_extra_docstrings(pos, dsl) {
  if (Caml_obj.caml_notequal(dsl, /* [] */0)) {
    return Stdlib__Hashtbl.add(pre_extra_table, pos, dsl);
  }
  
}

function get_pre_extra_text(pos) {
  try {
    return get_docstrings(Stdlib__Hashtbl.find(pre_extra_table, pos));
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return /* [] */0;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

const post_extra_table = Stdlib__Hashtbl.create(undefined, 50);

function set_post_extra_docstrings(pos, dsl) {
  if (Caml_obj.caml_notequal(dsl, /* [] */0)) {
    return Stdlib__Hashtbl.add(post_extra_table, pos, dsl);
  }
  
}

function get_post_extra_text(pos) {
  try {
    return get_docstrings(Stdlib__Hashtbl.find(post_extra_table, pos));
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return /* [] */0;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function symbol_docs(param) {
  return {
          docs_pre: get_pre_docs(Stdlib__Parsing.symbol_start_pos(undefined)),
          docs_post: get_post_docs(Stdlib__Parsing.symbol_end_pos(undefined))
        };
}

function symbol_docs_lazy(param) {
  const p1 = Stdlib__Parsing.symbol_start_pos(undefined);
  const p2 = Stdlib__Parsing.symbol_end_pos(undefined);
  return {
          LAZY_DONE: false,
          VAL: (function () {
              return {
                      docs_pre: get_pre_docs(p1),
                      docs_post: get_post_docs(p2)
                    };
            })
        };
}

function mark_symbol_docs(param) {
  mark_pre_docs(Stdlib__Parsing.symbol_start_pos(undefined));
  mark_post_docs(Stdlib__Parsing.symbol_end_pos(undefined));
}

function mark_rhs_docs(pos1, pos2) {
  mark_pre_docs(Stdlib__Parsing.rhs_start_pos(pos1));
  mark_post_docs(Stdlib__Parsing.rhs_end_pos(pos2));
}

function symbol_text_lazy(param) {
  const pos = Stdlib__Parsing.symbol_start_pos(undefined);
  return {
          LAZY_DONE: false,
          VAL: (function () {
              return get_text(pos);
            })
        };
}

function init(param) {
  docstrings.contents = /* [] */0;
  Stdlib__Hashtbl.reset(pre_table);
  Stdlib__Hashtbl.reset(post_table);
  Stdlib__Hashtbl.reset(floating_table);
  Stdlib__Hashtbl.reset(pre_extra_table);
  Stdlib__Hashtbl.reset(post_extra_table);
}

const default_loc = {
  contents: none
};

function mk(locOpt, attrsOpt, d) {
  const loc = locOpt !== undefined ? locOpt : default_loc.contents;
  const attrs = attrsOpt !== undefined ? attrsOpt : /* [] */0;
  return {
          ptyp_desc: d,
          ptyp_loc: loc,
          ptyp_attributes: attrs
        };
}

function attr(d, a) {
  return {
          ptyp_desc: d.ptyp_desc,
          ptyp_loc: d.ptyp_loc,
          ptyp_attributes: Stdlib.$at(d.ptyp_attributes, {
                hd: a,
                tl: /* [] */0
              })
        };
}

function $$var(loc, attrs, a) {
  return mk(loc, attrs, {
              TAG: /* Ptyp_var */0,
              _0: a
            });
}

function arrow(loc, attrs, a, b, c) {
  return mk(loc, attrs, {
              TAG: /* Ptyp_arrow */1,
              _0: a,
              _1: b,
              _2: c
            });
}

function tuple(loc, attrs, a) {
  return mk(loc, attrs, {
              TAG: /* Ptyp_tuple */2,
              _0: a
            });
}

function constr(loc, attrs, a, b) {
  return mk(loc, attrs, {
              TAG: /* Ptyp_constr */3,
              _0: a,
              _1: b
            });
}

function object_(loc, attrs, a, b) {
  return mk(loc, attrs, {
              TAG: /* Ptyp_object */4,
              _0: a,
              _1: b
            });
}

function class_(loc, attrs, a, b) {
  return mk(loc, attrs, {
              TAG: /* Ptyp_class */5,
              _0: a,
              _1: b
            });
}

function alias(loc, attrs, a, b) {
  return mk(loc, attrs, {
              TAG: /* Ptyp_alias */6,
              _0: a,
              _1: b
            });
}

function variant(loc, attrs, a, b, c) {
  return mk(loc, attrs, {
              TAG: /* Ptyp_variant */7,
              _0: a,
              _1: b,
              _2: c
            });
}

function poly(loc, attrs, a, b) {
  return mk(loc, attrs, {
              TAG: /* Ptyp_poly */8,
              _0: a,
              _1: b
            });
}

function $$package(loc, attrs, a, b) {
  return mk(loc, attrs, {
              TAG: /* Ptyp_package */9,
              _0: [
                a,
                b
              ]
            });
}

function extension(loc, attrs, a) {
  return mk(loc, attrs, {
              TAG: /* Ptyp_extension */10,
              _0: a
            });
}

function force_poly(t) {
  const match = t.ptyp_desc;
  if (typeof match !== "number" && match.TAG === /* Ptyp_poly */8) {
    return t;
  }
  return poly(t.ptyp_loc, undefined, /* [] */0, t);
}

function mk$1(locOpt, attrsOpt, d) {
  const loc = locOpt !== undefined ? locOpt : default_loc.contents;
  const attrs = attrsOpt !== undefined ? attrsOpt : /* [] */0;
  return {
          ppat_desc: d,
          ppat_loc: loc,
          ppat_attributes: attrs
        };
}

function attr$1(d, a) {
  return {
          ppat_desc: d.ppat_desc,
          ppat_loc: d.ppat_loc,
          ppat_attributes: Stdlib.$at(d.ppat_attributes, {
                hd: a,
                tl: /* [] */0
              })
        };
}

function $$var$1(loc, attrs, a) {
  return mk$1(loc, attrs, {
              TAG: /* Ppat_var */0,
              _0: a
            });
}

function alias$1(loc, attrs, a, b) {
  return mk$1(loc, attrs, {
              TAG: /* Ppat_alias */1,
              _0: a,
              _1: b
            });
}

function constant(loc, attrs, a) {
  return mk$1(loc, attrs, {
              TAG: /* Ppat_constant */2,
              _0: a
            });
}

function interval(loc, attrs, a, b) {
  return mk$1(loc, attrs, {
              TAG: /* Ppat_interval */3,
              _0: a,
              _1: b
            });
}

function tuple$1(loc, attrs, a) {
  return mk$1(loc, attrs, {
              TAG: /* Ppat_tuple */4,
              _0: a
            });
}

function construct(loc, attrs, a, b) {
  return mk$1(loc, attrs, {
              TAG: /* Ppat_construct */5,
              _0: a,
              _1: b
            });
}

function variant$1(loc, attrs, a, b) {
  return mk$1(loc, attrs, {
              TAG: /* Ppat_variant */6,
              _0: a,
              _1: b
            });
}

function record(loc, attrs, a, b) {
  return mk$1(loc, attrs, {
              TAG: /* Ppat_record */7,
              _0: a,
              _1: b
            });
}

function array(loc, attrs, a) {
  return mk$1(loc, attrs, {
              TAG: /* Ppat_array */8,
              _0: a
            });
}

function or_(loc, attrs, a, b) {
  return mk$1(loc, attrs, {
              TAG: /* Ppat_or */9,
              _0: a,
              _1: b
            });
}

function constraint_(loc, attrs, a, b) {
  return mk$1(loc, attrs, {
              TAG: /* Ppat_constraint */10,
              _0: a,
              _1: b
            });
}

function type_(loc, attrs, a) {
  return mk$1(loc, attrs, {
              TAG: /* Ppat_type */11,
              _0: a
            });
}

function lazy_(loc, attrs, a) {
  return mk$1(loc, attrs, {
              TAG: /* Ppat_lazy */12,
              _0: a
            });
}

function unpack(loc, attrs, a) {
  return mk$1(loc, attrs, {
              TAG: /* Ppat_unpack */13,
              _0: a
            });
}

function exception_(loc, attrs, a) {
  return mk$1(loc, attrs, {
              TAG: /* Ppat_exception */14,
              _0: a
            });
}

function extension$1(loc, attrs, a) {
  return mk$1(loc, attrs, {
              TAG: /* Ppat_extension */15,
              _0: a
            });
}

function mk$2(locOpt, attrsOpt, d) {
  const loc = locOpt !== undefined ? locOpt : default_loc.contents;
  const attrs = attrsOpt !== undefined ? attrsOpt : /* [] */0;
  return {
          pexp_desc: d,
          pexp_loc: loc,
          pexp_attributes: attrs
        };
}

function attr$2(d, a) {
  return {
          pexp_desc: d.pexp_desc,
          pexp_loc: d.pexp_loc,
          pexp_attributes: Stdlib.$at(d.pexp_attributes, {
                hd: a,
                tl: /* [] */0
              })
        };
}

function ident(loc, attrs, a) {
  return mk$2(loc, attrs, {
              TAG: /* Pexp_ident */0,
              _0: a
            });
}

function constant$1(loc, attrs, a) {
  return mk$2(loc, attrs, {
              TAG: /* Pexp_constant */1,
              _0: a
            });
}

function let_(loc, attrs, a, b, c) {
  return mk$2(loc, attrs, {
              TAG: /* Pexp_let */2,
              _0: a,
              _1: b,
              _2: c
            });
}

function fun_(loc, attrs, a, b, c, d) {
  return mk$2(loc, attrs, {
              TAG: /* Pexp_fun */4,
              _0: a,
              _1: b,
              _2: c,
              _3: d
            });
}

function function_(loc, attrs, a) {
  return mk$2(loc, attrs, {
              TAG: /* Pexp_function */3,
              _0: a
            });
}

function apply(loc, attrs, a, b) {
  return mk$2(loc, attrs, {
              TAG: /* Pexp_apply */5,
              _0: a,
              _1: b
            });
}

function match_(loc, attrs, a, b) {
  return mk$2(loc, attrs, {
              TAG: /* Pexp_match */6,
              _0: a,
              _1: b
            });
}

function try_(loc, attrs, a, b) {
  return mk$2(loc, attrs, {
              TAG: /* Pexp_try */7,
              _0: a,
              _1: b
            });
}

function tuple$2(loc, attrs, a) {
  return mk$2(loc, attrs, {
              TAG: /* Pexp_tuple */8,
              _0: a
            });
}

function construct$1(loc, attrs, a, b) {
  return mk$2(loc, attrs, {
              TAG: /* Pexp_construct */9,
              _0: a,
              _1: b
            });
}

function variant$2(loc, attrs, a, b) {
  return mk$2(loc, attrs, {
              TAG: /* Pexp_variant */10,
              _0: a,
              _1: b
            });
}

function record$1(loc, attrs, a, b) {
  return mk$2(loc, attrs, {
              TAG: /* Pexp_record */11,
              _0: a,
              _1: b
            });
}

function field(loc, attrs, a, b) {
  return mk$2(loc, attrs, {
              TAG: /* Pexp_field */12,
              _0: a,
              _1: b
            });
}

function setfield(loc, attrs, a, b, c) {
  return mk$2(loc, attrs, {
              TAG: /* Pexp_setfield */13,
              _0: a,
              _1: b,
              _2: c
            });
}

function array$1(loc, attrs, a) {
  return mk$2(loc, attrs, {
              TAG: /* Pexp_array */14,
              _0: a
            });
}

function ifthenelse(loc, attrs, a, b, c) {
  return mk$2(loc, attrs, {
              TAG: /* Pexp_ifthenelse */15,
              _0: a,
              _1: b,
              _2: c
            });
}

function sequence(loc, attrs, a, b) {
  return mk$2(loc, attrs, {
              TAG: /* Pexp_sequence */16,
              _0: a,
              _1: b
            });
}

function while_(loc, attrs, a, b) {
  return mk$2(loc, attrs, {
              TAG: /* Pexp_while */17,
              _0: a,
              _1: b
            });
}

function for_(loc, attrs, a, b, c, d, e) {
  return mk$2(loc, attrs, {
              TAG: /* Pexp_for */18,
              _0: a,
              _1: b,
              _2: c,
              _3: d,
              _4: e
            });
}

function constraint_$1(loc, attrs, a, b) {
  return mk$2(loc, attrs, {
              TAG: /* Pexp_constraint */19,
              _0: a,
              _1: b
            });
}

function coerce(loc, attrs, a, b, c) {
  return mk$2(loc, attrs, {
              TAG: /* Pexp_coerce */20,
              _0: a,
              _1: b,
              _2: c
            });
}

function send(loc, attrs, a, b) {
  return mk$2(loc, attrs, {
              TAG: /* Pexp_send */21,
              _0: a,
              _1: b
            });
}

function new_(loc, attrs, a) {
  return mk$2(loc, attrs, {
              TAG: /* Pexp_new */22,
              _0: a
            });
}

function setinstvar(loc, attrs, a, b) {
  return mk$2(loc, attrs, {
              TAG: /* Pexp_setinstvar */23,
              _0: a,
              _1: b
            });
}

function override(loc, attrs, a) {
  return mk$2(loc, attrs, {
              TAG: /* Pexp_override */24,
              _0: a
            });
}

function letmodule(loc, attrs, a, b, c) {
  return mk$2(loc, attrs, {
              TAG: /* Pexp_letmodule */25,
              _0: a,
              _1: b,
              _2: c
            });
}

function assert_(loc, attrs, a) {
  return mk$2(loc, attrs, {
              TAG: /* Pexp_assert */26,
              _0: a
            });
}

function lazy_$1(loc, attrs, a) {
  return mk$2(loc, attrs, {
              TAG: /* Pexp_lazy */27,
              _0: a
            });
}

function poly$1(loc, attrs, a, b) {
  return mk$2(loc, attrs, {
              TAG: /* Pexp_poly */28,
              _0: a,
              _1: b
            });
}

function object_$1(loc, attrs, a) {
  return mk$2(loc, attrs, {
              TAG: /* Pexp_object */29,
              _0: a
            });
}

function newtype(loc, attrs, a, b) {
  return mk$2(loc, attrs, {
              TAG: /* Pexp_newtype */30,
              _0: a,
              _1: b
            });
}

function pack(loc, attrs, a) {
  return mk$2(loc, attrs, {
              TAG: /* Pexp_pack */31,
              _0: a
            });
}

function open_(loc, attrs, a, b, c) {
  return mk$2(loc, attrs, {
              TAG: /* Pexp_open */32,
              _0: a,
              _1: b,
              _2: c
            });
}

function extension$2(loc, attrs, a) {
  return mk$2(loc, attrs, {
              TAG: /* Pexp_extension */33,
              _0: a
            });
}

function $$case(lhs, guard, rhs) {
  return {
          pc_lhs: lhs,
          pc_guard: guard,
          pc_rhs: rhs
        };
}

function mk$3(locOpt, attrsOpt, d) {
  const loc = locOpt !== undefined ? locOpt : default_loc.contents;
  const attrs = attrsOpt !== undefined ? attrsOpt : /* [] */0;
  return {
          pmty_desc: d,
          pmty_loc: loc,
          pmty_attributes: attrs
        };
}

function attr$3(d, a) {
  return {
          pmty_desc: d.pmty_desc,
          pmty_loc: d.pmty_loc,
          pmty_attributes: Stdlib.$at(d.pmty_attributes, {
                hd: a,
                tl: /* [] */0
              })
        };
}

function ident$1(loc, attrs, a) {
  return mk$3(loc, attrs, {
              TAG: /* Pmty_ident */0,
              _0: a
            });
}

function alias$2(loc, attrs, a) {
  return mk$3(loc, attrs, {
              TAG: /* Pmty_alias */6,
              _0: a
            });
}

function signature(loc, attrs, a) {
  return mk$3(loc, attrs, {
              TAG: /* Pmty_signature */1,
              _0: a
            });
}

function functor_(loc, attrs, a, b, c) {
  return mk$3(loc, attrs, {
              TAG: /* Pmty_functor */2,
              _0: a,
              _1: b,
              _2: c
            });
}

function with_(loc, attrs, a, b) {
  return mk$3(loc, attrs, {
              TAG: /* Pmty_with */3,
              _0: a,
              _1: b
            });
}

function typeof_(loc, attrs, a) {
  return mk$3(loc, attrs, {
              TAG: /* Pmty_typeof */4,
              _0: a
            });
}

function extension$3(loc, attrs, a) {
  return mk$3(loc, attrs, {
              TAG: /* Pmty_extension */5,
              _0: a
            });
}

function mk$4(locOpt, attrsOpt, d) {
  const loc = locOpt !== undefined ? locOpt : default_loc.contents;
  const attrs = attrsOpt !== undefined ? attrsOpt : /* [] */0;
  return {
          pmod_desc: d,
          pmod_loc: loc,
          pmod_attributes: attrs
        };
}

function attr$4(d, a) {
  return {
          pmod_desc: d.pmod_desc,
          pmod_loc: d.pmod_loc,
          pmod_attributes: Stdlib.$at(d.pmod_attributes, {
                hd: a,
                tl: /* [] */0
              })
        };
}

function ident$2(loc, attrs, x) {
  return mk$4(loc, attrs, {
              TAG: /* Pmod_ident */0,
              _0: x
            });
}

function structure(loc, attrs, x) {
  return mk$4(loc, attrs, {
              TAG: /* Pmod_structure */1,
              _0: x
            });
}

function functor_$1(loc, attrs, arg, arg_ty, body) {
  return mk$4(loc, attrs, {
              TAG: /* Pmod_functor */2,
              _0: arg,
              _1: arg_ty,
              _2: body
            });
}

function apply$1(loc, attrs, m1, m2) {
  return mk$4(loc, attrs, {
              TAG: /* Pmod_apply */3,
              _0: m1,
              _1: m2
            });
}

function constraint_$2(loc, attrs, m, mty) {
  return mk$4(loc, attrs, {
              TAG: /* Pmod_constraint */4,
              _0: m,
              _1: mty
            });
}

function unpack$1(loc, attrs, e) {
  return mk$4(loc, attrs, {
              TAG: /* Pmod_unpack */5,
              _0: e
            });
}

function extension$4(loc, attrs, a) {
  return mk$4(loc, attrs, {
              TAG: /* Pmod_extension */6,
              _0: a
            });
}

function mk$5(locOpt, d) {
  const loc = locOpt !== undefined ? locOpt : default_loc.contents;
  return {
          psig_desc: d,
          psig_loc: loc
        };
}

function extension$5(loc, attrsOpt, a) {
  const attrs = attrsOpt !== undefined ? attrsOpt : /* [] */0;
  return mk$5(loc, {
              TAG: /* Psig_extension */12,
              _0: a,
              _1: attrs
            });
}

function text(txt) {
  return Stdlib__List.map((function (ds) {
                const a = text_attr(ds);
                const loc = ds.ds_loc;
                return mk$5(loc, {
                            TAG: /* Psig_attribute */11,
                            _0: a
                          });
              }), txt);
}

function mk$6(locOpt, d) {
  const loc = locOpt !== undefined ? locOpt : default_loc.contents;
  return {
          pstr_desc: d,
          pstr_loc: loc
        };
}

function $$eval(loc, attrsOpt, a) {
  const attrs = attrsOpt !== undefined ? attrsOpt : /* [] */0;
  return mk$6(loc, {
              TAG: /* Pstr_eval */0,
              _0: a,
              _1: attrs
            });
}

function value(loc, a, b) {
  return mk$6(loc, {
              TAG: /* Pstr_value */1,
              _0: a,
              _1: b
            });
}

function extension$6(loc, attrsOpt, a) {
  const attrs = attrsOpt !== undefined ? attrsOpt : /* [] */0;
  return mk$6(loc, {
              TAG: /* Pstr_extension */14,
              _0: a,
              _1: attrs
            });
}

function text$1(txt) {
  return Stdlib__List.map((function (ds) {
                const a = text_attr(ds);
                const loc = ds.ds_loc;
                return mk$6(loc, {
                            TAG: /* Pstr_attribute */13,
                            _0: a
                          });
              }), txt);
}

function mk$7(locOpt, attrsOpt, d) {
  const loc = locOpt !== undefined ? locOpt : default_loc.contents;
  const attrs = attrsOpt !== undefined ? attrsOpt : /* [] */0;
  return {
          pcl_desc: d,
          pcl_loc: loc,
          pcl_attributes: attrs
        };
}

function attr$5(d, a) {
  return {
          pcl_desc: d.pcl_desc,
          pcl_loc: d.pcl_loc,
          pcl_attributes: Stdlib.$at(d.pcl_attributes, {
                hd: a,
                tl: /* [] */0
              })
        };
}

function constr$1(loc, attrs, a, b) {
  return mk$7(loc, attrs, {
              TAG: /* Pcl_constr */0,
              _0: a,
              _1: b
            });
}

function structure$1(loc, attrs, a) {
  return mk$7(loc, attrs, {
              TAG: /* Pcl_structure */1,
              _0: a
            });
}

function fun_$1(loc, attrs, a, b, c, d) {
  return mk$7(loc, attrs, {
              TAG: /* Pcl_fun */2,
              _0: a,
              _1: b,
              _2: c,
              _3: d
            });
}

function apply$2(loc, attrs, a, b) {
  return mk$7(loc, attrs, {
              TAG: /* Pcl_apply */3,
              _0: a,
              _1: b
            });
}

function let_$1(loc, attrs, a, b, c) {
  return mk$7(loc, attrs, {
              TAG: /* Pcl_let */4,
              _0: a,
              _1: b,
              _2: c
            });
}

function constraint_$3(loc, attrs, a, b) {
  return mk$7(loc, attrs, {
              TAG: /* Pcl_constraint */5,
              _0: a,
              _1: b
            });
}

function extension$7(loc, attrs, a) {
  return mk$7(loc, attrs, {
              TAG: /* Pcl_extension */6,
              _0: a
            });
}

function mk$8(locOpt, attrsOpt, d) {
  const loc = locOpt !== undefined ? locOpt : default_loc.contents;
  const attrs = attrsOpt !== undefined ? attrsOpt : /* [] */0;
  return {
          pcty_desc: d,
          pcty_loc: loc,
          pcty_attributes: attrs
        };
}

function attr$6(d, a) {
  return {
          pcty_desc: d.pcty_desc,
          pcty_loc: d.pcty_loc,
          pcty_attributes: Stdlib.$at(d.pcty_attributes, {
                hd: a,
                tl: /* [] */0
              })
        };
}

function constr$2(loc, attrs, a, b) {
  return mk$8(loc, attrs, {
              TAG: /* Pcty_constr */0,
              _0: a,
              _1: b
            });
}

function signature$1(loc, attrs, a) {
  return mk$8(loc, attrs, {
              TAG: /* Pcty_signature */1,
              _0: a
            });
}

function arrow$1(loc, attrs, a, b, c) {
  return mk$8(loc, attrs, {
              TAG: /* Pcty_arrow */2,
              _0: a,
              _1: b,
              _2: c
            });
}

function extension$8(loc, attrs, a) {
  return mk$8(loc, attrs, {
              TAG: /* Pcty_extension */3,
              _0: a
            });
}

function mk$9(locOpt, attrsOpt, docsOpt, d) {
  const loc = locOpt !== undefined ? locOpt : default_loc.contents;
  const attrs = attrsOpt !== undefined ? attrsOpt : /* [] */0;
  const docs = docsOpt !== undefined ? docsOpt : empty_docs;
  return {
          pctf_desc: d,
          pctf_loc: loc,
          pctf_attributes: add_docs_attrs(docs, attrs)
        };
}

function inherit_(loc, attrs, a) {
  return mk$9(loc, attrs, undefined, {
              TAG: /* Pctf_inherit */0,
              _0: a
            });
}

function val_(loc, attrs, a, b, c, d) {
  return mk$9(loc, attrs, undefined, {
              TAG: /* Pctf_val */1,
              _0: [
                a,
                b,
                c,
                d
              ]
            });
}

function method_(loc, attrs, a, b, c, d) {
  return mk$9(loc, attrs, undefined, {
              TAG: /* Pctf_method */2,
              _0: [
                a,
                b,
                c,
                d
              ]
            });
}

function constraint_$4(loc, attrs, a, b) {
  return mk$9(loc, attrs, undefined, {
              TAG: /* Pctf_constraint */3,
              _0: [
                a,
                b
              ]
            });
}

function extension$9(loc, attrs, a) {
  return mk$9(loc, attrs, undefined, {
              TAG: /* Pctf_extension */5,
              _0: a
            });
}

function attribute(loc, a) {
  return mk$9(loc, undefined, undefined, {
              TAG: /* Pctf_attribute */4,
              _0: a
            });
}

function text$2(txt) {
  return Stdlib__List.map((function (ds) {
                return attribute(ds.ds_loc, text_attr(ds));
              }), txt);
}

function attr$7(d, a) {
  return {
          pctf_desc: d.pctf_desc,
          pctf_loc: d.pctf_loc,
          pctf_attributes: Stdlib.$at(d.pctf_attributes, {
                hd: a,
                tl: /* [] */0
              })
        };
}

function mk$10(locOpt, attrsOpt, docsOpt, d) {
  const loc = locOpt !== undefined ? locOpt : default_loc.contents;
  const attrs = attrsOpt !== undefined ? attrsOpt : /* [] */0;
  const docs = docsOpt !== undefined ? docsOpt : empty_docs;
  return {
          pcf_desc: d,
          pcf_loc: loc,
          pcf_attributes: add_docs_attrs(docs, attrs)
        };
}

function inherit_$1(loc, attrs, a, b, c) {
  return mk$10(loc, attrs, undefined, {
              TAG: /* Pcf_inherit */0,
              _0: a,
              _1: b,
              _2: c
            });
}

function val_$1(loc, attrs, a, b, c) {
  return mk$10(loc, attrs, undefined, {
              TAG: /* Pcf_val */1,
              _0: [
                a,
                b,
                c
              ]
            });
}

function method_$1(loc, attrs, a, b, c) {
  return mk$10(loc, attrs, undefined, {
              TAG: /* Pcf_method */2,
              _0: [
                a,
                b,
                c
              ]
            });
}

function constraint_$5(loc, attrs, a, b) {
  return mk$10(loc, attrs, undefined, {
              TAG: /* Pcf_constraint */3,
              _0: [
                a,
                b
              ]
            });
}

function initializer_(loc, attrs, a) {
  return mk$10(loc, attrs, undefined, {
              TAG: /* Pcf_initializer */4,
              _0: a
            });
}

function extension$10(loc, attrs, a) {
  return mk$10(loc, attrs, undefined, {
              TAG: /* Pcf_extension */6,
              _0: a
            });
}

function attribute$1(loc, a) {
  return mk$10(loc, undefined, undefined, {
              TAG: /* Pcf_attribute */5,
              _0: a
            });
}

function text$3(txt) {
  return Stdlib__List.map((function (ds) {
                return attribute$1(ds.ds_loc, text_attr(ds));
              }), txt);
}

function virtual_(ct) {
  return {
          TAG: /* Cfk_virtual */0,
          _0: ct
        };
}

function concrete(o, e) {
  return {
          TAG: /* Cfk_concrete */1,
          _0: o,
          _1: e
        };
}

function attr$8(d, a) {
  return {
          pcf_desc: d.pcf_desc,
          pcf_loc: d.pcf_loc,
          pcf_attributes: Stdlib.$at(d.pcf_attributes, {
                hd: a,
                tl: /* [] */0
              })
        };
}

function mk$11(locOpt, attrsOpt, docsOpt, primOpt, name, typ) {
  const loc = locOpt !== undefined ? locOpt : default_loc.contents;
  const attrs = attrsOpt !== undefined ? attrsOpt : /* [] */0;
  const docs = docsOpt !== undefined ? docsOpt : empty_docs;
  const prim = primOpt !== undefined ? primOpt : /* [] */0;
  return {
          pval_name: name,
          pval_type: typ,
          pval_prim: prim,
          pval_attributes: add_docs_attrs(docs, attrs),
          pval_loc: loc
        };
}

function mk$12(locOpt, attrsOpt, docsOpt, textOpt, name, typ) {
  const loc = locOpt !== undefined ? locOpt : default_loc.contents;
  const attrs = attrsOpt !== undefined ? attrsOpt : /* [] */0;
  const docs = docsOpt !== undefined ? docsOpt : empty_docs;
  const text = textOpt !== undefined ? textOpt : /* [] */0;
  return {
          pmd_name: name,
          pmd_type: typ,
          pmd_attributes: add_text_attrs(text, add_docs_attrs(docs, attrs)),
          pmd_loc: loc
        };
}

function mk$13(locOpt, attrsOpt, docsOpt, textOpt, typ, name) {
  const loc = locOpt !== undefined ? locOpt : default_loc.contents;
  const attrs = attrsOpt !== undefined ? attrsOpt : /* [] */0;
  const docs = docsOpt !== undefined ? docsOpt : empty_docs;
  const text = textOpt !== undefined ? textOpt : /* [] */0;
  return {
          pmtd_name: name,
          pmtd_type: typ,
          pmtd_attributes: add_text_attrs(text, add_docs_attrs(docs, attrs)),
          pmtd_loc: loc
        };
}

function mk$14(locOpt, attrsOpt, docsOpt, textOpt, name, expr) {
  const loc = locOpt !== undefined ? locOpt : default_loc.contents;
  const attrs = attrsOpt !== undefined ? attrsOpt : /* [] */0;
  const docs = docsOpt !== undefined ? docsOpt : empty_docs;
  const text = textOpt !== undefined ? textOpt : /* [] */0;
  return {
          pmb_name: name,
          pmb_expr: expr,
          pmb_attributes: add_text_attrs(text, add_docs_attrs(docs, attrs)),
          pmb_loc: loc
        };
}

function mk$15(locOpt, attrsOpt, docsOpt, overrideOpt, lid) {
  const loc = locOpt !== undefined ? locOpt : default_loc.contents;
  const attrs = attrsOpt !== undefined ? attrsOpt : /* [] */0;
  const docs = docsOpt !== undefined ? docsOpt : empty_docs;
  const override = overrideOpt !== undefined ? overrideOpt : /* Fresh */1;
  return {
          popen_lid: lid,
          popen_override: override,
          popen_loc: loc,
          popen_attributes: add_docs_attrs(docs, attrs)
        };
}

function mk$16(locOpt, attrsOpt, docsOpt, mexpr) {
  const loc = locOpt !== undefined ? locOpt : default_loc.contents;
  const attrs = attrsOpt !== undefined ? attrsOpt : /* [] */0;
  const docs = docsOpt !== undefined ? docsOpt : empty_docs;
  return {
          pincl_mod: mexpr,
          pincl_loc: loc,
          pincl_attributes: add_docs_attrs(docs, attrs)
        };
}

function mk$17(locOpt, attrsOpt, docsOpt, textOpt, pat, expr) {
  const loc = locOpt !== undefined ? locOpt : default_loc.contents;
  const attrs = attrsOpt !== undefined ? attrsOpt : /* [] */0;
  const docs = docsOpt !== undefined ? docsOpt : empty_docs;
  const text = textOpt !== undefined ? textOpt : /* [] */0;
  return {
          pvb_pat: pat,
          pvb_expr: expr,
          pvb_attributes: add_text_attrs(text, add_docs_attrs(docs, attrs)),
          pvb_loc: loc
        };
}

function mk$18(locOpt, attrsOpt, docsOpt, textOpt, virtOpt, paramsOpt, name, expr) {
  const loc = locOpt !== undefined ? locOpt : default_loc.contents;
  const attrs = attrsOpt !== undefined ? attrsOpt : /* [] */0;
  const docs = docsOpt !== undefined ? docsOpt : empty_docs;
  const text = textOpt !== undefined ? textOpt : /* [] */0;
  const virt = virtOpt !== undefined ? virtOpt : /* Concrete */1;
  const params = paramsOpt !== undefined ? paramsOpt : /* [] */0;
  return {
          pci_virt: virt,
          pci_params: params,
          pci_name: name,
          pci_expr: expr,
          pci_loc: loc,
          pci_attributes: add_text_attrs(text, add_docs_attrs(docs, attrs))
        };
}

function mk$19(locOpt, attrsOpt, docsOpt, textOpt, paramsOpt, cstrsOpt, kindOpt, privOpt, manifest, name) {
  const loc = locOpt !== undefined ? locOpt : default_loc.contents;
  const attrs = attrsOpt !== undefined ? attrsOpt : /* [] */0;
  const docs = docsOpt !== undefined ? docsOpt : empty_docs;
  const text = textOpt !== undefined ? textOpt : /* [] */0;
  const params = paramsOpt !== undefined ? paramsOpt : /* [] */0;
  const cstrs = cstrsOpt !== undefined ? cstrsOpt : /* [] */0;
  const kind = kindOpt !== undefined ? kindOpt : /* Ptype_abstract */0;
  const priv = privOpt !== undefined ? privOpt : /* Public */1;
  return {
          ptype_name: name,
          ptype_params: params,
          ptype_cstrs: cstrs,
          ptype_kind: kind,
          ptype_private: priv,
          ptype_manifest: manifest,
          ptype_attributes: add_text_attrs(text, add_docs_attrs(docs, attrs)),
          ptype_loc: loc
        };
}

function constructor(locOpt, attrsOpt, infoOpt, argsOpt, res, name) {
  const loc = locOpt !== undefined ? locOpt : default_loc.contents;
  const attrs = attrsOpt !== undefined ? attrsOpt : /* [] */0;
  const info = infoOpt !== undefined ? Caml_option.valFromOption(infoOpt) : undefined;
  const args = argsOpt !== undefined ? argsOpt : /* [] */0;
  return {
          pcd_name: name,
          pcd_args: args,
          pcd_res: res,
          pcd_loc: loc,
          pcd_attributes: add_info_attrs(info, attrs)
        };
}

function field$1(locOpt, attrsOpt, infoOpt, mutOpt, name, typ) {
  const loc = locOpt !== undefined ? locOpt : default_loc.contents;
  const attrs = attrsOpt !== undefined ? attrsOpt : /* [] */0;
  const info = infoOpt !== undefined ? Caml_option.valFromOption(infoOpt) : undefined;
  const mut = mutOpt !== undefined ? mutOpt : /* Immutable */0;
  return {
          pld_name: name,
          pld_mutable: mut,
          pld_type: typ,
          pld_loc: loc,
          pld_attributes: add_info_attrs(info, attrs)
        };
}

function mk$20(attrsOpt, docsOpt, paramsOpt, privOpt, path, constructors) {
  const attrs = attrsOpt !== undefined ? attrsOpt : /* [] */0;
  const docs = docsOpt !== undefined ? docsOpt : empty_docs;
  const params = paramsOpt !== undefined ? paramsOpt : /* [] */0;
  const priv = privOpt !== undefined ? privOpt : /* Public */1;
  return {
          ptyext_path: path,
          ptyext_params: params,
          ptyext_constructors: constructors,
          ptyext_private: priv,
          ptyext_attributes: add_docs_attrs(docs, attrs)
        };
}

function constructor$1(locOpt, attrsOpt, docsOpt, infoOpt, name, kind) {
  const loc = locOpt !== undefined ? locOpt : default_loc.contents;
  const attrs = attrsOpt !== undefined ? attrsOpt : /* [] */0;
  const docs = docsOpt !== undefined ? docsOpt : empty_docs;
  const info = infoOpt !== undefined ? Caml_option.valFromOption(infoOpt) : undefined;
  return {
          pext_name: name,
          pext_kind: kind,
          pext_loc: loc,
          pext_attributes: add_docs_attrs(docs, add_info_attrs(info, attrs))
        };
}

function decl(locOpt, attrsOpt, docsOpt, infoOpt, argsOpt, res, name) {
  const loc = locOpt !== undefined ? locOpt : default_loc.contents;
  const attrs = attrsOpt !== undefined ? attrsOpt : /* [] */0;
  const docs = docsOpt !== undefined ? docsOpt : empty_docs;
  const info = infoOpt !== undefined ? Caml_option.valFromOption(infoOpt) : undefined;
  const args = argsOpt !== undefined ? argsOpt : /* [] */0;
  return {
          pext_name: name,
          pext_kind: {
            TAG: /* Pext_decl */0,
            _0: args,
            _1: res
          },
          pext_loc: loc,
          pext_attributes: add_docs_attrs(docs, add_info_attrs(info, attrs))
        };
}

function rebind(locOpt, attrsOpt, docsOpt, infoOpt, name, lid) {
  const loc = locOpt !== undefined ? locOpt : default_loc.contents;
  const attrs = attrsOpt !== undefined ? attrsOpt : /* [] */0;
  const docs = docsOpt !== undefined ? docsOpt : empty_docs;
  const info = infoOpt !== undefined ? Caml_option.valFromOption(infoOpt) : undefined;
  return {
          pext_name: name,
          pext_kind: {
            TAG: /* Pext_rebind */1,
            _0: lid
          },
          pext_loc: loc,
          pext_attributes: add_docs_attrs(docs, add_info_attrs(info, attrs))
        };
}

const Ast_helper_Exp = {
  mk: mk$2,
  attr: attr$2,
  ident: ident,
  constant: constant$1,
  let_: let_,
  fun_: fun_,
  function_: function_,
  apply: apply,
  match_: match_,
  try_: try_,
  tuple: tuple$2,
  construct: construct$1,
  variant: variant$2,
  record: record$1,
  field: field,
  setfield: setfield,
  array: array$1,
  ifthenelse: ifthenelse,
  sequence: sequence,
  while_: while_,
  for_: for_,
  coerce: coerce,
  constraint_: constraint_$1,
  send: send,
  new_: new_,
  setinstvar: setinstvar,
  override: override,
  letmodule: letmodule,
  assert_: assert_,
  lazy_: lazy_$1,
  poly: poly$1,
  object_: object_$1,
  newtype: newtype,
  pack: pack,
  open_: open_,
  extension: extension$2,
  $$case: $$case
};

const Ast_helper_Ctf = {
  mk: mk$9,
  attr: attr$7,
  inherit_: inherit_,
  val_: val_,
  method_: method_,
  constraint_: constraint_$4,
  extension: extension$9,
  attribute: attribute,
  text: text$2
};

const Ast_helper_Cf = {
  mk: mk$10,
  attr: attr$8,
  inherit_: inherit_$1,
  val_: val_$1,
  method_: method_$1,
  constraint_: constraint_$5,
  initializer_: initializer_,
  extension: extension$10,
  attribute: attribute$1,
  text: text$3,
  virtual_: virtual_,
  concrete: concrete
};

function map_fst(f, param) {
  return [
          Curry._1(f, param[0]),
          param[1]
        ];
}

function map_snd(f, param) {
  return [
          param[0],
          Curry._1(f, param[1])
        ];
}

function map_tuple(f1, f2, param) {
  return [
          Curry._1(f1, param[0]),
          Curry._1(f2, param[1])
        ];
}

function map_opt(f, x) {
  if (x !== undefined) {
    return Caml_option.some(Curry._1(f, Caml_option.valFromOption(x)));
  }
  
}

function map_loc(sub, param) {
  return {
          txt: param.txt,
          loc: Curry._2(sub.location, sub, param.loc)
        };
}

function map$1(sub, param) {
  const desc = param.ptyp_desc;
  const loc = Curry._2(sub.location, sub, param.ptyp_loc);
  const attrs = Curry._2(sub.attributes, sub, param.ptyp_attributes);
  if (typeof desc === "number") {
    return mk(loc, attrs, /* Ptyp_any */0);
  }
  switch (desc.TAG | 0) {
    case /* Ptyp_var */0 :
        return $$var(loc, attrs, desc._0);
    case /* Ptyp_arrow */1 :
        return arrow(loc, attrs, desc._0, Curry._2(sub.typ, sub, desc._1), Curry._2(sub.typ, sub, desc._2));
    case /* Ptyp_tuple */2 :
        return tuple(loc, attrs, Stdlib__List.map(Curry._1(sub.typ, sub), desc._0));
    case /* Ptyp_constr */3 :
        return constr(loc, attrs, map_loc(sub, desc._0), Stdlib__List.map(Curry._1(sub.typ, sub), desc._1));
    case /* Ptyp_object */4 :
        const f = function (param) {
          return [
                  param[0],
                  Curry._2(sub.attributes, sub, param[1]),
                  Curry._2(sub.typ, sub, param[2])
                ];
        };
        return object_(loc, attrs, Stdlib__List.map(f, desc._0), desc._1);
    case /* Ptyp_class */5 :
        return class_(loc, attrs, map_loc(sub, desc._0), Stdlib__List.map(Curry._1(sub.typ, sub), desc._1));
    case /* Ptyp_alias */6 :
        return alias(loc, attrs, Curry._2(sub.typ, sub, desc._0), desc._1);
    case /* Ptyp_variant */7 :
        return variant(loc, attrs, Stdlib__List.map((function (param) {
                          if (param.TAG === /* Rtag */0) {
                            return {
                                    TAG: /* Rtag */0,
                                    _0: param._0,
                                    _1: Curry._2(sub.attributes, sub, param._1),
                                    _2: param._2,
                                    _3: Stdlib__List.map(Curry._1(sub.typ, sub), param._3)
                                  };
                          } else {
                            return {
                                    TAG: /* Rinherit */1,
                                    _0: Curry._2(sub.typ, sub, param._0)
                                  };
                          }
                        }), desc._0), desc._1, desc._2);
    case /* Ptyp_poly */8 :
        return poly(loc, attrs, desc._0, Curry._2(sub.typ, sub, desc._1));
    case /* Ptyp_package */9 :
        const match = desc._0;
        const partial_arg = Curry._1(sub.typ, sub);
        return $$package(loc, attrs, map_loc(sub, match[0]), Stdlib__List.map((function (param) {
                          return map_tuple((function (param) {
                                        return map_loc(sub, param);
                                      }), partial_arg, param);
                        }), match[1]));
    case /* Ptyp_extension */10 :
        return extension(loc, attrs, Curry._2(sub.extension, sub, desc._0));
    
  }
}

function map_type_declaration(sub, param) {
  const partial_arg = Curry._1(sub.typ, sub);
  const partial_arg$1 = Curry._1(sub.location, sub);
  const partial_arg$2 = Curry._1(sub.typ, sub);
  const partial_arg$3 = Curry._1(sub.typ, sub);
  return mk$19(Curry._2(sub.location, sub, param.ptype_loc), Curry._2(sub.attributes, sub, param.ptype_attributes), undefined, undefined, Stdlib__List.map((function (param) {
                    return map_fst(partial_arg, param);
                  }), param.ptype_params), Stdlib__List.map((function (param) {
                    return [
                            Curry._1(partial_arg$3, param[0]),
                            Curry._1(partial_arg$2, param[1]),
                            Curry._1(partial_arg$1, param[2])
                          ];
                  }), param.ptype_cstrs), Curry._2(sub.type_kind, sub, param.ptype_kind), param.ptype_private, map_opt(Curry._1(sub.typ, sub), param.ptype_manifest), map_loc(sub, param.ptype_name));
}

function map_type_kind(sub, l) {
  if (typeof l === "number") {
    if (l === /* Ptype_abstract */0) {
      return /* Ptype_abstract */0;
    } else {
      return /* Ptype_open */1;
    }
  } else if (l.TAG === /* Ptype_variant */0) {
    return {
            TAG: /* Ptype_variant */0,
            _0: Stdlib__List.map(Curry._1(sub.constructor_declaration, sub), l._0)
          };
  } else {
    return {
            TAG: /* Ptype_record */1,
            _0: Stdlib__List.map(Curry._1(sub.label_declaration, sub), l._0)
          };
  }
}

function map_type_extension(sub, param) {
  const partial_arg = Curry._1(sub.typ, sub);
  return mk$20(Curry._2(sub.attributes, sub, param.ptyext_attributes), undefined, Stdlib__List.map((function (param) {
                    return map_fst(partial_arg, param);
                  }), param.ptyext_params), param.ptyext_private, map_loc(sub, param.ptyext_path), Stdlib__List.map(Curry._1(sub.extension_constructor, sub), param.ptyext_constructors));
}

function map_extension_constructor_kind(sub, li) {
  if (li.TAG === /* Pext_decl */0) {
    return {
            TAG: /* Pext_decl */0,
            _0: Stdlib__List.map(Curry._1(sub.typ, sub), li._0),
            _1: map_opt(Curry._1(sub.typ, sub), li._1)
          };
  } else {
    return {
            TAG: /* Pext_rebind */1,
            _0: map_loc(sub, li._0)
          };
  }
}

function map_extension_constructor(sub, param) {
  return constructor$1(Curry._2(sub.location, sub, param.pext_loc), Curry._2(sub.attributes, sub, param.pext_attributes), undefined, undefined, map_loc(sub, param.pext_name), map_extension_constructor_kind(sub, param.pext_kind));
}

function map$2(sub, param) {
  const desc = param.pcty_desc;
  const loc = Curry._2(sub.location, sub, param.pcty_loc);
  const attrs = Curry._2(sub.attributes, sub, param.pcty_attributes);
  switch (desc.TAG | 0) {
    case /* Pcty_constr */0 :
        return constr$2(loc, attrs, map_loc(sub, desc._0), Stdlib__List.map(Curry._1(sub.typ, sub), desc._1));
    case /* Pcty_signature */1 :
        return signature$1(loc, attrs, Curry._2(sub.class_signature, sub, desc._0));
    case /* Pcty_arrow */2 :
        return arrow$1(loc, attrs, desc._0, Curry._2(sub.typ, sub, desc._1), Curry._2(sub.class_type, sub, desc._2));
    case /* Pcty_extension */3 :
        return extension$8(loc, attrs, Curry._2(sub.extension, sub, desc._0));
    
  }
}

function map_field(sub, param) {
  const desc = param.pctf_desc;
  const loc = Curry._2(sub.location, sub, param.pctf_loc);
  const attrs = Curry._2(sub.attributes, sub, param.pctf_attributes);
  switch (desc.TAG | 0) {
    case /* Pctf_inherit */0 :
        return Curry._3(Ast_helper_Ctf.inherit_, loc, attrs, Curry._2(sub.class_type, sub, desc._0));
    case /* Pctf_val */1 :
        const match = desc._0;
        return Curry._6(Ast_helper_Ctf.val_, loc, attrs, match[0], match[1], match[2], Curry._2(sub.typ, sub, match[3]));
    case /* Pctf_method */2 :
        const match$1 = desc._0;
        return Curry._6(Ast_helper_Ctf.method_, loc, attrs, match$1[0], match$1[1], match$1[2], Curry._2(sub.typ, sub, match$1[3]));
    case /* Pctf_constraint */3 :
        const match$2 = desc._0;
        return Curry._4(Ast_helper_Ctf.constraint_, loc, attrs, Curry._2(sub.typ, sub, match$2[0]), Curry._2(sub.typ, sub, match$2[1]));
    case /* Pctf_attribute */4 :
        return Curry._2(Ast_helper_Ctf.attribute, loc, Curry._2(sub.attribute, sub, desc._0));
    case /* Pctf_extension */5 :
        return Curry._3(Ast_helper_Ctf.extension, loc, attrs, Curry._2(sub.extension, sub, desc._0));
    
  }
}

function map_signature(sub, param) {
  return {
          pcsig_self: Curry._2(sub.typ, sub, param.pcsig_self),
          pcsig_fields: Stdlib__List.map(Curry._1(sub.class_type_field, sub), param.pcsig_fields)
        };
}

function map$3(sub, param) {
  const desc = param.pmty_desc;
  const loc = Curry._2(sub.location, sub, param.pmty_loc);
  const attrs = Curry._2(sub.attributes, sub, param.pmty_attributes);
  switch (desc.TAG | 0) {
    case /* Pmty_ident */0 :
        return ident$1(loc, attrs, map_loc(sub, desc._0));
    case /* Pmty_signature */1 :
        return signature(loc, attrs, Curry._2(sub.signature, sub, desc._0));
    case /* Pmty_functor */2 :
        return functor_(loc, attrs, map_loc(sub, desc._0), may_map(Curry._1(sub.module_type, sub), desc._1), Curry._2(sub.module_type, sub, desc._2));
    case /* Pmty_with */3 :
        return with_(loc, attrs, Curry._2(sub.module_type, sub, desc._0), Stdlib__List.map(Curry._1(sub.with_constraint, sub), desc._1));
    case /* Pmty_typeof */4 :
        return typeof_(loc, attrs, Curry._2(sub.module_expr, sub, desc._0));
    case /* Pmty_extension */5 :
        return extension$3(loc, attrs, Curry._2(sub.extension, sub, desc._0));
    case /* Pmty_alias */6 :
        return alias$2(loc, attrs, map_loc(sub, desc._0));
    
  }
}

function map_with_constraint(sub, d) {
  switch (d.TAG | 0) {
    case /* Pwith_type */0 :
        return {
                TAG: /* Pwith_type */0,
                _0: map_loc(sub, d._0),
                _1: Curry._2(sub.type_declaration, sub, d._1)
              };
    case /* Pwith_module */1 :
        return {
                TAG: /* Pwith_module */1,
                _0: map_loc(sub, d._0),
                _1: map_loc(sub, d._1)
              };
    case /* Pwith_typesubst */2 :
        return {
                TAG: /* Pwith_typesubst */2,
                _0: Curry._2(sub.type_declaration, sub, d._0)
              };
    case /* Pwith_modsubst */3 :
        return {
                TAG: /* Pwith_modsubst */3,
                _0: map_loc(sub, d._0),
                _1: map_loc(sub, d._1)
              };
    
  }
}

function map_signature_item(sub, param) {
  const desc = param.psig_desc;
  const loc = Curry._2(sub.location, sub, param.psig_loc);
  switch (desc.TAG | 0) {
    case /* Psig_value */0 :
        const a = Curry._2(sub.value_description, sub, desc._0);
        return mk$5(loc, {
                    TAG: /* Psig_value */0,
                    _0: a
                  });
    case /* Psig_type */1 :
        const a$1 = Stdlib__List.map(Curry._1(sub.type_declaration, sub), desc._0);
        return mk$5(loc, {
                    TAG: /* Psig_type */1,
                    _0: a$1
                  });
    case /* Psig_typext */2 :
        const a$2 = Curry._2(sub.type_extension, sub, desc._0);
        return mk$5(loc, {
                    TAG: /* Psig_typext */2,
                    _0: a$2
                  });
    case /* Psig_exception */3 :
        const a$3 = Curry._2(sub.extension_constructor, sub, desc._0);
        return mk$5(loc, {
                    TAG: /* Psig_exception */3,
                    _0: a$3
                  });
    case /* Psig_module */4 :
        const a$4 = Curry._2(sub.module_declaration, sub, desc._0);
        return mk$5(loc, {
                    TAG: /* Psig_module */4,
                    _0: a$4
                  });
    case /* Psig_recmodule */5 :
        const a$5 = Stdlib__List.map(Curry._1(sub.module_declaration, sub), desc._0);
        return mk$5(loc, {
                    TAG: /* Psig_recmodule */5,
                    _0: a$5
                  });
    case /* Psig_modtype */6 :
        const a$6 = Curry._2(sub.module_type_declaration, sub, desc._0);
        return mk$5(loc, {
                    TAG: /* Psig_modtype */6,
                    _0: a$6
                  });
    case /* Psig_open */7 :
        const a$7 = Curry._2(sub.open_description, sub, desc._0);
        return mk$5(loc, {
                    TAG: /* Psig_open */7,
                    _0: a$7
                  });
    case /* Psig_include */8 :
        const a$8 = Curry._2(sub.include_description, sub, desc._0);
        return mk$5(loc, {
                    TAG: /* Psig_include */8,
                    _0: a$8
                  });
    case /* Psig_class */9 :
        const a$9 = Stdlib__List.map(Curry._1(sub.class_description, sub), desc._0);
        return mk$5(loc, {
                    TAG: /* Psig_class */9,
                    _0: a$9
                  });
    case /* Psig_class_type */10 :
        const a$10 = Stdlib__List.map(Curry._1(sub.class_type_declaration, sub), desc._0);
        return mk$5(loc, {
                    TAG: /* Psig_class_type */10,
                    _0: a$10
                  });
    case /* Psig_attribute */11 :
        const a$11 = Curry._2(sub.attribute, sub, desc._0);
        return mk$5(loc, {
                    TAG: /* Psig_attribute */11,
                    _0: a$11
                  });
    case /* Psig_extension */12 :
        return extension$5(loc, Curry._2(sub.attributes, sub, desc._1), Curry._2(sub.extension, sub, desc._0));
    
  }
}

function map$4(sub, param) {
  const desc = param.pmod_desc;
  const loc = Curry._2(sub.location, sub, param.pmod_loc);
  const attrs = Curry._2(sub.attributes, sub, param.pmod_attributes);
  switch (desc.TAG | 0) {
    case /* Pmod_ident */0 :
        return ident$2(loc, attrs, map_loc(sub, desc._0));
    case /* Pmod_structure */1 :
        return structure(loc, attrs, Curry._2(sub.structure, sub, desc._0));
    case /* Pmod_functor */2 :
        return functor_$1(loc, attrs, map_loc(sub, desc._0), may_map(Curry._1(sub.module_type, sub), desc._1), Curry._2(sub.module_expr, sub, desc._2));
    case /* Pmod_apply */3 :
        return apply$1(loc, attrs, Curry._2(sub.module_expr, sub, desc._0), Curry._2(sub.module_expr, sub, desc._1));
    case /* Pmod_constraint */4 :
        return constraint_$2(loc, attrs, Curry._2(sub.module_expr, sub, desc._0), Curry._2(sub.module_type, sub, desc._1));
    case /* Pmod_unpack */5 :
        return unpack$1(loc, attrs, Curry._2(sub.expr, sub, desc._0));
    case /* Pmod_extension */6 :
        return extension$4(loc, attrs, Curry._2(sub.extension, sub, desc._0));
    
  }
}

function map_structure_item(sub, param) {
  const desc = param.pstr_desc;
  const loc = Curry._2(sub.location, sub, param.pstr_loc);
  switch (desc.TAG | 0) {
    case /* Pstr_eval */0 :
        return $$eval(loc, Curry._2(sub.attributes, sub, desc._1), Curry._2(sub.expr, sub, desc._0));
    case /* Pstr_value */1 :
        return value(loc, desc._0, Stdlib__List.map(Curry._1(sub.value_binding, sub), desc._1));
    case /* Pstr_primitive */2 :
        const a = Curry._2(sub.value_description, sub, desc._0);
        return mk$6(loc, {
                    TAG: /* Pstr_primitive */2,
                    _0: a
                  });
    case /* Pstr_type */3 :
        const a$1 = Stdlib__List.map(Curry._1(sub.type_declaration, sub), desc._0);
        return mk$6(loc, {
                    TAG: /* Pstr_type */3,
                    _0: a$1
                  });
    case /* Pstr_typext */4 :
        const a$2 = Curry._2(sub.type_extension, sub, desc._0);
        return mk$6(loc, {
                    TAG: /* Pstr_typext */4,
                    _0: a$2
                  });
    case /* Pstr_exception */5 :
        const a$3 = Curry._2(sub.extension_constructor, sub, desc._0);
        return mk$6(loc, {
                    TAG: /* Pstr_exception */5,
                    _0: a$3
                  });
    case /* Pstr_module */6 :
        const a$4 = Curry._2(sub.module_binding, sub, desc._0);
        return mk$6(loc, {
                    TAG: /* Pstr_module */6,
                    _0: a$4
                  });
    case /* Pstr_recmodule */7 :
        const a$5 = Stdlib__List.map(Curry._1(sub.module_binding, sub), desc._0);
        return mk$6(loc, {
                    TAG: /* Pstr_recmodule */7,
                    _0: a$5
                  });
    case /* Pstr_modtype */8 :
        const a$6 = Curry._2(sub.module_type_declaration, sub, desc._0);
        return mk$6(loc, {
                    TAG: /* Pstr_modtype */8,
                    _0: a$6
                  });
    case /* Pstr_open */9 :
        const a$7 = Curry._2(sub.open_description, sub, desc._0);
        return mk$6(loc, {
                    TAG: /* Pstr_open */9,
                    _0: a$7
                  });
    case /* Pstr_class */10 :
        const a$8 = Stdlib__List.map(Curry._1(sub.class_declaration, sub), desc._0);
        return mk$6(loc, {
                    TAG: /* Pstr_class */10,
                    _0: a$8
                  });
    case /* Pstr_class_type */11 :
        const a$9 = Stdlib__List.map(Curry._1(sub.class_type_declaration, sub), desc._0);
        return mk$6(loc, {
                    TAG: /* Pstr_class_type */11,
                    _0: a$9
                  });
    case /* Pstr_include */12 :
        const a$10 = Curry._2(sub.include_declaration, sub, desc._0);
        return mk$6(loc, {
                    TAG: /* Pstr_include */12,
                    _0: a$10
                  });
    case /* Pstr_attribute */13 :
        const a$11 = Curry._2(sub.attribute, sub, desc._0);
        return mk$6(loc, {
                    TAG: /* Pstr_attribute */13,
                    _0: a$11
                  });
    case /* Pstr_extension */14 :
        return extension$6(loc, Curry._2(sub.attributes, sub, desc._1), Curry._2(sub.extension, sub, desc._0));
    
  }
}

function map$5(sub, param) {
  const desc = param.pexp_desc;
  const loc = Curry._2(sub.location, sub, param.pexp_loc);
  const attrs = Curry._2(sub.attributes, sub, param.pexp_attributes);
  switch (desc.TAG | 0) {
    case /* Pexp_ident */0 :
        return Curry._3(Ast_helper_Exp.ident, loc, attrs, map_loc(sub, desc._0));
    case /* Pexp_constant */1 :
        return Curry._3(Ast_helper_Exp.constant, loc, attrs, desc._0);
    case /* Pexp_let */2 :
        return Curry._5(Ast_helper_Exp.let_, loc, attrs, desc._0, Stdlib__List.map(Curry._1(sub.value_binding, sub), desc._1), Curry._2(sub.expr, sub, desc._2));
    case /* Pexp_function */3 :
        return Curry._3(Ast_helper_Exp.function_, loc, attrs, Curry._2(sub.cases, sub, desc._0));
    case /* Pexp_fun */4 :
        return Curry._6(Ast_helper_Exp.fun_, loc, attrs, desc._0, map_opt(Curry._1(sub.expr, sub), desc._1), Curry._2(sub.pat, sub, desc._2), Curry._2(sub.expr, sub, desc._3));
    case /* Pexp_apply */5 :
        const partial_arg = Curry._1(sub.expr, sub);
        return Curry._4(Ast_helper_Exp.apply, loc, attrs, Curry._2(sub.expr, sub, desc._0), Stdlib__List.map((function (param) {
                          return map_snd(partial_arg, param);
                        }), desc._1));
    case /* Pexp_match */6 :
        return Curry._4(Ast_helper_Exp.match_, loc, attrs, Curry._2(sub.expr, sub, desc._0), Curry._2(sub.cases, sub, desc._1));
    case /* Pexp_try */7 :
        return Curry._4(Ast_helper_Exp.try_, loc, attrs, Curry._2(sub.expr, sub, desc._0), Curry._2(sub.cases, sub, desc._1));
    case /* Pexp_tuple */8 :
        return Curry._3(Ast_helper_Exp.tuple, loc, attrs, Stdlib__List.map(Curry._1(sub.expr, sub), desc._0));
    case /* Pexp_construct */9 :
        return Curry._4(Ast_helper_Exp.construct, loc, attrs, map_loc(sub, desc._0), map_opt(Curry._1(sub.expr, sub), desc._1));
    case /* Pexp_variant */10 :
        return Curry._4(Ast_helper_Exp.variant, loc, attrs, desc._0, map_opt(Curry._1(sub.expr, sub), desc._1));
    case /* Pexp_record */11 :
        const partial_arg$1 = Curry._1(sub.expr, sub);
        return Curry._4(Ast_helper_Exp.record, loc, attrs, Stdlib__List.map((function (param) {
                          return map_tuple((function (param) {
                                        return map_loc(sub, param);
                                      }), partial_arg$1, param);
                        }), desc._0), map_opt(Curry._1(sub.expr, sub), desc._1));
    case /* Pexp_field */12 :
        return Curry._4(Ast_helper_Exp.field, loc, attrs, Curry._2(sub.expr, sub, desc._0), map_loc(sub, desc._1));
    case /* Pexp_setfield */13 :
        return Curry._5(Ast_helper_Exp.setfield, loc, attrs, Curry._2(sub.expr, sub, desc._0), map_loc(sub, desc._1), Curry._2(sub.expr, sub, desc._2));
    case /* Pexp_array */14 :
        return Curry._3(Ast_helper_Exp.array, loc, attrs, Stdlib__List.map(Curry._1(sub.expr, sub), desc._0));
    case /* Pexp_ifthenelse */15 :
        return Curry._5(Ast_helper_Exp.ifthenelse, loc, attrs, Curry._2(sub.expr, sub, desc._0), Curry._2(sub.expr, sub, desc._1), map_opt(Curry._1(sub.expr, sub), desc._2));
    case /* Pexp_sequence */16 :
        return Curry._4(Ast_helper_Exp.sequence, loc, attrs, Curry._2(sub.expr, sub, desc._0), Curry._2(sub.expr, sub, desc._1));
    case /* Pexp_while */17 :
        return Curry._4(Ast_helper_Exp.while_, loc, attrs, Curry._2(sub.expr, sub, desc._0), Curry._2(sub.expr, sub, desc._1));
    case /* Pexp_for */18 :
        return Curry._7(Ast_helper_Exp.for_, loc, attrs, Curry._2(sub.pat, sub, desc._0), Curry._2(sub.expr, sub, desc._1), Curry._2(sub.expr, sub, desc._2), desc._3, Curry._2(sub.expr, sub, desc._4));
    case /* Pexp_constraint */19 :
        return Curry._4(Ast_helper_Exp.constraint_, loc, attrs, Curry._2(sub.expr, sub, desc._0), Curry._2(sub.typ, sub, desc._1));
    case /* Pexp_coerce */20 :
        return Curry._5(Ast_helper_Exp.coerce, loc, attrs, Curry._2(sub.expr, sub, desc._0), map_opt(Curry._1(sub.typ, sub), desc._1), Curry._2(sub.typ, sub, desc._2));
    case /* Pexp_send */21 :
        return Curry._4(Ast_helper_Exp.send, loc, attrs, Curry._2(sub.expr, sub, desc._0), desc._1);
    case /* Pexp_new */22 :
        return Curry._3(Ast_helper_Exp.new_, loc, attrs, map_loc(sub, desc._0));
    case /* Pexp_setinstvar */23 :
        return Curry._4(Ast_helper_Exp.setinstvar, loc, attrs, map_loc(sub, desc._0), Curry._2(sub.expr, sub, desc._1));
    case /* Pexp_override */24 :
        const partial_arg$2 = Curry._1(sub.expr, sub);
        return Curry._3(Ast_helper_Exp.override, loc, attrs, Stdlib__List.map((function (param) {
                          return map_tuple((function (param) {
                                        return map_loc(sub, param);
                                      }), partial_arg$2, param);
                        }), desc._0));
    case /* Pexp_letmodule */25 :
        return Curry._5(Ast_helper_Exp.letmodule, loc, attrs, map_loc(sub, desc._0), Curry._2(sub.module_expr, sub, desc._1), Curry._2(sub.expr, sub, desc._2));
    case /* Pexp_assert */26 :
        return Curry._3(Ast_helper_Exp.assert_, loc, attrs, Curry._2(sub.expr, sub, desc._0));
    case /* Pexp_lazy */27 :
        return Curry._3(Ast_helper_Exp.lazy_, loc, attrs, Curry._2(sub.expr, sub, desc._0));
    case /* Pexp_poly */28 :
        return Curry._4(Ast_helper_Exp.poly, loc, attrs, Curry._2(sub.expr, sub, desc._0), map_opt(Curry._1(sub.typ, sub), desc._1));
    case /* Pexp_object */29 :
        return Curry._3(Ast_helper_Exp.object_, loc, attrs, Curry._2(sub.class_structure, sub, desc._0));
    case /* Pexp_newtype */30 :
        return Curry._4(Ast_helper_Exp.newtype, loc, attrs, desc._0, Curry._2(sub.expr, sub, desc._1));
    case /* Pexp_pack */31 :
        return Curry._3(Ast_helper_Exp.pack, loc, attrs, Curry._2(sub.module_expr, sub, desc._0));
    case /* Pexp_open */32 :
        return Curry._5(Ast_helper_Exp.open_, loc, attrs, desc._0, map_loc(sub, desc._1), Curry._2(sub.expr, sub, desc._2));
    case /* Pexp_extension */33 :
        return Curry._3(Ast_helper_Exp.extension, loc, attrs, Curry._2(sub.extension, sub, desc._0));
    
  }
}

function map$6(sub, param) {
  const desc = param.ppat_desc;
  const loc = Curry._2(sub.location, sub, param.ppat_loc);
  const attrs = Curry._2(sub.attributes, sub, param.ppat_attributes);
  if (typeof desc === "number") {
    return mk$1(loc, attrs, /* Ppat_any */0);
  }
  switch (desc.TAG | 0) {
    case /* Ppat_var */0 :
        return $$var$1(loc, attrs, map_loc(sub, desc._0));
    case /* Ppat_alias */1 :
        return alias$1(loc, attrs, Curry._2(sub.pat, sub, desc._0), map_loc(sub, desc._1));
    case /* Ppat_constant */2 :
        return constant(loc, attrs, desc._0);
    case /* Ppat_interval */3 :
        return interval(loc, attrs, desc._0, desc._1);
    case /* Ppat_tuple */4 :
        return tuple$1(loc, attrs, Stdlib__List.map(Curry._1(sub.pat, sub), desc._0));
    case /* Ppat_construct */5 :
        return construct(loc, attrs, map_loc(sub, desc._0), map_opt(Curry._1(sub.pat, sub), desc._1));
    case /* Ppat_variant */6 :
        return variant$1(loc, attrs, desc._0, map_opt(Curry._1(sub.pat, sub), desc._1));
    case /* Ppat_record */7 :
        const partial_arg = Curry._1(sub.pat, sub);
        return record(loc, attrs, Stdlib__List.map((function (param) {
                          return map_tuple((function (param) {
                                        return map_loc(sub, param);
                                      }), partial_arg, param);
                        }), desc._0), desc._1);
    case /* Ppat_array */8 :
        return array(loc, attrs, Stdlib__List.map(Curry._1(sub.pat, sub), desc._0));
    case /* Ppat_or */9 :
        return or_(loc, attrs, Curry._2(sub.pat, sub, desc._0), Curry._2(sub.pat, sub, desc._1));
    case /* Ppat_constraint */10 :
        return constraint_(loc, attrs, Curry._2(sub.pat, sub, desc._0), Curry._2(sub.typ, sub, desc._1));
    case /* Ppat_type */11 :
        return type_(loc, attrs, map_loc(sub, desc._0));
    case /* Ppat_lazy */12 :
        return lazy_(loc, attrs, Curry._2(sub.pat, sub, desc._0));
    case /* Ppat_unpack */13 :
        return unpack(loc, attrs, map_loc(sub, desc._0));
    case /* Ppat_exception */14 :
        return exception_(loc, attrs, Curry._2(sub.pat, sub, desc._0));
    case /* Ppat_extension */15 :
        return extension$1(loc, attrs, Curry._2(sub.extension, sub, desc._0));
    
  }
}

function map$7(sub, param) {
  const desc = param.pcl_desc;
  const loc = Curry._2(sub.location, sub, param.pcl_loc);
  const attrs = Curry._2(sub.attributes, sub, param.pcl_attributes);
  switch (desc.TAG | 0) {
    case /* Pcl_constr */0 :
        return constr$1(loc, attrs, map_loc(sub, desc._0), Stdlib__List.map(Curry._1(sub.typ, sub), desc._1));
    case /* Pcl_structure */1 :
        return structure$1(loc, attrs, Curry._2(sub.class_structure, sub, desc._0));
    case /* Pcl_fun */2 :
        return fun_$1(loc, attrs, desc._0, map_opt(Curry._1(sub.expr, sub), desc._1), Curry._2(sub.pat, sub, desc._2), Curry._2(sub.class_expr, sub, desc._3));
    case /* Pcl_apply */3 :
        const partial_arg = Curry._1(sub.expr, sub);
        return apply$2(loc, attrs, Curry._2(sub.class_expr, sub, desc._0), Stdlib__List.map((function (param) {
                          return map_snd(partial_arg, param);
                        }), desc._1));
    case /* Pcl_let */4 :
        return let_$1(loc, attrs, desc._0, Stdlib__List.map(Curry._1(sub.value_binding, sub), desc._1), Curry._2(sub.class_expr, sub, desc._2));
    case /* Pcl_constraint */5 :
        return constraint_$3(loc, attrs, Curry._2(sub.class_expr, sub, desc._0), Curry._2(sub.class_type, sub, desc._1));
    case /* Pcl_extension */6 :
        return extension$7(loc, attrs, Curry._2(sub.extension, sub, desc._0));
    
  }
}

function map_kind(sub, t) {
  if (t.TAG === /* Cfk_virtual */0) {
    return {
            TAG: /* Cfk_virtual */0,
            _0: Curry._2(sub.typ, sub, t._0)
          };
  } else {
    return {
            TAG: /* Cfk_concrete */1,
            _0: t._0,
            _1: Curry._2(sub.expr, sub, t._1)
          };
  }
}

function map_field$1(sub, param) {
  const desc = param.pcf_desc;
  const loc = Curry._2(sub.location, sub, param.pcf_loc);
  const attrs = Curry._2(sub.attributes, sub, param.pcf_attributes);
  switch (desc.TAG | 0) {
    case /* Pcf_inherit */0 :
        return Curry._5(Ast_helper_Cf.inherit_, loc, attrs, desc._0, Curry._2(sub.class_expr, sub, desc._1), desc._2);
    case /* Pcf_val */1 :
        const match = desc._0;
        return Curry._5(Ast_helper_Cf.val_, loc, attrs, map_loc(sub, match[0]), match[1], map_kind(sub, match[2]));
    case /* Pcf_method */2 :
        const match$1 = desc._0;
        return Curry._5(Ast_helper_Cf.method_, loc, attrs, map_loc(sub, match$1[0]), match$1[1], map_kind(sub, match$1[2]));
    case /* Pcf_constraint */3 :
        const match$2 = desc._0;
        return Curry._4(Ast_helper_Cf.constraint_, loc, attrs, Curry._2(sub.typ, sub, match$2[0]), Curry._2(sub.typ, sub, match$2[1]));
    case /* Pcf_initializer */4 :
        return Curry._3(Ast_helper_Cf.initializer_, loc, attrs, Curry._2(sub.expr, sub, desc._0));
    case /* Pcf_attribute */5 :
        return Curry._2(Ast_helper_Cf.attribute, loc, Curry._2(sub.attribute, sub, desc._0));
    case /* Pcf_extension */6 :
        return Curry._3(Ast_helper_Cf.extension, loc, attrs, Curry._2(sub.extension, sub, desc._0));
    
  }
}

function map_structure(sub, param) {
  return {
          pcstr_self: Curry._2(sub.pat, sub, param.pcstr_self),
          pcstr_fields: Stdlib__List.map(Curry._1(sub.class_field, sub), param.pcstr_fields)
        };
}

function class_infos(sub, f, param) {
  const partial_arg = Curry._1(sub.typ, sub);
  return mk$18(Curry._2(sub.location, sub, param.pci_loc), Curry._2(sub.attributes, sub, param.pci_attributes), undefined, undefined, param.pci_virt, Stdlib__List.map((function (param) {
                    return map_fst(partial_arg, param);
                  }), param.pci_params), map_loc(sub, param.pci_name), Curry._1(f, param.pci_expr));
}

function default_mapper_attribute($$this, param) {
  return [
          map_loc($$this, param[0]),
          Curry._2($$this.payload, $$this, param[1])
        ];
}

function default_mapper_attributes($$this, l) {
  return Stdlib__List.map(Curry._1($$this.attribute, $$this), l);
}

function default_mapper_case($$this, param) {
  return {
          pc_lhs: Curry._2($$this.pat, $$this, param.pc_lhs),
          pc_guard: map_opt(Curry._1($$this.expr, $$this), param.pc_guard),
          pc_rhs: Curry._2($$this.expr, $$this, param.pc_rhs)
        };
}

function default_mapper_cases($$this, l) {
  return Stdlib__List.map(Curry._1($$this.case, $$this), l);
}

function default_mapper_class_declaration($$this) {
  const partial_arg = Curry._1($$this.class_expr, $$this);
  return function (param) {
    return class_infos($$this, partial_arg, param);
  };
}

function default_mapper_class_description($$this) {
  const partial_arg = Curry._1($$this.class_type, $$this);
  return function (param) {
    return class_infos($$this, partial_arg, param);
  };
}

function default_mapper_class_type_declaration($$this) {
  const partial_arg = Curry._1($$this.class_type, $$this);
  return function (param) {
    return class_infos($$this, partial_arg, param);
  };
}

function default_mapper_constructor_declaration($$this, param) {
  return constructor(Curry._2($$this.location, $$this, param.pcd_loc), Curry._2($$this.attributes, $$this, param.pcd_attributes), undefined, Stdlib__List.map(Curry._1($$this.typ, $$this), param.pcd_args), map_opt(Curry._1($$this.typ, $$this), param.pcd_res), map_loc($$this, param.pcd_name));
}

function default_mapper_extension($$this, param) {
  return [
          map_loc($$this, param[0]),
          Curry._2($$this.payload, $$this, param[1])
        ];
}

function default_mapper_include_declaration($$this, param) {
  return mk$16(Curry._2($$this.location, $$this, param.pincl_loc), Curry._2($$this.attributes, $$this, param.pincl_attributes), undefined, Curry._2($$this.module_expr, $$this, param.pincl_mod));
}

function default_mapper_include_description($$this, param) {
  return mk$16(Curry._2($$this.location, $$this, param.pincl_loc), Curry._2($$this.attributes, $$this, param.pincl_attributes), undefined, Curry._2($$this.module_type, $$this, param.pincl_mod));
}

function default_mapper_label_declaration($$this, param) {
  return field$1(Curry._2($$this.location, $$this, param.pld_loc), Curry._2($$this.attributes, $$this, param.pld_attributes), undefined, param.pld_mutable, map_loc($$this, param.pld_name), Curry._2($$this.typ, $$this, param.pld_type));
}

function default_mapper_location($$this, l) {
  return l;
}

function default_mapper_module_binding($$this, param) {
  return mk$14(Curry._2($$this.location, $$this, param.pmb_loc), Curry._2($$this.attributes, $$this, param.pmb_attributes), undefined, undefined, map_loc($$this, param.pmb_name), Curry._2($$this.module_expr, $$this, param.pmb_expr));
}

function default_mapper_module_declaration($$this, param) {
  return mk$12(Curry._2($$this.location, $$this, param.pmd_loc), Curry._2($$this.attributes, $$this, param.pmd_attributes), undefined, undefined, map_loc($$this, param.pmd_name), Curry._2($$this.module_type, $$this, param.pmd_type));
}

function default_mapper_module_type_declaration($$this, param) {
  return mk$13(Curry._2($$this.location, $$this, param.pmtd_loc), Curry._2($$this.attributes, $$this, param.pmtd_attributes), undefined, undefined, map_opt(Curry._1($$this.module_type, $$this), param.pmtd_type), map_loc($$this, param.pmtd_name));
}

function default_mapper_open_description($$this, param) {
  return mk$15(Curry._2($$this.location, $$this, param.popen_loc), Curry._2($$this.attributes, $$this, param.popen_attributes), undefined, param.popen_override, map_loc($$this, param.popen_lid));
}

function default_mapper_payload($$this, x) {
  switch (x.TAG | 0) {
    case /* PStr */0 :
        return {
                TAG: /* PStr */0,
                _0: Curry._2($$this.structure, $$this, x._0)
              };
    case /* PTyp */1 :
        return {
                TAG: /* PTyp */1,
                _0: Curry._2($$this.typ, $$this, x._0)
              };
    case /* PPat */2 :
        return {
                TAG: /* PPat */2,
                _0: Curry._2($$this.pat, $$this, x._0),
                _1: map_opt(Curry._1($$this.expr, $$this), x._1)
              };
    
  }
}

function default_mapper_signature($$this, l) {
  return Stdlib__List.map(Curry._1($$this.signature_item, $$this), l);
}

function default_mapper_structure($$this, l) {
  return Stdlib__List.map(Curry._1($$this.structure_item, $$this), l);
}

function default_mapper_value_binding($$this, param) {
  return mk$17(Curry._2($$this.location, $$this, param.pvb_loc), Curry._2($$this.attributes, $$this, param.pvb_attributes), undefined, undefined, Curry._2($$this.pat, $$this, param.pvb_pat), Curry._2($$this.expr, $$this, param.pvb_expr));
}

function default_mapper_value_description($$this, param) {
  return mk$11(Curry._2($$this.location, $$this, param.pval_loc), Curry._2($$this.attributes, $$this, param.pval_attributes), undefined, param.pval_prim, map_loc($$this, param.pval_name), Curry._2($$this.typ, $$this, param.pval_type));
}

const default_mapper = {
  attribute: default_mapper_attribute,
  attributes: default_mapper_attributes,
  case: default_mapper_case,
  cases: default_mapper_cases,
  class_declaration: default_mapper_class_declaration,
  class_description: default_mapper_class_description,
  class_expr: map$7,
  class_field: map_field$1,
  class_signature: map_signature,
  class_structure: map_structure,
  class_type: map$2,
  class_type_declaration: default_mapper_class_type_declaration,
  class_type_field: map_field,
  constructor_declaration: default_mapper_constructor_declaration,
  expr: map$5,
  extension: default_mapper_extension,
  extension_constructor: map_extension_constructor,
  include_declaration: default_mapper_include_declaration,
  include_description: default_mapper_include_description,
  label_declaration: default_mapper_label_declaration,
  location: default_mapper_location,
  module_binding: default_mapper_module_binding,
  module_declaration: default_mapper_module_declaration,
  module_expr: map$4,
  module_type: map$3,
  module_type_declaration: default_mapper_module_type_declaration,
  open_description: default_mapper_open_description,
  pat: map$6,
  payload: default_mapper_payload,
  signature: default_mapper_signature,
  signature_item: map_signature_item,
  structure: default_mapper_structure,
  structure_item: map_structure_item,
  typ: map$1,
  type_declaration: map_type_declaration,
  type_extension: map_type_extension,
  type_kind: map_type_kind,
  value_binding: default_mapper_value_binding,
  value_description: default_mapper_value_description,
  with_constraint: map_with_constraint
};

function height$4(param) {
  if (param) {
    return param._4;
  } else {
    return 0;
  }
}

function create$5(l, x, d, r) {
  const hl = height$4(l);
  const hr = height$4(r);
  return /* Node */{
          _0: l,
          _1: x,
          _2: d,
          _3: r,
          _4: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        };
}

function bal$4(l, x, d, r) {
  const hl = height$4(l);
  const hr = height$4(r);
  if (hl > (hr + 1 | 0)) {
    if (l) {
      const lr = l._3;
      const ld = l._2;
      const lv = l._1;
      const ll = l._0;
      if (height$4(ll) >= height$4(lr)) {
        return create$5(ll, lv, ld, create$5(lr, x, d, r));
      }
      if (lr) {
        return create$5(create$5(ll, lv, ld, lr._0), lr._1, lr._2, create$5(lr._3, x, d, r));
      }
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  8866,
                  11
                ]
              });
    }
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                8866,
                11
              ]
            });
  }
  if (hr <= (hl + 1 | 0)) {
    return create$5(l, x, d, r);
  }
  if (r) {
    const rl = r._0;
    const rr = r._3;
    if (height$4(rr) >= height$4(rl)) {
      return create$5(create$5(l, x, d, rl), r._1, r._2, rr);
    }
    if (rl) {
      return create$5(create$5(l, x, d, rl._0), rl._1, rl._2, create$5(rl._3, r._1, r._2, r._3));
    }
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                8873,
                11
              ]
            });
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              8873,
              11
            ]
          });
}

function add$5(x, data, param) {
  if (!param) {
    return /* Node */{
            _0: /* Empty */0,
            _1: x,
            _2: data,
            _3: /* Empty */0,
            _4: 1
          };
  }
  const r = param._3;
  const d = param._2;
  const v = param._1;
  const l = param._0;
  const c = Caml_obj.caml_compare(x, v);
  if (c === 0) {
    return /* Node */{
            _0: l,
            _1: x,
            _2: data,
            _3: r,
            _4: param._4
          };
  } else if (c < 0) {
    return bal$4(add$5(x, data, l), v, d, r);
  } else {
    return bal$4(l, v, d, add$5(x, data, r));
  }
}

function find$2(x, _param) {
  while(true) {
    const param = _param;
    if (param) {
      const c = Caml_obj.caml_compare(x, param._1);
      if (c === 0) {
        return param._2;
      }
      _param = c < 0 ? param._0 : param._3;
      continue ;
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
  };
}

function mem$4(x, _param) {
  while(true) {
    const param = _param;
    if (!param) {
      return false;
    }
    const c = Caml_obj.caml_compare(x, param._1);
    if (c === 0) {
      return true;
    }
    _param = c < 0 ? param._0 : param._3;
    continue ;
  };
}

function iter$2(f, _param) {
  while(true) {
    const param = _param;
    if (!param) {
      return ;
    }
    iter$2(f, param._0);
    Curry._2(f, param._1, param._2);
    _param = param._3;
    continue ;
  };
}

function fold$4(f, _m, _accu) {
  while(true) {
    const accu = _accu;
    const m = _m;
    if (!m) {
      return accu;
    }
    _accu = Curry._3(f, m._1, m._2, fold$4(f, m._0, accu));
    _m = m._3;
    continue ;
  };
}

const identity = {
  types: /* Empty */0,
  modules: /* Empty */0,
  modtypes: /* Empty */0,
  for_saving: false
};

function add_type(id, p, s) {
  return {
          types: add$5(id, p, s.types),
          modules: s.modules,
          modtypes: s.modtypes,
          for_saving: s.for_saving
        };
}

function add_module(id, p, s) {
  return {
          types: s.types,
          modules: add$5(id, p, s.modules),
          modtypes: s.modtypes,
          for_saving: s.for_saving
        };
}

function add_modtype(id, ty, s) {
  return {
          types: s.types,
          modules: s.modules,
          modtypes: add$5(id, ty, s.modtypes),
          for_saving: s.for_saving
        };
}

function for_saving(s) {
  return {
          types: s.types,
          modules: s.modules,
          modtypes: s.modtypes,
          for_saving: true
        };
}

function loc(s, x) {
  if (s.for_saving && !keep_locs.contents) {
    return none;
  } else {
    return x;
  }
}

const newrecord = Caml_obj.caml_obj_dup(default_mapper);

newrecord.location = (function (_this, _loc) {
    return none;
  });

function is_not_doc(param) {
  switch (param[0].txt) {
    case "doc" :
    case "ocaml.doc" :
    case "ocaml.text" :
    case "text" :
        return false;
    default:
      return true;
  }
}

function attrs(s, x) {
  const x$1 = s.for_saving && !keep_docs.contents ? Stdlib__List.filter(is_not_doc, x) : x;
  if (s.for_saving && !keep_locs.contents) {
    return Curry._2(newrecord.attributes, newrecord, x$1);
  } else {
    return x$1;
  }
}

function module_path(s, p) {
  switch (p.TAG | 0) {
    case /* Pident */0 :
        try {
          return find$2(p._0, s.modules);
        }
        catch (raw_exn){
          const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.MEL_EXN_ID === Stdlib.Not_found) {
            return p;
          }
          throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
        }
    case /* Pdot */1 :
        return {
                TAG: /* Pdot */1,
                _0: module_path(s, p._0),
                _1: p._1,
                _2: p._2
              };
    case /* Papply */2 :
        return {
                TAG: /* Papply */2,
                _0: module_path(s, p._0),
                _1: module_path(s, p._1)
              };
    
  }
}

function modtype_path(s, p) {
  switch (p.TAG | 0) {
    case /* Pident */0 :
        try {
          const p$1 = find$2(p._0, s.modtypes);
          if (p$1.TAG === /* Mty_ident */0) {
            return p$1._0;
          } else {
            return fatal_error("Subst.modtype_path");
          }
        }
        catch (raw_exn){
          const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.MEL_EXN_ID === Stdlib.Not_found) {
            return p;
          }
          throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
        }
    case /* Pdot */1 :
        return {
                TAG: /* Pdot */1,
                _0: module_path(s, p._0),
                _1: p._1,
                _2: p._2
              };
    case /* Papply */2 :
        return fatal_error("Subst.modtype_path");
    
  }
}

function type_path(s, p) {
  switch (p.TAG | 0) {
    case /* Pident */0 :
        try {
          return find$2(p._0, s.types);
        }
        catch (raw_exn){
          const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.MEL_EXN_ID === Stdlib.Not_found) {
            return p;
          }
          throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
        }
    case /* Pdot */1 :
        return {
                TAG: /* Pdot */1,
                _0: module_path(s, p._0),
                _1: p._1,
                _2: p._2
              };
    case /* Papply */2 :
        return fatal_error("Subst.type_path");
    
  }
}

const new_id$1 = {
  contents: -1
};

function newpersty(desc) {
  new_id$1.contents = new_id$1.contents - 1 | 0;
  return {
          desc: desc,
          level: 100000000,
          id: new_id$1.contents
        };
}

function norm(d) {
  if (typeof d === "number") {
    return d;
  }
  switch (d.TAG | 0) {
    case /* Tvar */0 :
        if (d._0 !== undefined) {
          return d;
        } else {
          return {
                  TAG: /* Tvar */0,
                  _0: undefined
                };
        }
    case /* Tunivar */9 :
        if (d._0 !== undefined) {
          return d;
        } else {
          return {
                  TAG: /* Tunivar */9,
                  _0: undefined
                };
        }
    default:
      return d;
  }
}

function typexp(s, ty) {
  const ty$1 = repr(ty);
  const desc = ty$1.desc;
  let exit = 0;
  if (typeof desc === "number") {
    exit = 1;
  } else {
    switch (desc.TAG | 0) {
      case /* Tsubst */7 :
          return desc._0;
      case /* Tvar */0 :
      case /* Tunivar */9 :
          exit = 2;
          break;
      default:
        exit = 1;
    }
  }
  switch (exit) {
    case 1 :
        const desc$1 = ty$1.desc;
        save_desc(ty$1, desc$1);
        const ty$p = s.for_saving ? newpersty({
                TAG: /* Tvar */0,
                _0: undefined
              }) : newty2(100000000, {
                TAG: /* Tvar */0,
                _0: undefined
              });
        ty$1.desc = {
          TAG: /* Tsubst */7,
          _0: ty$p
        };
        let tmp;
        let exit$1 = 0;
        if (typeof desc$1 === "number") {
          exit$1 = 3;
        } else {
          switch (desc$1.TAG | 0) {
            case /* Tconstr */3 :
                tmp = {
                  TAG: /* Tconstr */3,
                  _0: type_path(s, desc$1._0),
                  _1: Stdlib__List.map((function (param) {
                          return typexp(s, param);
                        }), desc$1._1),
                  _2: {
                    contents: /* Mnil */0
                  }
                };
                break;
            case /* Tobject */4 :
                const match = desc$1._1.contents;
                tmp = {
                  TAG: /* Tobject */4,
                  _0: typexp(s, desc$1._0),
                  _1: {
                    contents: match !== undefined ? [
                        type_path(s, match[0]),
                        Stdlib__List.map((function (param) {
                                return typexp(s, param);
                              }), match[1])
                      ] : undefined
                  }
                };
                break;
            case /* Tfield */5 :
                const m = desc$1._0;
                if (s === identity && ty$1.level < 100000000 && m === dummy_method) {
                  tmp = {
                    TAG: /* Tfield */5,
                    _0: m,
                    _1: desc$1._1,
                    _2: desc$1._2,
                    _3: typexp(s, desc$1._3)
                  };
                } else if (Caml_obj.caml_equal(field_kind_repr(desc$1._1), /* Fabsent */1)) {
                  tmp = {
                    TAG: /* Tlink */6,
                    _0: typexp(s, desc$1._3)
                  };
                } else {
                  exit$1 = 3;
                }
                break;
            case /* Tvariant */8 :
                const row = row_repr_aux(/* [] */0, desc$1._0);
                const more = repr(row.row_more);
                const match$1 = more.desc;
                let exit$2 = 0;
                if (typeof match$1 === "number" || match$1.TAG !== /* Tsubst */7) {
                  exit$2 = 4;
                } else {
                  const match$2 = match$1._0.desc;
                  if (typeof match$2 === "number" || match$2.TAG !== /* Ttuple */2) {
                    exit$2 = 4;
                  } else {
                    const match$3 = match$2._0;
                    if (match$3) {
                      const match$4 = match$3.tl;
                      if (match$4 && !match$4.tl) {
                        const ty2 = match$4.hd;
                        ty$1.desc = {
                          TAG: /* Tsubst */7,
                          _0: ty2
                        };
                        tmp = {
                          TAG: /* Tlink */6,
                          _0: ty2
                        };
                      } else {
                        exit$2 = 4;
                      }
                    } else {
                      exit$2 = 4;
                    }
                  }
                }
                if (exit$2 === 4) {
                  let dup = true;
                  if (!s.for_saving) {
                    let tmp$1 = true;
                    if (more.level !== 100000000) {
                      let tmp$2 = true;
                      if (!static_row(row)) {
                        const match$5 = more.desc;
                        let tmp$3;
                        tmp$3 = typeof match$5 === "number" || match$5.TAG !== /* Tconstr */3 ? false : true;
                        tmp$2 = tmp$3;
                      }
                      tmp$1 = tmp$2;
                    }
                    dup = tmp$1;
                  }
                  const ty$2 = more.desc;
                  let more$p;
                  let exit$3 = 0;
                  if (typeof ty$2 === "number") {
                    more$p = typexp(s, more);
                  } else {
                    switch (ty$2.TAG | 0) {
                      case /* Tconstr */3 :
                          more$p = typexp(s, more);
                          break;
                      case /* Tsubst */7 :
                          more$p = ty$2._0;
                          break;
                      case /* Tvar */0 :
                      case /* Tunivar */9 :
                          exit$3 = 5;
                          break;
                      default:
                        throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                                  MEL_EXN_ID: "Assert_failure",
                                  _1: [
                                    "jscomp/test/ocaml_typedtree_test.ml",
                                    9179,
                                    23
                                  ]
                                });
                    }
                  }
                  if (exit$3 === 5) {
                    save_desc(more, more.desc);
                    more$p = s.for_saving ? newpersty(norm(more.desc)) : (
                        dup && is_Tvar(more) ? newty2(100000000, more.desc) : more
                      );
                  }
                  more.desc = {
                    TAG: /* Tsubst */7,
                    _0: newty2(100000000, {
                          TAG: /* Ttuple */2,
                          _0: {
                            hd: more$p,
                            tl: {
                              hd: ty$p,
                              tl: /* [] */0
                            }
                          }
                        })
                  };
                  const row$1 = copy_row((function (param) {
                          return typexp(s, param);
                        }), true, row, !dup, more$p);
                  const match$6 = row$1.row_name;
                  tmp = match$6 !== undefined ? ({
                        TAG: /* Tvariant */8,
                        _0: {
                          row_fields: row$1.row_fields,
                          row_more: row$1.row_more,
                          row_bound: row$1.row_bound,
                          row_closed: row$1.row_closed,
                          row_fixed: row$1.row_fixed,
                          row_name: [
                            type_path(s, match$6[0]),
                            match$6[1]
                          ]
                        }
                      }) : ({
                        TAG: /* Tvariant */8,
                        _0: row$1
                      });
                }
                break;
            case /* Tpackage */11 :
                tmp = {
                  TAG: /* Tpackage */11,
                  _0: modtype_path(s, desc$1._0),
                  _1: desc$1._1,
                  _2: Stdlib__List.map((function (param) {
                          return typexp(s, param);
                        }), desc$1._2)
                };
                break;
            default:
              exit$1 = 3;
          }
        }
        if (exit$1 === 3) {
          tmp = copy_type_desc(undefined, (function (param) {
                  return typexp(s, param);
                }), desc$1);
        }
        ty$p.desc = tmp;
        return ty$p;
    case 2 :
        if (!(s.for_saving || ty$1.id < 0)) {
          return ty$1;
        }
        const ty$p$1 = s.for_saving ? newpersty(norm(desc)) : newty2(ty$1.level, desc);
        save_desc(ty$1, desc);
        ty$1.desc = {
          TAG: /* Tsubst */7,
          _0: ty$p$1
        };
        return ty$p$1;
    
  }
}

function type_expr(s, ty) {
  const ty$p = typexp(s, ty);
  cleanup_types(undefined);
  return ty$p;
}

function type_declaration(s, decl) {
  const cstrs = decl.type_kind;
  let tmp;
  tmp = typeof cstrs === "number" ? (
      cstrs === /* Type_abstract */0 ? /* Type_abstract */0 : /* Type_open */1
    ) : (
      cstrs.TAG === /* Type_record */0 ? ({
            TAG: /* Type_record */0,
            _0: Stdlib__List.map((function (l) {
                    return {
                            ld_id: l.ld_id,
                            ld_mutable: l.ld_mutable,
                            ld_type: typexp(s, l.ld_type),
                            ld_loc: loc(s, l.ld_loc),
                            ld_attributes: attrs(s, l.ld_attributes)
                          };
                  }), cstrs._0),
            _1: cstrs._1
          }) : ({
            TAG: /* Type_variant */1,
            _0: Stdlib__List.map((function (c) {
                    return {
                            cd_id: c.cd_id,
                            cd_args: Stdlib__List.map((function (param) {
                                    return typexp(s, param);
                                  }), c.cd_args),
                            cd_res: may_map((function (param) {
                                    return typexp(s, param);
                                  }), c.cd_res),
                            cd_loc: loc(s, c.cd_loc),
                            cd_attributes: attrs(s, c.cd_attributes)
                          };
                  }), cstrs._0)
          })
    );
  const ty = decl.type_manifest;
  const decl_type_params = Stdlib__List.map((function (param) {
          return typexp(s, param);
        }), decl.type_params);
  const decl_type_arity = decl.type_arity;
  const decl_type_private = decl.type_private;
  const decl_type_manifest = ty !== undefined ? typexp(s, ty) : undefined;
  const decl_type_variance = decl.type_variance;
  const decl_type_loc = loc(s, decl.type_loc);
  const decl_type_attributes = attrs(s, decl.type_attributes);
  const decl$1 = {
    type_params: decl_type_params,
    type_arity: decl_type_arity,
    type_kind: tmp,
    type_private: decl_type_private,
    type_manifest: decl_type_manifest,
    type_variance: decl_type_variance,
    type_newtype_level: undefined,
    type_loc: decl_type_loc,
    type_attributes: decl_type_attributes
  };
  cleanup_types(undefined);
  return decl$1;
}

function class_signature(s, sign) {
  return {
          csig_self: typexp(s, sign.csig_self),
          csig_vars: Curry._2(Meths.map, (function (param) {
                  return [
                          param[0],
                          param[1],
                          typexp(s, param[2])
                        ];
                }), sign.csig_vars),
          csig_concr: sign.csig_concr,
          csig_inher: Stdlib__List.map((function (param) {
                  return [
                          type_path(s, param[0]),
                          Stdlib__List.map((function (param) {
                                  return typexp(s, param);
                                }), param[1])
                        ];
                }), sign.csig_inher)
        };
}

function class_type(s, sign) {
  switch (sign.TAG | 0) {
    case /* Cty_constr */0 :
        return {
                TAG: /* Cty_constr */0,
                _0: type_path(s, sign._0),
                _1: Stdlib__List.map((function (param) {
                        return typexp(s, param);
                      }), sign._1),
                _2: class_type(s, sign._2)
              };
    case /* Cty_signature */1 :
        return {
                TAG: /* Cty_signature */1,
                _0: class_signature(s, sign._0)
              };
    case /* Cty_arrow */2 :
        return {
                TAG: /* Cty_arrow */2,
                _0: sign._0,
                _1: typexp(s, sign._1),
                _2: class_type(s, sign._2)
              };
    
  }
}

function class_declaration(s, decl) {
  const ty = decl.cty_new;
  const decl$1 = {
    cty_params: Stdlib__List.map((function (param) {
            return typexp(s, param);
          }), decl.cty_params),
    cty_type: class_type(s, decl.cty_type),
    cty_path: type_path(s, decl.cty_path),
    cty_new: ty !== undefined ? typexp(s, ty) : undefined,
    cty_variance: decl.cty_variance,
    cty_loc: loc(s, decl.cty_loc),
    cty_attributes: attrs(s, decl.cty_attributes)
  };
  if (!s.for_saving) {
    cleanup_types(undefined);
  }
  return decl$1;
}

function cltype_declaration(s, decl) {
  const decl_clty_params = Stdlib__List.map((function (param) {
          return typexp(s, param);
        }), decl.clty_params);
  const decl_clty_type = class_type(s, decl.clty_type);
  const decl_clty_path = type_path(s, decl.clty_path);
  const decl_clty_variance = decl.clty_variance;
  const decl_clty_loc = loc(s, decl.clty_loc);
  const decl_clty_attributes = attrs(s, decl.clty_attributes);
  const decl$1 = {
    clty_params: decl_clty_params,
    clty_type: decl_clty_type,
    clty_path: decl_clty_path,
    clty_variance: decl_clty_variance,
    clty_loc: decl_clty_loc,
    clty_attributes: decl_clty_attributes
  };
  cleanup_types(undefined);
  return decl$1;
}

function class_type$1(s, cty) {
  const cty$1 = class_type(s, cty);
  cleanup_types(undefined);
  return cty$1;
}

function value_description(s, descr) {
  return {
          val_type: type_expr(s, descr.val_type),
          val_kind: descr.val_kind,
          val_loc: loc(s, descr.val_loc),
          val_attributes: attrs(s, descr.val_attributes)
        };
}

function extension_constructor(s, ext) {
  const ext_ext_type_path = type_path(s, ext.ext_type_path);
  const ext_ext_type_params = Stdlib__List.map((function (param) {
          return typexp(s, param);
        }), ext.ext_type_params);
  const ext_ext_args = Stdlib__List.map((function (param) {
          return typexp(s, param);
        }), ext.ext_args);
  const ext_ext_ret_type = may_map((function (param) {
          return typexp(s, param);
        }), ext.ext_ret_type);
  const ext_ext_private = ext.ext_private;
  const ext_ext_loc = s.for_saving ? none : ext.ext_loc;
  const ext_ext_attributes = attrs(s, ext.ext_attributes);
  const ext$1 = {
    ext_type_path: ext_ext_type_path,
    ext_type_params: ext_ext_type_params,
    ext_args: ext_ext_args,
    ext_ret_type: ext_ext_ret_type,
    ext_private: ext_ext_private,
    ext_loc: ext_ext_loc,
    ext_attributes: ext_ext_attributes
  };
  cleanup_types(undefined);
  return ext$1;
}

function rename_bound_idents(_s, _idents, _param) {
  while(true) {
    const param = _param;
    const idents = _idents;
    const s = _s;
    if (!param) {
      return [
              Stdlib__List.rev(idents),
              s
            ];
    }
    const match = param.hd;
    switch (match.TAG | 0) {
      case /* Sig_type */1 :
          const id = match._0;
          const id$p = rename(id);
          _param = param.tl;
          _idents = {
            hd: id$p,
            tl: idents
          };
          _s = add_type(id, {
                TAG: /* Pident */0,
                _0: id$p
              }, s);
          continue ;
      case /* Sig_module */3 :
          const id$1 = match._0;
          const id$p$1 = rename(id$1);
          _param = param.tl;
          _idents = {
            hd: id$p$1,
            tl: idents
          };
          _s = add_module(id$1, {
                TAG: /* Pident */0,
                _0: id$p$1
              }, s);
          continue ;
      case /* Sig_modtype */4 :
          const id$2 = match._0;
          const id$p$2 = rename(id$2);
          _param = param.tl;
          _idents = {
            hd: id$p$2,
            tl: idents
          };
          _s = add_modtype(id$2, {
                TAG: /* Mty_ident */0,
                _0: {
                  TAG: /* Pident */0,
                  _0: id$p$2
                }
              }, s);
          continue ;
      default:
        const id$p$3 = rename(match._0);
        _param = param.tl;
        _idents = {
          hd: id$p$3,
          tl: idents
        };
        continue ;
    }
  };
}

function modtype(s, mty) {
  switch (mty.TAG | 0) {
    case /* Mty_ident */0 :
        const p = mty._0;
        switch (p.TAG | 0) {
          case /* Pident */0 :
              try {
                return find$2(p._0, s.modtypes);
              }
              catch (raw_exn){
                const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                if (exn.MEL_EXN_ID === Stdlib.Not_found) {
                  return mty;
                }
                throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
              }
          case /* Pdot */1 :
              return {
                      TAG: /* Mty_ident */0,
                      _0: {
                        TAG: /* Pdot */1,
                        _0: module_path(s, p._0),
                        _1: p._1,
                        _2: p._2
                      }
                    };
          case /* Papply */2 :
              return fatal_error("Subst.modtype");
          
        }
    case /* Mty_signature */1 :
        return {
                TAG: /* Mty_signature */1,
                _0: signature$2(s, mty._0)
              };
    case /* Mty_functor */2 :
        const id = mty._0;
        const id$p = rename(id);
        return {
                TAG: /* Mty_functor */2,
                _0: id$p,
                _1: may_map((function (param) {
                        return modtype(s, param);
                      }), mty._1),
                _2: modtype(add_module(id, {
                          TAG: /* Pident */0,
                          _0: id$p
                        }, s), mty._2)
              };
    case /* Mty_alias */3 :
        return {
                TAG: /* Mty_alias */3,
                _0: module_path(s, mty._0)
              };
    
  }
}

function signature$2(s, sg) {
  const match = rename_bound_idents(s, /* [] */0, sg);
  const s$p = match[1];
  return Stdlib__List.map2((function (param, param$1) {
                switch (param.TAG | 0) {
                  case /* Sig_value */0 :
                      return {
                              TAG: /* Sig_value */0,
                              _0: param$1,
                              _1: value_description(s$p, param._1)
                            };
                  case /* Sig_type */1 :
                      return {
                              TAG: /* Sig_type */1,
                              _0: param$1,
                              _1: type_declaration(s$p, param._1),
                              _2: param._2
                            };
                  case /* Sig_typext */2 :
                      return {
                              TAG: /* Sig_typext */2,
                              _0: param$1,
                              _1: extension_constructor(s$p, param._1),
                              _2: param._2
                            };
                  case /* Sig_module */3 :
                      return {
                              TAG: /* Sig_module */3,
                              _0: param$1,
                              _1: module_declaration(s$p, param._1),
                              _2: param._2
                            };
                  case /* Sig_modtype */4 :
                      return {
                              TAG: /* Sig_modtype */4,
                              _0: param$1,
                              _1: modtype_declaration(s$p, param._1)
                            };
                  case /* Sig_class */5 :
                      return {
                              TAG: /* Sig_class */5,
                              _0: param$1,
                              _1: class_declaration(s$p, param._1),
                              _2: param._2
                            };
                  case /* Sig_class_type */6 :
                      return {
                              TAG: /* Sig_class_type */6,
                              _0: param$1,
                              _1: cltype_declaration(s$p, param._1),
                              _2: param._2
                            };
                  
                }
              }), sg, match[0]);
}

function module_declaration(s, decl) {
  return {
          md_type: modtype(s, decl.md_type),
          md_attributes: attrs(s, decl.md_attributes),
          md_loc: loc(s, decl.md_loc)
        };
}

function modtype_declaration(s, decl) {
  return {
          mtd_type: may_map((function (param) {
                  return modtype(s, param);
                }), decl.mtd_type),
          mtd_attributes: attrs(s, decl.mtd_attributes),
          mtd_loc: loc(s, decl.mtd_loc)
        };
}

const add_delayed_check_forward = {
  contents: (function (param) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  9717,
                  46
                ]
              });
    })
};

const value_declarations = Stdlib__Hashtbl.create(undefined, 16);

const type_declarations = Stdlib__Hashtbl.create(undefined, 16);

function add_constructor_usage(cu, param) {
  switch (param) {
    case /* Positive */0 :
        cu.cu_positive = true;
        return ;
    case /* Pattern */1 :
        cu.cu_pattern = true;
        return ;
    case /* Privatize */2 :
        cu.cu_privatize = true;
        return ;
    
  }
}

const used_constructors = Stdlib__Hashtbl.create(undefined, 16);

const prefixed_sg = Stdlib__Hashtbl.create(undefined, 113);

const $$Error$2 = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Env.Error");

function force(f, x) {
  const x$1 = x.contents;
  switch (x$1.TAG | 0) {
    case /* Done */0 :
        return x$1._0;
    case /* Raise */1 :
        throw new Caml_js_exceptions.MelangeError(x$1._0.MEL_EXN_ID, x$1._0);
    case /* Thunk */2 :
        try {
          const y = Curry._1(f, x$1._0);
          x.contents = {
            TAG: /* Done */0,
            _0: y
          };
          return y;
        }
        catch (raw_e){
          const e = Caml_js_exceptions.internalToOCamlException(raw_e);
          x.contents = {
            TAG: /* Raise */1,
            _0: e
          };
          throw new Caml_js_exceptions.MelangeError(e.MEL_EXN_ID, e);
        }
    
  }
}

function get_arg(x) {
  const a = x.contents;
  switch (a.TAG | 0) {
    case /* Done */0 :
    case /* Raise */1 :
        return ;
    case /* Thunk */2 :
        return Caml_option.some(a._0);
    
  }
}

function nothing(param) {
  
}

function already_defined(s, tbl) {
  try {
    find_name(s, tbl);
    return true;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return false;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function add$6(kind, slot, id, x, tbl, ref_tbl) {
  const slot$1 = slot !== undefined ? (function (param) {
        const s = id.name;
        Curry._3(slot, kind, s, already_defined(s, ref_tbl));
      }) : nothing;
  return add(id, [
              x,
              slot$1
            ], tbl);
}

function find_same$1(id, tbl) {
  const match = find_same(id, tbl);
  Curry._1(match[1], undefined);
  return match[0];
}

function find_name$1(s, tbl) {
  const match = find_name(s, tbl);
  Curry._1(match[1], undefined);
  return match[0];
}

function fold_name(f) {
  return function (param, param$1) {
    const f$1 = function (k, param) {
      return Curry._2(f, k, param[0]);
    };
    const f$2 = function (k) {
      return Curry._2(f$1, k.ident, k.data);
    };
    let _stack = /* [] */0;
    let _accu = param$1;
    let _param = param;
    while(true) {
      const param$2 = _param;
      const accu = _accu;
      const stack = _stack;
      if (param$2) {
        _param = param$2._2;
        _accu = Curry._2(f$2, param$2._1, accu);
        _stack = {
          hd: param$2._0,
          tl: stack
        };
        continue ;
      }
      if (!stack) {
        return accu;
      }
      _param = stack.hd;
      _stack = stack.tl;
      continue ;
    };
  };
}

function subst_modtype_maker(param) {
  return modtype(param[0], param[1]);
}

const empty = {
  values: /* Empty */0,
  constrs: /* Empty */0,
  labels: /* Empty */0,
  types: /* Empty */0,
  modules: /* Empty */0,
  modtypes: /* Empty */0,
  components: /* Empty */0,
  classes: /* Empty */0,
  cltypes: /* Empty */0,
  functor_args: /* Empty */0,
  summary: /* Env_empty */0,
  local_constraints: false,
  gadt_instances: /* [] */0,
  flags: 0
};

function in_signature(env) {
  return {
          values: env.values,
          constrs: env.constrs,
          labels: env.labels,
          types: env.types,
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: env.summary,
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags | 1
        };
}

function implicit_coercion(env) {
  return {
          values: env.values,
          constrs: env.constrs,
          labels: env.labels,
          types: env.types,
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: env.summary,
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags | 2
        };
}

function is_in_signature(env) {
  return (env.flags & 1) !== 0;
}

function is_implicit_coercion(env) {
  return (env.flags & 2) !== 0;
}

const components_of_module$p = {
  contents: (function (env, sub, path, mty) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  9965,
                  32
                ]
              });
    })
};

const components_of_module_maker$p = {
  contents: (function (param) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  9968,
                  37
                ]
              });
    })
};

const components_of_functor_appl$p = {
  contents: (function (f, p1, p2) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  9971,
                  23
                ]
              });
    })
};

const check_modtype_inclusion = {
  contents: (function (env, mty1, path1, mty2) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  9975,
                  35
                ]
              });
    })
};

const strengthen = {
  contents: (function (env, mty, path) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  9979,
                  28
                ]
              });
    })
};

const current_unit = {
  contents: ""
};

const persistent_structures = Stdlib__Hashtbl.create(undefined, 17);

const crc_units = Stdlib__Hashtbl.create(undefined, 13);

const funarg$2 = {
  compare: Stdlib__String.compare
};

function height$5(param) {
  if (param) {
    return param.h;
  } else {
    return 0;
  }
}

function create$6(l, v, r) {
  const hl = l ? l.h : 0;
  const hr = r ? r.h : 0;
  return /* Node */{
          l: l,
          v: v,
          r: r,
          h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        };
}

function bal$5(l, v, r) {
  const hl = l ? l.h : 0;
  const hr = r ? r.h : 0;
  if (hl > (hr + 2 | 0)) {
    if (l) {
      const lr = l.r;
      const lv = l.v;
      const ll = l.l;
      if (height$5(ll) >= height$5(lr)) {
        return create$6(ll, lv, create$6(lr, v, r));
      }
      if (lr) {
        return create$6(create$6(ll, lv, lr.l), lr.v, create$6(lr.r, v, r));
      }
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
                MEL_EXN_ID: "Invalid_argument",
                _1: "Set.bal"
              });
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Set.bal"
            });
  }
  if (hr <= (hl + 2 | 0)) {
    return /* Node */{
            l: l,
            v: v,
            r: r,
            h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          };
  }
  if (r) {
    const rr = r.r;
    const rv = r.v;
    const rl = r.l;
    if (height$5(rr) >= height$5(rl)) {
      return create$6(create$6(l, v, rl), rv, rr);
    }
    if (rl) {
      return create$6(create$6(l, v, rl.l), rl.v, create$6(rl.r, rv, rr));
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Set.bal"
            });
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Set.bal"
          });
}

function add$7(x, t) {
  if (!t) {
    return /* Node */{
            l: /* Empty */0,
            v: x,
            r: /* Empty */0,
            h: 1
          };
  }
  const r = t.r;
  const v = t.v;
  const l = t.l;
  const c = Curry._2(funarg$2.compare, x, v);
  if (c === 0) {
    return t;
  }
  if (c < 0) {
    const ll = add$7(x, l);
    if (l === ll) {
      return t;
    } else {
      return bal$5(ll, v, r);
    }
  }
  const rr = add$7(x, r);
  if (r === rr) {
    return t;
  } else {
    return bal$5(l, v, rr);
  }
}

function fold$5(f, _s, _accu) {
  while(true) {
    const accu = _accu;
    const s = _s;
    if (!s) {
      return accu;
    }
    _accu = Curry._2(f, s.v, fold$5(f, s.l, accu));
    _s = s.r;
    continue ;
  };
}

function elements_aux$2(_accu, _param) {
  while(true) {
    const param = _param;
    const accu = _accu;
    if (!param) {
      return accu;
    }
    _param = param.l;
    _accu = {
      hd: param.v,
      tl: elements_aux$2(accu, param.r)
    };
    continue ;
  };
}

function elements$2(s) {
  return elements_aux$2(/* [] */0, s);
}

const imported_units = {
  contents: /* Empty */0
};

function add_import(s) {
  imported_units.contents = Curry._2(add$7, s, imported_units.contents);
}

function check_consistency(ps) {
  if (ps.ps_crcs_checked) {
    return ;
  }
  try {
    Stdlib__List.iter((function (param) {
            const crco = param[1];
            if (crco === undefined) {
              return ;
            }
            const name = param[0];
            add_import(name);
            let source = ps.ps_filename;
            try {
              const match = Stdlib__Hashtbl.find(crc_units, name);
              if (!Caml_obj.caml_notequal(crco, match[0])) {
                return ;
              }
              throw new Caml_js_exceptions.MelangeError(Inconsistency, {
                        MEL_EXN_ID: Inconsistency,
                        _1: name,
                        _2: source,
                        _3: match[1]
                      });
            }
            catch (raw_exn){
              const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn.MEL_EXN_ID === Stdlib.Not_found) {
                return Stdlib__Hashtbl.add(crc_units, name, [
                            crco,
                            source
                          ]);
              }
              throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
            }
          }), ps.ps_crcs);
    ps.ps_crcs_checked = true;
    return ;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Inconsistency) {
      throw new Caml_js_exceptions.MelangeError($$Error$2, {
                MEL_EXN_ID: $$Error$2,
                _1: {
                  TAG: /* Inconsistent_import */1,
                  _0: exn._1,
                  _1: exn._3,
                  _2: exn._2
                }
              });
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function save_pers_struct(crc, ps) {
  const modname = ps.ps_name;
  Stdlib__Hashtbl.add(persistent_structures, modname, ps);
  set$1(crc_units, modname, crc, ps.ps_filename);
  add_import(modname);
}

function read_pers_struct(modname, filename) {
  const cmi = read_cmi(filename);
  const name = cmi.cmi_name;
  const sign = cmi.cmi_sign;
  const crcs = cmi.cmi_crcs;
  const flags = cmi.cmi_flags;
  const comps = Curry._4(components_of_module$p.contents, empty, identity, {
        TAG: /* Pident */0,
        _0: {
          stamp: 0,
          name: name,
          flags: 1
        }
      }, {
        TAG: /* Mty_signature */1,
        _0: sign
      });
  const ps = {
    ps_name: name,
    ps_sig: sign,
    ps_comps: comps,
    ps_crcs: crcs,
    ps_crcs_checked: false,
    ps_filename: filename,
    ps_flags: flags
  };
  if (ps.ps_name !== modname) {
    throw new Caml_js_exceptions.MelangeError($$Error$2, {
              MEL_EXN_ID: $$Error$2,
              _1: {
                TAG: /* Illegal_renaming */0,
                _0: modname,
                _1: ps.ps_name,
                _2: filename
              }
            });
  }
  add_import(name);
  Stdlib__List.iter((function (param) {
          if (recursive_types.contents) {
            return ;
          }
          throw new Caml_js_exceptions.MelangeError($$Error$2, {
                    MEL_EXN_ID: $$Error$2,
                    _1: {
                      TAG: /* Need_recursive_types */2,
                      _0: ps.ps_name,
                      _1: current_unit.contents
                    }
                  });
        }), ps.ps_flags);
  Stdlib__Hashtbl.add(persistent_structures, modname, ps);
  return ps;
}

function find_pers_struct(checkOpt, name) {
  const check = checkOpt !== undefined ? checkOpt : true;
  if (name === "*predef*") {
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
  }
  let r;
  try {
    r = Caml_option.some(Stdlib__Hashtbl.find(persistent_structures, name));
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      r = undefined;
    } else {
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  }
  let ps;
  if (r !== undefined) {
    const sg = Caml_option.valFromOption(r);
    if (sg !== undefined) {
      ps = sg;
    } else {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
    }
  } else {
    add_import(name);
    let filename;
    try {
      filename = find_in_path_uncap(load_path.contents, name + ".cmi");
    }
    catch (raw_exn$1){
      const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
      if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
        Stdlib__Hashtbl.add(persistent_structures, name, undefined);
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                  MEL_EXN_ID: Stdlib.Not_found
                });
      }
      throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
    }
    ps = read_pers_struct(name, filename);
  }
  if (check) {
    check_consistency(ps);
  }
  return ps;
}

function find_module_descr(path, env) {
  switch (path.TAG | 0) {
    case /* Pident */0 :
        const id = path._0;
        try {
          return find_same$1(id, env.components)[1];
        }
        catch (raw_exn){
          const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.MEL_EXN_ID === Stdlib.Not_found) {
            if (id.stamp === 0 && id.name !== current_unit.contents) {
              return find_pers_struct(undefined, id.name).ps_comps;
            }
            throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                      MEL_EXN_ID: Stdlib.Not_found
                    });
          }
          throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
        }
    case /* Pdot */1 :
        const c = force(components_of_module_maker$p.contents, find_module_descr(path._0, env));
        if (c.TAG === /* Structure_comps */0) {
          return find$2(path._1, c._0.comp_components)[0];
        }
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                  MEL_EXN_ID: Stdlib.Not_found
                });
    case /* Papply */2 :
        const p1 = path._0;
        const f = force(components_of_module_maker$p.contents, find_module_descr(p1, env));
        if (f.TAG !== /* Structure_comps */0) {
          return Curry._3(components_of_functor_appl$p.contents, f._0, p1, path._1);
        }
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                  MEL_EXN_ID: Stdlib.Not_found
                });
    
  }
}

function find$3(proj1, proj2, path, env) {
  switch (path.TAG | 0) {
    case /* Pident */0 :
        return find_same$1(path._0, Curry._1(proj1, env))[1];
    case /* Pdot */1 :
        const c = force(components_of_module_maker$p.contents, find_module_descr(path._0, env));
        if (c.TAG === /* Structure_comps */0) {
          return find$2(path._1, Curry._1(proj2, c._0))[0];
        }
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                  MEL_EXN_ID: Stdlib.Not_found
                });
    case /* Papply */2 :
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                  MEL_EXN_ID: Stdlib.Not_found
                });
    
  }
}

function find_value(param, param$1) {
  return find$3((function (env) {
                return env.values;
              }), (function (sc) {
                return sc.comp_values;
              }), param, param$1);
}

function find_type_full(param, param$1) {
  return find$3((function (env) {
                return env.types;
              }), (function (sc) {
                return sc.comp_types;
              }), param, param$1);
}

function find_modtype(param, param$1) {
  return find$3((function (env) {
                return env.modtypes;
              }), (function (sc) {
                return sc.comp_modtypes;
              }), param, param$1);
}

function find_class(param, param$1) {
  return find$3((function (env) {
                return env.classes;
              }), (function (sc) {
                return sc.comp_classes;
              }), param, param$1);
}

function find_module(alias, path, env) {
  switch (path.TAG | 0) {
    case /* Pident */0 :
        const id = path._0;
        try {
          return find_same$1(id, env.modules)[1];
        }
        catch (raw_exn){
          const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.MEL_EXN_ID === Stdlib.Not_found) {
            if (id.stamp === 0 && id.name !== current_unit.contents) {
              const ps = find_pers_struct(undefined, id.name);
              return {
                      md_type: {
                        TAG: /* Mty_signature */1,
                        _0: ps.ps_sig
                      },
                      md_attributes: /* [] */0,
                      md_loc: none
                    };
            }
            throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                      MEL_EXN_ID: Stdlib.Not_found
                    });
          }
          throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
        }
    case /* Pdot */1 :
        const c = force(components_of_module_maker$p.contents, find_module_descr(path._0, env));
        if (c.TAG === /* Structure_comps */0) {
          const match = find$2(path._1, c._0.comp_modules);
          const md_type = force(subst_modtype_maker, match[0]);
          return {
                  md_type: md_type,
                  md_attributes: /* [] */0,
                  md_loc: none
                };
        }
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                  MEL_EXN_ID: Stdlib.Not_found
                });
    case /* Papply */2 :
        const p2 = path._1;
        const desc1 = find_module_descr(path._0, env);
        const f = force(components_of_module_maker$p.contents, desc1);
        if (f.TAG === /* Structure_comps */0) {
          throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                    MEL_EXN_ID: Stdlib.Not_found
                  });
        }
        const f$1 = f._0;
        const p = f$1.fcomp_res;
        let md_type$1;
        if (p.TAG === /* Mty_alias */3) {
          md_type$1 = {
            TAG: /* Mty_alias */3,
            _0: module_path(f$1.fcomp_subst, p._0)
          };
        } else if (alias) {
          md_type$1 = p;
        } else {
          try {
            md_type$1 = Stdlib__Hashtbl.find(f$1.fcomp_subst_cache, p2);
          }
          catch (raw_exn$1){
            const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
            if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
              const mty = modtype(add_module(f$1.fcomp_param, p2, f$1.fcomp_subst), f$1.fcomp_res);
              Stdlib__Hashtbl.add(f$1.fcomp_subst_cache, p2, mty);
              md_type$1 = mty;
            } else {
              throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
            }
          }
        }
        return {
                md_type: md_type$1,
                md_attributes: /* [] */0,
                md_loc: none
              };
    
  }
}

const required_globals = {
  contents: /* [] */0
};

function add_required_global(id) {
  if ($$global(id) && !transparent_modules.contents && !Stdlib__List.exists((function (param) {
            return Caml_obj.caml_equal(id, param);
          }), required_globals.contents)) {
    required_globals.contents = {
      hd: id,
      tl: required_globals.contents
    };
    return ;
  }
  
}

function normalize_path(lax, env, path) {
  let path$1;
  switch (path.TAG | 0) {
    case /* Pident */0 :
        path$1 = path;
        break;
    case /* Pdot */1 :
        path$1 = {
          TAG: /* Pdot */1,
          _0: normalize_path(lax, env, path._0),
          _1: path._1,
          _2: path._2
        };
        break;
    case /* Papply */2 :
        path$1 = {
          TAG: /* Papply */2,
          _0: normalize_path(lax, env, path._0),
          _1: normalize_path(true, env, path._1)
        };
        break;
    
  }
  try {
    const match = find_module(true, path$1, env);
    const path1 = match.md_type;
    if (path1.TAG !== /* Mty_alias */3) {
      return path$1;
    }
    const path$p = normalize_path(lax, env, path1._0);
    if (lax || transparent_modules.contents) {
      return path$p;
    }
    const id = head(path$1);
    if ($$global(id) && !Caml_obj.caml_equal(id, head(path$p))) {
      add_required_global(id);
    }
    return path$p;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      let tmp = true;
      if (!lax) {
        let tmp$1;
        switch (path$1.TAG | 0) {
          case /* Pident */0 :
              tmp$1 = path$1._0.stamp !== 0;
              break;
          case /* Pdot */1 :
          case /* Papply */2 :
              tmp$1 = true;
              break;
          
        }
        tmp = tmp$1;
      }
      if (tmp) {
        return path$1;
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    } else {
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  }
}

function normalize_path$1(oloc, env, path) {
  try {
    return normalize_path(oloc === undefined, env, path);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      if (oloc !== undefined) {
        throw new Caml_js_exceptions.MelangeError($$Error$2, {
                  MEL_EXN_ID: $$Error$2,
                  _1: {
                    TAG: /* Missing_module */3,
                    _0: oloc,
                    _1: path,
                    _2: normalize_path(true, env, path)
                  }
                });
      }
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  10272,
                  28
                ]
              });
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function find_type_expansion(path, env) {
  const decl = find_type_full(path, env)[0];
  const body = decl.type_manifest;
  if (body !== undefined && (decl.type_private === /* Public */1 || Caml_obj.caml_notequal(decl.type_kind, /* Type_abstract */0) || has_constr_row(body))) {
    return [
            decl.type_params,
            body,
            may_map((function (prim) {
                    return prim[1];
                  }), decl.type_newtype_level)
          ];
  }
  const path$p = normalize_path$1(undefined, env, path);
  if (same(path, path$p)) {
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
  }
  return [
          decl.type_params,
          newty2(100000000, {
                TAG: /* Tconstr */3,
                _0: path$p,
                _1: decl.type_params,
                _2: {
                  contents: /* Mnil */0
                }
              }),
          may_map((function (prim) {
                  return prim[1];
                }), decl.type_newtype_level)
        ];
}

function find_type_expansion_opt(path, env) {
  const decl = find_type_full(path, env)[0];
  const body = decl.type_manifest;
  if (body !== undefined) {
    return [
            decl.type_params,
            body,
            may_map((function (prim) {
                    return prim[1];
                  }), decl.type_newtype_level)
          ];
  }
  const path$p = normalize_path$1(undefined, env, path);
  if (same(path, path$p)) {
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
  }
  return [
          decl.type_params,
          newty2(100000000, {
                TAG: /* Tconstr */3,
                _0: path$p,
                _1: decl.type_params,
                _2: {
                  contents: /* Mnil */0
                }
              }),
          may_map((function (prim) {
                  return prim[1];
                }), decl.type_newtype_level)
        ];
}

function find_modtype_expansion(path, env) {
  const mty = find_modtype(path, env).mtd_type;
  if (mty !== undefined) {
    return mty;
  }
  throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
}

function is_functor_arg(_path, env) {
  while(true) {
    const path = _path;
    switch (path.TAG | 0) {
      case /* Pident */0 :
          try {
            find_same(path._0, env.functor_args);
            return true;
          }
          catch (raw_exn){
            const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.MEL_EXN_ID === Stdlib.Not_found) {
              return false;
            }
            throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
          }
      case /* Pdot */1 :
          _path = path._0;
          continue ;
      case /* Papply */2 :
          return true;
      
    }
  };
}

const Recmodule = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Env.Recmodule");

function lookup_module_descr(lid, env) {
  switch (lid.TAG | 0) {
    case /* Lident */0 :
        const s = lid._0;
        try {
          return find_name$1(s, env.components);
        }
        catch (raw_exn){
          const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.MEL_EXN_ID === Stdlib.Not_found) {
            if (s === current_unit.contents) {
              throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                        MEL_EXN_ID: Stdlib.Not_found
                      });
            }
            const ps = find_pers_struct(undefined, s);
            return [
                    {
                      TAG: /* Pident */0,
                      _0: {
                        stamp: 0,
                        name: s,
                        flags: 1
                      }
                    },
                    ps.ps_comps
                  ];
          }
          throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
        }
    case /* Ldot */1 :
        const s$1 = lid._1;
        const match = lookup_module_descr(lid._0, env);
        const c = force(components_of_module_maker$p.contents, match[1]);
        if (c.TAG === /* Structure_comps */0) {
          const match$1 = find$2(s$1, c._0.comp_components);
          return [
                  {
                    TAG: /* Pdot */1,
                    _0: match[0],
                    _1: s$1,
                    _2: match$1[1]
                  },
                  match$1[0]
                ];
        }
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                  MEL_EXN_ID: Stdlib.Not_found
                });
    case /* Lapply */2 :
        const match$2 = lookup_module_descr(lid._0, env);
        const p1 = match$2[0];
        const p2 = lookup_module(true, lid._1, env);
        const match$3 = find_module(false, p2, env);
        const f = force(components_of_module_maker$p.contents, match$2[1]);
        if (f.TAG === /* Structure_comps */0) {
          throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                    MEL_EXN_ID: Stdlib.Not_found
                  });
        }
        const f$1 = f._0;
        may(Curry._3(check_modtype_inclusion.contents, env, match$3.md_type, p2), f$1.fcomp_arg);
        return [
                {
                  TAG: /* Papply */2,
                  _0: p1,
                  _1: p2
                },
                Curry._3(components_of_functor_appl$p.contents, f$1, p1, p2)
              ];
    
  }
}

function lookup_module(load, lid, env) {
  switch (lid.TAG | 0) {
    case /* Lident */0 :
        const s = lid._0;
        try {
          const r = find_name$1(s, env.modules);
          const md_type = r[1].md_type;
          if (md_type.TAG === /* Mty_ident */0) {
            const id = md_type._0;
            switch (id.TAG | 0) {
              case /* Pident */0 :
                  if (id._0.name === "#recmod#") {
                    throw new Caml_js_exceptions.MelangeError(Recmodule, {
                              MEL_EXN_ID: Recmodule
                            });
                  }
                  break;
              case /* Pdot */1 :
              case /* Papply */2 :
                  break;
              
            }
          }
          return r[0];
        }
        catch (raw_exn){
          const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.MEL_EXN_ID === Stdlib.Not_found) {
            if (s === current_unit.contents) {
              throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                        MEL_EXN_ID: Stdlib.Not_found
                      });
            }
            if (transparent_modules.contents && !load) {
              try {
                find_pers_struct(false, s);
              }
              catch (raw_exn$1){
                const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
                if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
                  prerr_warning(none, {
                        TAG: /* No_cmi_file */32,
                        _0: s
                      });
                } else {
                  throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
                }
              }
            } else {
              find_pers_struct(undefined, s);
            }
            return {
                    TAG: /* Pident */0,
                    _0: {
                      stamp: 0,
                      name: s,
                      flags: 1
                    }
                  };
          }
          throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
        }
    case /* Ldot */1 :
        const s$1 = lid._1;
        const match = lookup_module_descr(lid._0, env);
        const c = force(components_of_module_maker$p.contents, match[1]);
        if (c.TAG === /* Structure_comps */0) {
          const match$1 = find$2(s$1, c._0.comp_modules);
          return {
                  TAG: /* Pdot */1,
                  _0: match[0],
                  _1: s$1,
                  _2: match$1[1]
                };
        }
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                  MEL_EXN_ID: Stdlib.Not_found
                });
    case /* Lapply */2 :
        const match$2 = lookup_module_descr(lid._0, env);
        const p2 = lookup_module(true, lid._1, env);
        const match$3 = find_module(false, p2, env);
        const p_0 = match$2[0];
        const p = {
          TAG: /* Papply */2,
          _0: p_0,
          _1: p2
        };
        const f = force(components_of_module_maker$p.contents, match$2[1]);
        if (f.TAG === /* Structure_comps */0) {
          throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                    MEL_EXN_ID: Stdlib.Not_found
                  });
        }
        may(Curry._3(check_modtype_inclusion.contents, env, match$3.md_type, p2), f._0.fcomp_arg);
        return p;
    
  }
}

function lookup(proj1, proj2, lid, env) {
  switch (lid.TAG | 0) {
    case /* Lident */0 :
        return find_name$1(lid._0, Curry._1(proj1, env));
    case /* Ldot */1 :
        const s = lid._1;
        const match = lookup_module_descr(lid._0, env);
        const c = force(components_of_module_maker$p.contents, match[1]);
        if (c.TAG === /* Structure_comps */0) {
          const match$1 = find$2(s, Curry._1(proj2, c._0));
          return [
                  {
                    TAG: /* Pdot */1,
                    _0: match[0],
                    _1: s,
                    _2: match$1[1]
                  },
                  match$1[0]
                ];
        }
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                  MEL_EXN_ID: Stdlib.Not_found
                });
    case /* Lapply */2 :
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                  MEL_EXN_ID: Stdlib.Not_found
                });
    
  }
}

function lookup_all_simple(proj1, proj2, shadow, lid, env) {
  switch (lid.TAG | 0) {
    case /* Lident */0 :
        const xl = find_all(lid._0, Curry._1(proj1, env));
        const do_shadow = function (param) {
          if (!param) {
            return /* [] */0;
          }
          const match = param.hd;
          const x = match[0];
          return {
                  hd: [
                    x,
                    match[1]
                  ],
                  tl: do_shadow(Stdlib__List.filter((function (param) {
                              return !Curry._2(shadow, x, param[0]);
                            }), param.tl))
                };
        };
        return do_shadow(xl);
    case /* Ldot */1 :
        const match = lookup_module_descr(lid._0, env);
        const c = force(components_of_module_maker$p.contents, match[1]);
        if (c.TAG === /* Structure_comps */0) {
          let comps;
          try {
            comps = find$2(lid._1, Curry._1(proj2, c._0));
          }
          catch (raw_exn){
            const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.MEL_EXN_ID === Stdlib.Not_found) {
              comps = /* [] */0;
            } else {
              throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
            }
          }
          return Stdlib__List.map((function (param) {
                        return [
                                param[0],
                                (function (param) {
                                    
                                  })
                              ];
                      }), comps);
        }
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                  MEL_EXN_ID: Stdlib.Not_found
                });
    case /* Lapply */2 :
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                  MEL_EXN_ID: Stdlib.Not_found
                });
    
  }
}

function cstr_shadow(cstr1, cstr2) {
  const match = cstr1.cstr_tag;
  const match$1 = cstr2.cstr_tag;
  switch (match.TAG | 0) {
    case /* Cstr_constant */0 :
    case /* Cstr_block */1 :
        return false;
    case /* Cstr_extension */2 :
        switch (match$1.TAG | 0) {
          case /* Cstr_constant */0 :
          case /* Cstr_block */1 :
              return false;
          case /* Cstr_extension */2 :
              return true;
          
        }
    
  }
}

function lbl_shadow(lbl1, lbl2) {
  return false;
}

function lookup_value(param, param$1) {
  return lookup((function (env) {
                return env.values;
              }), (function (sc) {
                return sc.comp_values;
              }), param, param$1);
}

function lookup_all_constructors(param, param$1) {
  return lookup_all_simple((function (env) {
                return env.constrs;
              }), (function (sc) {
                return sc.comp_constrs;
              }), cstr_shadow, param, param$1);
}

function lookup_all_labels(param, param$1) {
  return lookup_all_simple((function (env) {
                return env.labels;
              }), (function (sc) {
                return sc.comp_labels;
              }), lbl_shadow, param, param$1);
}

function lookup_type(param, param$1) {
  return lookup((function (env) {
                return env.types;
              }), (function (sc) {
                return sc.comp_types;
              }), param, param$1);
}

function lookup_modtype(param, param$1) {
  return lookup((function (env) {
                return env.modtypes;
              }), (function (sc) {
                return sc.comp_modtypes;
              }), param, param$1);
}

function lookup_class(param, param$1) {
  return lookup((function (env) {
                return env.classes;
              }), (function (sc) {
                return sc.comp_classes;
              }), param, param$1);
}

function lookup_cltype(param, param$1) {
  return lookup((function (env) {
                return env.cltypes;
              }), (function (sc) {
                return sc.comp_cltypes;
              }), param, param$1);
}

function mark_value_used(env, name, vd) {
  if (is_implicit_coercion(env)) {
    return ;
  }
  try {
    return Curry._1(Stdlib__Hashtbl.find(value_declarations, [
                    name,
                    vd.val_loc
                  ]), undefined);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return ;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function mark_type_used(env, name, vd) {
  if (is_implicit_coercion(env)) {
    return ;
  }
  try {
    return Curry._1(Stdlib__Hashtbl.find(type_declarations, [
                    name,
                    vd.type_loc
                  ]), undefined);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return ;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function mark_constructor_used(usage, env, name, vd, constr) {
  if (is_implicit_coercion(env)) {
    return ;
  }
  try {
    return Curry._1(Stdlib__Hashtbl.find(used_constructors, [
                    name,
                    vd.type_loc,
                    constr
                  ]), usage);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return ;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function mark_extension_used(usage, env, ext, name) {
  if (is_implicit_coercion(env)) {
    return ;
  }
  const ty_name = last(ext.ext_type_path);
  try {
    return Curry._1(Stdlib__Hashtbl.find(used_constructors, [
                    ty_name,
                    ext.ext_loc,
                    name
                  ]), usage);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return ;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function set_type_used_callback(name, td, callback) {
  const loc = td.type_loc;
  if (loc.loc_ghost) {
    return ;
  }
  const key = [
    name,
    loc
  ];
  let old;
  try {
    old = Stdlib__Hashtbl.find(type_declarations, key);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  10534,
                  22
                ]
              });
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
  Stdlib__Hashtbl.replace(type_declarations, key, (function (param) {
          Curry._1(callback, old);
        }));
}

function lookup_value$1(lid, env) {
  const r = lookup_value(lid, env);
  mark_value_used(env, last$1(lid), r[1]);
  return r;
}

function lookup_type$1(lid, env) {
  const match = lookup_type(lid, env);
  const decl = match[1][0];
  mark_type_used(env, last$1(lid), decl);
  return [
          match[0],
          decl
        ];
}

function mark_type_path(env, path) {
  try {
    const decl = find_type_full(path, env)[0];
    return mark_type_used(env, last(path), decl);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return ;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function ty_path(t) {
  const match = repr(t);
  const match$1 = match.desc;
  if (typeof match$1 === "number") {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                10564,
                9
              ]
            });
  }
  if (match$1.TAG === /* Tconstr */3) {
    return match$1._0;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              10564,
              9
            ]
          });
}

function lookup_constructor(lid, env) {
  const match = lookup_all_constructors(lid, env);
  if (match) {
    const match$1 = match.hd;
    const desc = match$1[0];
    mark_type_path(env, ty_path(desc.cstr_res));
    Curry._1(match$1[1], undefined);
    return desc;
  }
  throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
}

function is_lident(param) {
  switch (param.TAG | 0) {
    case /* Lident */0 :
        return true;
    case /* Ldot */1 :
    case /* Lapply */2 :
        return false;
    
  }
}

function lookup_all_constructors$1(lid, env) {
  try {
    const cstrs = lookup_all_constructors(lid, env);
    return Stdlib__List.map((function (param) {
                  const use = param[1];
                  const cstr = param[0];
                  return [
                          cstr,
                          (function (param) {
                              mark_type_path(env, ty_path(cstr.cstr_res));
                              return Curry._1(use, undefined);
                            })
                        ];
                }), cstrs);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      if (is_lident(lid)) {
        return /* [] */0;
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function mark_constructor(usage, env, name, desc) {
  if (is_implicit_coercion(env)) {
    return ;
  }
  const match = desc.cstr_tag;
  switch (match.TAG | 0) {
    case /* Cstr_constant */0 :
    case /* Cstr_block */1 :
        break;
    case /* Cstr_extension */2 :
        const ty_path$1 = ty_path(desc.cstr_res);
        const ty_name = last(ty_path$1);
        try {
          return Curry._1(Stdlib__Hashtbl.find(used_constructors, [
                          ty_name,
                          desc.cstr_loc,
                          name
                        ]), usage);
        }
        catch (raw_exn){
          const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.MEL_EXN_ID === Stdlib.Not_found) {
            return ;
          }
          throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
        }
    
  }
  const ty_path$2 = ty_path(desc.cstr_res);
  let ty_decl;
  try {
    ty_decl = find_type_full(ty_path$2, env)[0];
  }
  catch (raw_exn$1){
    const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
    if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  10601,
                  64
                ]
              });
    }
    throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
  }
  const ty_name$1 = last(ty_path$2);
  mark_constructor_used(usage, env, ty_name$1, ty_decl, name);
}

function lookup_all_labels$1(lid, env) {
  try {
    const lbls = lookup_all_labels(lid, env);
    return Stdlib__List.map((function (param) {
                  const use = param[1];
                  const lbl = param[0];
                  return [
                          lbl,
                          (function (param) {
                              mark_type_path(env, ty_path(lbl.lbl_res));
                              return Curry._1(use, undefined);
                            })
                        ];
                }), lbls);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      if (is_lident(lid)) {
        return /* [] */0;
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function lookup_class$1(lid, env) {
  const r = lookup_class(lid, env);
  const desc = r[1];
  if (name(undefined, desc.cty_path) === "") {
    lookup_type$1(lid, env);
  } else {
    mark_type_path(env, desc.cty_path);
  }
  return r;
}

function lookup_cltype$1(lid, env) {
  const r = lookup_cltype(lid, env);
  const desc = r[1];
  if (name(undefined, desc.clty_path) === "") {
    lookup_type$1(lid, env);
  } else {
    mark_type_path(env, desc.clty_path);
  }
  mark_type_path(env, desc.clty_path);
  return r;
}

const iter_env_cont = {
  contents: /* [] */0
};

function scrape_alias_safe(env, _mty) {
  while(true) {
    const mty = _mty;
    if (mty.TAG !== /* Mty_alias */3) {
      return true;
    }
    const id = mty._0;
    switch (id.TAG | 0) {
      case /* Pident */0 :
          if (id._0.stamp === 0) {
            return false;
          }
          break;
      case /* Pdot */1 :
      case /* Papply */2 :
          break;
      
    }
    _mty = find_module(false, id, env).md_type;
    continue ;
  };
}

function run_iter_cont(l) {
  iter_env_cont.contents = /* [] */0;
  Stdlib__List.iter((function (c) {
          Curry._1(c, undefined);
        }), l);
  const cont = Stdlib__List.rev(iter_env_cont.contents);
  iter_env_cont.contents = /* [] */0;
  return cont;
}

function iter_types(f) {
  return function (param, param$1) {
    const proj1 = function (env) {
      return env.types;
    };
    const proj2 = function (sc) {
      return sc.comp_types;
    };
    iter((function (id, param) {
            Curry._2(f, {
                  TAG: /* Pident */0,
                  _0: id
                }, param[0]);
          }), Curry._1(proj1, param));
    const iter_components = function (path, path$p, mcomps) {
      const cont = function (param) {
        const match = get_arg(mcomps);
        let safe;
        if (match !== undefined) {
          try {
            safe = scrape_alias_safe(match[0], match[3]);
          }
          catch (raw_exn){
            const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.MEL_EXN_ID === Stdlib.Not_found) {
              safe = false;
            } else {
              throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
            }
          }
        } else {
          safe = true;
        }
        if (!safe) {
          return ;
        }
        const comps = force(components_of_module_maker$p.contents, mcomps);
        if (comps.TAG !== /* Structure_comps */0) {
          return ;
        }
        const comps$1 = comps._0;
        iter$2((function (s, param) {
                const n = param[1];
                Curry._2(f, {
                      TAG: /* Pdot */1,
                      _0: path,
                      _1: s,
                      _2: n
                    }, [
                      {
                        TAG: /* Pdot */1,
                        _0: path$p,
                        _1: s,
                        _2: n
                      },
                      param[0]
                    ]);
              }), Curry._1(proj2, comps$1));
        iter$2((function (s, param) {
                const n = param[1];
                iter_components({
                      TAG: /* Pdot */1,
                      _0: path,
                      _1: s,
                      _2: n
                    }, {
                      TAG: /* Pdot */1,
                      _0: path$p,
                      _1: s,
                      _2: n
                    }, param[0]);
              }), comps$1.comp_components);
      };
      iter_env_cont.contents = {
        hd: [
          path,
          cont
        ],
        tl: iter_env_cont.contents
      };
    };
    Stdlib__Hashtbl.iter((function (s, pso) {
            if (pso === undefined) {
              return ;
            }
            const id = {
              TAG: /* Pident */0,
              _0: {
                stamp: 0,
                name: s,
                flags: 1
              }
            };
            iter_components(id, id, pso.ps_comps);
          }), persistent_structures);
    return iter((function (id, param) {
                  const match = param[0];
                  iter_components({
                        TAG: /* Pident */0,
                        _0: id
                      }, match[0], match[1]);
                }), param.components);
  };
}

function same_types(env1, env2) {
  if (env1.types === env2.types) {
    return env1.components === env2.components;
  } else {
    return false;
  }
}

function used_persistent(param) {
  const r = {
    contents: /* Empty */0
  };
  Stdlib__Hashtbl.iter((function (s, pso) {
          if (pso !== undefined) {
            r.contents = Curry._2(add$2, s, r.contents);
            return ;
          }
          
        }), persistent_structures);
  return r.contents;
}

function find_all_comps(proj, s, param) {
  const comps = force(components_of_module_maker$p.contents, param[1]);
  if (comps.TAG !== /* Structure_comps */0) {
    return /* [] */0;
  }
  try {
    const match = find$2(s, Curry._1(proj, comps._0));
    return {
            hd: [
              {
                TAG: /* Pdot */1,
                _0: param[0],
                _1: s,
                _2: match[1]
              },
              match[0]
            ],
            tl: /* [] */0
          };
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return /* [] */0;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function find_shadowed_comps(path, env) {
  switch (path.TAG | 0) {
    case /* Pident */0 :
        return Stdlib__List.map((function (prim) {
                      return prim[0];
                    }), find_all(path._0.name, env.components));
    case /* Pdot */1 :
        const s = path._1;
        const l = find_shadowed_comps(path._0, env);
        return Stdlib__List.flatten(Stdlib__List.map((function (param) {
                          return find_all_comps((function (comps) {
                                        return comps.comp_components;
                                      }), s, param);
                        }), l));
    case /* Papply */2 :
        return /* [] */0;
    
  }
}

function find_shadowed(proj1, proj2, path, env) {
  switch (path.TAG | 0) {
    case /* Pident */0 :
        return Stdlib__List.map((function (prim) {
                      return prim[0];
                    }), find_all(path._0.name, Curry._1(proj1, env)));
    case /* Pdot */1 :
        const s = path._1;
        const l = find_shadowed_comps(path._0, env);
        return Stdlib__List.flatten(Stdlib__List.map((function (param) {
                          return find_all_comps(proj2, s, param);
                        }), l));
    case /* Papply */2 :
        return /* [] */0;
    
  }
}

function find_shadowed_types(path, env) {
  const l = find_shadowed((function (env) {
          return env.types;
        }), (function (comps) {
          return comps.comp_types;
        }), path, env);
  return Stdlib__List.map((function (prim) {
                return prim[0];
              }), l);
}

function add_gadt_instance_level(lv, env) {
  return {
          values: env.values,
          constrs: env.constrs,
          labels: env.labels,
          types: env.types,
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: env.summary,
          local_constraints: env.local_constraints,
          gadt_instances: {
            hd: [
              lv,
              {
                contents: /* Empty */0
              }
            ],
            tl: env.gadt_instances
          },
          flags: env.flags
        };
}

function is_Tlink(param) {
  const match = param.desc;
  if (typeof match === "number" || match.TAG !== /* Tlink */6) {
    return false;
  } else {
    return true;
  }
}

function gadt_instance_level(env, t) {
  let _param = env.gadt_instances;
  while(true) {
    const param = _param;
    if (!param) {
      return ;
    }
    const match = param.hd;
    const r = match[1];
    if (Curry._2(exists$1, is_Tlink, r.contents)) {
      r.contents = Curry._3(fold$2, (function (ty) {
              return Curry._1(add$3, repr(ty));
            }), r.contents, /* Empty */0);
    }
    if (Curry._2(mem$3, t, r.contents)) {
      return Caml_option.some(match[0]);
    }
    _param = param.tl;
    continue ;
  };
}

function add_gadt_instances(env, lv, tl) {
  let r;
  try {
    r = Stdlib__List.assoc(lv, env.gadt_instances);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  10759,
                  59
                ]
              });
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
  set_typeset(r, Stdlib__List.fold_right(add$3, tl, r.contents));
}

function add_gadt_instance_chain(env, lv, t) {
  let r;
  try {
    r = Stdlib__List.assoc(lv, env.gadt_instances);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  10768,
                  59
                ]
              });
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
  const add_instance = function (t) {
    const t$1 = repr(t);
    if (Curry._2(mem$3, t$1, r.contents)) {
      return ;
    }
    set_typeset(r, Curry._2(add$3, t$1, r.contents));
    const match = t$1.desc;
    if (typeof match === "number" || match.TAG !== /* Tconstr */3) {
      return ;
    } else {
      return may(add_instance, find_expans(/* Private */0, match._0, match._2.contents));
    }
  };
  add_instance(t);
}

function scrape_alias(env, path, mty) {
  switch (mty.TAG | 0) {
    case /* Mty_ident */0 :
        try {
          return scrape_alias(env, path, find_modtype_expansion(mty._0, env));
        }
        catch (raw_exn){
          const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.MEL_EXN_ID === Stdlib.Not_found) {
            return mty;
          }
          throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
        }
    case /* Mty_signature */1 :
    case /* Mty_functor */2 :
        break;
    case /* Mty_alias */3 :
        const path$1 = mty._0;
        try {
          return scrape_alias(env, path$1, find_module(false, path$1, env).md_type);
        }
        catch (raw_exn$1){
          const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
          if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
            return mty;
          }
          throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
        }
    
  }
  if (path !== undefined) {
    return Curry._3(strengthen.contents, env, mty, path);
  } else {
    return mty;
  }
}

function constructors_of_type(ty_path, decl) {
  const cstrs = decl.type_kind;
  if (typeof cstrs === "number" || cstrs.TAG !== /* Type_variant */1) {
    return /* [] */0;
  } else {
    let cstrs$1 = cstrs._0;
    let ty_res = newty2(100000000, {
          TAG: /* Tconstr */3,
          _0: ty_path,
          _1: decl.type_params,
          _2: {
            contents: /* Mnil */0
          }
        });
    let priv = decl.type_private;
    const num_consts = {
      contents: 0
    };
    const num_nonconsts = {
      contents: 0
    };
    const num_normal = {
      contents: 0
    };
    Stdlib__List.iter((function (param) {
            if (Caml_obj.caml_equal(param.cd_args, /* [] */0)) {
              num_consts.contents = num_consts.contents + 1 | 0;
            } else {
              num_nonconsts.contents = num_nonconsts.contents + 1 | 0;
            }
            if (param.cd_res === undefined) {
              num_normal.contents = num_normal.contents + 1 | 0;
              return ;
            }
            
          }), cstrs$1);
    const describe_constructors = function (idx_const, idx_nonconst, param) {
      if (!param) {
        return /* [] */0;
      }
      const rem = param.tl;
      const match = param.hd;
      const cd_res = match.cd_res;
      const cd_args = match.cd_args;
      const cd_id = match.cd_id;
      const ty_res$1 = cd_res !== undefined ? cd_res : ty_res;
      const match$1 = cd_args ? [
          {
            TAG: /* Cstr_block */1,
            _0: idx_nonconst
          },
          describe_constructors(idx_const, idx_nonconst + 1 | 0, rem)
        ] : [
          {
            TAG: /* Cstr_constant */0,
            _0: idx_const
          },
          describe_constructors(idx_const + 1 | 0, idx_nonconst, rem)
        ];
      let existentials;
      if (cd_res !== undefined) {
        const res_vars = free_vars(cd_res);
        const arg_vars = free_vars(newty2(100000000, {
                  TAG: /* Ttuple */2,
                  _0: cd_args
                }));
        existentials = Curry._1(elements$1, Curry._2(diff$1, arg_vars, res_vars));
      } else {
        existentials = /* [] */0;
      }
      const cstr_cstr_name = cd_id.name;
      const cstr_cstr_arity = Stdlib__List.length(cd_args);
      const cstr_cstr_tag = match$1[0];
      const cstr_cstr_consts = num_consts.contents;
      const cstr_cstr_nonconsts = num_nonconsts.contents;
      const cstr_cstr_normal = num_normal.contents;
      const cstr_cstr_generalized = cd_res !== undefined;
      const cstr_cstr_loc = match.cd_loc;
      const cstr_cstr_attributes = match.cd_attributes;
      const cstr = {
        cstr_name: cstr_cstr_name,
        cstr_res: ty_res$1,
        cstr_existentials: existentials,
        cstr_args: cd_args,
        cstr_arity: cstr_cstr_arity,
        cstr_tag: cstr_cstr_tag,
        cstr_consts: cstr_cstr_consts,
        cstr_nonconsts: cstr_cstr_nonconsts,
        cstr_normal: cstr_cstr_normal,
        cstr_generalized: cstr_cstr_generalized,
        cstr_private: priv,
        cstr_loc: cstr_cstr_loc,
        cstr_attributes: cstr_cstr_attributes
      };
      return {
              hd: [
                cd_id,
                cstr
              ],
              tl: match$1[1]
            };
    };
    const result = describe_constructors(0, 0, cstrs$1);
    let a_id;
    let a_descr;
    let b_id;
    let b_descr;
    if (!result) {
      return result;
    }
    const match = result.hd;
    const a_id$1 = match[0];
    switch (a_id$1.name) {
      case "None" :
          const a_descr$1 = match[1];
          if (a_descr$1.cstr_args) {
            return result;
          }
          const match$1 = result.tl;
          if (!match$1) {
            return result;
          }
          const match$2 = match$1.hd;
          const b_id$1 = match$2[0];
          if (b_id$1.name !== "Some") {
            return result;
          }
          const b_descr$1 = match$2[1];
          const match$3 = b_descr$1.cstr_args;
          if (!match$3) {
            return result;
          }
          if (match$3.tl) {
            return result;
          }
          if (match$1.tl) {
            return result;
          }
          a_id = a_id$1;
          a_descr = a_descr$1;
          b_id = b_id$1;
          b_descr = b_descr$1;
          break;
      case "Some" :
          const a_descr$2 = match[1];
          const match$4 = a_descr$2.cstr_args;
          if (!match$4) {
            return result;
          }
          if (match$4.tl) {
            return result;
          }
          const match$5 = result.tl;
          if (!match$5) {
            return result;
          }
          const match$6 = match$5.hd;
          const b_id$2 = match$6[0];
          if (b_id$2.name !== "None") {
            return result;
          }
          const b_descr$2 = match$6[1];
          if (b_descr$2.cstr_args) {
            return result;
          }
          if (match$5.tl) {
            return result;
          }
          a_id = a_id$1;
          a_descr = a_descr$2;
          b_id = b_id$2;
          b_descr = b_descr$2;
          break;
      default:
        return result;
    }
    return {
            hd: [
              a_id,
              {
                cstr_name: a_descr.cstr_name,
                cstr_res: a_descr.cstr_res,
                cstr_existentials: a_descr.cstr_existentials,
                cstr_args: a_descr.cstr_args,
                cstr_arity: a_descr.cstr_arity,
                cstr_tag: a_descr.cstr_tag,
                cstr_consts: a_descr.cstr_consts,
                cstr_nonconsts: a_descr.cstr_nonconsts,
                cstr_normal: a_descr.cstr_normal,
                cstr_generalized: a_descr.cstr_generalized,
                cstr_private: a_descr.cstr_private,
                cstr_loc: a_descr.cstr_loc,
                cstr_attributes: {
                  hd: optional_shape,
                  tl: a_descr.cstr_attributes
                }
              }
            ],
            tl: {
              hd: [
                b_id,
                {
                  cstr_name: b_descr.cstr_name,
                  cstr_res: b_descr.cstr_res,
                  cstr_existentials: b_descr.cstr_existentials,
                  cstr_args: b_descr.cstr_args,
                  cstr_arity: b_descr.cstr_arity,
                  cstr_tag: b_descr.cstr_tag,
                  cstr_consts: b_descr.cstr_consts,
                  cstr_nonconsts: b_descr.cstr_nonconsts,
                  cstr_normal: b_descr.cstr_normal,
                  cstr_generalized: b_descr.cstr_generalized,
                  cstr_private: b_descr.cstr_private,
                  cstr_loc: b_descr.cstr_loc,
                  cstr_attributes: {
                    hd: optional_shape,
                    tl: b_descr.cstr_attributes
                  }
                }
              ],
              tl: /* [] */0
            }
          };
  }
}

function labels_of_type(ty_path, decl) {
  const match = decl.type_kind;
  if (typeof match === "number" || match.TAG !== /* Type_record */0) {
    return /* [] */0;
  } else {
    let ty_res = newty2(100000000, {
          TAG: /* Tconstr */3,
          _0: ty_path,
          _1: decl.type_params,
          _2: {
            contents: /* Mnil */0
          }
        });
    let lbls = match._0;
    let repres = match._1;
    let priv = decl.type_private;
    const all_labels = Caml_array.make(Stdlib__List.length(lbls), dummy_label);
    const describe_labels = function (num, param) {
      if (!param) {
        return /* [] */0;
      }
      const l = param.hd;
      const lbl_lbl_name = l.ld_id.name;
      const lbl_lbl_arg = l.ld_type;
      const lbl_lbl_mut = l.ld_mutable;
      const lbl_lbl_loc = l.ld_loc;
      const lbl_lbl_attributes = l.ld_attributes;
      const lbl = {
        lbl_name: lbl_lbl_name,
        lbl_res: ty_res,
        lbl_arg: lbl_lbl_arg,
        lbl_mut: lbl_lbl_mut,
        lbl_pos: num,
        lbl_all: all_labels,
        lbl_repres: repres,
        lbl_private: priv,
        lbl_loc: lbl_lbl_loc,
        lbl_attributes: lbl_lbl_attributes
      };
      Caml_array.set(all_labels, num, lbl);
      return {
              hd: [
                l.ld_id,
                lbl
              ],
              tl: describe_labels(num + 1 | 0, param.tl)
            };
    };
    return describe_labels(0, lbls);
  }
}

function prefix_idents(root, pos, sub, param) {
  if (!param) {
    return [
            /* [] */0,
            sub
          ];
  }
  const match = param.hd;
  switch (match.TAG | 0) {
    case /* Sig_value */0 :
        const p_1 = match._0.name;
        const p = {
          TAG: /* Pdot */1,
          _0: root,
          _1: p_1,
          _2: pos
        };
        const match$1 = match._1.val_kind;
        let nextpos;
        nextpos = typeof match$1 === "number" || match$1.TAG !== /* Val_prim */0 ? pos + 1 | 0 : pos;
        const match$2 = prefix_idents(root, nextpos, sub, param.tl);
        return [
                {
                  hd: p,
                  tl: match$2[0]
                },
                match$2[1]
              ];
    case /* Sig_type */1 :
        const id = match._0;
        const p_1$1 = id.name;
        const p$1 = {
          TAG: /* Pdot */1,
          _0: root,
          _1: p_1$1,
          _2: -1
        };
        const match$3 = prefix_idents(root, pos, add_type(id, p$1, sub), param.tl);
        return [
                {
                  hd: p$1,
                  tl: match$3[0]
                },
                match$3[1]
              ];
    case /* Sig_typext */2 :
        const p_1$2 = match._0.name;
        const p$2 = {
          TAG: /* Pdot */1,
          _0: root,
          _1: p_1$2,
          _2: pos
        };
        const match$4 = prefix_idents(root, pos + 1 | 0, sub, param.tl);
        return [
                {
                  hd: p$2,
                  tl: match$4[0]
                },
                match$4[1]
              ];
    case /* Sig_module */3 :
        const id$1 = match._0;
        const p_1$3 = id$1.name;
        const p$3 = {
          TAG: /* Pdot */1,
          _0: root,
          _1: p_1$3,
          _2: pos
        };
        const match$5 = prefix_idents(root, pos + 1 | 0, add_module(id$1, p$3, sub), param.tl);
        return [
                {
                  hd: p$3,
                  tl: match$5[0]
                },
                match$5[1]
              ];
    case /* Sig_modtype */4 :
        const id$2 = match._0;
        const p_1$4 = id$2.name;
        const p$4 = {
          TAG: /* Pdot */1,
          _0: root,
          _1: p_1$4,
          _2: -1
        };
        const match$6 = prefix_idents(root, pos, add_modtype(id$2, {
                  TAG: /* Mty_ident */0,
                  _0: p$4
                }, sub), param.tl);
        return [
                {
                  hd: p$4,
                  tl: match$6[0]
                },
                match$6[1]
              ];
    case /* Sig_class */5 :
        const p_1$5 = match._0.name;
        const p$5 = {
          TAG: /* Pdot */1,
          _0: root,
          _1: p_1$5,
          _2: pos
        };
        const match$7 = prefix_idents(root, pos + 1 | 0, sub, param.tl);
        return [
                {
                  hd: p$5,
                  tl: match$7[0]
                },
                match$7[1]
              ];
    case /* Sig_class_type */6 :
        const p_1$6 = match._0.name;
        const p$6 = {
          TAG: /* Pdot */1,
          _0: root,
          _1: p_1$6,
          _2: -1
        };
        const match$8 = prefix_idents(root, pos, sub, param.tl);
        return [
                {
                  hd: p$6,
                  tl: match$8[0]
                },
                match$8[1]
              ];
    
  }
}

function prefix_idents_and_subst(root, sub, sg) {
  const match = prefix_idents(root, 0, sub, sg);
  const sub$1 = match[1];
  return [
          match[0],
          sub$1,
          {
            LAZY_DONE: false,
            VAL: (function () {
                return Stdlib__List.map((function (item) {
                              switch (item.TAG | 0) {
                                case /* Sig_value */0 :
                                    return {
                                            TAG: /* Sig_value */0,
                                            _0: item._0,
                                            _1: value_description(sub$1, item._1)
                                          };
                                case /* Sig_type */1 :
                                    return {
                                            TAG: /* Sig_type */1,
                                            _0: item._0,
                                            _1: type_declaration(sub$1, item._1),
                                            _2: item._2
                                          };
                                case /* Sig_typext */2 :
                                    return {
                                            TAG: /* Sig_typext */2,
                                            _0: item._0,
                                            _1: extension_constructor(sub$1, item._1),
                                            _2: item._2
                                          };
                                case /* Sig_module */3 :
                                    return {
                                            TAG: /* Sig_module */3,
                                            _0: item._0,
                                            _1: module_declaration(sub$1, item._1),
                                            _2: item._2
                                          };
                                case /* Sig_modtype */4 :
                                    return {
                                            TAG: /* Sig_modtype */4,
                                            _0: item._0,
                                            _1: modtype_declaration(sub$1, item._1)
                                          };
                                case /* Sig_class */5 :
                                    return {
                                            TAG: /* Sig_class */5,
                                            _0: item._0,
                                            _1: class_declaration(sub$1, item._1),
                                            _2: item._2
                                          };
                                case /* Sig_class_type */6 :
                                    return {
                                            TAG: /* Sig_class_type */6,
                                            _0: item._0,
                                            _1: cltype_declaration(sub$1, item._1),
                                            _2: item._2
                                          };
                                
                              }
                            }), sg);
              })
          }
        ];
}

function prefix_idents_and_subst$1(root, sub, sg) {
  if (!Caml_obj.caml_equal(sub, identity)) {
    return prefix_idents_and_subst(root, sub, sg);
  }
  let sgs;
  try {
    sgs = Stdlib__Hashtbl.find(prefixed_sg, root);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      const sgs$1 = {
        contents: /* [] */0
      };
      Stdlib__Hashtbl.add(prefixed_sg, root, sgs$1);
      sgs = sgs$1;
    } else {
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  }
  try {
    return Stdlib__List.assq(sg, sgs.contents);
  }
  catch (raw_exn$1){
    const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
    if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
      const r = prefix_idents_and_subst(root, sub, sg);
      sgs.contents = {
        hd: [
          sg,
          r
        ],
        tl: sgs.contents
      };
      return r;
    }
    throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
  }
}

function add_to_tbl(id, decl, tbl) {
  let decls;
  try {
    decls = find$2(id, tbl);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      decls = /* [] */0;
    } else {
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  }
  return add$5(id, {
              hd: decl,
              tl: decls
            }, tbl);
}

function components_of_module(env, sub, path, mty) {
  return {
          contents: {
            TAG: /* Thunk */2,
            _0: [
              env,
              sub,
              path,
              mty
            ]
          }
        };
}

function store_modtype(slot, id, path, info, env, renv) {
  return {
          values: env.values,
          constrs: env.constrs,
          labels: env.labels,
          types: env.types,
          modules: env.modules,
          modtypes: add$6("module type", slot, id, [
                path,
                info
              ], env.modtypes, renv.modtypes),
          components: env.components,
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: {
            TAG: /* Env_modtype */4,
            _0: env.summary,
            _1: id,
            _2: info
          },
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags
        };
}

function store_type_infos(slot, id, path, info, env, renv) {
  return {
          values: env.values,
          constrs: env.constrs,
          labels: env.labels,
          types: add$6("type", slot, id, [
                path,
                [
                  info,
                  [
                    /* [] */0,
                    /* [] */0
                  ]
                ]
              ], env.types, renv.types),
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: {
            TAG: /* Env_type */1,
            _0: env.summary,
            _1: id,
            _2: info
          },
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags
        };
}

function store_module(slot, id, path, md, env, renv) {
  return {
          values: env.values,
          constrs: env.constrs,
          labels: env.labels,
          types: env.types,
          modules: add$6("module", slot, id, [
                path,
                md
              ], env.modules, renv.modules),
          modtypes: env.modtypes,
          components: add$6("module", slot, id, [
                path,
                components_of_module(env, identity, path, md.md_type)
              ], env.components, renv.components),
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: {
            TAG: /* Env_module */3,
            _0: env.summary,
            _1: id,
            _2: md
          },
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags
        };
}

function check_usage(loc, id, warn, tbl) {
  if (!(!loc.loc_ghost && is_active(Curry._1(warn, "")))) {
    return ;
  }
  const name = id.name;
  const key = [
    name,
    loc
  ];
  if (Stdlib__Hashtbl.mem(tbl, key)) {
    return ;
  }
  const used = {
    contents: false
  };
  Stdlib__Hashtbl.add(tbl, key, (function (param) {
          used.contents = true;
        }));
  if (!(name === "" || Caml_string.get(name, 0) === /* '_' */95 || Caml_string.get(name, 0) === /* '#' */35)) {
    return Curry._1(add_delayed_check_forward.contents, (function (param) {
                  if (!used.contents) {
                    return prerr_warning(loc, Curry._1(warn, name));
                  }
                  
                }));
  }
  
}

function check_value_name(name, loc) {
  if (bs_only.contents && name === "|.") {
    throw new Caml_js_exceptions.MelangeError($$Error$2, {
              MEL_EXN_ID: $$Error$2,
              _1: {
                TAG: /* Illegal_value_name */4,
                _0: loc,
                _1: name
              }
            });
  }
  if (!(name.length !== 0 && Caml_string.get(name, 0) === /* '#' */35)) {
    return ;
  }
  for(let i = 1 ,i_finish = name.length; i < i_finish; ++i){
    if (Caml_string.get(name, i) === /* '#' */35) {
      throw new Caml_js_exceptions.MelangeError($$Error$2, {
                MEL_EXN_ID: $$Error$2,
                _1: {
                  TAG: /* Illegal_value_name */4,
                  _0: loc,
                  _1: name
                }
              });
    }
    
  }
}

function components_of_module_maker(param) {
  const sub = param[1];
  const env = param[0];
  const sg = scrape_alias(env, undefined, param[3]);
  switch (sg.TAG | 0) {
    case /* Mty_signature */1 :
        const sg$1 = sg._0;
        const c = {
          comp_values: /* Empty */0,
          comp_constrs: /* Empty */0,
          comp_labels: /* Empty */0,
          comp_types: /* Empty */0,
          comp_modules: /* Empty */0,
          comp_modtypes: /* Empty */0,
          comp_components: /* Empty */0,
          comp_classes: /* Empty */0,
          comp_cltypes: /* Empty */0
        };
        const match = prefix_idents_and_subst$1(param[2], sub, sg$1);
        const sub$1 = match[1];
        const env$1 = {
          contents: env
        };
        const pos = {
          contents: 0
        };
        Stdlib__List.iter2((function (item, path) {
                switch (item.TAG | 0) {
                  case /* Sig_value */0 :
                      const decl = item._1;
                      const decl$p = value_description(sub$1, decl);
                      c.comp_values = add$5(item._0.name, [
                            decl$p,
                            pos.contents
                          ], c.comp_values);
                      const match = decl.val_kind;
                      if (typeof match === "number" || match.TAG !== /* Val_prim */0) {
                        pos.contents = pos.contents + 1 | 0;
                        return ;
                      } else {
                        return ;
                      }
                  case /* Sig_type */1 :
                      const decl$1 = item._1;
                      const id = item._0;
                      const decl$p$1 = type_declaration(sub$1, decl$1);
                      const constructors = Stdlib__List.map((function (prim) {
                              return prim[1];
                            }), constructors_of_type(path, decl$p$1));
                      const labels = Stdlib__List.map((function (prim) {
                              return prim[1];
                            }), labels_of_type(path, decl$p$1));
                      c.comp_types = add$5(id.name, [
                            [
                              decl$p$1,
                              [
                                constructors,
                                labels
                              ]
                            ],
                            -1
                          ], c.comp_types);
                      Stdlib__List.iter((function (descr) {
                              c.comp_constrs = add_to_tbl(descr.cstr_name, [
                                    descr,
                                    -1
                                  ], c.comp_constrs);
                            }), constructors);
                      Stdlib__List.iter((function (descr) {
                              c.comp_labels = add_to_tbl(descr.lbl_name, [
                                    descr,
                                    -1
                                  ], c.comp_labels);
                            }), labels);
                      env$1.contents = store_type_infos(undefined, id, {
                            TAG: /* Pident */0,
                            _0: id
                          }, decl$1, env$1.contents, env$1.contents);
                      return ;
                  case /* Sig_typext */2 :
                      const ext$p = extension_constructor(sub$1, item._1);
                      const descr = extension_descr(path, ext$p);
                      c.comp_constrs = add_to_tbl(item._0.name, [
                            descr,
                            pos.contents
                          ], c.comp_constrs);
                      pos.contents = pos.contents + 1 | 0;
                      return ;
                  case /* Sig_module */3 :
                      const md = item._1;
                      const id$1 = item._0;
                      const mty = md.md_type;
                      const mty$p = {
                        contents: {
                          TAG: /* Thunk */2,
                          _0: [
                            sub$1,
                            mty
                          ]
                        }
                      };
                      c.comp_modules = add$5(id$1.name, [
                            mty$p,
                            pos.contents
                          ], c.comp_modules);
                      const comps = components_of_module(env$1.contents, sub$1, path, mty);
                      c.comp_components = add$5(id$1.name, [
                            comps,
                            pos.contents
                          ], c.comp_components);
                      env$1.contents = store_module(undefined, id$1, {
                            TAG: /* Pident */0,
                            _0: id$1
                          }, md, env$1.contents, env$1.contents);
                      pos.contents = pos.contents + 1 | 0;
                      return ;
                  case /* Sig_modtype */4 :
                      const decl$2 = item._1;
                      const id$2 = item._0;
                      const decl$p$2 = modtype_declaration(sub$1, decl$2);
                      c.comp_modtypes = add$5(id$2.name, [
                            decl$p$2,
                            -1
                          ], c.comp_modtypes);
                      env$1.contents = store_modtype(undefined, id$2, {
                            TAG: /* Pident */0,
                            _0: id$2
                          }, decl$2, env$1.contents, env$1.contents);
                      return ;
                  case /* Sig_class */5 :
                      const decl$p$3 = class_declaration(sub$1, item._1);
                      c.comp_classes = add$5(item._0.name, [
                            decl$p$3,
                            pos.contents
                          ], c.comp_classes);
                      pos.contents = pos.contents + 1 | 0;
                      return ;
                  case /* Sig_class_type */6 :
                      const decl$p$4 = cltype_declaration(sub$1, item._1);
                      c.comp_cltypes = add$5(item._0.name, [
                            decl$p$4,
                            pos.contents
                          ], c.comp_cltypes);
                      return ;
                  
                }
              }), sg$1, match[0]);
        return {
                TAG: /* Structure_comps */0,
                _0: c
              };
    case /* Mty_functor */2 :
        return {
                TAG: /* Functor_comps */1,
                _0: {
                  fcomp_param: sg._0,
                  fcomp_arg: may_map((function (param) {
                          return modtype(sub, param);
                        }), sg._1),
                  fcomp_res: sg._2,
                  fcomp_env: env,
                  fcomp_subst: sub,
                  fcomp_cache: Stdlib__Hashtbl.create(undefined, 17),
                  fcomp_subst_cache: Stdlib__Hashtbl.create(undefined, 17)
                }
              };
    case /* Mty_ident */0 :
    case /* Mty_alias */3 :
        break;
    
  }
  return {
          TAG: /* Structure_comps */0,
          _0: {
            comp_values: /* Empty */0,
            comp_constrs: /* Empty */0,
            comp_labels: /* Empty */0,
            comp_types: /* Empty */0,
            comp_modules: /* Empty */0,
            comp_modtypes: /* Empty */0,
            comp_components: /* Empty */0,
            comp_classes: /* Empty */0,
            comp_cltypes: /* Empty */0
          }
        };
}

function store_value(check, slot, id, path, decl, env, renv) {
  check_value_name(id.name, decl.val_loc);
  may((function (f) {
          check_usage(decl.val_loc, id, f, value_declarations);
        }), check);
  return {
          values: add$6("value", slot, id, [
                path,
                decl
              ], env.values, renv.values),
          constrs: env.constrs,
          labels: env.labels,
          types: env.types,
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: {
            TAG: /* Env_value */0,
            _0: env.summary,
            _1: id,
            _2: decl
          },
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags
        };
}

function store_type(check, slot, id, path, info, env, renv) {
  const loc = info.type_loc;
  if (check) {
    check_usage(loc, id, (function (s) {
            return {
                    TAG: /* Unused_type_declaration */18,
                    _0: s
                  };
          }), type_declarations);
  }
  const constructors = constructors_of_type(path, info);
  const labels = labels_of_type(path, info);
  const descrs_0 = Stdlib__List.map((function (prim) {
          return prim[1];
        }), constructors);
  const descrs_1 = Stdlib__List.map((function (prim) {
          return prim[1];
        }), labels);
  const descrs = [
    descrs_0,
    descrs_1
  ];
  if (check && !loc.loc_ghost && is_active({
          TAG: /* Unused_constructor */21,
          _0: "",
          _1: false,
          _2: false
        })) {
    const ty = id.name;
    Stdlib__List.iter((function (param) {
            const c = param[1].cstr_name;
            const k = [
              ty,
              loc,
              c
            ];
            if (Stdlib__Hashtbl.mem(used_constructors, k)) {
              return ;
            }
            const used = {
              cu_positive: false,
              cu_pattern: false,
              cu_privatize: false
            };
            Stdlib__Hashtbl.add(used_constructors, k, (function (param) {
                    return add_constructor_usage(used, param);
                  }));
            if (!(ty === "" || Caml_string.get(ty, 0) === /* '_' */95)) {
              return Curry._1(add_delayed_check_forward.contents, (function (param) {
                            if (!is_in_signature(env) && !used.cu_positive) {
                              return prerr_warning(loc, {
                                          TAG: /* Unused_constructor */21,
                                          _0: c,
                                          _1: used.cu_pattern,
                                          _2: used.cu_privatize
                                        });
                            }
                            
                          }));
            }
            
          }), constructors);
  }
  return {
          values: env.values,
          constrs: Stdlib__List.fold_right((function (param, constrs) {
                  return add$6("constructor", slot, param[0], param[1], constrs, renv.constrs);
                }), constructors, env.constrs),
          labels: Stdlib__List.fold_right((function (param, labels) {
                  return add$6("label", slot, param[0], param[1], labels, renv.labels);
                }), labels, env.labels),
          types: add$6("type", slot, id, [
                path,
                [
                  info,
                  descrs
                ]
              ], env.types, renv.types),
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: {
            TAG: /* Env_type */1,
            _0: env.summary,
            _1: id,
            _2: info
          },
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags
        };
}

function store_extension(check, slot, id, path, ext, env, renv) {
  const loc = ext.ext_loc;
  if (check && !loc.loc_ghost && is_active({
          TAG: /* Unused_extension */22,
          _0: "",
          _1: false,
          _2: false
        })) {
    const ty = last(ext.ext_type_path);
    const n = id.name;
    const k = [
      ty,
      loc,
      n
    ];
    if (!Stdlib__Hashtbl.mem(used_constructors, k)) {
      const used = {
        cu_positive: false,
        cu_pattern: false,
        cu_privatize: false
      };
      Stdlib__Hashtbl.add(used_constructors, k, (function (param) {
              return add_constructor_usage(used, param);
            }));
      Curry._1(add_delayed_check_forward.contents, (function (param) {
              if (!is_in_signature(env) && !used.cu_positive) {
                return prerr_warning(loc, {
                            TAG: /* Unused_extension */22,
                            _0: n,
                            _1: used.cu_pattern,
                            _2: used.cu_privatize
                          });
              }
              
            }));
    }
    
  }
  return {
          values: env.values,
          constrs: add$6("constructor", slot, id, extension_descr(path, ext), env.constrs, renv.constrs),
          labels: env.labels,
          types: env.types,
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: {
            TAG: /* Env_extension */2,
            _0: env.summary,
            _1: id,
            _2: ext
          },
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags
        };
}

function store_class(slot, id, path, desc, env, renv) {
  return {
          values: env.values,
          constrs: env.constrs,
          labels: env.labels,
          types: env.types,
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: add$6("class", slot, id, [
                path,
                desc
              ], env.classes, renv.classes),
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: {
            TAG: /* Env_class */5,
            _0: env.summary,
            _1: id,
            _2: desc
          },
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags
        };
}

function store_cltype(slot, id, path, desc, env, renv) {
  return {
          values: env.values,
          constrs: env.constrs,
          labels: env.labels,
          types: env.types,
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: env.classes,
          cltypes: add$6("class type", slot, id, [
                path,
                desc
              ], env.cltypes, renv.cltypes),
          functor_args: env.functor_args,
          summary: {
            TAG: /* Env_cltype */6,
            _0: env.summary,
            _1: id,
            _2: desc
          },
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags
        };
}

function components_of_functor_appl(f, p1, p2) {
  try {
    return Stdlib__Hashtbl.find(f.fcomp_cache, p2);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      const p = {
        TAG: /* Papply */2,
        _0: p1,
        _1: p2
      };
      const mty = modtype(add_module(f.fcomp_param, p2, identity), f.fcomp_res);
      const comps = components_of_module(f.fcomp_env, f.fcomp_subst, p, mty);
      Stdlib__Hashtbl.add(f.fcomp_cache, p2, comps);
      return comps;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

components_of_module$p.contents = components_of_module;

components_of_functor_appl$p.contents = components_of_functor_appl;

components_of_module_maker$p.contents = components_of_module_maker;

function add_value(check, id, desc, env) {
  return store_value(check, undefined, id, {
              TAG: /* Pident */0,
              _0: id
            }, desc, env, env);
}

function add_type$1(check, id, info, env) {
  return store_type(check, undefined, id, {
              TAG: /* Pident */0,
              _0: id
            }, info, env, env);
}

function add_extension(check, id, ext, env) {
  return store_extension(check, undefined, id, {
              TAG: /* Pident */0,
              _0: id
            }, ext, env, env);
}

function add_module_declaration(arg, id, md, env) {
  const path = {
    TAG: /* Pident */0,
    _0: id
  };
  const env$1 = store_module(undefined, id, path, md, env, env);
  const arg$1 = arg !== undefined ? arg : false;
  if (arg$1) {
    return {
            values: env$1.values,
            constrs: env$1.constrs,
            labels: env$1.labels,
            types: env$1.types,
            modules: env$1.modules,
            modtypes: env$1.modtypes,
            components: env$1.components,
            classes: env$1.classes,
            cltypes: env$1.cltypes,
            functor_args: add(id, undefined, env$1.functor_args),
            summary: {
              TAG: /* Env_functor_arg */8,
              _0: env$1.summary,
              _1: id
            },
            local_constraints: env$1.local_constraints,
            gadt_instances: env$1.gadt_instances,
            flags: env$1.flags
          };
  } else {
    return env$1;
  }
}

function add_modtype$1(id, info, env) {
  return store_modtype(undefined, id, {
              TAG: /* Pident */0,
              _0: id
            }, info, env, env);
}

function add_class(id, ty, env) {
  return store_class(undefined, id, {
              TAG: /* Pident */0,
              _0: id
            }, ty, env, env);
}

function add_cltype(id, ty, env) {
  return store_cltype(undefined, id, {
              TAG: /* Pident */0,
              _0: id
            }, ty, env, env);
}

function add_module$1(arg, id, mty, env) {
  return add_module_declaration(arg, id, {
              md_type: mty,
              md_attributes: /* [] */0,
              md_loc: none
            }, env);
}

function add_local_constraint(id, info, elv, env) {
  if (info.type_manifest !== undefined) {
    const match = info.type_newtype_level;
    if (match !== undefined) {
      const env$1 = add_type$1(false, id, {
            type_params: info.type_params,
            type_arity: info.type_arity,
            type_kind: info.type_kind,
            type_private: info.type_private,
            type_manifest: info.type_manifest,
            type_variance: info.type_variance,
            type_newtype_level: [
              match[0],
              elv
            ],
            type_loc: info.type_loc,
            type_attributes: info.type_attributes
          }, env);
      return {
              values: env$1.values,
              constrs: env$1.constrs,
              labels: env$1.labels,
              types: env$1.types,
              modules: env$1.modules,
              modtypes: env$1.modtypes,
              components: env$1.components,
              classes: env$1.classes,
              cltypes: env$1.cltypes,
              functor_args: env$1.functor_args,
              summary: env$1.summary,
              local_constraints: true,
              gadt_instances: env$1.gadt_instances,
              flags: env$1.flags
            };
    }
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                11231,
                9
              ]
            });
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              11231,
              9
            ]
          });
}

function enter(store_fun, name, data, env) {
  const id = create(name);
  return [
          id,
          Curry._6(store_fun, undefined, id, {
                TAG: /* Pident */0,
                _0: id
              }, data, env, env)
        ];
}

function enter_value(check) {
  return function (param, param$1, param$2) {
    return enter((function (param, param$1, param$2, param$3, param$4, param$5) {
                  return store_value(check, param, param$1, param$2, param$3, param$4, param$5);
                }), param, param$1, param$2);
  };
}

function enter_type(param, param$1, param$2) {
  return enter((function (param, param$1, param$2, param$3, param$4, param$5) {
                return store_type(true, param, param$1, param$2, param$3, param$4, param$5);
              }), param, param$1, param$2);
}

function enter_module_declaration(arg, name, md, env) {
  const id = create(name);
  return [
          id,
          add_module_declaration(arg, id, md, env)
        ];
}

function enter_modtype(param, param$1, param$2) {
  return enter(store_modtype, param, param$1, param$2);
}

function enter_module(arg, s, mty, env) {
  return enter_module_declaration(arg, s, {
              md_type: mty,
              md_attributes: /* [] */0,
              md_loc: none
            }, env);
}

function add_item(comp, env) {
  switch (comp.TAG | 0) {
    case /* Sig_value */0 :
        return add_value(undefined, comp._0, comp._1, env);
    case /* Sig_type */1 :
        return add_type$1(false, comp._0, comp._1, env);
    case /* Sig_typext */2 :
        return add_extension(false, comp._0, comp._1, env);
    case /* Sig_module */3 :
        return add_module_declaration(undefined, comp._0, comp._1, env);
    case /* Sig_modtype */4 :
        return add_modtype$1(comp._0, comp._1, env);
    case /* Sig_class */5 :
        return add_class(comp._0, comp._1, env);
    case /* Sig_class_type */6 :
        return add_cltype(comp._0, comp._1, env);
    
  }
}

function add_signature(_sg, _env) {
  while(true) {
    const env = _env;
    const sg = _sg;
    if (!sg) {
      return env;
    }
    _env = add_item(sg.hd, env);
    _sg = sg.tl;
    continue ;
  };
}

function open_signature(slot, root, sg, env0) {
  const match = prefix_idents_and_subst$1(root, identity, sg);
  const sg$1 = CamlinternalLazy.force(match[2]);
  const newenv = Stdlib__List.fold_left2((function (env, item, p) {
          switch (item.TAG | 0) {
            case /* Sig_value */0 :
                return store_value(undefined, slot, hide(item._0), p, item._1, env, env0);
            case /* Sig_type */1 :
                return store_type(false, slot, hide(item._0), p, item._1, env, env0);
            case /* Sig_typext */2 :
                return store_extension(false, slot, hide(item._0), p, item._1, env, env0);
            case /* Sig_module */3 :
                return store_module(slot, hide(item._0), p, item._1, env, env0);
            case /* Sig_modtype */4 :
                return store_modtype(slot, hide(item._0), p, item._1, env, env0);
            case /* Sig_class */5 :
                return store_class(slot, hide(item._0), p, item._1, env, env0);
            case /* Sig_class_type */6 :
                return store_cltype(slot, hide(item._0), p, item._1, env, env0);
            
          }
        }), env0, sg$1, match[0]);
  return {
          values: newenv.values,
          constrs: newenv.constrs,
          labels: newenv.labels,
          types: newenv.types,
          modules: newenv.modules,
          modtypes: newenv.modtypes,
          components: newenv.components,
          classes: newenv.classes,
          cltypes: newenv.cltypes,
          functor_args: newenv.functor_args,
          summary: {
            TAG: /* Env_open */7,
            _0: env0.summary,
            _1: root
          },
          local_constraints: newenv.local_constraints,
          gadt_instances: newenv.gadt_instances,
          flags: newenv.flags
        };
}

function open_signature$1(locOpt, toplevelOpt, ovf, root, sg, env) {
  const loc = locOpt !== undefined ? locOpt : none;
  const toplevel = toplevelOpt !== undefined ? toplevelOpt : false;
  if (!(!toplevel && ovf === /* Fresh */1 && !loc.loc_ghost && (is_active({
              TAG: /* Unused_open */17,
              _0: ""
            }) || is_active({
              TAG: /* Open_shadow_identifier */27,
              _0: "",
              _1: ""
            }) || is_active({
              TAG: /* Open_shadow_label_constructor */28,
              _0: "",
              _1: ""
            })))) {
    return open_signature(undefined, root, sg, env);
  }
  const used = {
    contents: false
  };
  Curry._1(add_delayed_check_forward.contents, (function (param) {
          if (!used.contents) {
            return prerr_warning(loc, {
                        TAG: /* Unused_open */17,
                        _0: name(undefined, root)
                      });
          }
          
        }));
  const shadowed = {
    contents: /* [] */0
  };
  const slot = function (kind, s, b) {
    if (b && !Stdlib__List.mem([
            kind,
            s
          ], shadowed.contents)) {
      shadowed.contents = {
        hd: [
          kind,
          s
        ],
        tl: shadowed.contents
      };
      let w;
      switch (kind) {
        case "constructor" :
        case "label" :
            w = {
              TAG: /* Open_shadow_label_constructor */28,
              _0: kind,
              _1: s
            };
            break;
        default:
          w = {
            TAG: /* Open_shadow_identifier */27,
            _0: kind,
            _1: s
          };
      }
      prerr_warning(loc, w);
    }
    used.contents = true;
  };
  return open_signature(slot, root, sg, env);
}

function read_signature(modname, filename) {
  const ps = read_pers_struct(modname, filename);
  check_consistency(ps);
  return ps.ps_sig;
}

function imports(param) {
  const dont_record_crc_unit$1 = dont_record_crc_unit.contents;
  if (dont_record_crc_unit$1 !== undefined) {
    return extract(Curry._3(fold$5, (function (m, acc) {
                      if (m === dont_record_crc_unit$1) {
                        return acc;
                      } else {
                        return {
                                hd: m,
                                tl: acc
                              };
                      }
                    }), imported_units.contents, /* [] */0), crc_units);
  } else {
    return extract(Curry._1(elements$2, imported_units.contents), crc_units);
  }
}

function save_signature(sg, modname, filename) {
  let imports$1 = imports(undefined);
  cleanup_abbrev(undefined);
  new_id$1.contents = -1;
  const sg$1 = signature$2(for_saving(identity), sg);
  const oc = Stdlib.open_out_bin(filename);
  try {
    const cmi_cmi_flags = recursive_types.contents ? ({
          hd: /* Rectypes */0,
          tl: /* [] */0
        }) : /* [] */0;
    const cmi = {
      cmi_name: modname,
      cmi_sign: sg$1,
      cmi_crcs: imports$1,
      cmi_flags: cmi_cmi_flags
    };
    const crc = output_cmi(filename, oc, cmi);
    Caml_io.caml_ml_flush(oc);
    Caml_external_polyfill.resolve("caml_ml_close_channel")(oc);
    const comps = components_of_module(empty, identity, {
          TAG: /* Pident */0,
          _0: {
            stamp: 0,
            name: modname,
            flags: 1
          }
        }, {
          TAG: /* Mty_signature */1,
          _0: sg$1
        });
    const ps = {
      ps_name: modname,
      ps_sig: sg$1,
      ps_comps: comps,
      ps_crcs: {
        hd: [
          modname,
          crc
        ],
        tl: imports$1
      },
      ps_crcs_checked: false,
      ps_filename: filename,
      ps_flags: cmi_cmi_flags
    };
    save_pers_struct(crc, ps);
    return sg$1;
  }
  catch (exn){
    Caml_io.caml_ml_flush(oc);
    Caml_external_polyfill.resolve("caml_ml_close_channel")(oc);
    remove_file(filename);
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function find_all$1(proj1, proj2, f, lid, env, acc) {
  if (lid === undefined) {
    return fold_name(function (id, param, acc) {
                  return Curry._4(f, id.name, param[0], param[1], acc);
                })(Curry._1(proj1, env), acc);
  }
  const match = lookup_module_descr(lid, env);
  const p = match[0];
  const c = force(components_of_module_maker, match[1]);
  if (c.TAG === /* Structure_comps */0) {
    return fold$4((function (s, param, acc) {
                  return Curry._4(f, s, {
                              TAG: /* Pdot */1,
                              _0: p,
                              _1: s,
                              _2: param[1]
                            }, param[0], acc);
                }), Curry._1(proj2, c._0), acc);
  } else {
    return acc;
  }
}

function find_all_simple_list(proj1, proj2, f, lid, env, acc) {
  if (lid === undefined) {
    return fold_name(function (id, data, acc) {
                  return Curry._2(f, data, acc);
                })(Curry._1(proj1, env), acc);
  }
  const match = lookup_module_descr(lid, env);
  const c = force(components_of_module_maker, match[1]);
  if (c.TAG === /* Structure_comps */0) {
    return fold$4((function (s, comps, acc) {
                  if (comps) {
                    return Curry._2(f, comps.hd[0], acc);
                  } else {
                    return acc;
                  }
                }), Curry._1(proj2, c._0), acc);
  } else {
    return acc;
  }
}

function fold_modules(f, lid, env, acc) {
  if (lid !== undefined) {
    const match = lookup_module_descr(lid, env);
    const p = match[0];
    const c = force(components_of_module_maker, match[1]);
    if (c.TAG === /* Structure_comps */0) {
      return fold$4((function (s, param, acc) {
                    const md_type = force(subst_modtype_maker, param[0]);
                    return Curry._4(f, s, {
                                TAG: /* Pdot */1,
                                _0: p,
                                _1: s,
                                _2: param[1]
                              }, {
                                md_type: md_type,
                                md_attributes: /* [] */0,
                                md_loc: none
                              }, acc);
                  }), c._0.comp_modules, acc);
    } else {
      return acc;
    }
  }
  const acc$1 = fold_name(function (id, param, acc) {
          return Curry._4(f, id.name, param[0], param[1], acc);
        })(env.modules, acc);
  return Stdlib__Hashtbl.fold((function (name, ps, acc) {
                if (ps !== undefined) {
                  return Curry._4(f, name, {
                              TAG: /* Pident */0,
                              _0: {
                                stamp: 0,
                                name: name,
                                flags: 1
                              }
                            }, {
                              md_type: {
                                TAG: /* Mty_signature */1,
                                _0: ps.ps_sig
                              },
                              md_attributes: /* [] */0,
                              md_loc: none
                            }, acc);
                } else {
                  return acc;
                }
              }), persistent_structures, acc$1);
}

function fold_values(f) {
  return function (param, param$1, param$2) {
    return find_all$1((function (env) {
                  return env.values;
                }), (function (sc) {
                  return sc.comp_values;
                }), f, param, param$1, param$2);
  };
}

function fold_constructors(f) {
  return function (param, param$1, param$2) {
    return find_all_simple_list((function (env) {
                  return env.constrs;
                }), (function (sc) {
                  return sc.comp_constrs;
                }), f, param, param$1, param$2);
  };
}

function fold_labels(f) {
  return function (param, param$1, param$2) {
    return find_all_simple_list((function (env) {
                  return env.labels;
                }), (function (sc) {
                  return sc.comp_labels;
                }), f, param, param$1, param$2);
  };
}

function fold_types(f) {
  return function (param, param$1, param$2) {
    return find_all$1((function (env) {
                  return env.types;
                }), (function (sc) {
                  return sc.comp_types;
                }), f, param, param$1, param$2);
  };
}

function fold_modtypes(f) {
  return function (param, param$1, param$2) {
    return find_all$1((function (env) {
                  return env.modtypes;
                }), (function (sc) {
                  return sc.comp_modtypes;
                }), f, param, param$1, param$2);
  };
}

function fold_classs(f) {
  return function (param, param$1, param$2) {
    return find_all$1((function (env) {
                  return env.classes;
                }), (function (sc) {
                  return sc.comp_classes;
                }), f, param, param$1, param$2);
  };
}

function fold_cltypes(f) {
  return function (param, param$1, param$2) {
    return find_all$1((function (env) {
                  return env.cltypes;
                }), (function (sc) {
                  return sc.comp_cltypes;
                }), f, param, param$1, param$2);
  };
}

const match = build_initial_env((function (param, param$1, param$2) {
        return add_type$1(false, param, param$1, param$2);
      }), (function (param, param$1, param$2) {
        return add_extension(false, param, param$1, param$2);
      }), empty);

const initial_safe_string = match[0];

const last_env = {
  contents: empty
};

const last_reduced_env = {
  contents: empty
};

function keep_only_summary(env) {
  if (last_env.contents === env) {
    return last_reduced_env.contents;
  }
  const new_env_summary = env.summary;
  const new_env_local_constraints = env.local_constraints;
  const new_env_flags = env.flags;
  const new_env = {
    values: /* Empty */0,
    constrs: /* Empty */0,
    labels: /* Empty */0,
    types: /* Empty */0,
    modules: /* Empty */0,
    modtypes: /* Empty */0,
    components: /* Empty */0,
    classes: /* Empty */0,
    cltypes: /* Empty */0,
    functor_args: /* Empty */0,
    summary: new_env_summary,
    local_constraints: new_env_local_constraints,
    gadt_instances: /* [] */0,
    flags: new_env_flags
  };
  last_env.contents = env;
  last_reduced_env.contents = new_env;
  return new_env;
}

function report_error$1(ppf, param) {
  switch (param.TAG | 0) {
    case /* Illegal_renaming */0 :
        return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "Wrong file naming: ",
                          _1: {
                            TAG: /* Alpha */15,
                            _0: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@ ",
                                _1: 1,
                                _2: 0
                              },
                              _1: {
                                TAG: /* String_literal */11,
                                _0: "contains the compiled interface for ",
                                _1: {
                                  TAG: /* Formatting_lit */17,
                                  _0: {
                                    TAG: /* Break */0,
                                    _0: "@ ",
                                    _1: 1,
                                    _2: 0
                                  },
                                  _1: {
                                    TAG: /* String */2,
                                    _0: /* No_padding */0,
                                    _1: {
                                      TAG: /* String_literal */11,
                                      _0: " when ",
                                      _1: {
                                        TAG: /* String */2,
                                        _0: /* No_padding */0,
                                        _1: {
                                          TAG: /* String_literal */11,
                                          _0: " was expected",
                                          _1: /* End_of_format */0
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "Wrong file naming: %a@ contains the compiled interface for @ %s when %s was expected"
                      }), print_filename, param._2, param._0, param._1);
    case /* Inconsistent_import */1 :
        return Curry._5(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<hov>",
                                _1: /* End_of_format */0
                              },
                              _1: "<hov>"
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "The files ",
                            _1: {
                              TAG: /* Alpha */15,
                              _0: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@ ",
                                  _1: 1,
                                  _2: 0
                                },
                                _1: {
                                  TAG: /* String_literal */11,
                                  _0: "and ",
                                  _1: {
                                    TAG: /* Alpha */15,
                                    _0: {
                                      TAG: /* Formatting_lit */17,
                                      _0: {
                                        TAG: /* Break */0,
                                        _0: "@ ",
                                        _1: 1,
                                        _2: 0
                                      },
                                      _1: {
                                        TAG: /* String_literal */11,
                                        _0: "make inconsistent assumptions",
                                        _1: {
                                          TAG: /* Formatting_lit */17,
                                          _0: {
                                            TAG: /* Break */0,
                                            _0: "@ ",
                                            _1: 1,
                                            _2: 0
                                          },
                                          _1: {
                                            TAG: /* String_literal */11,
                                            _0: "over interface ",
                                            _1: {
                                              TAG: /* String */2,
                                              _0: /* No_padding */0,
                                              _1: {
                                                TAG: /* Formatting_lit */17,
                                                _0: /* Close_box */0,
                                                _1: /* End_of_format */0
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@[<hov>The files %a@ and %a@ make inconsistent assumptions@ over interface %s@]"
                      }), print_filename, param._1, print_filename, param._2, param._0);
    case /* Need_recursive_types */2 :
        return Curry._3(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<hov>",
                                _1: /* End_of_format */0
                              },
                              _1: "<hov>"
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "Unit ",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* String_literal */11,
                                _0: " imports from ",
                                _1: {
                                  TAG: /* String */2,
                                  _0: /* No_padding */0,
                                  _1: {
                                    TAG: /* String_literal */11,
                                    _0: ", which uses recursive types.",
                                    _1: {
                                      TAG: /* Formatting_lit */17,
                                      _0: {
                                        TAG: /* Break */0,
                                        _0: "@ ",
                                        _1: 1,
                                        _2: 0
                                      },
                                      _1: {
                                        TAG: /* String */2,
                                        _0: /* No_padding */0,
                                        _1: {
                                          TAG: /* Formatting_lit */17,
                                          _0: /* Close_box */0,
                                          _1: /* End_of_format */0
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@[<hov>Unit %s imports from %s, which uses recursive types.@ %s@]"
                      }), param._1, param._0, "The compilation flag -rectypes is required");
    case /* Missing_module */3 :
        const path2 = param._2;
        const path1 = param._1;
        Stdlib__Format.fprintf(ppf)(/* Format */{
              _0: {
                TAG: /* Formatting_gen */18,
                _0: {
                  TAG: /* Open_box */1,
                  _0: /* Format */{
                    _0: /* End_of_format */0,
                    _1: ""
                  }
                },
                _1: {
                  TAG: /* Formatting_gen */18,
                  _0: {
                    TAG: /* Open_box */1,
                    _0: /* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "<hov>",
                        _1: /* End_of_format */0
                      },
                      _1: "<hov>"
                    }
                  },
                  _1: /* End_of_format */0
                }
              },
              _1: "@[@[<hov>"
            });
        if (same(path1, path2)) {
          Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "Internal path",
                      _1: {
                        TAG: /* Formatting_lit */17,
                        _0: {
                          TAG: /* Break */0,
                          _0: "@ ",
                          _1: 1,
                          _2: 0
                        },
                        _1: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* Formatting_lit */17,
                            _0: {
                              TAG: /* Break */0,
                              _0: "@ ",
                              _1: 1,
                              _2: 0
                            },
                            _1: {
                              TAG: /* String_literal */11,
                              _0: "is dangling.",
                              _1: /* End_of_format */0
                            }
                          }
                        }
                      }
                    },
                    _1: "Internal path@ %s@ is dangling."
                  }), name(undefined, path1));
        } else {
          Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "Internal path",
                      _1: {
                        TAG: /* Formatting_lit */17,
                        _0: {
                          TAG: /* Break */0,
                          _0: "@ ",
                          _1: 1,
                          _2: 0
                        },
                        _1: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* Formatting_lit */17,
                            _0: {
                              TAG: /* Break */0,
                              _0: "@ ",
                              _1: 1,
                              _2: 0
                            },
                            _1: {
                              TAG: /* String_literal */11,
                              _0: "expands to",
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@ ",
                                  _1: 1,
                                  _2: 0
                                },
                                _1: {
                                  TAG: /* String */2,
                                  _0: /* No_padding */0,
                                  _1: {
                                    TAG: /* Formatting_lit */17,
                                    _0: {
                                      TAG: /* Break */0,
                                      _0: "@ ",
                                      _1: 1,
                                      _2: 0
                                    },
                                    _1: {
                                      TAG: /* String_literal */11,
                                      _0: "which is dangling.",
                                      _1: /* End_of_format */0
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    _1: "Internal path@ %s@ expands to@ %s@ which is dangling."
                  }), name(undefined, path1), name(undefined, path2));
        }
        return Curry._3(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_lit */17,
                          _0: /* Close_box */0,
                          _1: {
                            TAG: /* Formatting_lit */17,
                            _0: {
                              TAG: /* Break */0,
                              _0: "@ ",
                              _1: 1,
                              _2: 0
                            },
                            _1: {
                              TAG: /* Formatting_gen */18,
                              _0: {
                                TAG: /* Open_box */1,
                                _0: /* Format */{
                                  _0: /* End_of_format */0,
                                  _1: ""
                                }
                              },
                              _1: {
                                TAG: /* String */2,
                                _0: /* No_padding */0,
                                _1: {
                                  TAG: /* Formatting_lit */17,
                                  _0: {
                                    TAG: /* Break */0,
                                    _0: "@ ",
                                    _1: 1,
                                    _2: 0
                                  },
                                  _1: {
                                    TAG: /* String */2,
                                    _0: /* No_padding */0,
                                    _1: {
                                      TAG: /* Formatting_lit */17,
                                      _0: {
                                        TAG: /* Break */0,
                                        _0: "@ ",
                                        _1: 1,
                                        _2: 0
                                      },
                                      _1: {
                                        TAG: /* String */2,
                                        _0: /* No_padding */0,
                                        _1: {
                                          TAG: /* Char_literal */12,
                                          _0: /* '.' */46,
                                          _1: {
                                            TAG: /* Formatting_lit */17,
                                            _0: /* Close_box */0,
                                            _1: {
                                              TAG: /* Formatting_lit */17,
                                              _0: /* Close_box */0,
                                              _1: /* End_of_format */0
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@]@ @[%s@ %s@ %s.@]@]"
                      }), "The compiled interface for module", head(path2).name, "was not found");
    case /* Illegal_value_name */4 :
        return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Char_literal */12,
                          _0: /* '\'' */39,
                          _1: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: {
                              TAG: /* String_literal */11,
                              _0: "' is not a valid value identifier.",
                              _1: /* End_of_format */0
                            }
                          }
                        },
                        _1: "'%s' is not a valid value identifier."
                      }), param._1);
    
  }
}

register_error_of_exn(function (err) {
      if (err.MEL_EXN_ID !== $$Error$2) {
        return ;
      }
      const err$1 = err._1;
      switch (err$1.TAG | 0) {
        case /* Missing_module */3 :
        case /* Illegal_value_name */4 :
            break;
        default:
          return error_of_printer_file(report_error$1, err$1);
      }
      const loc = err$1._0;
      if (Caml_obj.caml_notequal(loc, none)) {
        return error_of_printer(loc, report_error$1, err$1);
      } else {
        return error_of_printer_file(report_error$1, err$1);
      }
    });

function assert_fail(msg) {
  Assert.fail(undefined, undefined, msg, "");
}

function is_mocha(param) {
  const match = Stdlib__Array.to_list(Process.argv);
  if (!match) {
    return false;
  }
  const match$1 = match.tl;
  if (!match$1) {
    return false;
  }
  const exec = Path.basename(match$1.hd);
  if (exec === "mocha") {
    return true;
  } else {
    return exec === "_mocha";
  }
}

function close_enough(thresholdOpt, a, b) {
  const threshold = thresholdOpt !== undefined ? thresholdOpt : 0.0000001;
  return Math.abs(a - b) < threshold;
}

function from_pair_suites(name, suites) {
  const match = Stdlib__Array.to_list(Process.argv);
  if (match) {
    if (is_mocha(undefined)) {
      describe(name, (function () {
              return Stdlib__List.iter((function (param) {
                            const code = param[1];
                            it(param[0], (function () {
                                    let spec = Curry._1(code, undefined);
                                    switch (spec.TAG | 0) {
                                      case /* Eq */0 :
                                          Assert.deepEqual(spec._0, spec._1);
                                          return ;
                                      case /* Neq */1 :
                                          Assert.notDeepEqual(spec._0, spec._1);
                                          return ;
                                      case /* StrictEq */2 :
                                          Assert.strictEqual(spec._0, spec._1);
                                          return ;
                                      case /* StrictNeq */3 :
                                          Assert.notStrictEqual(spec._0, spec._1);
                                          return ;
                                      case /* Ok */4 :
                                          Assert.ok(spec._0);
                                          return ;
                                      case /* Approx */5 :
                                          const b = spec._1;
                                          const a = spec._0;
                                          if (!close_enough(undefined, a, b)) {
                                            Assert.deepEqual(a, b);
                                            return ;
                                          } else {
                                            return ;
                                          }
                                      case /* ApproxThreshold */6 :
                                          const b$1 = spec._2;
                                          const a$1 = spec._1;
                                          if (!close_enough(spec._0, a$1, b$1)) {
                                            Assert.deepEqual(a$1, b$1);
                                            return ;
                                          } else {
                                            return ;
                                          }
                                      case /* ThrowAny */7 :
                                          Assert.throws(spec._0);
                                          return ;
                                      case /* Fail */8 :
                                          return assert_fail("failed");
                                      case /* FailWith */9 :
                                          return assert_fail(spec._0);
                                      
                                    }
                                  }));
                          }), suites);
            }));
      return ;
    } else {
      console.log([
            name,
            "testing"
          ]);
      return Stdlib__List.iter((function (param) {
                    const name = param[0];
                    const fn = Curry._1(param[1], undefined);
                    switch (fn.TAG | 0) {
                      case /* Eq */0 :
                          console.log([
                                name,
                                fn._0,
                                "eq?",
                                fn._1
                              ]);
                          return ;
                      case /* Neq */1 :
                          console.log([
                                name,
                                fn._0,
                                "neq?",
                                fn._1
                              ]);
                          return ;
                      case /* StrictEq */2 :
                          console.log([
                                name,
                                fn._0,
                                "strict_eq?",
                                fn._1
                              ]);
                          return ;
                      case /* StrictNeq */3 :
                          console.log([
                                name,
                                fn._0,
                                "strict_neq?",
                                fn._1
                              ]);
                          return ;
                      case /* Ok */4 :
                          console.log([
                                name,
                                fn._0,
                                "ok?"
                              ]);
                          return ;
                      case /* Approx */5 :
                          console.log([
                                name,
                                fn._0,
                                "~",
                                fn._1
                              ]);
                          return ;
                      case /* ApproxThreshold */6 :
                          console.log([
                                name,
                                fn._1,
                                "~",
                                fn._2,
                                " (",
                                fn._0,
                                ")"
                              ]);
                          return ;
                      case /* ThrowAny */7 :
                          return ;
                      case /* Fail */8 :
                          console.log("failed");
                          return ;
                      case /* FailWith */9 :
                          console.log("failed: " + fn._0);
                          return ;
                      
                    }
                  }), suites);
    }
  }
  
}

Promise.resolve(undefined);

const $$Error$3 = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Syntaxerr.Error");

const Escape_error = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Syntaxerr.Escape_error");

function prepare_error(loc) {
  switch (loc.TAG | 0) {
    case /* Unclosed */0 :
        const closing = loc._3;
        const opening = loc._1;
        return Curry._1(errorf(loc._2, {
                        hd: Curry._1(errorf(loc._0, undefined, undefined, /* Format */{
                                  _0: {
                                    TAG: /* String_literal */11,
                                    _0: "This '",
                                    _1: {
                                      TAG: /* String */2,
                                      _0: /* No_padding */0,
                                      _1: {
                                        TAG: /* String_literal */11,
                                        _0: "' might be unmatched",
                                        _1: /* End_of_format */0
                                      }
                                    }
                                  },
                                  _1: "This '%s' might be unmatched"
                                }), opening),
                        tl: /* [] */0
                      }, Curry._2(Stdlib__Printf.sprintf(/* Format */{
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: "Syntax error: '",
                                  _1: {
                                    TAG: /* String */2,
                                    _0: /* No_padding */0,
                                    _1: {
                                      TAG: /* String_literal */11,
                                      _0: "' expected, the highlighted '",
                                      _1: {
                                        TAG: /* String */2,
                                        _0: /* No_padding */0,
                                        _1: {
                                          TAG: /* String_literal */11,
                                          _0: "' might be unmatched",
                                          _1: /* End_of_format */0
                                        }
                                      }
                                    }
                                  }
                                },
                                _1: "Syntax error: '%s' expected, the highlighted '%s' might be unmatched"
                              }), closing, opening), /* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "Syntax error: '",
                          _1: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: {
                              TAG: /* String_literal */11,
                              _0: "' expected",
                              _1: /* End_of_format */0
                            }
                          }
                        },
                        _1: "Syntax error: '%s' expected"
                      }), closing);
    case /* Expecting */1 :
        return Curry._1(errorf(loc._0, undefined, undefined, /* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "Syntax error: ",
                          _1: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: {
                              TAG: /* String_literal */11,
                              _0: " expected.",
                              _1: /* End_of_format */0
                            }
                          }
                        },
                        _1: "Syntax error: %s expected."
                      }), loc._1);
    case /* Not_expecting */2 :
        return Curry._1(errorf(loc._0, undefined, undefined, /* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "Syntax error: ",
                          _1: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: {
                              TAG: /* String_literal */11,
                              _0: " not expected.",
                              _1: /* End_of_format */0
                            }
                          }
                        },
                        _1: "Syntax error: %s not expected."
                      }), loc._1);
    case /* Applicative_path */3 :
        return errorf(loc._0, undefined, undefined, /* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "Syntax error: applicative paths of the form F(X).t are not supported when the option -no-app-func is set.",
                      _1: /* End_of_format */0
                    },
                    _1: "Syntax error: applicative paths of the form F(X).t are not supported when the option -no-app-func is set."
                  });
    case /* Variable_in_scope */4 :
        const $$var = loc._1;
        return Curry._2(errorf(loc._0, undefined, undefined, /* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "In this scoped type, variable '",
                          _1: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: {
                              TAG: /* String_literal */11,
                              _0: " is reserved for the local type ",
                              _1: {
                                TAG: /* String */2,
                                _0: /* No_padding */0,
                                _1: {
                                  TAG: /* Char_literal */12,
                                  _0: /* '.' */46,
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          }
                        },
                        _1: "In this scoped type, variable '%s is reserved for the local type %s."
                      }), $$var, $$var);
    case /* Other */5 :
        return errorf(loc._0, undefined, undefined, /* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "Syntax error",
                      _1: /* End_of_format */0
                    },
                    _1: "Syntax error"
                  });
    case /* Ill_formed_ast */6 :
        return Curry._1(errorf(loc._0, undefined, undefined, /* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "broken invariant in parsetree: ",
                          _1: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: /* End_of_format */0
                          }
                        },
                        _1: "broken invariant in parsetree: %s"
                      }), loc._1);
    
  }
}

register_error_of_exn(function (err) {
      if (err.MEL_EXN_ID === $$Error$3) {
        return prepare_error(err._1);
      }
      
    });

function ill_formed_ast(loc, s) {
  throw new Caml_js_exceptions.MelangeError($$Error$3, {
            MEL_EXN_ID: $$Error$3,
            _1: {
              TAG: /* Ill_formed_ast */6,
              _0: loc,
              _1: s
            }
          });
}

function mktyp(d) {
  return mk(symbol_rloc(undefined), undefined, d);
}

function mkpat(d) {
  return mk$1(symbol_rloc(undefined), undefined, d);
}

function mkexp(d) {
  return Curry._3(Ast_helper_Exp.mk, symbol_rloc(undefined), undefined, d);
}

function mkmty(d) {
  return mk$3(symbol_rloc(undefined), undefined, d);
}

function mksig(d) {
  return mk$5(symbol_rloc(undefined), d);
}

function mkmod(d) {
  return mk$4(symbol_rloc(undefined), undefined, d);
}

function mkstr(d) {
  return mk$6(symbol_rloc(undefined), d);
}

function mkclass(d) {
  return mk$7(symbol_rloc(undefined), undefined, d);
}

function mkcty(d) {
  return mk$8(symbol_rloc(undefined), undefined, d);
}

function mkctf(attrs, docs, d) {
  return Curry._4(Ast_helper_Ctf.mk, symbol_rloc(undefined), attrs, docs, d);
}

function mkcf(attrs, docs, d) {
  return Curry._4(Ast_helper_Cf.mk, symbol_rloc(undefined), attrs, docs, d);
}

function mkoption(d) {
  const init = d.ptyp_loc;
  const loc_loc_start = init.loc_start;
  const loc_loc_end = init.loc_end;
  const loc = {
    loc_start: loc_loc_start,
    loc_end: loc_loc_end,
    loc_ghost: true
  };
  return mk(loc, undefined, {
              TAG: /* Ptyp_constr */3,
              _0: {
                txt: {
                  TAG: /* Ldot */1,
                  _0: {
                    TAG: /* Lident */0,
                    _0: "*predef*"
                  },
                  _1: "option"
                },
                loc: loc
              },
              _1: {
                hd: d,
                tl: /* [] */0
              }
            });
}

function reloc_pat(x) {
  return {
          ppat_desc: x.ppat_desc,
          ppat_loc: symbol_rloc(undefined),
          ppat_attributes: x.ppat_attributes
        };
}

function reloc_exp(x) {
  return {
          pexp_desc: x.pexp_desc,
          pexp_loc: symbol_rloc(undefined),
          pexp_attributes: x.pexp_attributes
        };
}

function mkoperator(name, pos) {
  const loc = rhs_loc(pos);
  return Curry._3(Ast_helper_Exp.mk, loc, undefined, {
              TAG: /* Pexp_ident */0,
              _0: {
                txt: {
                  TAG: /* Lident */0,
                  _0: name
                },
                loc: loc
              }
            });
}

function mkpatvar(name, pos) {
  return mk$1(rhs_loc(pos), undefined, {
              TAG: /* Ppat_var */0,
              _0: {
                txt: name,
                loc: rhs_loc(pos)
              }
            });
}

function ghexp(d) {
  return Curry._3(Ast_helper_Exp.mk, symbol_gloc(undefined), undefined, d);
}

function ghpat(d) {
  return mk$1(symbol_gloc(undefined), undefined, d);
}

function ghtyp(d) {
  return mk(symbol_gloc(undefined), undefined, d);
}

function mkinfix(arg1, name, arg2) {
  return mkexp({
              TAG: /* Pexp_apply */5,
              _0: mkoperator(name, 2),
              _1: {
                hd: [
                  "",
                  arg1
                ],
                tl: {
                  hd: [
                    "",
                    arg2
                  ],
                  tl: /* [] */0
                }
              }
            });
}

function neg_float_string(f) {
  if (f.length !== 0 && Caml_string.get(f, 0) === /* '-' */45) {
    return Stdlib__String.sub(f, 1, f.length - 1 | 0);
  } else {
    return "-" + f;
  }
}

function mkexp_cons(consloc, args, loc) {
  return Curry._3(Ast_helper_Exp.mk, loc, undefined, {
              TAG: /* Pexp_construct */9,
              _0: {
                txt: {
                  TAG: /* Lident */0,
                  _0: "::"
                },
                loc: consloc
              },
              _1: args
            });
}

function mkpat_cons(consloc, args, loc) {
  return mk$1(loc, undefined, {
              TAG: /* Ppat_construct */5,
              _0: {
                txt: {
                  TAG: /* Lident */0,
                  _0: "::"
                },
                loc: consloc
              },
              _1: args
            });
}

function mktailexp(nilloc, param) {
  if (param) {
    const e1 = param.hd;
    const exp_el = mktailexp(nilloc, param.tl);
    const loc_loc_start = e1.pexp_loc.loc_start;
    const loc_loc_end = exp_el.pexp_loc.loc_end;
    const loc = {
      loc_start: loc_loc_start,
      loc_end: loc_loc_end,
      loc_ghost: true
    };
    const arg = Curry._3(Ast_helper_Exp.mk, loc, undefined, {
          TAG: /* Pexp_tuple */8,
          _0: {
            hd: e1,
            tl: {
              hd: exp_el,
              tl: /* [] */0
            }
          }
        });
    return mkexp_cons({
                loc_start: loc_loc_start,
                loc_end: loc_loc_end,
                loc_ghost: true
              }, arg, loc);
  }
  const loc_loc_start$1 = nilloc.loc_start;
  const loc_loc_end$1 = nilloc.loc_end;
  const loc$1 = {
    loc_start: loc_loc_start$1,
    loc_end: loc_loc_end$1,
    loc_ghost: true
  };
  const nil_txt = {
    TAG: /* Lident */0,
    _0: "[]"
  };
  const nil = {
    txt: nil_txt,
    loc: loc$1
  };
  return Curry._3(Ast_helper_Exp.mk, loc$1, undefined, {
              TAG: /* Pexp_construct */9,
              _0: nil,
              _1: undefined
            });
}

function mktailpat(nilloc, param) {
  if (param) {
    const p1 = param.hd;
    const pat_pl = mktailpat(nilloc, param.tl);
    const loc_loc_start = p1.ppat_loc.loc_start;
    const loc_loc_end = pat_pl.ppat_loc.loc_end;
    const loc = {
      loc_start: loc_loc_start,
      loc_end: loc_loc_end,
      loc_ghost: true
    };
    const arg = mk$1(loc, undefined, {
          TAG: /* Ppat_tuple */4,
          _0: {
            hd: p1,
            tl: {
              hd: pat_pl,
              tl: /* [] */0
            }
          }
        });
    return mkpat_cons({
                loc_start: loc_loc_start,
                loc_end: loc_loc_end,
                loc_ghost: true
              }, arg, loc);
  }
  const loc_loc_start$1 = nilloc.loc_start;
  const loc_loc_end$1 = nilloc.loc_end;
  const loc$1 = {
    loc_start: loc_loc_start$1,
    loc_end: loc_loc_end$1,
    loc_ghost: true
  };
  const nil_txt = {
    TAG: /* Lident */0,
    _0: "[]"
  };
  const nil = {
    txt: nil_txt,
    loc: loc$1
  };
  return mk$1(loc$1, undefined, {
              TAG: /* Ppat_construct */5,
              _0: nil,
              _1: undefined
            });
}

function mkstrexp(e, attrs) {
  return {
          pstr_desc: {
            TAG: /* Pstr_eval */0,
            _0: e,
            _1: attrs
          },
          pstr_loc: e.pexp_loc
        };
}

function mkexp_constraint(e, param) {
  const t2 = param[1];
  const t1 = param[0];
  if (t1 !== undefined) {
    if (t2 !== undefined) {
      return ghexp({
                  TAG: /* Pexp_coerce */20,
                  _0: e,
                  _1: t1,
                  _2: t2
                });
    } else {
      return ghexp({
                  TAG: /* Pexp_constraint */19,
                  _0: e,
                  _1: t1
                });
    }
  }
  if (t2 !== undefined) {
    return ghexp({
                TAG: /* Pexp_coerce */20,
                _0: e,
                _1: t1,
                _2: t2
              });
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              12327,
              18
            ]
          });
}

function array_function(str, name) {
  return {
          txt: {
            TAG: /* Ldot */1,
            _0: {
              TAG: /* Lident */0,
              _0: str
            },
            _1: fast.contents ? "unsafe_" + name : name
          },
          loc: symbol_gloc(undefined)
        };
}

function unclosed(opening_name, opening_num, closing_name, closing_num) {
  throw new Caml_js_exceptions.MelangeError($$Error$3, {
            MEL_EXN_ID: $$Error$3,
            _1: {
              TAG: /* Unclosed */0,
              _0: rhs_loc(opening_num),
              _1: opening_name,
              _2: rhs_loc(closing_num),
              _3: closing_name
            }
          });
}

function expecting(pos, nonterm) {
  throw new Caml_js_exceptions.MelangeError($$Error$3, {
            MEL_EXN_ID: $$Error$3,
            _1: {
              TAG: /* Expecting */1,
              _0: rhs_loc(pos),
              _1: nonterm
            }
          });
}

function not_expecting(pos, nonterm) {
  throw new Caml_js_exceptions.MelangeError($$Error$3, {
            MEL_EXN_ID: $$Error$3,
            _1: {
              TAG: /* Not_expecting */2,
              _0: rhs_loc(pos),
              _1: nonterm
            }
          });
}

function bigarray_function(str, name) {
  return {
          txt: {
            TAG: /* Ldot */1,
            _0: {
              TAG: /* Ldot */1,
              _0: {
                TAG: /* Lident */0,
                _0: "Bigarray"
              },
              _1: str
            },
            _1: name
          },
          loc: symbol_gloc(undefined)
        };
}

function bigarray_untuplify(exp) {
  const explist = exp.pexp_desc;
  if (explist.TAG === /* Pexp_tuple */8) {
    return explist._0;
  } else {
    return {
            hd: exp,
            tl: /* [] */0
          };
  }
}

function exp_of_label(lbl, pos) {
  const rhs = {
    TAG: /* Lident */0,
    _0: last$1(lbl)
  };
  return mkexp({
              TAG: /* Pexp_ident */0,
              _0: {
                txt: rhs,
                loc: rhs_loc(pos)
              }
            });
}

function pat_of_label(lbl, pos) {
  const rhs = last$1(lbl);
  return mkpat({
              TAG: /* Ppat_var */0,
              _0: {
                txt: rhs,
                loc: rhs_loc(pos)
              }
            });
}

function check_variable(vl, loc, v) {
  if (!Stdlib__List.mem(v, vl)) {
    return ;
  }
  throw new Caml_js_exceptions.MelangeError($$Error$3, {
            MEL_EXN_ID: $$Error$3,
            _1: {
              TAG: /* Variable_in_scope */4,
              _0: loc,
              _1: v
            }
          });
}

function varify_constructors(var_names, t) {
  const loop = function (t) {
    const x = t.ptyp_desc;
    let desc;
    if (typeof x === "number") {
      desc = /* Ptyp_any */0;
    } else {
      switch (x.TAG | 0) {
        case /* Ptyp_var */0 :
            const x$1 = x._0;
            check_variable(var_names, t.ptyp_loc, x$1);
            desc = {
              TAG: /* Ptyp_var */0,
              _0: x$1
            };
            break;
        case /* Ptyp_arrow */1 :
            desc = {
              TAG: /* Ptyp_arrow */1,
              _0: x._0,
              _1: loop(x._1),
              _2: loop(x._2)
            };
            break;
        case /* Ptyp_tuple */2 :
            desc = {
              TAG: /* Ptyp_tuple */2,
              _0: Stdlib__List.map(loop, x._0)
            };
            break;
        case /* Ptyp_constr */3 :
            const longident = x._0;
            let exit = 0;
            const s = longident.txt;
            switch (s.TAG | 0) {
              case /* Lident */0 :
                  if (x._1) {
                    exit = 1;
                  } else {
                    const s$1 = s._0;
                    if (Stdlib__List.mem(s$1, var_names)) {
                      desc = {
                        TAG: /* Ptyp_var */0,
                        _0: s$1
                      };
                    } else {
                      exit = 1;
                    }
                  }
                  break;
              case /* Ldot */1 :
              case /* Lapply */2 :
                  exit = 1;
                  break;
              
            }
            if (exit === 1) {
              desc = {
                TAG: /* Ptyp_constr */3,
                _0: longident,
                _1: Stdlib__List.map(loop, x._1)
              };
            }
            break;
        case /* Ptyp_object */4 :
            desc = {
              TAG: /* Ptyp_object */4,
              _0: Stdlib__List.map((function (param) {
                      return [
                              param[0],
                              param[1],
                              loop(param[2])
                            ];
                    }), x._0),
              _1: x._1
            };
            break;
        case /* Ptyp_class */5 :
            desc = {
              TAG: /* Ptyp_class */5,
              _0: x._0,
              _1: Stdlib__List.map(loop, x._1)
            };
            break;
        case /* Ptyp_alias */6 :
            const string = x._1;
            check_variable(var_names, t.ptyp_loc, string);
            desc = {
              TAG: /* Ptyp_alias */6,
              _0: loop(x._0),
              _1: string
            };
            break;
        case /* Ptyp_variant */7 :
            desc = {
              TAG: /* Ptyp_variant */7,
              _0: Stdlib__List.map(loop_row_field, x._0),
              _1: x._1,
              _2: x._2
            };
            break;
        case /* Ptyp_poly */8 :
            const string_lst = x._0;
            const partial_arg = t.ptyp_loc;
            Stdlib__List.iter((function (param) {
                    return check_variable(var_names, partial_arg, param);
                  }), string_lst);
            desc = {
              TAG: /* Ptyp_poly */8,
              _0: string_lst,
              _1: loop(x._1)
            };
            break;
        case /* Ptyp_package */9 :
            const match = x._0;
            desc = {
              TAG: /* Ptyp_package */9,
              _0: [
                match[0],
                Stdlib__List.map((function (param) {
                        return [
                                param[0],
                                loop(param[1])
                              ];
                      }), match[1])
              ]
            };
            break;
        case /* Ptyp_extension */10 :
            const match$1 = x._0;
            desc = {
              TAG: /* Ptyp_extension */10,
              _0: [
                match$1[0],
                match$1[1]
              ]
            };
            break;
        
      }
    }
    return {
            ptyp_desc: desc,
            ptyp_loc: t.ptyp_loc,
            ptyp_attributes: t.ptyp_attributes
          };
  };
  const loop_row_field = function (t) {
    if (t.TAG === /* Rtag */0) {
      return {
              TAG: /* Rtag */0,
              _0: t._0,
              _1: t._1,
              _2: t._2,
              _3: Stdlib__List.map(loop, t._3)
            };
    } else {
      return {
              TAG: /* Rinherit */1,
              _0: loop(t._0)
            };
    }
  };
  return loop(t);
}

function wrap_type_annotation(newtypes, core_type, body) {
  const exp = mkexp({
        TAG: /* Pexp_constraint */19,
        _0: body,
        _1: core_type
      });
  const exp$1 = Stdlib__List.fold_right((function (newtype, exp) {
          return mkexp({
                      TAG: /* Pexp_newtype */30,
                      _0: newtype,
                      _1: exp
                    });
        }), newtypes, exp);
  return [
          exp$1,
          ghtyp({
                TAG: /* Ptyp_poly */8,
                _0: newtypes,
                _1: varify_constructors(newtypes, core_type)
              })
        ];
}

function wrap_exp_attrs(body, param) {
  const ext = param[0];
  const body_pexp_desc = body.pexp_desc;
  const body_pexp_loc = body.pexp_loc;
  const body_pexp_attributes = Stdlib.$at(param[1], body.pexp_attributes);
  const body$1 = {
    pexp_desc: body_pexp_desc,
    pexp_loc: body_pexp_loc,
    pexp_attributes: body_pexp_attributes
  };
  if (ext !== undefined) {
    return ghexp({
                TAG: /* Pexp_extension */33,
                _0: [
                  ext,
                  {
                    TAG: /* PStr */0,
                    _0: {
                      hd: mkstrexp(body$1, /* [] */0),
                      tl: /* [] */0
                    }
                  }
                ]
              });
  } else {
    return body$1;
  }
}

function text_def(pos) {
  return {
          hd: {
            TAG: /* Ptop_def */0,
            _0: text$1(get_text(Stdlib__Parsing.rhs_start_pos(pos)))
          },
          tl: /* [] */0
        };
}

function extra_text(text, pos, items) {
  const pre_extras = get_pre_extra_text(Stdlib__Parsing.rhs_start_pos(pos));
  const post_extras = get_post_extra_text(Stdlib__Parsing.rhs_end_pos(pos));
  return Stdlib.$at(Curry._1(text, pre_extras), Stdlib.$at(items, Curry._1(text, post_extras)));
}

function extra_cstr(pos, items) {
  return extra_text(Ast_helper_Cf.text, pos, items);
}

function extra_csig(pos, items) {
  return extra_text(Ast_helper_Ctf.text, pos, items);
}

function add_nonrec(rf, attrs, pos) {
  if (rf) {
    return attrs;
  }
  const name_loc = rhs_loc(pos);
  const name = {
    txt: "nonrec",
    loc: name_loc
  };
  return {
          hd: [
            name,
            {
              TAG: /* PStr */0,
              _0: /* [] */0
            }
          ],
          tl: attrs
        };
}

function mklb(param, attrs) {
  return {
          lb_pattern: param[0],
          lb_expression: param[1],
          lb_attributes: attrs,
          lb_docs: symbol_docs_lazy(undefined),
          lb_text: symbol_text_lazy(undefined),
          lb_loc: symbol_rloc(undefined)
        };
}

const yytransl_const = [
  257,
  258,
  259,
  260,
  261,
  262,
  263,
  264,
  265,
  266,
  267,
  269,
  270,
  271,
  272,
  273,
  274,
  275,
  276,
  277,
  278,
  279,
  280,
  281,
  282,
  0,
  283,
  284,
  285,
  286,
  288,
  289,
  290,
  291,
  292,
  293,
  294,
  295,
  296,
  297,
  303,
  304,
  309,
  310,
  311,
  312,
  313,
  314,
  315,
  316,
  317,
  318,
  319,
  320,
  322,
  323,
  324,
  325,
  326,
  327,
  328,
  329,
  330,
  331,
  332,
  334,
  335,
  336,
  337,
  338,
  340,
  341,
  342,
  343,
  344,
  346,
  347,
  348,
  349,
  350,
  351,
  352,
  353,
  354,
  355,
  357,
  358,
  360,
  361,
  362,
  363,
  364,
  365,
  366,
  368,
  369,
  370,
  371,
  372,
  373,
  376,
  0
];

const yytransl_block = [
  268,
  287,
  298,
  299,
  300,
  301,
  302,
  305,
  306,
  307,
  308,
  321,
  333,
  339,
  345,
  356,
  359,
  367,
  374,
  375,
  0
];

const yyact = [
  (function (param) {
      throw new Caml_js_exceptions.MelangeError("Failure", {
                MEL_EXN_ID: "Failure",
                _1: "parser"
              });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return extra_text(text$1, 1, _1);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return extra_text(text, 1, _1);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return {
              TAG: /* Ptop_def */0,
              _0: extra_text(text$1, 1, _1)
            };
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 1);
    }),
  (function (__caml_parser_env) {
      throw new Caml_js_exceptions.MelangeError(Stdlib.End_of_file, {
                MEL_EXN_ID: Stdlib.End_of_file
              });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return Stdlib.$at(text$1(get_text(Stdlib__Parsing.rhs_start_pos(1))), {
                  hd: mkstrexp(_1, _2),
                  tl: /* [] */0
                });
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return /* [] */0;
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return Stdlib.$at(text$1(get_text(Stdlib__Parsing.rhs_start_pos(1))), {
                  hd: _1,
                  tl: _2
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      let pos = 1;
      return extra_text((function (txt) {
                    return {
                            hd: {
                              TAG: /* Ptop_def */0,
                              _0: text$1(txt)
                            },
                            tl: /* [] */0
                          };
                  }), pos, _1);
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return Stdlib.$at(text_def(1), {
                  hd: {
                    TAG: /* Ptop_def */0,
                    _0: {
                      hd: mkstrexp(_1, _2),
                      tl: /* [] */0
                    }
                  },
                  tl: _3
                });
    }),
  (function (__caml_parser_env) {
      return /* [] */0;
    }),
  (function (__caml_parser_env) {
      return text_def(1);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      mark_rhs_docs(2, 3);
      return Stdlib.$at(text_def(1), Stdlib.$at(text_def(2), {
                      hd: {
                        TAG: /* Ptop_def */0,
                        _0: {
                          hd: mkstrexp(_2, _3),
                          tl: /* [] */0
                        }
                      },
                      tl: _4
                    }));
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return Stdlib.$at(text_def(1), Stdlib.$at(text_def(2), {
                      hd: {
                        TAG: /* Ptop_def */0,
                        _0: {
                          hd: _2,
                          tl: /* [] */0
                        }
                      },
                      tl: _3
                    }));
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      mark_rhs_docs(2, 3);
      return Stdlib.$at(text_def(1), Stdlib.$at(text_def(2), {
                      hd: _2,
                      tl: _3
                    }));
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return Stdlib.$at(text_def(1), {
                  hd: {
                    TAG: /* Ptop_def */0,
                    _0: {
                      hd: _1,
                      tl: /* [] */0
                    }
                  },
                  tl: _2
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      mark_rhs_docs(1, 1);
      return Stdlib.$at(text_def(1), {
                  hd: _1,
                  tl: _2
                });
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 1);
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 1);
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 1);
    }),
  (function (__caml_parser_env) {
      return [
              {
                txt: "*",
                loc: rhs_loc(2)
              },
              undefined
            ];
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return [
              {
                txt: _2,
                loc: rhs_loc(2)
              },
              _4
            ];
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return "_";
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _2,
              tl: _1
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkmod({
                  TAG: /* Pmod_ident */0,
                  _0: {
                    txt: _1,
                    loc: rhs_loc(1)
                  }
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mkmod({
                  TAG: /* Pmod_structure */1,
                  _0: extra_text(text$1, 2, _2)
                });
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("struct", 1, "end", 3);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return Stdlib__List.fold_left((function (acc, param) {
                    return mkmod({
                                TAG: /* Pmod_functor */2,
                                _0: param[0],
                                _1: param[1],
                                _2: acc
                              });
                  }), _4, _2);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mkmod({
                  TAG: /* Pmod_apply */3,
                  _0: _1,
                  _1: _3
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      return mkmod({
                  TAG: /* Pmod_apply */3,
                  _0: _1,
                  _1: mkmod({
                        TAG: /* Pmod_structure */1,
                        _0: /* [] */0
                      })
                });
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 2, ")", 4);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mkmod({
                  TAG: /* Pmod_constraint */4,
                  _0: _2,
                  _1: _4
                });
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 5);
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 1);
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 3);
    }),
  (function (__caml_parser_env) {
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mkmod({
                  TAG: /* Pmod_unpack */5,
                  _0: _3
                });
    }),
  (function (__caml_parser_env) {
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mkmod({
                  TAG: /* Pmod_unpack */5,
                  _0: ghexp({
                        TAG: /* Pexp_constraint */19,
                        _0: _3,
                        _1: ghtyp({
                              TAG: /* Ptyp_package */9,
                              _0: _5
                            })
                      })
                });
    }),
  (function (__caml_parser_env) {
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 5);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _7 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mkmod({
                  TAG: /* Pmod_unpack */5,
                  _0: ghexp({
                        TAG: /* Pexp_coerce */20,
                        _0: _3,
                        _1: ghtyp({
                              TAG: /* Ptyp_package */9,
                              _0: _5
                            }),
                        _2: ghtyp({
                              TAG: /* Ptyp_package */9,
                              _0: _7
                            })
                      })
                });
    }),
  (function (__caml_parser_env) {
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mkmod({
                  TAG: /* Pmod_unpack */5,
                  _0: ghexp({
                        TAG: /* Pexp_coerce */20,
                        _0: _3,
                        _1: undefined,
                        _2: ghtyp({
                              TAG: /* Ptyp_package */9,
                              _0: _5
                            })
                      })
                });
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      return unclosed("(", 1, ")", 5);
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      return unclosed("(", 1, ")", 5);
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 4);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return attr$4(_1, _2);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkmod({
                  TAG: /* Pmod_extension */6,
                  _0: _1
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      mark_rhs_docs(1, 2);
      return Stdlib.$at(text$1(get_text(Stdlib__Parsing.rhs_start_pos(1))), {
                  hd: mkstrexp(_1, _2),
                  tl: _3
                });
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return /* [] */0;
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return Stdlib.$at(text$1(get_text(Stdlib__Parsing.rhs_start_pos(1))), _2);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return Stdlib.$at(text$1(get_text(Stdlib__Parsing.rhs_start_pos(1))), {
                  hd: _1,
                  tl: _2
                });
    }),
  (function (__caml_parser_env) {
      let lbs = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      const bindings = lbs.lbs_bindings;
      let str;
      let exit = 0;
      if (bindings) {
        const lb = bindings.hd;
        if (typeof lb.lb_pattern.ppat_desc === "number" && !bindings.tl) {
          const exp = wrap_exp_attrs(lb.lb_expression, [
                undefined,
                lbs.lbs_attributes
              ]);
          str = mkstr({
                TAG: /* Pstr_eval */0,
                _0: exp,
                _1: lb.lb_attributes
              });
        } else {
          exit = 1;
        }
      } else {
        exit = 1;
      }
      if (exit === 1) {
        if (Caml_obj.caml_notequal(lbs.lbs_attributes, /* [] */0)) {
          throw new Caml_js_exceptions.MelangeError($$Error$3, {
                    MEL_EXN_ID: $$Error$3,
                    _1: {
                      TAG: /* Not_expecting */2,
                      _0: lbs.lbs_loc,
                      _1: "attributes"
                    }
                  });
        }
        const bindings$1 = Stdlib__List.map((function (lb) {
                return mk$17(lb.lb_loc, lb.lb_attributes, CamlinternalLazy.force(lb.lb_docs), CamlinternalLazy.force(lb.lb_text), lb.lb_pattern, lb.lb_expression);
              }), bindings);
        str = mkstr({
              TAG: /* Pstr_value */1,
              _0: lbs.lbs_rec,
              _1: Stdlib__List.rev(bindings$1)
            });
      }
      const id = lbs.lbs_extension;
      if (id !== undefined) {
        let d = {
          TAG: /* Pstr_extension */14,
          _0: [
            id,
            {
              TAG: /* PStr */0,
              _0: {
                hd: str,
                tl: /* [] */0
              }
            }
          ],
          _1: /* [] */0
        };
        return mk$6(symbol_gloc(undefined), d);
      } else {
        return str;
      }
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkstr({
                  TAG: /* Pstr_primitive */2,
                  _0: _1
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkstr({
                  TAG: /* Pstr_type */3,
                  _0: Stdlib__List.rev(_1)
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkstr({
                  TAG: /* Pstr_typext */4,
                  _0: _1
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkstr({
                  TAG: /* Pstr_exception */5,
                  _0: _1
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkstr({
                  TAG: /* Pstr_module */6,
                  _0: _1
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkstr({
                  TAG: /* Pstr_recmodule */7,
                  _0: Stdlib__List.rev(_1)
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkstr({
                  TAG: /* Pstr_modtype */8,
                  _0: _1
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkstr({
                  TAG: /* Pstr_open */9,
                  _0: _1
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkstr({
                  TAG: /* Pstr_class */10,
                  _0: Stdlib__List.rev(_1)
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkstr({
                  TAG: /* Pstr_class_type */11,
                  _0: Stdlib__List.rev(_1)
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkstr({
                  TAG: /* Pstr_include */12,
                  _0: _1
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkstr({
                  TAG: /* Pstr_extension */14,
                  _0: _1,
                  _1: add_docs_attrs(symbol_docs(undefined), _2)
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      mark_symbol_docs(undefined);
      return mkstr({
                  TAG: /* Pstr_attribute */13,
                  _0: _1
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mk$16(symbol_rloc(undefined), _3, symbol_docs(undefined), _2);
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkmod({
                  TAG: /* Pmod_constraint */4,
                  _0: _4,
                  _1: _2
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkmod({
                  TAG: /* Pmod_functor */2,
                  _0: _1[0],
                  _1: _1[1],
                  _2: _2
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mk$14(symbol_rloc(undefined), _4, symbol_docs(undefined), undefined, {
                  txt: _2,
                  loc: rhs_loc(2)
                }, _3);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _2,
              tl: _1
            };
    }),
  (function (__caml_parser_env) {
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mk$14(symbol_rloc(undefined), _5, symbol_docs(undefined), undefined, {
                  txt: _3,
                  loc: rhs_loc(3)
                }, _4);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mk$14(symbol_rloc(undefined), _4, symbol_docs(undefined), get_text(Stdlib__Parsing.symbol_start_pos(undefined)), {
                  txt: _2,
                  loc: rhs_loc(2)
                }, _3);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkmty({
                  TAG: /* Pmty_ident */0,
                  _0: {
                    txt: _1,
                    loc: rhs_loc(1)
                  }
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mkmty({
                  TAG: /* Pmty_signature */1,
                  _0: extra_text(text, 2, _2)
                });
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("sig", 1, "end", 3);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return Stdlib__List.fold_left((function (acc, param) {
                    return mkmty({
                                TAG: /* Pmty_functor */2,
                                _0: param[0],
                                _1: param[1],
                                _2: acc
                              });
                  }), _4, _2);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkmty({
                  TAG: /* Pmty_with */3,
                  _0: _1,
                  _1: Stdlib__List.rev(_3)
                });
    }),
  (function (__caml_parser_env) {
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkmty({
                  TAG: /* Pmty_typeof */4,
                  _0: _4
                });
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 1);
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 3);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkmty({
                  TAG: /* Pmty_extension */5,
                  _0: _1
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return attr$3(_1, _2);
    }),
  (function (__caml_parser_env) {
      return /* [] */0;
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return Stdlib.$at(text(get_text(Stdlib__Parsing.rhs_start_pos(1))), _2);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return Stdlib.$at(text(get_text(Stdlib__Parsing.rhs_start_pos(1))), {
                  hd: _1,
                  tl: _2
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mksig({
                  TAG: /* Psig_value */0,
                  _0: _1
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mksig({
                  TAG: /* Psig_value */0,
                  _0: _1
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mksig({
                  TAG: /* Psig_type */1,
                  _0: Stdlib__List.rev(_1)
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mksig({
                  TAG: /* Psig_typext */2,
                  _0: _1
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mksig({
                  TAG: /* Psig_exception */3,
                  _0: _1
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mksig({
                  TAG: /* Psig_module */4,
                  _0: _1
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mksig({
                  TAG: /* Psig_module */4,
                  _0: _1
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mksig({
                  TAG: /* Psig_recmodule */5,
                  _0: Stdlib__List.rev(_1)
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mksig({
                  TAG: /* Psig_modtype */6,
                  _0: _1
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mksig({
                  TAG: /* Psig_open */7,
                  _0: _1
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mksig({
                  TAG: /* Psig_include */8,
                  _0: _1
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mksig({
                  TAG: /* Psig_class */9,
                  _0: Stdlib__List.rev(_1)
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mksig({
                  TAG: /* Psig_class_type */10,
                  _0: Stdlib__List.rev(_1)
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mksig({
                  TAG: /* Psig_extension */12,
                  _0: _1,
                  _1: add_docs_attrs(symbol_docs(undefined), _2)
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      mark_symbol_docs(undefined);
      return mksig({
                  TAG: /* Psig_attribute */11,
                  _0: _1
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mk$15(symbol_rloc(undefined), _4, symbol_docs(undefined), _2, {
                  txt: _3,
                  loc: rhs_loc(3)
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mk$16(symbol_rloc(undefined), _3, symbol_docs(undefined), _2);
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _6 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkmty({
                  TAG: /* Pmty_functor */2,
                  _0: {
                    txt: _2,
                    loc: rhs_loc(2)
                  },
                  _1: _4,
                  _2: _6
                });
    }),
  (function (__caml_parser_env) {
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkmty({
                  TAG: /* Pmty_functor */2,
                  _0: {
                    txt: "*",
                    loc: rhs_loc(1)
                  },
                  _1: undefined,
                  _2: _3
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mk$12(symbol_rloc(undefined), _4, symbol_docs(undefined), undefined, {
                  txt: _2,
                  loc: rhs_loc(2)
                }, _3);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mk$12(symbol_rloc(undefined), _5, symbol_docs(undefined), undefined, {
                  txt: _2,
                  loc: rhs_loc(2)
                }, alias$2(rhs_loc(4), undefined, {
                      txt: _4,
                      loc: rhs_loc(4)
                    }));
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _2,
              tl: _1
            };
    }),
  (function (__caml_parser_env) {
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _6 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mk$12(symbol_rloc(undefined), _6, symbol_docs(undefined), undefined, {
                  txt: _3,
                  loc: rhs_loc(3)
                }, _5);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mk$12(symbol_rloc(undefined), _5, symbol_docs(undefined), get_text(Stdlib__Parsing.symbol_start_pos(undefined)), {
                  txt: _2,
                  loc: rhs_loc(2)
                }, _4);
    }),
  (function (__caml_parser_env) {
      
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mk$13(symbol_rloc(undefined), _5, symbol_docs(undefined), undefined, _4, {
                  txt: _3,
                  loc: rhs_loc(3)
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _2,
              tl: _1
            };
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _6 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mk$18(symbol_rloc(undefined), _6, symbol_docs(undefined), undefined, _2, _3, {
                  txt: _4,
                  loc: rhs_loc(4)
                }, _5);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _6 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mk$18(symbol_rloc(undefined), _6, symbol_docs(undefined), get_text(Stdlib__Parsing.symbol_start_pos(undefined)), _2, _3, {
                  txt: _4,
                  loc: rhs_loc(4)
                }, _5);
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkclass({
                  TAG: /* Pcl_constraint */5,
                  _0: _4,
                  _1: _2
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkclass({
                  TAG: /* Pcl_fun */2,
                  _0: _1[0],
                  _1: _1[1],
                  _2: _1[2],
                  _3: _2
                });
    }),
  (function (__caml_parser_env) {
      return /* [] */0;
    }),
  (function (__caml_parser_env) {
      return Stdlib__List.rev(Stdlib__Parsing.peek_val(__caml_parser_env, 1));
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkclass({
                  TAG: /* Pcl_fun */2,
                  _0: _1[0],
                  _1: _1[1],
                  _2: _1[2],
                  _3: _3
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkclass({
                  TAG: /* Pcl_fun */2,
                  _0: _1[0],
                  _1: _1[1],
                  _2: _1[2],
                  _3: _2
                });
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkclass({
                  TAG: /* Pcl_apply */3,
                  _0: _1,
                  _1: Stdlib__List.rev(_2)
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      const bindings = Stdlib__List.map((function (lb) {
              if (Caml_obj.caml_notequal(lb.lb_attributes, /* [] */0)) {
                throw new Caml_js_exceptions.MelangeError($$Error$3, {
                          MEL_EXN_ID: $$Error$3,
                          _1: {
                            TAG: /* Not_expecting */2,
                            _0: lb.lb_loc,
                            _1: "item attribute"
                          }
                        });
              }
              return mk$17(lb.lb_loc, undefined, undefined, undefined, lb.lb_pattern, lb.lb_expression);
            }), _1.lbs_bindings);
      if (_1.lbs_extension !== undefined) {
        throw new Caml_js_exceptions.MelangeError($$Error$3, {
                  MEL_EXN_ID: $$Error$3,
                  _1: {
                    TAG: /* Not_expecting */2,
                    _0: _1.lbs_loc,
                    _1: "extension"
                  }
                });
      }
      if (Caml_obj.caml_notequal(_1.lbs_attributes, /* [] */0)) {
        throw new Caml_js_exceptions.MelangeError($$Error$3, {
                  MEL_EXN_ID: $$Error$3,
                  _1: {
                    TAG: /* Not_expecting */2,
                    _0: _1.lbs_loc,
                    _1: "attributes"
                  }
                });
      }
      return mkclass({
                  TAG: /* Pcl_let */4,
                  _0: _1.lbs_rec,
                  _1: Stdlib__List.rev(bindings),
                  _2: _3
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return attr$5(_1, _2);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkclass({
                  TAG: /* Pcl_extension */6,
                  _0: _1
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkclass({
                  TAG: /* Pcl_constr */0,
                  _0: {
                    txt: _4,
                    loc: rhs_loc(4)
                  },
                  _1: Stdlib__List.rev(_2)
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkclass({
                  TAG: /* Pcl_constr */0,
                  _0: {
                    txt: _1,
                    loc: rhs_loc(1)
                  },
                  _1: /* [] */0
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mkclass({
                  TAG: /* Pcl_structure */1,
                  _0: _2
                });
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("object", 1, "end", 3);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mkclass({
                  TAG: /* Pcl_constraint */5,
                  _0: _2,
                  _1: _4
                });
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 5);
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 1);
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 3);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              pcstr_self: _1,
              pcstr_fields: extra_cstr(2, Stdlib__List.rev(_2))
            };
    }),
  (function (__caml_parser_env) {
      return reloc_pat(Stdlib__Parsing.peek_val(__caml_parser_env, 1));
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mkpat({
                  TAG: /* Ppat_constraint */10,
                  _0: _2,
                  _1: _4
                });
    }),
  (function (__caml_parser_env) {
      return ghpat(/* Ppat_any */0);
    }),
  (function (__caml_parser_env) {
      return /* [] */0;
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return Stdlib.$at({
                  hd: _2,
                  tl: Curry._1(Ast_helper_Cf.text, get_text(Stdlib__Parsing.rhs_start_pos(2)))
                }, _1);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkcf(_5, symbol_docs(undefined), {
                  TAG: /* Pcf_inherit */0,
                  _0: _2,
                  _1: _3,
                  _2: _4
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkcf(_3, symbol_docs(undefined), {
                  TAG: /* Pcf_val */1,
                  _0: _2
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkcf(_3, symbol_docs(undefined), {
                  TAG: /* Pcf_method */2,
                  _0: _2
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkcf(_3, symbol_docs(undefined), {
                  TAG: /* Pcf_constraint */3,
                  _0: _2
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkcf(_3, symbol_docs(undefined), {
                  TAG: /* Pcf_initializer */4,
                  _0: _2
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkcf(_2, symbol_docs(undefined), {
                  TAG: /* Pcf_extension */6,
                  _0: _1
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      mark_symbol_docs(undefined);
      return mkcf(undefined, undefined, {
                  TAG: /* Pcf_attribute */5,
                  _0: _1
                });
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 5);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _6 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      if (_1 === /* Override */0) {
        throw new Caml_js_exceptions.MelangeError(Escape_error, {
                  MEL_EXN_ID: Escape_error
                });
      }
      return [
              {
                txt: _4,
                loc: rhs_loc(4)
              },
              /* Mutable */1,
              {
                TAG: /* Cfk_virtual */0,
                _0: _6
              }
            ];
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              {
                txt: _3,
                loc: rhs_loc(3)
              },
              _2,
              {
                TAG: /* Cfk_virtual */0,
                _0: _5
              }
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              {
                txt: _3,
                loc: rhs_loc(3)
              },
              _2,
              {
                TAG: /* Cfk_concrete */1,
                _0: _1,
                _1: _5
              }
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 5);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _6 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      const e = mkexp_constraint(_6, _4);
      return [
              {
                txt: _3,
                loc: rhs_loc(3)
              },
              _2,
              {
                TAG: /* Cfk_concrete */1,
                _0: _1,
                _1: e
              }
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 5);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _6 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      if (_1 === /* Override */0) {
        throw new Caml_js_exceptions.MelangeError(Escape_error, {
                  MEL_EXN_ID: Escape_error
                });
      }
      return [
              {
                txt: _4,
                loc: rhs_loc(4)
              },
              /* Private */0,
              {
                TAG: /* Cfk_virtual */0,
                _0: _6
              }
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 5);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _6 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      if (_1 === /* Override */0) {
        throw new Caml_js_exceptions.MelangeError(Escape_error, {
                  MEL_EXN_ID: Escape_error
                });
      }
      return [
              {
                txt: _4,
                loc: rhs_loc(4)
              },
              _3,
              {
                TAG: /* Cfk_virtual */0,
                _0: _6
              }
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              {
                txt: _3,
                loc: rhs_loc(3)
              },
              _2,
              {
                TAG: /* Cfk_concrete */1,
                _0: _1,
                _1: ghexp({
                      TAG: /* Pexp_poly */28,
                      _0: _4,
                      _1: undefined
                    })
              }
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 6);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 5);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _7 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              {
                txt: _3,
                loc: rhs_loc(3)
              },
              _2,
              {
                TAG: /* Cfk_concrete */1,
                _0: _1,
                _1: ghexp({
                      TAG: /* Pexp_poly */28,
                      _0: _7,
                      _1: _5
                    })
              }
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 9);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 8);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 7);
      const _6 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _8 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _10 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      const match = wrap_type_annotation(_6, _8, _10);
      return [
              {
                txt: _3,
                loc: rhs_loc(3)
              },
              _2,
              {
                TAG: /* Cfk_concrete */1,
                _0: _1,
                _1: ghexp({
                      TAG: /* Pexp_poly */28,
                      _0: match[0],
                      _1: match[1]
                    })
              }
            ];
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _6 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkcty({
                  TAG: /* Pcty_arrow */2,
                  _0: "?" + _2,
                  _1: mkoption(_4),
                  _2: _6
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkcty({
                  TAG: /* Pcty_arrow */2,
                  _0: "?" + _1,
                  _1: mkoption(_2),
                  _2: _4
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkcty({
                  TAG: /* Pcty_arrow */2,
                  _0: _1,
                  _1: _3,
                  _2: _5
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkcty({
                  TAG: /* Pcty_arrow */2,
                  _0: "",
                  _1: _1,
                  _2: _3
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkcty({
                  TAG: /* Pcty_constr */0,
                  _0: {
                    txt: _4,
                    loc: rhs_loc(4)
                  },
                  _1: Stdlib__List.rev(_2)
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkcty({
                  TAG: /* Pcty_constr */0,
                  _0: {
                    txt: _1,
                    loc: rhs_loc(1)
                  },
                  _1: /* [] */0
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mkcty({
                  TAG: /* Pcty_signature */1,
                  _0: _2
                });
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("object", 1, "end", 3);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return attr$6(_1, _2);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkcty({
                  TAG: /* Pcty_extension */3,
                  _0: _1
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              pcsig_self: _1,
              pcsig_fields: extra_csig(2, Stdlib__List.rev(_2))
            };
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 1);
    }),
  (function (__caml_parser_env) {
      return mktyp(/* Ptyp_any */0);
    }),
  (function (__caml_parser_env) {
      return /* [] */0;
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return Stdlib.$at({
                  hd: _2,
                  tl: Curry._1(Ast_helper_Ctf.text, get_text(Stdlib__Parsing.rhs_start_pos(2)))
                }, _1);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkctf(_3, symbol_docs(undefined), {
                  TAG: /* Pctf_inherit */0,
                  _0: _2
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkctf(_3, symbol_docs(undefined), {
                  TAG: /* Pctf_val */1,
                  _0: _2
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _6 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkctf(_6, symbol_docs(undefined), {
                  TAG: /* Pctf_method */2,
                  _0: [
                    _3,
                    _2[0],
                    _2[1],
                    _5
                  ]
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkctf(_3, symbol_docs(undefined), {
                  TAG: /* Pctf_constraint */3,
                  _0: _2
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkctf(_2, symbol_docs(undefined), {
                  TAG: /* Pctf_extension */5,
                  _0: _1
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      mark_symbol_docs(undefined);
      return mkctf(undefined, undefined, {
                  TAG: /* Pctf_attribute */4,
                  _0: _1
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              _3,
              _2,
              /* Virtual */0,
              _5
            ];
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              _3,
              /* Mutable */1,
              _2,
              _5
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              _1,
              /* Immutable */0,
              /* Concrete */1,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              _1,
              _3,
              symbol_rloc(undefined)
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              _1,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _2,
              tl: _1
            };
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 5);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _6 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _7 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mk$18(symbol_rloc(undefined), _7, symbol_docs(undefined), undefined, _2, _3, {
                  txt: _4,
                  loc: rhs_loc(4)
                }, _6);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 5);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _6 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _7 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mk$18(symbol_rloc(undefined), _7, symbol_docs(undefined), get_text(Stdlib__Parsing.symbol_start_pos(undefined)), _2, _3, {
                  txt: _4,
                  loc: rhs_loc(4)
                }, _6);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _2,
              tl: _1
            };
    }),
  (function (__caml_parser_env) {
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 5);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _7 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _8 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mk$18(symbol_rloc(undefined), _8, symbol_docs(undefined), undefined, _3, _4, {
                  txt: _5,
                  loc: rhs_loc(5)
                }, _7);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 5);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _6 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _7 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mk$18(symbol_rloc(undefined), _7, symbol_docs(undefined), get_text(Stdlib__Parsing.symbol_start_pos(undefined)), _2, _3, {
                  txt: _4,
                  loc: rhs_loc(4)
                }, _6);
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return reloc_exp(Stdlib__Parsing.peek_val(__caml_parser_env, 1));
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkexp({
                  TAG: /* Pexp_sequence */16,
                  _0: _1,
                  _1: _3
                });
    }),
  (function (__caml_parser_env) {
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return [
              "?" + _3[0],
              _4,
              _3[1]
            ];
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              "?" + _2[0],
              undefined,
              _2[1]
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return [
              "?" + _1,
              _4,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              "?" + _1,
              undefined,
              _2
            ];
    }),
  (function (__caml_parser_env) {
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return [
              _3[0],
              undefined,
              _3[1]
            ];
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              _2[0],
              undefined,
              _2[1]
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              _1,
              undefined,
              _2
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              "",
              undefined,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkpat({
                  TAG: /* Ppat_var */0,
                  _0: {
                    txt: _1,
                    loc: rhs_loc(1)
                  }
                });
    }),
  (function (__caml_parser_env) {
      return mkpat(/* Ppat_any */0);
    }),
  (function (__caml_parser_env) {
      
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              _1[0],
              mkpat({
                    TAG: /* Ppat_constraint */10,
                    _0: _1[1],
                    _1: _3
                  })
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              _1,
              mkpat({
                    TAG: /* Ppat_var */0,
                    _0: {
                      txt: _1,
                      loc: rhs_loc(1)
                    }
                  })
            ];
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkpat({
                  TAG: /* Ppat_constraint */10,
                  _0: _1,
                  _1: _3
                });
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkexp({
                  TAG: /* Pexp_apply */5,
                  _0: _1,
                  _1: Stdlib__List.rev(_2)
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      const bindings = Stdlib__List.map((function (lb) {
              if (Caml_obj.caml_notequal(lb.lb_attributes, /* [] */0)) {
                throw new Caml_js_exceptions.MelangeError($$Error$3, {
                          MEL_EXN_ID: $$Error$3,
                          _1: {
                            TAG: /* Not_expecting */2,
                            _0: lb.lb_loc,
                            _1: "item attribute"
                          }
                        });
              }
              return mk$17(lb.lb_loc, undefined, undefined, undefined, lb.lb_pattern, lb.lb_expression);
            }), _1.lbs_bindings);
      const d_0 = _1.lbs_rec;
      const d_1 = Stdlib__List.rev(bindings);
      const d = {
        TAG: /* Pexp_let */2,
        _0: d_0,
        _1: d_1,
        _2: _3
      };
      return wrap_exp_attrs(mkexp(d), [
                  _1.lbs_extension,
                  _1.lbs_attributes
                ]);
    }),
  (function (__caml_parser_env) {
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _7 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      const d_0 = {
        txt: _4,
        loc: rhs_loc(4)
      };
      const d = {
        TAG: /* Pexp_letmodule */25,
        _0: d_0,
        _1: _5,
        _2: _7
      };
      return wrap_exp_attrs(mkexp(d), _3);
    }),
  (function (__caml_parser_env) {
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _7 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      const d_1 = {
        txt: _5,
        loc: rhs_loc(5)
      };
      const d = {
        TAG: /* Pexp_open */32,
        _0: _3,
        _1: d_1,
        _2: _7
      };
      return wrap_exp_attrs(mkexp(d), _4);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      const d = {
        TAG: /* Pexp_function */3,
        _0: Stdlib__List.rev(_4)
      };
      return wrap_exp_attrs(mkexp(d), _2);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return wrap_exp_attrs(mkexp({
                      TAG: /* Pexp_fun */4,
                      _0: _3[0],
                      _1: _3[1],
                      _2: _3[2],
                      _3: _4
                    }), _2);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 5);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _7 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return wrap_exp_attrs(mkexp({
                      TAG: /* Pexp_newtype */30,
                      _0: _5,
                      _1: _7
                    }), _2);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _6 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      const d_1 = Stdlib__List.rev(_6);
      const d = {
        TAG: /* Pexp_match */6,
        _0: _3,
        _1: d_1
      };
      return wrap_exp_attrs(mkexp(d), _2);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _6 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      const d_1 = Stdlib__List.rev(_6);
      const d = {
        TAG: /* Pexp_try */7,
        _0: _3,
        _1: d_1
      };
      return wrap_exp_attrs(mkexp(d), _2);
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      throw new Caml_js_exceptions.MelangeError(Escape_error, {
                MEL_EXN_ID: Escape_error
              });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkexp({
                  TAG: /* Pexp_tuple */8,
                  _0: Stdlib__List.rev(_1)
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkexp({
                  TAG: /* Pexp_construct */9,
                  _0: {
                    txt: _1,
                    loc: rhs_loc(1)
                  },
                  _1: _2
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkexp({
                  TAG: /* Pexp_variant */10,
                  _0: _1,
                  _1: _2
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 5);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _7 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return wrap_exp_attrs(mkexp({
                      TAG: /* Pexp_ifthenelse */15,
                      _0: _3,
                      _1: _5,
                      _2: _7
                    }), _2);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return wrap_exp_attrs(mkexp({
                      TAG: /* Pexp_ifthenelse */15,
                      _0: _3,
                      _1: _5,
                      _2: undefined
                    }), _2);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return wrap_exp_attrs(mkexp({
                      TAG: /* Pexp_while */17,
                      _0: _3,
                      _1: _5
                    }), _2);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 8);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 7);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 5);
      const _6 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _7 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _9 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return wrap_exp_attrs(mkexp({
                      TAG: /* Pexp_for */18,
                      _0: _3,
                      _1: _5,
                      _2: _7,
                      _3: _6,
                      _4: _9
                    }), _2);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkexp_cons(rhs_loc(2), ghexp({
                      TAG: /* Pexp_tuple */8,
                      _0: {
                        hd: _1,
                        tl: {
                          hd: _3,
                          tl: /* [] */0
                        }
                      }
                    }), symbol_rloc(undefined));
    }),
  (function (__caml_parser_env) {
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _7 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mkexp_cons(rhs_loc(2), ghexp({
                      TAG: /* Pexp_tuple */8,
                      _0: {
                        hd: _5,
                        tl: {
                          hd: _7,
                          tl: /* [] */0
                        }
                      }
                    }), symbol_rloc(undefined));
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, _2, _3);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, _2, _3);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, _2, _3);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, _2, _3);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, _2, _3);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "+", _3);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "+.", _3);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "+=", _3);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "-", _3);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "-.", _3);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "*", _3);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "%", _3);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "=", _3);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "<", _3);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, ">", _3);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "or", _3);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "||", _3);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "&", _3);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "&&", _3);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, ":=", _3);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      const match = _2.pexp_desc;
      let exit = 0;
      switch (_1) {
        case "-" :
            if (match.TAG === /* Pexp_constant */1) {
              const n = match._0;
              switch (n.TAG | 0) {
                case /* Const_int */0 :
                    return mkexp({
                                TAG: /* Pexp_constant */1,
                                _0: {
                                  TAG: /* Const_int */0,
                                  _0: -n._0 | 0
                                }
                              });
                case /* Const_int32 */4 :
                    return mkexp({
                                TAG: /* Pexp_constant */1,
                                _0: {
                                  TAG: /* Const_int32 */4,
                                  _0: -n._0 | 0
                                }
                              });
                case /* Const_int64 */5 :
                    return mkexp({
                                TAG: /* Pexp_constant */1,
                                _0: {
                                  TAG: /* Const_int64 */5,
                                  _0: Caml_int64.neg(n._0)
                                }
                              });
                case /* Const_nativeint */6 :
                    return mkexp({
                                TAG: /* Pexp_constant */1,
                                _0: {
                                  TAG: /* Const_nativeint */6,
                                  _0: Caml_external_polyfill.resolve("nativeint_neg")(n._0)
                                }
                              });
                default:
                  exit = 2;
              }
            } else {
              exit = 2;
            }
            break;
        case "-." :
            exit = 2;
            break;
        default:
          
      }
      if (exit === 2 && match.TAG === /* Pexp_constant */1) {
        const f = match._0;
        if (f.TAG === /* Const_float */3) {
          return mkexp({
                      TAG: /* Pexp_constant */1,
                      _0: {
                        TAG: /* Const_float */3,
                        _0: neg_float_string(f._0)
                      }
                    });
        }
        
      }
      return mkexp({
                  TAG: /* Pexp_apply */5,
                  _0: mkoperator("~" + _1, 1),
                  _1: {
                    hd: [
                      "",
                      _2
                    ],
                    tl: /* [] */0
                  }
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      const desc = _2.pexp_desc;
      let exit = 0;
      switch (_1) {
        case "+" :
            if (desc.TAG === /* Pexp_constant */1) {
              switch (desc._0.TAG | 0) {
                case /* Const_char */1 :
                case /* Const_string */2 :
                case /* Const_float */3 :
                    exit = 2;
                    break;
                default:
                  return mkexp(desc);
              }
            } else {
              exit = 2;
            }
            break;
        case "+." :
            exit = 2;
            break;
        default:
          
      }
      if (exit === 2 && desc.TAG === /* Pexp_constant */1 && desc._0.TAG === /* Const_float */3) {
        return mkexp(desc);
      }
      return mkexp({
                  TAG: /* Pexp_apply */5,
                  _0: mkoperator("~" + _1, 1),
                  _1: {
                    hd: [
                      "",
                      _2
                    ],
                    tl: /* [] */0
                  }
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkexp({
                  TAG: /* Pexp_setfield */13,
                  _0: _1,
                  _1: {
                    txt: _3,
                    loc: rhs_loc(3)
                  },
                  _2: _5
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 6);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _7 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkexp({
                  TAG: /* Pexp_apply */5,
                  _0: ghexp({
                        TAG: /* Pexp_ident */0,
                        _0: array_function("Array", "set")
                      }),
                  _1: {
                    hd: [
                      "",
                      _1
                    ],
                    tl: {
                      hd: [
                        "",
                        _4
                      ],
                      tl: {
                        hd: [
                          "",
                          _7
                        ],
                        tl: /* [] */0
                      }
                    }
                  }
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 6);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _7 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkexp({
                  TAG: /* Pexp_apply */5,
                  _0: ghexp({
                        TAG: /* Pexp_ident */0,
                        _0: array_function("String", "set")
                      }),
                  _1: {
                    hd: [
                      "",
                      _1
                    ],
                    tl: {
                      hd: [
                        "",
                        _4
                      ],
                      tl: {
                        hd: [
                          "",
                          _7
                        ],
                        tl: /* [] */0
                      }
                    }
                  }
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 6);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _7 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      const set = fast.contents ? "unsafe_set" : "set";
      const coords = bigarray_untuplify(_4);
      if (coords) {
        const match = coords.tl;
        const c1 = coords.hd;
        if (!match) {
          return mkexp({
                      TAG: /* Pexp_apply */5,
                      _0: ghexp({
                            TAG: /* Pexp_ident */0,
                            _0: bigarray_function("Array1", set)
                          }),
                      _1: {
                        hd: [
                          "",
                          _1
                        ],
                        tl: {
                          hd: [
                            "",
                            c1
                          ],
                          tl: {
                            hd: [
                              "",
                              _7
                            ],
                            tl: /* [] */0
                          }
                        }
                      }
                    });
        }
        const match$1 = match.tl;
        const c2 = match.hd;
        if (!match$1) {
          return mkexp({
                      TAG: /* Pexp_apply */5,
                      _0: ghexp({
                            TAG: /* Pexp_ident */0,
                            _0: bigarray_function("Array2", set)
                          }),
                      _1: {
                        hd: [
                          "",
                          _1
                        ],
                        tl: {
                          hd: [
                            "",
                            c1
                          ],
                          tl: {
                            hd: [
                              "",
                              c2
                            ],
                            tl: {
                              hd: [
                                "",
                                _7
                              ],
                              tl: /* [] */0
                            }
                          }
                        }
                      }
                    });
        }
        if (!match$1.tl) {
          return mkexp({
                      TAG: /* Pexp_apply */5,
                      _0: ghexp({
                            TAG: /* Pexp_ident */0,
                            _0: bigarray_function("Array3", set)
                          }),
                      _1: {
                        hd: [
                          "",
                          _1
                        ],
                        tl: {
                          hd: [
                            "",
                            c1
                          ],
                          tl: {
                            hd: [
                              "",
                              c2
                            ],
                            tl: {
                              hd: [
                                "",
                                match$1.hd
                              ],
                              tl: {
                                hd: [
                                  "",
                                  _7
                                ],
                                tl: /* [] */0
                              }
                            }
                          }
                        }
                      }
                    });
        }
        
      }
      return mkexp({
                  TAG: /* Pexp_apply */5,
                  _0: ghexp({
                        TAG: /* Pexp_ident */0,
                        _0: bigarray_function("Genarray", "set")
                      }),
                  _1: {
                    hd: [
                      "",
                      _1
                    ],
                    tl: {
                      hd: [
                        "",
                        ghexp({
                              TAG: /* Pexp_array */14,
                              _0: coords
                            })
                      ],
                      tl: {
                        hd: [
                          "",
                          _7
                        ],
                        tl: /* [] */0
                      }
                    }
                  }
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkexp({
                  TAG: /* Pexp_setinstvar */23,
                  _0: {
                    txt: _1,
                    loc: rhs_loc(1)
                  },
                  _1: _3
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return wrap_exp_attrs(mkexp({
                      TAG: /* Pexp_assert */26,
                      _0: _3
                    }), _2);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return wrap_exp_attrs(mkexp({
                      TAG: /* Pexp_lazy */27,
                      _0: _3
                    }), _2);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return wrap_exp_attrs(mkexp({
                      TAG: /* Pexp_object */29,
                      _0: _3
                    }), _2);
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("object", 1, "end", 4);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return Curry._2(Ast_helper_Exp.attr, _1, _2);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkexp({
                  TAG: /* Pexp_ident */0,
                  _0: {
                    txt: _1,
                    loc: rhs_loc(1)
                  }
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkexp({
                  TAG: /* Pexp_constant */1,
                  _0: _1
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkexp({
                  TAG: /* Pexp_construct */9,
                  _0: {
                    txt: _1,
                    loc: rhs_loc(1)
                  },
                  _1: undefined
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkexp({
                  TAG: /* Pexp_variant */10,
                  _0: _1,
                  _1: undefined
                });
    }),
  (function (__caml_parser_env) {
      return reloc_exp(Stdlib__Parsing.peek_val(__caml_parser_env, 1));
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 3);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return wrap_exp_attrs(reloc_exp(_3), _2);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const d_0 = {
        txt: {
          TAG: /* Lident */0,
          _0: "()"
        },
        loc: symbol_rloc(undefined)
      };
      const d = {
        TAG: /* Pexp_construct */9,
        _0: d_0,
        _1: undefined
      };
      return wrap_exp_attrs(mkexp(d), _2);
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("begin", 1, "end", 3);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mkexp_constraint(_2, _3);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkexp({
                  TAG: /* Pexp_field */12,
                  _0: _1,
                  _1: {
                    txt: _3,
                    loc: rhs_loc(3)
                  }
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mkexp({
                  TAG: /* Pexp_open */32,
                  _0: /* Fresh */1,
                  _1: {
                    txt: _1,
                    loc: rhs_loc(1)
                  },
                  _2: _4
                });
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 3, ")", 5);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mkexp({
                  TAG: /* Pexp_apply */5,
                  _0: ghexp({
                        TAG: /* Pexp_ident */0,
                        _0: array_function("Array", "get")
                      }),
                  _1: {
                    hd: [
                      "",
                      _1
                    ],
                    tl: {
                      hd: [
                        "",
                        _4
                      ],
                      tl: /* [] */0
                    }
                  }
                });
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 3, ")", 5);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mkexp({
                  TAG: /* Pexp_apply */5,
                  _0: ghexp({
                        TAG: /* Pexp_ident */0,
                        _0: array_function("String", "get")
                      }),
                  _1: {
                    hd: [
                      "",
                      _1
                    ],
                    tl: {
                      hd: [
                        "",
                        _4
                      ],
                      tl: /* [] */0
                    }
                  }
                });
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("[", 3, "]", 5);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const get = fast.contents ? "unsafe_get" : "get";
      const coords = bigarray_untuplify(_4);
      if (coords) {
        const match = coords.tl;
        const c1 = coords.hd;
        if (!match) {
          return mkexp({
                      TAG: /* Pexp_apply */5,
                      _0: ghexp({
                            TAG: /* Pexp_ident */0,
                            _0: bigarray_function("Array1", get)
                          }),
                      _1: {
                        hd: [
                          "",
                          _1
                        ],
                        tl: {
                          hd: [
                            "",
                            c1
                          ],
                          tl: /* [] */0
                        }
                      }
                    });
        }
        const match$1 = match.tl;
        const c2 = match.hd;
        if (!match$1) {
          return mkexp({
                      TAG: /* Pexp_apply */5,
                      _0: ghexp({
                            TAG: /* Pexp_ident */0,
                            _0: bigarray_function("Array2", get)
                          }),
                      _1: {
                        hd: [
                          "",
                          _1
                        ],
                        tl: {
                          hd: [
                            "",
                            c1
                          ],
                          tl: {
                            hd: [
                              "",
                              c2
                            ],
                            tl: /* [] */0
                          }
                        }
                      }
                    });
        }
        if (!match$1.tl) {
          return mkexp({
                      TAG: /* Pexp_apply */5,
                      _0: ghexp({
                            TAG: /* Pexp_ident */0,
                            _0: bigarray_function("Array3", get)
                          }),
                      _1: {
                        hd: [
                          "",
                          _1
                        ],
                        tl: {
                          hd: [
                            "",
                            c1
                          ],
                          tl: {
                            hd: [
                              "",
                              c2
                            ],
                            tl: {
                              hd: [
                                "",
                                match$1.hd
                              ],
                              tl: /* [] */0
                            }
                          }
                        }
                      }
                    });
        }
        
      }
      return mkexp({
                  TAG: /* Pexp_apply */5,
                  _0: ghexp({
                        TAG: /* Pexp_ident */0,
                        _0: bigarray_function("Genarray", "get")
                      }),
                  _1: {
                    hd: [
                      "",
                      _1
                    ],
                    tl: {
                      hd: [
                        "",
                        ghexp({
                              TAG: /* Pexp_array */14,
                              _0: coords
                            })
                      ],
                      tl: /* [] */0
                    }
                  }
                });
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("{", 3, "}", 5);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mkexp({
                  TAG: /* Pexp_record */11,
                  _0: _2[1],
                  _1: _2[0]
                });
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("{", 1, "}", 3);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const rec_exp = mkexp({
            TAG: /* Pexp_record */11,
            _0: _4[1],
            _1: _4[0]
          });
      return mkexp({
                  TAG: /* Pexp_open */32,
                  _0: /* Fresh */1,
                  _1: {
                    txt: _1,
                    loc: rhs_loc(1)
                  },
                  _2: rec_exp
                });
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("{", 3, "}", 5);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mkexp({
                  TAG: /* Pexp_array */14,
                  _0: Stdlib__List.rev(_2)
                });
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("[|", 1, "|]", 4);
    }),
  (function (__caml_parser_env) {
      return mkexp({
                  TAG: /* Pexp_array */14,
                  _0: /* [] */0
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 5);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mkexp({
                  TAG: /* Pexp_open */32,
                  _0: /* Fresh */1,
                  _1: {
                    txt: _1,
                    loc: rhs_loc(1)
                  },
                  _2: mkexp({
                        TAG: /* Pexp_array */14,
                        _0: Stdlib__List.rev(_4)
                      })
                });
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 5);
      Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("[|", 3, "|]", 6);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return reloc_exp(mktailexp(rhs_loc(4), Stdlib__List.rev(_2)));
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("[", 1, "]", 4);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 5);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const list_exp = reloc_exp(mktailexp(rhs_loc(6), Stdlib__List.rev(_4)));
      return mkexp({
                  TAG: /* Pexp_open */32,
                  _0: /* Fresh */1,
                  _1: {
                    txt: _1,
                    loc: rhs_loc(1)
                  },
                  _2: list_exp
                });
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 5);
      Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("[", 3, "]", 6);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkexp({
                  TAG: /* Pexp_apply */5,
                  _0: mkoperator(_1, 1),
                  _1: {
                    hd: [
                      "",
                      _2
                    ],
                    tl: /* [] */0
                  }
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkexp({
                  TAG: /* Pexp_apply */5,
                  _0: mkoperator("!", 1),
                  _1: {
                    hd: [
                      "",
                      _2
                    ],
                    tl: /* [] */0
                  }
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      const d = {
        TAG: /* Pexp_new */22,
        _0: {
          txt: _3,
          loc: rhs_loc(3)
        }
      };
      return wrap_exp_attrs(mkexp(d), _2);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mkexp({
                  TAG: /* Pexp_override */24,
                  _0: Stdlib__List.rev(_2)
                });
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("{<", 1, ">}", 4);
    }),
  (function (__caml_parser_env) {
      return mkexp({
                  TAG: /* Pexp_override */24,
                  _0: /* [] */0
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 5);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mkexp({
                  TAG: /* Pexp_open */32,
                  _0: /* Fresh */1,
                  _1: {
                    txt: _1,
                    loc: rhs_loc(1)
                  },
                  _2: mkexp({
                        TAG: /* Pexp_override */24,
                        _0: Stdlib__List.rev(_4)
                      })
                });
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 5);
      Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("{<", 3, ">}", 6);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkexp({
                  TAG: /* Pexp_send */21,
                  _0: _1,
                  _1: _3
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, _2, _3);
    }),
  (function (__caml_parser_env) {
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mkexp({
                  TAG: /* Pexp_pack */31,
                  _0: _3
                });
    }),
  (function (__caml_parser_env) {
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mkexp({
                  TAG: /* Pexp_constraint */19,
                  _0: ghexp({
                        TAG: /* Pexp_pack */31,
                        _0: _3
                      }),
                  _1: ghtyp({
                        TAG: /* Ptyp_package */9,
                        _0: _5
                      })
                });
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      return unclosed("(", 1, ")", 5);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 7);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _7 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mkexp({
                  TAG: /* Pexp_open */32,
                  _0: /* Fresh */1,
                  _1: {
                    txt: _1,
                    loc: rhs_loc(1)
                  },
                  _2: mkexp({
                        TAG: /* Pexp_constraint */19,
                        _0: ghexp({
                              TAG: /* Pexp_pack */31,
                              _0: _5
                            }),
                        _1: ghtyp({
                              TAG: /* Ptyp_package */9,
                              _0: _7
                            })
                      })
                });
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 6);
      Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      return unclosed("(", 3, ")", 7);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkexp({
                  TAG: /* Pexp_extension */33,
                  _0: _1
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _2,
              tl: _1
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              "",
              _1
            ];
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              _1,
              _2
            ];
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              "?" + _2[0],
              _2[1]
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              "?" + _1,
              _2
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              _1,
              mkexp({
                    TAG: /* Pexp_ident */0,
                    _0: {
                      txt: {
                        TAG: /* Lident */0,
                        _0: _1
                      },
                      loc: rhs_loc(1)
                    }
                  })
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: _2
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              mkpatvar(_1, 1),
              _2
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 6);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _7 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              ghpat({
                    TAG: /* Ppat_constraint */10,
                    _0: mkpatvar(_1, 1),
                    _1: ghtyp({
                          TAG: /* Ptyp_poly */8,
                          _0: Stdlib__List.rev(_3),
                          _1: _5
                        })
                  }),
              _7
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 7);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _6 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _8 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      const match = wrap_type_annotation(_4, _6, _8);
      return [
              ghpat({
                    TAG: /* Ppat_constraint */10,
                    _0: mkpatvar(_1, 1),
                    _1: match[1]
                  }),
              match[0]
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              _1,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              ghpat({
                    TAG: /* Ppat_constraint */10,
                    _0: _1,
                    _1: _3
                  }),
              _5
            ];
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              lbs_bindings: {
                hd: _2,
                tl: _1.lbs_bindings
              },
              lbs_rec: _1.lbs_rec,
              lbs_extension: _1.lbs_extension,
              lbs_attributes: _1.lbs_attributes,
              lbs_loc: _1.lbs_loc
            };
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      let lb = mklb(_4, _5);
      return {
              lbs_bindings: {
                hd: lb,
                tl: /* [] */0
              },
              lbs_rec: _3,
              lbs_extension: _2[0],
              lbs_attributes: _2[1],
              lbs_loc: symbol_rloc(undefined)
            };
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mklb(_2, _3);
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkexp_constraint(_3, _1);
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return ghexp({
                  TAG: /* Pexp_fun */4,
                  _0: _1[0],
                  _1: _1[1],
                  _2: _1[2],
                  _3: _2
                });
    }),
  (function (__caml_parser_env) {
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkexp({
                  TAG: /* Pexp_newtype */30,
                  _0: _3,
                  _1: _5
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _3,
              tl: _1
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return Curry._3(Ast_helper_Exp.$$case, _1, undefined, _3);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return Curry._3(Ast_helper_Exp.$$case, _1, _3, _5);
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return ghexp({
                  TAG: /* Pexp_fun */4,
                  _0: _1[0],
                  _1: _1[1],
                  _2: _1[2],
                  _3: _2
                });
    }),
  (function (__caml_parser_env) {
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkexp({
                  TAG: /* Pexp_newtype */30,
                  _0: _3,
                  _1: _5
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _3,
              tl: _1
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _3,
              tl: {
                hd: _1,
                tl: /* [] */0
              }
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              _1,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              undefined,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: _3
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              {
                txt: _1,
                loc: rhs_loc(1)
              },
              _3
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              {
                txt: _1,
                loc: rhs_loc(1)
              },
              exp_of_label(_1, 1)
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: [
                {
                  txt: _1,
                  loc: rhs_loc(1)
                },
                _3
              ],
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: [
                {
                  txt: _3,
                  loc: rhs_loc(3)
                },
                _5
              ],
              tl: _1
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _3,
              tl: _1
            };
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              _2,
              undefined
            ];
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              _2,
              _4
            ];
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              undefined,
              _2
            ];
    }),
  (function (__caml_parser_env) {
      throw new Caml_js_exceptions.MelangeError(Escape_error, {
                MEL_EXN_ID: Escape_error
              });
    }),
  (function (__caml_parser_env) {
      throw new Caml_js_exceptions.MelangeError(Escape_error, {
                MEL_EXN_ID: Escape_error
              });
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkpat({
                  TAG: /* Ppat_alias */1,
                  _0: _1,
                  _1: {
                    txt: _3,
                    loc: rhs_loc(3)
                  }
                });
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      return expecting(3, "identifier");
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkpat({
                  TAG: /* Ppat_tuple */4,
                  _0: Stdlib__List.rev(_1)
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkpat({
                  TAG: /* Ppat_construct */5,
                  _0: {
                    txt: _1,
                    loc: rhs_loc(1)
                  },
                  _1: _2
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkpat({
                  TAG: /* Ppat_variant */6,
                  _0: _1,
                  _1: _2
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkpat_cons(rhs_loc(2), ghpat({
                      TAG: /* Ppat_tuple */4,
                      _0: {
                        hd: _1,
                        tl: {
                          hd: _3,
                          tl: /* [] */0
                        }
                      }
                    }), symbol_rloc(undefined));
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      return expecting(3, "pattern");
    }),
  (function (__caml_parser_env) {
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _7 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mkpat_cons(rhs_loc(2), ghpat({
                      TAG: /* Ppat_tuple */4,
                      _0: {
                        hd: _5,
                        tl: {
                          hd: _7,
                          tl: /* [] */0
                        }
                      }
                    }), symbol_rloc(undefined));
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 4, ")", 8);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkpat({
                  TAG: /* Ppat_or */9,
                  _0: _1,
                  _1: _3
                });
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      return expecting(3, "pattern");
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkpat({
                  TAG: /* Ppat_lazy */12,
                  _0: _2
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkpat({
                  TAG: /* Ppat_exception */14,
                  _0: _2
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return attr$1(_1, _2);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkpat({
                  TAG: /* Ppat_var */0,
                  _0: {
                    txt: _1,
                    loc: rhs_loc(1)
                  }
                });
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return mkpat(/* Ppat_any */0);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkpat({
                  TAG: /* Ppat_constant */2,
                  _0: _1
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkpat({
                  TAG: /* Ppat_interval */3,
                  _0: _1,
                  _1: _3
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkpat({
                  TAG: /* Ppat_construct */5,
                  _0: {
                    txt: _1,
                    loc: rhs_loc(1)
                  },
                  _1: undefined
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkpat({
                  TAG: /* Ppat_variant */6,
                  _0: _1,
                  _1: undefined
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkpat({
                  TAG: /* Ppat_type */11,
                  _0: {
                    txt: _2,
                    loc: rhs_loc(2)
                  }
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mkpat({
                  TAG: /* Ppat_record */7,
                  _0: _2[0],
                  _1: _2[1]
                });
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("{", 1, "}", 3);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return reloc_pat(mktailpat(rhs_loc(4), Stdlib__List.rev(_2)));
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("[", 1, "]", 4);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mkpat({
                  TAG: /* Ppat_array */8,
                  _0: Stdlib__List.rev(_2)
                });
    }),
  (function (__caml_parser_env) {
      return mkpat({
                  TAG: /* Ppat_array */8,
                  _0: /* [] */0
                });
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("[|", 1, "|]", 4);
    }),
  (function (__caml_parser_env) {
      return reloc_pat(Stdlib__Parsing.peek_val(__caml_parser_env, 1));
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 3);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mkpat({
                  TAG: /* Ppat_constraint */10,
                  _0: _2,
                  _1: _4
                });
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 5);
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      return expecting(4, "type");
    }),
  (function (__caml_parser_env) {
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mkpat({
                  TAG: /* Ppat_unpack */13,
                  _0: {
                    txt: _3,
                    loc: rhs_loc(3)
                  }
                });
    }),
  (function (__caml_parser_env) {
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mkpat({
                  TAG: /* Ppat_constraint */10,
                  _0: mkpat({
                        TAG: /* Ppat_unpack */13,
                        _0: {
                          txt: _3,
                          loc: rhs_loc(3)
                        }
                      }),
                  _1: ghtyp({
                        TAG: /* Ptyp_package */9,
                        _0: _5
                      })
                });
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 6);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mkpat({
                  TAG: /* Ppat_extension */15,
                  _0: _1
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _3,
              tl: _1
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _3,
              tl: {
                hd: _1,
                tl: /* [] */0
              }
            };
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      return expecting(3, "pattern");
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _3,
              tl: _1
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              {
                hd: _1,
                tl: /* [] */0
              },
              /* Closed */0
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return [
              {
                hd: _1,
                tl: /* [] */0
              },
              /* Closed */0
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              {
                hd: _1,
                tl: /* [] */0
              },
              /* Open */1
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              {
                hd: _1,
                tl: _3[0]
              },
              _3[1]
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              {
                txt: _1,
                loc: rhs_loc(1)
              },
              _3
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              {
                txt: _1,
                loc: rhs_loc(1)
              },
              pat_of_label(_1, 1)
            ];
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mk$11(symbol_rloc(undefined), _5, symbol_docs(undefined), undefined, {
                  txt: _2,
                  loc: rhs_loc(2)
                }, _4);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1[0],
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1[0],
              tl: _2
            };
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 5);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _6 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _7 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mk$11(symbol_rloc(undefined), _7, symbol_docs(undefined), _6, {
                  txt: _2,
                  loc: rhs_loc(2)
                }, _4);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _2,
              tl: _1
            };
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 5);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _6 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _7 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mk$19(symbol_rloc(undefined), add_nonrec(_2, _7, 2), symbol_docs(undefined), undefined, _3, Stdlib__List.rev(_6), _5[0], _5[1], _5[2], {
                  txt: _4,
                  loc: rhs_loc(4)
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _6 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mk$19(symbol_rloc(undefined), _6, symbol_docs(undefined), get_text(Stdlib__Parsing.symbol_start_pos(undefined)), _2, Stdlib__List.rev(_5), _4[0], _4[1], _4[2], {
                  txt: _3,
                  loc: rhs_loc(3)
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _3,
              tl: _1
            };
    }),
  (function (__caml_parser_env) {
      return /* [] */0;
    }),
  (function (__caml_parser_env) {
      return [
              /* Ptype_abstract */0,
              /* Public */1,
              undefined
            ];
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              /* Ptype_abstract */0,
              /* Public */1,
              _2
            ];
    }),
  (function (__caml_parser_env) {
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              /* Ptype_abstract */0,
              /* Private */0,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              {
                TAG: /* Ptype_variant */0,
                _0: Stdlib__List.rev(_2)
              },
              /* Public */1,
              undefined
            ];
    }),
  (function (__caml_parser_env) {
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              {
                TAG: /* Ptype_variant */0,
                _0: Stdlib__List.rev(_3)
              },
              /* Private */0,
              undefined
            ];
    }),
  (function (__caml_parser_env) {
      return [
              /* Ptype_open */1,
              /* Public */1,
              undefined
            ];
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return [
              {
                TAG: /* Ptype_record */1,
                _0: _4
              },
              _2,
              undefined
            ];
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              {
                TAG: /* Ptype_variant */0,
                _0: Stdlib__List.rev(_5)
              },
              _4,
              _2
            ];
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      return [
              /* Ptype_open */1,
              /* Public */1,
              _2
            ];
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 5);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _6 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return [
              {
                TAG: /* Ptype_record */1,
                _0: _6
              },
              _4,
              _2
            ];
    }),
  (function (__caml_parser_env) {
      return /* [] */0;
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      return Stdlib__List.rev(Stdlib__Parsing.peek_val(__caml_parser_env, 1));
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              _2,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _3,
              tl: _1
            };
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mktyp({
                  TAG: /* Ptyp_var */0,
                  _0: _2
                });
    }),
  (function (__caml_parser_env) {
      return mktyp(/* Ptyp_any */0);
    }),
  (function (__caml_parser_env) {
      return /* [] */0;
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      return Stdlib__List.rev(Stdlib__Parsing.peek_val(__caml_parser_env, 1));
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              _2,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      return /* Invariant */2;
    }),
  (function (__caml_parser_env) {
      return /* Covariant */0;
    }),
  (function (__caml_parser_env) {
      return /* Contravariant */1;
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mktyp({
                  TAG: /* Ptyp_var */0,
                  _0: _2
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _3,
              tl: _1
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _2,
              tl: _1
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return constructor(symbol_rloc(undefined), _3, Caml_option.some(get_info(Stdlib__Parsing.symbol_end_pos(undefined))), _2[0], _2[1], {
                  txt: _1,
                  loc: rhs_loc(1)
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return constructor(symbol_rloc(undefined), _4, Caml_option.some(get_info(Stdlib__Parsing.symbol_end_pos(undefined))), _3[0], _3[1], {
                  txt: _2,
                  loc: rhs_loc(2)
                });
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _6 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return rebind(symbol_rloc(undefined), Stdlib.$at(_5, _6), symbol_docs(undefined), undefined, {
                  txt: _2,
                  loc: rhs_loc(2)
                }, {
                  txt: _4,
                  loc: rhs_loc(4)
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return decl(symbol_rloc(undefined), Stdlib.$at(_4, _5), symbol_docs(undefined), undefined, _3[0], _3[1], {
                  txt: _2,
                  loc: rhs_loc(2)
                });
    }),
  (function (__caml_parser_env) {
      return [
              /* [] */0,
              undefined
            ];
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              Stdlib__List.rev(_2),
              undefined
            ];
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              Stdlib__List.rev(_2),
              _4
            ];
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              /* [] */0,
              _2
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: _2
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return field$1(symbol_rloc(undefined), _5, Caml_option.some(get_info(Stdlib__Parsing.symbol_end_pos(undefined))), _1, {
                  txt: _2,
                  loc: rhs_loc(2)
                }, _4);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 6);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 5);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _7 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      const info_before_semi = get_info(Stdlib__Parsing.rhs_end_pos(5));
      const info = info_before_semi !== undefined ? info_before_semi : get_info(Stdlib__Parsing.symbol_end_pos(undefined));
      return field$1(symbol_rloc(undefined), Stdlib.$at(_5, _7), Caml_option.some(info), _1, {
                  txt: _2,
                  loc: rhs_loc(2)
                }, _4);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 6);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 5);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _6 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _7 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _8 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      if (_2 !== /* Recursive */1) {
        not_expecting(2, "nonrec flag");
      }
      return mk$20(_8, symbol_docs(undefined), _3, _6, {
                  txt: _4,
                  loc: rhs_loc(4)
                }, Stdlib__List.rev(_7));
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 6);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 5);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _6 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _7 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _8 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      if (_2 !== /* Recursive */1) {
        not_expecting(2, "nonrec flag");
      }
      return mk$20(_8, symbol_docs(undefined), _3, _6, {
                  txt: _4,
                  loc: rhs_loc(4)
                }, Stdlib__List.rev(_7));
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _2,
              tl: _1
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _2,
              tl: _1
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _2,
              tl: _1
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return decl(symbol_rloc(undefined), _3, undefined, Caml_option.some(get_info(Stdlib__Parsing.symbol_end_pos(undefined))), _2[0], _2[1], {
                  txt: _1,
                  loc: rhs_loc(1)
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return decl(symbol_rloc(undefined), _4, undefined, Caml_option.some(get_info(Stdlib__Parsing.symbol_end_pos(undefined))), _3[0], _3[1], {
                  txt: _2,
                  loc: rhs_loc(2)
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return rebind(symbol_rloc(undefined), _4, undefined, Caml_option.some(get_info(Stdlib__Parsing.symbol_end_pos(undefined))), {
                  txt: _1,
                  loc: rhs_loc(1)
                }, {
                  txt: _3,
                  loc: rhs_loc(3)
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return rebind(symbol_rloc(undefined), _5, undefined, Caml_option.some(get_info(Stdlib__Parsing.symbol_end_pos(undefined))), {
                  txt: _2,
                  loc: rhs_loc(2)
                }, {
                  txt: _4,
                  loc: rhs_loc(4)
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _3,
              tl: _1
            };
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _6 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      const rhs = last$1(_3);
      return {
              TAG: /* Pwith_type */0,
              _0: {
                txt: _3,
                loc: rhs_loc(3)
              },
              _1: mk$19(symbol_rloc(undefined), undefined, undefined, undefined, _2, Stdlib__List.rev(_6), undefined, _4, _5, {
                    txt: rhs,
                    loc: rhs_loc(3)
                  })
            };
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Pwith_typesubst */2,
              _0: mk$19(symbol_rloc(undefined), undefined, undefined, undefined, _2, undefined, undefined, undefined, _5, {
                    txt: _3,
                    loc: rhs_loc(3)
                  })
            };
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Pwith_module */1,
              _0: {
                txt: _2,
                loc: rhs_loc(2)
              },
              _1: {
                txt: _4,
                loc: rhs_loc(4)
              }
            };
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Pwith_modsubst */3,
              _0: {
                txt: _2,
                loc: rhs_loc(2)
              },
              _1: {
                txt: _4,
                loc: rhs_loc(4)
              }
            };
    }),
  (function (__caml_parser_env) {
      return /* Public */1;
    }),
  (function (__caml_parser_env) {
      return /* Private */0;
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _2,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _3,
              tl: _1
            };
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mktyp({
                  TAG: /* Ptyp_poly */8,
                  _0: Stdlib__List.rev(_1),
                  _1: _3
                });
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mktyp({
                  TAG: /* Ptyp_poly */8,
                  _0: Stdlib__List.rev(_1),
                  _1: _3
                });
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return attr(_1, _2);
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mktyp({
                  TAG: /* Ptyp_alias */6,
                  _0: _1,
                  _1: _4
                });
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _6 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mktyp({
                  TAG: /* Ptyp_arrow */1,
                  _0: "?" + _2,
                  _1: mkoption(_4),
                  _2: _6
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mktyp({
                  TAG: /* Ptyp_arrow */1,
                  _0: "?" + _1,
                  _1: mkoption(_2),
                  _2: _4
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mktyp({
                  TAG: /* Ptyp_arrow */1,
                  _0: _1,
                  _1: _3,
                  _2: _5
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mktyp({
                  TAG: /* Ptyp_arrow */1,
                  _0: "",
                  _1: _1,
                  _2: _3
                });
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      if (_2) {
        if (_2.tl) {
          throw new Caml_js_exceptions.MelangeError(Stdlib__Parsing.Parse_error, {
                    MEL_EXN_ID: Stdlib__Parsing.Parse_error
                  });
        }
        return _2.hd;
      }
      throw new Caml_js_exceptions.MelangeError(Stdlib__Parsing.Parse_error, {
                MEL_EXN_ID: Stdlib__Parsing.Parse_error
              });
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      if (_2) {
        if (_2.tl) {
          throw new Caml_js_exceptions.MelangeError(Stdlib__Parsing.Parse_error, {
                    MEL_EXN_ID: Stdlib__Parsing.Parse_error
                  });
        }
        return _2.hd;
      }
      throw new Caml_js_exceptions.MelangeError(Stdlib__Parsing.Parse_error, {
                MEL_EXN_ID: Stdlib__Parsing.Parse_error
              });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mktyp({
                  TAG: /* Ptyp_var */0,
                  _0: _2
                });
    }),
  (function (__caml_parser_env) {
      return mktyp(/* Ptyp_any */0);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mktyp({
                  TAG: /* Ptyp_constr */3,
                  _0: {
                    txt: _1,
                    loc: rhs_loc(1)
                  },
                  _1: /* [] */0
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mktyp({
                  TAG: /* Ptyp_constr */3,
                  _0: {
                    txt: _2,
                    loc: rhs_loc(2)
                  },
                  _1: {
                    hd: _1,
                    tl: /* [] */0
                  }
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mktyp({
                  TAG: /* Ptyp_constr */3,
                  _0: {
                    txt: _4,
                    loc: rhs_loc(4)
                  },
                  _1: Stdlib__List.rev(_2)
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mktyp({
                  TAG: /* Ptyp_object */4,
                  _0: _2[0],
                  _1: _2[1]
                });
    }),
  (function (__caml_parser_env) {
      return mktyp({
                  TAG: /* Ptyp_object */4,
                  _0: /* [] */0,
                  _1: /* Closed */0
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mktyp({
                  TAG: /* Ptyp_class */5,
                  _0: {
                    txt: _2,
                    loc: rhs_loc(2)
                  },
                  _1: /* [] */0
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mktyp({
                  TAG: /* Ptyp_class */5,
                  _0: {
                    txt: _3,
                    loc: rhs_loc(3)
                  },
                  _1: {
                    hd: _1,
                    tl: /* [] */0
                  }
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mktyp({
                  TAG: /* Ptyp_class */5,
                  _0: {
                    txt: _5,
                    loc: rhs_loc(5)
                  },
                  _1: Stdlib__List.rev(_2)
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mktyp({
                  TAG: /* Ptyp_variant */7,
                  _0: {
                    hd: _2,
                    tl: /* [] */0
                  },
                  _1: /* Closed */0,
                  _2: undefined
                });
    }),
  (function (__caml_parser_env) {
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mktyp({
                  TAG: /* Ptyp_variant */7,
                  _0: Stdlib__List.rev(_3),
                  _1: /* Closed */0,
                  _2: undefined
                });
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mktyp({
                  TAG: /* Ptyp_variant */7,
                  _0: {
                    hd: _2,
                    tl: Stdlib__List.rev(_4)
                  },
                  _1: /* Closed */0,
                  _2: undefined
                });
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mktyp({
                  TAG: /* Ptyp_variant */7,
                  _0: Stdlib__List.rev(_3),
                  _1: /* Open */1,
                  _2: undefined
                });
    }),
  (function (__caml_parser_env) {
      return mktyp({
                  TAG: /* Ptyp_variant */7,
                  _0: /* [] */0,
                  _1: /* Open */1,
                  _2: undefined
                });
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mktyp({
                  TAG: /* Ptyp_variant */7,
                  _0: Stdlib__List.rev(_3),
                  _1: /* Closed */0,
                  _2: /* [] */0
                });
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mktyp({
                  TAG: /* Ptyp_variant */7,
                  _0: Stdlib__List.rev(_3),
                  _1: /* Closed */0,
                  _2: Stdlib__List.rev(_5)
                });
    }),
  (function (__caml_parser_env) {
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return mktyp({
                  TAG: /* Ptyp_package */9,
                  _0: _3
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mktyp({
                  TAG: /* Ptyp_extension */10,
                  _0: _1
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              {
                txt: _1,
                loc: rhs_loc(1)
              },
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              {
                txt: _1,
                loc: rhs_loc(1)
              },
              _3
            ];
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              {
                txt: _2,
                loc: rhs_loc(2)
              },
              _4
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: _3
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _3,
              tl: _1
            };
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Rinherit */1,
              _0: _1
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 4);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _5 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Rtag */0,
              _0: _1,
              _1: _5,
              _2: _3,
              _3: Stdlib__List.rev(_4)
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Rtag */0,
              _0: _1,
              _1: _2,
              _2: true,
              _3: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      return true;
    }),
  (function (__caml_parser_env) {
      return false;
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _3,
              tl: _1
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _2,
              tl: _1
            };
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mktyp({
                  TAG: /* Ptyp_tuple */2,
                  _0: {
                    hd: _1,
                    tl: Stdlib__List.rev(_3)
                  }
                });
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return mktyp({
                  TAG: /* Ptyp_tuple */2,
                  _0: {
                    hd: _1,
                    tl: Stdlib__List.rev(_3)
                  }
                });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _3,
              tl: _1
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _3,
              tl: _1
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: /* [] */0
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _3,
              tl: _1
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              {
                hd: _1,
                tl: _3[0]
              },
              _3[1]
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              {
                hd: _1,
                tl: /* [] */0
              },
              /* Closed */0
            ];
    }),
  (function (__caml_parser_env) {
      return [
              /* [] */0,
              /* Open */1
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              _1,
              _4,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Const_int */0,
              _0: _1
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Const_char */1,
              _0: _1
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Const_string */2,
              _0: _1[0],
              _1: _1[1]
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Const_float */3,
              _0: _1
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Const_int32 */4,
              _0: _1
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Const_int64 */5,
              _0: _1
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Const_nativeint */6,
              _0: _1
            };
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Const_int */0,
              _0: -_2 | 0
            };
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Const_float */3,
              _0: "-" + _2
            };
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Const_int32 */4,
              _0: -_2 | 0
            };
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Const_int64 */5,
              _0: Caml_int64.neg(_2)
            };
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Const_nativeint */6,
              _0: Caml_external_polyfill.resolve("nativeint_neg")(_2)
            };
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Const_int */0,
              _0: _2
            };
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Const_float */3,
              _0: _2
            };
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Const_int32 */4,
              _0: _2
            };
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Const_int64 */5,
              _0: _2
            };
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Const_nativeint */6,
              _0: _2
            };
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 1);
    }),
  (function (__caml_parser_env) {
      Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 3);
    }),
  (function (__caml_parser_env) {
      return expecting(2, "operator");
    }),
  (function (__caml_parser_env) {
      return expecting(3, "module-expr");
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return "!";
    }),
  (function (__caml_parser_env) {
      return "+";
    }),
  (function (__caml_parser_env) {
      return "+.";
    }),
  (function (__caml_parser_env) {
      return "-";
    }),
  (function (__caml_parser_env) {
      return "-.";
    }),
  (function (__caml_parser_env) {
      return "*";
    }),
  (function (__caml_parser_env) {
      return "=";
    }),
  (function (__caml_parser_env) {
      return "<";
    }),
  (function (__caml_parser_env) {
      return ">";
    }),
  (function (__caml_parser_env) {
      return "or";
    }),
  (function (__caml_parser_env) {
      return "||";
    }),
  (function (__caml_parser_env) {
      return "&";
    }),
  (function (__caml_parser_env) {
      return "&&";
    }),
  (function (__caml_parser_env) {
      return ":=";
    }),
  (function (__caml_parser_env) {
      return "+=";
    }),
  (function (__caml_parser_env) {
      return "%";
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return "()";
    }),
  (function (__caml_parser_env) {
      return "::";
    }),
  (function (__caml_parser_env) {
      return "false";
    }),
  (function (__caml_parser_env) {
      return "true";
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Lident */0,
              _0: _1
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Ldot */1,
              _0: _1,
              _1: _3
            };
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return {
              TAG: /* Lident */0,
              _0: "[]"
            };
    }),
  (function (__caml_parser_env) {
      return {
              TAG: /* Lident */0,
              _0: "()"
            };
    }),
  (function (__caml_parser_env) {
      return {
              TAG: /* Lident */0,
              _0: "false"
            };
    }),
  (function (__caml_parser_env) {
      return {
              TAG: /* Lident */0,
              _0: "true"
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Lident */0,
              _0: _1
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Ldot */1,
              _0: _1,
              _1: _3
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Lident */0,
              _0: _1
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Ldot */1,
              _0: _1,
              _1: _3
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Lident */0,
              _0: _1
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Ldot */1,
              _0: _1,
              _1: _3
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Lident */0,
              _0: _1
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Ldot */1,
              _0: _1,
              _1: _3
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 3);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      if (applicative_functors.contents) {
        return {
                TAG: /* Lapply */2,
                _0: _1,
                _1: _3
              };
      }
      throw new Caml_js_exceptions.MelangeError($$Error$3, {
                MEL_EXN_ID: $$Error$3,
                _1: {
                  TAG: /* Applicative_path */3,
                  _0: symbol_rloc(undefined)
                }
              });
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Lident */0,
              _0: _1
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Ldot */1,
              _0: _1,
              _1: _3
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Lident */0,
              _0: _1
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Ldot */1,
              _0: _1,
              _1: _3
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Lident */0,
              _0: _1
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Ldot */1,
              _0: _1,
              _1: _3
            };
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Ptop_dir */1,
              _0: _2,
              _1: /* Pdir_none */0
            };
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Ptop_dir */1,
              _0: _2,
              _1: {
                TAG: /* Pdir_string */0,
                _0: _3[0]
              }
            };
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Ptop_dir */1,
              _0: _2,
              _1: {
                TAG: /* Pdir_int */1,
                _0: _3
              }
            };
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Ptop_dir */1,
              _0: _2,
              _1: {
                TAG: /* Pdir_ident */2,
                _0: _3
              }
            };
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* Ptop_dir */1,
              _0: _2,
              _1: {
                TAG: /* Pdir_ident */2,
                _0: _3
              }
            };
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return {
              TAG: /* Ptop_dir */1,
              _0: _2,
              _1: {
                TAG: /* Pdir_bool */3,
                _0: false
              }
            };
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return {
              TAG: /* Ptop_dir */1,
              _0: _2,
              _1: {
                TAG: /* Pdir_bool */3,
                _0: true
              }
            };
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return /* Nonrecursive */0;
    }),
  (function (__caml_parser_env) {
      return /* Recursive */1;
    }),
  (function (__caml_parser_env) {
      return /* Recursive */1;
    }),
  (function (__caml_parser_env) {
      return /* Nonrecursive */0;
    }),
  (function (__caml_parser_env) {
      return /* Upto */0;
    }),
  (function (__caml_parser_env) {
      return /* Downto */1;
    }),
  (function (__caml_parser_env) {
      return /* Public */1;
    }),
  (function (__caml_parser_env) {
      return /* Private */0;
    }),
  (function (__caml_parser_env) {
      return /* Immutable */0;
    }),
  (function (__caml_parser_env) {
      return /* Mutable */1;
    }),
  (function (__caml_parser_env) {
      return /* Concrete */1;
    }),
  (function (__caml_parser_env) {
      return /* Virtual */0;
    }),
  (function (__caml_parser_env) {
      return [
              /* Public */1,
              /* Concrete */1
            ];
    }),
  (function (__caml_parser_env) {
      return [
              /* Private */0,
              /* Concrete */1
            ];
    }),
  (function (__caml_parser_env) {
      return [
              /* Public */1,
              /* Virtual */0
            ];
    }),
  (function (__caml_parser_env) {
      return [
              /* Private */0,
              /* Virtual */0
            ];
    }),
  (function (__caml_parser_env) {
      return [
              /* Private */0,
              /* Virtual */0
            ];
    }),
  (function (__caml_parser_env) {
      return /* Fresh */1;
    }),
  (function (__caml_parser_env) {
      return /* Override */0;
    }),
  (function (__caml_parser_env) {
      
    }),
  (function (__caml_parser_env) {
      
    }),
  (function (__caml_parser_env) {
      
    }),
  (function (__caml_parser_env) {
      
    }),
  (function (__caml_parser_env) {
      return "-";
    }),
  (function (__caml_parser_env) {
      return "-.";
    }),
  (function (__caml_parser_env) {
      return "+";
    }),
  (function (__caml_parser_env) {
      return "+.";
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return Stdlib__Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return "and";
    }),
  (function (__caml_parser_env) {
      return "as";
    }),
  (function (__caml_parser_env) {
      return "assert";
    }),
  (function (__caml_parser_env) {
      return "begin";
    }),
  (function (__caml_parser_env) {
      return "class";
    }),
  (function (__caml_parser_env) {
      return "constraint";
    }),
  (function (__caml_parser_env) {
      return "do";
    }),
  (function (__caml_parser_env) {
      return "done";
    }),
  (function (__caml_parser_env) {
      return "downto";
    }),
  (function (__caml_parser_env) {
      return "else";
    }),
  (function (__caml_parser_env) {
      return "end";
    }),
  (function (__caml_parser_env) {
      return "exception";
    }),
  (function (__caml_parser_env) {
      return "external";
    }),
  (function (__caml_parser_env) {
      return "false";
    }),
  (function (__caml_parser_env) {
      return "for";
    }),
  (function (__caml_parser_env) {
      return "fun";
    }),
  (function (__caml_parser_env) {
      return "function";
    }),
  (function (__caml_parser_env) {
      return "functor";
    }),
  (function (__caml_parser_env) {
      return "if";
    }),
  (function (__caml_parser_env) {
      return "in";
    }),
  (function (__caml_parser_env) {
      return "include";
    }),
  (function (__caml_parser_env) {
      return "inherit";
    }),
  (function (__caml_parser_env) {
      return "initializer";
    }),
  (function (__caml_parser_env) {
      return "lazy";
    }),
  (function (__caml_parser_env) {
      return "let";
    }),
  (function (__caml_parser_env) {
      return "match";
    }),
  (function (__caml_parser_env) {
      return "method";
    }),
  (function (__caml_parser_env) {
      return "module";
    }),
  (function (__caml_parser_env) {
      return "mutable";
    }),
  (function (__caml_parser_env) {
      return "new";
    }),
  (function (__caml_parser_env) {
      return "object";
    }),
  (function (__caml_parser_env) {
      return "of";
    }),
  (function (__caml_parser_env) {
      return "open";
    }),
  (function (__caml_parser_env) {
      return "or";
    }),
  (function (__caml_parser_env) {
      return "private";
    }),
  (function (__caml_parser_env) {
      return "rec";
    }),
  (function (__caml_parser_env) {
      return "sig";
    }),
  (function (__caml_parser_env) {
      return "struct";
    }),
  (function (__caml_parser_env) {
      return "then";
    }),
  (function (__caml_parser_env) {
      return "to";
    }),
  (function (__caml_parser_env) {
      return "true";
    }),
  (function (__caml_parser_env) {
      return "try";
    }),
  (function (__caml_parser_env) {
      return "type";
    }),
  (function (__caml_parser_env) {
      return "val";
    }),
  (function (__caml_parser_env) {
      return "virtual";
    }),
  (function (__caml_parser_env) {
      return "when";
    }),
  (function (__caml_parser_env) {
      return "while";
    }),
  (function (__caml_parser_env) {
      return "with";
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              txt: _1,
              loc: symbol_rloc(undefined)
            };
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              txt: _1 + ("." + _3.txt),
              loc: symbol_rloc(undefined)
            };
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return [
              _2,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return [
              _2,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return [
              _2,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      return /* [] */0;
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: _2
            };
    }),
  (function (__caml_parser_env) {
      return /* [] */0;
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              hd: _1,
              tl: _2
            };
    }),
  (function (__caml_parser_env) {
      return [
              undefined,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              undefined,
              {
                hd: _1,
                tl: _2
              }
            ];
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return [
              _2,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return [
              _2,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _3 = Stdlib__Parsing.peek_val(__caml_parser_env, 1);
      return [
              _2,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      const _1 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* PStr */0,
              _0: _1
            };
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* PTyp */1,
              _0: _2
            };
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* PPat */2,
              _0: _2,
              _1: undefined
            };
    }),
  (function (__caml_parser_env) {
      const _2 = Stdlib__Parsing.peek_val(__caml_parser_env, 2);
      const _4 = Stdlib__Parsing.peek_val(__caml_parser_env, 0);
      return {
              TAG: /* PPat */2,
              _0: _2,
              _1: _4
            };
    }),
  (function (__caml_parser_env) {
      throw new Caml_js_exceptions.MelangeError(Stdlib__Parsing.YYexit, {
                MEL_EXN_ID: Stdlib__Parsing.YYexit,
                _1: Stdlib__Parsing.peek_val(__caml_parser_env, 0)
              });
    }),
  (function (__caml_parser_env) {
      throw new Caml_js_exceptions.MelangeError(Stdlib__Parsing.YYexit, {
                MEL_EXN_ID: Stdlib__Parsing.YYexit,
                _1: Stdlib__Parsing.peek_val(__caml_parser_env, 0)
              });
    }),
  (function (__caml_parser_env) {
      throw new Caml_js_exceptions.MelangeError(Stdlib__Parsing.YYexit, {
                MEL_EXN_ID: Stdlib__Parsing.YYexit,
                _1: Stdlib__Parsing.peek_val(__caml_parser_env, 0)
              });
    }),
  (function (__caml_parser_env) {
      throw new Caml_js_exceptions.MelangeError(Stdlib__Parsing.YYexit, {
                MEL_EXN_ID: Stdlib__Parsing.YYexit,
                _1: Stdlib__Parsing.peek_val(__caml_parser_env, 0)
              });
    }),
  (function (__caml_parser_env) {
      throw new Caml_js_exceptions.MelangeError(Stdlib__Parsing.YYexit, {
                MEL_EXN_ID: Stdlib__Parsing.YYexit,
                _1: Stdlib__Parsing.peek_val(__caml_parser_env, 0)
              });
    }),
  (function (__caml_parser_env) {
      throw new Caml_js_exceptions.MelangeError(Stdlib__Parsing.YYexit, {
                MEL_EXN_ID: Stdlib__Parsing.YYexit,
                _1: Stdlib__Parsing.peek_val(__caml_parser_env, 0)
              });
    }),
  (function (__caml_parser_env) {
      throw new Caml_js_exceptions.MelangeError(Stdlib__Parsing.YYexit, {
                MEL_EXN_ID: Stdlib__Parsing.YYexit,
                _1: Stdlib__Parsing.peek_val(__caml_parser_env, 0)
              });
    })
];

const yytables = {
  actions: yyact,
  transl_const: yytransl_const,
  transl_block: yytransl_block,
  lhs: "\xff\xff\x01\0\x02\0\x03\0\x03\0\x03\0\n\0\n\0\x0e\0\x0e\0\x04\0\x10\0\x10\0\x11\0\x11\0\x11\0\x11\0\x11\0\x11\0\x11\0\x05\0\x06\0\x07\0\x14\0\x14\0\x15\0\x15\0\x17\0\x17\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\b\0\b\0\x1e\0\x1e\0\x1e\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0*\0-\0-\0-\0$\0%\0%\0.\0/\0\x16\0\x16\0\x16\0\x16\0\x16\0\x16\0\x16\0\x16\0\x16\0\x16\0\t\0\t\0\t\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\0'\x009\0<\0<\0<\x006\x007\x008\x008\0=\0>\0?\0?\0&\0(\0(\0A\0B\0E\0E\0E\0D\0D\0J\0J\0F\0F\0F\0F\0F\0F\0K\0K\0K\0K\0K\0K\0K\0K\0O\0P\0P\0P\0Q\0Q\0R\0R\0R\0R\0R\0R\0R\0S\0S\0T\0T\0T\0T\0U\0U\0U\0U\0U\0G\0G\0G\0G\0G\0^\0^\0^\0^\0^\0^\0a\0b\0b\0c\0c\0d\0d\0d\0d\0d\0d\0e\0e\0e\0g\0V\0:\0:\0h\0i\0)\0)\0j\0k\0\f\0\f\0\f\0H\0H\0H\0H\0H\0H\0H\0H\0p\0p\0m\0m\0l\0l\0n\0o\0o\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0L\0L\0\x84\0\x84\0\x85\0\x85\0\x85\0\x85\0\x86\0]\0]\0\x87\0\x87\0\x87\0\x87\0\x87\0\x1f\0\x1f\0\x8c\0\x8d\0\x89\0\x89\0\\\0\\\0\\\0u\0u\0\x8f\0\x8f\0v\0v\0v\0w\0w\0\x80\0\x80\0\x90\0\x90\0\x90\0\x91\0\x91\0\x83\0\x83\0\x81\0\x81\0Y\0Y\0Y\0Y\0Y\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0q\0q\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x92\0\x92\0\x92\0\x96\0\x96\0\x95\0\x95\0\x95\0\x95\0\x97\0\x97\x003\0\x98\0\x98\0 \0!\0!\0\x99\0\x9a\0\x9e\0\x9e\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9c\0\x9c\0\x9c\0\xa1\0\xa2\0\xa2\0\xa4\0\xa4\0\xa5\0\xa5\0\xa5\0\xa6\0\xa3\0\xa3\0\xa3\0\xa7\0I\0I\0\x9f\0\x9f\0\x9f\0\xa8\0\xa9\0#\0#\x005\0\xab\0\xab\0\xab\0\xab\0\xa0\0\xa0\0\xa0\0\xaf\0\xb0\0\"\x004\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb3\0\xb3\0\xb3\0\xb4\0\xb5\0\xb6\0\xb7\x001\x001\0\xb8\0\xb8\0\xb8\0\xb8\0\xb9\0\xb9\0\x8a\0\x8a\0Z\0Z\0\xb1\0\xb1\0\x12\0\x12\0\xba\0\xba\0\xbc\0\xbc\0\xbc\0\xbc\0\xbc\0\xbe\0\xbe\0\xae\0\xae\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\x1b\0\x1b\0\xc6\0\xc5\0\xc5\0\xc2\0\xc2\0\xc3\0\xc3\0\xc1\0\xc1\0\xc7\0\xc7\0\xc8\0\xc8\0\xc4\0\xc4\0\xbd\0\xbd\0_\0_\0M\0M\0\xc9\0\xc9\0\xad\0\xad\0\xc0\0\xc0\0\xc0\0\xca\0W\0\x7f\0\x7f\0\x7f\0\x7f\0\x7f\0\x7f\0\x7f\0\x93\0\x93\0\x93\0\x93\0\x93\0\x93\0\x93\0\x93\0\x93\0\x93\0\x93\0@\0@\0\x88\0\x88\0\x88\0\x88\0\x88\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xaa\0\xaa\0\xaa\0\xaa\0\xaa\0~\0~\0x\0x\0x\0x\0x\0}\0}\0\x94\0\x94\0\x19\0\x19\0\xbb\0\xbb\0\xbb\x000\x000\0`\0`\0N\0N\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0y\0\x8e\0\x8e\0\x9b\0\x9b\0z\0z\0[\0[\0X\0X\0C\0C\0f\0f\0f\0f\0f\0;\0;\0t\0t\0\x82\0\x82\0{\0{\0|\0|\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcd\0\xcd\0\x1c\0\xcf\0,\0\r\0\r\0\xac\0\xac\0s\0s\0s\0\x1d\0+\0\xce\0\xce\0\xce\0\xce\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
  len: "\x02\0\x02\0\x02\0\x02\0\x02\0\x01\0\x02\0\x01\0\0\0\x02\0\x01\0\x01\0\x03\0\x01\0\x02\0\x04\0\x03\0\x03\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x05\0\x01\0\x01\0\x02\0\x01\0\x01\0\x03\0\x03\0\x04\0\x04\0\x03\0\x04\0\x05\0\x05\0\x03\0\x03\0\x04\0\x06\0\b\0\x06\0\x05\0\x05\0\x04\0\x02\0\x01\0\x03\0\x01\0\0\0\x02\0\x02\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x02\0\x01\0\x03\0\x02\0\x04\0\x02\0\x04\0\x01\0\x02\0\x05\0\x04\0\x01\0\x03\0\x03\0\x04\0\x03\0\x04\0\x03\0\x03\0\x01\0\x02\0\0\0\x02\0\x02\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x02\0\x01\0\x04\0\x03\0\x02\0\x06\0\x03\0\x04\0\x05\0\x01\0\x02\0\x06\0\x05\0\0\0\x02\0\x05\0\x01\0\x02\0\x06\0\x06\0\x02\0\x04\0\x02\0\0\0\x03\0\x03\0\x02\0\x01\0\x02\0\x02\0\x03\0\x02\0\x01\0\x04\0\x01\0\x03\0\x03\0\x05\0\x05\0\x03\0\x03\0\x02\0\x03\0\x05\0\0\0\0\0\x02\0\x05\0\x03\0\x03\0\x03\0\x03\0\x02\0\x01\0\x02\0\0\0\x06\0\x05\0\x05\0\x06\0\x06\0\x06\0\x04\0\x07\0\n\0\x01\0\x06\0\x04\0\x05\0\x03\0\x04\0\x01\0\x03\0\x03\0\x02\0\x01\0\x02\0\x03\0\0\0\0\0\x02\0\x03\0\x03\0\x06\0\x03\0\x02\0\x01\0\x05\0\x05\0\x03\0\x03\0\x03\0\x01\0\x02\0\x07\0\x07\0\x01\0\x02\0\b\0\x07\0\x01\0\x02\0\x03\0\x05\0\x02\0\x05\0\x02\0\x04\0\x02\0\x02\0\x01\0\x01\0\x01\0\0\0\x02\0\x01\0\x03\0\x01\0\x01\0\x03\0\x01\0\x02\0\x03\0\x07\0\x07\0\x04\0\x04\0\x07\0\x06\0\x06\0\x05\0\x01\0\x02\0\x02\0\x07\0\x05\0\x06\0\n\0\x03\0\b\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x02\0\x02\0\x05\0\x07\0\x07\0\x07\0\x03\0\x03\0\x03\0\x04\0\x04\0\x02\0\x01\0\x01\0\x01\0\x01\0\x03\0\x03\0\x04\0\x03\0\x04\0\x04\0\x03\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x03\0\x03\0\x05\0\x05\0\x04\0\x04\0\x02\0\x06\0\x06\0\x04\0\x04\0\x06\0\x06\0\x02\0\x02\0\x03\0\x04\0\x04\0\x02\0\x06\0\x06\0\x03\0\x03\0\x04\0\x06\0\x05\0\b\0\x07\0\x01\0\x01\0\x02\0\x01\0\x01\0\x02\0\x02\0\x02\0\x02\0\x01\0\x01\0\x02\0\x02\0\x07\0\b\0\x03\0\x05\0\x01\0\x02\0\x05\0\x03\0\x01\0\x03\0\x02\0\x02\0\x05\0\x01\0\x03\0\x03\0\x05\0\x02\0\x02\0\x05\0\x03\0\x03\0\x03\0\x01\0\x01\0\x03\0\x02\0\x03\0\x01\0\x03\0\x05\0\x01\0\x03\0\x02\0\x04\0\x02\0\x02\0\x02\0\x01\0\x03\0\x03\0\x01\0\x02\0\x02\0\x03\0\x03\0\b\0\b\0\x03\0\x03\0\x02\0\x02\0\x02\0\x01\0\x01\0\x01\0\x01\0\x03\0\x01\0\x01\0\x02\0\x03\0\x03\0\x04\0\x04\0\x04\0\x02\0\x04\0\x03\0\x03\0\x05\0\x05\0\x04\0\x04\0\x06\0\x06\0\x01\0\x03\0\x03\0\x03\0\x01\0\x03\0\x01\0\x02\0\x04\0\x03\0\x03\0\x01\0\x05\0\x01\0\x02\0\x07\0\x01\0\x02\0\x07\0\x06\0\x03\0\0\0\0\0\x02\0\x03\0\x02\0\x03\0\x02\0\x05\0\x05\0\x04\0\x07\0\0\0\x01\0\x03\0\x02\0\x01\0\x03\0\x02\0\x01\0\0\0\x01\0\x03\0\x02\0\0\0\x01\0\x01\0\x02\0\x01\0\x03\0\x01\0\x01\0\x02\0\x03\0\x04\0\x01\0\x06\0\x05\0\0\0\x02\0\x04\0\x02\0\x01\0\x01\0\x02\0\x05\0\x07\0\b\0\b\0\x01\0\x01\0\x01\0\x01\0\x02\0\x02\0\x01\0\x01\0\x02\0\x03\0\x04\0\x04\0\x05\0\x01\0\x03\0\x06\0\x05\0\x04\0\x04\0\x01\0\x02\0\x02\0\x03\0\x01\0\x03\0\x01\0\x03\0\x01\0\x02\0\x01\0\x04\0\x01\0\x06\0\x04\0\x05\0\x03\0\x01\0\x03\0\x01\0\x03\0\x02\0\x01\0\x01\0\x02\0\x04\0\x03\0\x02\0\x02\0\x03\0\x05\0\x03\0\x04\0\x05\0\x04\0\x02\0\x04\0\x06\0\x04\0\x01\0\x01\0\x03\0\x04\0\x01\0\x03\0\x01\0\x03\0\x01\0\x01\0\x05\0\x02\0\x01\0\0\0\x01\0\x03\0\x01\0\x02\0\x01\0\x03\0\x01\0\x03\0\x01\0\x03\0\x01\0\x03\0\x01\0\x03\0\x03\0\x02\0\x01\0\x04\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x01\0\x01\0\x01\0\x03\0\x03\0\x02\0\x03\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x02\0\x01\0\x01\0\x01\0\x01\0\x03\0\x01\0\x02\0\x02\0\x01\0\x01\0\x01\0\x03\0\x01\0\x03\0\x01\0\x03\0\x01\0\x03\0\x04\0\x01\0\x03\0\x01\0\x03\0\x01\0\x03\0\x02\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x02\0\0\0\x01\0\0\0\x01\0\x01\0\x01\0\0\0\x01\0\0\0\x01\0\0\0\x01\0\0\0\x01\0\x01\0\x02\0\x02\0\0\0\x01\0\0\0\x01\0\0\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x03\0\x04\0\x04\0\x04\0\0\0\x02\0\0\0\x02\0\0\0\x02\0\x03\0\x04\0\x04\0\x01\0\x02\0\x02\0\x04\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0",
  defred: "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0<\x02\0\0\0\0\0\0u\x02>\x02\0\0\0\0\0\0\0\0\0\0;\x02?\x02@\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa5\x02\xa6\x02\0\0A\x02\0\0\0\0\0\0\xa7\x02\xa8\x02\0\0\0\0=\x02v\x02\0\0\0\0{\x02\0\0\xed\x02\0\0\0\0\0\0\0\0\0\0B\x012\0\0\x007\0\0\x009\0:\0;\0\0\0=\0>\0\0\0\0\0A\0\0\0C\0I\0\xd2\x01w\0\0\0\xc7\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\x01\x14\x01p\x02S\x01\xab\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xee\x02\0\0[\0\0\0b\0c\0\0\0\0\0h\0\0\0Z\0]\0^\0_\0`\0\0\0d\0\0\0p\0\xc3\0\x05\0\0\0\xef\x02\0\0\0\0\0\0\x07\0\0\0\r\0\0\0\xf0\x02\0\0\0\0\0\0\n\0\x0b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0}\x02\t\x02\xf1\x02\0\0\x1a\x02\n\x02\xfb\x01\0\0\0\0\xff\x01\0\0\0\0\xf2\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0O\x02\0\0\0\0\0\0\0\0\x86\x01\xf3\x02\0\0\0\0\x9b\x01u\x01\0\0\0\0B\x02\x84\x01\x85\x01\0\0\0\0\0\0\0\0\0\0\0\0N\x02M\x02\x8d\x02\0\x004\x01\x15\x01\x16\x01\0\0\0\0\x99\x02\0\0m\x02n\x02\0\0o\x02k\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x000\0\0\0\0\0\0\0\0\0\0\0\0\0f\x01\0\x008\x01:\x02\0\0\0\0s\x02\0\0\0\0,\x01\0\0\xab\x02\xac\x02\xad\x02\xae\x02\xaf\x02\xb0\x02\xb1\x02\xb2\x02\xb3\x02\xb4\x02\xb5\x02\xb6\x02\xb7\x02\xb8\x02\xb9\x02\xba\x02\xbb\x02\xbc\x02\xbd\x02\xbe\x02\xbf\x02\xc0\x02\xc1\x02\xc2\x02\xc3\x02\xa9\x02\xc4\x02\xc5\x02\xc6\x02\xc7\x02\xc8\x02\xc9\x02\xca\x02\xcb\x02\xcc\x02\xcd\x02\xce\x02\xcf\x02\xd0\x02\xd1\x02\xd2\x02\xd3\x02\xd4\x02\xd5\x02\xaa\x02\xd6\x02\xd7\x02\xd8\x02\xd9\x02\xda\x02\0\0\0\0\0\0\0\0\0\0\0\0R\x02g\x02f\x02\0\0e\x02\0\0h\x02a\x02c\x02U\x02V\x02W\x02X\x02Y\x02b\x02\0\0\0\0\0\0d\x02j\x02\0\0\0\0i\x02\0\0t\x02Z\x02`\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa0\x02\0\x003\x014\0\0\0\x91\x02\0\0\0\0\x01\0\0\0\0\0\0\0\0\x005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x12\x01\0\0\0\0T\x01\0\0\xac\x01\0\0J\0\0\0x\0\0\0\xc8\0B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0C\x01F\x01\0\0\0\0\0\0\x07\x01\b\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0U\0M\0\x80\x02\0\0\0\0\0\0X\0\0\0\0\0\x02\0g\0Y\0\0\0q\0\0\0\xc4\0\0\0\x03\0\x04\0\x06\0\t\0\x0e\0\0\0\0\0\0\0\x13\0\0\0\x12\0\0\0y\x02\0\0#\x02\0\0\0\0\xa2\x02\0\0\x16\x02\0\x008\x02\x0e\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\b\x02\x84\x02\0\0\x0f\x02\x14\0\xfc\x01\0\0\0\0\0\0\0\0\0\0\0\0\x0b\x02\x15\0\x82\x01\0\0\x81\x01\x89\x01\x8a\x01w\x02\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01\0\0[\x02\0\0\0\0_\x02\0\0\0\0]\x02T\x02\0\0D\x02C\x02E\x02F\x02G\x02I\x02H\x02J\x02K\x02L\x02\x8b\x01\0\0\0\0\0\0\0\0\x16\0\x83\x01\0\0y\x01z\x01\0\0\0\0\0\0\0\0\0\0\xe5\x02\0\0\0\0\x1a\x01\0\0\0\0\0\0\0\0l\x02\0\0\0\0\0\0\0\0^\x02\0\0\\\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd5\0\0\0\0\0\0\0\x1c\0\0\0\0\0\0\0\0\0\0\0D\0/\0\0\0\0\0\0\0\0\0'\x01&\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe9\x02\0\0\0\0\0\0\0\0\x8f\x02\0\0\0\0S\x02\0\0\x18\x01\0\0\0\0\x17\x01\0\0Q\x02P\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x005\x01\0\0\0\0\x94\0\0\0\0\0\0\0\xc9\x01\xc8\x01\0\0\xbc\x01\0\0\0\0\0\x001\0\xe1\x02\0\0\0\0\0\0\0\0\0\0|\x02q\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xcd\0\0\0\0\0\0\0\0\0\0\0\xe1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0K\x01I\x01;\x01\0\0H\x01D\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0j\0V\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8b\x02\x88\x02\x87\x02\x8c\x02\0\0\x89\x02\x11\0\0\0\x10\0\f\0\"\x02\0\0 \x02\0\0%\x02\x12\x02\0\0\0\0\0\0\0\0\r\x02\0\x007\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0z\x02~\x02\0\0\0\0\0\x002\x02\0\0\x10\x02\0\0\0\0\x8d\x01\x8c\x01\0\0\0\0\0\0\0\0\0\0\0\0\x94\x01\0\0\x93\x01w\x01v\x01\x80\x01\0\0|\x01\0\0\x9e\x01\0\0\0\0\x88\x01\0\0\xe6\x02\xe3\x02\0\0\0\0\0\0\x1d\x01\x1b\x01\x19\x01\0\0\0\0\0\0\xcb\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd6\x014\x02\0\0\0\0\0\0\xd4\0\0\0\xd6\0\0\0\xd7\0\xd1\0\xdc\0\0\0\xcf\0\0\0\xd3\0\0\0\0\0\0\0\xe5\0\0\0\0\0\\\x01\0\0\x17\0\x19\0\x1a\0\0\0\0\0\x1b\0\0\0'\0\0\0&\0\x1f\0\x1e\0\"\0\0\0\0\0e\x01\0\0h\x01\0\0\0\x007\x016\x01\0\x000\x01/\x01+\x01*\x01\xdc\x02\0\0\0\0\xe7\x02\xe8\x02\0\0\0\0\0\0\0\0\0\0=\x01s\x01\0\0t\x01\0\0\x1c\x01\xdf\x02\0\0\0\0\0\0\0\0\0\0\0\0G\0H\0\0\0\x11\x01\x10\x01\0\0i\0\0\0\xbf\x01\0\0\0\0\0\0\0\0\xc2\x01\xbe\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0V\x01\0\0\0\0\0\0\0\0\0\0W\x01N\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\0S\0\0\0O\0N\0\0\0\0\0\0\0\xed\x01\0\0\x81\x02\0\0\0\0\0\0\0\0\0\0n\0\0\0\0\0\0\0\0\0\0\0\x0f\0\0\0\x13\x02&\x02\0\0\0\0\0\0\x17\x02\x15\x02\0\0\0\0\0\0\xf9\x016\x02\0\0\x19\x02\0\0\0\0\0\0\f\x02\0\0\0\0\x85\x02\0\0\x7f\x02\xfe\x01\0\0x\x02\0\0\0\0\xa4\x01\0\0\x8f\x01\x8e\x01\x92\x01\x90\x01\0\0\0\0\x98\x01\x97\x01\0\0\xdd\x02\0\0\0\0\0\0\0\0\0\0\x7f\0\0\0\xc6\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd4\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01a\x01\0\0\0\0\0\0\0\0\0\0\0\0.\0\0\0\0\0(\0\0\0#\0!\0\0\0\0\0\0\0\0\0U\x01\0\0?\x01\0\0\0\0\0\0K\0\0\0v\0\0\0\0\0\x91\0\0\0\0\0\0\0\0\0\0\0\0\0\x9c\0\x95\0\xe9\0\0\0\0\0\xbd\x01\0\0\xb0\x01\0\0\xc1\x01\0\0\xde\x02)\x01(\x01\0\0\0\0\0\0\0\0\x1f\x01\x1e\x01Q\x01\0\0\0\0Y\x01\0\0Z\x01\0\0\0\0\xb0\x01L\0\0\0\0\0\0\0%\x01#\x01\0\0!\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xc4\x01\0\0\0\0o\0m\0\0\0\0\0\xa7\x01\0\0\0\0!\x02(\x02\0\0\x14\x02*\x02\0\0\0\0\0\0\0\x009\x02\0\0\0\0\x1c\x02\0\0\x11\x02\0\x003\x02\xa4\x02\xa3\x01\0\0\0\0\x96\x01\x95\x01$\x01\"\x01 \x01\0\0\xcc\x01\xca\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xae\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x87\0\0\0\0\0\0\0\x89\0y\0}\0\0\0\xd7\x015\x02\xd3\x01\0\0\0\0\x93\x02\x92\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd2\0\0\0^\x01\0\0]\x01\0\0\0\0,\0\0\0-\0\0\0%\0$\0\0\0\xec\x02\0\0\0\0\0\0>\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x9b\0\0\0\xc0\x01\0\0\xb6\x01\0\0\0\0\0\0\0\0\0\0\0\0\xcd\x01\xce\x01\0\0\0\0\x95\x02\0\0\xef\0:\x019\x012\x011\x01.\x01-\x01\0\0\0\0\0\0\0\0\0\0X\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xee\x01r\0\0\0\0\0s\0\0\0\0\0$\x02\x18\x02+\x02\xfa\x01\xf6\x01\0\0\0\0\0\0\0\0\x9a\x01\x99\x01\0\0\x82\x02\xb2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb6\0\0\0\0\0\0\0\xb1\0\0\0\0\0\0\0\0\0\x83\0\0\0\0\0\0\0\0\0\x86\0\0\0\xa9\x01\xaa\x01\0\0\xe6\0\0\0\xd9\0\xd0\0\xce\0\0\0\0\0\0\0\0\0\x18\0\0\0)\0+\0\xe2\0\xe3\0\0\0\x92\0\0\0\x99\0\0\0\x9a\0\0\0\0\0\0\0\x98\0\x97\x02\0\0\0\0\0\0\x97\0\0\0\0\0\0\0\0\0\0\0\xcf\x01\0\0\0\0\xad\x01\0\0\0\0\0\0\xe0\x01\xe1\x01\xe2\x01\xe3\x01A\x01\0\0M\x01\0\0\0\0\0\0R\x01\xae\x01z\0\0\0\0\0\0\0\0\0\xc5\0\0\0\0\0\xc5\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe6\x01\xe7\x01\0\0)\x02\0\0\x1f\x02\0\0\xc9\0\0\0\0\0\0\0\0\0\0\0\xb0\0\xaf\0\0\0\0\0\0\0\0\0\xac\0/\x02\0\0\0\0\x81\0\0\0\x8f\0\0\0\x8e\0\x8b\0\x8a\0\0\0\0\0b\x01_\x01\0\0\xf2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb9\x01\0\0\0\0\0\0\xd9\x01\0\0\xd0\x01\0\0\xaf\x01\0\0\0\0\0\0\xde\x01\xe4\x01\xe5\x01@\x01\0\0\0\0[\x01\xca\0\xf0\x01\xf4\x01\xb0\x01l\0\0\0\xdf\x01\xe8\x01\xc6\0\0\0~\x01}\x01\x83\x02\xad\0\0\0\xb4\0\0\0\0\0\0\0\0\0\0\0\xbd\0\xb7\0\xaa\0\0\0\0\0\x88\0\0\0\0\0*\0\x9d\0\x96\0\0\0\0\0\0\0\xa5\0\0\0\0\0\0\0\0\0\xd1\x01\0\0\0\0\0\0\xb7\x01\xdb\x01\0\0\0\0\0\0\0\0\xe9\x01\0\0O\x01\0\0\xab\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xbc\0\0\0\x8d\0\x8c\0\xf0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa1\0\0\0\0\0\0\0\0\0\0\0\xea\x01\xeb\x01P\x01\xbb\0\xb8\0\x9d\x02\x9e\x02\0\0\0\0\0\0\0\0\xb9\0\xa9\0\xa3\0\xa4\0\0\0\0\0\0\0\0\0\xa2\0\xba\x01\0\0\xec\x01\0\0\0\0\0\0\0\0\0\0\xa6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xba\0\0\0\0\0\0\0\xdd\x01\xa7\0",
  dgoto: "\b\x008\0e\0{\0\x83\0\x95\0\x9f\0\xad\x007\x02f\0|\0\x84\0:\0Q\x01\x7f\0;\0\x87\0\x88\0\xc1\x01\xe9\x01N\x02\x16\x03\x93\x01 \x02\xd7\0<\0=\0\xbf\x02n\x01>\0?\0\xa1\0A\0B\0C\0D\0E\0F\0G\0H\0I\0J\0K\0L\0M\0O\x02N\0u\x01\x95\x01x\x03n\0o\0p\0O\0r\0s\0t\0u\0v\0H\x01\xa2\x02w\0\xa1\x01B\x03\x96\x01P\0w\x01\xc7\0\n\x02\xbb\x03Y\x04L\x04\r\x03\xef\x02\xdf\x04Z\x04\x83\x01\xc2\x01[\x04R\x02S\x02J\x03\xf1\x03U\x05\x8c\x04\x89\x04\x85\x04Q\0_\x05b\x03\xb9\x05\x96\x04c\x03\xa7\x04M\x04N\x04O\x04\xd5\x04\xd6\x04>\x05\x86\x05\xaf\x05\xab\x05e\x05x\0\xa3\x01R\0y\x01\xc7\x03j\x04\xc8\x03\xc6\x03\x05\x03\xb1\0S\0\"\x01\xb7\x01\x10\x03\x0e\x03T\0U\0V\0f\x04W\0X\0\xde\0Y\0Z\0\xdf\0\xe8\x000\x02\xe5\0\x85\x01\x86\x01\x8f\x02\x7f\x02[\0d\x03\xba\x05\xb6\0\\\0q\x01=\x02\x11\x03\xe0\0\xe1\0\xb7\0\xb8\0\x98\0\xdb\x01\xde\x01\xdc\x01c\x04]\0s\x01M\x01Y\x02\xf7\x03\x9b\x04\x97\x04`\x05Z\x02N\x03[\x02S\x03\x1d\x04\xf1\x02\xb8\x03\x98\x04\x99\x04\x9a\x04\x0f\x02\x03\x02\xf4\x02P\x04a\x05b\x05\x92\x03\x12\x05.\x05\x13\x05\x14\x05\x15\x05\x16\x05y\x03*\x05\x99\0\x9a\0\x9b\0\x9c\0\x9d\0\x9e\0\xbd\x01\xb1\x02\xb2\x02\xb3\x02-\x044\x045\x04\x8b\x03*\x04\xf7\x02\xbe\x01?\x01\x1d\x01\x1e\x018\x02R\x01",
  sindex: "\x14\b\xd9>\x9d\x06p,\x05,k\x0f\x90@\x96D\0\0\x84\x04l\x02WF\x84\x04\0\0\xca\x01e\0\x11\x01\0\0\0\0\x84\x04\x84\x04\x84\x04\x84\x04\x19\x03\0\0\0\0\0\0\x84\x04\x96FR\xff1?\x8b?\xdb:\xdb:\x1d\x05\0\0\xb87\xdb:\x84\x04\0\0\0\0\xe8\x04\0\0\x84\x04\x84\x04\x8e\xff\0\0\0\0WF\xd9>\0\0\0\0\x84\x04\xb9\xff\0\0\x84\x04\0\0(\x01/\0\x9b\x0b\x18\0\xd9G\0\0\0\0\xf6\x02\0\x008\0\0\0\0\0\0\0\xde\x01\0\0\0\0\"\x027\x02\0\0/\0\0\0\0\0\0\0\0\x000\x02\0\0\xd9E\x9b\0WFWF\x90@\x90@\0\0\0\0\0\0\0\0\0\0\xca\x01e\0\x18\x04B\x05\x9d\x06\xb9\xff\x11\x01\0\0\x88\x03\0\x008\0\0\0\0\x007\x02/\0\0\0\x9d\x06\0\0\0\0\0\0\0\0\0\0\x87\x02\0\0\x9e\x02\0\0\0\0\0\0l\x02\0\0<\x02`\x02/\0\0\0\xe3\x02\0\0\xe4,\0\0R\x04/\0R\x04\0\0\0\0\x0b\t\xd5\x02\xac\xff\x87\x04\n\x03\x85Ik\x0f\x8c\x03l\x02\xf3\x02\0\0\0\0\0\0L\0\0\0\0\0\0\0\xd4\x01\x13\0\0\0\x90\x03\xb6\x02\0\0+\x05\xf6\x02\x96D\x96E\x18\x03\x87C\xcdC\0\0\x90;f\x03\xb7\x03\x1c\x03\0\0\0\0J\0$\x04\0\0\0\0\x96D\x96D\0\0\0\0\0\0U\x04\x98\x04\xdb:\xdb:S\x04WF\0\0\0\0\0\0(8\0\0\0\0\0\0\xe2?\xcf\x03\0\0~\x04\0\0\0\0X\x04\0\0\0\0O\x02\x98G\xbd\x04\x96D\xc7B\xd5\x02\x90@\x95\x04o\x02\xd9>[\x05$\x04\0\0WF\0\0\xd9\x04\x0e\x01\xe5\x04\x91\xff\0\0\x93\x04\0\0\0\0\xea\x04\xa1\x04\0\0\x95H\xbe\x04\0\0\xbe\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x10\x05\x80>\x80>\x84\x04\x8e\xff\xd5\x04\0\0\0\0\0\0WF\0\0\xe1\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb3\0\0\0\0\0\0\0\0\0\0\0WF\0\0\0\0\0\0)\0v\xff\x80>\x90@\xcc\x04l\x02\xc1\x02\xf3\x02\b\x05\0\0\xe2\x04\0\0\0\0\x90@\0\0\xb9\x04\x90@\0\0\xdb:\x9b\x0b/\0\x84\x04\0\0W\x05\t\x06\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\0\0\x96D\x90@\0\0\xb9\x04\0\0\xfa\x04\0\0\xcf\x03\0\0\xcf\x03\0\0\0\0\x90@\x1f\x04WFWF6\x05;\x05WF6\x05\x18Fb\x01\0\0\0\0\x90@b\x01b\x01\0\0\0\0~\x04\x98\x01\x95\x04\x18\x04\x02\x05\x9d\x06\0\0;\x02\0\0\0\0\0\0\xad\x02\x1b\x05J\x03\0\0\xb9\x04\x80\x05\0\0\0\0\0\x003\x05\0\0\xcf\x03\0\0B\x06\0\0\0\0\0\0\0\0\0\0R\x04/\0R\x04\0\0R\x04\0\0I\f\0\0\x19\x04\0\0M\x05\xa5\x05\0\0I\f\0\0I\f\0\0\0\0\xab\x05\x97\x05]\x05k\x0f;\x03S\x04\x1d\x01{\x05\xba\x05\0\0\0\0\xb6\x05\0\0\0\0\0\0=\x03`\x05x\x05k\x0f_\x07\xf3\x02\0\0\0\0\0\0T=\0\0\0\0\0\0\0\0\xbf\x05\xbb\x05@\0z\x05\xf9\x03}\x05\0\0}\x05\0\0\x86\x05f\x03\0\0\x87\xff\xb7\x03\0\0\0\0\x81\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0,\x02\x94=\xd4=\x14>\0\0\0\0\x8b\x05\0\0\0\0\x96D\xc0\x02\x80>S\x04S\x04\0\0b\x01\xd0\x04\0\0\xf5\x02~\x04*\x04\xad\x05\0\0\x03't\x01\x03'S\x04\0\0\xec\x05\0\0k\x0f+\x03\x96E\x01<d\x02D\x05d\x05GB\0\0\x96D\x95\x05\x0e\x05\0\0\x0b\x01\x90@\x8b\x01\xa7\x03\xd6\x03\0\0\0\0b\x01|\x06\x18\x03\x90@\0\0\0\0\x18\x03\x90@;\x05\xc7\x03\x90@\xbb\xffz\xff\xdb:k\x0f\x96D\0\0\xa4\x05\xa6\x05\x94\x05\x84\x04\0\0\x96D\xc3\x05\0\0v\x01\0\0\x98\x0b\xd6\f\0\0\xaa\x05\0\0\0\0\xa8\x05\x96\x05\xc1\x02\xf1\x05\x18\x04\x19\x03\xc1\x02/\0\0\0\x96D5\x04\0\0l\x03\x9c\x05*\x04\0\0\0\0b\x03\0\0\xef\0\xfe\x05\x80>\0\0\0\0\x96F;\x05\x90@\x90@\x988\0\0\0\0\x86I\x86IQI\x1a\x07\x95HQI\x8f\f\x8f\f\x8f\f\x8f\f\xa5\x02\xe5\x05\xe5\x05\x8f\f\xa5\x02\xa5\x02QI\xe5\x05\xa5\x02\xa5\x02\xa5\x02\0\0\xe5\x05\x0f\x05/\0>A\x06\x06\0\0\xd5\x05\xc1\x02~\x04~\x04\x95H\x90@\x90@\x90@\xd9\x05b\x01b\x01\0\0\0\0\0\0\x01\x06\0\0\0\0QI\xdd\x05\x13\x05\x8f\xff\xc9\x05H\x04\xfe\x03\0\0\0\0m\x03\x14\x06\x18\x04\xe2\x04\xd8\x02/\0b\x03k\x0f\x18\x06~\x04\0\0\0\0\0\0\0\0\x11\x06\0\0\0\0R\x04\0\0\0\0\0\0\xda\0\0\0)\x06\0\0\0\0I\f\xbf\0\x19\x01\x1d\x10\0\0\xec\x01\0\0\xe2\x05\xda\x05\xc4\x05k\x0f/\x03k\x0fk\x0fu\x03\0\0\0\0\xbb\x01l\x02\xf2\x05\0\0\xd7\x05\0\0\x81\x03\x96D\0\0\0\0 \x03\x96D \0?\x03\x04\x06\"\x01\0\0\x9c\r\0\0\0\0\0\0\0\0\xaa\x02\0\x004\x06\0\0`\xff`\xff\0\0\xe9\x05\0\0\0\0\x90@\x90@\x90@\0\0\0\0\0\0\x07\x06\xbb\0\xf0\x05\0\0\xc4A\x85I\x03\x06\0\0\xb6\x02\xe8\x05\xf4\x05\xef\x05S\x04\0\0\0\0/\0\xc2\x01\x90@\0\0\x0f\x06\0\0\x96D\0\0\0\0\0\0\x17\x06\0\0\x17\x06\0\0r<\x90@GB\0\0\x1d\0Q\x06\0\0\x90@\0\0\0\0\0\0L\x06\x19\x03\0\0iG\0\0\x18\x04\0\0\0\0\0\0\0\0\xfd\0\0\0\0\0\x95H\0\0\x95HA\x06\0\0\0\0\x95H\0\0\0\0\0\0\0\0\0\0S\x04y\xff\0\0\0\0\xc1\x02\xe2\x04/\0\x90@\x94\xff\0\0\0\0\x10\x02\0\0S\x04\0\0\0\0\xd5\x02/\0\x18\x04/\0+\x01p\x05\0\0\0\x005\x02\0\0\0\0+\x02\0\0\x83\x05\0\x008\x01C\x06\x05\x06l\x02\0\0\0\0\x90@\x0b\x06S\0\xa1\x04\xbe\x04\xbe\x04\xb3\0\xa6\xff\x90@\0\0$\x0b\x90@\xe3<\x81AD\x06\0\0\0\0k\x0fC\x06/\0!\x06$\x06\xf9G\x03\x05E\0\xae\xff\x90@Y\x06\x18\x04\0\0\0\0\x19\x03\0\0\0\0\xfc\x05\xc2\x04i\x06\0\0\0\0\0\0\x18\x04$\x02l\x03v\x02c\x06\0\0\x1a\x06s\x05\x18\x048\x06\xe2\xff\0\0I\f\0\0\0\0k\x0f@\x01t\x06\0\0\0\0l\x02+\0S\x04\0\0\0\0k\x0f\0\0\x0e\x06S\x04\xf3\x02\0\0\xf2\x055\x06\0\0\x13\x06\0\0\0\0_\x07\0\0\xf9\x03&\x06\0\0\xf9\x03\0\0\0\0\0\0\0\0\x96D;\x03\0\0\0\0\xcd\xff\0\x007H\xb6\0\xd9\xffj\x06*\x04\0\0l\x02\0\0a\n\x9c\x04/\0\xc4A^\x01\x8d.\x03'/\0\0\0%\x06\x07\0(\x06\xcb\x03r\x06r\x06\x80\x06/\x06O\x06\0\0\0\0\x90@\x90@\x96DWH\x18\x04p\x05\0\0\x9c\xff\x9d\xff\0\0\xa0\xff\0\0\0\0\x90@\x90@l\x06\x18\x05\0\0\xb5H\0\x001\x06k\x0f\x96D\0\0$\x02\0\0\x19\x03k\x0f\0\0k\x0f\x8e\xff\x90@\x8e\xffu\xff/\0\0\0\0\0\0\0\x96D*\x04\0\0\xe3F\0\0<\x06\0\0\x82\x06\0\0\0\0\0\x003\x04\xeb\0>\x05U\x02\0\0\0\0\0\0Z\x06T\x01\0\0d\x06\0\0\x90@\xa3\x02\0\0\0\0\xc4A\x81\x06g\x06\0\0\0\0h\x06\0\0m\x06\x95Ha\n$\x02p\x05\x98\x06\x90\0*\x04\x96\x03\0\0\xfe\x03;\x02\0\0\0\0\x18\x04<\x06\0\0;\x02\x9f\x06\0\0\0\0.\x02\0\0\0\0A\x01\0\0k\x0fl\x02\0\0\xf2\x05\x18\x03\0\0\xac\x06\0\0k\x0f\0\0\0\0\0\0%\x04Z\0\0\0\0\0\0\0\0\0\0\0\f\x03\0\0\0\0r\x0e\xa8\x06\x85Iv\x06\x8d.z\x06\0\0\xa1\x06S\x04x\x06\0\0]\x06*\x03\xb6\x02\x07Ck\x0f\x9c\x04\b\x05\0\0P\x04S\x04\x18F\0\0\0\0\0\0/\x03\0\0\0\0\0\0%\x06/\0\0\0\0\0\x90@GBk\x0f\x90@`\x06e\x06k\x0f\0\0k\x06\0\0}\x06\0\0\x90@%\xff\0\0O\xff\0\0n\x06\0\0\0\0\x95H\0\0\x90@\x90@\x90@\0\0S\x04Q\x06p\x05;\xff\xff\x02/\0\x9c\x04/\0\0\x03/\0\x85\x06\x87\x06/\0\0\0Q\x06\0\0e\0\0\0\xdb0\"G\0\0o\x03\x8e\x06\xc0\x06\0\0\0\0\x98\x01\x01\x02\0\0%\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa9\xffZ\x06\xb3\x06k\x0fw\x06\0\0\x90@\x01\x02/\0\f\x03\x90@\x90@\x90@/\0`\x05`\x05\x95\x01\0\0\xbd\x06\xbb\x06\0\0\0\0\xde\x02y\x01\0\0a\nk\x0f\0\0\0\0\0\0\0\0\0\0\xc1\x06\x0e\x06\xf2\x05\x14>\0\0\0\0k\x0f\0\0\0\0s\x05\x99\x03W\x01\x90\x03\x8d.\x9f\x01k\x0f\x89\x04\0\0\x91\x06\xcf\x06\x9c\x04\0\0a\n\x03'\xb3\x03\x87B\0\0a\x01\xdf\xff\x90\x04\x9c\x04\0\0\x18F\0\0\0\0\xca\x06\0\0S\x04\0\0\0\0\0\0S\x04GB\x90@\x95H\0\0;\x03\0\0\0\0\0\0\0\0\x13I\0\0k\x0f\0\0\xc3\x01\0\0q\x06<\x06;\x05\0\0\0\0;\x05{\x06;\x05\0\0\x98\x01S\x04\xc0\x06\xc0\x01\x85\x06\0\0S\x04k\x0f\0\0e\0^\x02 \x02\0\0\0\0\0\0\0\0\0\0\x84\x06\0\0k\x0f\x92\x03\x81A\0\0\0\0\0\0s\x05\x95H\x95H\x95H\0\0\xf0\x03\xf0\x03\0\0k\x0f\x86\x06k\x0fv\x02e\0\x98\x01G\x02\0\0\0\0/\0\0\0k\x0f\0\0\x1f\x01\0\0\xce\x03\xd0\x03\x9c\x06/\x03W\0\0\0\0\0m\x01a\n\x8d.S\x04\0\0\0\0\0\0\x9c\x04\0\0\xf3\x02\0\0a\n\0\0\0\0\0\0S\x04\x90@\0\0\0\0\x8a\x06\0\0S\x04\xab\x06/\0;\x05;\x05\x07B\xe2\x06;\x05\f\x05S\x04\0\0\xcf\0;\x05\x94\x06\0\0\x85\x06\0\0\xdd\x03\0\0\x7f\x02t\x01S\x04\0\0\0\0\0\0\0\0\xe5\x03\x90@\0\0\0\0\0\0\0\0\0\0\0\0\x98\x01\0\0\0\0\0\0S\x04\0\0\0\0\0\0\0\0a\n\0\0k\x0f\f\x03:\x04\xba\x02/\0\0\0\0\0\0\0\xb2\x06S\x04\0\0l\0\xec\x06\0\0\0\0\0\0\xf4\x06\xf5\x06\xbdF\0\0k\x0f\xf8\x06\x90@\xef\x06\0\0\x85\x06\xc0\x06\xf9\x06\0\0\0\0k\x0ft\x01S\x04S\x04\0\0\x90@\0\0\xfa\x06\0\0/\0s\x05\xaa\x06\xb5\x06;\x05\xcf\x03\x85\x06\x0f\x07/\0\0\0a\n\0\0\0\0\0\0\x1d\x10\x1d\x10Z\x06S\x04\x06\x07\xac\x01S\x04k\x0f\0\0\x90@\xc5\x06\x1d\x10S\x04S\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15\x07;\x05;\x05k\x0f\0\0\0\0\0\0\0\0\x11\x07\x90@k\x0fS\x04\0\0\0\0S\x04\0\0\x1d\x10\x1c\x07\x1e\x07S\x04k\x0f\0\0S\x04\xcd\x06/\0k\x0fk\x0f\x04\x04S\x04\0\0S\x04S\x04\x90@\0\0\0\0",
  rindex: "\0\0/\b0\b\xd0\x06\0\0\0\0\0\0\0\0\0\0\xd5F\0\0\0\x009@\0\0s\x03\0\0\0\0\0\0\0\0\xd6DGC\x10D\xe7@\0\0\0\0\0\0\0\0\xd5F\0\0\0\0\0\0\0\0\0\0\0\0PD\xea\x10\0\0\0\0\xe7@\0\0\0\0\0\0\0\0\xf7\x03\xed\x01\xc2\x06\0\0\0\0\0\0G\0\0\0\0\0\xe7@\xd4\x03\0\0\xe7@\0\0\0\0\xe2\tG\0f\x11\x9a&\0\0\0\0@6\0\0g6\0\0\0\0\0\0\x936\0\0\0\0\xc06\xd66\0\0\xdf6\0\0\0\0\0\0\0\0\0\0\0\0\xfb\x16s\x17\x0e\x16\x84\x16\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\x03\0\0\0\0\0\0n\0\xd4\x03\0\0\0\0\0\0\0\0y\x0e\0\0\0\0?1\xb51\0\0n\0\0\0\0\0\0\0\0\0\0\0\xf02\0\0Y3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd1\x06\0\0\xd0\x06\0\0\0\0\0\0\0\0\x7f\x04\0\0\0\0\0\0\0\0<\r<\r\0\0\n'\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0%\x0f\0\0\xed'R(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0V-\0\0\0\0\xa4\x02 \x06\0\0\0\0\0\0\x95\x06\xc8-\0\0\0\0\x039\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\x03\0\0\xfc\x06\0\0\0\0\0\0\0\0\0\0\xf84\0\0\0\0\0\0\0\0\x16E\0\0\0\0\0\0\xc5\x04\xdf6\xf3\x05\0\0\0\0`\x01\x9b\x04\0\0\xc9\xff\0\0\0\0[\0\0\0\0\0\0\0\x82\x04\0\0^\0\xfe\0\0\0\\\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0C7\xd7\x06\xd7\x06\xc7\x06\"\x04VE\0\0\0\0\0\0\x97\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0u9\xcd9\0\0\0\0\0\0%:}:\0\0\x99\0\0\0\0\0\0\0\0\0\0\0\xd7\x06\0\0\0\0\0\0\0\0\0\0[\x06\0\0\0\0\0\0\0\0\0\0\0\0\xf8\x02\0\0\0\0\0\0G\0\xf7/PD\0\0@6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xca\x1f\0\0\0\0\0\0\0\0\0\x002\x03\0\0\0\0\0\0s\x03\0\0s\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\x11\xa9\x14\0\0\0\0\0\0\xe9\x17_\x18\0\0\0\0\xfc\x06\x8a\n\0\0\0\0\0\0\xd6\x04\xca\x07\xb51\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf8\x02\0\0\0\0\0\0\0\0\0\0\0\0s\x03\0\0o\x07\0\0\0\0\0\0\0\0\0\0\0\0\x7f\x04\0\0\0\0\0\0\0\0\0\0\0\0G\x01\0\x000\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x1b\x07\0\0\0\0\x90\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xca\xff\0\0\x96\0\xa8\0\xfe\0\0\0\\\x05\0\0\0\0\xc9\0\0\0\0\0\xca\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd7\x06\x039\x95+\0\0\xd7\x18\0\0\0\0\0\0\xfc\x06\xe4\x06\0\0\0\0\0\0\0\0\0\0\xac\x0b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0M\x19\0\0\0\0\0\0\0\0\0\0\x0f\x01\0\0\xa9\x04\0\0\xa1\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xc7\x06\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13'\0\0\0\0\0\0\xdf6\0\0\0\0\0\0\0\0z4\0\0/\x04\0\0\0\0\0\0\0\0\0\0\0\0\xd7\x06\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x85\"\xf4\"P\t\x7f\x05\xcf\x0f^#@ \xb7 .!\xa4!\x02\x1d\xc3\x19:\x1a\x1b\"x\x1d\xef\x1d\xc8#\xb0\x1af\x1e\xdc\x1eS\x1f\0\0'\x1b\0\0F5\xaf\x04i\x05\0\0\0\0\0\0\xfc\x06\xfc\x06Z\x10\0\0\0\0\0\0W\x12!\x15\x98\x15\0\0\0\0\0\0\xce\x12\0\0\0\x002$\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb51\0\0\0\0\0\0\xfc\x06\0\0\0\0\0\0\0\0\x11\f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x036\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x1d\x07\0\0\0\0\0\0\x99\xff\0\0\xb7(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83)\0\0\x1e)\0\0\0\0\0\0\0\0\0\0\x1c\x01\xa1\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\x04\0\0\t\n\0\0\xc6\x03+\b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0.0z0\0\0\0\0\0\0\xcb5\0\0\0\0z4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x9e\x1b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\x01\0\0\xdb\xff\0\0\xa9\0\0\0\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\0\0\xe0\x06\xe5\x06\0\0\0\0\0\0\0\0F5\0\0\0\0\0\0\0\x005\x01\0\0\xb9\x01\0\0\0\0\x16E\x0e6\0\0z4\0\0\x904\0\0\0\0\0\0\0\0\0\0\xdb\x04\0\0\x16E\0\0\0\0\xcd1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x04\xfe\0\\\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0v2\x0e6\0\0\0\0\0\0\xf3H\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa1\x02\x80\x03\0\0\xf3\n\0\0\0\0D\r\xb51\0\0\0\0\0\0\0\0\xb51\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x1b\x02\0\0\0\0\0\0\0\0\0\0\x99\x01\0\0\0\0\xe8)\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\0,\x01\0\0\xf6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\x06\0\0\0\0\0\0\0\0\0\0\x0e6\0\0\0\0\0\0\0\0\xdf6\0\0\0\0\0\0\0\0\xc7\x01\xea\x06\xea\x06\xd7\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0}'\0\0\xf7\x06\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe03\0\0\0\0\0\0\0\0\0\0\xf5\x04\0\0,\xff\xe7\x04:\b\0\0\0\0\0\0\0\0/\x04\0\0\x18\x07\0\0\b\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0D\x13\0\0\0\0\xbc\x13\0\x003\x14\x97$\0\0\xff1!+r\x04\0\0\xe4\x06\0\0\0\0\0\0\xe9\r\0\0\0\0\0\0\b\x02\0\0\xe9\r\0\0\0\0\0\0G\x01\0\0\0\0\0\0A;\0\0\0\0\0\0O*\0\0\0\0\xac\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0E/\0\0\xd8\x05\0\0\0\0\x80/\0\0\xc0\b\0\0\0\0\x01\x07\0\0\x8b0\0\0\0\0\0\0[\x06\0\0\0\0\\5\x14.\0\0\0\0\0\0\xe70\0\0\0\0\0\0\x124z4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb5\0\0\0\0\0\0\0\0\0\0\0\xdb\x01\x14\x1c\xbd4\0\0\0\0:\b\0\0:\b\x0e\x07:\b\x12\x07\x12\x07:\b\0\0\x8b\x1c\0\0\0\0\0\0\0\0 \x07\x9d.\xb12\0\0\xec2\0\0\0\0\x831M4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0:\x07\0\0\0\0\0\0\0\0\0\0M4\x0e6\0\0\0\0\0\0\0\0\xe9\r\0\0\0\0\0\x004\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb4*\0\0\0\0\0\0\0\0\0\0\0\0M4\0\0\0\0\r\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0O.\0\0\0\0\0\0\0\0\xf2\x01\0\0\0\0\0\0\t\x02\0\0\0\0\xfc$\0\0\0\0\0\0\0\0\0\0\0\0V\x01\0\0\0\0\0\x006\x02\0\0\x13\x07\x0e\x07\0\0\0\0\0\0\0\0%\x07\0\0\0\0\x831'3j3\xf3\x01\x12\x07\0\0:2\0\0\0\0\0\0\xef4\xdf6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0M4f%\xcb%0&\0\0P\f\xdd\f\0\0\0\0&A\0\0\0\0\0\0D\x07\xb51\0\0\0\0\xe9\r\0\0\0\0\0\0\xfa\x03\0\0\0\0\0\0\0\x0051\0\0\0\0\0\0\xe3\x04\0\0\0\0r5\0\0\0\0\xbb/\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd8.\0\0\0\0\0\0\0\0\0\0\t\x05\0\0:\b\0\0\0\0\0\0\0\0\0\0\0\0:2\0\0\0\0\0\0\0\0\0\0E\x02\0\0\0\0\0\0\xef4\0\0\xd73\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0D\x07\0\0\0\0\0\0\xbe\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0&\x07\0\0\xe3\t\0\0\0\0\0\0\0\0\x13/\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x12\x07\xa53\0\0\0\0\0\0\0\0\0\0\xd73\xc15\0\0\0\0\0\0,\x0e\0\0\xe3\t\xe3\t-\x072\x07\0\x008\x07\x12\x07\0\0\xe3\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x000\x03\0\0\0\0/\x05\0\0\0\0\0\0\0\0\0\0\xef*\xc15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb4\x05\0\0\0\0\x9b\x02\0\0\0\0\0\0\0\0\xb8\x05\0\0\0\0i\x04\xff\x06\xe3\t\0\0\0\0\0\0\x9f\x04\0\0\xe1\x06\xd3\b\0\0\0\0\0\0",
  gindex: "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\\\0\xf3\xff\0\0V\0\xfd\xff\xe8\x06\xff\x07>\0\0\0\xcc\xff\x87\0?\0[\xff\0\0\x94\xfe\0\x07G\xff\xd2\x07\xa3\x0e\xf3\xfc\x11\0\x16\x04\x0e\x001\x004\0B\0\0\0\0\0\0\0\0\0K\0X\0\0\0a\0\0\0\x02\0\x04\0^\xfe\0\0\0\0S\xfe\0\0\0\0\0\0\0\0c\0\0\0\0\0\0\0\0\0\0\0\xee\xfe\xa0\xfc\0\0\0\0\0\0\x06\0\0\0\0\0\xa4\xff\xcf\xfe\x88\xfe\x12\xfcr\xfcH\xffg\x04\xa8\x03\0\x000\x048\xfds\xff7\x04\0\0\0\0\0\0\0\0\0\0\0\0\x10\x03\xf7\xff\xcc\xfb\xc9\xfe$\xfe\x81\xfc9\x03\x8b\xfb\x1d\xfc\n\xfcZ\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8c\x05\xcd\x04\xa8\x04\0\0\0\0g\xff\x1e\0\xe7\0\x8c\xff\x05\x02\t\xfd]\xff\xbe\b1\x0b\0\0\0\0\0\0j\xff\xfb\x06\x8e\f>\x06\x01\0V\xffI\x06\x86\xfe\0\0\"\x07p\x06\xd6\x0b\xbd\xfcX\xfd\xd4\xfe\0\0\0\0\0\0\xdc\x04L\x04\0\0\0\0\xa6\x06w\xff\xdc\x05\n\b\0\0O\x04\0\0\0\0P\bI\x02P\x05-\xfc\xb8\xfb\xf4\xfc\xd2\xfd\0\0\x0f\xfe\0\0\0\0\xea\xff\0\0\0\0\xeb\xfb\xf9\xff\xf0\xfbi\xfe\xfe\xfd\"\xfe\0\0\0\0\xf7\x02\0\0\0\0\xfc\x03\xa0\xfb\0\0\xaa\x03\x9a\x04\0\0s\xfd\x03\f~\xff\0\0\t\0C\xfe\n\x06\x88\xff\xd7\xfe\x82\xff\0\0\xfd\x03\0\0\0\0\0\0\xee\x06\0\0\0\0\0\0\x1a\x005\xff\0\0",
  tablesize: 19189,
  table: "~\0\x85\0\x8c\x01\xa0\0l\0\xc8\x01m\0E\x02\xcd\0\x93\x02\xd5\x01\xb5\x01\xfb\x02\xc3\x01\xda\x01;\x02\xbf\0\xb4\x01\x91\x03\xc0\x02\xe4\0\xd1\x01\xcc\x03\xb9\x01\xf0\x02\x1a\x02\xbb\0\xb5\x02\"\x02\xbb\0\t\x04\"\x04\xea\0>\x01\xf4\x01\x97\x02\xbb\0\xbb\0\xbb\0\xbb\0M\x03\xc1\0\xe1\x03\xbd\x03\xbb\0\x93\x03\xf5\x02\x1f\x02\xfc\x02\x19\x05@\0\xbb\0@\0@\0g\0\xbb\0\x1b\x02\xac\x04\xdd\0\x1f\x01\xbb\0\xbb\x002\x02@\x013\x02\x80\0\x86\0\x81\x02h\0\xbb\0\xae\x003\0\xbb\0T\x01\xf9\x01\t\x05\xc9\x01i\0I\x01\xf6\x02\xad\x01\xf6\x02\xaf\x01\xd7\x049\x02\x9a\x01\x03\x05\x05\x05\x8d\x01}\0j\0\x95\x020\x059\0\x1c\x02\xce\x04\xf3\x04\x9f\x01@\0k\0l\0q\0m\0\xe1\x04\xb9\0\b\x02\xe6\x02\xe7\x02U\x01\x9f\x02W\0\xf7\x01l\0\x84\x01m\0\x88\x01\x89\x01H\x02F\x02\xe2\0\xfd\x02\x9d\x04,\x03@\x02G\x01\xf5\x01\xb9\0\xab\x01\xa4\x01\xf6\x01\f\x05\xbc\x01-\x03\xf2\x04\x9f\x02?\x02\xf7\x01\xb2\x04\r\x05\xf8\x01\x96\0J\x01\xb8\x02q\x03\xb9\x02+\x02\xb3\x01\xe3\0\xe0\x03G\x01g\0\xc5\x01\xfc\x04\x1b\x02\x9a\x02\xf9\x04t\x04v\x04\x9f\x02<\x04x\x04\xa4\x02g\0\xb9\0h\0\xbc\x04\x02\x04\xca\x01@\x03\x17\x05\x1b\x02\xa4\x02E\x03i\0\x14\x04\xf4\x04h\0U\x01j\x05@\0\xb6\x01U\x01\x06\x04U\x01P\x02i\0j\0*\x03\xb9\0>\x01\x80\0\xfa\x01\xac\x01\x07\x02\x86\0k\0\x86\0q\0j\0u\x04w\x04k\x01\xa6\x01 \x05\x02\x02=\x04w\x05k\0\x1d\x02q\0\xb9\0\0\x02\x01\x02\xbd\0G\x02\xee\x02\xaa\x01\x14\x04\x04\x02j\x019\x05\xbd\0\xbd\0H\x05C\x03\xd3\x01g\x03\xb9\0\xdd\x01\xdd\x01\x8b\x02\x8a\x04&\x02\x1f\x02\xbd\0A\x05\xdb\x03I\x05,\x02r\x03\xbc\0\xfc\x01\xfd\x01\xc4\0\f\x05M\x05\xd7\x02\\\x05'\x02\x1b\x02\xd0\0\xd1\0\xd2\0\xd3\0)\x04\xa4\x02y\x04h\x05\xda\0\x92\x01\x9a\x02\xa5\x01\x03\x04@\0L\x01\0\x05\xb8\x01\x92\x01\x92\x01A\x01\x15\x04\x14\x02\xb9\0\x81\x02E\x01F\x01\xbd\x02\x9a\x02\x9a\x05\xcd\x01\x92\x01+\x03\x85\x02K\x01\x86\x02h\x05N\x01d\x04\xa7\x03\xf5\x01\xb9\0\xa7\0\xce\0\xf6\x01k\x01\xa6\x01O\x01A\x02k\x01\xa6\x01\xf7\x01>\x04V\x01\xf8\x011\x05\xbb\0#\x02}\x03\xd4\x02\xe5\x02\xd5\x02B\x02j\x01A\x04C\x02r\x01j\x01\xbe\x02I\x02J\x05\xd0\x02/\x04\xd2\x05\xcd\x02\xc1\0\x12\x04\xa6\x023\0U\x02K\x02\x88\x05\\\x02\xca\x02B\x05\xf5\x01@\0@\0e\x02\xf6\x01\xfc\x03h\x03i\x03\xa0\x05\x89\x05I\x01\xf7\x01\xc9\x04g\x01\xf8\x01\xce\x01n\x01^\x02\xb9\x003\0\xa5\x01\xc0\x03\xbb\0\xa0\x05\xa5\x01\xcd\x03n\x01|\x02]\x02 \x03\xb2\x05\x82\x02W\0\xeb\x02\xe9\x04@\0e\x04P\x01\xc8\0\x85\x03\xad\x02\x90\x02\xaf\x02\xcc\x05\xb0\x02\x18\x03\0\x03\xd0\x04\xa8\x03\xd3\x04W\x05\x1b\x02U\x01\xc9\0\x99\x02\f\x05\xf0\x020\x04W\0D\x02\xc0\x02^\x05\xe0\x04\xb9\0\x8c\x03\xb9\0\xce\x03\xdc\x03U\x03l\0D\x03m\0\xa1\x01[\x02\x18\x05T\x02\xb9\0\x8c\x02\x8d\x02\xd1\x02\xa8\x05\x91\x02\xa5\x05\x84\x01\xc3\x04\x13\x04\x9c\x023\0\xfb\x01\xca\0\x9f\x01l\x01o\x01\xb4\x04\x1e\x02\x87\x01~\x02\xd7\x03\xfd\x03\x87\x05\x9f\x01?\x02o\x01m\x01\x12\x04\x7f\x05g\x01\xb3\x01\xca\x04\x8b\x05n\x01\x1e\x02\x1d\x02n\x01\xb3\x01\x1d\x02\xb3\x01\x02\x02\xf0\x02g\0\x8f\x04\x88\x03a\x03^\x02\\\x02t\x05\xb3\x05\xb5\x03l\x01\x1d\x02P\x03\xcb\0\xca\x01h\0\xcc\0\xe5\x03\xd4\0\x90\x04\xcb\x02o\x05m\x01U\x01i\0U\x01\xc8\0U\x01_\x04`\x04\x88\x03\x8d\x03\xfa\x01k\x03Q\x05\x1b\x02\x86\0j\0\x86\0\xa1\x04\x86\0\xc9\0\xfa\x01 \0\xa6\x05\x18\x03k\0\xa1\x01q\0\xd5\0\xa0\x01[\x02O\x05T\x02\xfa\x011\x04R\x04\xd8\x03\xa3\x02\xc0\x02\xa0\x01R\x04\xf6\x02\xd0\x04\x18\x04\x99\x05\x9f\x01:\x02o\x01\x9f\x01l\x01o\x01\x1e\x02\xfa\x01\xfa\x01i\x01 \x04\xca\0\x02\x02\x02\x02@\x04\xcb\x02m\x01\xcb\x02&\x04\xb6\x03\x82\x03\xd6\0\xa2\x01\x8e\x03\x1d\x02z\x05\x02\x02\x88\x036\0\xcf\x05\x05\x02\xfa\x01&\x03\xc0\x02\xc0\x02^\x02\\\x02\xf0\x02\xa3\x02\x10\x05\xf7\x01\xc1\x02\xac\x03@\x002\x05&\x02\xc8\0\xde\x02\xe0\x02\xe2\x02\x89\x03\x9a\x03\xbc\x03\xcb\0\xda\x01\xe3\x02\xcc\0$\x02\xb9\0\x9b\x03\x9c\x03\xc9\0]\x04k\x03\xe7\x03\n\0\x88\x03\xa2\x04\xf4\x03Q\x03\xbb\0\x1e\x02.\x03\xe2\x02p\x01&\x02\xa7\0\xce\0\xa0\x01\x17\x03\x9d\x05\xa0\x01\xe4\0\x1b\x02R\x04\x0f\x03\xa3\x02\xd9\x03\xd2\x03R\x03w\x02[\x03\xb9\0X\x03Y\x03s\x04d\x01\xca\0d\x01\xc1\x02\xa8\x04\xe2\x02i\x01\xd1\x01\xb9\0x\x02\xc1\x02\x80\x01\x81\x01\xc1\x02\x1b\x020\x03O\x02\x8f\x03\x05\x02\xa2\x01\x87\x03w\x02~\x02\xc2\x02\xdd\0{\x05\x80\x05,\x05\xad\x03)\x027\x03O\x02l\x03m\x03\xc8\0\xa3\x02x\x02\x1a\x03R\x04\xbf\x05@\0\xfa\x01G\x03\xcb\0\x11\0\xc0\x04\xcc\0p\x01\xad\x04\xc9\0\xf5\x03\x1b\x03\xfe\x02q\x05\x81\x05s\x05+\x04\xc1\x04\x9a\x02\x01\x040\x02{\x03\x89\x01\xe2\x02\f\x02\xb5\x03\x9c\x02a\x03!\x001\x02\xf8\x02\xfe\x03\xff\x03\0\x040\x04\xc1\x02%\0\xbc\x01\x82\x058\x05\xf9\x02\xbb\x04$\x02\xb9\0\x19\x04\xca\0/\x03w\x02^\x04G\x05\xb3\x01w\x02\xd4\x05O\x02O\x02\x80\x01\x81\x01T\x05\x1b\x02:\x03<\x03\xe3\x03x\x02$\x02\xb9\0\xa0\x03x\x02\x9e\x03O\x02O\x02r\x01O\x028\x03]\x05\xf3\x03\x86\x04C\x05\x88\x04\x8b\x04\xc2\x03\x83\x05U\x013\0t\x01\xdd\x006\0O\x02\xcb\0\xb2\x03\xb3\x03\xcc\0\x0e\x02\xcb\x01\x1c\x03\x86\0\xe4\x020\x02\xfa\x010\x02\xfa\x01\xda\0\xfa\x01\xfa\x01'\x05q\x011\x02\xc0\x021\x02:\x04\x94\x02\xc3\x03\xcc\x01\xfc\x02:\x05\xe4\x02R\x04\x94\x02\xba\x01\xbc\x03\xb9\0\xb9\0\xe4\x020\x04\xcb\x03(\x04\x02\x026\x04\xde\0\xa3\x03\xca\x01\x94\x02\x94\x02\xa6\x032\x04\x0e\x05R\x04\xcc\x01\x94\x02\x91\x03r\x01\x9c\x04\x9f\x03\xe4\x02\xe4\x02R\x04\xf6\x02\xfa\x01\xe2\x034\x03\x1b\x02\xdb\0v\x01\x94\x02\xdd\0\x10\x05\x94\x02\xe4\x02\x83\x03\xdb\x02\xe3\0\x82\x04\xe4\x02\xbf\x04&\x02\xe4\x02\x93\x03\xe4\x02\x94\x02\x9e\0\xda\0\xc5\0\xf5\x01x\x01q\x01\xc6\0\xf6\x01\xea\x03\xe2\x02\xca\x01\xfa\x01\xc5\x03\xe8\x03\xf7\x01P\x01\xc0\x02\xf8\x01\x98\x03\x9e\0\x94\x02\xca\x01\xef\x03\xca\x01\xf0\x03,\x05\x9e\0\xfa\x03\xde\0\xb9\0\x9c\x02&\x02\xbc\x03\xf9\x03\xfa\x01\x04\x04\xeb\x03\xec\x03\x07\x04\f\x02\xe4\x02\x94\x02\xaf\x03\x1e\x04\x94\x02\xa5\x04P\x01\x9e\0\x9e\0\xb9\0!\0\xdb\0\r\x02\x93\x02\f\x02\xa7\0\xce\0{\x01%\0\xb9\0\xed\x03\x9e\0\x94\x02\x1b\x02c\x05\x94\x02\xb9\0g\x05\x9e\0\x9e\0\xe2\x02\x9e\0\xb9\0P\x01Q\0\xd8\x02R\x04R\x04\x9f\x02\xf5\x01\x96\x02\xb8\x04\x9d\x01\xf6\x01\xa0\x01P\x01R\x04\f\x02\x9c\x02\xd9\x02\xf7\x01\xb3\x01\xd4\0\xf8\x01\xca\x01\xe9\x03.\x04$\x02\xb9\0\x9a\x02\x9f\x05\xde\x04\xee\x03\xc5\x04\xa5\x01C\x04\x0e\x02\xa2\x01\xda\x01\x02\x02\x89\x01\x02\x03\x03\x03\x9e\0\x89\x01\xca\x018\x04 \0\x89\x01\xbd\0\x89\x01\x0e\x02\x9a\x02\xd5\0\x89\x01\x89\x01\xfa\x01\xc7\x04\x89\x01\xfa\x01\xa1\x02\xf7\x01\x1b\x02\x83\x02\xf8\x01D\x04\xab\x04\x89\x01\xca\x01R\x04\xa6\x01\x9d\x02\xb9\0\x98\x05\x9d\x01\xb5\x018\x04\xd1\x01o\x04p\x04\r\0\xb4\x01\x1b\x02L\x02\x0e\x02\xa2\x05b\x01c\x01\x04\x03\x9a\x03\xfa\x01\xd6\0{\x04\xd0\x05\xd1\x05\xbe\0M\x02\xb6\x016\0\x12\0!\x02\xda\x02\xc3\x01&\x02\xa3\x02:\x03\xb9\0\x89\x01\x9c\x02\x87\x04;\x04X\x04\x0b\x04\xb9\0\x89\x01\xcc\x01\x0e\0\x18\0\x19\0\x1a\0R\x04\xec\x02\x9c\x02\xb1\x01\xe2\x02o\x01h\x01\xe3\0\xe2\x02\xc7\x01\xe2\x05\x0f\0\x10\0\x89\x01\x89\x01\x1e\x02\x89\x01\x89\x01\xac\x05\xaa\x04\xa9\0\xc3\x05\xc4\x05m\x01\x17\0*\0\x0f\x03\xed\x02\xc3\x01,\x02&\x02\x7f\x01\xb7\x04#\x02\xaa\0\x89\x01\xbf\x01\xd0\x01\xfa\x04\x97\0\xca\x01\xb0\0p\x01,\x02!\0\xb9\0\x0f\x03S\x01\x97\x05\x93\0\xde\x042\0%\0\x9c\x02&\x02\xd9\x05\xad\x05\xd9\0)\0\xf5\x01\xf7\x01\x9c\x02\x0f\x03\xf6\x01\xc6\x01-\0\xc4\x04\x9c\x02\x7f\x03\xbb\x01\xf7\x01\x02\x02\xd4\0\xf8\x01+\x05\xa9\x03\xdd\x04\xe1\x05\xb9\0\xf7\x01\xcb\x04\x1b\x02\xff\x02\x80\x03 \0\xaa\x03\xf7\x01\xf7\x01\xfa\x01\xcc\x04\xd1\x04\xeb\x05,\x025\0\x81\0\x9a\x02\xc7\x01 \0\x1b\x02,\x02\x9f\x02\xd8\x01\xfe\x04\xd5\0H\x04\xb1\x01\xda\x04\xf7\x01\xf7\x01\xd8\x016\0\xe8\x04a\x03\xa0\x02\xeb\x04\xbb\x01\xc7\x01\x80\x04\xe4\x04,\x02\xcc\x01\xf7\x01\xb9\0\x83\x04\xb1\x01\x84\x04\xff\x04\xbb\x01\xf7\x01\xf7\x01\x94\x01\xf7\x01\x84\x01\xf6\x04\xf7\x04\x93\0\xbd\0\x95\x04\xc6\x02\xe0\x02Q\0\xd6\0\xfb\x01\x1b\x02\x9c\x02\xea\x01X\x046\x006\0\x07\x05\n\x05\x93\0\xa1\x02Q\0\xc7\x016\0\xa4\x03\xca\x01\x99\x03&\x02\xca\x01\xca\x01\x11\x05\xeb\x01\xec\x01\xed\x01Q\0Q\0Q\0Q\0\x93\0\x97\0a\x03\xf7\x01\xc7\x01O\x03\x97\0\x97\0\xca\x01\x1d\x03\x1d\x05Q\0\x92\x01\x98\x02\xc7\x02n\x05\xbd\x007\x05P\x01\x9a\x03\xb9\0\xee\x01\x98\x02-\x05\x9d\x03X\x04\xb0\0\xb0\0\x8a\x05\xb0\0\xb0\0Q\0\xb0\0\x1b\x02Q\0\x1e\x03\xa2\x03Q\0Q\0Q\0\x9d\x01'\x03\xb0\0\xb0\0\x9d\x01Q\0\x9c\x02\xc4\x01\x9d\x01\xf5\x01\x9d\x01\x93\0Q\0\xf6\x01\x9d\x01\xb9\0\xef\x01\xb6\x04\x9d\x01h\x04\xf7\x01\xcc\x01z\x03\xf8\x01Q\0\xda\x04Q\0\x9d\x01Q\0Q\0e\x02\xcb\x02\xb0\0\xb0\0\xf0\x01\xf1\x01\xf2\x01\xd9\0(\x03P\x05Q\0\xea\x04e\x02Q\0\xe4\x04\xee\x04D\x05Q\0\xcf\x01X\x05\x9e\x05\xd4\0Y\x05\xca\x01[\x05\xf5\x01\x9d\x01\xca\x01\xa3\x05\xf6\x01\x9d\x01\x84\x01\xf3\x016\0\x9e\x035\x05\xf7\x01f\x05X\x04\xf8\x01\x9d\x01\xe4\x04\xb9\0|\x05\x9d\x01\xcc\x04 \0\x7f\x01X\x04\x90\x02\x90\x02\x7f\x01\xd5\0\xca\x01\b\x05\x7f\x01\x90\x02\x7f\x01\x02\x02\xea\x05\xb9\0\x7f\x01\xc7\x02\x9d\x01\x9d\x01u\x05\x9d\x01\x9d\x01\xb9\0\xf5\x01\x90\x02\xd2\x01\xca\x01\xf6\x01\x7f\x01\x1b\x05\x90\x02\xda\x04\xcc\x01\x9f\x04\xf7\x01H\x03\x1f\x03\xc8\x04\xe4\x02\x9d\x01\xfb\x01\x8e\x01\xb9\0\xc7\x02\xd6\0\x93\0\x84\x05\xc6\0\x85\x05\x90\x02\x90\x026\0\xfa\x01\xb9\0t\x03v\x03\xd9\0\x8c\x05\xca\x01\x90\x05\x91\x05I\x03\xcb\x05\x95\x05\xe4\x04o\x01 \0\x88\x02\x9b\x05\x89\x02\xa0\x04\xbd\0\x8f\x01;\x05\xb9\0\x7f\x01\xe4\x04\x0e\0\xd8\x01\x8a\x02u\x03\x90\x01\xca\x01\x9f\x02\xe4\x02\xfe\x01\xb9\0\xf8\x01\xb4\x02\xa4\x05w\x03\x02\x02\x0f\0\x10\0\x7f\x01\x7f\x01W\x02\x7f\x01\x7f\x01\xca\x01X\x04\x9f\x02\xe3\x04\x02\x02\xae\x05\x17\0\xf8\x01\x91\x01\xca\x01\xf1\0X\x02S\x05\xa3\x02\xf8\x01\xf8\x01\xb0\0\x7f\x01\x92\x01{\x02<\x05\xca\x01\xc7\x01\xe0\x02{\x026\0!\0K\x05\x9f\x02S\x01\xbd\x05\xa9\x05d\x05\xb9\0%\0\xf8\x01\xf8\x01\xe4\x04\xe0\x02\xe0\x02)\0\xba\x01\xc7\x01\xc5\x05m\x05\xca\x05=\x05-\0\x94\x01\xf8\x01\xa3\x02\xe0\x02\xa4\x02L\x05\xbb\x01\xaa\x05\xf8\x01\xf8\x01\xff\x01\xf8\x01\x02\x02\x02\x02\x84\x01\x82\0z\0\t\x02\x84\x01\x0b\x02\xda\x04y\x05\xd6\x05\xe0\x02S\x04\x84\x01\xe0\x025\0\x84\x01\xdb\x05\xdc\x05\xe0\x023\0\x97\0\xb9\0\xe3\0\xca\x01\xe0\x02\x13\x02\xca\x01\x97\0\xa4\x02\x97\0\xdf\x05\xe0\x02\xca\x01\x02\x02T\x04\x97\0W\0\x1e\x02 \0\xba\0\xf8\x01\x90\0S\x01\xc6\x01U\x043\0\xe2\x02\xe0\x02\xe0\x02\xb3\0\x97\0\x97\0\xca\x01\xec\x05\x81\x04\x02\x02\xb0\0\xe2\x02V\x04\xe0\x02\xca\x01(\x02W\0\xca\x01\x84\x01\x1d\0-\x02\x90\0\xca\x01\x02\x02\x8e\x04\xca\x01\xca\x01V\x02\xe2\x02\xb3\0r\x02r\x02*\x02W\x02/\x02\x11\x04\x1c\x04.\x02\xe8\x02\x84\x04\xe9\x02\xc2\0W\x026\0\xb0\0\xb0\0\xb0\0X\x02r\x02\xd8\x01\xea\x02\xf5\x01\xb0\0\x87\x01\x9f\x02\xf6\x01X\x02\xb8\x05B\x02\xbb\x05\xc2\0C\x02\xf7\x011\x02\x8a\x01\xf8\x01\x97\0\xc2\0\x97\0\xc1\x054\x02\x96\x05\x9f\x02\x97\0\\\x03\xb0\0\xb0\0\x9f\x02\xfb\x01\xa0\0\xb0\0\x9f\x02\xb0\0\x9f\x02<\x02\x9f\x02\x9f\x02\x9f\x02\xc2\0\xc2\0\xd9\0J\x02\xb8\x05\xb8\x05\xa3\x046\0}\x04>\x02\xa0\0\xd5\x05:\x02\x9f\x02\xc2\0B\x01\xa4\x04\xa0\0Q\x02\x97\0\xb0\0\xc2\0\xc2\0w\x02\xc2\x006\0\xb9\0\xb0\0\xdd\x05\x1e\x02C\x01D\x01\x97\0\x97\0o\x01\xe0\x05\xa3\x02p\x03\xa0\0\xa0\0\xb9\0\xb8\x05\x94\x01\xd9\0\x9f\x02\xe5\x05\xa3\x02\xb0\0 \x01\x84\x02\xe8\x05\xe9\x05\xa0\0\x85\x01\x13\x03!\x01\x98\x02\x85\x01\xba\0\xa0\0\xa0\0\"\x03\xa0\0\x8e\x02\x85\x01$\x03\xc2\0\x85\x01\xe3\0\x14\x03\x15\x03\xf1\0\xf1\0\xf1\0\xf1\0\xf2\x03\x85\x01\x06\x03\x07\x03\xf1\0\xf1\0\xf1\0\x9e\x02\xb6\x01\xf1\0\xf1\0\xa4\x02\xf1\0\xf1\0\xf1\0\xf1\0\xf1\0\xf1\0x\x01\xb0\0\xf1\0\xf1\0\xf1\0\xf1\0\xf1\0\xf1\0$\x02\xb9\0P\x01\xa0\0\x98\x01\xa5\x02\xf1\0\xf1\0\x06\x03\t\x03\xf1\0\xf1\0\xf1\0\xf1\0\xb6\x02\x85\x01\xb7\x02\xf1\0\xf1\0C\x01\x99\x01$\x02\xb9\0\x9f\0\x94\x01\xb9\0P\x01\xc0\0\xba\x02\x97\0\xbb\x02\xf1\0\xf1\0\xbc\x02\xf1\0\b\x03\n\x03\xf1\0\xf1\0\xf1\0\xc3\x02\xf1\0\x9f\0\xc4\x02\xf1\0\xf1\0\xc0\0\xc5\x02\x97\0\x9f\0\x93\0\x97\0\xf1\0\xc0\0\xf1\0\xc9\x02\xce\x02\xcf\x02\x97\0\xb5\0\x97\0\x97\0\xd2\x02\xf1\0\xf1\0\xd3\x02\xf1\0\xf1\0\xf1\0\xf1\0\x9f\0\x9f\0\xb0\0\xd6\x02\xc0\0\xf1\0\xb0\0\xf1\0\xb5\0?\x02\xf1\0\xf2\x02\x97\0\xf1\0\x9f\0\xb5\0\x1d\0\xf1\0\xc0\0\x1d\0 \0\x9f\0\x9f\0e\x02\x9f\0\xc0\0\xc0\0\x12\x03\xc0\0\x1d\0\x1d\x001\x033\x032\x036\x03>\x03\xb5\0\xb0\0\x97\0=\x03?\x03A\x03\x1d\0\x1d\0\x1d\0\x1d\0L\x03T\x03c\x01e\x03\xb5\0f\x03\x05\x02n\x03\xb0\0s\x03\x1d\0\x1d\0\xb5\0o\x03\xb5\0\x8a\x01\xb0\0|\x03\xb0\0\x8a\x01\x9f\0\x84\x03\x86\x03\x8a\x01\xc0\0\x8a\x01\x8a\x03\x95\x03\xd9\0\x8a\x01\x8a\x01\x1d\0\x94\x01\x8a\x01\x1d\0z\x01\x1d\0\x1d\0\x1d\0\x1d\0\x97\x03\x96\x03\x8a\x01\xce\x01\xa1\x03\x1d\0`\x02a\x02b\x02c\x02\xf7\x01\xd5\x01\x1d\0\xab\x03\xb0\x03\xb4\x03\xb5\0\xa7\0d\x02\xb7\x03\xbe\x03\xbf\x03;\x01\xc4\x03\x1d\0\xe6\0\x1d\0\x9e\x01\x1d\0\x1d\0\x94\x01\x06\x03\xcf\x03\xd1\x03\x93\0\xda\x03\xf8\x03\xf6\x03\n\x04\xa7\x02\x1d\0\x0e\x04\x8a\x01\x1d\0\x0f\x04\xa7\x01\x17\x04\x1d\0\xfb\x03\x8a\x01\x1a\x04\x1f\x04\xae\x01\x93\0\x86\x02\xd9\0#\x04$\x04\xa8\x02\x97\0\x93\0\xb0\0\xb0\0e\x02'\x04\n\0\x97\x003\x04\x8a\x01\x8a\x017\x04\x8a\x01\x8a\x01\xc7\x02\xa7\0\xce\0B\x04\x94\x019\x04g\x04\xd9\0\x93\0\x93\0b\x04i\x04l\x04m\x04n\x04\x7f\x04\x94\x01\x8a\x01|\x04x\x01\x9c\x04\x9e\x04\x93\0x\x01\x94\x01\xa6\x04\xae\x04x\x01\x97\0x\x01\x93\0\x97\0\x93\0x\x01x\x01\xa9\x04\xaf\x04\xb0\x04\xb3\x04\xa9\x02^\0\x97\0\xb1\x04\xbe\x04\xaa\x02\xc6\x04x\x016\0`\x02a\x02b\x02c\x02\xd2\x04\x97\0\xd4\x04_\0\x10\0\xd8\x04\xd9\x04!\x03d\x02%\x02\xec\x04\xb0\0\xdb\x04\xdc\x04\x0b\x05\xed\x04`\0\xf0\x04\x90\x04\x1a\x05M\x02\xef\x04\x93\0(\x05\xf5\x04K\x04W\x04\x02\x05\xb0\0\x04\x05\x97\0\x97\0)\x05\x1c\x05x\x01\xaf\0!\0?\x053\x05@\x05N\x05x\x01r\x05\xbf\0%\0V\x05l\x05\xb0\0~\x05\x94\x01a\0\xd8\0\x8d\x05e\x02\x8e\x05Z\x05\xdc\0-\0\x94\x05\x9c\x05x\x01x\x01\xbf\0x\x01x\x01 \0\x97\0\xb0\0 \0\xbf\0\xb1\x05\xd9\0\x97\0b\0\x97\0\xb4\x05\xb5\x05\xb6\x05 \0 \0\xbc\x05\xc0\x05x\x01\xb0\0\xbe\x05c\0\x97\0\x0e\x05d\0\xc9\x05\xbf\0 \0 \0 \0 \0\x01\0\x02\0\x03\0\x04\0\x05\0\x06\0\x07\0\xc8\x05\xcd\x05\xbf\0 \0 \0\xd3\x05\xd7\x05\xda\x05\xb0\0\xbf\0\xbf\0\xde\x05\xbf\0Z\x01\xe3\x05\x9c\x01\xe4\x05K\x04\xe6\x053\0W\0\x9f\x02\b\0\xe0\x02 \x003\0\xe4\x02 \0\"\x02\x94\x01_\x02 \0 \0~\0\xea\x02\xa3\x02\xc7\x01\xa4\x02 \0\xeb\x02\xd5\x01\x97\0a\x01b\x01c\x01 \0\xd8\0.\x02\xd5\x01\x97\0\x94\x02\x94\x02L\x01\xd5\x01\xbf\0\x96\x02\x95\x02 \0\x95\x02 \0\xcd\x04 \0 \0\x97\0\xdc\x01\x97\0\xd5\x01\x97\0\xd5\x01\xd5\x01e\x01f\x01\xc7\x01 \0\x97\x02\x9a\x02 \0\xb0\0\x97\0W\x04 \0\xd5\x01\x9b\x02h\x01i\x01j\x01k\x01\x9c\x02\xaf\0\xaf\0\xd9\x01\xaf\0\xaf\0\x98\x02\xaf\0\x9b\x02\x86\x02\xb0\0\x97\0\xa8\x01m\x01\xd5\x01\x97\0\xb5\x04\xaf\0\xaf\0F\x05\xd5\x01\xd5\x01\xd5\x01\xe5\x04\x86\x02\x86\x02\xe2\x04\x96\x02\xd5\x01\xa7\x05\x93\x05}\x05\xae\x02k\x04\xc9\x03\xd5\x01\x89\0\x86\x02\x8a\0\x8b\0 \0W\x04\x8c\0V\x03\xac\x02\xb1\x01\x8e\0\xaf\0\xaf\0\x92\x02\xe4\x02\xd5\x01\xd8\0\x97\0\x97\0W\x03q\x04\x86\x025\x03\xa5\x03\x86\x02\xe0\x01\xe6\x04\xd5\x01\x9b\x01\x86\x02\xd5\x01\f\x04\xd8\x05/\x05\xb9\x04\x86\x02\x91\0k\x05\xcc\x02\x97\0\0\0\xa8\0\x86\x02\x92\x004\x05\xcd\x04\xb2\0\x94\x03\0\0\0\0\xc2\0M\x02\0\0\0\0M\x02\x93\0\x94\0\0\0\x86\x02\x86\x02\0\0K\x04\x97\0\0\0M\x02\0\0\0\0\xc2\0M\x02\0\0\x86\x02\xb0\0\0\0}\x02\x97\0\0\0\0\0M\x02M\x02M\x02M\x02\x97\0\0\0\x97\0\0\0\0\0\0\0\xc2\0W\x04\0\0K\x04\x97\0M\x02\xb0\0\0\0\0\0\0\0\0\0W\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb0\0\xd8\0M\x02\0\0\0\0M\x02\0\0}\x02M\x02M\x02M\x02\x97\0\xc2\0\0\0\xc2\0\xc2\0M\x02\0\0\xc7\x01\0\0\0\0T\x02\0\0M\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x97\0\0\0\0\0\0\0M\x02\0\0M\x02\x9c\x01M\x02M\x02\0\0\x9c\x01\x97\0\0\0\xb0\0\x9c\x01\0\0\x9c\x01\0\0F\x03M\x02\x9c\x01\xe0\x02M\x02K\x03\x9c\x01\x97\0M\x02\x97\0\xaf\0\0\0\0\0\0\0\0\0\x9c\x01\0\0\0\0\x97\0\0\0\0\0\0\0\xe0\x02\xd9\x01\0\0\x03\x01\0\0\0\0\0\0\xe0\x02K\x04\x97\0\0\0\0\0\0\0\0\0W\x04\0\0\0\0\0\0K\x04\xb2\0\xd6\x01\0\0\xb2\0\xb2\0\0\0\xb2\0]\x03\0\0\xe0\x02\xe0\x02\0\0\0\0\0\0\xb0\0\0\0\xb2\0\xb2\0\0\0\0\0\0\0\x9c\x01\xab\x02\xe0\x02\0\0\0\0\xc2\0\0\0\0\0\0\0\0\0\xe0\x02\0\0\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\x9c\x01\x9c\x01\x81\x03\x9c\x01\x9c\x01\0\0\xb2\0\xd6\x01\0\0\0\0\0\0\0\0K\x04\0\0\x97\0\xcd\x04\xc2\0\0\0\0\0\0\0\0\0\0\0\x9c\x01\0\0\0\0\0\0\xc7\x01\0\0\0\0\0\0\xaf\0\0\0\x97\0\0\0\x97\0\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x97\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa8\0\0\0\0\0\xa8\0\0\0\0\0\0\0K\x04\xaf\0\xaf\0\xaf\0\x97\0\x97\0\xa8\0\0\0\0\0\xaf\0\0\0\x97\0\xbe\0\0\0\0\0\x97\0\xd9\x01\0\0\0\0\xa8\0\xa8\0\xa8\0\xa8\0\0\0\xaf\0\0\0\0\0\xe0\x02\x97\0\xc2\0\xc1\x03\xbe\0\xaf\0\xaf\0\xa8\0\x97\0\0\0\xaf\0\xbe\0\xaf\0\0\0\x97\0\0\0\0\0\0\0\x97\0\0\0\xd8\0\0\0\xc2\0\x97\0\x97\0\xd9\x01\0\0\xa8\0\0\0\xd9\x01\0\0\0\0\xbe\0\0\0\xa8\0\xa8\0\0\0\0\0\xaf\0{\x01\0\0\xa8\0\0\0\0\0\0\0\xaf\0\xbe\0\n\0\xa8\0\xb0\x01\0\0\0\0\0\0\xbe\0\xbe\0\0\0\xbe\0\0\0\0\0\xde\x03\0\0\xd8\0\xa8\0\0\0\xa8\0\xaf\0\0\0\0\0\0\0\0\0\xe4\x03\0\0\xe6\x03\0\0\0\0\xb2\0\xa8\0\0\0\0\0\xa8\0\xdc\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xc2\0\xc2\0\0\0\0\0\xc2\0\0\0\xc2\0\0\0\x89\0\xbe\0\x8a\0\x8b\0 \0\0\0\x8c\0\0\0\0\0\xb1\x01\x8e\0\0\0\r\x04\x03\x01\0\0\xaf\0\x03\x01\0\0\0\0\0\0\0\0\x03\x01\0\0\x03\x01\0\0\0\0\x03\x01\x03\x01\0\0\x03\x01\x03\x01\x03\x01\x03\x01\x03\x01\x03\x01!\x04\x91\0\x03\x01\x03\x01\x03\x01%\x04\x03\x01\x03\x01\x92\0\0\0\0\0\0\0~\x03\0\0\0\0\x03\x01\0\0\0\0\x03\x01\x03\x01\x93\0\x94\0\0\0\0\0\0\0\x03\x01\x03\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd5\x01\0\0\0\0\x03\x01\0\0\0\0\x03\x01\0\0\xb2\0\0\0\x03\x01\x03\x01\0\0\x03\x01\0\0\0\0\x03\x01\x03\x01\0\0\0\0\0\0\0\0\0\0\xaf\0\x03\x01\\\x04\xd9\x01\xaf\0\0\0\0\0a\x04\0\0\0\0\0\0\0\0\x03\x01\x03\x01\0\0\x03\x01\x03\x01\x03\x01\x03\x01\xb2\0\xb2\0\xb2\0\0\0\0\0\x03\x01\0\0\x03\x01\xb2\0\0\0\x03\x01\0\0\0\0\x03\x01\0\0\0\0\xaf\0\x03\x01\0\0\0\0\0\0\0\0\0\0\xfa\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd6\x01\xb2\0\xaf\0\0\0\x8d\x04\xd6\x01\0\0\xb2\0\0\0\0\0\xaf\0\0\0\xaf\0\0\0\0\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0\0\0\xd8\0\0\0\0\0\0\0\0\0\0\0\xe0\x02\0\0\0\0\0\0M\x02\xb2\0\0\0\xe0\x02\0\0\0\0\0\0\0\0\xb2\0\xe0\x02\xe0\x02\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\xdd\x03\0\0\xba\x04{\x01\0\0\xe0\x02\0\0{\x01\xbd\x04\xb2\0\0\0{\x01\xe0\x02{\x01\0\0\0\0\0\0{\x01\0\0\0\0\0\0{\x01\0\0\0\0\xc2\0\xe0\x02\xe0\x02\0\0\xe0\x02\0\0{\x01\0\0\0\0\xe0\x02\xe0\x02\0\0\xe0\x02\0\0\xd8\0\xe0\x02\0\0\0\0\0\0\0\0\xaf\0\xaf\0\xe0\x02\0\0\0\0\0\0\xb3\0\0\0\0\0\0\0\xc3\0\0\0\xd6\x01\0\0\xe0\x02\0\0\0\0\0\0\xe0\x02\xd8\0\0\0\0\0\x1b\x04\0\0\0\0\xe7\x04{\x01\xc3\0\0\0\0\0\xe0\x02\0\0\0\0{\x01\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xc3\0\0\0\0\0\0\0\0\0{\x01{\x01\0\0{\x01{\x01\xc7\x01\0\0\xfb\x04\0\0\xfd\x04\0\0\x01\x05\0\0\0\0\x06\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0{\x01\xaf\0\0\0\0\0\0\0\0\0\0\0\x0f\x05\xc3\0\0\0\xc3\0\xc3\0\0\0\0\0\xd5\x01\0\0\xc7\x01\xb2\0\xaf\0\0\0\0\0\xb2\0\0\0\0\0\x1e\x05\x1f\x05\0\0\xd5\x01\0\0E\x04$\x05\x8a\0\x8b\0 \0\0\0\x8c\0\0\0\xaf\0F\x04G\x04\xd5\x01\0\0\xd5\x01\xd5\x01\0\0\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\xd6\x01H\x04\0\0\xd5\x01I\x04\xaf\x006\x05\0\0\0\0\xd8\0\xb2\x01\0\0J\x04\x91\0\0\0\0\0\0\0\xb2\0\0\0\0\0\x92\0\xaf\0\0\0\xd5\x01\0\0\xb2\0\0\0\xd6\x01\0\0\xd5\x01\xd5\x01\xd5\x01\x93\0\x94\0\0\0\xb3\0\xd7\x01\xd5\x01\xb3\0\xb3\0\0\0\xb3\0\0\0\0\0\xd5\x01\xb5\0\0\0\0\0\xaf\0\0\0\0\0\xb3\0\xb3\0\0\0\xcf\0\0\0\0\0\0\0\0\0\0\0\xd5\x01\xc3\0\0\0\xd9\x01\0\0\0\0\0\0M\x02\0\0\0\0M\x02\0\0\xd5\x01\0\0i\x05\xd5\x01\0\0\0\0\0\0\0\0M\x02\xb3\0\xd7\x01\0\0M\x02\xd9\x01\0\0\0\0p\x05~\x02\0\0\xc3\0\0\0M\x02M\x02M\x02M\x02\x8a\x02\0\0\0\0\0\0\0\0v\x05\0\0\0\0x\x05\0\0\0\0M\x02\0\0\xb2\0\xd6\x01\0\0\0\0\0\0\0\x009\x03\xaf\0\0\0\xc7\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0M\x02\0\0\0\0M\x02\0\0~\x02M\x02M\x02M\x02\xaf\0\x9c\x01\0\0\0\0\x8f\x05M\x02\0\0\0\0\0\0\0\0\0\0\0\0M\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf2\x01M\x02\0\0M\x02\0\0M\x02M\x02\xc3\0\xc7\x01\0\0\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0M\x02\x8c\0\x97\x01M\x02\x8d\0\x8e\0\0\0M\x02\xb2\0\0\0\xc3\0\xb0\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8f\0\xb5\0\xb5\0\xd6\x01\xb5\0\xb5\0\0\0\xb5\0\x90\0\x90\x03\0\0\0\0\0\0\0\0\0\0\0\0\x92\0\xb5\0\xb5\0\0\0\0\0\0\0\xb2\0\0\0\xc6\x05\xc7\x05\0\0\x05\x04\x93\0\x94\0\xb4\0\0\0\xce\x059\x03\0\0\xaf\0\0\0\0\0\0\0\0\0\0\0\xb3\0\xb2\0\0\0\0\0\0\0\0\0\xb5\0\xb5\0\x0e\0\0\0\0\0\xc7\x01\xe2\x02\0\0\xc3\0\xc3\0\xaf\0\xb2\0\xc3\0\0\0\xc3\0\xc7\x01\0\0\x0f\0\x10\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xaf\0\0\0\0\0\x17\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\xe7\x05\0\0\xd6\x01\0\0\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\xe2\x02\x8c\0\0\0!\0\x8d\0\x8e\0S\x01\0\0\xf1\x01\0\0\0\0%\0\xb2\x01\0\0\0\0\0\0\0\0)\0\0\0\xb2\x01\xe2\x02\xb2\x01\x8f\0\xe2\x02-\0\xaf\0\0\0\xe2\x02\xe2\x02\0\0\x90\0\x91\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\x92\0\0\x001\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\xb3\0\0\0\x93\0\x94\x005\0\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02\0\0\xd6\x01\0\0\0\0\0\0\0\0\0\0\xc7\x01\xc2\0\xc7\x01\xe2\x02\0\0\0\0\xe2\x02\x8a\x02\0\0\0\0\0\0\0\0\0\0\0\0\xd6\x01\0\0\xb3\0\xb3\0\xb3\0\xaf\0\0\0f\x02\x8a\x02\x8a\x02\xb3\0\xb4\0\xb4\0\0\0\xb4\0\xb4\0\0\0\xb4\0\0\0\0\0\xaf\0\x8a\x02\0\0\0\0\0\0\0\0\0\0\xb4\0\xb4\0\0\0\0\0k\0\x80\x02\xd7\x01\xb3\0\0\0\0\0\0\0\xd7\x01\0\0\xb3\0\x8a\x02\n\0\xf2\x01\x8a\x02\0\0\xf2\x01\0\0\0\0\x8a\x02\0\0\0\0\0\0\0\0\0\0\x8a\x02\xf2\x01\xb4\0\xb4\0\0\0\0\0\0\0\x8a\x02\0\0\0\0\0\0\xb3\0\0\0\0\0\xf2\x01\xf2\x01\xf2\x01\xf2\x01\xb3\0\0\0\0\0\xaf\0\0\0\x8a\x02\x8a\x02\0\0\0\0\0\0\0\0\xf2\x01\0\0\0\0\0\0\0\0\0\0\x8a\x02\0\0\x89\0\xb3\0\x8a\0\x8b\0 \0\xb2\0\x8c\0\0\0\0\0\xb1\x01\x8e\0\0\0\xf2\x01\0\0\0\0\xf2\x01\xc3\0\x97\x01\xf2\x01\xf2\x01\xf2\x01\0\0\0\0\0\0\0\0\0\0\xf2\x01\xd6\x01\0\0Z\x01\0\0\0\0\0\0\xf2\x01\xc2\0\0\0\x91\0\0\0\0\0\0\0\0\0\xb5\0\0\0\x92\0\xd6\x01\xf2\x01\0\0\xf2\x01\xd7\x01\xf2\x01\xf2\x01\0\0\0\0\0\0\0\0\x93\0\x94\0`\x01a\x01b\x01c\x01\xf2\x01\0\0\0\0\xf2\x01\0\0\x97\x01\0\0\xf2\x01\0\0\0\0\0\0\0\0\0\0\xdc\x02\xb5\0\xb5\0\xb5\0\xc8\x02\0\0\0\0\xb9\0\0\0\xb5\0\0\0;\x03e\x01f\x01\0\0\xd6\x01\0\0\0\0\xf1\x01\0\0\0\0\xf1\x01\0\0\0\0\0\0h\x01i\x01j\x01k\x01\xb2\x01\xe0\x02\xf1\x01\xb5\0\xb5\0\0\0\0\0\0\0\xb5\0\0\0\xb5\0\0\0\0\0m\x01\0\0\xf1\x01\xf1\x01\xf1\x01\xf1\x01\0\0\0\0\xb4\0f\x02\0\0\xb3\0\0\0\0\0\0\0\xb3\0\0\0\xf1\x01\0\0\0\0\0\0\0\0\0\0\xb5\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\x80\x02\x8c\0\0\0\xd6\x01\x8d\0\x8e\0\0\0\xf1\x01\0\0\0\0\xf1\x01\0\0\0\0\xf1\x01\xf1\x01\xf1\x01\xd7\x01\0\0\xa1\x05\0\0\xb5\0\xf1\x01\x8f\0\0\0\0\0\xef\x01\0\0\0\0\xf1\x01\0\0\x90\0\x91\0\0\0\xb3\0\0\0\0\0\0\0\0\0\x92\0\0\0\xf1\x01\xb3\0\xf1\x01\xd7\x01\xf1\x01\xf1\x01\0\0\xa1\x02\0\0k\0\x93\0\x94\0\0\0\0\0\0\0\0\0\xf1\x01\0\0\0\0\xf1\x01\x97\x01\0\0k\0\xf1\x01\0\0\0\0\0\0\xb5\0\0\0\0\0\0\0\0\0\0\0\0\0\xc2\x05k\0\0\0k\0k\0\xb4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\xa1\x02\0\0\xa1\x02\xa1\x02\xa1\x02\\\0\xa1\x02\0\0\0\0\xa1\x02\xa1\x02\0\0\0\0k\0\0\0\0\0\xb4\0\xb4\0\xb4\0\0\0k\0k\0\0\0\0\0\xb4\0\xb4\0\0\0k\0\0\0\xb3\0\xd7\x01\0\0\0\0\0\0k\0\0\0\xa1\x02\0\0\0\0\0\0\xae\x03\0\0\0\0\xa1\x02\0\0\0\0\x97\x01\xb4\0\xb4\0\xb5\0k\0\0\0\xb4\0\xb5\0\xb4\0\xa1\x02\xa1\x02\0\0\0\0\0\0\0\0\0\0k\0\0\0\0\0k\0\0\0\0\0\0\0\xb2\x01\0\0\0\0\0\0\0\0,\x04\0\0\0\0\xe7\0\xe7\0\0\0\xb4\0\0\0\0\0\0\0\xb5\0\0\0\0\0\xb4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\xb5\0\x8c\0\0\0\xb3\0\x8d\0\x8e\0\xb4\0\0\0\xb5\0\0\0\xb5\0\0\0\0\0\0\0\0\0\0\0\xe0\x02\0\0\0\0\xe0\x02\xd7\x01\0\0\x8f\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\x02\x90\0\x91\0\0\0\x8a\x01\x8b\x01\0\0\0\0\0\0\x92\0\xb3\0\0\0\0\0\xe0\x02\0\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0\x93\0\x94\0\0\0\xb4\0\0\0\0\0\0\0\xe0\x02\0\0\xb3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x97\x01\0\0\0\0\0\0\0\0\0\0\xb3\0\xfd\x01\xe0\x02\0\0\0\0\0\0\0\0\0\0\xef\x01\0\0\xe0\x02\xef\x01\0\0\0\0\0\0\0\0\xe0\x02\0\0\xb5\0\xb5\0\0\0\xef\x01\x97\x01\xe0\x02\0\0\0\0\0\0\xd7\x01\0\0\0\0\0\0\0\0\x97\x01\0\0\xef\x01\xef\x01\xef\x01\xef\x01\0\0\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xef\x01\0\0\xe0\x02\0\0\0\0\xe0\x02\0\0f\x02\xb4\0\xc2\x04\0\0\0\0\xb4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xef\x01\0\0\0\0\xef\x01\0\0\0\0\xef\x01\xef\x01\xef\x01\0\0\x97\x01\0\0\0\0\xb2\x01\xef\x01\n\0\\\0\xb0\x01\0\0\0\0\0\0\xef\x01\x97\x01\xb4\0\xb5\0\0\0\0\0\xd7\x01\0\0\\\0\x97\x01\0\0\0\0\xef\x01\xc3\0\xef\x01\0\0\xef\x01\xef\x01\0\0\xb4\0\xb5\0\\\0\0\0\\\0\\\0\0\0\xd7\x01\xb4\0\xef\x01\xb4\0\0\0\xef\x01\0\0\0\0\0\0\xef\x01\\\0\0\0\0\0\xb5\0\0\0\0\0\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\x97\x01\x8c\0\0\0\0\0\x8d\0\x8e\0\0\0\\\0\0\0\0\0\xb5\0\0\0\0\0Q\x04\0\0\\\0\0\0\0\0\0\0\0\0\0\0\\\0\x8f\0\0\0\0\0\0\0\xb5\0\0\0\\\0\0\0\x90\0\x91\0\x06\x01\0\0\0\0\0\0\0\0\x97\x01\x92\0\0\0\x97\x01\x97\x01\0\0\0\0\\\0\0\0\0\0\0\0\0\0\0\0\x93\0\x94\0\0\0\xb5\0\0\0\0\0\\\0\0\0\0\0\\\0\0\0\0\0\0\0\xb4\0\xb4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb3\0g\x02h\x02i\x02j\x02k\x02l\x02m\x02n\x02o\x02p\x02q\x02r\x02s\x02t\x02u\x02v\x02w\x02x\x02y\x02z\x02{\x02\xd7\x01}\x02\0\0\0\0\0\0\0\0\0\0\xc3\0\0\0\0\0\0\0Q\x04\0\0\0\0\0\0\x87\x02\0\0\xd7\x01\0\0\0\0\0\0\0\0\xfd\x01\x97\x01\xfd\x01\xfd\x01\xb5\0\x94\x02\0\0\0\0\xfd\x01\0\0\0\0\0\0\0\0\xfd\x01\0\0\0\0\0\0\xfd\x01\xfd\x01\xfd\x01\xb4\0\0\0\0\0\0\0\xb5\0\0\0\xfd\x01\xfd\x01\xfd\x01\xfd\x01\0\0\0\0\xcf\x04\0\0\0\0\0\0\xfd\x01\xb4\0\0\0\0\0\xd7\x01\xfd\x01\0\0\0\0\0\0\0\0\0\0\xfd\x01\xfd\x01\0\0\0\0\0\0\0\0\r\x01\0\0\0\0\xb4\0\0\0\0\0\0\0\0\0\xfd\x01\0\0\0\0\xfd\x01\0\0\0\0\xfd\x01\xfd\x01\xfd\x01\0\0\xfd\x01\0\0\0\0\0\0\xfd\x01\xb4\0\0\0\0\0\0\0\0\0\0\0\xfd\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb4\0\xfd\x01\xfd\x01\0\0\xfd\x01\xfd\x01\xfd\x01\xfd\x01\xd7\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xfd\x01\0\0\0\0\xfd\x01\0\0\0\0\0\0\xfd\x01\0\0\xb4\0\0\0\xb5\0\0\0\0\0\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\x97\x01\x8c\0\0\0\0\0\x8d\0\x8e\0\0\0\0\0\0\0\xcf\x04\0\0\0\0\xb5\0\0\0%\x05&\x05\0\0\0\0\0\0\0\0\0\0\0\0\x8f\0\0\0\0\0Q\x04\0\0\0\0\x19\x03\xb5\0\x90\0\x91\0\0\0\0\0\0\0\0\0\0\0#\x03\x92\0\x06\x01\0\0%\x03\x06\x01\0\0)\x03\0\0\0\0\x06\x01\0\0\x06\x01\x93\0\x94\0\x06\x01\x06\x01Q\x04\0\0\x06\x01\xb4\0\x06\x01\x06\x01\x06\x01\0\0\0\0\x06\x01\x06\x01\x06\x01O\x02\x06\x01\x06\x01\0\0\0\0\0\0\0\0\0\0\xb5\0\0\0\x06\x01\xb4\0\x97\x01\x06\x01\x06\x01\0\0\0\0\0\0\0\0\0\0\x06\x01\x06\x01\0\0\0\0\0\0\0\0\0\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\0\0\x06\x01\0\0\0\0\x06\x01\0\0\0\0\0\0\x06\x01\x06\x01\0\0\x06\x01\0\0\0\0\x06\x01\x06\x01\0\0\0\0\0\0\0\0\0\0\0\0\x06\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0j\x03\x06\x01\x06\x01\xb5\0\x06\x01\x06\x01\x06\x01\x06\x01\0\0\0\0\0\0\0\0\0\0\x06\x01\0\0\x06\x01\xcf\x04\0\0\x06\x01\0\0\0\0\x06\x01\0\0Q\x04\0\0\x06\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0Q\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x89\0\xb4\0\x8a\0\x8b\0 \0\r\x01\x8c\0\0\0\r\x01\x8d\0\x8e\0\0\0\0\0\r\x01\0\0\r\x01\0\0r\x02\r\x01\r\x01\0\0\0\0\r\x01\xb4\0\r\x01\r\x01\r\x01\x8f\0\0\0\r\x01\r\x01\r\x01\0\0\r\x01\r\x01\x90\0\x90\x03\0\0\0\0\0\0\xb4\0\0\0\r\x01\x92\0Q\x04\r\x01\r\x01\xcf\x04\0\0\0\0\0\0\0\0\r\x01\r\x01\xb1\x03\x93\0\x94\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\r\x01\0\0\0\0\r\x01\0\0\0\0\0\0\r\x01\r\x01\0\0\r\x01\0\0\0\0\r\x01\r\x01\0\0\0\0\0\0\0\0\xb4\0\0\0\r\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0Q\x04\xd0\x03\0\0\r\x01\r\x01\0\0\r\x01\r\x01\r\x01\r\x01\0\0\0\0\0\0\0\0\0\0\r\x01\0\0\r\x01\0\0\0\0\r\x01\0\0\0\0\r\x01\0\0\0\0\0\0\r\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xdf\x03\0\0\0\0\0\0\0\0\0\0\0\0\xe0\0\0\0\0\0\0\0\0\0\0\0\xb4\0\0\0\0\0\0\0O\x02O\x02O\x02O\x02\0\0\0\0O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02\0\0O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02\0\0\0\0\0\0\0\0O\x02O\x02\0\0\x16\x04O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02\0\0O\x02O\x02O\x02O\x02\0\0\0\0O\x02O\x02O\x02:\x02O\x02O\x02O\x02O\x02O\x02O\x02\0\0O\x02O\x02O\x02O\x02O\x02\0\0O\x02O\x02\0\0\0\0\0\0O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02\0\0O\x02\0\0O\x02O\x02\0\0O\x02O\x02O\x02O\x02O\x02\0\0O\x02O\x02\0\0O\x02O\x02O\x02O\x02\x1d\x01O\x02O\x02\0\0O\x02\0\0\0\0\0\0O\x02\0\0\0\0\0\0\0\0\0\0\0\0r\x02r\x02r\x02r\x02r\x02\0\0r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02\0\0z\x04r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02\0\0\0\0\0\0\0\0r\x02r\x02\0\0\0\0r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02\0\0r\x02r\x02r\x02r\x02\0\0\0\0r\x02r\x02r\x02\0\0r\x02r\x02r\x02r\x02r\x02r\x02\0\0r\x02r\x02r\x02r\x02r\x02\0\0r\x02r\x02\0\0\0\0\0\0r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02\0\0r\x02\0\0r\x02r\x02\0\0r\x02r\x02r\x02r\x02r\x02\0\0r\x02r\x02<\x01r\x02r\x02r\x02r\x02\0\0r\x02r\x02\0\0r\x02\0\0\0\0\0\0r\x02\0\0\0\0\0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\0\0\0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\0\xe0\0\0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\0\0\0\0\xf1\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\0\xe0\0\0\0\xe0\0\xf8\x04\0\0\xe0\0\xe0\0\xe0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\0\0\0\0\xe0\0\xe0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0$\x01\0\0\xe0\0\0\0\0\0\xe0\0\0\0\xe0\0\0\0\0\0\xe0\0\0\0\0\0\xe0\0!\x05\"\x05#\x05\xe0\0\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\0\0\0\0\0\0\x1d\x01\x1d\x01\0\0\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\0\0\x1d\x01\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\0\0\0\0\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\x1d\x01\0\0\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\"\x01\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\0\0\x1d\x01\0\0\0\0\0\0\x1d\x01\0\0<\x01<\x01<\x01<\x01<\x01\0\0<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01\0\0\0\0<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01\0\0\0\0\0\0\0\0<\x01<\x01\0\0\0\0<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01\0\0<\x01<\x01<\x01<\x01\0\0\0\0<\x01<\x01<\x01\0\0<\x01<\x01<\x01<\x01<\x01<\x01\0\0<\x01<\x01<\x01<\x01<\x01\0\0<\x01<\x01\0\0\0\0\0\0<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01\0\0<\x01\0\0<\x01<\x01\0\0<\x01<\x01<\x01<\x01<\x01 \x01<\x01<\x01\0\0<\x01<\x01<\x01<\x01\0\0<\x01<\x01\0\0<\x01\0\0\0\0\0\0<\x01$\x01$\x01$\x01$\x01\0\0\0\0$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01\0\0$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01\0\0\0\0\0\0\0\0$\x01$\x01\0\0\0\0$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01\0\0$\x01$\x01$\x01$\x01\0\0\0\0$\x01$\x01$\x01\0\0$\x01$\x01$\x01$\x01$\x01$\x01\0\0$\x01$\x01$\x01$\x01$\x01\0\0$\x01$\x01\0\0\0\0\0\0$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01\0\0$\x01\0\0$\x01$\x01\0\0$\x01$\x01$\x01$\x01$\x01E\x01$\x01$\x01\0\0$\x01$\x01$\x01$\x01\0\0$\x01$\x01\0\0$\x01\0\0\0\0\0\0$\x01\0\0\0\0\"\x01\"\x01\"\x01\"\x01\0\0\0\0\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\0\0\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\0\0\0\0\0\0\0\0\"\x01\"\x01\0\0\0\0\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\0\0\"\x01\"\x01\"\x01\"\x01\0\0\0\0\"\x01\"\x01\"\x01\0\0\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\0\0\"\x01\"\x01\"\x01\"\x01\"\x01\0\0\"\x01\"\x01\0\0\0\0\0\0\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\0\0\"\x01\0\0\"\x01\"\x01\0\0\"\x01\"\x01\"\x01\"\x01\"\x01G\x01\"\x01\"\x01\0\0\"\x01\"\x01\"\x01\"\x01\0\0\"\x01\"\x01\0\0\"\x01\0\0\0\0\0\0\"\x01\0\0 \x01 \x01 \x01 \x01\0\0\0\0 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01\0\0 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01\0\0\0\0\0\0\0\0 \x01 \x01\0\0\0\0 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01\0\0 \x01 \x01 \x01 \x01\0\0\0\0 \x01 \x01 \x01\0\0 \x01 \x01 \x01 \x01 \x01 \x01\0\0 \x01 \x01 \x01 \x01 \x01\0\0 \x01 \x01\0\0\0\0\0\0 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01\0\0 \x01\0\0 \x01 \x01\0\0 \x01 \x01 \x01 \x01 \x01J\x01 \x01 \x01\0\0 \x01 \x01 \x01 \x01\0\0 \x01 \x01\0\0 \x01\0\0\0\0\0\0 \x01E\x01E\x01E\x01E\x01E\x01\0\0E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01\0\0\0\0E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01\0\0\0\0\0\0\0\0E\x01E\x01\0\0\0\0E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01\0\0E\x01E\x01E\x01E\x01\0\0\0\0E\x01E\x01E\x01\0\0E\x01E\x01E\x01E\x01E\x01E\x01\0\0E\x01E\x01E\x01E\x01E\x01\0\0E\x01E\x01\0\0\0\0\0\0E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01\0\0E\x01\0\0E\x01E\x01\0\0E\x01E\x01E\x01\0\0\0\0\x15\x01E\x01E\x01\0\0E\x01E\x01E\x01E\x01\0\0E\x01E\x01\0\0E\x01\0\0\0\0\0\0E\x01\0\0\0\0G\x01G\x01G\x01G\x01G\x01\0\0G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01\0\0\0\0G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01\0\0\0\0\0\0\0\0G\x01G\x01\0\0\0\0G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01\0\0G\x01G\x01G\x01G\x01\0\0\0\0G\x01G\x01G\x01\0\0G\x01G\x01G\x01G\x01G\x01G\x01\0\0G\x01G\x01G\x01G\x01G\x01\0\0G\x01G\x01\0\0\0\0\0\0G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01\0\0G\x01\0\0G\x01G\x01\0\0G\x01G\x01G\x01\x16\x01\0\0\0\0G\x01G\x01\0\0G\x01G\x01G\x01G\x01\0\0G\x01G\x01\0\0G\x01\0\0\0\0\0\0G\x01\0\0J\x01J\x01J\x01J\x01J\x01\0\0J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01\0\0\0\0J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01\0\0\0\0\0\0\0\0J\x01J\x01\0\0\0\0J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01\0\0J\x01J\x01J\x01J\x01\0\0\0\0J\x01J\x01J\x01\0\0J\x01J\x01J\x01J\x01J\x01J\x01\0\0J\x01J\x01J\x01J\x01J\x01\0\0J\x01J\x01\0\0\0\0\0\0J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01\0\0J\x01\0\0J\x01J\x01\0\0J\x01J\x01J\x01\xdf\0\0\0\0\0J\x01J\x01\0\0J\x01J\x01J\x01J\x01\0\0J\x01J\x01\0\0J\x01\0\0\0\0\0\0J\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\0\0\0\0\0\0\x15\x01\x15\x01\x15\x01\0\0\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\0\0\0\0\0\0\0\0\0\0\x15\x01\x15\x01\0\0\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\0\0\0\0\x15\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15\x01\x15\x01\0\0\x15\x01\0\0\0\0\x15\x01\x15\x01\x15\x01\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\0\0\0\0\0\0\0\0\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\0\0\x15\x01\0\0\x15\x01\x15\x01\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\xea\0\x15\x01\0\0\0\0\x15\x01\x15\x01\x15\x01\0\0\0\0\x15\x01\0\0\0\0\x15\x01\0\0\0\0\0\0\x15\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\0\0\0\0\0\0\x16\x01\x16\x01\x16\x01\0\0\0\0\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\0\0\0\0\0\0\0\0\0\0\x16\x01\x16\x01\0\0\0\0\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\0\0\0\0\x16\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x01\x16\x01\0\0\x16\x01\0\0\0\0\x16\x01\x16\x01\x16\x01\0\0\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\0\0\0\0\0\0\0\0\0\0\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\0\0\x16\x01\0\0\x16\x01\x16\x01\0\0\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\xeb\0\x16\x01\0\0\0\0\x16\x01\x16\x01\x16\x01\0\0\0\0\x16\x01\0\0\0\0\x16\x01\0\0\0\0\0\0\x16\x01\0\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\xdf\0\xdf\0\xdf\0\0\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\0\0\0\0\xdf\0\xdf\0\0\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xdf\0\xdf\0\0\0\xdf\0\0\0\0\0\xdf\0\xdf\0\xdf\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\0\0\0\0\xdf\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\xdf\0\xdf\0\0\0\xdf\0\xdf\0\xdf\0\0\0\xec\0\0\0\xdf\0\0\0\0\0\xdf\0\0\0\xdf\0\0\0\0\0\xdf\0\0\0\0\0\xdf\0\0\0\0\0\0\0\xdf\0\0\0\0\0\xea\0\xea\0\xea\0\xea\0\0\0\0\0\0\0\0\0\xea\0\xea\0\xea\0\0\0\0\0\xea\0\xea\0\xea\0\xea\0\xea\0\0\0\xea\0\xea\0\xea\0\0\0\0\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\0\0\0\0\0\0\0\0\0\0\0\0\xea\0\xea\0\0\0\0\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xea\0\xea\0\0\0\xea\0\0\0\0\0\xea\0\xea\0\xea\0\0\0\xea\0\xea\0\xea\0\xea\0\xea\0\0\0\0\0\0\0\0\0\0\0\0\0\xea\0\0\0\xea\0\xea\0\xea\0\xea\0\xea\0\0\0\0\0\0\0\0\0\xea\0\xea\0\0\0\xea\0\xea\0\xea\0\xea\0\x0e\x01\0\0\xea\0\0\0\0\0\xea\0\0\0\xea\0\0\0\0\0\xea\0\0\0\0\0\xea\0\0\0\0\0\0\0\xea\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\xeb\0\xeb\0\xeb\0\0\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\0\0\0\0\xeb\0\xeb\0\0\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xeb\0\xeb\0\0\0\xeb\0\0\0\0\0\xeb\0\xeb\0\xeb\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\0\0\0\0\xeb\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\xeb\0\xeb\0\0\0\xeb\0\xeb\0\xeb\0\0\0\x0f\x01\0\0\xeb\0\0\0\0\0\xeb\0\0\0\xeb\0\0\0\0\0\xeb\0\0\0\0\0\xeb\0\0\0\0\0\0\0\xeb\0\xec\0\xec\0\xec\0\xec\0\0\0\0\0\0\0\0\0\xec\0\xec\0\xec\0\0\0\0\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\0\0\0\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\0\0\0\0\0\0\0\0\0\0\0\0\xec\0\xec\0\0\0\0\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xec\0\xec\0\0\0\xec\0\0\0\0\0\xec\0\xec\0\xec\0\0\0\xec\0\xec\0\xec\0\xec\0\xec\0\0\0\0\0\0\0\0\0\0\0\0\0\xec\0\0\0\xec\0\xec\0\xec\0\xec\0\xec\0\0\0\0\0\0\0\0\0\xec\0\xec\0\0\0\xec\0\xec\0\xec\0\0\0\xf6\0\0\0\xec\0\0\0\0\0\xec\0\0\0\xec\0\0\0\0\0\xec\0\0\0\0\0\xec\0\0\0\0\0\0\0\xec\0\0\0\0\0\x0e\x01\x0e\x01\x0e\x01\x0e\x01\0\0\0\0\0\0\0\0\x0e\x01\x0e\x01\x0e\x01\0\0\0\0\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\0\0\0\0\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\0\0\0\0\0\0\0\0\0\0\0\0\x0e\x01\x0e\x01\0\0\0\0\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0e\x01\x0e\x01\0\0\x0e\x01\0\0\0\0\x0e\x01\x0e\x01\x0e\x01\0\0\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\0\0\0\0\0\0\0\0\0\0\0\0\x0e\x01\0\0\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\0\0\0\0\0\0\0\0\x0e\x01\x0e\x01\0\0\x0e\x01\x0e\x01\x0e\x01\xf7\0\0\0\0\0\x0e\x01\0\0\0\0\x0e\x01\0\0\x0e\x01\0\0\0\0\x0e\x01\0\0\0\0\x0e\x01\0\0\0\0\0\0\x0e\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\0\0\0\0\0\0\0\0\x0f\x01\x0f\x01\x0f\x01\0\0\0\0\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\0\0\0\0\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\0\0\0\0\0\0\0\0\0\0\0\0\x0f\x01\x0f\x01\0\0\0\0\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0f\x01\x0f\x01\0\0\x0f\x01\0\0\0\0\x0f\x01\x0f\x01\x0f\x01\0\0\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\0\0\0\0\0\0\0\0\0\0\0\0\x0f\x01\0\0\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\0\0\0\0\0\0\0\0\x0f\x01\x0f\x01\0\0\x0f\x01\x0f\x01\x0f\x01\xfe\0\0\0\0\0\x0f\x01\0\0\0\0\x0f\x01\0\0\x0f\x01\0\0\0\0\x0f\x01\0\0\0\0\x0f\x01\0\0\0\0\0\0\x0f\x01\xf6\0\xf6\0\xf6\0\xf6\0\0\0\0\0\0\0\0\0\xf6\0\xf6\0\xf6\0\0\0\0\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\0\0\0\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\0\0\0\0\0\0\0\0\0\0\0\0\xf6\0\xf6\0\0\0\0\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\0\0\xf6\0\xf6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf6\0\xf6\0\0\0\xf6\0\0\0\0\0\xf6\0\xf6\0\xf6\0\0\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\0\0\0\0\0\0\0\0\0\0\0\0\xf6\0\0\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\0\0\0\0\0\0\0\0\xf6\0\xf6\0\0\0\xf6\0\xf6\0\xf6\0\xf6\0\xfd\0\0\0\xf6\0\0\0\0\0\xf6\0\0\0\xf6\0\0\0\0\0\xf6\0\0\0\0\0\xf6\0\0\0\0\0\0\0\xf6\0\0\0\xf7\0\xf7\0\xf7\0\xf7\0\0\0\0\0\0\0\0\0\xf7\0\xf7\0\xf7\0\0\0\0\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\0\0\0\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\0\0\0\0\0\0\0\0\0\0\0\0\xf7\0\xf7\0\0\0\0\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\0\0\xf7\0\xf7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf7\0\xf7\0\0\0\xf7\0\0\0\0\0\xf7\0\xf7\0\xf7\0\0\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\0\0\0\0\0\0\0\0\0\0\0\0\xf7\0\0\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\0\0\0\0\0\0\0\0\xf7\0\xf7\0\0\0\xf7\0\xf7\0\xf7\0\xf7\0\xe4\0\0\0\xf7\0\0\0\0\0\xf7\0\0\0\xf7\0\0\0\0\0\xf7\0\0\0\0\0\xf7\0\0\0\0\0\0\0\xf7\0\xfe\0\xfe\0\xfe\0\xfe\0\0\0\0\0\0\0\0\0\xfe\0\xfe\0\xfe\0\0\0\0\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\0\0\0\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\0\0\0\0\0\0\0\0\0\0\0\0\xfe\0\xfe\0\0\0\0\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\0\0\xfe\0\xfe\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xfe\0\xfe\0\0\0\xfe\0\0\0\0\0\xfe\0\xfe\0\xfe\0\0\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\0\0\0\0\0\0\0\0\0\0\0\0\xfe\0\0\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\0\0\0\0\0\0\0\0\xfe\0\xfe\0\0\0\xfe\0\xfe\0\xfe\0\xfe\0\xe7\0\0\0\xfe\0\0\0\0\0\xfe\0\0\0\xfe\0\0\0\0\0\xfe\0\0\0\0\0\xfe\0\0\0\0\0\0\0\xfe\0\0\0\xfd\0\xfd\0\xfd\0\xfd\0\0\0\0\0\0\0\0\0\xfd\0\xfd\0\xfd\0\0\0\0\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\0\0\0\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\0\0\0\0\0\0\0\0\0\0\0\0\xfd\0\xfd\0\0\0\0\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\0\0\xfd\0\xfd\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xfd\0\xfd\0\0\0\xfd\0\0\0\0\0\xfd\0\xfd\0\xfd\0\0\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\0\0\0\0\0\0\0\0\0\0\0\0\xfd\0\0\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\0\0\0\0\0\0\0\0\xfd\0\xfd\0\0\0\xfd\0\xfd\0\xfd\0\xfd\0\xe8\0\0\0\xfd\0\0\0\0\0\xfd\0\0\0\xfd\0\0\0\0\0\xfd\0\0\0\0\0\xfd\0\0\0\0\0\0\0\xfd\0\0\0\xe4\0\xe4\0\xe4\0\xe4\0\0\0\0\0\0\0\0\0\0\0\xe4\0\xe4\0\0\0\0\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\0\0\0\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\0\xe4\0\0\0\0\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\0\xe4\0\0\0\xe4\0\0\0\0\0\xe4\0\xe4\0\xe4\0\0\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\0\0\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\0\0\0\0\0\0\0\0\xe4\0\xe4\0\0\0\xe4\0\xe4\0\xe4\0\xe4\0\xf5\0\0\0\xe4\0\0\0\0\0\xe4\0\0\0\xe4\0\0\0\0\0\xe4\0\0\0\0\0\xe4\0\0\0\0\0\0\0\xe4\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\0\0\xe7\0\xe7\0\0\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\0\0\0\0\xe7\0\xe7\0\0\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe7\0\xe7\0\0\0\xe7\0\0\0\0\0\xe7\0\xe7\0\xe7\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\0\0\0\0\xe7\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\xe7\0\xe7\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xfb\0\0\0\xe7\0\0\0\0\0\xe7\0\0\0\xe7\0\0\0\0\0\xe7\0\0\0\0\0\xe7\0\0\0\0\0\0\0\xe7\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\0\0\0\0\0\0\0\0\0\0\xe8\0\xe8\0\0\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\0\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\0\0\0\0\0\0\0\0\0\0\0\0\xe8\0\xe8\0\0\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe8\0\xe8\0\0\0\xe8\0\0\0\0\0\xe8\0\xe8\0\xe8\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\0\0\0\0\0\0\0\0\0\0\0\0\xe8\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\0\0\0\0\0\0\0\0\xe8\0\xe8\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xfc\0\0\0\xe8\0\0\0\0\0\xe8\0\0\0\xe8\0\0\0\0\0\xe8\0\0\0\0\0\xe8\0\0\0\0\0\0\0\xe8\0\0\0\xf5\0\xf5\0\xf5\0\xf5\0\0\0\0\0\0\0\0\0\xf5\0\xf5\0\xf5\0\0\0\0\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\0\0\0\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\0\0\0\0\0\0\0\0\0\0\0\0\xf5\0\xf5\0\0\0\0\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\0\0\0\0\xf5\0\xf5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf5\0\xf5\0\0\0\xf5\0\0\0\0\0\xf5\0\xf5\0\xf5\0\0\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\0\0\0\0\0\0\0\0\0\0\0\0\xf5\0\0\0\xf5\0\0\0\xf5\0\xf5\0\xf5\0\0\0\0\0\0\0\0\0\xf5\0\xf5\0\0\0\xf5\0\xf5\0\xf5\0\xf5\0\xf8\0\0\0\0\0\0\0\0\0\xf5\0\0\0\xf5\0\0\0\0\0\xf5\0\0\0\0\0\xf5\0\0\0\0\0\0\0\xf5\0\xfb\0\xfb\0\xfb\0\xfb\0\0\0\0\0\0\0\0\0\xfb\0\xfb\0\xfb\0\0\0\0\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\0\0\0\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\0\0\0\0\0\0\0\0\0\0\0\0\xfb\0\xfb\0\0\0\0\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\0\0\0\0\xfb\0\xfb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xfb\0\xfb\0\0\0\xfb\0\0\0\0\0\xfb\0\xfb\0\xfb\0\0\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\0\0\0\0\0\0\0\0\0\0\0\0\xfb\0\0\0\xfb\0\0\0\xfb\0\xfb\0\xfb\0\0\0\0\0\0\0\0\0\xfb\0\xfb\0\0\0\xfb\0\xfb\0\xfb\0\xfb\0\xf9\0\0\0\0\0\0\0\0\0\xfb\0\0\0\xfb\0\0\0\0\0\xfb\0\0\0\0\0\xfb\0\0\0\0\0\0\0\xfb\0\0\0\xfc\0\xfc\0\xfc\0\xfc\0\0\0\0\0\0\0\0\0\xfc\0\xfc\0\xfc\0\0\0\0\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\0\0\0\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\0\0\0\0\0\0\0\0\0\0\0\0\xfc\0\xfc\0\0\0\0\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\0\0\0\0\xfc\0\xfc\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xfc\0\xfc\0\0\0\xfc\0\0\0\0\0\xfc\0\xfc\0\xfc\0\0\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\0\0\0\0\0\0\0\0\0\0\0\0\xfc\0\0\0\xfc\0\0\0\xfc\0\xfc\0\xfc\0\0\0\0\0\0\0\0\0\xfc\0\xfc\0\0\0\xfc\0\xfc\0\xfc\0\xfc\0\xfa\0\0\0\0\0\0\0\0\0\xfc\0\0\0\xfc\0\0\0\0\0\xfc\0\0\0\0\0\xfc\0\0\0\0\0\0\0\xfc\0\0\0\xf8\0\xf8\0\xf8\0\xf8\0\0\0\0\0\0\0\0\0\xf8\0\xf8\0\xf8\0\0\0\0\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\0\0\0\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\0\0\0\0\0\0\0\0\0\0\0\0\xf8\0\xf8\0\0\0\0\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\0\0\0\0\xf8\0\xf8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf8\0\xf8\0\0\0\xf8\0\0\0\0\0\xf8\0\xf8\0\xf8\0\0\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\0\0\0\0\0\0\0\0\0\0\0\0\xf8\0\0\0\xf8\0\0\0\xf8\0\xf8\0\xf8\0\0\0\0\0\0\0\0\0\xf8\0\xf8\0\0\0\xf8\0\xf8\0\xf8\0\xf8\0\xcc\0\0\0\0\0\0\0\0\0\xf8\0\0\0\xf8\0\0\0\0\0\xf8\0\0\0\0\0\xf8\0\0\0\0\0\0\0\xf8\0\xf9\0\xf9\0\xf9\0\xf9\0\0\0\0\0\0\0\0\0\xf9\0\xf9\0\xf9\0\0\0\0\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\0\0\0\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\0\0\0\0\0\0\0\0\0\0\0\0\xf9\0\xf9\0\0\0\0\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\0\0\0\0\xf9\0\xf9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf9\0\xf9\0\0\0\xf9\0\0\0\0\0\xf9\0\xf9\0\xf9\0\0\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\0\0\0\0\0\0\0\0\0\0\0\0\xf9\0\0\0\xf9\0\0\0\xf9\0\xf9\0\xf9\0\0\0\0\0\0\0\0\0\xf9\0\xf9\0\0\0\xf9\0\xf9\0\xf9\0\xf9\0\xff\0\0\0\0\0\0\0\0\0\xf9\0\0\0\xf9\0\0\0\0\0\xf9\0\0\0\0\0\xf9\0\0\0\0\0\0\0\xf9\0\0\0\xfa\0\xfa\0\xfa\0\xfa\0\0\0\0\0\0\0\0\0\xfa\0\xfa\0\xfa\0\0\0\0\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\0\0\0\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\0\0\0\0\0\0\0\0\0\0\0\0\xfa\0\xfa\0\0\0\0\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\0\0\0\0\xfa\0\xfa\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xfa\0\xfa\0\0\0\xfa\0\0\0\0\0\xfa\0\xfa\0\xfa\0\0\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\0\0\0\0\0\0\0\0\0\0\0\0\xfa\0\0\0\xfa\0\0\0\xfa\0\xfa\0\xfa\0\0\0\0\0\0\0\0\0\xfa\0\xfa\0\0\0\xfa\0\xfa\0\xfa\0\xfa\0\x01\x01\0\0\0\0\0\0\0\0\xfa\0\0\0\xfa\0\0\0\0\0\xfa\0\0\0\0\0\xfa\0\0\0\0\0\0\0\xfa\0\0\0\xcc\0\xcc\0\xcc\0\xcc\0\0\0\0\0\0\0\0\0\xcc\0\xcc\0\xcc\0\0\0\0\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\0\0\0\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\0\0\0\0\0\0\0\0\0\0\0\0\xcc\0\xcc\0\0\0\0\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xcc\0\xcc\0\0\0\0\0\0\0\0\0\xcc\0\xcc\0\xcc\0\0\0\xcc\0\0\0\0\0\xcc\0\xcc\0\0\0\0\0\0\0\0\0\0\0\0\0\xcc\0\0\0\xcc\0\xcc\0\0\0\0\0\xcc\0\0\0\0\0\0\0\0\0\xcc\0\xcc\0\0\0\xcc\0\xcc\0\xcc\0\xcc\0\xf3\0\0\0\xcc\0\0\0\0\0\xcc\0\0\0\xcc\0\0\0\0\0\xcc\0\0\0\0\0\xcc\0\0\0\0\0\0\0\xcc\0\xff\0\xff\0\xff\0\xff\0\0\0\0\0\0\0\0\0\xff\0\xff\0\xff\0\0\0\0\0\xff\0\xff\0\0\0\xff\0\xff\0\xff\0\xff\0\xff\0\xff\0\0\0\0\0\xff\0\xff\0\xff\0\xff\0\xff\0\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\0\xff\0\0\0\0\0\xff\0\xff\0\xff\0\0\0\0\0\0\0\0\0\xff\0\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\0\xff\0\0\0\xff\0\0\0\0\0\0\0\xff\0\xff\0\0\0\xff\0\0\0\0\0\xff\0\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\0\0\0\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\0\xff\0\0\0\xff\0\xff\0\xff\0\xff\0\xf4\0\0\0\0\0\0\0\0\0\xff\0\0\0\xff\0\0\0\0\0\xff\0\0\0\0\0\xff\0\0\0\0\0\0\0\xff\0\0\0\x01\x01\x01\x01\x01\x01\x01\x01\0\0\0\0\0\0\0\0\x01\x01\x01\x01\x01\x01\0\0\0\0\x01\x01\x01\x01\0\0\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\0\0\0\0\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\x01\x01\x01\x01\0\0\0\0\x01\x01\x01\x01\x01\x01\0\0\0\0\0\0\0\0\x01\x01\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\x01\x01\x01\0\0\x01\x01\0\0\0\0\0\0\x01\x01\x01\x01\0\0\x01\x01\0\0\0\0\x01\x01\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\x01\x01\0\0\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\x01\x01\x01\0\0\x01\x01\x01\x01\x01\x01\x01\x01\0\x01\0\0\0\0\0\0\0\0\x01\x01\0\0\x01\x01\0\0\0\0\x01\x01\0\0\0\0\x01\x01\0\0\0\0\0\0\x01\x01\0\0\xf3\0\xf3\0\xf3\0\xf3\0\0\0\0\0\0\0\0\0\xf3\0\xf3\0\xf3\0\0\0\0\0\xf3\0\xf3\0\0\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\0\0\0\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\0\0\0\0\0\0\0\0\0\0\0\0\xf3\0\xf3\0\0\0\0\0\xf3\0\xf3\0\xf3\0\0\0\0\0\0\0\0\0\xf3\0\xf3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf3\0\xf3\0\0\0\xf3\0\0\0\0\0\0\0\xf3\0\xf3\0\0\0\xf3\0\0\0\0\0\xf3\0\xf3\0\0\0\0\0\0\0\0\0\0\0\0\0\xf3\0\0\0\xf3\0\0\0\0\0\x05\x01\0\0\0\0\0\0\0\0\0\0\xf3\0\xf3\0\0\0\xf3\0\xf3\0\xf3\0\xf3\0\0\0\0\0\0\0\0\0\0\0\xf3\0\0\0\xf3\0\0\0\0\0\xf3\0\0\0\0\0\xf3\0\0\0\0\0\0\0\xf3\0\xf4\0\xf4\0\xf4\0\xf4\0\0\0\0\0\0\0\0\0\xf4\0\xf4\0\xf4\0\0\0\0\0\xf4\0\xf4\0\0\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\0\0\0\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\0\0\0\0\0\0\0\0\0\0\0\0\xf4\0\xf4\0\0\0\0\0\xf4\0\xf4\0\xf4\0\0\0\0\0\0\0\0\0\xf4\0\xf4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf4\0\xf4\0\0\0\xf4\0\0\0\0\0\0\0\xf4\0\xf4\0\0\0\xf4\0\0\0\0\0\xf4\0\xf4\0\0\0\0\0\0\0\0\0\x04\x01\0\0\xf4\0\0\0\xf4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf4\0\xf4\0\0\0\xf4\0\xf4\0\xf4\0\xf4\0\0\0\0\0\0\0\0\0\0\0\xf4\0\0\0\xf4\0\0\0\0\0\xf4\0\0\0\0\0\xf4\0\0\0\0\0\0\0\xf4\0\0\0\0\x01\0\x01\0\x01\0\x01\0\0\0\0\0\0\0\0\0\x01\0\x01\0\x01\0\0\0\0\0\x01\0\x01\0\0\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\0\0\0\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\x01\0\0\0\0\0\x01\0\x01\0\x01\0\0\0\0\0\0\0\0\0\x01\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\x01\0\0\0\x01\0\0\0\0d\x01\0\x01\0\x01\0\0\0\x01\0\0\0\0\0\x01\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\x01\0\0\0\x01\0\x01\0\x01\0\x01\0\0\0\0\0\0\0\0\0\0\0\x01\x05\x01\0\x01\0\0\x05\x01\0\x01\0\0\0\0\0\x01\x05\x01\x05\x01\x05\x01\0\x01\0\0\x05\x01\x05\x01\0\0\x05\x01\x05\x01\x05\x01\x05\x01\x05\x01\x05\x01\0\0\0\0\x05\x01\x05\x01\x05\x01\0\0\x05\x01\x05\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\x01\0\0\0\0\x05\x01\x05\x01\0\0\0\0\0\0\0\0\0\0\x05\x01\x05\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\x01\0\0\0\0\x05\x01\0\0\0\0\x02\x01\x05\x01\x05\x01\0\0\x05\x01\0\0\0\0\x05\x01\x05\x01\0\0\0\0\0\0\0\0\0\0\0\0\x05\x01\0\0\x05\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\x01\x05\x01\0\0\x05\x01\x05\x01\x05\x01\x05\x01\0\0\0\0\0\0\0\0\0\0\x05\x01\0\0\x05\x01\0\0\0\0\x05\x01\x04\x01\0\0\x05\x01\x04\x01\0\0\0\0\x05\x01\0\0\x04\x01\x04\x01\x04\x01\0\0\0\0\x04\x01\x04\x01\0\0\x04\x01\x04\x01\x04\x01\x04\x01\x04\x01\x04\x01\0\0\0\0\x04\x01\x04\x01\x04\x01\0\0\x04\x01\x04\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\x01\0\0\0\0\x04\x01\x04\x01\0\0\0\0\0\0\0\0\0\0\x04\x01\x04\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\x01c\x01\0\0\x04\x01\0\0\0\0\0\0\x04\x01\x04\x01\0\0\x04\x01\0\0\0\0\x04\x01\x04\x01\0\0\0\0\0\0\0\0\0\0\0\0\x04\x01\0\0\x04\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\x01\x04\x01\0\0\x04\x01\x04\x01\x04\x01\x04\x01\0\0\0\0\0\0\0\0\0\0\x04\x01d\x01\x04\x01\0\0d\x01\x04\x01\0\0\0\0\x04\x01d\x01\0\0d\x01\x04\x01\0\0d\x01d\x01\0\0d\x01d\x01d\x01d\x01d\x01d\x01\0\0\0\0d\x01d\x01d\x01\0\0d\x01d\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\x01\0\0\0\0d\x01d\x01\0\0\0\0\0\0\0\0\0\0d\x01d\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\t\x01\0\0\0\0\0\0d\x01\0\0\0\0d\x01\0\0\0\0\0\0d\x01d\x01\0\0d\x01\0\0\0\0d\x01d\x01\0\0\0\0\0\0\0\0\0\0\0\0d\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\x01d\x01\0\0d\x01d\x01d\x01d\x01\0\0\0\0\0\0\0\0\0\0d\x01\x02\x01d\x01\0\0\x02\x01d\x01\0\0\0\0d\x01\x02\x01\0\0\x02\x01d\x01\0\0\x02\x01\x02\x01\0\0\x02\x01\x02\x01\x02\x01\x02\x01\x02\x01\x02\x01\0\0\0\0\x02\x01\x02\x01\x02\x01\0\0\x02\x01\x02\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\x01\0\0\0\0\x02\x01\x02\x01\0\0\0\0\0\0\0\0\0\0\x02\x01\x02\x01\0\0\0\0\0\0\xed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\x01\0\0\0\0\x02\x01\0\0\0\0\0\0\x02\x01\x02\x01\0\0\x02\x01\0\0\0\0\x02\x01\x02\x01\0\0\0\0\0\0\0\0\0\0\0\0\x02\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\x01\x02\x01\0\0\x02\x01\x02\x01\x02\x01\x02\x01\0\0\0\0\0\0\0\0\0\0\x02\x01c\x01\x02\x01\0\0c\x01\x02\x01\0\0\0\0\x02\x01c\x01\0\0c\x01\x02\x01\0\0c\x01c\x01\0\0c\x01c\x01c\x01c\x01c\x01c\x01\0\0\0\0c\x01c\x01c\x01\0\0c\x01c\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0c\x01\0\0\0\0c\x01c\x01\0\0\0\0\0\0\0\0\0\0c\x01c\x01\0\0\0\0\0\0\f\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0c\x01\0\0\0\0c\x01\0\0\0\0\0\0c\x01c\x01\0\0c\x01\0\0\0\0c\x01c\x01\0\0\0\0\0\0\0\0\0\0\0\0c\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0c\x01c\x01\0\0c\x01c\x01c\x01c\x01\0\0\t\x01\0\0\0\0\t\x01c\x01\0\0c\x01\0\0\t\x01c\x01\t\x01\0\0c\x01\t\x01\t\x01\0\0c\x01\t\x01\0\0\t\x01\t\x01\t\x01\0\0\0\0\t\x01\t\x01\t\x01\0\0\t\x01\t\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\t\x01\0\0\0\0\t\x01\t\x01\0\0\0\0\0\0\0\0\0\0\t\x01\t\x01\0\0\0\0\0\0\x0b\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\t\x01\0\0\0\0\t\x01\0\0\0\0\0\0\t\x01\t\x01\0\0\t\x01\0\0\0\0\t\x01\t\x01\0\0\0\0\0\0\0\0\0\0\0\0\t\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\t\x01\t\x01\0\0\t\x01\t\x01\t\x01\t\x01\0\0\xed\0\0\0\0\0\xed\0\t\x01\0\0\t\x01\0\0\xed\0\t\x01\xed\0\0\0\t\x01\xed\0\xed\0\0\0\t\x01\xed\0\0\0\xed\0\xed\0\xed\0\0\0\0\0\xed\0\xed\0\xed\0\0\0\xed\0\xed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xed\0\0\0\0\0\xed\0\xed\0\0\0\0\0\0\0\0\0\0\0\xed\0\xed\0\0\0\0\0\0\0\n\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xed\0\0\0\0\0\xed\0\0\0\0\0\0\0\xed\0\xed\0\0\0\xed\0\0\0\0\0\xed\0\xed\0\0\0\0\0\0\0\0\0\0\0\0\0\xed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xed\0\xed\0\0\0\xed\0\xed\0\xed\0\xed\0\0\0\0\0\0\0\0\0\0\0\xed\0\f\x01\xed\0\0\0\f\x01\xed\0\0\0\0\0\xed\0\f\x01\0\0\f\x01\xed\0\0\0\f\x01\f\x01\0\0\0\0\f\x01\0\0\f\x01\f\x01\f\x01\0\0\0\0\f\x01\f\x01\f\x01\0\0\f\x01\f\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\x01\0\0\0\0\f\x01\f\x01\0\0\0\0\0\0\0\0\0\0\f\x01\f\x01\0\0\0\0\0\0\xcb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\x01\0\0\0\0\f\x01\0\0\0\0\0\0\f\x01\f\x01\0\0\f\x01\0\0\0\0\f\x01\f\x01\0\0\0\0\0\0\0\0\0\0\0\0\f\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\x01\f\x01\0\0\f\x01\f\x01\f\x01\f\x01\0\0\x0b\x01\0\0\0\0\x0b\x01\f\x01\0\0\f\x01\0\0\x0b\x01\f\x01\x0b\x01\0\0\f\x01\x0b\x01\x0b\x01\0\0\f\x01\x0b\x01\0\0\x0b\x01\x0b\x01\x0b\x01\0\0\0\0\x0b\x01\x0b\x01\x0b\x01\0\0\x0b\x01\x0b\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0b\x01\0\0\0\0\x0b\x01\x0b\x01\0\0\0\0\0\0\0\0\0\0\x0b\x01\x0b\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0b\x01\0\0y\x02\x0b\x01\0\0\0\0\0\0\x0b\x01\x0b\x01\0\0\x0b\x01t\0\0\0\x0b\x01\x0b\x01\0\0\0\0\0\0\0\0\0\0\0\0\x0b\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0b\x01\x0b\x01\0\0\x0b\x01\x0b\x01\x0b\x01\x0b\x01\0\0\n\x01\0\0\0\0\n\x01\x0b\x01\0\0\x0b\x01\0\0\n\x01\x0b\x01\n\x01\0\0\x0b\x01\n\x01\n\x01\0\0\x0b\x01\n\x01\0\0\n\x01\n\x01\n\x01\0\0\0\0\n\x01\n\x01\n\x01\0\0\n\x01\n\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\n\x01\0\0\0\0\n\x01\n\x01\0\0\0\0\0\0\0\0\0\0\n\x01\n\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\n\x01\0\0\0\0\n\x01\0\0\0\0\0\0\n\x01\n\x01\0\0\n\x01\0\0\0\0\n\x01\n\x01\0\0\xee\0\0\0\0\0\0\0\0\0\n\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\n\x01\n\x01\0\0\n\x01\n\x01\n\x01\n\x01\0\0\0\0\0\0\0\0\0\0\n\x01\xcb\0\n\x01\0\0\xcb\0\n\x01\0\0\0\0\n\x01\xcb\0\0\0\xcb\0\n\x01\0\0\xcb\0\xcb\0\0\0\0\0\xcb\0\0\0\xcb\0\xcb\0\xcb\0\0\0\0\0\xcb\0\xcb\0\xcb\0\0\0\xcb\0\xcb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xcb\0\0\0\0\0\xcb\0\xcb\0\0\0\0\0\0\0\0\0\0\0\xcb\0\xcb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xcb\0\0\0\0\0\xcb\0\0\0\0\0\0\0\xcb\0\xcb\0\0\0\xcb\0\0\0\0\0\xcb\0\xcb\0\0\0\0\0\0\0\0\0\0\0\0\0\xcb\0,\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xcb\0\xcb\0\0\0\xcb\0\0\0\xcb\0\xcb\0\0\0\0\0\0\0\0\0\0\0\xcb\0\0\0\xcb\0\0\0\0\0\xcb\0\0\0y\x02\xcb\0y\x02y\x02y\x02\xcb\0\0\0\0\0y\x02t\0\0\0\0\0\0\0y\x02\0\0\0\0\0\0y\x02y\x02y\x02\0\0\0\0t\0\0\0\0\0\0\0y\x02y\x02y\x02y\x02\0\0\0\0\0\0\0\0\0\0t\0y\x02t\0t\0\0\0\0\0y\x02\0\0\0\0\0\0\0\0\0\0y\x02y\x02\x89\0t\0\x8a\0\x8b\0 \0\0\0\x8c\0\0\0\0\0\xb1\x01\xf3\x02\0\0y\x02\0\0\0\0y\x02y\x02\0\0y\x02y\x02y\x02t\0y\x02\x04\x02t\0y\x02y\x02\0\0t\0t\0\0\0\0\0\0\0y\x02\0\0t\0\x91\0\0\0\0\0\0\0\0\0\0\0t\0\x92\0y\x02y\x02\0\0y\x02y\x02y\x02y\x02\0\0\0\0y\x02t\0\x93\0\x94\0\0\0t\0t\0\0\0y\x02y\x02\0\0y\x02\0\0\xee\0\0\0y\x02\xee\0t\0\0\0\0\0t\0\xee\0\0\0\xee\0\0\0\0\0\xee\0\xee\0\0\0\0\0\xee\0\0\0\xee\0\xee\0\xee\0\0\0\0\0\xee\0\0\0\xee\0\0\0\xee\0\xee\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xee\0\0\0\0\0\xee\0\xee\0\0\0\0\0\0\0\0\0\0\0\xee\0\xee\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\x02\0\0\0\0\xee\0\0\0\0\0\xee\0\0\0\0\0\0\0\xee\0\xee\0\0\0\xee\0\0\0\0\0\xee\0\xee\0\0\0\0\0\0\0\0\0\0\0\0\0\xee\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xee\0\xee\0\0\0\xee\0\xee\0\xee\0\xee\0\0\0\0\0\0\0\0\0\0\0\xee\0\0\0\xee\0\0\0\0\0\xee\0\0\0,\x02\xee\0,\x02,\x02,\x02\xee\0\0\0\0\0,\x02\0\0\0\0\0\0\0\0,\x02\0\0\0\0\0\0,\x02,\x02,\x02\0\0\0\0\0\0\0\0\0\0\0\0,\x02,\x02,\x02,\x02\0\0\0\0\0\0\0\0\0\0\0\0,\x02\0\0\0\0\0\0\0\0,\x02\0\0\0\0\0\0\0\0\0\0,\x02,\x02-\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0,\x02\0\0\0\0,\x02\0\0\0\0,\x02,\x02,\x02\0\0,\x02\0\0\0\0,\x02,\x02\0\0\0\0\0\0\0\0\0\0\0\0,\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0,\x02,\x02\0\0,\x02,\x02,\x02,\x02\0\0\x04\x02\0\0\x04\x02\x04\x02\x04\x02\0\0\0\0\0\0\x04\x02,\x02\0\0\0\0,\x02\x04\x02\0\0\0\0,\x02\x04\x02\x04\x02\x04\x02\0\0\0\0\0\0\0\0\0\0\0\0\x04\x02\x04\x02\x04\x02\x04\x02\0\0\0\0\0\0\0\0\0\0\0\0\x04\x02\0\0\0\0\0\0\0\0\x04\x02\0\0\0\0\0\0\0\0\0\0\x04\x02\x04\x02\x03\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\x02\0\0\0\0\x04\x02\0\0\0\0\x04\x02\x04\x02\x04\x02\0\0\x04\x02\0\0\0\0\x04\x02\x04\x02\0\0\0\0\0\0\0\0\0\0\0\0\x04\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\x02\x04\x02\0\0\x04\x02\x04\x02\x04\x02\0\0\0\0\x05\x02\x04\x02\x05\x02\x05\x02\x05\x02\0\0\0\0\0\0\x05\x02\x04\x02\0\0\0\0\x04\x02\x05\x02\0\0\0\0\x04\x02\x05\x02\x05\x02\x05\x02\0\0\0\0\0\0\0\0\0\0\0\0\x05\x02\x05\x02\x05\x02\x05\x02\0\0\0\0\0\0\0\0\0\0\0\0\x05\x02\0\0\0\0\0\0\0\0\x05\x02\0\0\0\0\0\0\0\0\0\0\x05\x02\x05\x02\x01\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\x02\0\0\0\0\x05\x02\0\0\0\0\x05\x02\x05\x02\x05\x02\0\0\x05\x02\0\0\0\0\x05\x02\x05\x02\0\0\0\0\0\0\0\0\0\0\0\0\x05\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\x02\x05\x02\0\0\x05\x02\x05\x02\x05\x02\0\0\0\0\0\0\x05\x02-\x02\0\0-\x02-\x02-\x02\0\0\0\0\x05\x02-\x02\0\0\x05\x02\0\0\0\0-\x02\x05\x02\0\0\0\0-\x02-\x02-\x02\0\0\0\0\0\0\0\0\0\0\0\0-\x02-\x02-\x02-\x02\0\0\0\0\0\0\0\0\0\0\0\0-\x02\0\0\0\0\0\0\0\0-\x02\0\0\0\0\0\0\0\0\0\0-\x02-\x02\x02\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0-\x02\0\0\0\0-\x02\0\0\0\0-\x02-\x02-\x02\0\0-\x02\0\0\0\0-\x02-\x02\0\0\0\0\0\0\0\0\0\0\0\0-\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0-\x02-\x02\0\0-\x02-\x02-\x02-\x02\0\0\x03\x02\0\0\x03\x02\x03\x02\x03\x02\0\0\0\0\0\0\x03\x02-\x02\0\0\0\0-\x02\x03\x02\0\0\0\0-\x02\x03\x02\x03\x02\x03\x02\0\0\0\0\0\0\0\0\0\0\0\0\x03\x02\x03\x02\x03\x02\x03\x02\0\0\0\0\0\0\0\0\0\0\0\0\x03\x02\0\0\0\0\0\0\0\0\x03\x02\0\0\0\0\0\0\0\0\0\0\x03\x02\x03\x02\0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03\x02\0\0\0\0\x03\x02\0\0\0\0\x03\x02\x03\x02\x03\x02\0\0\x03\x02\0\0\0\0\0\0\x03\x02\0\0\0\0\0\0\0\0\0\0\0\0\x03\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03\x02\x03\x02\0\0\x03\x02\x03\x02\x03\x02\x03\x02\0\0\x01\x02\0\0\x01\x02\x01\x02\x01\x02\0\0\0\0\xc1\0\x01\x02\x03\x02\0\0\0\0\x03\x02\x01\x02\0\0\0\0\x03\x02\x01\x02\x01\x02\x01\x02\0\0\0\0\0\0\0\0\0\0\0\0\x01\x02\x01\x02\x01\x02\x01\x02\0\0\0\0\0\0\0\0\0\0\0\0\x01\x02\0\0\0\0\0\0\0\0\x01\x02\0\0\0\0\0\0\0\0\0\0\x01\x02\x01\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0R\0\0\0\0\0\0\0\x01\x02\0\0\0\0\x01\x02\0\0\0\0\x01\x02\x01\x02\x01\x02\0\0\x01\x02\0\0\0\0\0\0\x01\x02\0\0\0\0\0\0\0\0\0\0\0\0\x01\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\x02\x01\x02\0\0\x01\x02\x01\x02\x01\x02\x01\x02\0\0\0\0\0\0\x02\x02\0\0\x02\x02\x02\x02\x02\x02\0\0\0\0\x01\x02\x02\x02\0\0\x01\x02\0\0\0\0\x02\x02\x01\x02\0\0\0\0\x02\x02\x02\x02\x02\x02\0\0\0\0\0\0\0\0\0\0\0\0\x02\x02\x02\x02\x02\x02\x02\x02\0\0\0\0\0\0\0\0\0\0\0\0\x02\x02\0\0\0\0\0\0\0\0\x02\x02\0\0\0\0\0\0\0\0\0\0\x02\x02\x02\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\x02\0\0\0\0\x02\x02\0\0\0\0\x02\x02\x02\x02\x02\x02\xe2\x02\x02\x02\0\0\0\0\0\0\x02\x02\0\0\0\0\0\0\0\0\0\0\0\0\x02\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\x02\x02\x02\0\0\x02\x02\x02\x02\x02\x02\x02\x02\0\0\0\x02\0\0\0\x02\0\x02\0\x02\0\0\0\0\0\0\0\x02\x02\x02\0\0\0\0\x02\x02\0\x02\0\0\0\0\x02\x02\0\x02\0\x02\0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\x02\0\x02\0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\0\0\0\0\0\0\0\0\x02\0\0\0\0\0\0\0\0\0\0\0\x02\0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xc1\0\0\0\0\x02\xc1\0\0\0\0\x02\0\0\0\0\0\x02\0\x02\0\x02\0\0\0\x02\xc1\0\0\0\0\0\0\x02\0\0\0\0\xc1\0\0\0\0\0\x81\0\0\x02\0\0\0\0\xc1\0\xc1\0\xc1\0\xc1\0\0\0\0\0\0\0\0\0\0\x02\0\x02\0\0\0\x02\0\x02\0\x02\0\x02\xc1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0R\0\0\x02\0\0R\0\0\x02\0\0\0\0\0\0\0\x02\0\0\0\0\xc1\0\0\0R\0\xc1\0\0\0\0\0\0\0\xc1\0\xc1\0\0\0\0\0\0\0\0\0\0\0\xc1\0R\0R\0R\0R\0\0\0\0\0\xc1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0R\0\0\0\0\0\xc1\0\0\0\xc1\0\0\0\xc1\0\xc1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xc1\0R\0\0\0\xc1\0R\0\0\0\0\0\xc1\0R\0R\0\0\0\0\0\0\0\0\0\0\0R\0\0\0\0\0\0\0y\0\0\0\0\0R\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0R\0\0\0R\0\0\0R\0R\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0R\0\0\0\0\0R\0\0\0\0\0\xe2\x02R\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xa9\x01\xe2\x02\0\0\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\0\0\xe2\x02\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\t\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\x0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0f\0\x10\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\x17\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0!\0\0\0\0\0\"\0#\0$\0\0\0\0\0%\0&\0\0\0'\0(\0\0\0)\0\0\0*\0+\0\0\0,\0r\x02-\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\0z\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\x004\x005\x006\0\t\0\n\0\x0b\0\0\x007\0\0\0\f\0\r\0\x0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0f\0\x10\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\x17\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0!\0\0\0\0\0\"\0#\0$\0\0\0\0\0%\0&\0\0\0'\0(\0\0\0)\0\0\0*\0+\0\0\0,\0\0\0-\0\0\0\0\0\0\0.\0/\0\x87\x010\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0z\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\x004\x005\x006\0\0\0\0\0\0\0\0\x007\0\0\0\0\0\0\0\0\0\t\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\x0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0f\0\x10\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\x17\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0!\0\0\0\0\0\"\0#\0$\0\0\0\0\0%\0&\0\0\0'\0(\0\0\0)\0\0\0*\0+\0\0\0,\0\0\0-\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0z\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\x84\x003\x004\x005\x006\0\0\0\0\0r\x02\0\x007\0\0\0r\x02\0\0r\x02\0\0r\x02\0\0r\x02\0\0r\x02r\x02r\x02r\x02\0\0r\x02r\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0r\x02r\x02r\x02r\x02r\x02r\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0r\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0r\x02r\x02r\x02r\x02r\x02r\x02\0\0r\x02r\x02\0\0\0\0r\x02r\x02\0\0\0\0r\x02r\x02r\x02r\x02r\x02r\x02\0\0k\x02r\x02\0\0r\x02r\x02\0\0r\x02\0\0\0\0\0\0\0\0r\x02r\x02\0\0\0\0r\x02\0\0\0\0\0\0\0\0r\x02\0\0r\x02r\x02\0\0r\x02r\x02r\x02r\x02\0\0\0\0\0\0r\x02\0\0\0\0r\x02\0\0r\x02\0\0r\x02r\x02r\x02\0\0\x87\x01r\x02\0\0\0\0\x87\x01\0\0\x87\x01\0\0\x87\x01\0\0\x87\x01\0\0\x87\x01\0\0\x87\x01\x87\x01\x85\0\x87\x01\x87\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x87\x01\0\0\0\0\x87\x01\x87\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x87\x01\x87\x01\x87\x01\x87\x01\0\0\x87\x01\0\0\x87\x01\x87\x01\0\0\0\0\x87\x01\0\0\0\0\0\0\0\0\x87\x01\x87\x01\x87\x01\0\0\0\0\0\0\0\0\x87\x01\0\0\x87\x01\x80\0\x82\0\x87\x01\0\0\x82\0\x82\0\0\0\0\0\x87\x01\0\0\0\0\x87\x01\0\0\0\0\x82\0\x82\0\x87\x01\0\0\x87\x01\x87\x01\x82\0\x87\x01\x87\x01\0\0\x87\x01\0\0\0\0\x82\0\x87\x01\x82\0\x82\0\x87\x01\0\0\x87\x01\0\0\0\0\x87\x01\x87\x01\0\0\0\0\x87\x01\0\0\x82\0\0\0\0\0\0\0\0\0\0\0\x82\0\x82\0\x82\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84\0\0\0\x82\0\x84\0\x84\0\x82\0\0\0\0\0\x82\0\x82\0\x82\0\0\0\x82\0\x84\0\x84\0\0\0\x82\0\0\0\0\0\x84\0\0\0\0\0\0\0\x82\0\0\0\0\0\x84\0\0\0\x84\0\x84\0\0\0\0\0\0\0\0\0\0\0\x82\0\0\0\x82\0\0\0\x82\0\x82\0\x84\0\0\0\0\0\0\0\0\0\0\0\x84\0\x84\0\xb2\0\0\0\x82\0\0\0\0\0\x82\0\0\0\0\0\0\0\0\0\0\0\0\0\x84\0\0\0\0\0\x84\0\0\0\0\0\x84\0\x84\0\x84\0\0\0\x84\0\0\0\0\0\0\0\x84\0\0\0\0\0k\x02\0\0\0\0k\x02\x84\0\0\0\0\0\0\0k\x02\0\0\0\0\0\0\0\0k\x02k\x02\0\0\x84\0\0\0\x84\0k\x02\x84\0\x84\0}\x02\0\0\0\0\0\0k\x02\0\0k\x02k\x02\x83\x02\0\0\x84\0\0\0\0\0\x84\0\0\0\0\0\0\0\0\0\x89\0k\x02\x8a\0\x8b\0 \0\0\0\x8c\0\0\0\0\0\xb1\x01G\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x85\0\0\0k\x02\x85\0\x85\0k\x02\0\0}\x02k\x02k\x02k\x02\0\0\0\0\x85\0\x85\0\0\0k\x02\x91\0\0\0\x85\0\0\0\0\0k\x02k\x02\x92\0\0\0\x85\0\0\0\x85\0\x85\0\0\0\xe0\x02\0\0\0\0\0\0k\x02\x93\0\x94\0\0\0k\x02k\x02\x85\0\0\0\0\0\0\0\0\0\0\0\x85\0\x85\0\0\0\0\0k\x02\0\0\0\0k\x02\0\0\0\0\0\0\0\0\x80\0\0\0\x85\0\x80\0\x80\0\x85\0\0\0\0\0\0\0\x85\0\x85\0\0\0\x85\0\x80\0\x80\0\0\0\x85\0\0\0\0\0\x80\0\0\0\0\0\0\0\x85\0\0\0\0\0\x80\0\xd8\x01\x80\0\x80\0\0\0\0\0\0\0\0\0\0\0\x85\0\0\0\x85\0\0\0\x85\0\x85\0\x80\0\0\0\0\0\0\0\0\0\0\0\x80\0\x80\0\0\0\x82\x02\x85\0\0\0\x82\x02\x85\0\0\0\0\0\0\0\0\0\0\0\0\0\x80\0\0\0\x82\x02\x80\0\0\0\0\0\0\0\x80\0\x80\0\0\0\x80\0\0\0\0\0\0\0\x80\0\x82\x02\x82\x02\x82\x02\x82\x02\0\0\0\0\x80\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x02\0\0\0\0\x80\0\0\0\x80\0\0\0\x80\0\x80\0\0\0\0\0\0\0\x06\x02\0\0\0\0\0\0\0\0\0\0\xb2\0\x80\0\x82\x02\xb2\0\x80\0\0\0y\x02\0\0\x82\x02\x82\x02\x82\x02\x06\x02\0\0\xb2\0\0\0y\x02\x82\x02\0\0\0\0\0\0\0\0\0\0\0\0\x82\x02\0\0\0\0\xb2\0\xb2\0\xb2\0\xb2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x02\0\0\x82\x02y\x02\xb2\0\0\0y\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x02y\x02\0\0\x82\x02\0\0\0\0\0\0\0\0\x83\x02\0\0\xb2\0\x83\x02\0\0\0\0\x1a\x02\0\0\xb2\0\xb2\0\xb2\0\0\0\0\0\x83\x02\0\0\x1a\x02\xb2\0\0\0\0\0\0\0\0\0\0\0\0\0\xb2\0\0\0\0\0\x83\x02\x83\x02\x83\x02\x83\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb2\0\0\0\xb2\0\x1a\x02\x83\x02\0\0\x1a\x02\x07\x02\0\0\0\0\0\0\0\0\0\0\0\0\xb2\0\x1a\x02\0\0\xb2\0\0\0\0\0\0\0\0\0\0\0\xe0\x02\x83\x02\0\0\xe0\x02\0\0z\x02\0\0\x83\x02\x83\x02\x83\x02\0\0\0\0\0\0\xe0\x02z\x02\x83\x02\0\0\0\0\0\0\xe0\x02\0\0\0\0\x83\x02\0\0\0\0\0\0\xe0\x02\0\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\x83\x02\0\0\x83\x02z\x02\xe0\x02\xe0\x02z\x02\0\0\0\0\0\0\0\0\xe0\x02\xe0\x02\0\0\x83\x02z\x02\0\0\x83\x02\0\0\xd8\x01\0\0\0\0\xd8\x01\0\0\0\0\xe0\x02\x07\x02\xd8\x01\xe0\x02\0\0\0\0\0\0\xd8\x01\xe0\x02\0\0\xe0\x02f\0\0\0\xd8\x01\xe0\x02\0\0\0\0\0\0\0\0\0\0\xd8\x01\xe0\x02\xd8\x01\xd8\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\x02\0\0\xd8\x01\0\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\x02\0\0\0\0\xe0\x02\0\0\0\0\xd8\x01\0\0\0\0\xd8\x01\0\0\0\0\xd8\x01\xd8\x01\xd8\x01\0\0\0\0\0\0\0\x004\x02\xd8\x01\x06\x02\0\0\0\0\x06\x02\0\0\0\0\xd8\x01\0\0\x06\x02\xd5\x01\0\0\0\0\0\0\x06\x02\0\0\0\0\0\0\x06\x02\xd8\x01\x06\x02\x06\x02\0\0\xd8\x01\xd8\x01\0\0\x06\x02\x06\x02\0\0\x06\x02\x06\x02\x06\x02\0\0\0\0\0\0\xd8\x01\0\0\x06\x02\xd8\x01\0\0\0\0\0\0\x06\x02\0\0\x06\x02\0\0\x06\x02\x06\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\x02\xe0\x02\0\0\x06\x02\0\0\0\0\x06\x02\0\0\0\0\x06\x02\x06\x02\x06\x02\0\0\0\0\0\0\0\0\x06\x02\x06\x02\0\0\0\0\x06\x02\0\0\0\0\x06\x02\x06\x02\xb1\x01\x06\x02\x06\x02\x06\x02\0\0\0\0\0\0\0\0\x06\x02\x06\x02\0\0\x06\x02\0\0\0\0\0\0\x06\x02\x06\x02\0\0\0\0\x04\x02\0\0\0\0\0\0\0\0\0\0\0\0\x07\x02\x06\x02\x06\x02\x07\x02\x06\x02\0\0\x06\x02\0\0\x07\x02\0\0\x06\x02\0\0\0\0\x07\x02\0\0\0\0\0\0\0\0\x06\x02\x07\x02\0\0\x06\x02\0\0\0\0P\0\0\0\x07\x02\0\0\x07\x02\x07\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\x02\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\0\0\x8c\0\0\0\0\0\x8d\0\x8e\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\x02\0\0\xc0\x01\x07\x02\0\0\0\0\x07\x02\x07\x02\x07\x02\0\0\x8f\0\0\0\0\0\x07\x02\x07\x02\0\0\0\0\x07\x02\x90\0\x91\0\x07\x02\x07\x02\xe2\x02\x0b\x02\0\0\x07\x02\x92\0f\0\0\0\0\0\x07\x02\0\0\0\0\x07\x02\0\0\0\0\x07\x02\x07\x02\x93\0\x94\0f\0\x05\x02\0\0\x07\x02\0\0\x07\x02\x07\x02\0\0\0\0\x07\x02\0\0\0\0\x07\x02f\0\0\0f\0f\0\0\0\x07\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\x02\0\0\0\0\x07\x02\xb1\x01\0\0\x07\x02\x07\x02\x07\x02\0\0f\0\0\0\0\0\x07\x02\x07\x02\0\0\0\0\xd5\x01f\0\0\0\xd5\x01\x07\x02\0\0\0\0f\0\xd5\x01\0\0\0\0\0\0\0\0\xd5\x01f\0\0\0\x07\x02\0\0\0\0\xd5\x01\x07\x02\0\0\0\0\0\0\x07\x02\0\0\xd5\x01\0\0\xd5\x01\xd5\x01f\0\0\0\x07\x02\0\0\0\0\x07\x02\0\0\0\0\0\0\0\0\0\0\xd5\x01f\0\0\0\0\0f\0\xb2\x01\0\0\0\0\0\0\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd5\x01\0\0\xe0\x02\xd5\x01\0\0\0\0\xd5\x01\xd5\x01\xd5\x01\0\0\0\0\0\0\0\0\xb1\x01\xd5\x01\xe0\x02\xb1\x01\xe0\x02\xe0\x02\0\0\0\0\xd5\x01\0\0\0\0\0\0\0\0\xb1\x01\0\0\0\0\0\0\xe0\x02\0\0\xb1\x01\xd5\x01\0\0\0\0\0\0\xd5\x01\xd5\x01\xb1\x01\0\0\xb1\x01\xb1\x01\0\0\xb4\x01\0\0\0\0\0\0a\0\xd5\x01\xe0\x02\0\0\xd5\x01\0\0\xb1\x01\0\0\0\0\0\0\xe0\x02\0\0\0\0\0\0\0\0P\0\xe0\x02\0\0P\0\0\0\0\0\0\0\0\0\xe0\x02\0\0\0\0\xb1\x01\0\0P\0\xb1\x01\0\0\0\0\0\0\xb1\x01\xb1\x01\0\0\0\0\0\0\0\0\xe0\x02\xb1\x01P\0P\0P\0P\0\0\0\0\0\xb1\x01\0\0\0\0\0\0\xe0\x02\0\0y\x02\xe0\x02\xb3\x01P\0\0\0\0\0\xb1\x01\0\0\0\0\0\0\xb1\x01\xb1\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\xb1\x01P\0\xe2\x02\xb1\x01P\0\0\0\0\0\xe2\x02P\0P\0\0\0\0\0\xe2\x02\0\0\0\0P\0\0\0\0\0\xe2\x02\0\0\0\0\0\0P\0\0\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\0\0e\0\0\0\0\0\0\0P\0\0\0P\0\0\0P\0P\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\xb5\x01\0\0\0\0P\0\0\0\0\0P\0\0\0\0\0\0\0\0\0\0\0\xb1\x01\xe2\x02\0\0\xb1\x01\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02\0\0\0\0\0\0\xb1\x01\0\0\xe2\x02\0\0\0\0\0\0\xb1\x01\0\0\0\0\xe2\x02\0\0\0\0\0\0\xb1\x01\0\0\xb1\x01\xb1\x01\0\0\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02\0\0\xb1\x01\0\0\0\0\0\0\0\0\0\0\xb8\x01\0\0\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\xb2\x01\0\0\xb1\x01\xb2\x01\0\0\xb1\x01\0\0\0\0\0\0\xb1\x01\xb1\x01\0\0\0\0\xb2\x01\0\0\0\0\xb1\x01\0\0\0\0\xb2\x01\0\0\0\0\0\0\xb1\x01\0\0\0\0\xb2\x01\0\0\xb2\x01\xb2\x01\0\0\0\0\0\0\0\0\0\0\xb1\x01\0\0\0\0\xe2\x02\xb1\x01\xb1\x01\xb2\x01\0\0\0\0\0\0\0\0\0\0u\0\0\0\0\0\0\0\xb1\x01\0\0\0\0\xb1\x01\0\0\0\0\0\0\0\0\xb4\x01\0\0\xb2\x01\xb4\x01a\0\xb2\x01\0\0\0\0\0\0\xb2\x01\xb2\x01\0\0\0\0\xb4\x01\0\0\0\0\xb2\x01a\0\0\0\xb4\x01\0\0\0\0\0\0\xb2\x01\0\0\0\0\xb4\x01\0\0\xb4\x01\xb4\x01a\0\0\0a\0a\0\0\0\xb2\x01\0\0\0\0\xa8\x01\xb2\x01\xb2\x01\xb4\x01\0\0\0\0\0\0a\0\0\0\0\0\0\0\0\0\0\0\xb2\x01\0\0\0\0\xb2\x01\0\0\0\0\0\0\0\0\xb3\x01\0\0\xb4\x01\xb3\x01\0\0\xb4\x01a\0\0\0\0\0\xb4\x01\xb4\x01\0\0\0\0\xb3\x01a\0\0\0\xb4\x01\0\0\0\0\xb3\x01a\0\0\0\0\0\xb4\x01\0\0\0\0\xb3\x01a\0\xb3\x01\xb3\x01\0\0\0\0\0\0\0\0\0\0\xb4\x01\0\0\0\0\xe0\x02\xb4\x01\xb4\x01\xb3\x01\0\0a\0\0\0\0\0\0\0\0\0\0\0\0\0e\0\xb4\x01\0\0\0\0\xb4\x01a\0\0\0\0\0a\0\0\0\0\0\xb3\x01\0\0e\0\xb3\x01\0\0\0\0\xb5\x01\xb3\x01\xb3\x01\xb5\x01\0\0\0\0\0\0\0\0\xb3\x01e\0\0\0e\0e\0\xb5\x01\0\0\xb3\x01\xe0\x02\0\0\0\0\xb5\x01\0\0\0\0\0\0\0\0e\0\0\0\xb5\x01\xb3\x01\xb5\x01\xb5\x01\0\0\xb3\x01\xb3\x01\0\0\0\0\0\0\0\0\0\0E\0\0\0\0\0\xb5\x01\0\0\xb3\x01e\0\0\0\xb3\x01\0\0\0\0\0\0\0\0\0\0e\0\0\0\0\0\0\0\0\0\0\0e\0\xb8\x01\0\0\xb5\x01\xb8\x01\0\0\xb5\x01e\0\0\0\0\0\xb5\x01\xb5\x01\0\0\0\0\xb8\x01\0\0\0\0\xb5\x01\0\0\0\0\xb8\x01\0\0\0\0e\0\xb5\x01F\0\0\0\xb8\x01\0\0\xb8\x01\xb8\x01\0\0\0\0\0\0\0\0e\0\xb5\x01\0\0e\0\0\0\xb5\x01\xb5\x01\xb8\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\xb5\x01\0\0\0\0\xb5\x01\0\0\0\0\0\0\xe2\x02u\0\0\0\xb8\x01\0\0\xe2\x02\xb8\x01\0\0\0\0\0\0\xb8\x01\xb8\x01\0\0\0\0u\0\0\0\xd5\x01\xb8\x01\xe2\x02\0\0\xe2\x02\xe2\x02\0\0\0\0\xb8\x01\xd5\x01\0\0u\0\0\0u\0u\0\0\0\0\0\xe2\x02\0\0\0\0\xb8\x01\0\0\0\0\0\0\xb8\x01\xb8\x01u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa8\x01\xb8\x01\xe2\x02\0\0\xb8\x01\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02u\0\0\0\xa8\x01u\0\0\0\xe2\x02\0\0u\0u\0\0\0\0\0\0\0\xe2\x02\0\0u\0\xa8\x01\0\0\xa8\x01\xa8\x01\0\0\0\0u\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02\xa8\x01\0\0\0\0u\0\0\0\0\0\0\0u\0u\0\0\0\xe2\x02\xe0\x02\0\0\xe2\x02\0\0\0\0\0\0\0\0\xe0\x02u\0\xa8\x01\xe0\x02u\0\xa8\x01\0\0\0\0\0\0\xa8\x01\xa8\x01\0\0\0\0\xe0\x02\0\0{\0\xa8\x01\0\0\0\0\0\0\0\0\0\0\0\0\xa8\x01\0\0\0\0\xe0\x02\0\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0\0\0\xa8\x01\0\0|\0\0\0\xa8\x01\xa8\x01\xe0\x02\0\0\0\0\0\0\xe0\x02\0\0\0\0\0\0\0\0\0\0\xa8\x01\0\0\0\0\xa8\x01\0\0\0\0\0\0\xe0\x02\0\0\0\0\xe0\x02\0\0\0\0\xe0\x02\0\0\0\0E\0\0\0\xe0\x02E\0\xe0\x02\0\0\xe0\x02\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0E\0\0\0\xe0\x02\0\0\0\0\0\0\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0E\0\xe0\x02E\0E\0\0\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\xe0\x02E\0E\0\xe0\x02\xe0\x02\0\0F\0\xe0\x02\xe0\x02F\0\xe2\x02\0\0\0\0\0\0\xe0\x02\0\0\0\0\0\0\0\0F\0\xe2\x02\xe0\x02E\0\0\0\0\0E\0\0\0\0\0\0\0E\0E\0\0\0F\0\xe0\x02F\0F\0E\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0E\0\0\0\0\0F\0F\0\0\0\xe0\x02\0\0\0\0\xe0\x02\0\0\0\0E\0\xd5\x01\0\0\0\0E\0E\0\0\0\0\0\0\0\xd5\x01\xd5\x01\0\0F\0\0\0\xd5\x01F\0E\0\0\0\0\0F\0F\0\0\0\0\0\xd5\x01\0\0\0\0F\0\xd5\x01\0\0\xd5\x01\xd5\x01\0\0\xe0\x02F\0\0\0\0\0\xd5\x01\0\0\xd5\x01\xd5\x01\0\0\0\0\xd5\x01\0\0\0\0F\0\0\0\0\0\0\0F\0F\0\xd5\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0F\0\xd5\x01\0\0\0\0\xd5\x01\0\0\0\0\xd5\x01\xd5\x01\xd5\x01\xd5\x01\0\0\0\0\xd5\x01\0\0\xd5\x01\xd5\x01\xd5\x01\xd5\x01\0\0\0\x006\0\xd5\x01\0\0\xd5\x01\0\0\0\0\xe0\x02\0\0\0\0\xe0\x02\xd5\x01\0\0\0\0\xd5\x01\0\0\0\0\0\0\xd5\x01\xd5\x01\xe0\x02\0\0\0\0\xd5\x01\0\0\0\0\0\0\xd5\x01\xd5\x01{\0\xd5\x01\0\0{\0\xe0\x02\0\0\xe0\x02\xe0\x02\0\0\0\0\xd5\x018\0\0\0{\0\0\0\0\0\0\0\0\0\xe0\x02\xe0\x02\0\0\0\0|\0\0\0\0\0|\0{\0\0\0{\0{\0\0\0\0\0\0\0\0\0\0\0|\0\0\0\0\0\0\0\xe0\x02\0\0{\0\xe0\x02\0\0\0\0\0\0\0\0\xe0\x02|\0\0\0|\0|\0\0\0\xe0\x02\0\0<\0\0\0\0\0\0\0\0\0\xe0\x02{\0\0\0|\0{\0\0\0\0\0\0\0{\0{\0\0\0\0\0\xe0\x02\0\0\0\0{\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0{\0|\0\0\0\0\0|\0\0\0\xe0\x02\0\0|\0|\0\0\0\0\0{\0\0\0\0\0|\0{\0{\0?\0\xe2\x02\0\0\0\0|\0\0\0\0\0\0\0\0\0\xe2\x02{\0\xe2\x02\0\0\0\0\xe2\x02\0\0|\0\0\0\0\0\0\0|\0|\0@\0\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\xe0\x02|\0\0\0\0\0\0\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\0\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02\0\0\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\0\0\xe0\x02\xe2\x02\xe2\x02\xe0\x02\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\0\0\0\0\0\0\xe0\x02\0\0\xe2\x02\0\0\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02\0\0\0\0\0\0\xe0\x02\xe2\x02\xe0\x02\xe0\x02\0\0\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\x02\0\0\xe2\x02\0\0'\x02\0\0'\x02'\x02'\x026\0'\x02\0\0\0\0'\x02'\x02\0\0\0\0\0\0\0\0\0\0\xe0\x02\0\x006\0\xe0\x02\0\0\0\0\0\0\0\0\xe0\x02\0\0\0\0'\x02\0\0\0\0\xe0\x026\0\0\x006\x006\0'\x02'\x02\xe0\x02\0\0\0\0\0\0\0\0\0\0'\x028\0\0\x006\0\0\0\0\0\xe0\x02\0\0\0\0\0\0\xe0\x02\xe0\x02'\x02'\x028\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\x026\0\0\0\0\x006\x008\0\0\x008\x008\x006\0\0\0\0\0\0\0\0\0\0\x006\0\0\0\0\0\0\0\0\x008\0\0\x006\0<\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x006\0\0\0<\0\0\x006\x006\x008\0\0\0\0\x008\0\0\0\0\0\0\0\0\x008\0<\x006\0<\0<\0\0\x008\0\0\0\0\0\0\0\0\0\0\0\0\x008\0\0\0\0\0<\0\0\0\0\0\0\0?\0\0\0\0\0\0\0\0\x008\0\0\0\0\0\0\x008\x008\0\0\0\0\0?\0\0\0\0\0<\0\0\0\0\0<\0\0\x008\0@\0\0\0<\0\0\0?\0\0\0?\0?\0<\0\xe0\x02\0\0\0\0\0\0@\0\0\0<\0\0\0\0\0\0\0?\0\0\0\0\0\xe0\x02\0\0\0\0\0\0@\0<\0@\0@\0\0\0<\0<\0\0\0\0\0\xe0\x02\0\0\xe0\x02\xe0\x02?\0\0\0@\0?\0<\0\0\0\0\0\0\0?\0\0\0\0\0\xe0\x02\0\0\0\0?\0\0\0\0\0\0\0\0\0\0\0\0\0?\0@\0\0\0\0\0@\0\0\0\0\0\0\0\0\0@\0\xe0\x02\0\0?\0\xe0\x02\0\0@\0?\0?\0\xe0\x02\0\0\0\0\0\0@\0\0\0\xe0\x02\0\0\0\0\0\0?\0\0\0\0\0\xe0\x02\0\0\0\0@\0\0\0\0\0\0\0@\0@\0\0\0\0\0\0\0\xe0\x02\0\0\0\0\0\0\xe0\x02\xe0\x02\xdb\x02@\0\0\0\0\0\0\0\xdb\x02\xdb\x02\xdb\x02\xdb\x02\0\0\xe0\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\0\0\0\0\0\0\0\0\xdb\x02\0\0\0\0\0\0\0\0\0\0\0\0\xdb\x02\0\0\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\0\0\0\0\0\0\0\0\xdb\x02\0\0\xdb\x02\0\0\0\0\0\0\0\0\0\0\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\0\0\0\0\xdb\x02\xdb\x02\0\0\0\0\xdb\x02\xdb\x02\xdb\x02\xdb\x02\0\0\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\0\0\xdb\x02\0\0\xdb\x02\xdb\x02\0\0\xdb\x02\0\0\xdb\x02\xdb\x02\0\0\0\0\xdb\x02\xdb\x02\0\0\xdb\x02\0\0\xdb\x02\0\0\0\0\xdb\x02\xdb\x02\0\0\0\0\xdb\x02\xdb\x02\0\0\0\0\0\0\xdb\x02\0\0\0\0\xdb\x02\0\0\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\0\0\0\0\xdb\x02#\x01$\x01%\x01\0\0\0\0\t\0\n\0&\x01\0\0'\x01\0\0\f\0\r\0\0\0\0\0(\x01)\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\x01\0\0\0\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0+\x01\0\0\0\0\x16\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\x001\x01\0\0\"\0#\0$\0\0\0\0\0\0\0&\0\0\x002\x013\x01\0\x004\x01\0\0*\0+\0\0\0,\0\0\0\0\0\0\x005\x016\x017\x018\x019\x01:\x01\0\0\0\0\0\0\0\0\0\0\0\0;\x01\0\0\0\0\0\0<\x01\0\0=\x012\0\0\0\0\0\0\0\0\x003\x004\0\0\x006\0#\x01$\x01%\x01\0\x007\0\t\0\n\0&\x01\0\0'\x01\0\0\f\0\r\0\0\0\0\0\0\0)\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\x01\0\0\0\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0+\x01\0\0\0\0\x16\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\x001\x01\0\0\"\0#\0$\0\0\0\0\0\0\0&\0\0\x002\x013\x01\0\x004\x01\0\0*\0+\0\0\0,\0\0\0\0\0\0\x005\x016\x017\x018\x019\x01:\x01\0\0\0\0\0\0\0\0\0\0\0\0;\x01\0\0\0\0\0\0<\x01\0\0=\x012\0\0\0\0\0\0\0\0\x003\x004\0\0\x006\0#\x01$\x01%\x01\0\x007\0\t\0\n\0&\x01\0\0'\x01\0\0\f\0\r\0\0\0\0\0\0\0)\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\x01\0\0\0\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0+\x01\0\0\0\0\x16\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\x001\x01\0\0\"\0#\0$\0\0\0\0\0\0\0&\0\0\x002\x013\x01\0\0Z\x03\0\0*\0+\0\0\0,\0\0\0\0\0\0\x005\x016\x017\x018\x019\x01:\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0<\x01\0\0=\x012\0\0\0\0\0\0\0\xe2\x023\x004\0\0\x006\0\xe2\x02\xe2\x02\xe2\x02\xe2\x027\0\0\0\xe2\x02\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\0\0\xe2\x02\0\0\xe2\x02\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02^\x02\0\0\xe2\x02\0\0\0\0\xa5\x02\xa5\x02\xa5\x02\0\0\0\0\0\0\xa5\x02\xa5\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa5\x02\xa5\x02\xa5\x02\xa5\x02\xa5\x02\0\0\0\0\0\0\0\0\xa5\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa5\x02\xa5\x02\xa5\x02\0\0\xa5\x02\xa5\x02\xa5\x02\xa5\x02\xa5\x02\0\0\0\0\xa5\x02\0\0\0\0\0\0\xa5\x02\xa5\x02\xa5\x02\0\0\0\0\0\0\xa5\x02\0\0\xa5\x02\xa5\x02\0\0\0\0\0\0\xa5\x02\xa5\x02\0\0\xa5\x02\0\0\0\0\0\0\0\0\0\0\xa5\x02\xa5\x02_\x02\xa5\x02\0\0\0\0\0\0\xa6\x02\xa6\x02\xa6\x02^\x02\0\0\0\0\xa6\x02\xa6\x02\0\0\0\0\xa5\x02\0\0\0\0\0\0\0\0\xa5\x02\xa5\x02\0\0\xa5\x02\0\0\0\0\0\0\0\0\xa5\x02\0\0\xa6\x02\xa6\x02\xa6\x02\xa6\x02\xa6\x02\0\0\0\0\0\0\0\0\xa6\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa6\x02\xa6\x02\xa6\x02\0\0\xa6\x02\xa6\x02\xa6\x02\xa6\x02\xa6\x02\0\0\0\0\xa6\x02\0\0\0\0\0\0\xa6\x02\xa6\x02\xa6\x02\0\0\0\0\0\0\xa6\x02\0\0\xa6\x02\xa6\x02\0\0\0\0\0\0\xa6\x02\xa6\x02\0\0\xa6\x02\0\0\0\0\0\0\0\0\0\0\xa6\x02\xa6\x02\\\x02\xa6\x02\0\0\0\0\0\0\xa7\x02\xa7\x02\xa7\x02_\x02\0\0\0\0\xa7\x02\xa7\x02\0\0\0\0\xa6\x02\0\0\0\0\0\0\0\0\xa6\x02\xa6\x02\0\0\xa6\x02\0\0\0\0\0\0\0\0\xa6\x02\0\0\xa7\x02\xa7\x02\xa7\x02\xa7\x02\xa7\x02\0\0\0\0\0\0\0\0\xa7\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa7\x02\xa7\x02\xa7\x02\0\0\xa7\x02\xa7\x02\xa7\x02\xa7\x02\xa7\x02\0\0\0\0\xa7\x02\0\0\0\0\0\0\xa7\x02\xa7\x02\xa7\x02\0\0\0\0\0\0\xa7\x02\0\0\xa7\x02\xa7\x02\0\0\0\0\0\0\xa7\x02\xa7\x02\0\0\xa7\x02\0\0\0\0\0\0\0\0\0\0\xa7\x02\xa7\x02]\x02\xa7\x02\0\0\0\0\0\0\xa8\x02\xa8\x02\xa8\x02\\\x02\0\0\0\0\xa8\x02\xa8\x02\0\0\0\0\xa7\x02\0\0\0\0\0\0\0\0\xa7\x02\xa7\x02\0\0\xa7\x02\0\0\0\0\0\0\0\0\xa7\x02\0\0\xa8\x02\xa8\x02\xa8\x02\xa8\x02\xa8\x02\0\0\0\0\0\0\0\0\xa8\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa8\x02\xa8\x02\xa8\x02\0\0\xa8\x02\xa8\x02\xa8\x02\xa8\x02\xa8\x02\0\0\0\0\xa8\x02\0\0\0\0\0\0\xa8\x02\xa8\x02\xa8\x02\0\0\0\0\0\0\xa8\x02\0\0\xa8\x02\xa8\x02\0\0\0\0\0\0\xa8\x02\xa8\x02\0\0\xa8\x02\0\0\0\0\0\0\0\0\0\0\xa8\x02\xa8\x02\0\0\xa8\x02\0\0\0\0\0\0\0\0\0\0\0\0]\x02\xeb\0\xec\0\xed\0\0\0\0\0\0\0\xa8\x02\0\0\xee\0\0\0\xef\0\xa8\x02\xa8\x02\0\0\xa8\x02\0\0\xf0\0\xf1\0\xf2\0\xa8\x02\0\0\xf3\0\xf4\0\xf5\0\0\0\xf6\0\xf7\0\xf8\0\0\0\xf9\0\xfa\0\xfb\0\xfc\0\0\0\0\0\0\0\xfd\0\xfe\0\xff\0\0\0\0\0\0\0\0\0\0\0\0\x01\x01\x01\0\0\0\0\0\0\0\0\x02\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03\x01\x04\x01\0\0\0\0\0\0\0\0\x05\x01\x06\x01\0\0\0\0\0\0\x07\x01\b\x01\0\0\t\x01\0\0\n\x01\x0b\x01\f\x01\0\0\r\x01\0\0\0\0\0\0\0\0\0\0\x0e\x01\0\0\0\0\0\0\0\0\x0f\x01\0\0\0\0\0\0\0\0\0\0\x10\x01\b\x02\0\0\x11\x01\x12\x01\b\x02\x13\x01\x14\x01\x15\x01\x16\x01\x17\x01\0\0\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\0\0\b\x02\0\0\b\x02\0\0\0\0\xf5\x01\0\0\0\0\0\0\b\x02\b\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\b\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\b\x02\b\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\b\x02\0\0\0\0\0\0\b\x02\0\0\b\x02\b\x02\b\x02\0\0\b\x02\0\0\0\0\b\x02\0\0\0\0\0\0\0\0#\x01$\x01%\x01\0\0\0\0\0\0\n\0\xe1\x01\0\0'\x01\0\0\0\0\r\0\xf5\x01\b\x02\xe2\x01)\x01\0\0\b\x02\0\0\b\x02\0\0\0\0\b\x02\0\0\0\0\0\0*\x01\xa2\0\0\0\x11\0\x12\0\b\x02\0\0\b\x02\0\0+\x01\0\0\0\0\0\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\x001\x01\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\0\0\0\0\xe3\x01\xe4\x01\0\0\xe5\x01\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\x005\x016\x01\xe6\x01\xe7\x019\x01\xe8\x01\0\0\0\0\0\0\0\0\0\0\0\0;\x01\0\0\0\0\xab\0<\x01\0\0=\x012\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0#\x01$\x01%\x01\0\0\0\0\0\0\n\0\xe1\x01\0\0'\x01\0\0\0\0\r\0\0\0\0\0\0\0)\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\x01\xa2\0\0\0\x11\0\x12\0\0\0\0\0\0\0\0\0+\x01\0\0\0\0\0\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\x001\x01\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\0\0\0\0\xe3\x01\xe4\x01\0\0\xe5\x01\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\x005\x016\x01\xe6\x01\xe7\x019\x01\xe8\x01\0\0\0\0\0\0\0\0\0\0\0\0;\x01\0\0\0\0\xab\0<\x01\0\0=\x012\0\0\0\0\0\0\0\0\x003\0\0\0\x01\x036\0\xac\0#\x01$\x01%\x01\0\0\0\0\0\0\n\0\xe1\x01\0\0'\x01\0\0\0\0\r\0\0\0\0\0\0\0)\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\x01\xa2\0\0\0\x11\0\x12\0\0\0\0\0\0\0\0\0+\x01\0\0\0\0\0\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\x001\x01\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\0\0\0\0\xe3\x01\xe4\x01\0\0\xe5\x01\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\x005\x016\x01\xe6\x01\xe7\x019\x01\xe8\x01\0\0\0\0\0\0\0\0\0\0\0\0;\x01\0\0\0\0\xab\0<\x01\0\0=\x012\0\0\0\0\0\0\0\0\x003\0\0\0\xca\x036\0\xac\0#\x01$\x01%\x01\0\0\0\0\0\0\n\0\xe1\x01\0\0'\x01\0\0\0\0\r\0\0\0\0\0\0\0)\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\x01\xa2\0\0\0\x11\0\x12\0\0\0\0\0\0\0\0\0+\x01\0\0\0\0\0\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\x001\x01\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\0\0\0\0\xe3\x01\xe4\x01\0\0\xe5\x01\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\x005\x016\x01\xe6\x01\xe7\x019\x01\xe8\x01\0\0\0\0\0\0\0\0\0\0\0\0;\x01\0\0\0\0\xab\0<\x01\0\0=\x012\0\0\0\0\0\0\0\0\x003\0\0\0\b\x046\0\xac\0#\x01$\x01%\x01\0\0\0\0\0\0\n\0\xe1\x01\0\0'\x01\0\0\0\0\r\0\0\0\0\0\0\0)\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\x01\xa2\0\0\0\x11\0\x12\0\0\0\0\0\0\0\0\0+\x01\0\0\0\0\0\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\x001\x01\0\0\xdd\x02\xa7\0\xa8\0\0\0\0\0\0\0\n\0\0\0\xe3\x01\xe4\x01\0\0\xe5\x01\r\0*\0\0\0\0\0\0\0\0\0\0\0\0\x005\x016\x01\xe6\x01\xe7\x019\x01\xe8\x01\0\0\0\0\xa2\0\0\0\x11\0\x12\0;\x01\0\0\0\0\xab\0<\x01\0\0=\x012\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\xdf\x02\xa7\0\xa8\0\0\0\0\0\0\0\n\0\0\0\xa9\0\0\0\0\0\0\0\r\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\0\0\xa2\0\0\0\x11\0\x12\0\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\xe1\x02\xa7\0\xa8\0\0\0\0\0\0\0\n\0\0\0\xa9\0\0\0\0\0\0\0\r\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\0\0\xa2\0\0\0\x11\0\x12\0\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\0\0\0\0\xa9\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\t\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\x0e\x005\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0f\0\x10\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\x17\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0!\0\0\0\0\0\"\0#\0$\0\0\0\0\0%\0&\0\0\0'\0(\0\0\0)\0\0\0*\0+\0\0\0,\0\0\0-\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\x006\x02\0\0\0\0\t\0\n\0\x0b\0\0\x001\0\0\0\f\0\r\0\x0e\x002\0\0\0\0\0\0\0\0\x003\x004\x005\x006\0\0\0\0\0\0\0\0\x007\0\x0f\0\x10\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\x17\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0!\0\0\0\0\0\"\0#\0$\0\0\0\0\0%\0&\0\0\0'\0(\0\0\0)\0\0\0*\0+\0\0\0,\0\0\0-\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\0\0\0\0\0\t\0\n\0\x0b\0\0\0\0\x001\0\f\0\r\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\x004\x005\x006\0\0\0\0\0\0\0\0\x007\0\0\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\"\0#\0$\0\0\0\0\0\0\0&\0\0\0'\0(\0\0\0\0\0\0\0*\0+\0\0\0,\0\0\0\0\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\0\0\0\0\0\0\0\xe6\0\t\0\n\0\x0b\0\0\0\0\0\xe9\0\f\0\r\x002\0\0\0\0\0\0\0\0\x003\x004\0\0\x006\0\0\0\0\0\0\0\0\x007\0\0\0\0\0\0\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\"\0#\0$\0\0\0\0\0\0\0&\0\0\0'\0(\0\0\0\0\0\0\0*\0+\0\0\0,\0\0\0\0\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\0\0\0\t\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\x004\0\0\x006\0\0\0\x06\x02\0\0\0\x007\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\"\0#\0$\0\0\0\0\0\0\0&\0\0\0'\0(\0\0\0\0\0\0\0*\0+\0\0\0,\0\0\0\0\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\x004\0\0\x006\0\0\0\xe4\x02\0\0\0\x007\0\xe4\x02\xe4\x02\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\0\0\0\0\t\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\"\0#\0$\0\0\0\0\0\0\0&\0\0\0'\0(\0\0\0\0\0\0\0*\0+\0\0\0,\0\0\0\0\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\x004\0\0\x006\0\0\0\0\0\0\0\0\x007\0\xe4\x02\xe4\x02\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\0\0\0\0\0\0\n\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0^\x03\0\0\xe4\x02C\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\0\0\0\0_\x03\0\0\xe4\x02\x11\0\x12\0\xf3\x01\0\0\xf3\x01\xf3\x01\xf3\x01\0\0\xf3\x01\0\0\0\0\xf3\x01\xf3\x01\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\xf3\x01 \0\0\0\0\0\0\0\0\0\xa7\0`\x03\xf3\x01\xf3\x01\0\0\0\0\0\0\xa9\0\n\0\0\0\xf3\x01\0\0*\0\0\0\r\0\0\0B\x02\0\0\x17\x02C\x02\0\0\xaa\0\xf3\x01\xf3\x01\0\0\0\0\x18\x02\0\0\0\0_\x03\0\0\0\0\x11\0\x12\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0`\x03\0\0\0\0\0\0\0\0\0\0\xa9\0\n\0\0\0\0\0\0\0*\0\0\0\r\0\0\0\xb9\x03\0\0\x17\x02\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\x18\x02\0\0\0\0\xba\x03\0\0\0\0\x11\0\x12\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xd4\x01\0\0\0\0\0\0\0\0\0\0\xa9\0\n\0\0\0\0\0\0\0*\0\0\0\r\0\0\0\x92\x05\0\0\x17\x02\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\x18\x02\0\0\0\0_\x03\0\0\0\0\x11\0\x12\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0`\x03\0\0\0\0\0\0\n\0\0\0\xa9\0\0\0\0\0\0\0\r\0*\0\0\0\0\0\0\0\0\0\0\0\x17\x02\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\x18\x02\0\0\0\0\x11\0\x12\0\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\x0b\x03\0\0\0\0\0\0\n\0\0\0\xa9\0\0\0\f\x03\0\0\r\0*\0\0\0\0\0\0\0\0\0\0\0\x17\x02\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\x18\x02\0\0\0\0\x11\0\x12\0\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xd4\x01\0\0\0\0\0\0\n\0\0\0\xa9\0\0\0E\x05\0\0\r\0*\0\0\0\0\0\0\0\0\0\0\0\x17\x02\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\x18\x02\0\0\0\0\x11\0\x12\0\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\x16\x02\0\0\0\0\0\0\n\0\0\0\xa9\0\0\0\0\0\0\0\r\0*\0\0\0\0\0\0\0\0\0\0\0\x17\x02\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\x18\x02\0\0\0\0\x11\0\x12\0\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xd4\x01\0\0\0\0\0\0\xe4\x02\0\0\xa9\0\0\0\0\0\0\0\xe4\x02*\0\0\0\0\0\0\0\0\0\0\0\x17\x02\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\x18\x02\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\xe4\x02\xe4\x02\xe4\x02\xe4\x02\0\0\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\n\0\0\0\xe4\x02\0\0\0\0\0\0\r\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\xa2\0\0\0\x11\0\x12\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\xe4\x02\0\0\0\0\xe4\x02\0\0\xe4\x02\0\0\0\0\xe4\x02\xe4\x02\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\0\0\0\0\xa9\0\0\0\0\0\0\0\n\0*\0\0\0\0\0\xdf\x01\0\0\r\0\0\0\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe6\0\0\0\0\0\0\0\xa2\0\xab\0\x11\0\x12\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\0\0\0\0\xa9\0\xe4\x02\0\0\xe4\x02\0\0*\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\xe4\x02\xe4\x02\xab\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\0\0\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\0\0\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\n\0\xe4\x02\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\xa2\0\xe4\x02\x11\0\x12\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\xe4\x02\0\0\xa9\0\0\0\0\0\0\0\xe4\x02*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\xe4\x02\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xa1\x02\0\0\xe4\x02\0\0\0\0\0\0\xa1\x02\xe4\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\xa1\x02\0\0\xa1\x02\xa1\x02\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\xe4\x02\xe4\x02\xa1\x02\xa1\x02\xa1\x02\0\0\xa1\x02\xa1\x02\0\0\xa1\x02\xa1\x02\0\0\0\0\xa1\x02\0\0\0\0\0\0\0\0\xa1\x02\xa1\x02\0\0\0\0\0\0\x8e\x02\0\0\xa1\x02\0\0\0\0\0\0\x8e\x02\xa1\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa1\x02\0\0\0\0\0\0\0\0\0\0\x8e\x02\0\0\x8e\x02\x8e\x02\0\0\0\0\0\0\xa1\x02\0\0\0\0\0\0\xa1\x02\0\0\0\0\0\0\0\0\xa1\x02\0\0\0\0\xa1\x02\xa1\x02\x8e\x02\x8e\x02\x8e\x02\0\0\x8e\x02\x8e\x02\0\0\x8e\x02\x8e\x02\0\0\0\0\x8e\x02\0\0\0\0\0\0\0\0\x8e\x02\x8e\x02\0\0\0\0\0\0\n\0\0\0\x8e\x02\0\0\0\0\0\0\r\0\x8e\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8e\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\0\x12\0\0\0\0\0\0\0\x8e\x02\0\0\0\0\0\0\x8e\x02\0\0\0\0\0\0\0\0\x8e\x02\0\0\0\0\x8e\x02\x8e\x02\x18\0\x19\0\x1a\0\0\0\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xd4\x01\0\0\0\0\0\0\0\0\0\0\xa9\0\n\0\x0b\0\0\0\0\0*\0\f\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\xaa\0\0\0\0\0|\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\0\x12\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0}\x01\0\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xc0\0\0\0\0\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\0\0*\0+\0\0\0\0\0\0\0\0\0~\x01\0\0\0\0\0\0\0\0\0\x000\0\0\0\x7f\x01\0\0\x11\0\x12\0\0\0\0\0\0\0\0\0\x80\x01\x81\x01\0\0\0\x002\0\0\0\0\0\x82\x01\0\x003\0\0\0\0\x006\0\x18\0\x19\0\x1a\0}\x01\0\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xc0\0\0\0\0\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\0\0*\0+\0\0\0\0\0\0\0\0\0~\x01\0\0\0\0\0\0\0\0\0\x000\0\0\0\x7f\x01\0\0\x11\0\x12\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x002\0\0\0\0\0\x82\x01\0\x003\0\0\0\0\x006\0\x18\0\x19\0\x1a\0\0\0\0\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xc0\0\0\0\0\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\0\0*\0+\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x000\0\0\0\0\0\0\0\x11\0\x12\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\x18\0\x19\0\x1a\0\0\0\0\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xdb\0\xc0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0*\0+\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x04\0\0\0\0\0\x000\0\0\0\0\0\xc8\0\xe4\x02\xe4\x02\x89\0\0\0\x8a\0\x8b\0 \0\x91\x04\x8c\0\0\x002\0\x8d\0\x8e\0\0\0\xc9\x003\0\0\0\0\x006\0\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\xe4\x02\0\0\x8f\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\x90\0\x90\x03\0\0\x89\0\0\0\x8a\0\x8b\0 \0\x92\0\x8c\0\xe4\x02\xe4\x02\x8d\0\x92\x04\0\0\0\0\0\0\0\0\x90\x04\xb7\x05\x93\0\x94\0\xe4\x02\0\0\0\0\xc8\0\0\0\0\0\0\0\0\0\x8f\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\x93\x04\x90\0\x91\0\xc9\0\xe4\x02\0\0\0\0\xe4\x02\0\0\x92\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xcb\0\0\0\0\0\x94\x04\x94\0\0\0\0\0\0\0\0\0\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\0\0\x8c\0\0\0\0\0\x8d\0\x92\x04\0\0\0\0\0\0\0\0\xd3\x03W\x01X\x01\0\0\0\0\0\0\0\0\0\0\0\0Y\x01\0\0\0\0\x8f\0\0\0\xd4\x03Z\x01[\x01\xd5\x03\\\x01\0\0\x90\0\x91\0\0\0\0\0\0\0\0\0\0\0]\x01\x92\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\x01\xcb\0\0\0\0\0\x94\x04\x94\0_\x01`\x01a\x01b\x01c\x01#\x01$\x01%\x01\0\0\0\0\0\0\0\0\xe1\x01\0\0'\x01\0\0\0\0\0\0\0\0\0\0d\x01)\x01\0\0\0\0\0\0\xb9\0\0\0\0\0\0\0\0\0e\x01f\x01*\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0+\x01g\x01h\x01i\x01j\x01k\x01,\x01-\x01.\x01/\x010\x01\0\0\0\0\xd6\x03\0\0\0\0\0\0\0\0\0\0m\x01\0\0\0\0\0\0\0\0\0\0\0\x001\x01\0\0\0\0\0\0W\x01X\x01\0\0\0\0\0\0\0\0\x10\x02\xe4\x01Y\x01\x11\x02\0\0\0\0\0\0\0\0Z\x01[\x01\0\0\\\x015\x016\x01\x12\x02\xe7\x019\x01\xe8\x01\0\0\0\0]\x01\0\0\0\0\0\0\0\0\0\0W\x01X\x01<\x01^\x01=\x01\0\0\0\0\0\0Y\x01_\x01`\x01a\x01b\x01c\x01Z\x01[\x01\0\0\\\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0]\x01\0\0\0\0d\x01\0\0\0\0\0\0\0\0\xb9\0^\x01\0\0\0\0\0\0e\x01f\x01_\x01`\x01a\x01b\x01c\x01\0\0\0\0\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01\0\0\0\0\0\0\0\0\0\0d\x01W\x01X\x01l\x01\0\0\xb9\0\0\0\0\0m\x01Y\x01e\x01f\x01\0\0\0\0\0\0Z\x01[\x01\0\0\\\x01\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01]\x01\0\0\0\0\0\0\x10\x04\0\0W\x01X\x01\0\0^\x01\0\0\0\0\0\0m\x01Y\x01_\x01`\x01a\x01b\x01c\x01Z\x01[\x01\0\0\\\x01\0\0\0\0\0\0\0\0\0\0\0\0r\x04\0\0]\x01\0\0\0\0d\x01\0\0\0\0\0\0\0\0\xb9\0^\x01\0\0\0\0\0\0e\x01f\x01_\x01`\x01a\x01b\x01c\x01\0\0\0\0\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01\0\0\0\0\0\0\0\0?\x04d\x01W\x01X\x01\0\0\0\0\xb9\0\0\0\0\0m\x01Y\x01e\x01f\x01\0\0\0\0\0\0Z\x01[\x01\0\0\\\x01\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01]\x01\0\0\0\0\0\0\0\0\0\0W\x01X\x01\0\0^\x01\0\0\0\0\0\0m\x01Y\x01_\x01`\x01a\x01b\x01c\x01Z\x01[\x01\0\0~\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0]\x01\0\0\0\0d\x01\0\0\0\0\0\0\0\0\xb9\0^\x01\0\0\0\0\0\0e\x01f\x01_\x01`\x01a\x01b\x01c\x01\0\0\0\0\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01\0\0\0\0\0\0\0\0\0\0d\x01\xea\0\xea\0\0\0\0\0\xb9\0\0\0\0\0m\x01\xea\0e\x01f\x01\0\0\0\0\0\0\xea\0\xea\0\0\0\0\0\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01\xea\0\0\0\0\0\0\0\0\0\0\0W\x01X\x01\0\0\xea\0\0\0\0\0\0\0m\x01Y\x01\xea\0\xea\0\xea\0\xea\0\xea\0Z\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0]\x01\0\0\0\0\xea\0\0\0\0\0\0\0\0\0\xea\0^\x01\0\0\0\0\0\0\xea\0\xea\0_\x01`\x01a\x01b\x01c\x01\0\0\0\0\0\0\0\0\0\0\xea\0\xea\0\xea\0\xea\0\xea\0\0\0\0\0\0\0\0\0\xea\0d\x01W\x01X\x01\0\0\0\0\xb9\0\0\0\0\0\xea\0Y\x01e\x01f\x01\0\0\0\0\0\0Z\x01\0\0\0\0\0\0\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01]\x01\0\0\0\0\0\0\0\0\0\0\0\0R\x05\0\0^\x01\0\0\0\0\0\0m\x01\0\0_\x01`\x01a\x01b\x01c\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0W\x01X\x01\0\0\0\0\0\0\0\0\0\0\0\0d\x01\0\0\0\0\0\0\0\0\xb9\0Z\x01\0\0\0\0\0\0e\x01f\x01\0\0\0\0\0\0\0\0\0\0\0\0]\x01\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01^\x01\0\0\0\0\0\0\0\0\0\0_\x01`\x01a\x01b\x01c\x01\0\0\0\0m\x01\0\0\0\0\0\0\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\0\0\x8c\0d\x01\0\0\x8d\0\x8e\0\0\0\xb9\0\0\0\0\0\0\0\0\0e\x01f\x01\xc0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8f\0\0\0\0\0h\x01i\x01j\x01k\x01\0\0\x90\0\x91\0\0\0\0\0\0\0\0\0\0\0\0\0\x92\0\0\0\0\0\0\0m\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x93\0\x94\0",
  check: "\x03\0\x04\0^\0\x06\0\x02\0\x92\0\x02\0>\x01\x0f\0\x83\x01\xa3\0\x89\0\x0e\x02\x8f\0\xa4\0!\x01\n\0\x89\0\xba\x02\xc0\x01\x1d\0\x9e\0\r\x03\x8b\0\t\x02\xd1\0\t\0\xb2\x01\xd5\0\f\0a\x03\x7f\x03\x1f\0$\0\xab\0\x8f\x01\x13\0\x14\0\x15\0\x16\0V\x02\x0b\x007\x03\xf3\x02\x1b\0\xba\x02\f\x02\xd4\0\x0e\x02\xa6\x04\x01\0\"\0\x03\0\x04\0\x02\0&\0\xd1\0\f\x04\x1c\0!\0+\0,\0\xe8\0%\0\xea\0\x03\0\x04\0o\x01\x02\x004\0\x07\0\0\x007\0;\0\0\0\x93\x04\0\0\x02\x000\0\f\x02\x84\0\x0e\x02\x86\0I\x04\x1f\x01b\0\x8a\x04\x8b\x04_\0\x03\0\x02\0\x8c\x01\xbc\x04\x01\0\xd2\0B\x04\x11\x01n\x001\0\x02\0b\0\x02\0b\0U\x04C\x01\xc5\0\x01\x02\x02\x02;\0A\x01\0\0\x0f\x01n\0S\0n\0U\0V\0@\x01\0\x01%\x01\x0f\x02\xf8\x03\0\x014\x01\x07\x01\x04\x01C\x01\x82\0z\0\b\x01\x97\x04\x8c\0\n\x01`\x01Z\x01\0\x01\x0f\x01\x17\x04\x9a\x04\x12\x01\x05\x001\0\xb7\x01\0\x01\xb9\x01\0\x01\x89\0A\x01\0\x01\x07\x01b\0\x91\0\x86\x04\0\x01u\x01`\x01\0\x01\0\x01r\x01\xac\x03\0\x01\0\x01n\0C\x01b\0$\x04\0\x01\x96\0J\x02\0\x01\x11\x01\n\x01N\x02b\0\0\x01`\x01n\0\x80\0\x12\x05\x82\0\b\x01\x84\0^\x03\x86\0E\x01n\0b\0\0\x01C\x01\xc0\0\x80\0\xae\0\x82\0\xc4\0\x84\0b\0\x86\0b\0n\0\xd4\x03\xd5\x03\0\x01\0\x01\xae\x04\xbb\0\0\x01.\x05n\0\xd3\0n\0C\x01\xb9\0\xba\0A\x01`\x01\b\x02\x82\0\0\x01\xbc\0\0\x01\xd2\x04A\x01A\x01\0\x01L\x02\xa2\0\x84\x02C\x01\xa5\0\xa6\0|\x01r\x01\xd7\0\x8e\x01A\x01\xd9\x04s\x01\x0e\x01]\x01`\x01\t\0\xb2\0\xb3\0\f\0\t\x05\xe3\x04o\x01\x07\x05\xda\0`\x01\x13\0\x14\0\x15\0\x16\0\x8b\x03^\x01`\x01\x11\x05\x1b\0o\x01u\x01\0\x01`\x01\xd6\0O\x01\x88\x04^\x01o\x01o\x01&\0`\x01\xd0\0C\x01=\x02+\0,\0\xbe\x01u\x01^\x05\x04\x01o\x01^\x01v\x014\0x\x01-\x057\0\x18\x01\0\x01\x04\x01C\x01A\x01B\x01\b\x01]\x01]\x01\0\0\0\x01a\x01a\x01\x0f\x01`\x01\x16\x01\x12\x01\xbe\x04 \x01\xd6\0\x9f\x02\xde\x01\0\x02\xe0\x01\x0e\x01]\x01`\x01\x11\x01\x03\x01a\x01\xbf\x01A\x01`\x01\0\x01\x16\x01\xb7\x05\xd0\x01&\x01\0\x01\xa2\x01\0\x01K\x01C\x01@\x05N\x01\xce\x01\xdb\x04\x04\x01\x1e\x01\x1f\x01o\x01\b\x01\0\x01\x85\x02\x86\x02f\x05E\x05:\x01\x0f\x01\0\x01\0\x01\x12\x01J\x01\0\x01Q\x01C\x01\x1a\x01]\x01\xfa\x02S\x01u\x05a\x01J\x01\n\x01l\x01P\x01$\x02\0\x01p\x01\0\x01\x05\x02g\x04@\x01k\x01D\x01\x0f\x01\xa6\x02\xaa\x01\x80\x01\xac\x01\xad\x05\xae\x01 \x02\x15\x02E\x04^\x01G\x04\xff\x04\x1a\x02Q\x01\x1e\x01\x91\x01\x9a\x05w\x03\\\x01\x1a\x01`\x017\x03\n\x05T\x04C\x01\xb7\x02C\x01s\x013\x03]\x02\x91\x01M\x02\x91\x01\0\x01\0\x01\xa5\x04\0\x01C\x01}\x01~\x01]\x01\x81\x05\x81\x01s\x05\x83\x01/\x04^\x01\x93\x01^\x01\x16\x01B\x01\0\x01\0\x01\0\x01\x1b\x01\0\x01\x12\x01o\x01\x1b\x03]\x01?\x05\n\x01\0\x01\n\x01\0\x01\0\x01`\x01]\x01\xb0\x01`\x01I\x05^\x01\x11\x01\0\x01a\x01\xb7\x01\x03\x01\xb9\x01\xb2\x01\xb5\x03\x91\x01\xf4\x03\b\x01\x80\x02\0\x01\0\x01+\x05`\x01\x12\x01%\x01\x11\x01Y\x02l\x01\xc1\x01\x91\x01o\x01A\x03#\x01\b\x01\xcf\x01\x1c\x05%\x01\xaa\x01\x91\x01\xac\x01\x0f\x01\xae\x01\xbe\x03\xbf\x03\b\x01$\x01\xd3\x01\x88\x02\xf3\x04\x80\x02\xaa\x01\x91\x01\xac\x01\0\x01\xae\x01\x1e\x01\xdd\x01<\x01~\x05\x96\x02\x91\x01]\x01\x91\x01B\x01\0\x01`\x01\xef\x04`\x01\xe9\x01\x92\x03\xb9\x03\0\x01\0\x01\xac\x03\n\x01\xbe\x03\xbf\x03\xcb\x04p\x036\x01^\x01 \x01^\x01a\x01a\x01a\x01`\x01\xfc\x01\xfd\x01\0\x01|\x03B\x01\x01\x02\x02\x02^\x01\f\x02a\x01\x0e\x02\x84\x03^\x01\xa3\x02h\x01\0\x01^\x01`\x01\0\x01\x0f\x02\b\x01o\x01\xb1\x05\x16\x01\x14\x02/\x02\xd4\x03\xd5\x03`\x01`\x01\x1c\x04\0\x01\b\x01\x0f\x01\x12\x01\x0e\x01\0\x02\xbf\x04\"\x02\x0f\x01\xf6\x01\xf7\x01\xf8\x01^\x01\xc2\x02\xf2\x02l\x01\xd2\x02\xfe\x01o\x01B\x01C\x01\xc3\x02\xc4\x02\x1e\x01\xbc\x03\xe8\x02\x1b\x01\x06\x01\b\x01^\x01\x12\x01\\\x01;\x02B\x014\x02\b\x01\x1b\x01@\x02A\x01B\x01^\x01J\x01b\x05a\x01a\x02\xf2\x02\x17\x04\x1c\x02^\x01`\x01\x17\x03p\x01\0\x01d\x02C\x01b\x02c\x02\xd1\x03\x10\x01B\x01\x12\x01\x12\x01\x16\x01$\x01]\x01\xf6\x02C\x01\0\x01\x12\x01c\x01d\x01\x12\x01\r\x036\x02\x16\x01^\x01\x16\x01]\x01\xae\x02\x1b\x01=\x02`\x01`\x02`\x01\x13\x01\b\x01`\x01u\x01\x0e\x01\x16\x01\x89\x02\x8a\x02\x0f\x01]\x01\x1b\x01\0\x01I\x04\x99\x05]\x02~\x02Q\x02l\x01\x1e\x01*\x04o\x01`\x01\x0e\x04\x1e\x01`\x01\x0e\x01\x13\x02(\x05/\x01*\x05^\x01^\x01u\x01Z\x03\x12\x01\x9d\x02\0\0^\x01\x0e\x01\x12\x01\x97\x02a\x03=\x01\x12\x018\x01W\x03X\x03Y\x03\\\x01\x12\x01E\x01\xbc\x02G\x01^\x01B\x01#\x04B\x01C\x01s\x03B\x015\x02]\x01`\x01^\x01\xb7\x02a\x01\x16\x01c\x01d\x01c\x01d\x01\x04\x01a\x03B\x02C\x02?\x03]\x01B\x01C\x01\xc9\x02a\x01\x16\x01c\x01d\x01\x1b\x01u\x01`\x01\x17\x01L\x03\xeb\x03\xdc\x04\xed\x03\xee\x03\x1b\x01q\x01\xae\x02l\x01\x03\x01\x1b\x01o\x01u\x01l\x01\xe9\x02\xea\x02o\x01Q\x01\x16\x01`\x01\xae\x02\0\x01^\x01\xde\x02`\x01\xe0\x02\x1b\x01\xe2\x02\xe3\x02`\x01\x1b\x01^\x01\xa5\x04`\x01\xa4\x03\b\x01\xff\x02B\x01\xdc\x04`\x01\x13\x01\xbe\x04\x0f\x01\x17\x01\xbc\x03C\x01C\x01\x1a\x01\\\x01\f\x03\x88\x03\xfa\x02\x99\x03\x1b\x01\xcf\x02\xfe\x02\b\x01\x1e\x01\xd3\x02\x95\x03\x13\x01\xd2\x04B\x01\x0f\x01\xc0\x05`\x01Z\x01`\x01/\x010\x01\xdb\x04\xdc\x04\x0f\x03\x11\x01;\x02\xbc\x03\x1b\x01\x03\x01\x1e\x01`\x01\b\x016\x01=\x01\xa4\x02\0\x01A\x01\xe7\x03B\x01\x02\x01 \x03E\x01\xc0\x05G\x01B\x01\0\x01`\x01n\x01\x04\x01\x03\x01`\x01r\x01\b\x01\x13\x01$\x01/\x030\x03\x03\x03\x0e\x01\x0f\x01D\x01\xf3\x04\x12\x01\xc1\x02\x13\x01B\x01:\x03J\x03<\x03J\x03\b\x01\x1a\x01T\x03`\x01C\x01C\x03D\x03\x0e\x04Q\x03G\x03\\\x03/\x010\x01_\x03\x0e\x01q\x01l\x01\xd9\x02w\x03o\x01\x0e\x01D\x01/\x010\x01C\x01=\x01`\x01\x1b\x01\xe5\x04\x0e\x01A\x01B\x01?\x01E\x01C\x01G\x01=\x01l\x01\x0e\x04\r\x05o\x01C\x01\x1b\x01D\x01E\x01a\x01G\x01C\x01D\x01\0\0\0\x01?\x05@\x05\x0e\x01\x04\x01A\x01\x1d\x04\0\0\b\x01\x03\x01D\x01I\x05\x0e\x01}\x03\x0e\x01\x0f\x01\x88\x03#\x01\x12\x01\x83\x03`\x01\x90\x03B\x01C\x01u\x01\x1b\x01S\x04q\x013\x04b\x01\xb5\x03Q\x01\x03\x01]\x01\x92\x03\0\x01A\x01B\x01q\x01\x04\x01\x98\x03\xa1\x03<\x01\b\x01A\x01\n\x01Q\x01u\x01B\x01\x0e\x01\x0f\x01\xa3\x037\x04\x12\x01\xa6\x03B\x01\x0f\x01S\x04r\x01\x12\x01\xb7\x03\x1b\x01\x1b\x01\xaf\x03~\x05b\x01\x16\x01C\x01\\\x05\0\0E\x04\xbf\x03R\x04\xcd\x03\xce\x03\f\x01E\x04g\x04\x0e\x01Q\x01h\x05-\x01.\x01p\x01^\x04\xc5\x03h\x01\xdb\x03\xb5\x05\xb6\x05o\x01\x1b\x01\b\x01o\x01\x1f\x01q\x01`\x01A\x01\xd2\x03\x9b\x01^\x03C\x01C\x01\xd7\x03\xec\x03\xab\x03\xba\x03e\x03C\x01J\x01B\x01\r\x011\x012\x013\x01\xb1\x05\0\x01\xe5\x03A\x01]\x01\x03\x01U\x01A\x01a\x01\\\x01\xda\x05\x1c\x01\x1d\x01]\x01^\x01B\x01`\x01a\x01L\x01\n\x04H\x01\xa0\x05\xa1\x05f\x01)\x01M\x01\xcf\x03\x1a\x01o\x01\x04\x01\x01\x04\0\0\x1d\x04\b\x01V\x01s\x01\x0e\x01c\x01\x1b\x01\x05\0\x0b\x04\x07\0(\x01\x12\x01=\x01C\x01\xe3\x03@\x01[\x05o\x01\xde\x04g\x01E\x01\x18\x04\x19\x04\xc2\x05r\x01\x17\0K\x01\x04\x01\0\x01 \x04\xf3\x03\b\x01A\x01R\x010\x04&\x04`\x01A\x01\x0f\x01*\x04#\x01\x12\x01`\x01\0\x01\x16\x01\xd8\x05C\x01\x13\x018\x01\xde\x04\x1b\x01o\x01<\x01\n\x01\x1a\x01\x1b\x01;\x04A\x01E\x04\xe6\x05C\x01n\x01\0\0u\x01\\\x01<\x01\xef\x04J\x01\x0e\x01A\x01Z\x01B\x01P\x01A\x01M\x04/\x010\x01A\x01o\x01f\x04\x1c\x05\x1b\x01i\x04o\x01p\x01\xe2\x03Y\x04^\x01B\x01=\x01C\x01\xe8\x03A\x01\xea\x03r\x01A\x01D\x01E\x01`\0G\x01Z\x04|\x04}\x04o\x01A\x01\xf6\x03A\x01\0\0\0\x01h\x01\x16\x01\x1c\x05s\x04\x1f\x01U\x04o\x01o\x01\x90\x04\x1b\x01o\x01B\x01\r\x01\\\x01o\x01p\x01\x80\x04c\x01\x82\x04\x83\x04\x84\x04\x9d\x041\x012\x013\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01o\x01\x89\0X\x05q\x01p\x01A\x01\x8e\0\x8f\0\x95\x04\0\x01\xab\x04)\x01o\x018\x01o\x01\x1b\x01A\x01\x16\x01D\x01:\x05C\x01M\x01A\x01\xbc\x04A\x01\x86\x04\xa2\0\xa3\0G\x05\xa5\0\xa6\0=\x01\xa8\0X\x05@\x01\x1a\x01A\x01C\x01D\x01E\x01\0\x01\0\x01\xb2\0\xb3\0\x04\x01K\x01\xbb\x04A\x01\b\x01\x04\x01\n\x01o\x01R\x01\b\x01\x0e\x01C\x01\x1f\x01A\x01\x12\x01\x0e\x01\x0f\x01B\x01o\x01\x12\x01^\x01\xce\x04`\x01\x1b\x01b\x01c\x01o\x01\xdc\x04\xd0\0\xd1\x001\x012\x013\x01\xd5\0%\x01\xf0\x04n\x01h\x04o\x01q\x01\xe1\x04l\x04A\x01u\x01f\x01\0\x05\x1b\x01#\x01\x03\x05\xea\x04\x05\x05\x04\x01\x04\x01\xee\x04\x1b\x01\b\x01\b\x01\xe5\x04M\x01o\x01\x16\x01\xc8\x04\x0f\x01\x10\x05\xd9\x04\x12\x01\x12\x01\xfc\x04C\x01A\x01J\x01A\x01<\x01\0\x01\xe3\x04A\x01B\x01\x04\x01B\x01\b\x05\x93\x04\b\x01H\x01\n\x01\r\x05\x1b\x01C\x01\x0e\x01o\x01]\x01^\x01,\x05`\x01a\x01C\x01\x04\x01V\x01\0\0\x1b\x05\b\x01\x1b\x01\xa8\x04\\\x01 \x05B\x01\0\x01\x0f\x01\0\x01`\x01\x12\x01A\x01s\x01\x16\x01#\x01C\x01o\x01h\x01o\x01>\x05r\x01>\x05o\x01p\x01o\x015\x05C\x01\0\x01K\x014\x01N\x05;\x05V\x05W\x05\x1a\x01\xac\x05Z\x05A\x05\x03\x01<\x016\x01_\x058\x01%\x01A\x01B\x01\xd4\x04C\x01J\x01M\x05\r\x01A\x01B\x01\x1a\x01K\x01S\x05C\x01o\x01\x12\x01C\x01\0\x01Q\x01n\x05n\x01\\\x05\x1c\x01\x1d\x01]\x01^\x01H\x01`\x01a\x01d\x05E\x05U\x01(\x01h\x05\x83\x05)\x01\x13\x01e\x01m\x05\0\0V\x01\xfa\x04\0\x01\x1a\x01\x1b\x01o\x01s\x01o\x01\x16\x01\0\x01y\x05\\\x01\r\x01\x1b\x01o\x01=\x01\0\x01o\x01@\x01\x96\x05Z\x01\x0e\x05C\x01E\x01/\x010\x01\x89\x05\x1c\x01\x1d\x01K\x01\x17\x01p\x01\xa3\x05\x1a\x05\xab\x05\x1a\x01R\x01\x8f\x01=\x01%\x01)\x01\0\x01\x1a\x01$\x01r\x01D\x01E\x01\x17\x01G\x01\xa0\x05\xa1\x05\x04\x01b\x01c\x018\x01\b\x01`\x01\xa8\x053\x05\xbe\x05=\x01!\x01\x0f\x01@\x01n\x01\x12\x01\xcb\x05\xcc\x05E\x01\0\x01\xb0\x01C\x01A\x01\xb8\x05K\x01\x0e\x01\xbb\x05\xb7\x01%\x01\xb9\x01\xd3\x05R\x01\xc1\x05\xc2\x058\x01\xbf\x01\0\x01B\x01<\x01U\x01q\x01\0\x01@\x01A\x01B\x01\x1a\x01A\x01b\x01c\x01\0\x01\xce\x01\xcf\x01\xd5\x05\xea\x05\xe3\x03\xd8\x05\xd4\x01L\x01P\x01n\x01\xdd\x05\x16\x01\x1a\x01\xe0\x05C\x01\0\0a\x01\x1a\x01\xe5\x05\xe6\x05\xf3\x03\xe8\x05\xe9\x05B\x01]\x01\x1a\x01c\x01d\x01\x1b\x01H\x01a\x01\0\x01B\x01\x1b\x016\x01\x80\x058\x01\0\x01H\x01o\x01\xf6\x01\xf7\x01\xf8\x01V\x01u\x01A\x01B\x01\x04\x01\xfe\x01\x12\x01!\x01\b\x01V\x01\x92\x05\x0e\x01\x94\x05\x13\x01\x11\x01\x0f\x01a\x01\0\0\x12\x01\f\x02\x1a\x01\x0e\x02\x9e\x05\x16\x01\x1b\x01A\x01\x13\x02\x1b\x01\x15\x02\x16\x028\x01\x16\x01\0\x01\x1a\x02<\x01\x1c\x02L\x01_\x01@\x01A\x01B\x01/\x010\x01$\x02o\x01\xb5\x05\xb6\x05\0\x01o\x01(\x01`\x01\x13\x01\xbc\x05\x10\x01P\x01=\x01_\x01\n\x01\x1a\x01B\x015\x026\x02D\x01E\x01\x1b\x01G\x01o\x01C\x01=\x02\xcd\x05B\x01n\x01o\x01B\x02C\x02\x03\x01\xd4\x05\0\x01J\x01/\x010\x01C\x01\xda\x05L\x02M\x02o\x01\xde\x05\n\x01Q\x02K\x01o\x01\xe3\x05\xe4\x05=\x01\x04\x01`\x01R\x01n\x01\b\x01U\x01D\x01E\x01)\x02G\x01A\x01\x0f\x01-\x02q\x01\x12\x01A\x01o\x01p\x01\0\x01\x01\x01\x02\x01\x03\x01\0\x01\x1b\x01A\x01B\x01\b\x01\t\x01\n\x01o\x01\b\x01\r\x01\x0e\x01\x0e\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\0\0\x80\x02\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01B\x01C\x01D\x01q\x01_\x01o\x01$\x01%\x01A\x01B\x01(\x01)\x01*\x01+\x01^\x01C\x01\b\x01/\x010\x01n\x01o\x01B\x01C\x01\0\x01\x9f\x02C\x01D\x01\0\x01\x0e\x01\xa4\x02$\x01=\x01>\x01a\x01@\x01\x18\x02\x19\x02C\x01D\x01E\x01J\x01G\x01\x13\x01\x0e\x01J\x01K\x01\x13\x01\x16\x01\xb7\x02\x1a\x01o\x01\xba\x02R\x01\x1a\x01T\x01\\\x01\x16\x01\x1b\x01\xc1\x02\0\x01\xc3\x02\xc4\x02a\x01]\x01^\x01a\x01`\x01a\x01b\x01c\x01/\x010\x01\xcf\x02`\x01/\x01i\x01\xd3\x02k\x01\x13\x01\0\x01n\x01A\x01\xd9\x02q\x01=\x01\x1a\x01\0\x01u\x01=\x01\x03\x01\0\0D\x01E\x01o\x01G\x01D\x01E\x01i\x01G\x01\r\x01\x0e\x01^\x01o\x01^\x01B\x01^\x01/\x01\xf2\x02\xf3\x02`\x01u\x01\x1b\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01u\x01\x14\x01.\x01\x0e\x01=\x01A\x01\x16\x01?\x01\x03\x03Q\x01(\x01)\x01E\x01A\x01G\x01\0\x01\x0b\x03\x0e\x01\r\x03\x04\x01q\x01\x0e\x01\x16\x01\b\x01q\x01\n\x01\x02\x01J\x01\x17\x03\x0e\x01\x0f\x01=\x01\x1b\x03\x12\x01@\x01L\0B\x01C\x01D\x01E\x01u\x01`\x01\x1b\x01J\x01f\x01K\x016\x017\x018\x019\x01\x0f\x01\0\0R\x01B\x01^\x01A\x01q\x01A\x01B\x01\\\x01J\x01f\x01`\x01A\x01^\x01^\x01`\x01l\0b\x01c\x01A\x03A\x01\b\x01\x0e\x01\0\x01\x1b\x01X\x01\x1b\x01\x1b\x01\x1e\x01n\x01A\x01C\x01q\x01A\x01~\0\x0e\x01u\x01^\x01J\x01o\x01\x03\x01\x85\0\x13\x01\0\0Z\x03\x0e\x01X\x011\x01^\x03\x1a\x01`\x03a\x03o\x01A\x01\x06\x01e\x03n\x01]\x01^\x01J\x01`\x01a\x01o\x01A\x01B\x01\x1b\x01p\x03a\x01`\x01s\x03/\x010\x01g\x01\x1b\x01\x0e\x01`\x01A\x01`\x01|\x03s\x01(\x01\0\x01Z\x01\x15\x01=\x01\x04\x01\x84\x03A\x01\x1b\x01\b\x01\x88\x03\n\x01E\x01\x8b\x03G\x01\x0e\x01\x0f\x01A\x01?\x01?\x01\x10\x01g\x01\r\x01\x95\x03?\x01\x0e\x01l\x01\x03\x01\x1b\x01o\x016\x017\x018\x019\x01\x0e\x01\xa1\x03B\x01\x1c\x01\x1d\x01A\x01\x1b\x01A\x01B\x01\xd7\0`\x01\xab\x03J\x01f\x016\x01`\x01)\x01J\x01\b\x01\x16\x01\0\0`\x01q\x01\x10\x01`\x01\xb9\x03\xba\x03L\x01\xbc\x03L\x01\xbe\x03\xbf\x03\x1b\x01`\x01C\x01\x07\0=\x01J\x01\x1b\x01\x0e\x01\x14\x01J\x01Z\x01\0\x01E\x01r\x01`\x01\xcf\x03J\x01\xd1\x03K\x01\x17\0`\x01o\x01A\x01r\x01\x1c\0R\x01\x0e\x01]\x01]\x01^\x01\x13\x01`\x01a\x01\0\x01\xe2\x03\xe3\x03\x03\x01\x1a\x01J\x01\xe7\x03\xe8\x03b\x01\xea\x03\x15\x01\x0e\x01\x0e\x01\r\x01\x0e\x01\x0e\x01\x0e\x01s\x01\xf3\x03\x1b\x01n\x01\xf6\x03\x13\x01q\x01Z\x01/\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x01\0\x02\0\x03\0\x04\0\x05\0\x06\0\x07\0r\x01\x0e\x01=\x01(\x01)\x01\x1b\x01]\x01\x0e\x01\x0e\x04D\x01E\x01\x16\x01G\x01\x0f\x01\x0e\x01\0\0\x0e\x01\x17\x04a\x01\0\0\0\0o\x01b\x01b\x01=\x01^\x01o\x01@\x01\b\x01#\x04R\x01D\x01E\x01A\x01^\x01$\x01\\\x01$\x01K\x01^\x01\0\x01/\x04,\x01-\x01.\x01R\x01`\x01J\x01\b\x017\x046\x01A\x01\x16\x01\r\x01q\x01A\x01A\x01^\x016\x01`\x01B\x04b\x01c\x01E\x04]\x01G\x04\x1a\x01I\x04\x1c\x01\x1d\x01H\x01I\x01\x92\0n\x01A\x01A\x01q\x01S\x04T\x04U\x04u\x01)\x01A\x01U\x01V\x01W\x01X\x01A\x01\xa2\0\xa3\0\xa4\0\xa5\0\xa6\0A\x01\xa8\0\x93\x01\r\x01g\x04h\x04\x80\0f\x01=\x01l\x04\x1c\x04\xb2\0\xb3\0\xde\x04C\x01D\x01E\x01Z\x04\x1c\x01\x1d\x01V\x04\x8e\x01K\x01\x80\x05X\x058\x05\xab\x01\xc7\x03\t\x03R\x018\x01)\x01:\x01;\x01<\x01\x86\x04>\x01`\x02\xa4\x01A\x01B\x01\xd0\0\xd1\0\x82\x01\xff\x01b\x01\xd5\0\x92\x04\x93\x04a\x02\xcf\x03=\x01=\x02\xd2\x02@\x01\xa6\0b\x04n\x01c\0E\x01q\x01f\x03\xc0\x05\xbc\x04\x1f\x04K\x01\\\x01\x12\x05\xcf\x01\xa8\x04\xff\xff\0\0R\x01c\x01\xc6\x04\xae\x04\x07\0\xbc\x02\xff\xff\xff\xff\x0b\0\0\x01\xff\xff\xff\xff\x03\x01o\x01p\x01\xff\xffb\x01c\x01\xff\xff\xbe\x04\xbf\x04\xff\xff\r\x01\xff\xff\xff\xff\x1c\0\x11\x01\xff\xffn\x01\xc8\x04\xff\xff\x16\x01\xcb\x04\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xd2\x04\xff\xff\xd4\x04\xff\xff\xff\xff\xff\xff0\0\xd9\x04\xff\xff\xdb\x04\xdc\x04)\x01\xde\x04\xff\xff\xff\xff\xff\xff\xff\xff\xe3\x04\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xef\x044\x01=\x01\xff\xff\xff\xff@\x01\xff\xffB\x01C\x01D\x01E\x01\xfa\x04S\0\xff\xffU\0V\0K\x01\xff\xffE\x01\xff\xff\xff\xffH\x01\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x0e\x05\xff\xff\xff\xff\xff\xff^\x01\xff\xff`\x01\0\x01b\x01c\x01\xff\xff\x04\x01\x1a\x05\xff\xff\x1c\x05\b\x01\xff\xff\n\x01\xff\xffO\x02n\x01\x0e\x01\0\x01q\x01T\x02\x12\x01(\x05u\x01*\x05o\x01\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff3\x05\xff\xff\xff\xff\xff\xff\x13\x01|\x01\xff\xff\0\0\xff\xff\xff\xff\xff\xff\x1a\x01?\x05@\x05\xff\xff\xff\xff\xff\xff\xff\xffE\x05\xff\xff\xff\xff\xff\xffI\x05\xa2\0\xa3\0\xff\xff\xa5\0\xa6\0\xff\xff\xa8\0\x7f\x02\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xffX\x05\xff\xff\xb2\0\xb3\0\xff\xff\xff\xff\xff\xffJ\x01\xa4\x01=\x01\xff\xff\xff\xff\xbc\0\xff\xff\xff\xff\xff\xff\xff\xffE\x01\xff\xffG\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xa2\x02`\x01a\x01\xff\xff\xd0\0\xd1\0\xff\xff\xff\xff\xff\xff\xff\xff~\x05\xff\xff\x80\x05\x81\x05\xda\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffs\x01\xff\xff\xff\xff\xff\xff\xd0\x01\xff\xff\xff\xff\xff\xff\xd4\x01\xff\xff\x92\x05\xff\xff\x94\x05q\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x9e\x05\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\x03\x01\xff\xff\xff\xff\xff\xff\xb1\x05\xf6\x01\xf7\x01\xf8\x01\xb5\x05\xb6\x05\r\x01\xff\xff\xff\xff\xfe\x01\xff\xff\xbc\x05\0\x01\xff\xff\xff\xff\xc0\x05\x05\x02\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\r\x02\xff\xff\xff\xff\0\0\xcd\x05&\x01\xfd\x02\x13\x01\x15\x02\x16\x02)\x01\xd4\x05\xff\xff\x1a\x02\x1a\x01\x1c\x02\xff\xff\xda\x05\xff\xff\xff\xff\xff\xff\xde\x05\xff\xff$\x02\xff\xff:\x01\xe3\x05\xe4\x05)\x02\xff\xff=\x01\xff\xff-\x02\xff\xff\xff\xff/\x01\xff\xffD\x01E\x01\xff\xff\xff\xff6\x02\0\0\xff\xffK\x01\xff\xff\xff\xff\xff\xff=\x02=\x01\x06\x01R\x01\b\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xff5\x03\xff\xffM\x02`\x01\xff\xffb\x01Q\x02\xff\xff\xff\xff\xff\xff\xff\xff@\x03\xff\xffB\x03\xff\xff\xff\xffo\x01n\x01\xff\xff\xff\xffq\x01`\x02\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff}\x01~\x01\xff\xff\xff\xff\x81\x01\xff\xff\x83\x01\xff\xff8\x01q\x01:\x01;\x01<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xffg\x03\0\x01\xff\xff\x80\x02\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\xff\xff\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01~\x03\\\x01\x18\x01\x19\x01\x1a\x01\x83\x03\x1c\x01\x1d\x01c\x01\xff\xff\xff\xff\xff\xff\xa0\x02\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01o\x01p\x01\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xd4\x01\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xcf\x02R\x01\xbb\x03\xd2\x02\xd3\x02\xff\xff\xff\xff\xc0\x03\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xf6\x01\xf7\x01\xf8\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xfe\x01\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xf2\x02u\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\r\x02\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x15\x02\x16\x02\x03\x03\xff\xff\xef\x03\x1a\x02\xff\xff\x1c\x02\xff\xff\xff\xff\x0b\x03\xff\xff\r\x03\xff\xff\xff\xff\0\x01\0\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x17\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\0\x006\x02\xff\xff\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff=\x02\x1a\x01\x1a\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff4\x03\xff\xff \x04\0\x01\xff\xff)\x01\xff\xff\x04\x01&\x04Q\x02\xff\xff\b\x01/\x01\n\x01\xff\xff\xff\xff\xff\xff\x0e\x01\xff\xff\xff\xff\xff\xff\x12\x01\xff\xff\xff\xff`\x02=\x01=\x01\xff\xff@\x01\xff\xff\x1b\x01\xff\xff\xff\xffE\x01E\x01\xff\xffG\x01\xff\xffZ\x03K\x01\xff\xff\xff\xff\xff\xff\xff\xff`\x03a\x03R\x01\xff\xff\xff\xff\xff\xff\x07\0\xff\xff\xff\xff\xff\xff\x0b\0\xff\xff\x80\x02\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01s\x03\xff\xff\xff\xffv\x03\xff\xff\xff\xffc\x04C\x01\x1c\0\xff\xff\xff\xffn\x01\xff\xff\xff\xffJ\x01q\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff0\0\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01\x99\x03\xff\xff\x85\x04\xff\xff\x87\x04\xff\xff\x89\x04\xff\xff\xff\xff\x8c\x04\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffs\x01\xab\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x9b\x04S\0\xff\xffU\0V\0\xff\xff\xff\xff\0\x01\xff\xff\xba\x03\xcf\x02\xbc\x03\xff\xff\xff\xff\xd3\x02\xff\xff\xff\xff\xac\x04\xad\x04\xff\xff\r\x01\xff\xff8\x01\xb2\x04:\x01;\x01<\x01\xff\xff>\x01\xff\xff\xcf\x03A\x01B\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xf2\x02P\x01\xff\xff)\x01S\x01\xe3\x03\xce\x04\xff\xff\xff\xff\xe7\x03\x89\0\xff\xff[\x01\\\x01\xff\xff\xff\xff\xff\xff\x03\x03\xff\xff\xff\xffc\x01\xf3\x03\xff\xff=\x01\xff\xff\x0b\x03\xff\xff\r\x03\xff\xffC\x01D\x01E\x01o\x01p\x01\xff\xff\xa2\0\xa3\0K\x01\xa5\0\xa6\0\xff\xff\xa8\0\xff\xff\xff\xffR\x01\x07\0\xff\xff\xff\xff\x0e\x04\xff\xff\xff\xff\xb2\0\xb3\0\xff\xff\x10\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffb\x01\xbc\0\xff\xff\x1d\x04\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\x03\x01\xff\xffn\x01\xff\xff\x12\x05q\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xd0\0\xd1\0\xff\xff\x11\x013\x04\xff\xff\xff\xff \x05\x16\x01\xff\xff\xda\0\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff.\x05\xff\xff\xff\xff1\x05\xff\xff\xff\xff)\x01\xff\xff`\x03a\x03\xff\xff\xff\xff\xff\xff\xff\xff\0\x01S\x04\xff\xffU\x04\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xffB\x01C\x01D\x01E\x01g\x04d\0\xff\xff\xff\xffU\x05K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0^\x01\xff\xff`\x01\xff\xffb\x01c\x01&\x01\x86\x04\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01n\x01>\x01`\0q\x01A\x01B\x01\xff\xffu\x01\xab\x03\xff\xff:\x01\x84\x05\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xa2\0\xa3\0\xbc\x03\xa5\0\xa6\0\xff\xff\xa8\0[\x01\\\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\x01\xb2\0\xb3\0\xff\xff\xff\xff\xff\xff\xcf\x03\xff\xff\xa7\x05\xa8\x05\xff\xffn\x01o\x01p\x01\x07\0\xff\xff\xaf\x05\0\x01\xff\xff\xc8\x04\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffo\x01\xe3\x03\xff\xff\xff\xff\xff\xff\xff\xff\xd0\0\xd1\0\r\x01\xff\xff\xff\xff\xd9\x04\0\x01\xff\xff}\x01~\x01\xde\x04\xf3\x03\x81\x01\xff\xff\x83\x01\xe3\x04\xff\xff\x1c\x01\x1d\x01\r\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xef\x04\xff\xff\xff\xff)\x01\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xe2\x05\xff\xff\x0e\x04\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01)\x01>\x01\xff\xff=\x01A\x01B\x01@\x01\xff\xff\0\0\xff\xff\xff\xffE\x01\xb0\x01\xff\xff\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xb7\x01=\x01\xb9\x01S\x01@\x01R\x01\x1c\x05\xff\xffD\x01E\x01\xff\xff[\x01\\\x01\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xffb\x01R\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xd4\x01\xff\xffo\x01p\x01n\x01^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xffS\x04\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffE\x05Z\x04G\x05n\x01\xff\xff\xff\xffq\x01\r\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffg\x04\xff\xff\xf6\x01\xf7\x01\xf8\x01X\x05\xff\xffV\x01\x1c\x01\x1d\x01\xfe\x01\xa2\0\xa3\0\xff\xff\xa5\0\xa6\0\xff\xff\xa8\0\xff\xff\xff\xffg\x05)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xb2\0\xb3\0\xff\xff\xff\xff\0\0o\x01\x15\x02\x16\x02\xff\xff\xff\xff\xff\xff\x1a\x02\xff\xff\x1c\x02=\x01\x06\x01\0\x01@\x01\xff\xff\x03\x01\xff\xff\xff\xffE\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\x01\r\x01\xd0\0\xd1\0\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff6\x02\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01=\x02\xff\xff\xff\xff\x9f\x05\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff8\x01Q\x02:\x01;\x01<\x01\xc8\x04>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff=\x01\xff\xff\xff\xff@\x01`\x02\x8f\x01C\x01D\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\x01\xde\x04\xff\xff\x0f\x01\xff\xff\xff\xff\xff\xffR\x01\xe5\x04\xff\xff\\\x01\xff\xff\xff\xff\xff\xff\xff\xff\xd4\x01\xff\xffc\x01\xef\x04^\x01\xff\xff`\x01\x80\x02b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xffo\x01p\x01+\x01,\x01-\x01.\x01n\x01\xff\xff\xff\xffq\x01\xff\xff\xc0\x01\xff\xffu\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf5\x01\xf6\x01\xf7\x01\xf8\x01\xcc\x01\xff\xff\xff\xffC\x01\xff\xff\xfe\x01\xff\xff\0\x01H\x01I\x01\xff\xff\x1c\x05\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\x03\x01\xff\xff\xff\xff\xff\xffU\x01V\x01W\x01X\x01\xb7\x02\0\0\r\x01\x15\x02\x16\x02\xff\xff\xff\xff\xff\xff\x1a\x02\xff\xff\x1c\x02\xff\xff\xff\xfff\x01\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xffo\x01(\x02\xff\xff\xcf\x02\xff\xff\xff\xff\xff\xff\xd3\x02\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff6\x02\xff\xff8\x01\xff\xff:\x01;\x01<\x01=\x02>\x01\xff\xffX\x05A\x01B\x01\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xf2\x02\xff\xffg\x05\xff\xffQ\x02K\x01S\x01\xff\xff\xff\xff\0\0\xff\xff\xff\xffR\x01\xff\xff[\x01\\\x01\xff\xff\x03\x03\xff\xff\xff\xff\xff\xff\xff\xffc\x01\xff\xff^\x01\x0b\x03`\x01\r\x03b\x01c\x01\xff\xff\x06\x01\xff\xff\0\x01o\x01p\x01\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01L\x02\xff\xff\r\x01u\x01\xff\xff\xff\xff\xff\xff\x80\x02\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x9f\x05\x1a\x01\xff\xff\x1c\x01\x1d\x01\xd4\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01\0\0>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff=\x01\xff\xff\xff\xff\xf6\x01\xf7\x01\xf8\x01\xff\xffD\x01E\x01\xff\xff\xff\xff\xfe\x01\xff\x01\xff\xffK\x01\xff\xff`\x03a\x03\xff\xff\xff\xff\xff\xffR\x01\xff\xff\\\x01\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\xff\xffc\x01\xff\xff\xff\xff\x9f\x02\x15\x02\x16\x02\xcf\x02b\x01\xff\xff\x1a\x02\xd3\x02\x1c\x02o\x01p\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\x88\x03\xff\xff\xff\xff\xff\xff\xff\xff\x8d\x03\xff\xff\xff\xff\x1e\0\x1f\0\xff\xff6\x02\xff\xff\xff\xff\xff\xff\xf2\x02\xff\xff\xff\xff=\x02\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01\x03\x03>\x01\xff\xff\xab\x03A\x01B\x01Q\x02\xff\xff\x0b\x03\xff\xff\r\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\x03\x01\xbc\x03\xff\xffS\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\r\x01[\x01\\\x01\xff\xffW\0X\0\xff\xff\xff\xff\xff\xffc\x01\xcf\x03\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xffo\x01p\x01\xff\xff\x80\x02\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xe3\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf3\x03\0\0=\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xffE\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xffK\x01\xff\xff`\x03a\x03\xff\xff\r\x017\x03R\x01\xff\xff\xff\xff\xff\xff\x0e\x04\xff\xff\xff\xff\xff\xff\xff\xffA\x03\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xffb\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\x86\x03\xcf\x02-\x04\xff\xff\xff\xff\xd3\x02\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffp\x03\xff\xff\xff\xffE\x04K\x01\x06\x01\0\x01\b\x01\xff\xff\xff\xff\xff\xffR\x01|\x03\xf2\x02\xab\x03\xff\xff\xff\xffS\x04\xff\xff\r\x01\x84\x03\xff\xff\xff\xff^\x01Z\x04`\x01\xff\xffb\x01c\x01\xff\xff\x03\x03\xbc\x03\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xffg\x04\x0b\x03n\x01\r\x03\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01)\x01\xff\xff\xff\xff\xcf\x03\xff\xff\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01\xac\x03>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff=\x01\xff\xff\xff\xff\xe3\x03\xff\xff\xff\xff\xb9\x03\xff\xffE\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\x01S\x01\xff\xff\xff\xff\xff\xff\xf3\x03\xff\xffR\x01\xff\xff[\x01\\\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xd1\x03c\x01\xff\xff\xd4\x03\xd5\x03\xff\xff\xff\xffb\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffo\x01p\x01\xff\xff\x0e\x04\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff`\x03a\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xc8\x04W\x01X\x01Y\x01Z\x01[\x01\\\x01]\x01^\x01_\x01`\x01a\x01b\x01c\x01d\x01e\x01f\x01g\x01h\x01i\x01j\x01k\x01\xde\x04m\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe5\x04\xff\xff\xff\xff\xff\xff\x17\x04\xff\xff\xff\xff\xff\xff{\x01\xff\xff\xef\x04\xff\xff\xff\xff\xff\xff\xff\xff\0\x01#\x04\x02\x01\x03\x01S\x04\x87\x01\xff\xff\xff\xff\b\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\x11\x01\x12\x01\x13\x01\xab\x03\xff\xff\xff\xff\xff\xffg\x04\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xffB\x04\xff\xff\xff\xff\xff\xff$\x01\xbc\x03\xff\xff\xff\xff\x1c\x05)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xcf\x03\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xff\xff\xffK\x01\xe3\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf3\x03]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01X\x05\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\x0e\x04\xff\xff\xc8\x04\xff\xff\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01\xa5\x04>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xae\x04\xff\xff\xff\xff\xde\x04\xff\xff\xb3\x04\xb4\x04\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xff\xbe\x04\xff\xff\xff\xff!\x02\xef\x04[\x01\\\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\x02c\x01\0\x01\xff\xff.\x02\x03\x01\xff\xff1\x02\xff\xff\xff\xff\b\x01\xff\xff\n\x01o\x01p\x01\r\x01\x0e\x01\xdb\x04\xff\xff\x11\x01S\x04\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\0\0\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x05\xff\xff%\x01g\x04\xf3\x04(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffb\x02c\x02\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x88\x02]\x01^\x01X\x05`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x018\x05\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff?\x05\xff\xffu\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffI\x05\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff8\x01\xc8\x04:\x01;\x01<\x01\0\x01>\x01\xff\xff\x03\x01A\x01B\x01\xff\xff\xff\xff\b\x01\xff\xff\n\x01\xff\xff\0\0\r\x01\x0e\x01\xff\xff\xff\xff\x11\x01\xde\x04\x13\x01\x14\x01\x15\x01S\x01\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01[\x01\\\x01\xff\xff\xff\xff\xff\xff\xef\x04\xff\xff%\x01c\x01~\x05(\x01)\x01\x81\x05\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xe8\x02o\x01p\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x05\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xb1\x05\x12\x03\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff6\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffX\x05\xff\xff\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\x16\x01\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xffn\x03(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01?\x01@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\xff\xfff\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\0\0n\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\x04\x01\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xda\x03\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\xff\xfff\x01g\x01\0\0i\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xffr\x04\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01~\x04\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xaf\x04\xb0\x04\xb1\x04u\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\x16\x01\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\0\0f\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\x04\x01\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\0\0f\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\x16\x01\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\0\0f\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\x16\x01\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\0\0f\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\x16\x01\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\0\0f\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\x04\x01\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\xff\xff\xff\xff\0\0f\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\x04\x01\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\0\0\xff\xff\xff\xfff\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\x04\x01\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\0\0\xff\xff\xff\xfff\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\x16\x01\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff4\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\0\0f\x01\xff\xff\xff\xffi\x01j\x01k\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\x16\x01\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff4\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\0\0f\x01\xff\xff\xff\xffi\x01j\x01k\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\xff\xff\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\xff\xff\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\xff\xff\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\0\0\xff\xff\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\0\0\xff\xff\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xffV\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xffV\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xffV\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xffV\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xffV\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xffV\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff\xff\xff\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01\xff\xff\xff\xffX\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xffR\x01\xff\xffT\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xff\0\0D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\0\x01k\x01\xff\xff\x03\x01n\x01\xff\xff\xff\xffq\x01\b\x01\t\x01\n\x01u\x01\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\0\0D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\0\x01\xff\xffq\x01\x03\x01\xff\xff\xff\xffu\x01\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\0\0\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\0\x01k\x01\xff\xff\x03\x01n\x01\xff\xff\xff\xffq\x01\b\x01\xff\xff\n\x01u\x01\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\0\x01k\x01\xff\xff\x03\x01n\x01\xff\xff\xff\xffq\x01\b\x01\xff\xff\n\x01u\x01\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\0\x01k\x01\xff\xff\x03\x01n\x01\xff\xff\xff\xffq\x01\b\x01\xff\xff\n\x01u\x01\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\xff\xff\x03\x01i\x01\xff\xffk\x01\xff\xff\b\x01n\x01\n\x01\xff\xffq\x01\r\x01\x0e\x01\xff\xffu\x01\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\xff\xff\x03\x01i\x01\xff\xffk\x01\xff\xff\b\x01n\x01\n\x01\xff\xffq\x01\r\x01\x0e\x01\xff\xffu\x01\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\0\x01k\x01\xff\xff\x03\x01n\x01\xff\xff\xff\xffq\x01\b\x01\xff\xff\n\x01u\x01\xff\xff\r\x01\x0e\x01\xff\xff\xff\xff\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\xff\xff\x03\x01i\x01\xff\xffk\x01\xff\xff\b\x01n\x01\n\x01\xff\xffq\x01\r\x01\x0e\x01\xff\xffu\x01\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\0\0@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\0\0\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\xff\xff\x03\x01i\x01\xff\xffk\x01\xff\xff\b\x01n\x01\n\x01\xff\xffq\x01\r\x01\x0e\x01\xff\xffu\x01\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\0\x01k\x01\xff\xff\x03\x01n\x01\xff\xff\xff\xffq\x01\b\x01\xff\xff\n\x01u\x01\xff\xff\r\x01\x0e\x01\xff\xff\xff\xff\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\0\x01q\x01\x02\x01\x03\x01\x04\x01u\x01\xff\xff\xff\xff\b\x01\0\x01\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01$\x01\x1c\x01\x1d\x01\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x018\x01)\x01:\x01;\x01<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff=\x01\xff\xff\xff\xff@\x01A\x01\xff\xffC\x01D\x01E\x01=\x01G\x01\0\0@\x01J\x01K\x01\xff\xffD\x01E\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xffK\x01\\\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01c\x01]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xfff\x01^\x01o\x01p\x01\xff\xffb\x01c\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\0\x01\xff\xffu\x01\x03\x01n\x01\xff\xff\xff\xffq\x01\b\x01\xff\xff\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\xff\xff\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\0\x01q\x01\x02\x01\x03\x01\x04\x01u\x01\xff\xff\xff\xff\b\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\x02\x01\x03\x01\x04\x01\xff\xff\xff\xff\xff\xff\b\x01n\x01\xff\xff\xff\xffq\x01\r\x01\xff\xff\xff\xffu\x01\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\xff\xff\xff\xff\0\x01f\x01\x02\x01\x03\x01\x04\x01\xff\xff\xff\xff\xff\xff\b\x01n\x01\xff\xff\xff\xffq\x01\r\x01\xff\xff\xff\xffu\x01\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\xff\xff\xff\xff\xff\xfff\x01\0\x01\xff\xff\x02\x01\x03\x01\x04\x01\xff\xff\xff\xffn\x01\b\x01\xff\xffq\x01\xff\xff\xff\xff\r\x01u\x01\xff\xff\xff\xff\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\x02\x01\x03\x01\x04\x01\xff\xff\xff\xff\xff\xff\b\x01n\x01\xff\xff\xff\xffq\x01\r\x01\xff\xff\xff\xffu\x01\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\x02\x01\x03\x01\x04\x01\xff\xff\xff\xff\0\0\b\x01n\x01\xff\xff\xff\xffq\x01\r\x01\xff\xff\xff\xffu\x01\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\x02\x01\x03\x01\x04\x01\xff\xff\xff\xffn\x01\b\x01\xff\xffq\x01\xff\xff\xff\xff\r\x01u\x01\xff\xff\xff\xff\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\0\0G\x01\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\x02\x01\x03\x01\x04\x01\xff\xff\xff\xff\xff\xff\b\x01n\x01\xff\xff\xff\xffq\x01\r\x01\xff\xff\xff\xffu\x01\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\r\x01\xff\xff\xff\xffK\x01\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\0\0R\x01\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01\xff\xff\x03\x01q\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff=\x01\xff\xff\r\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff^\x01\xff\xff`\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01=\x01\xff\xffq\x01@\x01\xff\xff\xff\xffu\x01D\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff`\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\0\x01u\x01\xff\xff\x03\x01\xff\xff\x05\x01\x06\x01\x07\x01\b\x01\xff\xff\xff\xff\x0b\x01\f\x01\r\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff$\x01\xff\xff\xff\xff'\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x011\x012\x013\x014\x015\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01\xff\xffD\x01E\x01F\x01G\x01H\x01I\x01\xff\xffK\x01L\x01M\x01N\x01\0\0P\x01\xff\xffR\x01S\x01\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff[\x01\xff\xff]\x01^\x01_\x01\xff\xffa\x01b\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01m\x01n\x01o\x01p\x01q\x01\xff\xff\xff\xfft\x01\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\r\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\x1d\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xffE\x01F\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\0\0R\x01\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01n\x01o\x01\x05\x01\x06\x01\x07\x01\xff\xfft\x01\xff\xff\x0b\x01\f\x01\r\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\x1d\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xffE\x01F\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xffR\x01\xff\xff\xff\xff\xff\xffV\x01W\x01\0\0Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01n\x01o\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\xff\xff\xff\xff\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\r\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\x1d\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x001\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xffE\x01F\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xffR\x01\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\0\0l\x01m\x01n\x01o\x01\xff\xff\xff\xff\0\x01\xff\xfft\x01\xff\xff\x04\x01\xff\xff\x06\x01\xff\xff\b\x01\xff\xff\n\x01\xff\xff\f\x01\r\x01\x0e\x01\x0f\x01\xff\xff\x11\x01\x12\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x014\x015\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xff\0\0H\x01\xff\xffJ\x01K\x01\xff\xffM\x01\xff\xff\xff\xff\xff\xff\xff\xffR\x01S\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xffn\x01o\x01p\x01\xff\xff\0\x01s\x01\xff\xff\xff\xff\x04\x01\xff\xff\x06\x01\xff\xff\b\x01\xff\xff\n\x01\xff\xff\f\x01\xff\xff\x0e\x01\x0f\x01\0\0\x11\x01\x12\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01C\x01\xff\xff\xff\xff\xff\xff\xff\xffH\x01\xff\xffJ\x01\0\0\0\x01M\x01\xff\xff\x03\x01\x04\x01\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\r\x01\x0e\x01[\x01\xff\xff]\x01^\x01\x13\x01`\x01a\x01\xff\xffc\x01\xff\xff\xff\xff\x1a\x01g\x01\x1c\x01\x1d\x01j\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xffs\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\x04\x01@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\r\x01\x0e\x01\xff\xffK\x01\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff`\x01\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\0\0\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\x03\x01R\x01\xff\xff\xff\xff\xff\xff\b\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff^\x01\xff\xff`\x01\x13\x01b\x01c\x01\x16\x01\xff\xff\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\0\0\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff8\x01)\x01:\x01;\x01<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\x04\x01@\x01\xff\xffB\x01C\x01D\x01E\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xffK\x01\\\x01\xff\xff\x13\x01\xff\xff\xff\xffQ\x01R\x01c\x01\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\0\0\xff\xff\xff\xff\xff\xff^\x01o\x01p\x01\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\x04\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\r\x01\x0e\x01\xff\xffK\x01\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\0\0\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff`\x01\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\0\x01n\x01\xff\xff\x03\x01q\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\r\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xff\xff\xffK\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff^\x01\xff\xff`\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01=\x01\x03\x01q\x01\xff\xffA\x01\xff\xffC\x01D\x01E\x01\0\0\xff\xff\r\x01\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xffb\x01c\x01)\x01\xff\xfff\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\xff\xff\xff\xffA\x01\xff\xffC\x01D\x01E\x01\xff\xff\xff\xff\r\x01\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xffb\x01c\x01)\x01\xff\xfff\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01=\x01\xff\xff\x03\x01\xff\xffA\x01\xff\xffC\x01D\x01E\x01\xff\xff\xff\xff\xff\xff\r\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\x13\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xffb\x01c\x01(\x01)\x01f\x01\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\0\x01\xff\xff\xff\xff\x03\x01\xff\xff\xff\xff=\x01\0\0\b\x01@\x01\xff\xff\xff\xff\xff\xff\r\x01E\x01\xff\xffG\x01\0\0\xff\xff\x13\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01R\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff)\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xffJ\x01K\x01\0\x01\xff\xff\xff\xff\x03\x01\xff\xff\xff\xffR\x01\xff\xff\b\x01\0\0\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\0\x01^\x01\x13\x01\x03\x01\xff\xffb\x01c\x01\xff\xff\b\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\r\x01\xff\xff\xff\xff\xff\xffn\x01\xff\xff\x13\x01q\x01\xff\xff\xff\xff\xff\xff)\x01\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\0\0\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01R\x01\0\0C\x01D\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xffJ\x01K\x01\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01R\x01\xff\xff\xff\xfff\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01^\x01\x03\x01q\x01\xff\xffb\x01\xff\xff\b\x01\xff\xfff\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\xff\xffn\x01\x13\x01\xff\xffq\x01\xff\xff\xff\xff\0\0\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xffK\x01@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffS\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\0\x01[\x01\\\x01\x03\x01R\x01\0\0`\x01\xff\xff\b\x01c\x01\0\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\x13\x01b\x01o\x01p\x01\r\x01f\x01\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\0\0\xff\xffC\x01D\x01E\x01\xff\xff=\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\0\x01E\x01\xff\xff\x03\x01R\x01\xff\xff\xff\xffK\x01\b\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01R\x01\xff\xff^\x01\xff\xff\xff\xff\x13\x01b\x01\xff\xff\xff\xff\xff\xfff\x01\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01b\x01\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01n\x01\xff\xff\xff\xffq\x01\0\0\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\r\x01@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01K\x01\x1a\x01\x03\x01\x1c\x01\x1d\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff)\x01\xff\xff\x13\x01^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\0\0\xff\xff\xff\xff\xff\xff\0\0n\x01=\x01\xff\xffq\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xffE\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01K\x01\xff\xff\x03\x01\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff=\x01\xff\xff\r\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xffb\x01K\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xffn\x01\xff\xffX\x01q\x01\0\0)\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01=\x01\x03\x01q\x01@\x01\xff\xff\xff\xff\b\x01D\x01E\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xffK\x01\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\0\0\xff\xff\xff\xff\xff\xff^\x01\xff\xff`\x01\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01=\x01\xff\xff\x03\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\xff\xff\r\x01\xff\xffK\x01\xff\xff\xff\xff\xff\xff\x13\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xffK\x01\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff\xff\xff\0\0b\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\0\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xffK\x01\r\x01\xff\xff\x13\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff^\x01\xff\xff\xff\xff\0\0b\x01c\x01)\x01\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\xff\xff@\x01=\x01\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\r\x01E\x01\xff\xffK\x01\xff\xff\xff\xff\x13\x01K\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01R\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff\xff\xff\0\0b\x01c\x01)\x01\xff\xffb\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01\xff\xff\xff\xffq\x01n\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff=\x01\xff\xff\r\x01@\x01\xff\xff\xff\xff\0\x01D\x01E\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xffK\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\r\x01\xff\xffR\x01\0\0\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\x1a\x01^\x01\x1c\x01\x1d\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff)\x01\xff\xffn\x01=\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffE\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\x01\0\x01\xff\xff=\x01\x03\x01\xff\xff@\x01R\x01\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xffK\x01\xff\xff\xff\xff\x13\x01\xff\xff\xff\xffb\x01R\x01\0\0\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xffn\x01^\x01\xff\xffq\x01\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\b\x01\0\x01\xff\xff=\x01\xff\xff\r\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\r\x01\xff\xff\0\0K\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xffR\x01\0\0\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff)\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01=\x01\xff\xffq\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01=\x01\xff\xff\r\x01@\x01\xff\xffK\x01\xff\xffD\x01E\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xffK\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xffn\x01\0\0\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01=\x01\x03\x01q\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\r\x01\xff\xff\0\0K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff\0\0\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\0\x01\xff\xffE\x01\x03\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xff\xffR\x01\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01^\x01\x1c\x01\x1d\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01(\x01)\x01@\x01n\x01\xff\xff\0\x01q\x01E\x01\x03\x01\0\0\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\0\0R\x01=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\x1a\x01^\x01\x1c\x01\x1d\x01K\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff(\x01)\x01\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff^\x01\0\x01\xff\xff\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\b\x01\0\x01\xff\xff=\x01\xff\xff\r\x01@\x01n\x01\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xffK\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\0\0R\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff)\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01=\x01\xff\xff\xff\xff@\x01\xff\xffK\x01C\x01D\x01E\x01\xff\xff\xff\xff\0\0R\x01\xff\xffK\x01\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\x03\x01R\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\r\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\0\x01n\x01\xff\xff\x03\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xffn\x01\0\0\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\x03\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff=\x01\xff\xff)\x01@\x01\xff\xff\xff\xff\xff\xff\xff\xffE\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xffK\x01\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xffR\x01=\x01\xff\xff)\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xffK\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xffR\x01=\x01\xff\xff\xff\xff@\x01\xff\xffn\x01\xff\xffD\x01E\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xffK\x01b\x01c\x01\0\0\0\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01n\x01\0\x01\xff\xff\xff\xff\r\x01\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\0\0\xff\xff\r\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\0\0n\x01\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff=\x01\xff\xff\xff\xff@\x01K\x01\xff\xff\0\x01D\x01E\x01\x03\x01\xff\xffR\x01\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xff\xffR\x01\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\x1a\x01^\x01\x1c\x01\x1d\x01\xff\xffb\x01c\x01n\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xffn\x01\xff\xff8\x01\xff\xff:\x01;\x01<\x01\0\x01>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\r\x01@\x01\xff\xff\xff\xff\xff\xff\xff\xffE\x01\xff\xff\xff\xffS\x01\xff\xff\xff\xffK\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01[\x01\\\x01R\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\x01\0\x01\xff\xff)\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01o\x01p\x01\r\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01=\x01\xff\xff\xff\xff@\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xffR\x01\0\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff\r\x01\xff\xffb\x01c\x01=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xff\xff\xffE\x01\x1a\x01n\x01\x1c\x01\x1d\x01\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xffn\x01\0\x01\xff\xffE\x01\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01K\x01\0\x01\xff\xff\xff\xff\xff\xff\r\x01\xff\xffR\x01\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\x1a\x01^\x01\x1c\x01\x1d\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01=\x01\xff\xff)\x01@\x01n\x01\xff\xff\xff\xff\xff\xffE\x01\xff\xff\xff\xff)\x01\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xff\xff\xffE\x01=\x01\xff\xff^\x01@\x01\xff\xffK\x01b\x01c\x01E\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xffK\x01\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\0\x01n\x01\xff\xff\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\b\x01\xff\xffn\x01\x0b\x01\f\x01\r\x01\x0e\x01\xff\xff\xff\xff\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x011\x012\x013\x014\x015\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01C\x01\xff\xffE\x01F\x01G\x01H\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xffR\x01S\x01\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff[\x01\xff\xff\xff\xff^\x01_\x01\xff\xff\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01m\x01n\x01o\x01p\x01q\x01\xff\xff\xff\xfft\x01\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\x0f\x01\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff$\x01\xff\xff\xff\xff'\x01\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xff\xff\xff\xff\xffd\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\0\x01\x01\x01\x02\x01\xff\xfft\x01\x05\x01\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xff\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff$\x01\xff\xff\xff\xff'\x01\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xff\xff\xff\xff\xffd\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\0\x01\x01\x01\x02\x01\xff\xfft\x01\x05\x01\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xff\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff$\x01\xff\xff\xff\xff'\x01\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffd\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\0\x01l\x01m\x01\xff\xffo\x01\x05\x01\x06\x01\x07\x01\b\x01t\x01\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x011\x012\x013\x014\x015\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xffE\x01F\x01G\x01H\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff[\x01\xff\xff\xff\xff\xff\xff_\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01m\x01\xff\xffo\x01p\x01q\x01\0\x01\xff\xfft\x01\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\0\x01Y\x01\xff\xff\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01`\x01\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\0\x01Y\x01\xff\xff\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01`\x01\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\0\x01Y\x01\xff\xff\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01`\x01\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\x03\x01\x04\x01\x05\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\x0b\x01\xff\xff\r\x01l\x01m\x01\xff\xffo\x01\xff\xff\x13\x01\x14\x01\x15\x01t\x01\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\x1e\x01\xff\xff \x01!\x01\"\x01#\x01\xff\xff\xff\xff\xff\xff'\x01(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff5\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff@\x01A\x01\xff\xff\xff\xff\xff\xff\xff\xffF\x01G\x01\xff\xff\xff\xff\xff\xffK\x01L\x01\xff\xffN\x01\xff\xffP\x01Q\x01R\x01\xff\xffT\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffZ\x01\xff\xff\xff\xff\xff\xff\xff\xff_\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffe\x01\0\x01\xff\xffh\x01i\x01\x04\x01k\x01l\x01m\x01n\x01o\x01\xff\xffq\x01r\x01s\x01t\x01u\x01\xff\xff\x11\x01\xff\xff\x13\x01\xff\xff\xff\xff\x16\x01\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff\xff\xffA\x01\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\xff\xff\f\x01\\\x01]\x01\x0f\x01\x10\x01\xff\xffa\x01\xff\xffc\x01\xff\xff\xff\xfff\x01\xff\xff\xff\xff\xff\xff\x1b\x01\x1c\x01\xff\xff\x1e\x01\x1f\x01o\x01\xff\xffq\x01\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xff\xff\xffc\x01d\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\xff\xff\f\x01\xff\xff\xff\xff\xff\xff\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xff\xff\xffc\x01d\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xffn\x01o\x01p\x01\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\xff\xff\f\x01\xff\xff\xff\xff\xff\xff\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xff\xff\xffc\x01d\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xffn\x01o\x01p\x01\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\xff\xff\f\x01\xff\xff\xff\xff\xff\xff\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xff\xff\xffc\x01d\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xffn\x01o\x01p\x01\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\xff\xff\f\x01\xff\xff\xff\xff\xff\xff\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff\0\x01A\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01I\x01\xff\xffK\x01\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01`\x01\xff\xff\xff\xffc\x01d\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\0\x01A\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\0\x01A\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01\xff\xff\xff\xff\xff\xff\xff\xffM\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\r\x01\x0e\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\x1d\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xffE\x01F\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xffR\x01\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff[\x01\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xffb\x01\xff\xff\x0b\x01\f\x01\r\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01n\x01o\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xffE\x01F\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xffR\x01\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\xff\xffb\x01\x0b\x01\f\x01\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01n\x01o\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\xff\xff\xff\xff^\x01\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\n\x01\x0b\x01\f\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\xff\xff\xff\xff\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\x1a\x01\xff\xff\xff\xfft\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\x1a\x01\xff\xff\xff\xfft\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\f\x01\xff\xff\x0e\x01\xff\xffg\x01\x11\x01\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\xff\xff\x1b\x01\xff\xfft\x01\x1e\x01\x1f\x018\x01\xff\xff:\x01;\x01<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xffS\x01<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01[\x01\\\x01\xff\xff\xff\xff\xff\xffH\x01\x06\x01\xff\xffc\x01\xff\xffM\x01\xff\xff\f\x01\xff\xff\x0e\x01\xff\xffS\x01\x11\x01\xff\xffV\x01o\x01p\x01\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\x1e\x01\x1f\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff1\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01\x06\x01\xff\xff\xff\xff\xff\xffM\x01\xff\xff\f\x01\xff\xff\x0e\x01\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\x1e\x01\x1f\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff1\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01\x06\x01\xff\xff\xff\xff\xff\xffM\x01\xff\xff\f\x01\xff\xff\x0e\x01\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\x1e\x01\x1f\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff1\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xffJ\x01\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xffJ\x01\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01\xff\xff\xff\xff\xff\xff\x06\x01M\x01\xff\xff\xff\xff\n\x01\xff\xff\f\x01\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xff\x1c\x01c\x01\x1e\x01\x1f\x01\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01\x06\x01\xff\xff\b\x01\xff\xffM\x01\xff\xff\f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01\xff\xff\xff\xff\xff\xff\x06\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\f\x01\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff_\x01\xff\xff\xff\xff\x1c\x01c\x01\x1e\x01\x1f\x01\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01\x06\x01\x07\x01\xff\xff\xff\xffM\x01\x0b\x01\f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\x16\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1e\x01\x1f\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff1\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffY\x01\xff\xff[\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xffc\x01d\x01\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffY\x01\xff\xff[\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x011\x012\x013\x01\xff\xff\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffY\x01\xff\xff\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x011\x012\x013\x01\xff\xff\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\xff\xff\xff\xff\xff\xffY\x01\xff\xff\xff\xff\x0f\x01\x1e\x01\x1f\x018\x01\xff\xff:\x01;\x01<\x01\x17\x01>\x01\xff\xffg\x01A\x01B\x01\xff\xff\x1e\x01l\x01\xff\xff\xff\xffo\x011\x012\x013\x01\xff\xff\xff\xff6\x017\x018\x019\x01\xff\xffS\x01<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01[\x01\\\x01\xff\xff8\x01\xff\xff:\x01;\x01<\x01c\x01>\x01M\x01N\x01A\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01n\x01o\x01p\x01Y\x01\xff\xff\xff\xff\x0f\x01\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffg\x01Z\x01[\x01\\\x01\x1e\x01l\x01\xff\xff\xff\xffo\x01\xff\xffc\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\t\x01\xff\xff\xff\xffS\x01\xff\xff\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\xff\xff[\x01\\\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01l\x01\xff\xff\xff\xffo\x01p\x01*\x01+\x01,\x01-\x01.\x01\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\xff\xff\x07\x01\xff\xff\t\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\x01\x10\x01\xff\xff\xff\xff\xff\xffC\x01\xff\xff\xff\xff\xff\xff\xff\xffH\x01I\x01\x1b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01T\x01U\x01V\x01W\x01X\x01*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff`\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xfff\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\x01\xff\xff\xff\xff\xff\xff\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\xff\xffH\x01I\x01\t\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\x0f\x01\x10\x01\xff\xff\x12\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x01\x02\x01d\x01$\x01f\x01\xff\xff\xff\xff\xff\xff\t\x01*\x01+\x01,\x01-\x01.\x01\x0f\x01\x10\x01\xff\xff\x12\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff>\x01\xff\xff\xff\xff\xff\xff\xff\xffC\x01$\x01\xff\xff\xff\xff\xff\xffH\x01I\x01*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\x01\x01\x01\x02\x01a\x01\xff\xffC\x01\xff\xff\xff\xfff\x01\t\x01H\x01I\x01\xff\xff\xff\xff\xff\xff\x0f\x01\x10\x01\xff\xff\x12\x01\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\x1b\x01\xff\xff\xff\xff\xff\xff]\x01\xff\xff\x01\x01\x02\x01\xff\xff$\x01\xff\xff\xff\xff\xff\xfff\x01\t\x01*\x01+\x01,\x01-\x01.\x01\x0f\x01\x10\x01\xff\xff\x12\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x19\x01\xff\xff\x1b\x01\xff\xff\xff\xff>\x01\xff\xff\xff\xff\xff\xff\xff\xffC\x01$\x01\xff\xff\xff\xff\xff\xffH\x01I\x01*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01>\x01\x01\x01\x02\x01\xff\xff\xff\xffC\x01\xff\xff\xff\xfff\x01\t\x01H\x01I\x01\xff\xff\xff\xff\xff\xff\x0f\x01\x10\x01\xff\xff\x12\x01\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\x1b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x01\x02\x01\xff\xff$\x01\xff\xff\xff\xff\xff\xfff\x01\t\x01*\x01+\x01,\x01-\x01.\x01\x0f\x01\x10\x01\xff\xff\x12\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff>\x01\xff\xff\xff\xff\xff\xff\xff\xffC\x01$\x01\xff\xff\xff\xff\xff\xffH\x01I\x01*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\x01\x01\x01\x02\x01\xff\xff\xff\xffC\x01\xff\xff\xff\xfff\x01\t\x01H\x01I\x01\xff\xff\xff\xff\xff\xff\x0f\x01\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\x1b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x01\x02\x01\xff\xff$\x01\xff\xff\xff\xff\xff\xfff\x01\t\x01*\x01+\x01,\x01-\x01.\x01\x0f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff>\x01\xff\xff\xff\xff\xff\xff\xff\xffC\x01$\x01\xff\xff\xff\xff\xff\xffH\x01I\x01*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01>\x01\x01\x01\x02\x01\xff\xff\xff\xffC\x01\xff\xff\xff\xfff\x01\t\x01H\x01I\x01\xff\xff\xff\xff\xff\xff\x0f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\x1b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xff$\x01\xff\xff\xff\xff\xff\xfff\x01\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\x01\xff\xff\xff\xff\xff\xff\xff\xffC\x01\x0f\x01\xff\xff\xff\xff\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01$\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xfff\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01\xff\xff>\x01>\x01\xff\xffA\x01B\x01\xff\xffC\x01\xff\xff\xff\xff\xff\xff\xff\xffH\x01I\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xffU\x01V\x01W\x01X\x01\xff\xff[\x01\\\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xfff\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffo\x01p\x01",
  error_function: Stdlib__Parsing.parse_error,
  names_const: "AMPERAMPER\0AMPERSAND\0AND\0AS\0ASSERT\0BACKQUOTE\0BANG\0BAR\0BARBAR\0BARRBRACKET\0BEGIN\0CLASS\0COLON\0COLONCOLON\0COLONEQUAL\0COLONGREATER\0COMMA\0CONSTRAINT\0DO\0DONE\0DOT\0DOTDOT\0DOWNTO\0ELSE\0END\0EOF\0EQUAL\0EXCEPTION\0EXTERNAL\0FALSE\0FOR\0FUN\0FUNCTION\0FUNCTOR\0GREATER\0GREATERRBRACE\0GREATERRBRACKET\0IF\0IN\0INCLUDE\0INHERIT\0INITIALIZER\0LAZY\0LBRACE\0LBRACELESS\0LBRACKET\0LBRACKETBAR\0LBRACKETLESS\0LBRACKETGREATER\0LBRACKETPERCENT\0LBRACKETPERCENTPERCENT\0LESS\0LESSMINUS\0LET\0LPAREN\0LBRACKETAT\0LBRACKETATAT\0LBRACKETATATAT\0MATCH\0METHOD\0MINUS\0MINUSDOT\0MINUSGREATER\0MODULE\0MUTABLE\0NEW\0NONREC\0OBJECT\0OF\0OPEN\0OR\0PERCENT\0PLUS\0PLUSDOT\0PLUSEQ\0PRIVATE\0QUESTION\0QUOTE\0RBRACE\0RBRACKET\0REC\0RPAREN\0SEMI\0SEMISEMI\0SHARP\0SIG\0STAR\0STRUCT\0THEN\0TILDE\0TO\0TRUE\0TRY\0TYPE\0UNDERSCORE\0VAL\0VIRTUAL\0WHEN\0WHILE\0WITH\0EOL\0",
  names_block: "CHAR\0FLOAT\0INFIXOP0\0INFIXOP1\0INFIXOP2\0INFIXOP3\0INFIXOP4\0INT\0INT32\0INT64\0LABEL\0LIDENT\0NATIVEINT\0OPTLABEL\0PREFIXOP\0SHARPOP\0STRING\0UIDENT\0COMMENT\0DOCSTRING\0"
};

function implementation(lexfun, lexbuf) {
  return Stdlib__Parsing.yyparse(yytables, 1, lexfun, lexbuf);
}

function type_of_directive(x) {
  if (typeof x === "number") {
    return /* Dir_type_null */4;
  }
  switch (x.TAG | 0) {
    case /* Dir_bool */0 :
        return /* Dir_type_bool */0;
    case /* Dir_float */1 :
        return /* Dir_type_float */1;
    case /* Dir_int */2 :
        return /* Dir_type_int */2;
    case /* Dir_string */3 :
        return /* Dir_type_string */3;
    
  }
}

function string_of_type_directive(x) {
  switch (x) {
    case /* Dir_type_bool */0 :
        return "bool";
    case /* Dir_type_float */1 :
        return "float";
    case /* Dir_type_int */2 :
        return "int";
    case /* Dir_type_string */3 :
        return "string";
    case /* Dir_type_null */4 :
        return "null";
    
  }
}

const $$Error$4 = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Lexer.Error");

function assert_same_type(lexbuf, x, y) {
  const lhs = type_of_directive(x);
  const rhs = type_of_directive(y);
  if (lhs !== rhs) {
    throw new Caml_js_exceptions.MelangeError($$Error$4, {
              MEL_EXN_ID: $$Error$4,
              _1: {
                TAG: /* Conditional_expr_expected_type */7,
                _0: lhs,
                _1: rhs
              },
              _2: curr(lexbuf)
            });
  }
  return y;
}

const directive_built_in_values = Stdlib__Hashtbl.create(undefined, 51);

Stdlib__Hashtbl.replace(directive_built_in_values, "OCAML_VERSION", {
      TAG: /* Dir_string */3,
      _0: Stdlib__Sys.ocaml_version
    });

let tmp;

let exit = 0;

let i;

try {
  i = Stdlib__String.rindex(Stdlib__Sys.ocaml_version, /* '+' */43);
  exit = 1;
}
catch (raw_exn$1){
  const exn$2 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
  if (exn$2.MEL_EXN_ID === Stdlib.Not_found) {
    tmp = "";
  } else {
    throw new Caml_js_exceptions.MelangeError(exn$2.MEL_EXN_ID, exn$2);
  }
}

if (exit === 1) {
  tmp = Stdlib__String.sub(Stdlib__Sys.ocaml_version, i + 1 | 0, (Stdlib__Sys.ocaml_version.length - i | 0) - 1 | 0);
}

Stdlib__Hashtbl.replace(directive_built_in_values, "OCAML_PATCH", {
      TAG: /* Dir_string */3,
      _0: tmp
    });

Stdlib__Hashtbl.replace(directive_built_in_values, "OS_TYPE", {
      TAG: /* Dir_string */3,
      _0: Stdlib__Sys.os_type
    });

Stdlib__Hashtbl.replace(directive_built_in_values, "BIG_ENDIAN", {
      TAG: /* Dir_bool */0,
      _0: Stdlib__Sys.big_endian
    });

Stdlib__Hashtbl.replace(directive_built_in_values, "WORD_SIZE", {
      TAG: /* Dir_int */2,
      _0: Stdlib__Sys.word_size
    });

function semantic_version_parse(str, start, last_index) {
  const aux = function (_start, _acc, last_index) {
    while(true) {
      const acc = _acc;
      const start = _start;
      if (start > last_index) {
        return [
                acc,
                start
              ];
      }
      const c = str.charCodeAt(start);
      if (c === /* '.' */46) {
        return [
                acc,
                start + 1 | 0
              ];
      }
      const v = c - /* '0' */48 | 0;
      if (!(v >= 0 && v <= 9)) {
        return [
                acc,
                start
              ];
      }
      _acc = Math.imul(acc, 10) + v | 0;
      _start = start + 1 | 0;
      continue ;
    };
  };
  const match = aux(start, 0, last_index);
  const match$1 = aux(match[1], 0, last_index);
  const match$2 = aux(match$1[1], 0, last_index);
  const patch_end = match$2[1];
  const additional = Stdlib__String.sub(str, patch_end, (last_index - patch_end | 0) + 1 | 0);
  return [
          [
            match[0],
            match$1[0],
            match$2[0]
          ],
          additional
        ];
}

function defined(str) {
  let val;
  try {
    val = Stdlib__Hashtbl.find(directive_built_in_values, str);
  }
  catch (exn){
    try {
      Caml_sys.caml_sys_getenv(str);
      return true;
    }
    catch (exn$1){
      return false;
    }
  }
  if (typeof val === "number") {
    return false;
  } else {
    return true;
  }
}

function query(loc, str) {
  let v;
  try {
    v = Stdlib__Hashtbl.find(directive_built_in_values, str);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      let exit = 0;
      let v$1;
      try {
        v$1 = Caml_sys.caml_sys_getenv(str);
        exit = 2;
      }
      catch (raw_exn$1){
        const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
        if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
          return {
                  TAG: /* Dir_bool */0,
                  _0: false
                };
        }
        throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
      }
      if (exit === 2) {
        try {
          return {
                  TAG: /* Dir_bool */0,
                  _0: Stdlib.bool_of_string(v$1)
                };
        }
        catch (exn$2){
          try {
            return {
                    TAG: /* Dir_int */2,
                    _0: Caml_format.caml_int_of_string(v$1)
                  };
          }
          catch (exn$3){
            try {
              return {
                      TAG: /* Dir_float */1,
                      _0: Caml_format.caml_float_of_string(v$1)
                    };
            }
            catch (exn$4){
              return {
                      TAG: /* Dir_string */3,
                      _0: v$1
                    };
            }
          }
        }
      }
      
    } else {
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  }
  if (typeof v === "number") {
    return {
            TAG: /* Dir_bool */0,
            _0: false
          };
  } else {
    return v;
  }
}

function value_of_token(loc, t) {
  if (typeof t === "number") {
    switch (t) {
      case /* FALSE */29 :
          return {
                  TAG: /* Dir_bool */0,
                  _0: false
                };
      case /* TRUE */91 :
          return {
                  TAG: /* Dir_bool */0,
                  _0: true
                };
      default:
        throw new Caml_js_exceptions.MelangeError($$Error$4, {
                  MEL_EXN_ID: $$Error$4,
                  _1: /* Unexpected_token_in_conditional */4,
                  _2: loc
                });
    }
  } else {
    switch (t.TAG | 0) {
      case /* FLOAT */1 :
          return {
                  TAG: /* Dir_float */1,
                  _0: Caml_format.caml_float_of_string(t._0)
                };
      case /* INT */7 :
          return {
                  TAG: /* Dir_int */2,
                  _0: t._0
                };
      case /* STRING */16 :
          return {
                  TAG: /* Dir_string */3,
                  _0: t._0[0]
                };
      case /* UIDENT */17 :
          return query(loc, t._0);
      default:
        throw new Caml_js_exceptions.MelangeError($$Error$4, {
                  MEL_EXN_ID: $$Error$4,
                  _1: /* Unexpected_token_in_conditional */4,
                  _2: loc
                });
    }
  }
}

function directive_parse(token_with_comments, lexbuf) {
  const look_ahead = {
    contents: undefined
  };
  const token = function (param) {
    const v = look_ahead.contents;
    if (v !== undefined) {
      look_ahead.contents = undefined;
      return v;
    }
    let _param;
    while(true) {
      const t = Curry._1(token_with_comments, lexbuf);
      if (typeof t === "number") {
        switch (t) {
          case /* EOF */25 :
              throw new Caml_js_exceptions.MelangeError($$Error$4, {
                        MEL_EXN_ID: $$Error$4,
                        _1: /* Unterminated_if */2,
                        _2: curr(lexbuf)
                      });
          case /* EOL */100 :
              _param = undefined;
              continue ;
          default:
            return t;
        }
      } else {
        switch (t.TAG | 0) {
          case /* COMMENT */18 :
          case /* DOCSTRING */19 :
              _param = undefined;
              continue ;
          default:
            return t;
        }
      }
    };
  };
  const push = function (e) {
    if (look_ahead.contents !== undefined) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  24607,
                  4
                ]
              });
    }
    look_ahead.contents = e;
  };
  const token_op = function (calc, no, lhs) {
    const op = token(undefined);
    let exit = 0;
    if (typeof op === "number") {
      switch (op) {
        case /* EQUAL */26 :
        case /* GREATER */34 :
        case /* LESS */51 :
            exit = 1;
            break;
        default:
          return Curry._1(no, op);
      }
    } else {
      if (op.TAG !== /* INFIXOP0 */2) {
        return Curry._1(no, op);
      }
      switch (op._0) {
        case "=~" :
            if (!calc) {
              return true;
            }
            let exit$1 = 0;
            if (typeof lhs === "number" || lhs.TAG !== /* Dir_string */3) {
              exit$1 = 2;
            } else {
              const curr_loc = curr(lexbuf);
              const rhs = value_of_token(curr_loc, token(undefined));
              let exit$2 = 0;
              if (typeof rhs === "number") {
                exit$2 = 3;
              } else {
                if (rhs.TAG === /* Dir_string */3) {
                  let lhs$1 = lhs._0;
                  let str = rhs._0;
                  const last_index = str.length - 1 | 0;
                  if (last_index < 0) {
                    throw new Caml_js_exceptions.MelangeError($$Error$4, {
                              MEL_EXN_ID: $$Error$4,
                              _1: {
                                TAG: /* Illegal_semver */6,
                                _0: str
                              },
                              _2: curr_loc
                            });
                  }
                  const v = str.charCodeAt(0);
                  let match;
                  let exit$3 = 0;
                  if (v !== 94) {
                    if (v >= 63) {
                      if (v !== 126) {
                        exit$3 = 1;
                      } else {
                        match = [
                          "Approximate",
                          semantic_version_parse(str, 1, last_index)
                        ];
                      }
                    } else if (v >= 60) {
                      switch (v) {
                        case 60 :
                            if (last_index === 0) {
                              throw new Caml_js_exceptions.MelangeError($$Error$4, {
                                        MEL_EXN_ID: $$Error$4,
                                        _1: {
                                          TAG: /* Illegal_semver */6,
                                          _0: str
                                        },
                                        _2: curr_loc
                                      });
                            }
                            match = str[1] === "=" ? [
                                "Le",
                                semantic_version_parse(str, 2, last_index)
                              ] : [
                                "Lt",
                                semantic_version_parse(str, 1, last_index)
                              ];
                            break;
                        case 61 :
                            exit$3 = 1;
                            break;
                        case 62 :
                            if (last_index === 0) {
                              throw new Caml_js_exceptions.MelangeError($$Error$4, {
                                        MEL_EXN_ID: $$Error$4,
                                        _1: {
                                          TAG: /* Illegal_semver */6,
                                          _0: str
                                        },
                                        _2: curr_loc
                                      });
                            }
                            match = str[1] === "=" ? [
                                "Ge",
                                semantic_version_parse(str, 2, last_index)
                              ] : [
                                "Gt",
                                semantic_version_parse(str, 1, last_index)
                              ];
                            break;
                        
                      }
                    } else {
                      exit$3 = 1;
                    }
                  } else {
                    match = [
                      "Compatible",
                      semantic_version_parse(str, 1, last_index)
                    ];
                  }
                  if (exit$3 === 1) {
                    match = [
                      "Exact",
                      semantic_version_parse(str, 0, last_index)
                    ];
                  }
                  const version = match[1][0];
                  const major = version[0];
                  const pred = match[0];
                  const match$1 = semantic_version_parse(lhs$1, 0, lhs$1.length - 1 | 0);
                  const lversion = match$1[0];
                  if (pred === "Ge") {
                    return Caml_obj.caml_greaterequal(lversion, version);
                  }
                  if (pred === "Gt") {
                    return Caml_obj.caml_greaterthan(lversion, version);
                  }
                  if (pred === "Le") {
                    return Caml_obj.caml_lessequal(lversion, version);
                  }
                  if (pred === "Lt") {
                    return Caml_obj.caml_lessthan(lversion, version);
                  }
                  if (pred === "Exact") {
                    return Caml_obj.caml_equal(lversion, version);
                  }
                  const l_major = lversion[0];
                  if (pred === "Compatible") {
                    return major === l_major;
                  } else if (major === l_major) {
                    return version[1] === lversion[1];
                  } else {
                    return false;
                  }
                }
                exit$2 = 3;
              }
              if (exit$2 === 3) {
                throw new Caml_js_exceptions.MelangeError($$Error$4, {
                          MEL_EXN_ID: $$Error$4,
                          _1: {
                            TAG: /* Conditional_expr_expected_type */7,
                            _0: /* Dir_type_string */3,
                            _1: type_of_directive(lhs)
                          },
                          _2: curr(lexbuf)
                        });
              }
              
            }
            if (exit$1 === 2) {
              throw new Caml_js_exceptions.MelangeError($$Error$4, {
                        MEL_EXN_ID: $$Error$4,
                        _1: {
                          TAG: /* Conditional_expr_expected_type */7,
                          _0: /* Dir_type_string */3,
                          _1: type_of_directive(lhs)
                        },
                        _2: curr(lexbuf)
                      });
            }
            break;
        case "<=" :
        case "<>" :
        case ">=" :
            exit = 1;
            break;
        default:
          return Curry._1(no, op);
      }
    }
    if (exit === 1) {
      let f;
      let exit$4 = 0;
      if (typeof op === "number") {
        switch (op) {
          case /* EQUAL */26 :
              f = Caml_obj.caml_equal;
              break;
          case /* GREATER */34 :
              f = Caml_obj.caml_greaterthan;
              break;
          case /* LESS */51 :
              f = Caml_obj.caml_lessthan;
              break;
          default:
            exit$4 = 2;
        }
      } else if (op.TAG === /* INFIXOP0 */2) {
        switch (op._0) {
          case "<=" :
              f = Caml_obj.caml_lessequal;
              break;
          case "<>" :
              f = Caml_obj.caml_notequal;
              break;
          default:
            exit$4 = 2;
        }
      } else {
        exit$4 = 2;
      }
      if (exit$4 === 2) {
        throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                  MEL_EXN_ID: "Assert_failure",
                  _1: [
                    "jscomp/test/ocaml_typedtree_test.ml",
                    24626,
                    17
                  ]
                });
      }
      const curr_loc$1 = curr(lexbuf);
      const rhs$1 = value_of_token(curr_loc$1, token(undefined));
      if (calc) {
        return Curry._2(f, lhs, assert_same_type(lexbuf, lhs, rhs$1));
      } else {
        return true;
      }
    }
    
  };
  const parse_or_aux = function (calc, v) {
    const e = token(undefined);
    if (e === 8) {
      const calc$1 = calc && !v;
      const b = parse_or_aux(calc$1, parse_and_aux(calc$1, parse_relation(calc$1)));
      if (v) {
        return true;
      } else {
        return b;
      }
    }
    push(e);
    return v;
  };
  const parse_relation = function (calc) {
    const curr_token = token(undefined);
    const curr_loc = curr(lexbuf);
    if (typeof curr_token === "number") {
      switch (curr_token) {
        case /* FALSE */29 :
            return false;
        case /* LPAREN */54 :
            const v = parse_or_aux(calc, parse_and_aux(calc, parse_relation(calc)));
            const match = token(undefined);
            if (match === 81) {
              return v;
            }
            throw new Caml_js_exceptions.MelangeError($$Error$4, {
                      MEL_EXN_ID: $$Error$4,
                      _1: /* Unterminated_paren_in_conditional */1,
                      _2: curr(lexbuf)
                    });
        case /* TRUE */91 :
            return true;
        default:
          throw new Caml_js_exceptions.MelangeError($$Error$4, {
                    MEL_EXN_ID: $$Error$4,
                    _1: /* Unexpected_token_in_conditional */4,
                    _2: curr_loc
                  });
      }
    } else {
      switch (curr_token.TAG | 0) {
        case /* FLOAT */1 :
            return token_op(calc, (function (e) {
                          throw new Caml_js_exceptions.MelangeError($$Error$4, {
                                    MEL_EXN_ID: $$Error$4,
                                    _1: {
                                      TAG: /* Conditional_expr_expected_type */7,
                                      _0: /* Dir_type_bool */0,
                                      _1: /* Dir_type_float */1
                                    },
                                    _2: curr_loc
                                  });
                        }), {
                        TAG: /* Dir_float */1,
                        _0: Caml_format.caml_float_of_string(curr_token._0)
                      });
        case /* INT */7 :
            return token_op(calc, (function (e) {
                          throw new Caml_js_exceptions.MelangeError($$Error$4, {
                                    MEL_EXN_ID: $$Error$4,
                                    _1: {
                                      TAG: /* Conditional_expr_expected_type */7,
                                      _0: /* Dir_type_bool */0,
                                      _1: /* Dir_type_int */2
                                    },
                                    _2: curr_loc
                                  });
                        }), {
                        TAG: /* Dir_int */2,
                        _0: curr_token._0
                      });
        case /* LIDENT */11 :
            const r = curr_token._0;
            switch (r) {
              case "defined" :
              case "undefined" :
                  break;
              default:
                throw new Caml_js_exceptions.MelangeError($$Error$4, {
                          MEL_EXN_ID: $$Error$4,
                          _1: /* Unexpected_token_in_conditional */4,
                          _2: curr_loc
                        });
            }
            const t = token(undefined);
            const loc = curr(lexbuf);
            if (typeof t === "number") {
              throw new Caml_js_exceptions.MelangeError($$Error$4, {
                        MEL_EXN_ID: $$Error$4,
                        _1: /* Unexpected_token_in_conditional */4,
                        _2: loc
                      });
            }
            if (t.TAG === /* UIDENT */17) {
              const s = t._0;
              if (calc) {
                if (Caml_string.get(r, 0) === /* 'u' */117) {
                  return !defined(s);
                } else {
                  return defined(s);
                }
              } else {
                return true;
              }
            }
            throw new Caml_js_exceptions.MelangeError($$Error$4, {
                      MEL_EXN_ID: $$Error$4,
                      _1: /* Unexpected_token_in_conditional */4,
                      _2: loc
                    });
            break;
        case /* STRING */16 :
            return token_op(calc, (function (e) {
                          throw new Caml_js_exceptions.MelangeError($$Error$4, {
                                    MEL_EXN_ID: $$Error$4,
                                    _1: {
                                      TAG: /* Conditional_expr_expected_type */7,
                                      _0: /* Dir_type_bool */0,
                                      _1: /* Dir_type_string */3
                                    },
                                    _2: curr_loc
                                  });
                        }), {
                        TAG: /* Dir_string */3,
                        _0: curr_token._0[0]
                      });
        case /* UIDENT */17 :
            const value_v = query(curr_loc, curr_token._0);
            return token_op(calc, (function (e) {
                          push(e);
                          if (typeof value_v !== "number" && value_v.TAG === /* Dir_bool */0) {
                            return value_v._0;
                          }
                          const ty = type_of_directive(value_v);
                          throw new Caml_js_exceptions.MelangeError($$Error$4, {
                                    MEL_EXN_ID: $$Error$4,
                                    _1: {
                                      TAG: /* Conditional_expr_expected_type */7,
                                      _0: /* Dir_type_bool */0,
                                      _1: ty
                                    },
                                    _2: curr_loc
                                  });
                        }), value_v);
        default:
          throw new Caml_js_exceptions.MelangeError($$Error$4, {
                    MEL_EXN_ID: $$Error$4,
                    _1: /* Unexpected_token_in_conditional */4,
                    _2: curr_loc
                  });
      }
    }
  };
  const parse_and_aux = function (calc, v) {
    const e = token(undefined);
    if (typeof e === "number") {
      if (e) {
        push(e);
        return v;
      }
      const calc$1 = calc && v;
      const b = parse_and_aux(calc$1, parse_relation(calc$1));
      if (v) {
        return b;
      } else {
        return false;
      }
    }
    push(e);
    return v;
  };
  const v = parse_or_aux(true, parse_and_aux(true, parse_relation(true)));
  const match = token(undefined);
  if (match === 88) {
    return v;
  }
  throw new Caml_js_exceptions.MelangeError($$Error$4, {
            MEL_EXN_ID: $$Error$4,
            _1: /* Expect_hash_then_in_conditional */5,
            _2: curr(lexbuf)
          });
}

function is_elif(i) {
  if (typeof i === "number" || !(i.TAG === /* LIDENT */11 && i._0 === "elif")) {
    return false;
  } else {
    return true;
  }
}

const keyword_table = create_hashtable(149, {
      hd: [
        "and",
        /* AND */2
      ],
      tl: {
        hd: [
          "as",
          /* AS */3
        ],
        tl: {
          hd: [
            "assert",
            /* ASSERT */4
          ],
          tl: {
            hd: [
              "begin",
              /* BEGIN */10
            ],
            tl: {
              hd: [
                "class",
                /* CLASS */11
              ],
              tl: {
                hd: [
                  "constraint",
                  /* CONSTRAINT */17
                ],
                tl: {
                  hd: [
                    "do",
                    /* DO */18
                  ],
                  tl: {
                    hd: [
                      "done",
                      /* DONE */19
                    ],
                    tl: {
                      hd: [
                        "downto",
                        /* DOWNTO */22
                      ],
                      tl: {
                        hd: [
                          "else",
                          /* ELSE */23
                        ],
                        tl: {
                          hd: [
                            "end",
                            /* END */24
                          ],
                          tl: {
                            hd: [
                              "exception",
                              /* EXCEPTION */27
                            ],
                            tl: {
                              hd: [
                                "external",
                                /* EXTERNAL */28
                              ],
                              tl: {
                                hd: [
                                  "false",
                                  /* FALSE */29
                                ],
                                tl: {
                                  hd: [
                                    "for",
                                    /* FOR */30
                                  ],
                                  tl: {
                                    hd: [
                                      "fun",
                                      /* FUN */31
                                    ],
                                    tl: {
                                      hd: [
                                        "function",
                                        /* FUNCTION */32
                                      ],
                                      tl: {
                                        hd: [
                                          "functor",
                                          /* FUNCTOR */33
                                        ],
                                        tl: {
                                          hd: [
                                            "if",
                                            /* IF */37
                                          ],
                                          tl: {
                                            hd: [
                                              "in",
                                              /* IN */38
                                            ],
                                            tl: {
                                              hd: [
                                                "include",
                                                /* INCLUDE */39
                                              ],
                                              tl: {
                                                hd: [
                                                  "inherit",
                                                  /* INHERIT */40
                                                ],
                                                tl: {
                                                  hd: [
                                                    "initializer",
                                                    /* INITIALIZER */41
                                                  ],
                                                  tl: {
                                                    hd: [
                                                      "lazy",
                                                      /* LAZY */42
                                                    ],
                                                    tl: {
                                                      hd: [
                                                        "let",
                                                        /* LET */53
                                                      ],
                                                      tl: {
                                                        hd: [
                                                          "match",
                                                          /* MATCH */58
                                                        ],
                                                        tl: {
                                                          hd: [
                                                            "method",
                                                            /* METHOD */59
                                                          ],
                                                          tl: {
                                                            hd: [
                                                              "module",
                                                              /* MODULE */63
                                                            ],
                                                            tl: {
                                                              hd: [
                                                                "mutable",
                                                                /* MUTABLE */64
                                                              ],
                                                              tl: {
                                                                hd: [
                                                                  "new",
                                                                  /* NEW */65
                                                                ],
                                                                tl: {
                                                                  hd: [
                                                                    "nonrec",
                                                                    /* NONREC */66
                                                                  ],
                                                                  tl: {
                                                                    hd: [
                                                                      "object",
                                                                      /* OBJECT */67
                                                                    ],
                                                                    tl: {
                                                                      hd: [
                                                                        "of",
                                                                        /* OF */68
                                                                      ],
                                                                      tl: {
                                                                        hd: [
                                                                          "open",
                                                                          /* OPEN */69
                                                                        ],
                                                                        tl: {
                                                                          hd: [
                                                                            "or",
                                                                            /* OR */70
                                                                          ],
                                                                          tl: {
                                                                            hd: [
                                                                              "private",
                                                                              /* PRIVATE */75
                                                                            ],
                                                                            tl: {
                                                                              hd: [
                                                                                "rec",
                                                                                /* REC */80
                                                                              ],
                                                                              tl: {
                                                                                hd: [
                                                                                  "sig",
                                                                                  /* SIG */85
                                                                                ],
                                                                                tl: {
                                                                                  hd: [
                                                                                    "struct",
                                                                                    /* STRUCT */87
                                                                                  ],
                                                                                  tl: {
                                                                                    hd: [
                                                                                      "then",
                                                                                      /* THEN */88
                                                                                    ],
                                                                                    tl: {
                                                                                      hd: [
                                                                                        "to",
                                                                                        /* TO */90
                                                                                      ],
                                                                                      tl: {
                                                                                        hd: [
                                                                                          "true",
                                                                                          /* TRUE */91
                                                                                        ],
                                                                                        tl: {
                                                                                          hd: [
                                                                                            "try",
                                                                                            /* TRY */92
                                                                                          ],
                                                                                          tl: {
                                                                                            hd: [
                                                                                              "type",
                                                                                              /* TYPE */93
                                                                                            ],
                                                                                            tl: {
                                                                                              hd: [
                                                                                                "val",
                                                                                                /* VAL */95
                                                                                              ],
                                                                                              tl: {
                                                                                                hd: [
                                                                                                  "virtual",
                                                                                                  /* VIRTUAL */96
                                                                                                ],
                                                                                                tl: {
                                                                                                  hd: [
                                                                                                    "when",
                                                                                                    /* WHEN */97
                                                                                                  ],
                                                                                                  tl: {
                                                                                                    hd: [
                                                                                                      "while",
                                                                                                      /* WHILE */98
                                                                                                    ],
                                                                                                    tl: {
                                                                                                      hd: [
                                                                                                        "with",
                                                                                                        /* WITH */99
                                                                                                      ],
                                                                                                      tl: {
                                                                                                        hd: [
                                                                                                          "mod",
                                                                                                          {
                                                                                                            TAG: /* INFIXOP3 */5,
                                                                                                            _0: "mod"
                                                                                                          }
                                                                                                        ],
                                                                                                        tl: {
                                                                                                          hd: [
                                                                                                            "land",
                                                                                                            {
                                                                                                              TAG: /* INFIXOP3 */5,
                                                                                                              _0: "land"
                                                                                                            }
                                                                                                          ],
                                                                                                          tl: {
                                                                                                            hd: [
                                                                                                              "lor",
                                                                                                              {
                                                                                                                TAG: /* INFIXOP3 */5,
                                                                                                                _0: "lor"
                                                                                                              }
                                                                                                            ],
                                                                                                            tl: {
                                                                                                              hd: [
                                                                                                                "lxor",
                                                                                                                {
                                                                                                                  TAG: /* INFIXOP3 */5,
                                                                                                                  _0: "lxor"
                                                                                                                }
                                                                                                              ],
                                                                                                              tl: {
                                                                                                                hd: [
                                                                                                                  "lsl",
                                                                                                                  {
                                                                                                                    TAG: /* INFIXOP4 */6,
                                                                                                                    _0: "lsl"
                                                                                                                  }
                                                                                                                ],
                                                                                                                tl: {
                                                                                                                  hd: [
                                                                                                                    "lsr",
                                                                                                                    {
                                                                                                                      TAG: /* INFIXOP4 */6,
                                                                                                                      _0: "lsr"
                                                                                                                    }
                                                                                                                  ],
                                                                                                                  tl: {
                                                                                                                    hd: [
                                                                                                                      "asr",
                                                                                                                      {
                                                                                                                        TAG: /* INFIXOP4 */6,
                                                                                                                        _0: "asr"
                                                                                                                      }
                                                                                                                    ],
                                                                                                                    tl: /* [] */0
                                                                                                                  }
                                                                                                                }
                                                                                                              }
                                                                                                            }
                                                                                                          }
                                                                                                        }
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    });

const initial_string_buffer = Caml_bytes.caml_create_bytes(256);

const string_buff = {
  contents: initial_string_buffer
};

const string_index = {
  contents: 0
};

function reset_string_buffer(param) {
  string_buff.contents = initial_string_buffer;
  string_index.contents = 0;
}

function store_string_char(c) {
  if (string_index.contents >= string_buff.contents.length) {
    const new_buff = Caml_bytes.caml_create_bytes((string_buff.contents.length << 1));
    Stdlib__Bytes.blit(string_buff.contents, 0, new_buff, 0, string_buff.contents.length);
    string_buff.contents = new_buff;
  }
  string_buff.contents[string_index.contents] = c;
  string_index.contents = string_index.contents + 1 | 0;
}

function store_string(s) {
  for(let i = 0 ,i_finish = s.length; i < i_finish; ++i){
    store_string_char(Caml_string.get(s, i));
  }
}

function get_stored_string(param) {
  const s = Stdlib__Bytes.sub_string(string_buff.contents, 0, string_index.contents);
  string_buff.contents = initial_string_buffer;
  return s;
}

const string_start_loc = {
  contents: none
};

const comment_start_loc = {
  contents: /* [] */0
};

const is_in_string = {
  contents: false
};

const print_warnings = {
  contents: true
};

const if_then_else = {
  contents: /* Dir_out */2
};

const sharp_look_ahead = {
  contents: undefined
};

function with_comment_buffer(comment, lexbuf) {
  const start_loc = curr(lexbuf);
  comment_start_loc.contents = {
    hd: start_loc,
    tl: /* [] */0
  };
  reset_string_buffer(undefined);
  const end_loc = Curry._1(comment, lexbuf);
  const s = get_stored_string(undefined);
  reset_string_buffer(undefined);
  const loc_loc_start = start_loc.loc_start;
  const loc_loc_end = end_loc.loc_end;
  const loc_loc_ghost = start_loc.loc_ghost;
  const loc = {
    loc_start: loc_loc_start,
    loc_end: loc_loc_end,
    loc_ghost: loc_loc_ghost
  };
  return [
          s,
          loc
        ];
}

function char_for_backslash(c) {
  if (c < 110) {
    if (c !== 98) {
      return c;
    } else {
      return /* '\b' */8;
    }
  }
  if (c >= 117) {
    return c;
  }
  switch (c) {
    case 110 :
        return /* '\n' */10;
    case 114 :
        return /* '\r' */13;
    case 111 :
    case 112 :
    case 113 :
    case 115 :
        return c;
    case 116 :
        return /* '\t' */9;
    
  }
}

function char_for_decimal_code(lexbuf, i) {
  const c = (Math.imul(100, Stdlib__Lexing.lexeme_char(lexbuf, i) - 48 | 0) + Math.imul(10, Stdlib__Lexing.lexeme_char(lexbuf, i + 1 | 0) - 48 | 0) | 0) + (Stdlib__Lexing.lexeme_char(lexbuf, i + 2 | 0) - 48 | 0) | 0;
  if (!(c < 0 || c > 255)) {
    return Stdlib__Char.chr(c);
  }
  if (Caml_obj.caml_notequal(comment_start_loc.contents, /* [] */0)) {
    return /* 'x' */120;
  }
  throw new Caml_js_exceptions.MelangeError($$Error$4, {
            MEL_EXN_ID: $$Error$4,
            _1: {
              TAG: /* Illegal_escape */1,
              _0: Stdlib__Lexing.lexeme(lexbuf)
            },
            _2: curr(lexbuf)
          });
}

function char_for_hexadecimal_code(lexbuf, i) {
  const d1 = Stdlib__Lexing.lexeme_char(lexbuf, i);
  const val1 = d1 >= 97 ? d1 - 87 | 0 : (
      d1 >= 65 ? d1 - 55 | 0 : d1 - 48 | 0
    );
  const d2 = Stdlib__Lexing.lexeme_char(lexbuf, i + 1 | 0);
  const val2 = d2 >= 97 ? d2 - 87 | 0 : (
      d2 >= 65 ? d2 - 55 | 0 : d2 - 48 | 0
    );
  return Stdlib__Char.chr((val1 << 4) + val2 | 0);
}

function cvt_int_literal(s) {
  return -Caml_format.caml_int_of_string("-" + s) | 0;
}

function cvt_int32_literal(s) {
  return -Caml_format.caml_int32_of_string("-" + Stdlib__String.sub(s, 0, s.length - 1 | 0)) | 0;
}

function cvt_int64_literal(s) {
  return Caml_int64.neg(Caml_format.caml_int64_of_string("-" + Stdlib__String.sub(s, 0, s.length - 1 | 0)));
}

function cvt_nativeint_literal(s) {
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              24914,
              30
            ]
          });
}

function remove_underscores(s) {
  const l = s.length;
  const b = Caml_bytes.caml_create_bytes(l);
  let _src = 0;
  let _dst = 0;
  while(true) {
    const dst = _dst;
    const src = _src;
    if (src >= l) {
      if (dst >= l) {
        return s;
      } else {
        return Stdlib__Bytes.sub_string(b, 0, dst);
      }
    }
    const c = Caml_string.get(s, src);
    if (c !== 95) {
      Caml_bytes.set(b, dst, c);
      _dst = dst + 1 | 0;
      _src = src + 1 | 0;
      continue ;
    }
    _src = src + 1 | 0;
    continue ;
  };
}

function get_label_name(lexbuf) {
  const s = Stdlib__Lexing.lexeme(lexbuf);
  const name = Stdlib__String.sub(s, 1, s.length - 2 | 0);
  if (Stdlib__Hashtbl.mem(keyword_table, name)) {
    throw new Caml_js_exceptions.MelangeError($$Error$4, {
              MEL_EXN_ID: $$Error$4,
              _1: {
                TAG: /* Keyword_as_label */4,
                _0: name
              },
              _2: curr(lexbuf)
            });
  }
  return name;
}

function update_loc(lexbuf, file, line, absolute, chars) {
  const pos = lexbuf.lex_curr_p;
  const new_file = file !== undefined ? file : pos.pos_fname;
  lexbuf.lex_curr_p = {
    pos_fname: new_file,
    pos_lnum: absolute ? line : pos.pos_lnum + line | 0,
    pos_bol: pos.pos_cnum - chars | 0,
    pos_cnum: pos.pos_cnum
  };
}

const preprocessor = {
  contents: undefined
};

const escaped_newlines = {
  contents: false
};

const comment_list = {
  contents: /* [] */0
};

function add_comment(com) {
  comment_list.contents = {
    hd: com,
    tl: comment_list.contents
  };
}

function add_docstring_comment(ds) {
  add_comment([
        ds.ds_body,
        ds.ds_loc
      ]);
}

function report_error$2(ppf, c) {
  if (typeof c === "number") {
    switch (c) {
      case /* Unterminated_string */0 :
          return Stdlib__Format.fprintf(ppf)(/* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "String literal not terminated",
                        _1: /* End_of_format */0
                      },
                      _1: "String literal not terminated"
                    });
      case /* Unterminated_paren_in_conditional */1 :
          return Stdlib__Format.fprintf(ppf)(/* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "Unterminated parens in conditional predicate",
                        _1: /* End_of_format */0
                      },
                      _1: "Unterminated parens in conditional predicate"
                    });
      case /* Unterminated_if */2 :
          return Stdlib__Format.fprintf(ppf)(/* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "#if not terminated",
                        _1: /* End_of_format */0
                      },
                      _1: "#if not terminated"
                    });
      case /* Unterminated_else */3 :
          return Stdlib__Format.fprintf(ppf)(/* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "#else not terminated",
                        _1: /* End_of_format */0
                      },
                      _1: "#else not terminated"
                    });
      case /* Unexpected_token_in_conditional */4 :
          return Stdlib__Format.fprintf(ppf)(/* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "Unexpected token in conditional predicate",
                        _1: /* End_of_format */0
                      },
                      _1: "Unexpected token in conditional predicate"
                    });
      case /* Expect_hash_then_in_conditional */5 :
          return Stdlib__Format.fprintf(ppf)(/* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "Expect `then` after conditional predicate",
                        _1: /* End_of_format */0
                      },
                      _1: "Expect `then` after conditional predicate"
                    });
      case /* Unexpected_directive */6 :
          return Stdlib__Format.fprintf(ppf)(/* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "Unexpected directive",
                        _1: /* End_of_format */0
                      },
                      _1: "Unexpected directive"
                    });
      
    }
  } else {
    switch (c.TAG | 0) {
      case /* Illegal_character */0 :
          return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "Illegal character (",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Char_literal */12,
                                _0: /* ')' */41,
                                _1: /* End_of_format */0
                              }
                            }
                          },
                          _1: "Illegal character (%s)"
                        }), Stdlib__Char.escaped(c._0));
      case /* Illegal_escape */1 :
          return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "Illegal backslash escape in string or character (",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Char_literal */12,
                                _0: /* ')' */41,
                                _1: /* End_of_format */0
                              }
                            }
                          },
                          _1: "Illegal backslash escape in string or character (%s)"
                        }), c._0);
      case /* Unterminated_comment */2 :
          return Stdlib__Format.fprintf(ppf)(/* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "Comment not terminated",
                        _1: /* End_of_format */0
                      },
                      _1: "Comment not terminated"
                    });
      case /* Unterminated_string_in_comment */3 :
          return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "This comment contains an unterminated string literal",
                            _1: {
                              TAG: /* Formatting_lit */17,
                              _0: /* Flush_newline */4,
                              _1: {
                                TAG: /* Alpha */15,
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: "String literal begins here",
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          },
                          _1: "This comment contains an unterminated string literal@.%aString literal begins here"
                        }), print_error, c._1);
      case /* Keyword_as_label */4 :
          return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* Char_literal */12,
                            _0: /* '`' */96,
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* String_literal */11,
                                _0: "' is a keyword, it cannot be used as label name",
                                _1: /* End_of_format */0
                              }
                            }
                          },
                          _1: "`%s' is a keyword, it cannot be used as label name"
                        }), c._0);
      case /* Literal_overflow */5 :
          return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "Integer literal exceeds the range of representable integers of type ",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: /* End_of_format */0
                            }
                          },
                          _1: "Integer literal exceeds the range of representable integers of type %s"
                        }), c._0);
      case /* Illegal_semver */6 :
          return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "Illegal semantic version string ",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: /* End_of_format */0
                            }
                          },
                          _1: "Illegal semantic version string %s"
                        }), c._0);
      case /* Conditional_expr_expected_type */7 :
          return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "Conditional expression type mismatch (",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Char_literal */12,
                                _0: /* ',' */44,
                                _1: {
                                  TAG: /* String */2,
                                  _0: /* No_padding */0,
                                  _1: {
                                    TAG: /* Char_literal */12,
                                    _0: /* ')' */41,
                                    _1: /* End_of_format */0
                                  }
                                }
                              }
                            }
                          },
                          _1: "Conditional expression type mismatch (%s,%s)"
                        }), string_of_type_directive(c._0), string_of_type_directive(c._1));
      
    }
  }
}

register_error_of_exn(function (param) {
      if (param.MEL_EXN_ID === $$Error$4) {
        return error_of_printer(param._2, report_error$2, param._1);
      }
      
    });

const __ocaml_lex_tables = {
  lex_base: "\0\0\xa4\xff\xa5\xff\xe0\0\x03\x01&\x01I\x01l\x01\x8f\x01\xbc\xff\xb2\x01\xd7\x01\xc4\xff[\0\xfc\x01\x1f\x02D\0G\0T\0B\x02\xd5\xff\xd7\xff\xda\xffe\x02\xc4\x02\xe7\x02Y\0\xff\0\x05\x03\xec\xffR\x03s\x03\xbc\x03\x8c\x04\\\x05,\x06\x0b\x07g\x077\b}\0\xfe\xff\x01\0\x05\0\xff\xff\x06\0\x07\0\x16\t4\t\x04\n\xfa\xff\xf9\xff\xd4\n\xa4\x0b\xf7\xff\xf6\xff\xed\xff\xee\xff\xef\xff]\0v\x02[\0n\0\xe7\x02\x07\x04\xd7\x04e\x02\xfe\x02v\0\xc2\xff\xeb\xffx\x05\x84\f`\0q\0\x0b\0\xea\xff\xe9\xff\xe5\xff\xe5\x04\x80\0s\0\xe8\xff\xe0\0u\0\xe7\xffw\x06\x93\0\xe6\xff\x92\0\xe1\xff\x94\0\xe0\xff\xd9\0\x84\f\xdf\xff\xab\f\xaf\b\xae\x06\xde\xff\f\0\x18\x01,\x01P\x01-\x01\xde\xff\r\0\xd9\f\0\r#\rI\r\xd2\xff\xce\xff\xcf\xff\xd0\xff\xcc\xffl\r\x9a\0\xb7\0\xc5\xff\xc6\xff\xc7\xff\xc7\0\xb6\xff\xb8\xff\xbf\xff\x8f\r\xbb\xff\xbd\xff\xb2\r\xd5\r\xf8\r\x1b\x0e\xeb\x05\xf3\xff\xf4\xff\x11\0\xf5\xff>\x02\xac\x07\xfd\xff\xdf\0\xf1\0\xff\xff\xfe\xff\xfc\xff\xc8\x07-\x0e\xfa\0\xfc\0\x12\0\xfb\xff\xfa\xff\xf9\xff\x80\t\x1e\x03\x03\x01\xf8\xff\\\x03\x04\x01\xf7\xffO\n\x05\x01\xf6\xff+\x01\xc7\x01\xf7\xff\xf8\xff\xf9\xff;\x01v\x0e\xff\xff\xfa\xff\x1f\x0b$\x04\xfd\xff&\x01E\x01^\x01\xfc\x04\xfc\xff\xef\x0b\xfb\xff_\x01\xb5\x01\xfc\xff\xee\x06\xfe\xff\xff\xffo\x01p\x01\xfd\xffJ\x07\x10\x01\x13\x012\x01?\x01\x1a\x01k\x01!\x01\x13\0\xff\xff",
  lex_backtrk: "\xff\xff\xff\xff\xff\xffX\0W\0T\0S\0L\0J\0\xff\xffA\0>\0\xff\xff7\x006\x004\x002\0.\0,\0O\0\xff\xff\xff\xff\xff\xff#\0\"\0)\0'\0&\0<\0\xff\xff\x0e\0\x0e\0\r\0\f\0\x0b\0\n\0\x07\0\x04\0\x03\0\x02\0\xff\xff[\0[\0\xff\xff\xff\xff\xff\xffR\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x0f\0\xff\xff\xff\xff\xff\xff\x0e\0\x0e\0\x0e\0\x0f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\0\x1a\0\x1a\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\0\xff\xff\x1c\0\xff\xff\x1d\0V\0\xff\xffY\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\0U\0P\0+\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff5\0F\0E\0\xff\xff\xff\xff\xff\xffH\0\xff\xff\xff\xff\xff\xff?\0\xff\xff\xff\xffQ\0K\0N\0M\0\xff\xff\xff\xff\xff\xff\f\0\xff\xff\f\0\f\0\xff\xff\f\0\f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\b\0\b\0\xff\xff\xff\xff\x05\0\x05\0\xff\xff\x01\0\x05\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x03\0\xff\xff\xff\xff\x03\0\xff\xff\xff\xff\xff\xff\x02\0\xff\xff\xff\xff\x01\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff",
  lex_default: "\x01\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xffH\0\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\xff\xffM\0\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xff\0\0\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xffd\0\xff\xff\0\0\xff\xffd\0e\0d\0g\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\xff\xff\0\0\0\0\0\0\xff\xff\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\x85\0\0\0\0\0\xff\xff\0\0\x93\0\xff\xff\0\0\xff\xff\xff\xff\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xff\xa5\0\0\0\0\0\0\0\xff\xff\xab\0\0\0\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\0\0\xff\xff\xb8\0\0\0\xff\xff\0\0\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xc2\0\xc5\0\xff\xff\xc5\0\xff\xff\xff\xff\0\0",
  lex_trans: "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\0(\0(\0'\0)\0-\0+\0+\0(\0,\0,\0-\0I\0b\0h\0J\0c\0i\0\x86\0\x94\0\xc8\0\xa3\0\x95\0'\0\b\0\x1d\0\x18\0\x06\0\x04\0\x17\0\x1b\0\x1a\0\x15\0\x19\0\x07\0\x14\0\x13\0\x12\0\x03\0\x1f\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x11\0\x10\0\x0f\0\x0e\0\n\0$\0\x05\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\r\0*\0\f\0\x05\0&\0\x16\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\x1c\0\x0b\0\t\0%\0r\0t\0q\0n\0X\0p\0o\0'\0L\0C\0'\0C\0A\0A\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0w\0K\0v\0Q\0u\0T\0'\0@\0@\0@\0@\0@\0@\0@\0@\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0W\0Y\0Z\0[\0\\\0{\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0x\0 \0 \0 \0 \0 \0 \0 \0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0y\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\x02\0\x03\0[\0\\\0\x03\0\x03\0\x03\0z\0\x8f\0I\0\x03\0\x03\0J\0\x03\0\x03\0\x03\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\x03\0\x8e\0\x03\0\x03\0\x03\0\x03\0\x03\0\x98\0b\0\x97\0\x03\0c\0\xff\xff\x03\0\x03\0\x03\0\x9c\0\x9f\0\xa2\0\x03\0\x03\0\xaf\0\x03\0\x03\0\x03\0\xc1\0\xc2\0\x86\0b\0h\0\xa3\0c\0i\0\xc6\0\xc3\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\xc7\0\xa7\0\xaf\0\x05\0\xb6\0\xc4\0\x05\0\x05\0\x05\0\0\0g\0\xaf\0\x05\0\x05\0\xb1\0\x05\0\x05\0\x05\0\0\0\0\0\0\0f\0b\0G\0\x03\0c\0\x03\0\0\0\x05\0\x03\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\xaf\0\xa7\0\x06\0\xb1\0\xb6\0\x06\0\x06\0\x06\0f\0\0\0e\0\x06\0\x06\0\xc4\0\x06\0\x06\0\x06\0\xbb\0\xbb\0\0\0\xbd\0\xbd\0\0\0\x03\0\0\0\x03\0\0\0\x06\0\x05\0\x06\0\x06\0\x06\0\x06\0\x06\0\0\0\0\0\0\0k\0\0\0\0\0k\0k\0k\0\0\0\0\0\0\0k\0k\0\0\0k\0\x83\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\0\0\0\x05\0\0\0k\0\x06\0k\0\x82\0k\0k\0k\0\0\0\0\0\0\0\x80\0\0\0\0\0\x80\0\x80\0\x80\0\0\0\0\0\0\0\x80\0\x80\0\0\0\x80\0\x80\0\x80\0\xbb\0\0\0\0\0\xbc\0\0\0\0\0\x06\0\0\0\x06\0\0\0\x80\0k\0\x80\0\x81\0\x80\0\x80\0\x80\0\0\0\xa7\0\0\0\x06\0\xa8\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\0\0\0\0\0\0k\0\xaa\0k\0\0\0\x06\0\x80\0\x06\0\x06\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\0\0\x06\0\x06\0\x06\0\0\0\xff\xff\0\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\0\0\x80\0\0\0\x80\0\0\0\x7f\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0\x06\0\x06\0\xff\xff\0\0\0\0\0\0\0\0\x06\0\0\0\0\0\x06\0\x06\0\x06\0\xa9\0\0\0\0\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0\xff\xff\xff\xff\x06\0~\0\x06\0\xb9\0\xff\xff\0\0|\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0\x06\0\x06\0\0\0\0\0\xff\xff\x06\0\0\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\x94\0\x06\0\x06\0\x95\0s\0\x06\0\x06\0\0\0\xff\xff\0\0\0\0}\0\0\0\x06\0\0\0\0\0\0\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\0\0\0\0\0\0k\0\0\0\x96\0k\0k\0k\0\0\0\0\0\xff\xffk\0k\0\0\0k\0l\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\x06\0\0\0k\0\x06\0k\0k\0m\0k\0k\0\0\0\0\0\0\0\x06\0\0\0\0\0\x06\0\x06\0j\0\0\0\0\0\0\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0A\0A\0\0\0\0\0\0\0\x92\0\x06\0\0\0\x06\0\0\0\x06\0k\0\x06\0\x06\0\x06\0\x06\0\x06\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0\0\x008\0\0\0\0\0\0\0\xba\0\0\0\0\0\0\0\0\0\0\0:\0\0\0\0\0k\0\0\0k\0\0\0\0\0\x06\0A\0\0\0\0\0\xa6\0\0\0\0\0\0\0\0\0\0\0a\0\0\0\0\0\0\x009\0\0\x007\0\0\0;\0\0\0\0\0\0\0\0\0\0\0:\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\x06\0a\0_\0\0\0_\0_\0_\0_\0\0\0\0\0\0\0_\0_\0\0\0_\0_\0_\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0_\0\0\0_\0_\0_\0_\0_\0\0\0\0\0\0\0\x03\0\0\0\0\0\x03\0\x03\0\x03\0\0\0\0\0^\0]\0\x03\0\0\0\x03\0\x03\0\x03\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0\x03\0_\0\x03\0\x03\0\x03\0\x03\0\x03\0?\0?\0?\0?\0?\0?\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\0\0_\0D\0_\0\0\0\0\0\x03\0\0\0\0\0?\0?\0?\0?\0?\0?\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\0\0\0\0\0\0\0\0\0\0B\0\0\0\0\0\0\0\0\0\0\0\x03\0F\0\x03\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0;\0E\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\0\0:\0\0\0\0\0\0\0\0\0\0\0\0\x008\0\0\0\0\0;\0\0\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\0\0\0\0\0\0\0\0\x1e\0\0\0\0\0\0\0<\0\0\0:\0:\0\0\0\0\0\0\0\0\0\0\x009\x008\x007\0\0\0=\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0>\0\0\0\0\0\0\0\0\0\0\0\0\0\x1e\0\0\0\0\0<\0\0\0\0\0:\0\0\0\0\0\0\0\0\0\0\0\0\x009\0\0\x007\0=\0 \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0>\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\0\0\0\0\0\0\0\0 \0\0\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0?\0?\0?\0?\0?\0?\0\0\0\0\0\0\0\0\0\0\x008\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0?\0\0\0?\0?\0?\0?\0?\0?\0\0\0\0\0\0\0\0\0\0\x009\0\0\x007\0\0\0\0\0\0\0\0\0\0\0\0\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\0\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0!\0 \0 \0 \0 \0 \0 \0 \0 \0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\0\0\0\0\0\0\0\0!\0\0\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0@\0@\0@\0@\0@\0@\0@\0@\0\0\0\0\0\0\0\0\0\0\0\0\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0\0\0\0\0\0\0\0\x008\0\0\0\0\0U\0U\0U\0U\0U\0U\0\xb3\0\xb3\0\xb3\0\xb3\0\xb3\0\xb3\0\xb3\0\xb3\0\xb3\0\xb3\0@\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x009\0\0\x007\0U\0U\0U\0U\0U\0U\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\0\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\"\0 \0 \0 \0 \0 \0 \0 \0 \0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\0\0\0\0\0\0\0\0\"\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0F\0\0\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0\0\0E\0\x86\0\0\0\0\0\x87\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8b\0\0\0\0\0\0\0\0\0\x89\0\x8d\0\0\0\x8c\0\0\0\0\0\0\0\0\0\0\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0#\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\x8a\0\0\0\0\0\0\0\0\0\0\0\0\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\0\0\0\0\0\0\0\0#\0\0\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0\0\0\0\0\0\0\0\0\0\0\0\0a\0V\0V\0V\0V\0V\0V\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0V\0V\0V\0V\0V\0V\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0\0\0\0\0\0\0\x88\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0.\0\0\0\0\0.\0.\0.\0\0\0\0\0\0\0.\0.\0\0\0.\0.\0.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0.\0\0\0.\0.\0.\0.\0.\0\0\0\xbf\0\0\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0.\x004\0\xbe\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\0\0.\0.\0.\0\0\0.\0.\0.\0\0\0\0\0\0\0.\0.\0\0\0.\0.\0.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0.\0\0\0.\0.\0.\0.\0.\0\0\0\xbf\0\0\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0.\x000\0\xbe\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\0\0.\0\0\0.\0\0\0\0\0\0\0\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\0\x003\x003\x003\x003\x003\x003\x003\x003\0\x91\0\0\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x90\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\0\0\x90\0\0\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0#\0/\0/\0/\0/\0/\0/\0/\0/\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\0\0\0\0\0\0\0\0#\0\0\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\0\0\0\0\0\0\0\0\0\0\0\0f\0b\0\0\0\0\0c\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0f\0\0\0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0.\0\0\0\0\0.\0.\0.\0\0\0\0\0\0\0.\0.\0\0\0.\0.\0.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0.\0\0\0.\0.\0.\0.\0.\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\x002\0\0\0\0\0\0\0\0\0\0\0.\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\0\0\0\0\0\0.\0/\0.\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\xff\xff\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\0\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\x000\0/\0/\0/\0/\0/\0/\0/\0/\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x001\0\0\0\0\0\0\0\0\0\0\0\0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\0\0\0\0\0\0\0\x000\0\0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\0\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\x003\0/\0/\0/\0/\0/\0/\0/\0/\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x006\0\0\0\0\0\0\0\0\0\0\0\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\0\0\0\0\0\0\0\x003\0\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x004\x003\x003\x003\x003\x003\x003\x003\x003\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x005\0\0\0\0\0\0\0\0\0\0\0\0\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\0\0\0\0\0\0\0\x004\0\0\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\0\x003\x003\x003\x003\x003\x003\x003\x003\0P\0]\0P\0\0\0]\0]\0]\0P\0\0\0\0\0]\0]\0\0\0]\0]\0]\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0]\0\0\0]\0]\0]\0]\0]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\0\0\0_\0_\0_\0_\0\0\0\0\0\0\0_\0_\0\0\0_\0_\0_\0\0\0\0\0\0\0\0\0\0\0P\0\0\0]\0\0\0\0\0_\0P\0_\0_\0_\0_\0_\0\0\0\0\0\0\0\0\0\0\0\0\0P\0\0\0\0\0\0\0P\0\0\0P\0\0\0\x06\0\0\0N\0\x06\0\x06\0\x06\0]\0\0\0]\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0_\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\x06\0\x06\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0k\0\0\0\0\0k\0k\0k\0_\0\0\0_\0k\0k\0\0\0k\0k\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\0\0k\0\0\0k\0k\0k\0k\0k\0\0\0\0\0\0\0k\0\0\0\0\0k\0k\0k\0\0\0\0\0\0\0k\0k\0\0\0k\0k\0k\0\0\0\0\0\x06\0\0\0\x06\0\0\0\0\0\0\0\0\0\0\0k\0k\0k\0k\0k\0k\0k\0\0\0\0\0\0\0\0\0\0\0\0\0k\0\0\0\0\0k\0k\0k\0\0\0\0\0\0\0k\0k\0\0\0k\0k\0k\0\0\0\0\0\0\0k\0\0\0k\0\0\0\0\0k\0\0\0k\0\xff\xffk\0k\0k\0k\0k\0\0\0\0\0\0\0\x06\0\0\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\0\0k\0\0\0k\0\0\0\0\0\0\0\0\0\x06\0k\0\x06\0\x06\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\x06\0\0\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\0\0\0\0\0\0k\0\0\0k\0\0\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\x80\0\0\0\0\0\x80\0\x80\0\x80\0\0\0\0\0\0\0\x80\0\x80\0\0\0\x80\0\x80\0\x80\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\x06\0\0\0\x80\0\x06\0\x80\0\x80\0\x80\0\x80\0\x80\0\0\0\0\0\0\0\x80\0\0\0\0\0\x80\0\x80\0\x80\0\0\0\0\0\0\0\x80\0\x80\0\0\0\x80\0\x80\0\x80\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\x06\0\0\0\x80\0\x80\0\x80\0\x80\0\x80\0\x80\0\x80\0\0\0\0\0\0\0k\0\0\0\0\0k\0k\0k\0\0\0\0\0\0\0k\0k\0\0\0k\0k\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x80\0\0\0\x80\0\0\0k\0\x80\0k\0k\0k\0k\0k\0\0\0\0\0\0\0k\0\0\0\0\0k\0k\0k\0\0\0\0\0\0\0k\0k\0\0\0k\0k\0k\0\0\0\0\0\x9b\0\0\0\x9b\0\0\0\x80\0\0\0\x80\0\x9b\0k\0k\0k\0k\0k\0k\0k\0\0\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0k\0\0\0k\0\0\0\0\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\xaf\0\0\0\0\0\xb0\0\0\0\0\0\0\0\0\0\0\0\x9b\0\0\0\0\0\0\0\0\0\0\0\x9b\0\0\0\0\0\0\0\0\0\0\0\0\0\xae\0k\0\xae\0k\0\0\0\x9b\0\0\0\xae\0\0\0\x9b\0\0\0\x9b\0\0\0\0\0\0\0\x99\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xae\0\0\0\0\0\0\0\0\0\0\0\xae\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xae\0\0\0\0\0\0\0\xae\0\0\0\xae\0\0\0\0\0\0\0\xac\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff",
  lex_check: "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0)\0\0\0\0\0)\0*\0,\0-\0*\0,\0-\0J\0c\0i\0J\0c\0i\0\x87\0\x95\0\xc7\0\x87\0\x95\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x10\0\r\0\x11\0\x12\0\x1a\0\x11\0\x11\0'\0H\0:\0'\0:\0<\0<\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0\r\0I\0\r\0P\0\r\0S\0'\0=\0=\0=\0=\0=\0=\0=\0=\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0V\0X\0X\0Z\0Z\0t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03\0\\\0\\\0\x03\0\x03\0\x03\0y\0\x8c\0\x1b\0\x03\0\x03\0\x1b\0\x03\0\x03\0\x03\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0\x03\0\x8d\0\x03\0\x03\0\x03\0\x03\0\x03\0\x93\0d\0\x94\0\x04\0d\0\x1b\0\x04\0\x04\0\x04\0\x9b\0\x9e\0\xa1\0\x04\0\x04\0\xaf\0\x04\0\x04\0\x04\0\xc0\0\xc1\0\xa3\0e\0g\0\xa3\0e\0g\0\xc4\0\xc2\0\x04\0\x03\0\x04\0\x04\0\x04\0\x04\0\x04\0\xc6\0\xa8\0\xaf\0\x05\0\xa8\0\xc3\0\x05\0\x05\0\x05\0\xff\xffe\0\xb0\0\x05\0\x05\0\xb0\0\x05\0\x05\0\x05\0\xff\xff\xff\xff\xff\xfff\0f\0\x1b\0\x03\0f\0\x03\0\xff\xff\x05\0\x04\0\x05\0\x05\0\x05\0\x05\0\x05\0\xff\xff\xb1\0\xb6\0\x06\0\xb1\0\xb6\0\x06\0\x06\0\x06\0f\0\xff\xfff\0\x06\0\x06\0\xc5\0\x06\0\x06\0\x06\0\xbc\0\xbd\0\xff\xff\xbc\0\xbd\0\xff\xff\x04\0\xff\xff\x04\0\xff\xff\x06\0\x05\0\x06\0\x06\0\x06\0\x06\0\x06\0\xff\xff\xff\xff\xff\xff\x07\0\xff\xff\xff\xff\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\x07\0\x07\0\xff\xff\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x05\0\xff\xff\x05\0\xff\xff\x07\0\x06\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\b\0\xff\xff\xff\xff\b\0\b\0\b\0\xff\xff\xff\xff\xff\xff\b\0\b\0\xff\xff\b\0\b\0\b\0\xb7\0\xff\xff\xff\xff\xb7\0\xff\xff\xff\xff\x06\0\xff\xff\x06\0\xff\xff\b\0\x07\0\b\0\b\0\b\0\b\0\b\0\xff\xff\xa4\0\xff\xff\n\0\xa4\0\xff\xff\n\0\n\0\n\0\xff\xff\xff\xff\xff\xff\n\0\n\0\xff\xff\n\0\n\0\n\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x07\0\xa4\0\x07\0\xff\xff\n\0\b\0\n\0\n\0\n\0\n\0\n\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x0b\0\xff\xff\xff\xff\x0b\0\x0b\0\x0b\0\xff\xff\x1b\0\xff\xff\x0b\0\x0b\0\xff\xff\x0b\0\x0b\0\x0b\0\xff\xff\xff\xff\xff\xff\xff\xff\b\0\xff\xff\b\0\xff\xff\n\0\n\0\x0b\0\xff\xff\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0d\0\xff\xff\xff\xff\xff\xff\xff\xff\x0e\0\xff\xff\xff\xff\x0e\0\x0e\0\x0e\0\xa4\0\xff\xff\xff\xff\x0e\0\x0e\0\xff\xff\x0e\0\x0e\0\x0e\0e\0g\0\n\0\n\0\n\0\xb7\0\xc2\0\xff\xff\x0b\0\x0b\0\x0e\0\xff\xff\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\xff\xff\xff\xff\xc3\0\x0f\0\xff\xff\xff\xff\x0f\0\x0f\0\x0f\0\xff\xff\xff\xff\x89\0\x0f\0\x0f\0\x89\0\x0f\0\x0f\0\x0f\0\xff\xfff\0\xff\xff\xff\xff\x0b\0\xff\xff\x0b\0\xff\xff\xff\xff\xff\xff\x0f\0\x0e\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\xff\xff\xff\xff\xff\xff\x13\0\xff\xff\x89\0\x13\0\x13\0\x13\0\xff\xff\xff\xff\xc5\0\x13\0\x13\0\xff\xff\x13\0\x13\0\x13\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x0e\0\xff\xff\x0e\0\xff\xff\x13\0\x0f\0\x13\0\x13\0\x13\0\x13\0\x13\0\xff\xff\xff\xff\xff\xff\x17\0\xff\xff\xff\xff\x17\0\x17\0\x17\0\xff\xff\xff\xff\xff\xff\x17\0\x17\0\xff\xff\x17\0\x17\0\x17\0A\0A\0\xff\xff\xff\xff\xff\xff\x89\0\x0f\0\xff\xff\x0f\0\xff\xff\x17\0\x13\0\x17\0\x17\0\x17\0\x17\0\x17\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0\xff\xffA\0\xff\xff\xff\xff\xff\xff\xb7\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff;\0\xff\xff\xff\xff\x13\0\xff\xff\x13\0\xff\xff\xff\xff\x17\0A\0\xff\xff\xff\xff\xa4\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x18\0\xff\xff\xff\xff\xff\xffA\0\xff\xffA\0\xff\xff;\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff;\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x17\0\xff\xff\x17\0\x18\0\x18\0\xff\xff\x18\0\x18\0\x18\0\x18\0\xff\xff\xff\xff\xff\xff\x18\0\x18\0\xff\xff\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\xff\xff\x18\0\x18\0\x18\0\x18\0\x18\0\xff\xff\xff\xff\xff\xff\x19\0\xff\xff\xff\xff\x19\0\x19\0\x19\0\xff\xff\xff\xff\x19\0\x19\0\x19\0\xff\xff\x19\0\x19\0\x19\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0\x19\0\x18\0\x19\0\x19\0\x19\0\x19\0\x19\0>\0>\0>\0>\0>\0>\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x89\0\xff\xff\x18\0\x1c\0\x18\0\xff\xff\xff\xff\x19\0\xff\xff\xff\xff>\0>\0>\0>\0>\0>\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffB\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x19\0\x1c\0\x19\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1e\0\x1c\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\xff\xff\x1e\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1e\0\xff\xff\xff\xff\x1f\0\xff\xff\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\xff\xff\xff\xff\xff\xff\xff\xff\x1e\0\xff\xff\xff\xff\xff\xff\x1f\0\xff\xff\x1e\0\x1f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1e\0\x1f\0\x1e\0\xff\xff\x1f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1f\0\xff\xff\xff\xff\x1f\0\xff\xff\xff\xff\x1f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1f\0\xff\xff\x1f\0\x1f\0 \0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1f\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\xff\xff\xff\xff\xff\xff\xff\xff \0\xff\xff \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff?\0?\0?\0?\0?\0?\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff?\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff?\0\xff\xff?\0?\0?\0?\0?\0?\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff?\0\xff\xff?\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\xff\xff \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0!\0 \0 \0 \0 \0 \0 \0 \0 \0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\xff\xff\xff\xff\xff\xff\xff\xff!\0\xff\xff!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0@\0@\0@\0@\0@\0@\0@\0@\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffN\0N\0N\0N\0N\0N\0N\0N\0N\0N\0\xff\xff\xff\xff\xff\xff\xff\xff@\0\xff\xff\xff\xffN\0N\0N\0N\0N\0N\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0@\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff@\0\xff\xff@\0N\0N\0N\0N\0N\0N\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\xff\xff!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\"\0!\0!\0!\0!\0!\0!\0!\0!\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\xff\xff\xff\xff\xff\xff\xff\xff\"\0\xff\xff\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0F\0\xff\xffF\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0\xff\xffF\0\x84\0\xff\xff\xff\xff\x84\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x84\0\xff\xff\xff\xff\xff\xff\xff\xff\x84\0\x84\0\xff\xff\x84\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\xff\xff\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0#\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\x84\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\xff\xff\xff\xff\xff\xff\xff\xff#\0\xff\xff#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffa\0U\0U\0U\0U\0U\0U\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffa\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffU\0U\0U\0U\0U\0U\0a\0a\0a\0a\0a\0a\0a\0a\0a\0a\0\xff\xff\xff\xff\xff\xff\x84\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\xff\xff#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\xff\xff#\0#\0#\0#\0#\0#\0#\0#\0$\0\xff\xff\xff\xff$\0$\0$\0\xff\xff\xff\xff\xff\xff$\0$\0\xff\xff$\0$\0$\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\0\xff\xff$\0$\0$\0$\0$\0\xff\xff\xb9\0\xff\xff\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0$\0$\0\xb9\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0\xff\xff$\0%\0$\0\xff\xff%\0%\0%\0\xff\xff\xff\xff\xff\xff%\0%\0\xff\xff%\0%\0%\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\0\xff\xff%\0%\0%\0%\0%\0\xff\xff\xbf\0\xff\xff\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0%\0%\0\xbf\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0\xff\xff%\0\xff\xff%\0\xff\xff\xff\xff\xff\xff\xff\xff$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0\xff\xff$\0$\0$\0$\0$\0$\0$\0$\0\x8a\0\xff\xff\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x91\0\x8a\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\xff\xff\x91\0\xff\xff%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0&\0%\0%\0%\0%\0%\0%\0%\0%\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0\xff\xff\xff\xff\xff\xff\xff\xff&\0\xff\xff&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\0`\0\xff\xff\xff\xff`\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\0\xff\xff`\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0\xff\xff&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0\xff\xff&\0&\0&\0&\0&\0&\0&\0&\0.\0\xff\xff\xff\xff.\0.\0.\0\xff\xff\xff\xff\xff\xff.\0.\0\xff\xff.\0.\0.\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff.\0\xff\xff.\0.\0.\0.\0.\0\xff\xff\xff\xff\xff\xff\xff\xff/\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff.\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\xff\xff\xff\xff\xff\xff.\0/\0.\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0`\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\xff\xff/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\x000\0/\0/\0/\0/\0/\0/\0/\0/\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\xff\xff\xff\xff\xff\xff\xff\xff0\0\xff\xff0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\xff\xff0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x003\x000\x000\x000\x000\x000\x000\x000\x000\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff3\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\xff\xff\xff\xff\xff\xff\xff\xff3\0\xff\xff3\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\xac\0\xac\0\xac\0\xac\0\xac\0\xac\0\xac\0\xac\0\xac\0\xac\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xac\0\xac\0\xac\0\xac\0\xac\0\xac\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xac\0\xac\0\xac\0\xac\0\xac\0\xac\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff3\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\xff\xff3\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x004\x003\x003\x003\x003\x003\x003\x003\x003\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff4\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xff\xff\xff\xff\xff\xff\xff\xff4\0\xff\xff4\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff4\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xff\xff4\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xff\xff4\x004\x004\x004\x004\x004\x004\x004\0G\0]\0G\0\xff\xff]\0]\0]\0G\0\xff\xff\xff\xff]\0]\0\xff\xff]\0]\0]\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0]\0\xff\xff]\0]\0]\0]\0]\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff_\0\xff\xff_\0_\0_\0_\0\xff\xff\xff\xff\xff\xff_\0_\0\xff\xff_\0_\0_\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffG\0\xff\xff]\0\xff\xff\xff\xff_\0G\0_\0_\0_\0_\0_\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffG\0\xff\xff\xff\xff\xff\xffG\0\xff\xffG\0\xff\xffj\0\xff\xffG\0j\0j\0j\0]\0\xff\xff]\0j\0j\0\xff\xffj\0j\0j\0_\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffj\0\xff\xffj\0j\0j\0j\0j\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffk\0\xff\xff\xff\xffk\0k\0k\0_\0\xff\xff_\0k\0k\0\xff\xffk\0k\0k\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffj\0\xff\xff\xff\xffk\0\xff\xffk\0k\0k\0k\0k\0\xff\xff\xff\xff\xff\xffl\0\xff\xff\xff\xffl\0l\0l\0\xff\xff\xff\xff\xff\xffl\0l\0\xff\xffl\0l\0l\0\xff\xff\xff\xffj\0\xff\xffj\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffl\0k\0l\0l\0l\0l\0l\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffm\0\xff\xff\xff\xffm\0m\0m\0\xff\xff\xff\xff\xff\xffm\0m\0\xff\xffm\0m\0m\0\xff\xff\xff\xff\xff\xffk\0\xff\xffk\0\xff\xff\xff\xffl\0\xff\xffm\0G\0m\0m\0m\0m\0m\0\xff\xff\xff\xff\xff\xffs\0\xff\xff\xff\xffs\0s\0s\0\xff\xff\xff\xff\xff\xffs\0s\0\xff\xffs\0s\0s\0\xff\xff\xff\xff\xff\xffl\0\xff\xffl\0\xff\xff\xff\xff\xff\xff\xff\xffs\0m\0s\0s\0s\0s\0s\0\xff\xff\xff\xff\xff\xff}\0\xff\xff\xff\xff}\0}\0}\0\xff\xff\xff\xff\xff\xff}\0}\0\xff\xff}\0}\0}\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffm\0\xff\xffm\0\xff\xff}\0s\0}\0}\0}\0}\0}\0\xff\xff\xff\xff\xff\xff\x80\0\xff\xff\xff\xff\x80\0\x80\0\x80\0\xff\xff\xff\xff\xff\xff\x80\0\x80\0\xff\xff\x80\0\x80\0\x80\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffs\0\xff\xffs\0\xff\xff\x80\0}\0\x80\0\x80\0\x80\0\x80\0\x80\0\xff\xff\xff\xff\xff\xff\x81\0\xff\xff\xff\xff\x81\0\x81\0\x81\0\xff\xff\xff\xff\xff\xff\x81\0\x81\0\xff\xff\x81\0\x81\0\x81\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff}\0\xff\xff}\0\xff\xff\x81\0\x80\0\x81\0\x81\0\x81\0\x81\0\x81\0\xff\xff\xff\xff\xff\xff\x82\0\xff\xff\xff\xff\x82\0\x82\0\x82\0\xff\xff\xff\xff\xff\xff\x82\0\x82\0\xff\xff\x82\0\x82\0\x82\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x80\0\xff\xff\x80\0\xff\xff\x82\0\x81\0\x82\0\x82\0\x82\0\x82\0\x82\0\xff\xff\xff\xff\xff\xff\x83\0\xff\xff\xff\xff\x83\0\x83\0\x83\0\xff\xff\xff\xff\xff\xff\x83\0\x83\0\xff\xff\x83\0\x83\0\x83\0\xff\xff\xff\xff\x92\0\xff\xff\x92\0\xff\xff\x81\0\xff\xff\x81\0\x92\0\x83\0\x82\0\x83\0\x83\0\x83\0\x83\0\x83\0\xff\xff\x92\0\x92\0\x92\0\x92\0\x92\0\x92\0\x92\0\x92\0\x92\0\x92\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x82\0\xff\xff\x82\0\xff\xff\xff\xff\x83\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\0\xff\xff\xff\xff\xa9\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x92\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x92\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\0\x83\0\xa9\0\x83\0\xff\xff\x92\0\xff\xff\xa9\0\xff\xff\x92\0\xff\xff\x92\0\xff\xff\xff\xff\xff\xff\x92\0\xa9\0\xa9\0\xa9\0\xa9\0\xa9\0\xa9\0\xa9\0\xa9\0\xa9\0\xa9\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\0\xff\xff\xff\xff\xff\xff\xa9\0\xff\xff\xa9\0\xff\xff\xff\xff\xff\xff\xa9\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\0",
  lex_base_code: "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\n\0$\0\f\0\0\0\0\0\0\0\x02\0\0\0\x1b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
  lex_backtrk_code: "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
  lex_default_code: "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
  lex_trans_code: "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0$\0$\0\0\0$\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\x01\0\x16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\x01\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
  lex_check_code: "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x18\0e\0\xa9\0\xb0\0e\0\xb1\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x18\0\xff\xffe\0\0\0f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\0a\0\xff\xff\xff\xff\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0a\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffa\0a\0a\0a\0a\0a\0a\0a\0a\0a\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffe\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff",
  lex_code: "\xff\x04\xff\xff\x05\xff\xff\x07\xff\x06\xff\xff\x03\xff\0\x04\x01\x05\xff\x07\xff\xff\x06\xff\x07\xff\xff\0\x04\x01\x05\x03\x06\x02\x07\xff\x01\xff\xff\0\x01\xff"
};

function token(lexbuf) {
  lexbuf.lex_mem = Caml_array.make(8, -1);
  let ___ocaml_lex_state = 0;
  while(true) {
    const __ocaml_lex_state = ___ocaml_lex_state;
    const __ocaml_lex_state$1 = Stdlib__Lexing.new_engine(__ocaml_lex_tables, __ocaml_lex_state, lexbuf);
    switch (__ocaml_lex_state$1) {
      case 0 :
          if (!escaped_newlines.contents) {
            throw new Caml_js_exceptions.MelangeError($$Error$4, {
                      MEL_EXN_ID: $$Error$4,
                      _1: {
                        TAG: /* Illegal_character */0,
                        _0: Stdlib__Lexing.lexeme_char(lexbuf, 0)
                      },
                      _2: curr(lexbuf)
                    });
          }
          update_loc(lexbuf, undefined, 1, false, 0);
          return token(lexbuf);
      case 1 :
          update_loc(lexbuf, undefined, 1, false, 0);
          return /* EOL */100;
      case 2 :
          return token(lexbuf);
      case 3 :
          return /* UNDERSCORE */94;
      case 4 :
          return /* TILDE */89;
      case 5 :
          return {
                  TAG: /* LABEL */10,
                  _0: get_label_name(lexbuf)
                };
      case 6 :
          prerr_warning(curr(lexbuf), {
                TAG: /* Deprecated */0,
                _0: "ISO-Latin1 characters in identifiers"
              });
          return {
                  TAG: /* LABEL */10,
                  _0: get_label_name(lexbuf)
                };
      case 7 :
          return /* QUESTION */76;
      case 8 :
          return {
                  TAG: /* OPTLABEL */13,
                  _0: get_label_name(lexbuf)
                };
      case 9 :
          prerr_warning(curr(lexbuf), {
                TAG: /* Deprecated */0,
                _0: "ISO-Latin1 characters in identifiers"
              });
          return {
                  TAG: /* OPTLABEL */13,
                  _0: get_label_name(lexbuf)
                };
      case 10 :
          const s = Stdlib__Lexing.lexeme(lexbuf);
          try {
            return Stdlib__Hashtbl.find(keyword_table, s);
          }
          catch (raw_exn){
            const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.MEL_EXN_ID === Stdlib.Not_found) {
              return {
                      TAG: /* LIDENT */11,
                      _0: s
                    };
            }
            throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
          }
      case 11 :
          prerr_warning(curr(lexbuf), {
                TAG: /* Deprecated */0,
                _0: "ISO-Latin1 characters in identifiers"
              });
          return {
                  TAG: /* LIDENT */11,
                  _0: Stdlib__Lexing.lexeme(lexbuf)
                };
      case 12 :
          return {
                  TAG: /* UIDENT */17,
                  _0: Stdlib__Lexing.lexeme(lexbuf)
                };
      case 13 :
          prerr_warning(curr(lexbuf), {
                TAG: /* Deprecated */0,
                _0: "ISO-Latin1 characters in identifiers"
              });
          return {
                  TAG: /* UIDENT */17,
                  _0: Stdlib__Lexing.lexeme(lexbuf)
                };
      case 14 :
          try {
            return {
                    TAG: /* INT */7,
                    _0: cvt_int_literal(Stdlib__Lexing.lexeme(lexbuf))
                  };
          }
          catch (raw_exn$1){
            const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
            if (exn$1.MEL_EXN_ID === Stdlib.Failure) {
              throw new Caml_js_exceptions.MelangeError($$Error$4, {
                        MEL_EXN_ID: $$Error$4,
                        _1: {
                          TAG: /* Literal_overflow */5,
                          _0: "int"
                        },
                        _2: curr(lexbuf)
                      });
            }
            throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
          }
      case 15 :
          return {
                  TAG: /* FLOAT */1,
                  _0: remove_underscores(Stdlib__Lexing.lexeme(lexbuf))
                };
      case 16 :
          try {
            return {
                    TAG: /* INT32 */8,
                    _0: cvt_int32_literal(Stdlib__Lexing.lexeme(lexbuf))
                  };
          }
          catch (raw_exn$2){
            const exn$2 = Caml_js_exceptions.internalToOCamlException(raw_exn$2);
            if (exn$2.MEL_EXN_ID === Stdlib.Failure) {
              throw new Caml_js_exceptions.MelangeError($$Error$4, {
                        MEL_EXN_ID: $$Error$4,
                        _1: {
                          TAG: /* Literal_overflow */5,
                          _0: "int32"
                        },
                        _2: curr(lexbuf)
                      });
            }
            throw new Caml_js_exceptions.MelangeError(exn$2.MEL_EXN_ID, exn$2);
          }
      case 17 :
          try {
            return {
                    TAG: /* INT64 */9,
                    _0: cvt_int64_literal(Stdlib__Lexing.lexeme(lexbuf))
                  };
          }
          catch (raw_exn$3){
            const exn$3 = Caml_js_exceptions.internalToOCamlException(raw_exn$3);
            if (exn$3.MEL_EXN_ID === Stdlib.Failure) {
              throw new Caml_js_exceptions.MelangeError($$Error$4, {
                        MEL_EXN_ID: $$Error$4,
                        _1: {
                          TAG: /* Literal_overflow */5,
                          _0: "int64"
                        },
                        _2: curr(lexbuf)
                      });
            }
            throw new Caml_js_exceptions.MelangeError(exn$3.MEL_EXN_ID, exn$3);
          }
      case 18 :
          try {
            return {
                    TAG: /* NATIVEINT */12,
                    _0: cvt_nativeint_literal(Stdlib__Lexing.lexeme(lexbuf))
                  };
          }
          catch (raw_exn$4){
            const exn$4 = Caml_js_exceptions.internalToOCamlException(raw_exn$4);
            if (exn$4.MEL_EXN_ID === Stdlib.Failure) {
              throw new Caml_js_exceptions.MelangeError($$Error$4, {
                        MEL_EXN_ID: $$Error$4,
                        _1: {
                          TAG: /* Literal_overflow */5,
                          _0: "nativeint"
                        },
                        _2: curr(lexbuf)
                      });
            }
            throw new Caml_js_exceptions.MelangeError(exn$4.MEL_EXN_ID, exn$4);
          }
      case 19 :
          reset_string_buffer(undefined);
          is_in_string.contents = true;
          const string_start = lexbuf.lex_start_p;
          string_start_loc.contents = curr(lexbuf);
          string(lexbuf);
          is_in_string.contents = false;
          lexbuf.lex_start_p = string_start;
          return {
                  TAG: /* STRING */16,
                  _0: [
                    get_stored_string(undefined),
                    undefined
                  ]
                };
      case 20 :
          reset_string_buffer(undefined);
          const delim = Stdlib__Lexing.lexeme(lexbuf);
          const delim$1 = Stdlib__String.sub(delim, 1, delim.length - 2 | 0);
          is_in_string.contents = true;
          const string_start$1 = lexbuf.lex_start_p;
          string_start_loc.contents = curr(lexbuf);
          __ocaml_lex_quoted_string_rec(delim$1, lexbuf, 183);
          is_in_string.contents = false;
          lexbuf.lex_start_p = string_start$1;
          return {
                  TAG: /* STRING */16,
                  _0: [
                    get_stored_string(undefined),
                    delim$1
                  ]
                };
      case 21 :
          update_loc(lexbuf, undefined, 1, false, 1);
          return {
                  TAG: /* CHAR */0,
                  _0: Stdlib__Lexing.lexeme_char(lexbuf, 1)
                };
      case 22 :
          return {
                  TAG: /* CHAR */0,
                  _0: Stdlib__Lexing.lexeme_char(lexbuf, 1)
                };
      case 23 :
          return {
                  TAG: /* CHAR */0,
                  _0: char_for_backslash(Stdlib__Lexing.lexeme_char(lexbuf, 2))
                };
      case 24 :
          return {
                  TAG: /* CHAR */0,
                  _0: char_for_decimal_code(lexbuf, 2)
                };
      case 25 :
          return {
                  TAG: /* CHAR */0,
                  _0: char_for_hexadecimal_code(lexbuf, 3)
                };
      case 26 :
          const l = Stdlib__Lexing.lexeme(lexbuf);
          const esc = Stdlib__String.sub(l, 1, l.length - 1 | 0);
          throw new Caml_js_exceptions.MelangeError($$Error$4, {
                    MEL_EXN_ID: $$Error$4,
                    _1: {
                      TAG: /* Illegal_escape */1,
                      _0: esc
                    },
                    _2: curr(lexbuf)
                  });
      case 27 :
          const match = with_comment_buffer(comment, lexbuf);
          return {
                  TAG: /* COMMENT */18,
                  _0: [
                    match[0],
                    match[1]
                  ]
                };
      case 28 :
          const match$1 = with_comment_buffer(comment, lexbuf);
          return {
                  TAG: /* DOCSTRING */19,
                  _0: docstring(match$1[0], match$1[1])
                };
      case 29 :
          const stars = Stdlib__Lexing.sub_lexeme(lexbuf, lexbuf.lex_start_pos, lexbuf.lex_curr_pos);
          const match$2 = with_comment_buffer((function (lexbuf) {
                  store_string("*" + stars);
                  return __ocaml_lex_comment_rec(lexbuf, 132);
                }), lexbuf);
          return {
                  TAG: /* COMMENT */18,
                  _0: [
                    match$2[0],
                    match$2[1]
                  ]
                };
      case 30 :
          if (print_warnings.contents) {
            prerr_warning(curr(lexbuf), /* Comment_start */0);
          }
          const match$3 = with_comment_buffer(comment, lexbuf);
          return {
                  TAG: /* COMMENT */18,
                  _0: [
                    match$3[0],
                    match$3[1]
                  ]
                };
      case 31 :
          const stars$1 = Stdlib__Lexing.sub_lexeme(lexbuf, lexbuf.lex_start_pos, lexbuf.lex_curr_pos - 2 | 0);
          return {
                  TAG: /* COMMENT */18,
                  _0: [
                    stars$1,
                    curr(lexbuf)
                  ]
                };
      case 32 :
          const loc = curr(lexbuf);
          prerr_warning(loc, /* Comment_not_end */1);
          lexbuf.lex_curr_pos = lexbuf.lex_curr_pos - 1 | 0;
          const curpos = lexbuf.lex_curr_p;
          lexbuf.lex_curr_p = {
            pos_fname: curpos.pos_fname,
            pos_lnum: curpos.pos_lnum,
            pos_bol: curpos.pos_bol,
            pos_cnum: curpos.pos_cnum - 1 | 0
          };
          return /* STAR */86;
      case 33 :
          const num = Stdlib__Lexing.sub_lexeme(lexbuf, Caml_array.get(lexbuf.lex_mem, 0), Caml_array.get(lexbuf.lex_mem, 1));
          const name = Stdlib__Lexing.sub_lexeme_opt(lexbuf, Caml_array.get(lexbuf.lex_mem, 3), Caml_array.get(lexbuf.lex_mem, 2));
          update_loc(lexbuf, name, Caml_format.caml_int_of_string(num), true, 0);
          return token(lexbuf);
      case 34 :
          return /* SHARP */84;
      case 35 :
          return /* AMPERSAND */1;
      case 36 :
          return /* AMPERAMPER */0;
      case 37 :
          return /* BACKQUOTE */5;
      case 38 :
          return /* QUOTE */77;
      case 39 :
          return /* LPAREN */54;
      case 40 :
          return /* RPAREN */81;
      case 41 :
          return /* STAR */86;
      case 42 :
          return /* COMMA */16;
      case 43 :
          return /* MINUSGREATER */62;
      case 44 :
          return /* DOT */20;
      case 45 :
          return /* DOTDOT */21;
      case 46 :
          return /* COLON */12;
      case 47 :
          return /* COLONCOLON */13;
      case 48 :
          return /* COLONEQUAL */14;
      case 49 :
          return /* COLONGREATER */15;
      case 50 :
          return /* SEMI */82;
      case 51 :
          return /* SEMISEMI */83;
      case 52 :
          return /* LESS */51;
      case 53 :
          return /* LESSMINUS */52;
      case 54 :
          return /* EQUAL */26;
      case 55 :
          return /* LBRACKET */45;
      case 56 :
          return /* LBRACKETBAR */46;
      case 57 :
          return /* LBRACKETLESS */47;
      case 58 :
          return /* LBRACKETGREATER */48;
      case 59 :
          return /* RBRACKET */79;
      case 60 :
          return /* LBRACE */43;
      case 61 :
          return /* LBRACELESS */44;
      case 62 :
          return /* BAR */7;
      case 63 :
          return /* BARBAR */8;
      case 64 :
          return /* BARRBRACKET */9;
      case 65 :
          return /* GREATER */34;
      case 66 :
          return /* GREATERRBRACKET */36;
      case 67 :
          return /* RBRACE */78;
      case 68 :
          return /* GREATERRBRACE */35;
      case 69 :
          return /* LBRACKETAT */55;
      case 70 :
          return /* LBRACKETPERCENT */49;
      case 71 :
          return /* LBRACKETPERCENTPERCENT */50;
      case 72 :
          return /* LBRACKETATAT */56;
      case 73 :
          return /* LBRACKETATATAT */57;
      case 74 :
          return /* BANG */6;
      case 75 :
          return {
                  TAG: /* INFIXOP0 */2,
                  _0: "!="
                };
      case 76 :
          return /* PLUS */72;
      case 77 :
          return /* PLUSDOT */73;
      case 78 :
          return /* PLUSEQ */74;
      case 79 :
          return /* MINUS */60;
      case 80 :
          return /* MINUSDOT */61;
      case 81 :
      case 82 :
          return {
                  TAG: /* PREFIXOP */14,
                  _0: Stdlib__Lexing.lexeme(lexbuf)
                };
      case 83 :
          return {
                  TAG: /* INFIXOP0 */2,
                  _0: Stdlib__Lexing.lexeme(lexbuf)
                };
      case 84 :
          return {
                  TAG: /* INFIXOP1 */3,
                  _0: Stdlib__Lexing.lexeme(lexbuf)
                };
      case 85 :
          return {
                  TAG: /* INFIXOP2 */4,
                  _0: Stdlib__Lexing.lexeme(lexbuf)
                };
      case 86 :
          return {
                  TAG: /* INFIXOP4 */6,
                  _0: Stdlib__Lexing.lexeme(lexbuf)
                };
      case 87 :
          return /* PERCENT */71;
      case 88 :
          return {
                  TAG: /* INFIXOP3 */5,
                  _0: Stdlib__Lexing.lexeme(lexbuf)
                };
      case 89 :
          return {
                  TAG: /* SHARPOP */15,
                  _0: Stdlib__Lexing.lexeme(lexbuf)
                };
      case 90 :
          if (if_then_else.contents === /* Dir_out */2) {
            return /* EOF */25;
          }
          if (if_then_else.contents === /* Dir_if_true */0) {
            throw new Caml_js_exceptions.MelangeError($$Error$4, {
                      MEL_EXN_ID: $$Error$4,
                      _1: /* Unterminated_if */2,
                      _2: curr(lexbuf)
                    });
          }
          throw new Caml_js_exceptions.MelangeError($$Error$4, {
                    MEL_EXN_ID: $$Error$4,
                    _1: /* Unterminated_else */3,
                    _2: curr(lexbuf)
                  });
      case 91 :
          throw new Caml_js_exceptions.MelangeError($$Error$4, {
                    MEL_EXN_ID: $$Error$4,
                    _1: {
                      TAG: /* Illegal_character */0,
                      _0: Stdlib__Lexing.lexeme_char(lexbuf, 0)
                    },
                    _2: curr(lexbuf)
                  });
      default:
        Curry._1(lexbuf.refill_buff, lexbuf);
        ___ocaml_lex_state = __ocaml_lex_state$1;
        continue ;
    }
  };
}

function comment(lexbuf) {
  return __ocaml_lex_comment_rec(lexbuf, 132);
}

function string(lexbuf) {
  lexbuf.lex_mem = Caml_array.make(2, -1);
  let ___ocaml_lex_state = 164;
  while(true) {
    const __ocaml_lex_state = ___ocaml_lex_state;
    const __ocaml_lex_state$1 = Stdlib__Lexing.new_engine(__ocaml_lex_tables, __ocaml_lex_state, lexbuf);
    switch (__ocaml_lex_state$1) {
      case 0 :
          return ;
      case 1 :
          const space = Stdlib__Lexing.sub_lexeme(lexbuf, Caml_array.get(lexbuf.lex_mem, 0), lexbuf.lex_curr_pos);
          update_loc(lexbuf, undefined, 1, false, space.length);
          return string(lexbuf);
      case 2 :
          store_string_char(char_for_backslash(Stdlib__Lexing.lexeme_char(lexbuf, 1)));
          return string(lexbuf);
      case 3 :
          store_string_char(char_for_decimal_code(lexbuf, 1));
          return string(lexbuf);
      case 4 :
          store_string_char(char_for_hexadecimal_code(lexbuf, 2));
          return string(lexbuf);
      case 5 :
          if (Caml_obj.caml_notequal(comment_start_loc.contents, /* [] */0)) {
            return string(lexbuf);
          }
          const loc = curr(lexbuf);
          prerr_warning(loc, /* Illegal_backslash */7);
          store_string_char(Stdlib__Lexing.lexeme_char(lexbuf, 0));
          store_string_char(Stdlib__Lexing.lexeme_char(lexbuf, 1));
          return string(lexbuf);
      case 6 :
          if (!Caml_obj.caml_notequal(comment_start_loc.contents, /* [] */0)) {
            prerr_warning(curr(lexbuf), /* Eol_in_string */14);
          }
          update_loc(lexbuf, undefined, 1, false, 0);
          store_string(Stdlib__Lexing.lexeme(lexbuf));
          return string(lexbuf);
      case 7 :
          is_in_string.contents = false;
          throw new Caml_js_exceptions.MelangeError($$Error$4, {
                    MEL_EXN_ID: $$Error$4,
                    _1: /* Unterminated_string */0,
                    _2: string_start_loc.contents
                  });
      case 8 :
          store_string_char(Stdlib__Lexing.lexeme_char(lexbuf, 0));
          return string(lexbuf);
      default:
        Curry._1(lexbuf.refill_buff, lexbuf);
        ___ocaml_lex_state = __ocaml_lex_state$1;
        continue ;
    }
  };
}

function __ocaml_lex_comment_rec(lexbuf, ___ocaml_lex_state) {
  while(true) {
    const __ocaml_lex_state = ___ocaml_lex_state;
    const __ocaml_lex_state$1 = Stdlib__Lexing.engine(__ocaml_lex_tables, __ocaml_lex_state, lexbuf);
    switch (__ocaml_lex_state$1) {
      case 0 :
          comment_start_loc.contents = {
            hd: curr(lexbuf),
            tl: comment_start_loc.contents
          };
          store_string(Stdlib__Lexing.lexeme(lexbuf));
          ___ocaml_lex_state = 132;
          continue ;
      case 1 :
          const match = comment_start_loc.contents;
          if (match) {
            if (match.tl) {
              comment_start_loc.contents = match.tl;
              store_string(Stdlib__Lexing.lexeme(lexbuf));
              ___ocaml_lex_state = 132;
              continue ;
            }
            comment_start_loc.contents = /* [] */0;
            return curr(lexbuf);
          }
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                    MEL_EXN_ID: "Assert_failure",
                    _1: [
                      "jscomp/test/ocaml_typedtree_test.ml",
                      26844,
                      16
                    ]
                  });
      case 2 :
          string_start_loc.contents = curr(lexbuf);
          store_string_char(/* '"' */34);
          is_in_string.contents = true;
          try {
            string(lexbuf);
          }
          catch (raw_exn){
            const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.MEL_EXN_ID === $$Error$4) {
              const match$1 = exn._1;
              if (typeof match$1 === "number") {
                if (match$1) {
                  throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
                }
                const match$2 = comment_start_loc.contents;
                if (match$2) {
                  const start = Stdlib__List.hd(Stdlib__List.rev(comment_start_loc.contents));
                  comment_start_loc.contents = /* [] */0;
                  throw new Caml_js_exceptions.MelangeError($$Error$4, {
                            MEL_EXN_ID: $$Error$4,
                            _1: {
                              TAG: /* Unterminated_string_in_comment */3,
                              _0: start,
                              _1: exn._2
                            },
                            _2: match$2.hd
                          });
                }
                throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                          MEL_EXN_ID: "Assert_failure",
                          _1: [
                            "jscomp/test/ocaml_typedtree_test.ml",
                            26861,
                            18
                          ]
                        });
              }
              throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
            }
            throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
          }
          is_in_string.contents = false;
          store_string_char(/* '"' */34);
          ___ocaml_lex_state = 132;
          continue ;
      case 3 :
          const delim = Stdlib__Lexing.lexeme(lexbuf);
          const delim$1 = Stdlib__String.sub(delim, 1, delim.length - 2 | 0);
          string_start_loc.contents = curr(lexbuf);
          store_string(Stdlib__Lexing.lexeme(lexbuf));
          is_in_string.contents = true;
          try {
            __ocaml_lex_quoted_string_rec(delim$1, lexbuf, 183);
          }
          catch (raw_exn$1){
            const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
            if (exn$1.MEL_EXN_ID === $$Error$4) {
              const match$3 = exn$1._1;
              if (typeof match$3 === "number") {
                if (match$3) {
                  throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
                }
                const match$4 = comment_start_loc.contents;
                if (match$4) {
                  const start$1 = Stdlib__List.hd(Stdlib__List.rev(comment_start_loc.contents));
                  comment_start_loc.contents = /* [] */0;
                  throw new Caml_js_exceptions.MelangeError($$Error$4, {
                            MEL_EXN_ID: $$Error$4,
                            _1: {
                              TAG: /* Unterminated_string_in_comment */3,
                              _0: start$1,
                              _1: exn$1._2
                            },
                            _2: match$4.hd
                          });
                }
                throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                          MEL_EXN_ID: "Assert_failure",
                          _1: [
                            "jscomp/test/ocaml_typedtree_test.ml",
                            26884,
                            18
                          ]
                        });
              }
              throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
            }
            throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
          }
          is_in_string.contents = false;
          store_string_char(/* '|' */124);
          store_string(delim$1);
          store_string_char(/* '}' */125);
          ___ocaml_lex_state = 132;
          continue ;
      case 5 :
          update_loc(lexbuf, undefined, 1, false, 1);
          store_string(Stdlib__Lexing.lexeme(lexbuf));
          ___ocaml_lex_state = 132;
          continue ;
      case 10 :
          const match$5 = comment_start_loc.contents;
          if (match$5) {
            const start$2 = Stdlib__List.hd(Stdlib__List.rev(comment_start_loc.contents));
            comment_start_loc.contents = /* [] */0;
            throw new Caml_js_exceptions.MelangeError($$Error$4, {
                      MEL_EXN_ID: $$Error$4,
                      _1: {
                        TAG: /* Unterminated_comment */2,
                        _0: start$2
                      },
                      _2: match$5.hd
                    });
          }
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                    MEL_EXN_ID: "Assert_failure",
                    _1: [
                      "jscomp/test/ocaml_typedtree_test.ml",
                      26934,
                      16
                    ]
                  });
      case 11 :
          update_loc(lexbuf, undefined, 1, false, 0);
          store_string(Stdlib__Lexing.lexeme(lexbuf));
          ___ocaml_lex_state = 132;
          continue ;
      case 4 :
      case 6 :
      case 7 :
      case 8 :
      case 9 :
      case 12 :
          store_string(Stdlib__Lexing.lexeme(lexbuf));
          ___ocaml_lex_state = 132;
          continue ;
      default:
        Curry._1(lexbuf.refill_buff, lexbuf);
        ___ocaml_lex_state = __ocaml_lex_state$1;
        continue ;
    }
  };
}

function __ocaml_lex_quoted_string_rec(delim, lexbuf, ___ocaml_lex_state) {
  while(true) {
    const __ocaml_lex_state = ___ocaml_lex_state;
    const __ocaml_lex_state$1 = Stdlib__Lexing.engine(__ocaml_lex_tables, __ocaml_lex_state, lexbuf);
    switch (__ocaml_lex_state$1) {
      case 0 :
          update_loc(lexbuf, undefined, 1, false, 0);
          store_string(Stdlib__Lexing.lexeme(lexbuf));
          ___ocaml_lex_state = 183;
          continue ;
      case 1 :
          is_in_string.contents = false;
          throw new Caml_js_exceptions.MelangeError($$Error$4, {
                    MEL_EXN_ID: $$Error$4,
                    _1: /* Unterminated_string */0,
                    _2: string_start_loc.contents
                  });
      case 2 :
          const edelim = Stdlib__Lexing.lexeme(lexbuf);
          const edelim$1 = Stdlib__String.sub(edelim, 1, edelim.length - 2 | 0);
          if (delim === edelim$1) {
            return ;
          }
          store_string(Stdlib__Lexing.lexeme(lexbuf));
          ___ocaml_lex_state = 183;
          continue ;
      case 3 :
          store_string_char(Stdlib__Lexing.lexeme_char(lexbuf, 0));
          ___ocaml_lex_state = 183;
          continue ;
      default:
        Curry._1(lexbuf.refill_buff, lexbuf);
        ___ocaml_lex_state = __ocaml_lex_state$1;
        continue ;
    }
  };
}

function at_bol(lexbuf) {
  const pos = lexbuf.lex_start_p;
  return pos.pos_cnum === pos.pos_bol;
}

function token_with_comments(lexbuf) {
  const match = preprocessor.contents;
  if (match !== undefined) {
    return Curry._2(match[1], token, lexbuf);
  } else {
    return token(lexbuf);
  }
}

function token$1(lexbuf) {
  const post_pos = lexbuf.lex_curr_p;
  const attach = function (lines, docs, pre_pos) {
    if (typeof docs === "number") {
      return ;
    }
    if (docs.TAG === /* After */0) {
      const a = docs._0;
      if (lines >= 2) {
        set_post_docstrings(post_pos, Stdlib__List.rev(a));
        return set_pre_extra_docstrings(pre_pos, Stdlib__List.rev(a));
      } else {
        set_post_docstrings(post_pos, Stdlib__List.rev(a));
        return set_pre_docstrings(pre_pos, a);
      }
    }
    const b = docs._2;
    const f = docs._1;
    const a$1 = docs._0;
    if (lines >= 2) {
      set_post_docstrings(post_pos, Stdlib__List.rev(a$1));
      set_post_extra_docstrings(post_pos, Stdlib__List.rev_append(f, Stdlib__List.rev(b)));
      set_floating_docstrings(pre_pos, Stdlib__List.rev_append(f, Stdlib__List.rev(b)));
      return set_pre_extra_docstrings(pre_pos, Stdlib__List.rev(a$1));
    } else {
      set_post_docstrings(post_pos, Stdlib__List.rev(a$1));
      set_post_extra_docstrings(post_pos, Stdlib__List.rev_append(f, Stdlib__List.rev(b)));
      set_floating_docstrings(pre_pos, Stdlib__List.rev(f));
      set_pre_extra_docstrings(pre_pos, Stdlib__List.rev(a$1));
      return set_pre_docstrings(pre_pos, b);
    }
  };
  const loop = function (_lines, _docs, lexbuf) {
    while(true) {
      const docs = _docs;
      const lines = _lines;
      const doc = token_with_comments(lexbuf);
      if (typeof doc === "number") {
        switch (doc) {
          case /* SHARP */84 :
              if (at_bol(lexbuf)) {
                const cont = function (lexbuf) {
                  return loop(lines, docs, lexbuf);
                };
                const look_ahead = function (token) {
                  sharp_look_ahead.contents = token;
                  return /* SHARP */84;
                };
                const if_then_else$1 = if_then_else.contents;
                const match = token_with_comments(lexbuf);
                if (typeof match === "number") {
                  switch (match) {
                    case /* ELSE */23 :
                        if (if_then_else$1) {
                          throw new Caml_js_exceptions.MelangeError($$Error$4, {
                                    MEL_EXN_ID: $$Error$4,
                                    _1: /* Unexpected_directive */6,
                                    _2: curr(lexbuf)
                                  });
                        }
                        break;
                    case /* END */24 :
                        if (if_then_else$1 >= 2) {
                          throw new Caml_js_exceptions.MelangeError($$Error$4, {
                                    MEL_EXN_ID: $$Error$4,
                                    _1: /* Unexpected_directive */6,
                                    _2: curr(lexbuf)
                                  });
                        }
                        if_then_else.contents = /* Dir_out */2;
                        return Curry._1(cont, lexbuf);
                    case /* IF */37 :
                        if (if_then_else$1 >= 2) {
                          if (directive_parse(token_with_comments, lexbuf)) {
                            if_then_else.contents = /* Dir_if_true */0;
                            return Curry._1(cont, lexbuf);
                          } else {
                            let _param;
                            while(true) {
                              const token = token_with_comments(lexbuf);
                              if (Caml_obj.caml_equal(token, /* EOF */25)) {
                                throw new Caml_js_exceptions.MelangeError($$Error$4, {
                                          MEL_EXN_ID: $$Error$4,
                                          _1: /* Unterminated_if */2,
                                          _2: curr(lexbuf)
                                        });
                              }
                              if (Caml_obj.caml_equal(token, /* SHARP */84) && at_bol(lexbuf)) {
                                const token$1 = token_with_comments(lexbuf);
                                if (typeof token$1 === "number") {
                                  if (token$1 === 24 || token$1 === 23) {
                                    if (token$1 >= 24) {
                                      if_then_else.contents = /* Dir_out */2;
                                      return Curry._1(cont, lexbuf);
                                    } else {
                                      if_then_else.contents = /* Dir_if_false */1;
                                      return Curry._1(cont, lexbuf);
                                    }
                                  }
                                  if (token$1 === 37) {
                                    throw new Caml_js_exceptions.MelangeError($$Error$4, {
                                              MEL_EXN_ID: $$Error$4,
                                              _1: /* Unexpected_directive */6,
                                              _2: curr(lexbuf)
                                            });
                                  }
                                  
                                }
                                if (is_elif(token$1) && directive_parse(token_with_comments, lexbuf)) {
                                  if_then_else.contents = /* Dir_if_true */0;
                                  return Curry._1(cont, lexbuf);
                                }
                                _param = undefined;
                                continue ;
                              }
                              _param = undefined;
                              continue ;
                            };
                          }
                        }
                        throw new Caml_js_exceptions.MelangeError($$Error$4, {
                                  MEL_EXN_ID: $$Error$4,
                                  _1: /* Unexpected_directive */6,
                                  _2: curr(lexbuf)
                                });
                    default:
                      return Curry._1(look_ahead, match);
                  }
                } else {
                  if (match.TAG !== /* LIDENT */11) {
                    return Curry._1(look_ahead, match);
                  }
                  if (match._0 !== "elif") {
                    return Curry._1(look_ahead, match);
                  }
                  if (if_then_else$1) {
                    throw new Caml_js_exceptions.MelangeError($$Error$4, {
                              MEL_EXN_ID: $$Error$4,
                              _1: /* Unexpected_directive */6,
                              _2: curr(lexbuf)
                            });
                  }
                  
                }
                if (if_then_else$1) {
                  return Curry._1(look_ahead, match);
                }
                let _else_seen = Caml_obj.caml_equal(match, /* ELSE */23);
                while(true) {
                  const else_seen = _else_seen;
                  const token$2 = token_with_comments(lexbuf);
                  if (Caml_obj.caml_equal(token$2, /* EOF */25)) {
                    throw new Caml_js_exceptions.MelangeError($$Error$4, {
                              MEL_EXN_ID: $$Error$4,
                              _1: /* Unterminated_else */3,
                              _2: curr(lexbuf)
                            });
                  }
                  if (Caml_obj.caml_equal(token$2, /* SHARP */84) && at_bol(lexbuf)) {
                    const token$3 = token_with_comments(lexbuf);
                    if (typeof token$3 === "number") {
                      if (token$3 === 24 || token$3 === 23) {
                        if (token$3 >= 24) {
                          if_then_else.contents = /* Dir_out */2;
                          return Curry._1(cont, lexbuf);
                        }
                        if (else_seen) {
                          throw new Caml_js_exceptions.MelangeError($$Error$4, {
                                    MEL_EXN_ID: $$Error$4,
                                    _1: /* Unexpected_directive */6,
                                    _2: curr(lexbuf)
                                  });
                        }
                        _else_seen = true;
                        continue ;
                      }
                      if (token$3 === 37) {
                        throw new Caml_js_exceptions.MelangeError($$Error$4, {
                                  MEL_EXN_ID: $$Error$4,
                                  _1: /* Unexpected_directive */6,
                                  _2: curr(lexbuf)
                                });
                      }
                      
                    }
                    if (else_seen && is_elif(token$3)) {
                      throw new Caml_js_exceptions.MelangeError($$Error$4, {
                                MEL_EXN_ID: $$Error$4,
                                _1: /* Unexpected_directive */6,
                                _2: curr(lexbuf)
                              });
                    }
                    continue ;
                  }
                  continue ;
                };
              }
              break;
          case /* EOL */100 :
              const lines$p = lines ? /* BlankLine */2 : /* NewLine */1;
              _lines = lines$p;
              continue ;
          default:
            
        }
      } else {
        switch (doc.TAG | 0) {
          case /* COMMENT */18 :
              const match$1 = doc._0;
              add_comment([
                    match$1[0],
                    match$1[1]
                  ]);
              const lines$p$1 = lines >= 2 ? /* BlankLine */2 : /* NoLine */0;
              _lines = lines$p$1;
              continue ;
          case /* DOCSTRING */19 :
              const doc$1 = doc._0;
              add_docstring_comment(doc$1);
              let docs$p;
              if (typeof docs === "number") {
                docs$p = lines >= 2 ? ({
                      TAG: /* Before */1,
                      _0: /* [] */0,
                      _1: /* [] */0,
                      _2: {
                        hd: doc$1,
                        tl: /* [] */0
                      }
                    }) : ({
                      TAG: /* After */0,
                      _0: {
                        hd: doc$1,
                        tl: /* [] */0
                      }
                    });
              } else if (docs.TAG === /* After */0) {
                const a = docs._0;
                docs$p = lines >= 2 ? ({
                      TAG: /* Before */1,
                      _0: a,
                      _1: /* [] */0,
                      _2: {
                        hd: doc$1,
                        tl: /* [] */0
                      }
                    }) : ({
                      TAG: /* After */0,
                      _0: {
                        hd: doc$1,
                        tl: a
                      }
                    });
              } else {
                const b = docs._2;
                const f = docs._1;
                const a$1 = docs._0;
                docs$p = lines >= 2 ? ({
                      TAG: /* Before */1,
                      _0: a$1,
                      _1: Stdlib.$at(b, f),
                      _2: {
                        hd: doc$1,
                        tl: /* [] */0
                      }
                    }) : ({
                      TAG: /* Before */1,
                      _0: a$1,
                      _1: f,
                      _2: {
                        hd: doc$1,
                        tl: b
                      }
                    });
              }
              _docs = docs$p;
              _lines = /* NoLine */0;
              continue ;
          default:
            
        }
      }
      attach(lines, docs, lexbuf.lex_start_p);
      return doc;
    };
  };
  const token$2 = sharp_look_ahead.contents;
  if (token$2 !== undefined) {
    sharp_look_ahead.contents = undefined;
    return token$2;
  } else {
    return loop(/* NoLine */0, /* Initial */0, lexbuf);
  }
}

function init$1(param) {
  sharp_look_ahead.contents = undefined;
  if_then_else.contents = /* Dir_out */2;
  is_in_string.contents = false;
  comment_start_loc.contents = /* [] */0;
  comment_list.contents = /* [] */0;
  const match = preprocessor.contents;
  if (match !== undefined) {
    return Curry._1(match[0], undefined);
  }
  
}

function skip_phrase(lexbuf) {
  while(true) {
    try {
      const match = token$1(lexbuf);
      if (typeof match === "number" && !(match !== 25 && match !== 83)) {
        return ;
      } else {
        return skip_phrase(lexbuf);
      }
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === $$Error$4) {
        let tmp = exn._1;
        if (typeof tmp === "number") {
          if (tmp === /* Unterminated_string */0) {
            continue ;
          }
          throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
        } else {
          switch (tmp.TAG | 0) {
            case /* Illegal_character */0 :
            case /* Unterminated_comment */2 :
            case /* Unterminated_string_in_comment */3 :
                continue ;
            default:
              throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
          }
        }
      } else {
        throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
      }
    }
  };
}

function maybe_skip_phrase(lexbuf) {
  if (Stdlib__Parsing.is_current_lookahead(/* SEMISEMI */83) || Stdlib__Parsing.is_current_lookahead(/* EOF */25)) {
    return ;
  } else {
    return skip_phrase(lexbuf);
  }
}

function wrap$1(parsing_fun, lexbuf) {
  try {
    init(undefined);
    init$1(undefined);
    const ast = Curry._2(parsing_fun, token$1, lexbuf);
    Stdlib__Parsing.clear_parser(undefined);
    warn_bad_docstrings(undefined);
    return ast;
  }
  catch (raw_err){
    const err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.MEL_EXN_ID === $$Error$4) {
      let tmp = err._1;
      if (typeof tmp === "number") {
        throw new Caml_js_exceptions.MelangeError(err.MEL_EXN_ID, err);
      }
      if (tmp.TAG === /* Illegal_character */0) {
        if (input_name.contents === "//toplevel//") {
          skip_phrase(lexbuf);
          throw new Caml_js_exceptions.MelangeError(err.MEL_EXN_ID, err);
        }
        throw new Caml_js_exceptions.MelangeError(err.MEL_EXN_ID, err);
      }
      throw new Caml_js_exceptions.MelangeError(err.MEL_EXN_ID, err);
    } else {
      if (err.MEL_EXN_ID === $$Error$3) {
        if (input_name.contents === "//toplevel//") {
          maybe_skip_phrase(lexbuf);
          throw new Caml_js_exceptions.MelangeError(err.MEL_EXN_ID, err);
        }
        throw new Caml_js_exceptions.MelangeError(err.MEL_EXN_ID, err);
      }
      if (err.MEL_EXN_ID !== Stdlib__Parsing.Parse_error && err.MEL_EXN_ID !== Escape_error) {
        throw new Caml_js_exceptions.MelangeError(err.MEL_EXN_ID, err);
      }
      
    }
    const loc = curr(lexbuf);
    if (input_name.contents === "//toplevel//") {
      maybe_skip_phrase(lexbuf);
    }
    throw new Caml_js_exceptions.MelangeError($$Error$3, {
              MEL_EXN_ID: $$Error$3,
              _1: {
                TAG: /* Other */5,
                _0: loc
              }
            });
  }
}

function iter_pattern_desc(f, patl) {
  if (typeof patl === "number") {
    return ;
  }
  switch (patl.TAG | 0) {
    case /* Tpat_construct */4 :
        return Stdlib__List.iter(f, patl._2);
    case /* Tpat_variant */5 :
        return may(f, patl._1);
    case /* Tpat_record */6 :
        return Stdlib__List.iter((function (param) {
                      Curry._1(f, param[2]);
                    }), patl._0);
    case /* Tpat_tuple */3 :
    case /* Tpat_array */7 :
        return Stdlib__List.iter(f, patl._0);
    case /* Tpat_or */8 :
        Curry._1(f, patl._0);
        return Curry._1(f, patl._1);
    case /* Tpat_alias */1 :
    case /* Tpat_lazy */9 :
        return Curry._1(f, patl._0);
    default:
      return ;
  }
}

function map_pattern_desc(f, d) {
  if (typeof d === "number") {
    return d;
  }
  switch (d.TAG | 0) {
    case /* Tpat_alias */1 :
        return {
                TAG: /* Tpat_alias */1,
                _0: Curry._1(f, d._0),
                _1: d._1,
                _2: d._2
              };
    case /* Tpat_tuple */3 :
        return {
                TAG: /* Tpat_tuple */3,
                _0: Stdlib__List.map(f, d._0)
              };
    case /* Tpat_construct */4 :
        return {
                TAG: /* Tpat_construct */4,
                _0: d._0,
                _1: d._1,
                _2: Stdlib__List.map(f, d._2)
              };
    case /* Tpat_variant */5 :
        const p1 = d._1;
        if (p1 !== undefined) {
          return {
                  TAG: /* Tpat_variant */5,
                  _0: d._0,
                  _1: Curry._1(f, p1),
                  _2: d._2
                };
        } else {
          return d;
        }
    case /* Tpat_record */6 :
        return {
                TAG: /* Tpat_record */6,
                _0: Stdlib__List.map((function (param) {
                        return [
                                param[0],
                                param[1],
                                Curry._1(f, param[2])
                              ];
                      }), d._0),
                _1: d._1
              };
    case /* Tpat_array */7 :
        return {
                TAG: /* Tpat_array */7,
                _0: Stdlib__List.map(f, d._0)
              };
    case /* Tpat_or */8 :
        return {
                TAG: /* Tpat_or */8,
                _0: Curry._1(f, d._0),
                _1: Curry._1(f, d._1),
                _2: d._2
              };
    case /* Tpat_lazy */9 :
        return {
                TAG: /* Tpat_lazy */9,
                _0: Curry._1(f, d._0)
              };
    default:
      return d;
  }
}

const idents = {
  contents: /* [] */0
};

function bound_idents(_pat) {
  while(true) {
    const pat = _pat;
    const d = pat.pat_desc;
    if (typeof d === "number") {
      return iter_pattern_desc(bound_idents, d);
    }
    switch (d.TAG | 0) {
      case /* Tpat_var */0 :
          idents.contents = {
            hd: [
              d._0,
              d._1
            ],
            tl: idents.contents
          };
          return ;
      case /* Tpat_alias */1 :
          bound_idents(d._0);
          idents.contents = {
            hd: [
              d._1,
              d._2
            ],
            tl: idents.contents
          };
          return ;
      case /* Tpat_or */8 :
          _pat = d._0;
          continue ;
      default:
        return iter_pattern_desc(bound_idents, d);
    }
  };
}

function pat_bound_idents(pat) {
  idents.contents = /* [] */0;
  bound_idents(pat);
  const res = idents.contents;
  idents.contents = /* [] */0;
  return res;
}

function rev_let_bound_idents_with_loc(bindings) {
  idents.contents = /* [] */0;
  Stdlib__List.iter((function (vb) {
          bound_idents(vb.vb_pat);
        }), bindings);
  const res = idents.contents;
  idents.contents = /* [] */0;
  return res;
}

function let_bound_idents(pat) {
  return Stdlib__List.map((function (prim) {
                return prim[0];
              }), Stdlib__List.rev(rev_let_bound_idents_with_loc(pat)));
}

function alpha_pat(env, p) {
  const d = p.pat_desc;
  if (typeof d !== "number") {
    switch (d.TAG | 0) {
      case /* Tpat_var */0 :
          let tmp;
          try {
            tmp = {
              TAG: /* Tpat_var */0,
              _0: Stdlib__List.assoc(d._0, env),
              _1: d._1
            };
          }
          catch (raw_exn){
            const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.MEL_EXN_ID === Stdlib.Not_found) {
              tmp = /* Tpat_any */0;
            } else {
              throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
            }
          }
          return {
                  pat_desc: tmp,
                  pat_loc: p.pat_loc,
                  pat_extra: p.pat_extra,
                  pat_type: p.pat_type,
                  pat_env: p.pat_env,
                  pat_attributes: p.pat_attributes
                };
      case /* Tpat_alias */1 :
          const new_p = alpha_pat(env, d._0);
          try {
            return {
                    pat_desc: {
                      TAG: /* Tpat_alias */1,
                      _0: new_p,
                      _1: Stdlib__List.assoc(d._1, env),
                      _2: d._2
                    },
                    pat_loc: p.pat_loc,
                    pat_extra: p.pat_extra,
                    pat_type: p.pat_type,
                    pat_env: p.pat_env,
                    pat_attributes: p.pat_attributes
                  };
          }
          catch (raw_exn$1){
            const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
            if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
              return new_p;
            }
            throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
          }
      default:
        
    }
  }
  return {
          pat_desc: map_pattern_desc((function (param) {
                  return alpha_pat(env, param);
                }), d),
          pat_loc: p.pat_loc,
          pat_extra: p.pat_extra,
          pat_type: p.pat_type,
          pat_env: p.pat_env,
          pat_attributes: p.pat_attributes
        };
}

function enter_structure(t) {
  return t;
}

function enter_value_description(t) {
  return t;
}

function enter_type_declaration(t) {
  return t;
}

function enter_type_extension(t) {
  return t;
}

function enter_extension_constructor(t) {
  return t;
}

function enter_pattern(t) {
  return t;
}

function enter_expression(t) {
  return t;
}

function enter_package_type(t) {
  return t;
}

function enter_signature(t) {
  return t;
}

function enter_signature_item(t) {
  return t;
}

function enter_module_type_declaration(t) {
  return t;
}

function enter_module_type(t) {
  return t;
}

function enter_module_expr(t) {
  return t;
}

function enter_with_constraint(t) {
  return t;
}

function enter_class_expr(t) {
  return t;
}

function enter_class_signature(t) {
  return t;
}

function enter_class_declaration(t) {
  return t;
}

function enter_class_description(t) {
  return t;
}

function enter_class_type_declaration(t) {
  return t;
}

function enter_class_type(t) {
  return t;
}

function enter_class_type_field(t) {
  return t;
}

function enter_core_type(t) {
  return t;
}

function enter_class_structure(t) {
  return t;
}

function enter_class_field(t) {
  return t;
}

function enter_structure_item(t) {
  return t;
}

function leave_value_description(t) {
  return t;
}

function leave_type_declaration(t) {
  return t;
}

function leave_type_extension(t) {
  return t;
}

function leave_extension_constructor(t) {
  return t;
}

function leave_package_type(t) {
  return t;
}

function leave_module_type_declaration(t) {
  return t;
}

function leave_with_constraint(t) {
  return t;
}

function leave_class_signature(t) {
  return t;
}

function leave_class_declaration(t) {
  return t;
}

function leave_class_description(t) {
  return t;
}

function leave_class_type_declaration(t) {
  return t;
}

function leave_class_type_field(t) {
  return t;
}

function leave_class_structure(t) {
  return t;
}

function leave_class_field(t) {
  return t;
}

function TypedtreeMap_MakeMap(funarg) {
  const map_structure = function (str) {
    const str$1 = Curry._1(funarg.enter_structure, str);
    const str_items = Stdlib__List.map(map_structure_item, str$1.str_items);
    return Curry._1(funarg.leave_structure, {
                str_items: str_items,
                str_type: str$1.str_type,
                str_final_env: str$1.str_final_env
              });
  };
  const map_core_type = function (ct) {
    const ct$1 = Curry._1(funarg.enter_core_type, ct);
    const list = ct$1.ctyp_desc;
    let ctyp_desc;
    if (typeof list === "number") {
      ctyp_desc = ct$1.ctyp_desc;
    } else {
      switch (list.TAG | 0) {
        case /* Ttyp_var */0 :
            ctyp_desc = ct$1.ctyp_desc;
            break;
        case /* Ttyp_arrow */1 :
            ctyp_desc = {
              TAG: /* Ttyp_arrow */1,
              _0: list._0,
              _1: map_core_type(list._1),
              _2: map_core_type(list._2)
            };
            break;
        case /* Ttyp_tuple */2 :
            ctyp_desc = {
              TAG: /* Ttyp_tuple */2,
              _0: Stdlib__List.map(map_core_type, list._0)
            };
            break;
        case /* Ttyp_constr */3 :
            ctyp_desc = {
              TAG: /* Ttyp_constr */3,
              _0: list._0,
              _1: list._1,
              _2: Stdlib__List.map(map_core_type, list._2)
            };
            break;
        case /* Ttyp_object */4 :
            ctyp_desc = {
              TAG: /* Ttyp_object */4,
              _0: Stdlib__List.map((function (param) {
                      return [
                              param[0],
                              param[1],
                              map_core_type(param[2])
                            ];
                    }), list._0),
              _1: list._1
            };
            break;
        case /* Ttyp_class */5 :
            ctyp_desc = {
              TAG: /* Ttyp_class */5,
              _0: list._0,
              _1: list._1,
              _2: Stdlib__List.map(map_core_type, list._2)
            };
            break;
        case /* Ttyp_alias */6 :
            ctyp_desc = {
              TAG: /* Ttyp_alias */6,
              _0: map_core_type(list._0),
              _1: list._1
            };
            break;
        case /* Ttyp_variant */7 :
            ctyp_desc = {
              TAG: /* Ttyp_variant */7,
              _0: Stdlib__List.map(map_row_field, list._0),
              _1: list._1,
              _2: list._2
            };
            break;
        case /* Ttyp_poly */8 :
            ctyp_desc = {
              TAG: /* Ttyp_poly */8,
              _0: list._0,
              _1: map_core_type(list._1)
            };
            break;
        case /* Ttyp_package */9 :
            ctyp_desc = {
              TAG: /* Ttyp_package */9,
              _0: map_package_type(list._0)
            };
            break;
        
      }
    }
    return Curry._1(funarg.leave_core_type, {
                ctyp_desc: ctyp_desc,
                ctyp_type: ct$1.ctyp_type,
                ctyp_env: ct$1.ctyp_env,
                ctyp_loc: ct$1.ctyp_loc,
                ctyp_attributes: ct$1.ctyp_attributes
              });
  };
  const map_row_field = function (rf) {
    if (rf.TAG === /* Ttag */0) {
      return {
              TAG: /* Ttag */0,
              _0: rf._0,
              _1: rf._1,
              _2: rf._2,
              _3: Stdlib__List.map(map_core_type, rf._3)
            };
    } else {
      return {
              TAG: /* Tinherit */1,
              _0: map_core_type(rf._0)
            };
    }
  };
  const map_package_type = function (pack) {
    const pack$1 = Curry._1(funarg.enter_package_type, pack);
    const pack_fields = Stdlib__List.map((function (param) {
            return [
                    param[0],
                    map_core_type(param[1])
                  ];
          }), pack$1.pack_fields);
    return Curry._1(funarg.leave_package_type, {
                pack_path: pack$1.pack_path,
                pack_fields: pack_fields,
                pack_type: pack$1.pack_type,
                pack_txt: pack$1.pack_txt
              });
  };
  const map_module_type = function (mty) {
    const mty$1 = Curry._1(funarg.enter_module_type, mty);
    const sg = mty$1.mty_desc;
    let mty_desc;
    switch (sg.TAG | 0) {
      case /* Tmty_signature */1 :
          mty_desc = {
            TAG: /* Tmty_signature */1,
            _0: map_signature(sg._0)
          };
          break;
      case /* Tmty_functor */2 :
          mty_desc = {
            TAG: /* Tmty_functor */2,
            _0: sg._0,
            _1: sg._1,
            _2: may_map(map_module_type, sg._2),
            _3: map_module_type(sg._3)
          };
          break;
      case /* Tmty_with */3 :
          mty_desc = {
            TAG: /* Tmty_with */3,
            _0: map_module_type(sg._0),
            _1: Stdlib__List.map((function (param) {
                    return [
                            param[0],
                            param[1],
                            map_with_constraint(param[2])
                          ];
                  }), sg._1)
          };
          break;
      case /* Tmty_typeof */4 :
          mty_desc = {
            TAG: /* Tmty_typeof */4,
            _0: map_module_expr(sg._0)
          };
          break;
      case /* Tmty_ident */0 :
      case /* Tmty_alias */5 :
          mty_desc = mty$1.mty_desc;
          break;
      
    }
    return Curry._1(funarg.leave_module_type, {
                mty_desc: mty_desc,
                mty_type: mty$1.mty_type,
                mty_env: mty$1.mty_env,
                mty_loc: mty$1.mty_loc,
                mty_attributes: mty$1.mty_attributes
              });
  };
  const map_expression = function (exp) {
    const exp$1 = Curry._1(funarg.enter_expression, exp);
    const list = exp$1.exp_desc;
    let exp_desc;
    switch (list.TAG | 0) {
      case /* Texp_let */2 :
          const rec_flag = list._0;
          exp_desc = {
            TAG: /* Texp_let */2,
            _0: rec_flag,
            _1: Stdlib__List.map(map_binding, list._1),
            _2: map_expression(list._2)
          };
          break;
      case /* Texp_function */3 :
          exp_desc = {
            TAG: /* Texp_function */3,
            _0: list._0,
            _1: Stdlib__List.map(map_case, list._1),
            _2: list._2
          };
          break;
      case /* Texp_apply */4 :
          exp_desc = {
            TAG: /* Texp_apply */4,
            _0: map_expression(list._0),
            _1: Stdlib__List.map((function (param) {
                    const expo = param[1];
                    const expo$1 = expo !== undefined ? map_expression(expo) : expo;
                    return [
                            param[0],
                            expo$1,
                            param[2]
                          ];
                  }), list._1)
          };
          break;
      case /* Texp_match */5 :
          exp_desc = {
            TAG: /* Texp_match */5,
            _0: map_expression(list._0),
            _1: Stdlib__List.map(map_case, list._1),
            _2: Stdlib__List.map(map_case, list._2),
            _3: list._3
          };
          break;
      case /* Texp_try */6 :
          exp_desc = {
            TAG: /* Texp_try */6,
            _0: map_expression(list._0),
            _1: Stdlib__List.map(map_case, list._1)
          };
          break;
      case /* Texp_tuple */7 :
          exp_desc = {
            TAG: /* Texp_tuple */7,
            _0: Stdlib__List.map(map_expression, list._0)
          };
          break;
      case /* Texp_construct */8 :
          exp_desc = {
            TAG: /* Texp_construct */8,
            _0: list._0,
            _1: list._1,
            _2: Stdlib__List.map(map_expression, list._2)
          };
          break;
      case /* Texp_variant */9 :
          const expo = list._1;
          const expo$1 = expo !== undefined ? map_expression(expo) : expo;
          exp_desc = {
            TAG: /* Texp_variant */9,
            _0: list._0,
            _1: expo$1
          };
          break;
      case /* Texp_record */10 :
          const expo$2 = list._1;
          const list$1 = Stdlib__List.map((function (param) {
                  return [
                          param[0],
                          param[1],
                          map_expression(param[2])
                        ];
                }), list._0);
          const expo$3 = expo$2 !== undefined ? map_expression(expo$2) : expo$2;
          exp_desc = {
            TAG: /* Texp_record */10,
            _0: list$1,
            _1: expo$3
          };
          break;
      case /* Texp_field */11 :
          exp_desc = {
            TAG: /* Texp_field */11,
            _0: map_expression(list._0),
            _1: list._1,
            _2: list._2
          };
          break;
      case /* Texp_setfield */12 :
          exp_desc = {
            TAG: /* Texp_setfield */12,
            _0: map_expression(list._0),
            _1: list._1,
            _2: list._2,
            _3: map_expression(list._3)
          };
          break;
      case /* Texp_array */13 :
          exp_desc = {
            TAG: /* Texp_array */13,
            _0: Stdlib__List.map(map_expression, list._0)
          };
          break;
      case /* Texp_ifthenelse */14 :
          const expo$4 = list._2;
          exp_desc = {
            TAG: /* Texp_ifthenelse */14,
            _0: map_expression(list._0),
            _1: map_expression(list._1),
            _2: expo$4 !== undefined ? map_expression(expo$4) : expo$4
          };
          break;
      case /* Texp_sequence */15 :
          exp_desc = {
            TAG: /* Texp_sequence */15,
            _0: map_expression(list._0),
            _1: map_expression(list._1)
          };
          break;
      case /* Texp_while */16 :
          exp_desc = {
            TAG: /* Texp_while */16,
            _0: map_expression(list._0),
            _1: map_expression(list._1)
          };
          break;
      case /* Texp_for */17 :
          exp_desc = {
            TAG: /* Texp_for */17,
            _0: list._0,
            _1: list._1,
            _2: map_expression(list._2),
            _3: map_expression(list._3),
            _4: list._4,
            _5: map_expression(list._5)
          };
          break;
      case /* Texp_send */18 :
          exp_desc = {
            TAG: /* Texp_send */18,
            _0: map_expression(list._0),
            _1: list._1,
            _2: may_map(map_expression, list._2)
          };
          break;
      case /* Texp_ident */0 :
      case /* Texp_constant */1 :
      case /* Texp_new */19 :
      case /* Texp_instvar */20 :
          exp_desc = exp$1.exp_desc;
          break;
      case /* Texp_setinstvar */21 :
          exp_desc = {
            TAG: /* Texp_setinstvar */21,
            _0: list._0,
            _1: list._1,
            _2: list._2,
            _3: map_expression(list._3)
          };
          break;
      case /* Texp_override */22 :
          exp_desc = {
            TAG: /* Texp_override */22,
            _0: list._0,
            _1: Stdlib__List.map((function (param) {
                    return [
                            param[0],
                            param[1],
                            map_expression(param[2])
                          ];
                  }), list._1)
          };
          break;
      case /* Texp_letmodule */23 :
          exp_desc = {
            TAG: /* Texp_letmodule */23,
            _0: list._0,
            _1: list._1,
            _2: map_module_expr(list._2),
            _3: map_expression(list._3)
          };
          break;
      case /* Texp_assert */24 :
          exp_desc = {
            TAG: /* Texp_assert */24,
            _0: map_expression(list._0)
          };
          break;
      case /* Texp_lazy */25 :
          exp_desc = {
            TAG: /* Texp_lazy */25,
            _0: map_expression(list._0)
          };
          break;
      case /* Texp_object */26 :
          exp_desc = {
            TAG: /* Texp_object */26,
            _0: map_class_structure(list._0),
            _1: list._1
          };
          break;
      case /* Texp_pack */27 :
          exp_desc = {
            TAG: /* Texp_pack */27,
            _0: map_module_expr(list._0)
          };
          break;
      
    }
    const exp_extra = Stdlib__List.map(map_exp_extra, exp$1.exp_extra);
    return Curry._1(funarg.leave_expression, {
                exp_desc: exp_desc,
                exp_loc: exp$1.exp_loc,
                exp_extra: exp_extra,
                exp_type: exp$1.exp_type,
                exp_env: exp$1.exp_env,
                exp_attributes: exp$1.exp_attributes
              });
  };
  const map_module_expr = function (mexpr) {
    const mexpr$1 = Curry._1(funarg.enter_module_expr, mexpr);
    const st = mexpr$1.mod_desc;
    let mod_desc;
    switch (st.TAG | 0) {
      case /* Tmod_ident */0 :
          mod_desc = mexpr$1.mod_desc;
          break;
      case /* Tmod_structure */1 :
          mod_desc = {
            TAG: /* Tmod_structure */1,
            _0: map_structure(st._0)
          };
          break;
      case /* Tmod_functor */2 :
          mod_desc = {
            TAG: /* Tmod_functor */2,
            _0: st._0,
            _1: st._1,
            _2: may_map(map_module_type, st._2),
            _3: map_module_expr(st._3)
          };
          break;
      case /* Tmod_apply */3 :
          mod_desc = {
            TAG: /* Tmod_apply */3,
            _0: map_module_expr(st._0),
            _1: map_module_expr(st._1),
            _2: st._2
          };
          break;
      case /* Tmod_constraint */4 :
          const mtype = st._2;
          const mod_type = st._1;
          const mexpr$2 = st._0;
          mod_desc = mtype ? ({
                TAG: /* Tmod_constraint */4,
                _0: map_module_expr(mexpr$2),
                _1: mod_type,
                _2: /* Tmodtype_explicit */{
                  _0: map_module_type(mtype._0)
                },
                _3: st._3
              }) : ({
                TAG: /* Tmod_constraint */4,
                _0: map_module_expr(mexpr$2),
                _1: mod_type,
                _2: /* Tmodtype_implicit */0,
                _3: st._3
              });
          break;
      case /* Tmod_unpack */5 :
          mod_desc = {
            TAG: /* Tmod_unpack */5,
            _0: map_expression(st._0),
            _1: st._1
          };
          break;
      
    }
    return Curry._1(funarg.leave_module_expr, {
                mod_desc: mod_desc,
                mod_loc: mexpr$1.mod_loc,
                mod_type: mexpr$1.mod_type,
                mod_env: mexpr$1.mod_env,
                mod_attributes: mexpr$1.mod_attributes
              });
  };
  const map_extension_constructor = function (ext) {
    const ext$1 = Curry._1(funarg.enter_extension_constructor, ext);
    const match = ext$1.ext_kind;
    let ext_kind;
    if (match.TAG === /* Text_decl */0) {
      const args = Stdlib__List.map(map_core_type, match._0);
      const ret = may_map(map_core_type, match._1);
      ext_kind = {
        TAG: /* Text_decl */0,
        _0: args,
        _1: ret
      };
    } else {
      ext_kind = {
        TAG: /* Text_rebind */1,
        _0: match._0,
        _1: match._1
      };
    }
    return Curry._1(funarg.leave_extension_constructor, {
                ext_id: ext$1.ext_id,
                ext_name: ext$1.ext_name,
                ext_type: ext$1.ext_type,
                ext_kind: ext_kind,
                ext_loc: ext$1.ext_loc,
                ext_attributes: ext$1.ext_attributes
              });
  };
  const map_type_parameter = function (param) {
    return [
            map_core_type(param[0]),
            param[1]
          ];
  };
  const map_case = function (param) {
    return {
            c_lhs: map_pattern(param.c_lhs),
            c_guard: may_map(map_expression, param.c_guard),
            c_rhs: map_expression(param.c_rhs)
          };
  };
  const map_type_extension = function (tyext) {
    const tyext$1 = Curry._1(funarg.enter_type_extension, tyext);
    const tyext_params = Stdlib__List.map(map_type_parameter, tyext$1.tyext_params);
    const tyext_constructors = Stdlib__List.map(map_extension_constructor, tyext$1.tyext_constructors);
    return Curry._1(funarg.leave_type_extension, {
                tyext_path: tyext$1.tyext_path,
                tyext_txt: tyext$1.tyext_txt,
                tyext_params: tyext_params,
                tyext_constructors: tyext_constructors,
                tyext_private: tyext$1.tyext_private,
                tyext_attributes: tyext$1.tyext_attributes
              });
  };
  const map_value_description = function (v) {
    const v$1 = Curry._1(funarg.enter_value_description, v);
    const val_desc = map_core_type(v$1.val_desc);
    return Curry._1(funarg.leave_value_description, {
                val_id: v$1.val_id,
                val_name: v$1.val_name,
                val_desc: val_desc,
                val_val: v$1.val_val,
                val_prim: v$1.val_prim,
                val_loc: v$1.val_loc,
                val_attributes: v$1.val_attributes
              });
  };
  const map_module_type_declaration = function (mtd) {
    const mtd$1 = Curry._1(funarg.enter_module_type_declaration, mtd);
    return Curry._1(funarg.leave_module_type_declaration, {
                mtd_id: mtd$1.mtd_id,
                mtd_name: mtd$1.mtd_name,
                mtd_type: may_map(map_module_type, mtd$1.mtd_type),
                mtd_attributes: mtd$1.mtd_attributes,
                mtd_loc: mtd$1.mtd_loc
              });
  };
  const map_type_declaration = function (decl) {
    const decl$1 = Curry._1(funarg.enter_type_declaration, decl);
    const typ_params = Stdlib__List.map(map_type_parameter, decl$1.typ_params);
    const typ_cstrs = Stdlib__List.map((function (param) {
            return [
                    map_core_type(param[0]),
                    map_core_type(param[1]),
                    param[2]
                  ];
          }), decl$1.typ_cstrs);
    const list = decl$1.typ_kind;
    let typ_kind;
    if (typeof list === "number") {
      typ_kind = list === /* Ttype_abstract */0 ? /* Ttype_abstract */0 : /* Ttype_open */1;
    } else if (list.TAG === /* Ttype_variant */0) {
      const list$1 = Stdlib__List.map(map_constructor_declaration, list._0);
      typ_kind = {
        TAG: /* Ttype_variant */0,
        _0: list$1
      };
    } else {
      const list$2 = Stdlib__List.map((function (ld) {
              return {
                      ld_id: ld.ld_id,
                      ld_name: ld.ld_name,
                      ld_mutable: ld.ld_mutable,
                      ld_type: map_core_type(ld.ld_type),
                      ld_loc: ld.ld_loc,
                      ld_attributes: ld.ld_attributes
                    };
            }), list._0);
      typ_kind = {
        TAG: /* Ttype_record */1,
        _0: list$2
      };
    }
    const typ_manifest = may_map(map_core_type, decl$1.typ_manifest);
    return Curry._1(funarg.leave_type_declaration, {
                typ_id: decl$1.typ_id,
                typ_name: decl$1.typ_name,
                typ_params: typ_params,
                typ_type: decl$1.typ_type,
                typ_cstrs: typ_cstrs,
                typ_kind: typ_kind,
                typ_private: decl$1.typ_private,
                typ_manifest: typ_manifest,
                typ_loc: decl$1.typ_loc,
                typ_attributes: decl$1.typ_attributes
              });
  };
  const map_class_type_declaration = function (cd) {
    const cd$1 = Curry._1(funarg.enter_class_type_declaration, cd);
    const ci_params = Stdlib__List.map(map_type_parameter, cd$1.ci_params);
    const ci_expr = map_class_type(cd$1.ci_expr);
    return Curry._1(funarg.leave_class_type_declaration, {
                ci_virt: cd$1.ci_virt,
                ci_params: ci_params,
                ci_id_name: cd$1.ci_id_name,
                ci_id_class: cd$1.ci_id_class,
                ci_id_class_type: cd$1.ci_id_class_type,
                ci_id_object: cd$1.ci_id_object,
                ci_id_typesharp: cd$1.ci_id_typesharp,
                ci_expr: ci_expr,
                ci_decl: cd$1.ci_decl,
                ci_type_decl: cd$1.ci_type_decl,
                ci_loc: cd$1.ci_loc,
                ci_attributes: cd$1.ci_attributes
              });
  };
  const map_class_description = function (cd) {
    const cd$1 = Curry._1(funarg.enter_class_description, cd);
    const ci_params = Stdlib__List.map(map_type_parameter, cd$1.ci_params);
    const ci_expr = map_class_type(cd$1.ci_expr);
    return Curry._1(funarg.leave_class_description, {
                ci_virt: cd$1.ci_virt,
                ci_params: ci_params,
                ci_id_name: cd$1.ci_id_name,
                ci_id_class: cd$1.ci_id_class,
                ci_id_class_type: cd$1.ci_id_class_type,
                ci_id_object: cd$1.ci_id_object,
                ci_id_typesharp: cd$1.ci_id_typesharp,
                ci_expr: ci_expr,
                ci_decl: cd$1.ci_decl,
                ci_type_decl: cd$1.ci_type_decl,
                ci_loc: cd$1.ci_loc,
                ci_attributes: cd$1.ci_attributes
              });
  };
  const map_pattern = function (pat) {
    const pat$1 = Curry._1(funarg.enter_pattern, pat);
    const list = pat$1.pat_desc;
    let pat_desc;
    if (typeof list === "number") {
      pat_desc = pat$1.pat_desc;
    } else {
      switch (list.TAG | 0) {
        case /* Tpat_alias */1 :
            const pat1 = map_pattern(list._0);
            pat_desc = {
              TAG: /* Tpat_alias */1,
              _0: pat1,
              _1: list._1,
              _2: list._2
            };
            break;
        case /* Tpat_tuple */3 :
            pat_desc = {
              TAG: /* Tpat_tuple */3,
              _0: Stdlib__List.map(map_pattern, list._0)
            };
            break;
        case /* Tpat_construct */4 :
            pat_desc = {
              TAG: /* Tpat_construct */4,
              _0: list._0,
              _1: list._1,
              _2: Stdlib__List.map(map_pattern, list._2)
            };
            break;
        case /* Tpat_variant */5 :
            const pato = list._1;
            const pato$1 = pato !== undefined ? map_pattern(pato) : pato;
            pat_desc = {
              TAG: /* Tpat_variant */5,
              _0: list._0,
              _1: pato$1,
              _2: list._2
            };
            break;
        case /* Tpat_record */6 :
            pat_desc = {
              TAG: /* Tpat_record */6,
              _0: Stdlib__List.map((function (param) {
                      return [
                              param[0],
                              param[1],
                              map_pattern(param[2])
                            ];
                    }), list._0),
              _1: list._1
            };
            break;
        case /* Tpat_array */7 :
            pat_desc = {
              TAG: /* Tpat_array */7,
              _0: Stdlib__List.map(map_pattern, list._0)
            };
            break;
        case /* Tpat_or */8 :
            pat_desc = {
              TAG: /* Tpat_or */8,
              _0: map_pattern(list._0),
              _1: map_pattern(list._1),
              _2: list._2
            };
            break;
        case /* Tpat_lazy */9 :
            pat_desc = {
              TAG: /* Tpat_lazy */9,
              _0: map_pattern(list._0)
            };
            break;
        default:
          pat_desc = pat$1.pat_desc;
      }
    }
    const pat_extra = Stdlib__List.map(map_pat_extra, pat$1.pat_extra);
    return Curry._1(funarg.leave_pattern, {
                pat_desc: pat_desc,
                pat_loc: pat$1.pat_loc,
                pat_extra: pat_extra,
                pat_type: pat$1.pat_type,
                pat_env: pat$1.pat_env,
                pat_attributes: pat$1.pat_attributes
              });
  };
  const map_class_field = function (cf) {
    const cf$1 = Curry._1(funarg.enter_class_field, cf);
    const exp = cf$1.cf_desc;
    let cf_desc;
    switch (exp.TAG | 0) {
      case /* Tcf_inherit */0 :
          cf_desc = {
            TAG: /* Tcf_inherit */0,
            _0: exp._0,
            _1: map_class_expr(exp._1),
            _2: exp._2,
            _3: exp._3,
            _4: exp._4
          };
          break;
      case /* Tcf_val */1 :
          const cty = exp._3;
          const ident = exp._2;
          const mut = exp._1;
          const lab = exp._0;
          cf_desc = cty.TAG === /* Tcfk_virtual */0 ? ({
                TAG: /* Tcf_val */1,
                _0: lab,
                _1: mut,
                _2: ident,
                _3: {
                  TAG: /* Tcfk_virtual */0,
                  _0: map_core_type(cty._0)
                },
                _4: exp._4
              }) : ({
                TAG: /* Tcf_val */1,
                _0: lab,
                _1: mut,
                _2: ident,
                _3: {
                  TAG: /* Tcfk_concrete */1,
                  _0: cty._0,
                  _1: map_expression(cty._1)
                },
                _4: exp._4
              });
          break;
      case /* Tcf_method */2 :
          const cty$1 = exp._2;
          const priv = exp._1;
          const lab$1 = exp._0;
          cf_desc = cty$1.TAG === /* Tcfk_virtual */0 ? ({
                TAG: /* Tcf_method */2,
                _0: lab$1,
                _1: priv,
                _2: {
                  TAG: /* Tcfk_virtual */0,
                  _0: map_core_type(cty$1._0)
                }
              }) : ({
                TAG: /* Tcf_method */2,
                _0: lab$1,
                _1: priv,
                _2: {
                  TAG: /* Tcfk_concrete */1,
                  _0: cty$1._0,
                  _1: map_expression(cty$1._1)
                }
              });
          break;
      case /* Tcf_constraint */3 :
          cf_desc = {
            TAG: /* Tcf_constraint */3,
            _0: map_core_type(exp._0),
            _1: map_core_type(exp._1)
          };
          break;
      case /* Tcf_initializer */4 :
          cf_desc = {
            TAG: /* Tcf_initializer */4,
            _0: map_expression(exp._0)
          };
          break;
      case /* Tcf_attribute */5 :
          cf_desc = exp;
          break;
      
    }
    return Curry._1(funarg.leave_class_field, {
                cf_desc: cf_desc,
                cf_loc: cf$1.cf_loc,
                cf_attributes: cf$1.cf_attributes
              });
  };
  const map_class_expr = function (cexpr) {
    const cexpr$1 = Curry._1(funarg.enter_class_expr, cexpr);
    const clstr = cexpr$1.cl_desc;
    let cl_desc;
    switch (clstr.TAG | 0) {
      case /* Tcl_ident */0 :
          cl_desc = {
            TAG: /* Tcl_ident */0,
            _0: clstr._0,
            _1: clstr._1,
            _2: Stdlib__List.map(map_core_type, clstr._2)
          };
          break;
      case /* Tcl_structure */1 :
          cl_desc = {
            TAG: /* Tcl_structure */1,
            _0: map_class_structure(clstr._0)
          };
          break;
      case /* Tcl_fun */2 :
          cl_desc = {
            TAG: /* Tcl_fun */2,
            _0: clstr._0,
            _1: map_pattern(clstr._1),
            _2: Stdlib__List.map((function (param) {
                    return [
                            param[0],
                            param[1],
                            map_expression(param[2])
                          ];
                  }), clstr._2),
            _3: map_class_expr(clstr._3),
            _4: clstr._4
          };
          break;
      case /* Tcl_apply */3 :
          cl_desc = {
            TAG: /* Tcl_apply */3,
            _0: map_class_expr(clstr._0),
            _1: Stdlib__List.map((function (param) {
                    return [
                            param[0],
                            may_map(map_expression, param[1]),
                            param[2]
                          ];
                  }), clstr._1)
          };
          break;
      case /* Tcl_let */4 :
          const rec_flat = clstr._0;
          cl_desc = {
            TAG: /* Tcl_let */4,
            _0: rec_flat,
            _1: Stdlib__List.map(map_binding, clstr._1),
            _2: Stdlib__List.map((function (param) {
                    return [
                            param[0],
                            param[1],
                            map_expression(param[2])
                          ];
                  }), clstr._2),
            _3: map_class_expr(clstr._3)
          };
          break;
      case /* Tcl_constraint */5 :
          const clty = clstr._1;
          const cl = clstr._0;
          cl_desc = clty !== undefined ? ({
                TAG: /* Tcl_constraint */5,
                _0: map_class_expr(cl),
                _1: map_class_type(clty),
                _2: clstr._2,
                _3: clstr._3,
                _4: clstr._4
              }) : ({
                TAG: /* Tcl_constraint */5,
                _0: map_class_expr(cl),
                _1: undefined,
                _2: clstr._2,
                _3: clstr._3,
                _4: clstr._4
              });
          break;
      
    }
    return Curry._1(funarg.leave_class_expr, {
                cl_desc: cl_desc,
                cl_loc: cexpr$1.cl_loc,
                cl_type: cexpr$1.cl_type,
                cl_env: cexpr$1.cl_env,
                cl_attributes: cexpr$1.cl_attributes
              });
  };
  const map_exp_extra = function (exp_extra) {
    const attrs = exp_extra[2];
    const loc = exp_extra[1];
    const desc = exp_extra[0];
    switch (desc.TAG | 0) {
      case /* Texp_constraint */0 :
          return [
                  {
                    TAG: /* Texp_constraint */0,
                    _0: map_core_type(desc._0)
                  },
                  loc,
                  attrs
                ];
      case /* Texp_coerce */1 :
          const ct1 = desc._0;
          if (ct1 !== undefined) {
            return [
                    {
                      TAG: /* Texp_coerce */1,
                      _0: map_core_type(ct1),
                      _1: map_core_type(desc._1)
                    },
                    loc,
                    attrs
                  ];
          } else {
            return [
                    {
                      TAG: /* Texp_coerce */1,
                      _0: undefined,
                      _1: map_core_type(desc._1)
                    },
                    loc,
                    attrs
                  ];
          }
      case /* Texp_poly */3 :
          const ct = desc._0;
          if (ct !== undefined) {
            return [
                    {
                      TAG: /* Texp_poly */3,
                      _0: map_core_type(ct)
                    },
                    loc,
                    attrs
                  ];
          } else {
            return exp_extra;
          }
      case /* Texp_open */2 :
      case /* Texp_newtype */4 :
          return exp_extra;
      
    }
  };
  const map_binding = function (vb) {
    return {
            vb_pat: map_pattern(vb.vb_pat),
            vb_expr: map_expression(vb.vb_expr),
            vb_attributes: vb.vb_attributes,
            vb_loc: vb.vb_loc
          };
  };
  const map_class_structure = function (cs) {
    const cs$1 = Curry._1(funarg.enter_class_structure, cs);
    const cstr_self = map_pattern(cs$1.cstr_self);
    const cstr_fields = Stdlib__List.map(map_class_field, cs$1.cstr_fields);
    return Curry._1(funarg.leave_class_structure, {
                cstr_self: cstr_self,
                cstr_fields: cstr_fields,
                cstr_type: cs$1.cstr_type,
                cstr_meths: cs$1.cstr_meths
              });
  };
  const map_constructor_declaration = function (cd) {
    return {
            cd_id: cd.cd_id,
            cd_name: cd.cd_name,
            cd_args: Stdlib__List.map(map_core_type, cd.cd_args),
            cd_res: may_map(map_core_type, cd.cd_res),
            cd_loc: cd.cd_loc,
            cd_attributes: cd.cd_attributes
          };
  };
  const map_class_type = function (ct) {
    const ct$1 = Curry._1(funarg.enter_class_type, ct);
    const csg = ct$1.cltyp_desc;
    let cltyp_desc;
    switch (csg.TAG | 0) {
      case /* Tcty_constr */0 :
          cltyp_desc = {
            TAG: /* Tcty_constr */0,
            _0: csg._0,
            _1: csg._1,
            _2: Stdlib__List.map(map_core_type, csg._2)
          };
          break;
      case /* Tcty_signature */1 :
          cltyp_desc = {
            TAG: /* Tcty_signature */1,
            _0: map_class_signature(csg._0)
          };
          break;
      case /* Tcty_arrow */2 :
          cltyp_desc = {
            TAG: /* Tcty_arrow */2,
            _0: csg._0,
            _1: map_core_type(csg._1),
            _2: map_class_type(csg._2)
          };
          break;
      
    }
    return Curry._1(funarg.leave_class_type, {
                cltyp_desc: cltyp_desc,
                cltyp_type: ct$1.cltyp_type,
                cltyp_env: ct$1.cltyp_env,
                cltyp_loc: ct$1.cltyp_loc,
                cltyp_attributes: ct$1.cltyp_attributes
              });
  };
  const map_signature_item = function (item) {
    const item$1 = Curry._1(funarg.enter_signature_item, item);
    const vd = item$1.sig_desc;
    let sig_desc;
    switch (vd.TAG | 0) {
      case /* Tsig_value */0 :
          sig_desc = {
            TAG: /* Tsig_value */0,
            _0: map_value_description(vd._0)
          };
          break;
      case /* Tsig_type */1 :
          sig_desc = {
            TAG: /* Tsig_type */1,
            _0: Stdlib__List.map(map_type_declaration, vd._0)
          };
          break;
      case /* Tsig_typext */2 :
          sig_desc = {
            TAG: /* Tsig_typext */2,
            _0: map_type_extension(vd._0)
          };
          break;
      case /* Tsig_exception */3 :
          sig_desc = {
            TAG: /* Tsig_exception */3,
            _0: map_extension_constructor(vd._0)
          };
          break;
      case /* Tsig_module */4 :
          const md = vd._0;
          sig_desc = {
            TAG: /* Tsig_module */4,
            _0: {
              md_id: md.md_id,
              md_name: md.md_name,
              md_type: map_module_type(md.md_type),
              md_attributes: md.md_attributes,
              md_loc: md.md_loc
            }
          };
          break;
      case /* Tsig_recmodule */5 :
          sig_desc = {
            TAG: /* Tsig_recmodule */5,
            _0: Stdlib__List.map((function (md) {
                    return {
                            md_id: md.md_id,
                            md_name: md.md_name,
                            md_type: map_module_type(md.md_type),
                            md_attributes: md.md_attributes,
                            md_loc: md.md_loc
                          };
                  }), vd._0)
          };
          break;
      case /* Tsig_modtype */6 :
          sig_desc = {
            TAG: /* Tsig_modtype */6,
            _0: map_module_type_declaration(vd._0)
          };
          break;
      case /* Tsig_open */7 :
          sig_desc = item$1.sig_desc;
          break;
      case /* Tsig_include */8 :
          const incl = vd._0;
          sig_desc = {
            TAG: /* Tsig_include */8,
            _0: {
              incl_mod: map_module_type(incl.incl_mod),
              incl_type: incl.incl_type,
              incl_loc: incl.incl_loc,
              incl_attributes: incl.incl_attributes
            }
          };
          break;
      case /* Tsig_class */9 :
          sig_desc = {
            TAG: /* Tsig_class */9,
            _0: Stdlib__List.map(map_class_description, vd._0)
          };
          break;
      case /* Tsig_class_type */10 :
          sig_desc = {
            TAG: /* Tsig_class_type */10,
            _0: Stdlib__List.map(map_class_type_declaration, vd._0)
          };
          break;
      case /* Tsig_attribute */11 :
          sig_desc = vd;
          break;
      
    }
    return Curry._1(funarg.leave_signature_item, {
                sig_desc: sig_desc,
                sig_env: item$1.sig_env,
                sig_loc: item$1.sig_loc
              });
  };
  const map_signature = function (sg) {
    const sg$1 = Curry._1(funarg.enter_signature, sg);
    const sig_items = Stdlib__List.map(map_signature_item, sg$1.sig_items);
    return Curry._1(funarg.leave_signature, {
                sig_items: sig_items,
                sig_type: sg$1.sig_type,
                sig_final_env: sg$1.sig_final_env
              });
  };
  const map_with_constraint = function (cstr) {
    const cstr$1 = Curry._1(funarg.enter_with_constraint, cstr);
    let tmp;
    switch (cstr$1.TAG | 0) {
      case /* Twith_type */0 :
          tmp = {
            TAG: /* Twith_type */0,
            _0: map_type_declaration(cstr$1._0)
          };
          break;
      case /* Twith_typesubst */2 :
          tmp = {
            TAG: /* Twith_typesubst */2,
            _0: map_type_declaration(cstr$1._0)
          };
          break;
      case /* Twith_module */1 :
      case /* Twith_modsubst */3 :
          tmp = cstr$1;
          break;
      
    }
    return Curry._1(funarg.leave_with_constraint, tmp);
  };
  const map_class_type_field = function (ctf) {
    const ctf$1 = Curry._1(funarg.enter_class_type_field, ctf);
    const ct = ctf$1.ctf_desc;
    let ctf_desc;
    switch (ct.TAG | 0) {
      case /* Tctf_inherit */0 :
          ctf_desc = {
            TAG: /* Tctf_inherit */0,
            _0: map_class_type(ct._0)
          };
          break;
      case /* Tctf_val */1 :
          const match = ct._0;
          ctf_desc = {
            TAG: /* Tctf_val */1,
            _0: [
              match[0],
              match[1],
              match[2],
              map_core_type(match[3])
            ]
          };
          break;
      case /* Tctf_method */2 :
          const match$1 = ct._0;
          ctf_desc = {
            TAG: /* Tctf_method */2,
            _0: [
              match$1[0],
              match$1[1],
              match$1[2],
              map_core_type(match$1[3])
            ]
          };
          break;
      case /* Tctf_constraint */3 :
          const match$2 = ct._0;
          ctf_desc = {
            TAG: /* Tctf_constraint */3,
            _0: [
              map_core_type(match$2[0]),
              map_core_type(match$2[1])
            ]
          };
          break;
      case /* Tctf_attribute */4 :
          ctf_desc = ct;
          break;
      
    }
    return Curry._1(funarg.leave_class_type_field, {
                ctf_desc: ctf_desc,
                ctf_loc: ctf$1.ctf_loc,
                ctf_attributes: ctf$1.ctf_attributes
              });
  };
  const map_pat_extra = function (pat_extra) {
    const ct = pat_extra[0];
    if (typeof ct === "number" || ct.TAG !== /* Tpat_constraint */0) {
      return pat_extra;
    } else {
      return [
              {
                TAG: /* Tpat_constraint */0,
                _0: map_core_type(ct._0)
              },
              pat_extra[1],
              pat_extra[2]
            ];
    }
  };
  const map_class_signature = function (cs) {
    const cs$1 = Curry._1(funarg.enter_class_signature, cs);
    const csig_self = map_core_type(cs$1.csig_self);
    const csig_fields = Stdlib__List.map(map_class_type_field, cs$1.csig_fields);
    return Curry._1(funarg.leave_class_signature, {
                csig_self: csig_self,
                csig_fields: csig_fields,
                csig_type: cs$1.csig_type
              });
  };
  const map_module_binding = function (x) {
    return {
            mb_id: x.mb_id,
            mb_name: x.mb_name,
            mb_expr: map_module_expr(x.mb_expr),
            mb_attributes: x.mb_attributes,
            mb_loc: x.mb_loc
          };
  };
  const map_class_declaration = function (cd) {
    const cd$1 = Curry._1(funarg.enter_class_declaration, cd);
    const ci_params = Stdlib__List.map(map_type_parameter, cd$1.ci_params);
    const ci_expr = map_class_expr(cd$1.ci_expr);
    return Curry._1(funarg.leave_class_declaration, {
                ci_virt: cd$1.ci_virt,
                ci_params: ci_params,
                ci_id_name: cd$1.ci_id_name,
                ci_id_class: cd$1.ci_id_class,
                ci_id_class_type: cd$1.ci_id_class_type,
                ci_id_object: cd$1.ci_id_object,
                ci_id_typesharp: cd$1.ci_id_typesharp,
                ci_expr: ci_expr,
                ci_decl: cd$1.ci_decl,
                ci_type_decl: cd$1.ci_type_decl,
                ci_loc: cd$1.ci_loc,
                ci_attributes: cd$1.ci_attributes
              });
  };
  const map_structure_item = function (item) {
    const item$1 = Curry._1(funarg.enter_structure_item, item);
    const vd = item$1.str_desc;
    let str_desc;
    switch (vd.TAG | 0) {
      case /* Tstr_eval */0 :
          str_desc = {
            TAG: /* Tstr_eval */0,
            _0: map_expression(vd._0),
            _1: vd._1
          };
          break;
      case /* Tstr_value */1 :
          const rec_flag = vd._0;
          str_desc = {
            TAG: /* Tstr_value */1,
            _0: rec_flag,
            _1: Stdlib__List.map(map_binding, vd._1)
          };
          break;
      case /* Tstr_primitive */2 :
          str_desc = {
            TAG: /* Tstr_primitive */2,
            _0: map_value_description(vd._0)
          };
          break;
      case /* Tstr_type */3 :
          str_desc = {
            TAG: /* Tstr_type */3,
            _0: Stdlib__List.map(map_type_declaration, vd._0)
          };
          break;
      case /* Tstr_typext */4 :
          str_desc = {
            TAG: /* Tstr_typext */4,
            _0: map_type_extension(vd._0)
          };
          break;
      case /* Tstr_exception */5 :
          str_desc = {
            TAG: /* Tstr_exception */5,
            _0: map_extension_constructor(vd._0)
          };
          break;
      case /* Tstr_module */6 :
          str_desc = {
            TAG: /* Tstr_module */6,
            _0: map_module_binding(vd._0)
          };
          break;
      case /* Tstr_recmodule */7 :
          const list = Stdlib__List.map(map_module_binding, vd._0);
          str_desc = {
            TAG: /* Tstr_recmodule */7,
            _0: list
          };
          break;
      case /* Tstr_modtype */8 :
          str_desc = {
            TAG: /* Tstr_modtype */8,
            _0: map_module_type_declaration(vd._0)
          };
          break;
      case /* Tstr_open */9 :
          str_desc = {
            TAG: /* Tstr_open */9,
            _0: vd._0
          };
          break;
      case /* Tstr_class */10 :
          const list$1 = Stdlib__List.map((function (param) {
                  return [
                          map_class_declaration(param[0]),
                          param[1],
                          param[2]
                        ];
                }), vd._0);
          str_desc = {
            TAG: /* Tstr_class */10,
            _0: list$1
          };
          break;
      case /* Tstr_class_type */11 :
          const list$2 = Stdlib__List.map((function (param) {
                  return [
                          param[0],
                          param[1],
                          map_class_type_declaration(param[2])
                        ];
                }), vd._0);
          str_desc = {
            TAG: /* Tstr_class_type */11,
            _0: list$2
          };
          break;
      case /* Tstr_include */12 :
          const incl = vd._0;
          str_desc = {
            TAG: /* Tstr_include */12,
            _0: {
              incl_mod: map_module_expr(incl.incl_mod),
              incl_type: incl.incl_type,
              incl_loc: incl.incl_loc,
              incl_attributes: incl.incl_attributes
            }
          };
          break;
      case /* Tstr_attribute */13 :
          str_desc = {
            TAG: /* Tstr_attribute */13,
            _0: vd._0
          };
          break;
      
    }
    return Curry._1(funarg.leave_structure_item, {
                str_desc: str_desc,
                str_loc: item$1.str_loc,
                str_env: item$1.str_env
              });
  };
  return {
          map_structure: map_structure,
          map_pattern: map_pattern,
          map_structure_item: map_structure_item,
          map_expression: map_expression,
          map_class_expr: map_class_expr,
          map_signature: map_signature,
          map_signature_item: map_signature_item,
          map_module_type: map_module_type
        };
}

let need_to_clear_env;

try {
  Caml_sys.caml_sys_getenv("OCAML_BINANNOT_WITHENV");
  need_to_clear_env = false;
}
catch (raw_exn$2){
  const exn$3 = Caml_js_exceptions.internalToOCamlException(raw_exn$2);
  if (exn$3.MEL_EXN_ID === Stdlib.Not_found) {
    need_to_clear_env = true;
  } else {
    throw new Caml_js_exceptions.MelangeError(exn$3.MEL_EXN_ID, exn$3);
  }
}

function leave_pattern(p) {
  return {
          pat_desc: p.pat_desc,
          pat_loc: p.pat_loc,
          pat_extra: p.pat_extra,
          pat_type: p.pat_type,
          pat_env: keep_only_summary(p.pat_env),
          pat_attributes: p.pat_attributes
        };
}

function leave_expression(e) {
  const exp_extra = Stdlib__List.map((function (exp_extra) {
          const match = exp_extra[0];
          if (match.TAG === /* Texp_open */2) {
            return [
                    {
                      TAG: /* Texp_open */2,
                      _0: match._0,
                      _1: match._1,
                      _2: match._2,
                      _3: keep_only_summary(match._3)
                    },
                    exp_extra[1],
                    exp_extra[2]
                  ];
          } else {
            return exp_extra;
          }
        }), e.exp_extra);
  return {
          exp_desc: e.exp_desc,
          exp_loc: e.exp_loc,
          exp_extra: exp_extra,
          exp_type: e.exp_type,
          exp_env: keep_only_summary(e.exp_env),
          exp_attributes: e.exp_attributes
        };
}

function leave_class_expr(c) {
  return {
          cl_desc: c.cl_desc,
          cl_loc: c.cl_loc,
          cl_type: c.cl_type,
          cl_env: keep_only_summary(c.cl_env),
          cl_attributes: c.cl_attributes
        };
}

function leave_module_expr(m) {
  return {
          mod_desc: m.mod_desc,
          mod_loc: m.mod_loc,
          mod_type: m.mod_type,
          mod_env: keep_only_summary(m.mod_env),
          mod_attributes: m.mod_attributes
        };
}

function leave_structure(s) {
  return {
          str_items: s.str_items,
          str_type: s.str_type,
          str_final_env: keep_only_summary(s.str_final_env)
        };
}

function leave_structure_item(str) {
  return {
          str_desc: str.str_desc,
          str_loc: str.str_loc,
          str_env: keep_only_summary(str.str_env)
        };
}

function leave_module_type(m) {
  return {
          mty_desc: m.mty_desc,
          mty_type: m.mty_type,
          mty_env: keep_only_summary(m.mty_env),
          mty_loc: m.mty_loc,
          mty_attributes: m.mty_attributes
        };
}

function leave_signature(s) {
  return {
          sig_items: s.sig_items,
          sig_type: s.sig_type,
          sig_final_env: keep_only_summary(s.sig_final_env)
        };
}

function leave_signature_item(s) {
  return {
          sig_desc: s.sig_desc,
          sig_env: keep_only_summary(s.sig_env),
          sig_loc: s.sig_loc
        };
}

function leave_core_type(c) {
  return {
          ctyp_desc: c.ctyp_desc,
          ctyp_type: c.ctyp_type,
          ctyp_env: keep_only_summary(c.ctyp_env),
          ctyp_loc: c.ctyp_loc,
          ctyp_attributes: c.ctyp_attributes
        };
}

function leave_class_type(c) {
  return {
          cltyp_desc: c.cltyp_desc,
          cltyp_type: c.cltyp_type,
          cltyp_env: keep_only_summary(c.cltyp_env),
          cltyp_loc: c.cltyp_loc,
          cltyp_attributes: c.cltyp_attributes
        };
}

const ClearEnv = Curry._1(TypedtreeMap_MakeMap, {
      enter_structure: enter_structure,
      enter_value_description: enter_value_description,
      enter_type_declaration: enter_type_declaration,
      enter_type_extension: enter_type_extension,
      enter_extension_constructor: enter_extension_constructor,
      enter_pattern: enter_pattern,
      enter_expression: enter_expression,
      enter_package_type: enter_package_type,
      enter_signature: enter_signature,
      enter_signature_item: enter_signature_item,
      enter_module_type_declaration: enter_module_type_declaration,
      enter_module_type: enter_module_type,
      enter_module_expr: enter_module_expr,
      enter_with_constraint: enter_with_constraint,
      enter_class_expr: enter_class_expr,
      enter_class_signature: enter_class_signature,
      enter_class_declaration: enter_class_declaration,
      enter_class_description: enter_class_description,
      enter_class_type_declaration: enter_class_type_declaration,
      enter_class_type: enter_class_type,
      enter_class_type_field: enter_class_type_field,
      enter_core_type: enter_core_type,
      enter_class_structure: enter_class_structure,
      enter_class_field: enter_class_field,
      enter_structure_item: enter_structure_item,
      leave_structure: leave_structure,
      leave_value_description: leave_value_description,
      leave_type_declaration: leave_type_declaration,
      leave_type_extension: leave_type_extension,
      leave_extension_constructor: leave_extension_constructor,
      leave_pattern: leave_pattern,
      leave_expression: leave_expression,
      leave_package_type: leave_package_type,
      leave_signature: leave_signature,
      leave_signature_item: leave_signature_item,
      leave_module_type_declaration: leave_module_type_declaration,
      leave_module_type: leave_module_type,
      leave_module_expr: leave_module_expr,
      leave_with_constraint: leave_with_constraint,
      leave_class_expr: leave_class_expr,
      leave_class_signature: leave_class_signature,
      leave_class_declaration: leave_class_declaration,
      leave_class_description: leave_class_description,
      leave_class_type_declaration: leave_class_type_declaration,
      leave_class_type: leave_class_type,
      leave_class_type_field: leave_class_type_field,
      leave_core_type: leave_core_type,
      leave_class_structure: leave_class_structure,
      leave_class_field: leave_class_field,
      leave_structure_item: leave_structure_item
    });

function clear_part(p) {
  switch (p.TAG | 0) {
    case /* Partial_structure */0 :
        return {
                TAG: /* Partial_structure */0,
                _0: Curry._1(ClearEnv.map_structure, p._0)
              };
    case /* Partial_structure_item */1 :
        return {
                TAG: /* Partial_structure_item */1,
                _0: Curry._1(ClearEnv.map_structure_item, p._0)
              };
    case /* Partial_expression */2 :
        return {
                TAG: /* Partial_expression */2,
                _0: Curry._1(ClearEnv.map_expression, p._0)
              };
    case /* Partial_pattern */3 :
        return {
                TAG: /* Partial_pattern */3,
                _0: Curry._1(ClearEnv.map_pattern, p._0)
              };
    case /* Partial_class_expr */4 :
        return {
                TAG: /* Partial_class_expr */4,
                _0: Curry._1(ClearEnv.map_class_expr, p._0)
              };
    case /* Partial_signature */5 :
        return {
                TAG: /* Partial_signature */5,
                _0: Curry._1(ClearEnv.map_signature, p._0)
              };
    case /* Partial_signature_item */6 :
        return {
                TAG: /* Partial_signature_item */6,
                _0: Curry._1(ClearEnv.map_signature_item, p._0)
              };
    case /* Partial_module_type */7 :
        return {
                TAG: /* Partial_module_type */7,
                _0: Curry._1(ClearEnv.map_module_type, p._0)
              };
    
  }
}

function clear_env(binary_annots) {
  if (!need_to_clear_env) {
    return binary_annots;
  }
  switch (binary_annots.TAG | 0) {
    case /* Packed */0 :
        return binary_annots;
    case /* Implementation */1 :
        return {
                TAG: /* Implementation */1,
                _0: Curry._1(ClearEnv.map_structure, binary_annots._0)
              };
    case /* Interface */2 :
        return {
                TAG: /* Interface */2,
                _0: Curry._1(ClearEnv.map_signature, binary_annots._0)
              };
    case /* Partial_implementation */3 :
        return {
                TAG: /* Partial_implementation */3,
                _0: Stdlib__Array.map(clear_part, binary_annots._0)
              };
    case /* Partial_interface */4 :
        return {
                TAG: /* Partial_interface */4,
                _0: Stdlib__Array.map(clear_part, binary_annots._0)
              };
    
  }
}

function output_cmt(oc, cmt) {
  Stdlib.output_string(oc, "Caml2012T004");
  Caml_external_polyfill.resolve("caml_output_value")(oc, cmt, /* [] */0);
}

const saved_types = {
  contents: /* [] */0
};

const value_deps = {
  contents: /* [] */0
};

function clear(param) {
  saved_types.contents = /* [] */0;
  value_deps.contents = /* [] */0;
}

function add_saved_type(b) {
  saved_types.contents = {
    hd: b,
    tl: saved_types.contents
  };
}

function record_value_dependency(vd1, vd2) {
  if (Caml_obj.caml_notequal(vd1.val_loc, vd2.val_loc)) {
    value_deps.contents = {
      hd: [
        vd1,
        vd2
      ],
      tl: value_deps.contents
    };
    return ;
  }
  
}

function save_cmt(filename, modname, binary_annots, sourcefile, initial_env, sg) {
  if (binary_annotations.contents && !print_types.contents) {
    const imports$1 = imports(undefined);
    const oc = Stdlib.open_out_bin(filename);
    let this_crc;
    if (sg !== undefined) {
      const cmi_cmi_flags = recursive_types.contents ? ({
            hd: /* Rectypes */0,
            tl: /* [] */0
          }) : /* [] */0;
      const cmi = {
        cmi_name: modname,
        cmi_sign: sg,
        cmi_crcs: imports$1,
        cmi_flags: cmi_cmi_flags
      };
      this_crc = output_cmi(filename, oc, cmi);
    } else {
      this_crc = undefined;
    }
    const source_digest = may_map(Stdlib__Digest.file, sourcefile);
    const cmt_cmt_annots = clear_env(binary_annots);
    const cmt_cmt_value_dependencies = value_deps.contents;
    const cmt_cmt_comments = Stdlib__List.rev(comment_list.contents);
    const cmt_cmt_args = Caml_sys.caml_sys_argv(0);
    const cmt_cmt_builddir = Caml_sys.caml_sys_getcwd(undefined);
    const cmt_cmt_loadpath = load_path.contents;
    const cmt_cmt_initial_env = need_to_clear_env ? keep_only_summary(initial_env) : initial_env;
    const cmt_cmt_imports = Stdlib__List.sort(Caml_obj.caml_compare, imports$1);
    const cmt = {
      cmt_modname: modname,
      cmt_annots: cmt_cmt_annots,
      cmt_value_dependencies: cmt_cmt_value_dependencies,
      cmt_comments: cmt_cmt_comments,
      cmt_args: cmt_cmt_args,
      cmt_sourcefile: sourcefile,
      cmt_builddir: cmt_cmt_builddir,
      cmt_loadpath: cmt_cmt_loadpath,
      cmt_source_digest: source_digest,
      cmt_initial_env: cmt_cmt_initial_env,
      cmt_imports: cmt_cmt_imports,
      cmt_interface_digest: this_crc,
      cmt_use_summaries: need_to_clear_env
    };
    output_cmt(oc, cmt);
    Caml_io.caml_ml_flush(oc);
    Caml_external_polyfill.resolve("caml_ml_close_channel")(oc);
    let exit = 0;
    let cmd;
    try {
      cmd = Caml_sys.caml_sys_getenv("BS_CMT_POST_PROCESS_CMD");
      exit = 1;
    }
    catch (exn){
      
    }
    if (exit === 1) {
      Caml_sys.caml_sys_system_command(cmd + (" -cmt-add " + (filename + (
                sourcefile !== undefined ? ":" + sourcefile : ""
              ))));
    }
    
  }
  clear(undefined);
}

const Unify = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Unify");

const Tags = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Tags");

register_error_of_exn(function (param) {
      if (param.MEL_EXN_ID === Tags) {
        return Curry._2(errorf(in_file(input_name.contents), undefined, undefined, /* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "In this program,",
                          _1: {
                            TAG: /* Formatting_lit */17,
                            _0: {
                              TAG: /* Break */0,
                              _0: "@ ",
                              _1: 1,
                              _2: 0
                            },
                            _1: {
                              TAG: /* String_literal */11,
                              _0: "variant constructors",
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@ ",
                                  _1: 1,
                                  _2: 0
                                },
                                _1: {
                                  TAG: /* Char_literal */12,
                                  _0: /* '`' */96,
                                  _1: {
                                    TAG: /* String */2,
                                    _0: /* No_padding */0,
                                    _1: {
                                      TAG: /* String_literal */11,
                                      _0: " and `",
                                      _1: {
                                        TAG: /* String */2,
                                        _0: /* No_padding */0,
                                        _1: {
                                          TAG: /* Formatting_lit */17,
                                          _0: {
                                            TAG: /* Break */0,
                                            _0: "@ ",
                                            _1: 1,
                                            _2: 0
                                          },
                                          _1: {
                                            TAG: /* String_literal */11,
                                            _0: "have the same hash value.",
                                            _1: {
                                              TAG: /* Formatting_lit */17,
                                              _0: {
                                                TAG: /* Break */0,
                                                _0: "@ ",
                                                _1: 1,
                                                _2: 0
                                              },
                                              _1: {
                                                TAG: /* String_literal */11,
                                                _0: "Change one of them.",
                                                _1: /* End_of_format */0
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "In this program,@ variant constructors@ `%s and `%s@ have the same hash value.@ Change one of them."
                      }), param._1, param._2);
      }
      
    });

const Subtype = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Subtype");

const Cannot_expand = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Cannot_expand");

const Recursive_abbrev = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Recursive_abbrev");

const Unification_recursive_abbrev = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Unification_recursive_abbrev");

const current_level = {
  contents: 0
};

const nongen_level = {
  contents: 0
};

const global_level = {
  contents: 1
};

const saved_level = {
  contents: /* [] */0
};

function init_def(level) {
  current_level.contents = level;
  nongen_level.contents = level;
}

function begin_def(param) {
  saved_level.contents = {
    hd: [
      current_level.contents,
      nongen_level.contents
    ],
    tl: saved_level.contents
  };
  current_level.contents = current_level.contents + 1 | 0;
  nongen_level.contents = current_level.contents;
}

function begin_class_def(param) {
  saved_level.contents = {
    hd: [
      current_level.contents,
      nongen_level.contents
    ],
    tl: saved_level.contents
  };
  current_level.contents = current_level.contents + 1 | 0;
}

function raise_nongen_level(param) {
  saved_level.contents = {
    hd: [
      current_level.contents,
      nongen_level.contents
    ],
    tl: saved_level.contents
  };
  nongen_level.contents = current_level.contents;
}

function end_def(param) {
  const match = Stdlib__List.hd(saved_level.contents);
  saved_level.contents = Stdlib__List.tl(saved_level.contents);
  current_level.contents = match[0];
  nongen_level.contents = match[1];
}

function reset_global_level(param) {
  global_level.contents = current_level.contents + 1 | 0;
}

function increase_global_level(param) {
  const gl = global_level.contents;
  global_level.contents = current_level.contents;
  return gl;
}

function is_object_type(path) {
  let name;
  switch (path.TAG | 0) {
    case /* Pident */0 :
        name = path._0.name;
        break;
    case /* Pdot */1 :
        name = path._1;
        break;
    case /* Papply */2 :
        throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                  MEL_EXN_ID: "Assert_failure",
                  _1: [
                    "jscomp/test/ocaml_typedtree_test.ml",
                    30161,
                    23
                  ]
                });
    
  }
  return Caml_string.get(name, 0) === /* '#' */35;
}

const trace_gadt_instances = {
  contents: false
};

function check_trace_gadt_instances(env) {
  if (!trace_gadt_instances.contents && env.local_constraints) {
    trace_gadt_instances.contents = true;
    cleanup_abbrev(undefined);
    return true;
  } else {
    return false;
  }
}

function reset_trace_gadt_instances(b) {
  if (b) {
    trace_gadt_instances.contents = false;
    return ;
  }
  
}

function wrap_trace_gadt_instances(env, f, x) {
  const b = check_trace_gadt_instances(env);
  const y = Curry._1(f, x);
  reset_trace_gadt_instances(b);
  return y;
}

const simple_abbrevs = {
  contents: /* Mnil */0
};

function proper_abbrevs(path, tl, abbrev) {
  if (Caml_obj.caml_notequal(tl, /* [] */0) || trace_gadt_instances.contents || principal.contents || is_object_type(path)) {
    return abbrev;
  } else {
    return simple_abbrevs;
  }
}

function newvar(name, param) {
  return newty2(current_level.contents, {
              TAG: /* Tvar */0,
              _0: name
            });
}

function new_global_var(name, param) {
  return newty2(global_level.contents, {
              TAG: /* Tvar */0,
              _0: name
            });
}

function newobj(fields) {
  return newty2(current_level.contents, {
              TAG: /* Tobject */4,
              _0: fields,
              _1: {
                contents: undefined
              }
            });
}

function newconstr(path, tyl) {
  return newty2(current_level.contents, {
              TAG: /* Tconstr */3,
              _0: path,
              _1: tyl,
              _2: {
                contents: /* Mnil */0
              }
            });
}

const none$2 = newty2(current_level.contents, {
      TAG: /* Ttuple */2,
      _0: /* [] */0
    });

function equal$4(param, param$1) {
  if (param[0] === param$1[0]) {
    return param[1] === param$1[1];
  } else {
    return false;
  }
}

function hash$1(param) {
  return param[0].id + Math.imul(93, param[1].id) | 0;
}

const TypePairs = Stdlib__Hashtbl.Make({
      equal: equal$4,
      hash: hash$1
    });

const umode = {
  contents: /* Expression */0
};

const generate_equations = {
  contents: false
};

const assume_injective = {
  contents: false
};

function set_mode_pattern(generate, injective, f) {
  const old_unification_mode = umode.contents;
  const old_gen = generate_equations.contents;
  const old_inj = assume_injective.contents;
  try {
    umode.contents = /* Pattern */1;
    generate_equations.contents = generate;
    assume_injective.contents = injective;
    const ret = Curry._1(f, undefined);
    umode.contents = old_unification_mode;
    generate_equations.contents = old_gen;
    assume_injective.contents = old_inj;
    return ret;
  }
  catch (e){
    umode.contents = old_unification_mode;
    generate_equations.contents = old_gen;
    assume_injective.contents = old_inj;
    throw new Caml_js_exceptions.MelangeError(e.MEL_EXN_ID, e);
  }
}

function in_current_module(param) {
  switch (param.TAG | 0) {
    case /* Pident */0 :
        return true;
    case /* Pdot */1 :
    case /* Papply */2 :
        return false;
    
  }
}

function in_pervasives(p) {
  if (!in_current_module(p)) {
    return false;
  }
  try {
    find_type_full(p, initial_safe_string)[0];
    return true;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return false;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function is_datatype(decl) {
  const match = decl.type_kind;
  if (typeof match === "number" && !match) {
    return false;
  } else {
    return true;
  }
}

function object_fields(ty) {
  const match = repr(ty).desc;
  if (typeof match === "number") {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                30296,
                27
              ]
            });
  }
  if (match.TAG === /* Tobject */4) {
    return match._0;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              30296,
              27
            ]
          });
}

function flatten_fields(ty) {
  const flatten = function (_l, _ty) {
    while(true) {
      const ty = _ty;
      const l = _l;
      const ty$1 = repr(ty);
      const match = ty$1.desc;
      if (typeof match === "number") {
        return [
                l,
                ty$1
              ];
      }
      if (match.TAG !== /* Tfield */5) {
        return [
                l,
                ty$1
              ];
      }
      _ty = match._3;
      _l = {
        hd: [
          match._0,
          match._1,
          match._2
        ],
        tl: l
      };
      continue ;
    };
  };
  const match = flatten(/* [] */0, ty);
  return [
          Stdlib__List.sort((function (param, param$1) {
                  return Caml.caml_string_compare(param[0], param$1[0]);
                }), match[0]),
          match[1]
        ];
}

function build_fields(level) {
  return function (param, param$1) {
    return Stdlib__List.fold_right((function (param, ty2) {
                  return newty2(level, {
                              TAG: /* Tfield */5,
                              _0: param[0],
                              _1: param[1],
                              _2: param[2],
                              _3: ty2
                            });
                }), param, param$1);
  };
}

function associate_fields(fields1, fields2) {
  let _p = /* [] */0;
  let _s = /* [] */0;
  let _s$p = /* [] */0;
  let _param = [
    fields1,
    fields2
  ];
  while(true) {
    const param = _param;
    const s$p = _s$p;
    const s = _s;
    const p = _p;
    const l = param[0];
    if (!param[1]) {
      return [
              Stdlib__List.rev(p),
              Stdlib.$at(Stdlib__List.rev(s), l),
              Stdlib__List.rev(s$p)
            ];
    }
    if (!l) {
      return [
              Stdlib__List.rev(p),
              Stdlib__List.rev(s),
              Stdlib.$at(Stdlib__List.rev(s$p), param[1])
            ];
    }
    const l$p = param[1];
    const match = l$p.hd;
    const n$p = match[0];
    const r = l.tl;
    const match$1 = l.hd;
    const t = match$1[2];
    const k = match$1[1];
    const n = match$1[0];
    if (Caml_obj.caml_equal(n, n$p)) {
      _param = [
        r,
        l$p.tl
      ];
      _p = {
        hd: [
          n,
          k,
          t,
          match[1],
          match[2]
        ],
        tl: p
      };
      continue ;
    }
    if (Caml_obj.caml_lessthan(n, n$p)) {
      _param = [
        r,
        l$p
      ];
      _s = {
        hd: [
          n,
          k,
          t
        ],
        tl: s
      };
      continue ;
    }
    _param = [
      l,
      l$p.tl
    ];
    _s$p = {
      hd: [
        n$p,
        match[1],
        match[2]
      ],
      tl: s$p
    };
    continue ;
  };
}

function object_row(_ty) {
  while(true) {
    const ty = _ty;
    const ty$1 = repr(ty);
    const match = ty$1.desc;
    if (typeof match === "number") {
      return ty$1;
    }
    switch (match.TAG | 0) {
      case /* Tobject */4 :
          _ty = match._0;
          continue ;
      case /* Tfield */5 :
          _ty = match._3;
          continue ;
      default:
        return ty$1;
    }
  };
}

function opened_object(ty) {
  const match = object_row(ty).desc;
  if (typeof match === "number") {
    return false;
  }
  switch (match.TAG | 0) {
    case /* Tvar */0 :
    case /* Tconstr */3 :
    case /* Tunivar */9 :
        return true;
    default:
      return false;
  }
}

function concrete_object(ty) {
  const match = object_row(ty).desc;
  if (typeof match === "number" || match.TAG !== /* Tvar */0) {
    return true;
  } else {
    return false;
  }
}

function close_object(ty) {
  const match = repr(ty).desc;
  if (typeof match === "number") {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                30363,
                25
              ]
            });
  }
  if (match.TAG === /* Tobject */4) {
    let _ty = match._0;
    while(true) {
      const ty$1 = _ty;
      const ty$2 = repr(ty$1);
      const match$1 = ty$2.desc;
      if (typeof match$1 === "number") {
        throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                  MEL_EXN_ID: "Assert_failure",
                  _1: [
                    "jscomp/test/ocaml_typedtree_test.ml",
                    30359,
                    30
                  ]
                });
      }
      switch (match$1.TAG | 0) {
        case /* Tvar */0 :
            return link_type(ty$2, newty2(ty$2.level, /* Tnil */0));
        case /* Tfield */5 :
            _ty = match$1._3;
            continue ;
        default:
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                    MEL_EXN_ID: "Assert_failure",
                    _1: [
                      "jscomp/test/ocaml_typedtree_test.ml",
                      30359,
                      30
                    ]
                  });
      }
    };
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              30363,
              25
            ]
          });
}

function row_variable(ty) {
  const match = repr(ty).desc;
  if (typeof match === "number") {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                30377,
                23
              ]
            });
  }
  if (match.TAG === /* Tobject */4) {
    let _ty = match._0;
    while(true) {
      const ty$1 = _ty;
      const ty$2 = repr(ty$1);
      const match$1 = ty$2.desc;
      if (typeof match$1 === "number") {
        throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                  MEL_EXN_ID: "Assert_failure",
                  _1: [
                    "jscomp/test/ocaml_typedtree_test.ml",
                    30373,
                    30
                  ]
                });
      }
      switch (match$1.TAG | 0) {
        case /* Tvar */0 :
            return ty$2;
        case /* Tfield */5 :
            _ty = match$1._3;
            continue ;
        default:
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                    MEL_EXN_ID: "Assert_failure",
                    _1: [
                      "jscomp/test/ocaml_typedtree_test.ml",
                      30373,
                      30
                    ]
                  });
      }
    };
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              30377,
              23
            ]
          });
}

function set_object_name(id, rv, params, ty) {
  const match = repr(ty).desc;
  if (typeof match === "number") {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                30387,
                6
              ]
            });
  }
  if (match.TAG === /* Tobject */4) {
    return set_name(match._1, [
                {
                  TAG: /* Pident */0,
                  _0: id
                },
                {
                  hd: rv,
                  tl: params
                }
              ]);
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              30387,
              6
            ]
          });
}

function hide_private_methods(ty) {
  const match = repr(ty).desc;
  if (typeof match === "number") {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                30409,
                6
              ]
            });
  }
  if (match.TAG === /* Tobject */4) {
    match._1.contents = undefined;
    const match$1 = flatten_fields(match._0);
    return Stdlib__List.iter((function (param) {
                  const r = field_kind_repr(param[1]);
                  if (typeof r === "number") {
                    return ;
                  } else {
                    return set_kind(r._0, /* Fabsent */1);
                  }
                }), match$1[0]);
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              30409,
              6
            ]
          });
}

function signature_of_class_type(_sign) {
  while(true) {
    const sign = _sign;
    switch (sign.TAG | 0) {
      case /* Cty_signature */1 :
          return sign._0;
      case /* Cty_constr */0 :
      case /* Cty_arrow */2 :
          _sign = sign._2;
          continue ;
      
    }
  };
}

function class_type_arity(_param) {
  while(true) {
    const param = _param;
    switch (param.TAG | 0) {
      case /* Cty_constr */0 :
          _param = param._2;
          continue ;
      case /* Cty_signature */1 :
          return 0;
      case /* Cty_arrow */2 :
          return 1 + class_type_arity(param._2) | 0;
      
    }
  };
}

function sort_row_fields(param) {
  return Stdlib__List.sort((function (param, param$1) {
                return Caml.caml_string_compare(param[0], param$1[0]);
              }), param);
}

function merge_row_fields(fi1, fi2) {
  let exit = 0;
  if (!fi1) {
    return [
            fi1,
            fi2,
            /* [] */0
          ];
  }
  if (!fi2) {
    return [
            fi1,
            fi2,
            /* [] */0
          ];
  }
  if (fi1.tl) {
    exit = 2;
  } else {
    if (!Stdlib__List.mem_assoc(fi1.hd[0], fi2)) {
      return [
              fi1,
              fi2,
              /* [] */0
            ];
    }
    exit = 2;
  }
  if (exit === 2 && !fi2.tl && !Stdlib__List.mem_assoc(fi2.hd[0], fi1)) {
    return [
            fi1,
            fi2,
            /* [] */0
          ];
  }
  let _r1 = /* [] */0;
  let _r2 = /* [] */0;
  let _pairs = /* [] */0;
  let _fi1 = sort_row_fields(fi1);
  let _fi2 = sort_row_fields(fi2);
  while(true) {
    const fi2$1 = _fi2;
    const fi1$1 = _fi1;
    const pairs = _pairs;
    const r2 = _r2;
    const r1 = _r1;
    if (!fi1$1) {
      return [
              Stdlib__List.rev(r1),
              Stdlib__List.rev_append(r2, fi2$1),
              pairs
            ];
    }
    if (!fi2$1) {
      return [
              Stdlib__List.rev_append(r1, fi1$1),
              Stdlib__List.rev(r2),
              pairs
            ];
    }
    const fi2$p = fi2$1.tl;
    const p2 = fi2$1.hd;
    const l2 = p2[0];
    const fi1$p = fi1$1.tl;
    const p1 = fi1$1.hd;
    const l1 = p1[0];
    if (Caml_obj.caml_equal(l1, l2)) {
      _fi2 = fi2$p;
      _fi1 = fi1$p;
      _pairs = {
        hd: [
          l1,
          p1[1],
          p2[1]
        ],
        tl: pairs
      };
      continue ;
    }
    if (Caml_obj.caml_lessthan(l1, l2)) {
      _fi1 = fi1$p;
      _r1 = {
        hd: p1,
        tl: r1
      };
      continue ;
    }
    _fi2 = fi2$p;
    _r2 = {
      hd: p2,
      tl: r2
    };
    continue ;
  };
}

function filter_row_fields(erase, param) {
  if (!param) {
    return /* [] */0;
  }
  const p = param.hd;
  const fi = filter_row_fields(erase, param.tl);
  const match = row_field_repr_aux(/* [] */0, p[1]);
  if (typeof match === "number") {
    return fi;
  } else if (match.TAG === /* Rpresent */0 || match._2 || !erase) {
    return {
            hd: p,
            tl: fi
          };
  } else {
    set_row_field(match._3, /* Rabsent */0);
    return fi;
  }
}

const Non_closed0 = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Non_closed0");

function closed_schema_rec(_ty) {
  while(true) {
    const ty = _ty;
    const ty$1 = repr(ty);
    if (ty$1.level < 0) {
      return ;
    }
    const level = ty$1.level;
    ty$1.level = pivot_level - level | 0;
    const row = ty$1.desc;
    if (typeof row === "number") {
      return iter_type_expr(closed_schema_rec, ty$1);
    }
    switch (row.TAG | 0) {
      case /* Tvar */0 :
          if (level !== 100000000) {
            throw new Caml_js_exceptions.MelangeError(Non_closed0, {
                      MEL_EXN_ID: Non_closed0
                    });
          }
          return iter_type_expr(closed_schema_rec, ty$1);
      case /* Tfield */5 :
          if (Caml_obj.caml_equal(field_kind_repr(row._1), /* Fpresent */0)) {
            closed_schema_rec(row._2);
          }
          _ty = row._3;
          continue ;
      case /* Tvariant */8 :
          const row$1 = row_repr_aux(/* [] */0, row._0);
          iter_row(closed_schema_rec, row$1);
          if (static_row(row$1)) {
            return ;
          }
          _ty = row$1.row_more;
          continue ;
      default:
        return iter_type_expr(closed_schema_rec, ty$1);
    }
  };
}

function closed_schema(ty) {
  try {
    closed_schema_rec(ty);
    unmark_type(ty);
    return true;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Non_closed0) {
      unmark_type(ty);
      return false;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

const Non_closed = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Non_closed");

const free_variables = {
  contents: /* [] */0
};

const really_closed = {
  contents: undefined
};

function free_vars_rec(_real, _ty) {
  while(true) {
    const ty = _ty;
    const real = _real;
    const ty$1 = repr(ty);
    if (ty$1.level < 0) {
      return ;
    }
    ty$1.level = pivot_level - ty$1.level | 0;
    const match = ty$1.desc;
    const match$1 = really_closed.contents;
    if (typeof match === "number") {
      return iter_type_expr((function (param) {
                    return free_vars_rec(true, param);
                  }), ty$1);
    }
    switch (match.TAG | 0) {
      case /* Tvar */0 :
          free_variables.contents = {
            hd: [
              ty$1,
              real
            ],
            tl: free_variables.contents
          };
          return ;
      case /* Tconstr */3 :
          if (match$1 === undefined) {
            return iter_type_expr((function (param) {
                          return free_vars_rec(true, param);
                        }), ty$1);
          }
          try {
            const match$2 = find_type_expansion(match._0, Caml_option.valFromOption(match$1));
            if (repr(match$2[1]).level !== 100000000) {
              free_variables.contents = {
                hd: [
                  ty$1,
                  real
                ],
                tl: free_variables.contents
              };
            }
            
          }
          catch (raw_exn){
            const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.MEL_EXN_ID !== Stdlib.Not_found) {
              throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
            }
            
          }
          return Stdlib__List.iter((function (param) {
                        return free_vars_rec(true, param);
                      }), match._1);
      case /* Tobject */4 :
          _ty = match._0;
          _real = false;
          continue ;
      case /* Tfield */5 :
          free_vars_rec(true, match._2);
          _ty = match._3;
          _real = false;
          continue ;
      case /* Tvariant */8 :
          const row = row_repr_aux(/* [] */0, match._0);
          iter_row((function (param) {
                  return free_vars_rec(true, param);
                }), row);
          if (static_row(row)) {
            return ;
          }
          _ty = row.row_more;
          _real = false;
          continue ;
      default:
        return iter_type_expr((function (param) {
                      return free_vars_rec(true, param);
                    }), ty$1);
    }
  };
}

function free_vars$1(env, ty) {
  free_variables.contents = /* [] */0;
  really_closed.contents = env;
  free_vars_rec(true, ty);
  const res = free_variables.contents;
  free_variables.contents = /* [] */0;
  really_closed.contents = undefined;
  return res;
}

function free_variables$1(env, ty) {
  const tl = Stdlib__List.map((function (prim) {
          return prim[0];
        }), free_vars$1(env, ty));
  unmark_type(ty);
  return tl;
}

function closed_type(ty) {
  const match = free_vars$1(undefined, ty);
  if (!match) {
    return ;
  }
  const match$1 = match.hd;
  throw new Caml_js_exceptions.MelangeError(Non_closed, {
            MEL_EXN_ID: Non_closed,
            _1: match$1[0],
            _2: match$1[1]
          });
}

function closed_parameterized_type(params, ty) {
  Stdlib__List.iter(mark_type, params);
  let ok;
  try {
    closed_type(ty);
    ok = true;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Non_closed) {
      ok = false;
    } else {
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  }
  Stdlib__List.iter(unmark_type, params);
  unmark_type(ty);
  return ok;
}

function closed_type_decl(decl) {
  try {
    Stdlib__List.iter(mark_type, decl.type_params);
    const v = decl.type_kind;
    if (typeof v === "number") {
      v === /* Type_abstract */0;
    } else if (v.TAG === /* Type_record */0) {
      Stdlib__List.iter((function (l) {
              closed_type(l.ld_type);
            }), v._0);
    } else {
      Stdlib__List.iter((function (param) {
              if (param.cd_res !== undefined) {
                return ;
              } else {
                return Stdlib__List.iter(closed_type, param.cd_args);
              }
            }), v._0);
    }
    const ty = decl.type_manifest;
    if (ty !== undefined) {
      closed_type(ty);
    }
    it_type_declaration(unmark_iterators, decl);
    return ;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Non_closed) {
      it_type_declaration(unmark_iterators, decl);
      return exn._1;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function closed_extension_constructor(ext) {
  try {
    Stdlib__List.iter(mark_type, ext.ext_type_params);
    const match = ext.ext_ret_type;
    if (match !== undefined) {
      
    } else {
      Stdlib__List.iter(closed_type, ext.ext_args);
    }
    unmark_extension_constructor(ext);
    return ;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Non_closed) {
      unmark_extension_constructor(ext);
      return exn._1;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

const CCFailure = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Ctype.CCFailure");

function closed_class(params, sign) {
  const ty = object_fields(repr(sign.csig_self));
  const match = flatten_fields(ty);
  const fields = match[0];
  Stdlib__List.iter(mark_type, params);
  mark_type(match[1]);
  Stdlib__List.iter((function (param) {
          if (param[0] === dummy_method) {
            return mark_type(param[2]);
          }
          
        }), fields);
  try {
    mark_type_node(repr(sign.csig_self));
    Stdlib__List.iter((function (param) {
            const ty = param[2];
            if (!Caml_obj.caml_equal(field_kind_repr(param[1]), /* Fpresent */0)) {
              return ;
            }
            try {
              return closed_type(ty);
            }
            catch (raw_exn){
              const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn.MEL_EXN_ID === Non_closed) {
                throw new Caml_js_exceptions.MelangeError(CCFailure, {
                          MEL_EXN_ID: CCFailure,
                          _1: {
                            TAG: /* CC_Method */0,
                            _0: exn._1,
                            _1: exn._2,
                            _2: param[0],
                            _3: ty
                          }
                        });
              }
              throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
            }
          }), fields);
    iter_type_expr(mark_type, repr(sign.csig_self));
    Stdlib__List.iter(unmark_type, params);
    unmark_class_signature(sign);
    return ;
  }
  catch (raw_reason){
    const reason = Caml_js_exceptions.internalToOCamlException(raw_reason);
    if (reason.MEL_EXN_ID === CCFailure) {
      iter_type_expr(mark_type, repr(sign.csig_self));
      Stdlib__List.iter(unmark_type, params);
      unmark_class_signature(sign);
      return reason._1;
    }
    throw new Caml_js_exceptions.MelangeError(reason.MEL_EXN_ID, reason);
  }
}

function iter_generalize(tyl, ty) {
  const ty$1 = repr(ty);
  if (!(ty$1.level > current_level.contents && ty$1.level !== 100000000)) {
    tyl.contents = {
      hd: ty$1,
      tl: tyl.contents
    };
    return ;
  }
  set_level(ty$1, 100000000);
  const match = ty$1.desc;
  if (typeof match !== "number" && match.TAG === /* Tconstr */3) {
    iter_abbrev((function (param) {
            return iter_generalize(tyl, param);
          }), match._2.contents);
  }
  iter_type_expr((function (param) {
          return iter_generalize(tyl, param);
        }), ty$1);
}

function iter_generalize$1(tyl, ty) {
  simple_abbrevs.contents = /* Mnil */0;
  iter_generalize(tyl, ty);
}

function generalize(ty) {
  iter_generalize$1({
        contents: /* [] */0
      }, ty);
}

function generalize_structure(var_level, ty) {
  const ty$1 = repr(ty);
  if (ty$1.level === 100000000) {
    return ;
  }
  if (is_Tvar(ty$1) && ty$1.level > var_level) {
    return set_level(ty$1, var_level);
  }
  let tmp = false;
  if (ty$1.level > current_level.contents) {
    const match = ty$1.desc;
    let tmp$1;
    tmp$1 = typeof match === "number" || match.TAG !== /* Tconstr */3 ? true : !is_object_type(match._0) && (match._2.contents = /* Mnil */0, true);
    tmp = tmp$1;
  }
  if (tmp) {
    set_level(ty$1, 100000000);
    return iter_type_expr((function (param) {
                  return generalize_structure(var_level, param);
                }), ty$1);
  }
  
}

function generalize_structure$1(var_level, ty) {
  simple_abbrevs.contents = /* Mnil */0;
  generalize_structure(var_level, ty);
}

function generalize_spine(_ty) {
  while(true) {
    const ty = _ty;
    const ty$1 = repr(ty);
    if (ty$1.level < current_level.contents || ty$1.level === 100000000) {
      return ;
    }
    const match = ty$1.desc;
    if (typeof match === "number") {
      return ;
    }
    switch (match.TAG | 0) {
      case /* Tarrow */1 :
          set_level(ty$1, 100000000);
          generalize_spine(match._1);
          _ty = match._2;
          continue ;
      case /* Ttuple */2 :
          set_level(ty$1, 100000000);
          return Stdlib__List.iter(generalize_spine, match._0);
      case /* Tconstr */3 :
          if (!is_object_type(match._0)) {
            set_level(ty$1, 100000000);
            match._2.contents = /* Mnil */0;
            return Stdlib__List.iter(generalize_spine, match._1);
          } else {
            return ;
          }
      case /* Tpoly */10 :
          set_level(ty$1, 100000000);
          _ty = match._0;
          continue ;
      case /* Tpackage */11 :
          set_level(ty$1, 100000000);
          return Stdlib__List.iter(generalize_spine, match._2);
      default:
        return ;
    }
  };
}

const forward_try_expand_once = {
  contents: (function (env, ty) {
      throw new Caml_js_exceptions.MelangeError(Cannot_expand, {
                MEL_EXN_ID: Cannot_expand
              });
    })
};

function get_level(env, p) {
  try {
    const match = find_type_full(p, env)[0].type_newtype_level;
    if (match !== undefined) {
      return match[0];
    } else {
      return binding_time(p);
    }
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return binding_time(p);
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function normalize_package_path(env, _p) {
  while(true) {
    const p = _p;
    let t;
    try {
      t = find_modtype(p, env).mtd_type;
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        t = undefined;
      } else {
        throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
      }
    }
    if (t === undefined) {
      return p;
    }
    if (t.TAG !== /* Mty_ident */0) {
      return p;
    }
    _p = t._0;
    continue ;
  };
}

function update_level(env, level, _ty) {
  while(true) {
    const ty = _ty;
    const ty$1 = repr(ty);
    if (ty$1.level <= level) {
      return ;
    }
    const lv = gadt_instance_level(env, ty$1);
    if (lv !== undefined && level < lv) {
      throw new Caml_js_exceptions.MelangeError(Unify, {
                MEL_EXN_ID: Unify,
                _1: {
                  hd: [
                    ty$1,
                    newty2(level, {
                          TAG: /* Tvar */0,
                          _0: undefined
                        })
                  ],
                  tl: /* [] */0
                }
              });
    }
    const row = ty$1.desc;
    if (typeof row !== "number") {
      switch (row.TAG | 0) {
        case /* Tconstr */3 :
            const p = row._0;
            if (level < get_level(env, p)) {
              try {
                link_type(ty$1, Curry._2(forward_try_expand_once.contents, env, ty$1));
                return update_level(env, level, ty$1);
              }
              catch (raw_exn){
                const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                if (exn.MEL_EXN_ID === Cannot_expand) {
                  if (level < get_level(env, p)) {
                    throw new Caml_js_exceptions.MelangeError(Unify, {
                              MEL_EXN_ID: Unify,
                              _1: {
                                hd: [
                                  ty$1,
                                  newty2(level, {
                                        TAG: /* Tvar */0,
                                        _0: undefined
                                      })
                                ],
                                tl: /* [] */0
                              }
                            });
                  }
                  return iter_type_expr((function (param) {
                                return update_level(env, level, param);
                              }), ty$1);
                }
                throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
              }
            }
            break;
        case /* Tobject */4 :
            const nm = row._1;
            const match = nm.contents;
            if (match !== undefined && level < get_level(env, match[0])) {
              set_name(nm, undefined);
              _ty = ty$1;
              continue ;
            }
            break;
        case /* Tfield */5 :
            const ty1 = row._2;
            if (row._0 === dummy_method && repr(ty1).level > level) {
              throw new Caml_js_exceptions.MelangeError(Unify, {
                        MEL_EXN_ID: Unify,
                        _1: {
                          hd: [
                            ty1,
                            newty2(level, {
                                  TAG: /* Tvar */0,
                                  _0: undefined
                                })
                          ],
                          tl: /* [] */0
                        }
                      });
            }
            break;
        case /* Tvariant */8 :
            const row$1 = row_repr_aux(/* [] */0, row._0);
            const match$1 = row$1.row_name;
            if (match$1 !== undefined && level < get_level(env, match$1[0])) {
              log_type(ty$1);
              ty$1.desc = {
                TAG: /* Tvariant */8,
                _0: {
                  row_fields: row$1.row_fields,
                  row_more: row$1.row_more,
                  row_bound: row$1.row_bound,
                  row_closed: row$1.row_closed,
                  row_fixed: row$1.row_fixed,
                  row_name: undefined
                }
              };
            }
            set_level(ty$1, level);
            return iter_type_expr((function (param) {
                          return update_level(env, level, param);
                        }), ty$1);
        case /* Tpackage */11 :
            const p$1 = row._0;
            if (level < get_level(env, p$1)) {
              const p$p = normalize_package_path(env, p$1);
              if (same(p$1, p$p)) {
                throw new Caml_js_exceptions.MelangeError(Unify, {
                          MEL_EXN_ID: Unify,
                          _1: {
                            hd: [
                              ty$1,
                              newty2(level, {
                                    TAG: /* Tvar */0,
                                    _0: undefined
                                  })
                            ],
                            tl: /* [] */0
                          }
                        });
              }
              log_type(ty$1);
              ty$1.desc = {
                TAG: /* Tpackage */11,
                _0: p$p,
                _1: row._1,
                _2: row._2
              };
              _ty = ty$1;
              continue ;
            }
            break;
        default:
          
      }
    }
    set_level(ty$1, level);
    return iter_type_expr((function (param) {
                  return update_level(env, level, param);
                }), ty$1);
  };
}

function generalize_contravariant(env) {
  if (principal.contents) {
    return generalize_structure$1;
  } else {
    return function (param, param$1) {
      return update_level(env, param, param$1);
    };
  }
}

function generalize_expansive(env, var_level, _ty) {
  while(true) {
    const ty = _ty;
    const ty$1 = repr(ty);
    if (ty$1.level === 100000000) {
      return ;
    }
    if (ty$1.level <= var_level) {
      return ;
    }
    set_level(ty$1, 100000000);
    const match = ty$1.desc;
    if (typeof match === "number") {
      return iter_type_expr((function (param) {
                    return generalize_expansive(env, var_level, param);
                  }), ty$1);
    }
    switch (match.TAG | 0) {
      case /* Tarrow */1 :
          generalize_contravariant(env)(var_level, match._1);
          _ty = match._2;
          continue ;
      case /* Tconstr */3 :
          const tyl = match._1;
          let variance;
          try {
            variance = find_type_full(match._0, env)[0].type_variance;
          }
          catch (raw_exn){
            const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.MEL_EXN_ID === Stdlib.Not_found) {
              variance = Stdlib__List.map((function (param) {
                      return Types_Variance.may_inv;
                    }), tyl);
            } else {
              throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
            }
          }
          match._2.contents = /* Mnil */0;
          return Stdlib__List.iter2((function (v, t) {
                        if (Curry._2(Types_Variance.mem, /* May_weak */2, v)) {
                          return generalize_contravariant(env)(var_level, t);
                        } else {
                          return generalize_expansive(env, var_level, t);
                        }
                      }), variance, tyl);
      case /* Tpackage */11 :
          const partial_arg = generalize_contravariant(env);
          return Stdlib__List.iter((function (param) {
                        return partial_arg(var_level, param);
                      }), match._2);
      default:
        return iter_type_expr((function (param) {
                      return generalize_expansive(env, var_level, param);
                    }), ty$1);
    }
  };
}

function generalize_expansive$1(env, ty) {
  simple_abbrevs.contents = /* Mnil */0;
  try {
    return generalize_expansive(env, nongen_level.contents, ty);
  }
  catch (raw_tr){
    const tr = Caml_js_exceptions.internalToOCamlException(raw_tr);
    if (tr.MEL_EXN_ID === Unify) {
      const tr$1 = tr._1;
      if (tr$1) {
        if (tr$1.tl) {
          throw new Caml_js_exceptions.MelangeError(tr.MEL_EXN_ID, tr);
        }
        throw new Caml_js_exceptions.MelangeError(Unify, {
                  MEL_EXN_ID: Unify,
                  _1: {
                    hd: [
                      ty,
                      tr$1.hd[1]
                    ],
                    tl: tr$1
                  }
                });
      }
      throw new Caml_js_exceptions.MelangeError(tr.MEL_EXN_ID, tr);
    }
    throw new Caml_js_exceptions.MelangeError(tr.MEL_EXN_ID, tr);
  }
}

function generalize_structure$2(ty) {
  generalize_structure$1(current_level.contents, ty);
}

function limited_generalize(ty0, ty) {
  const ty0$1 = repr(ty0);
  const graph = Stdlib__Hashtbl.create(undefined, 17);
  const idx = {
    contents: 0
  };
  const roots = {
    contents: /* [] */0
  };
  const inverse = function (pty, ty) {
    const ty$1 = repr(ty);
    if (ty$1.level > current_level.contents || ty$1.level === 100000000) {
      idx.contents = idx.contents - 1 | 0;
      Stdlib__Hashtbl.add(graph, idx.contents, [
            ty$1,
            {
              contents: pty
            }
          ]);
      if (ty$1.level === 100000000 || ty$1 === ty0$1) {
        roots.contents = {
          hd: ty$1,
          tl: roots.contents
        };
      }
      set_level(ty$1, idx.contents);
      const partial_arg = {
        hd: ty$1,
        tl: /* [] */0
      };
      return iter_type_expr((function (param) {
                    return inverse(partial_arg, param);
                  }), ty$1);
    }
    if (ty$1.level >= 0) {
      return ;
    }
    const match = Stdlib__Hashtbl.find(graph, ty$1.level);
    const parents = match[1];
    parents.contents = Stdlib.$at(pty, parents.contents);
  };
  const generalize_parents = function (ty) {
    const idx = ty.level;
    if (idx === 100000000) {
      return ;
    }
    set_level(ty, 100000000);
    Stdlib__List.iter(generalize_parents, Stdlib__Hashtbl.find(graph, idx)[1].contents);
    const row = ty.desc;
    if (typeof row === "number") {
      return ;
    }
    if (row.TAG !== /* Tvariant */8) {
      return ;
    }
    const more = row_more(row._0);
    const lv = more.level;
    if ((lv < 0 || lv > current_level.contents) && lv !== 100000000) {
      return set_level(more, 100000000);
    }
    
  };
  inverse(/* [] */0, ty);
  if (ty0$1.level < 0) {
    iter_type_expr((function (param) {
            return inverse(/* [] */0, param);
          }), ty0$1);
  }
  Stdlib__List.iter(generalize_parents, roots.contents);
  Stdlib__Hashtbl.iter((function (param, param$1) {
          const ty = param$1[0];
          if (ty.level !== 100000000) {
            return set_level(ty, current_level.contents);
          }
          
        }), graph);
}

function inv_type(hash, pty, ty) {
  const ty$1 = repr(ty);
  try {
    const inv = Curry._2(TypeHash.find, hash, ty$1);
    inv.inv_parents = Stdlib.$at(pty, inv.inv_parents);
    return ;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      const inv$1 = {
        inv_type: ty$1,
        inv_parents: pty
      };
      Curry._3(TypeHash.add, hash, ty$1, inv$1);
      const partial_arg = {
        hd: inv$1,
        tl: /* [] */0
      };
      return iter_type_expr((function (param) {
                    return inv_type(hash, partial_arg, param);
                  }), ty$1);
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function compute_univars(ty) {
  const inverted = Curry._1(TypeHash.create, 17);
  inv_type(inverted, /* [] */0, ty);
  const node_univars = Curry._1(TypeHash.create, 17);
  const add_univar = function (univ, inv) {
    const match = inv.inv_type.desc;
    if (typeof match !== "number" && match.TAG === /* Tpoly */10 && Stdlib__List.memq(univ, Stdlib__List.map(repr, match._1))) {
      return ;
    }
    try {
      const univs = Curry._2(TypeHash.find, node_univars, inv.inv_type);
      if (!Curry._2(mem$3, univ, univs.contents)) {
        univs.contents = Curry._2(add$3, univ, univs.contents);
        return Stdlib__List.iter((function (param) {
                      return add_univar(univ, param);
                    }), inv.inv_parents);
      } else {
        return ;
      }
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        Curry._3(TypeHash.add, node_univars, inv.inv_type, {
              contents: Curry._1(singleton$2, univ)
            });
        return Stdlib__List.iter((function (param) {
                      return add_univar(univ, param);
                    }), inv.inv_parents);
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  };
  Curry._2(TypeHash.iter, (function (ty, inv) {
          if (is_Tunivar(ty)) {
            return add_univar(ty, inv);
          }
          
        }), inverted);
  return function (ty) {
    try {
      return Curry._2(TypeHash.find, node_univars, ty).contents;
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        return /* Empty */0;
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  };
}

function find_repr(p1, _param) {
  while(true) {
    const param = _param;
    if (typeof param === "number") {
      return ;
    }
    if (param.TAG === /* Mcons */0) {
      if (param._0) {
        if (same(p1, param._1)) {
          return param._2;
        }
        _param = param._4;
        continue ;
      }
      _param = param._4;
      continue ;
    }
    const rem = param._0.contents;
    _param = rem;
    continue ;
  };
}

const abbreviations = {
  contents: {
    contents: /* Mnil */0
  }
};

function copy(env, partial, keep_names, ty) {
  const copy$1 = function (param) {
    return copy(env, partial, keep_names, param);
  };
  const ty$1 = repr(ty);
  const ty$2 = ty$1.desc;
  let exit = 0;
  if (typeof ty$2 === "number") {
    exit = 1;
  } else {
    if (ty$2.TAG === /* Tsubst */7) {
      return ty$2._0;
    }
    exit = 1;
  }
  if (exit === 1) {
    if (ty$1.level !== 100000000 && partial === undefined) {
      return ty$1;
    }
    let forget;
    if (ty$1.level === 100000000) {
      forget = 100000000;
    } else if (partial !== undefined) {
      forget = Curry._1(is_empty$2, Curry._1(partial[0], ty$1)) ? (
          partial[1] ? ty$1.level : current_level.contents
        ) : 100000000;
    } else {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  30996,
                  16
                ]
              });
    }
    if (forget !== 100000000) {
      return newty2(forget, {
                  TAG: /* Tvar */0,
                  _0: undefined
                });
    }
    const desc = ty$1.desc;
    save_desc(ty$1, desc);
    const t = newvar(undefined, undefined);
    if (env !== undefined) {
      const env$1 = Caml_option.valFromOption(env);
      if (env$1.local_constraints) {
        const lv = gadt_instance_level(env$1, ty$1);
        if (lv !== undefined) {
          add_gadt_instances(env$1, lv, {
                hd: t,
                tl: /* [] */0
              });
        }
        
      }
      
    }
    ty$1.desc = {
      TAG: /* Tsubst */7,
      _0: t
    };
    let tmp;
    if (typeof desc === "number") {
      tmp = copy_type_desc(keep_names, copy$1, desc);
    } else {
      switch (desc.TAG | 0) {
        case /* Tconstr */3 :
            const tl = desc._1;
            const p = desc._0;
            const abbrevs = proper_abbrevs(p, tl, abbreviations.contents);
            const ty$3 = find_repr(p, abbrevs.contents);
            let exit$1 = 0;
            if (ty$3 !== undefined && repr(ty$3) !== t) {
              tmp = {
                TAG: /* Tlink */6,
                _0: ty$3
              };
            } else {
              exit$1 = 2;
            }
            if (exit$1 === 2) {
              const abbrev = abbreviations.contents.contents;
              let tmp$1;
              tmp$1 = typeof abbrev === "number" || abbrev.TAG !== /* Mcons */0 ? abbrev : ({
                    TAG: /* Mlink */1,
                    _0: abbreviations.contents
                  });
              tmp = {
                TAG: /* Tconstr */3,
                _0: p,
                _1: Stdlib__List.map(copy$1, tl),
                _2: {
                  contents: tmp$1
                }
              };
            }
            break;
        case /* Tobject */4 :
            tmp = partial !== undefined ? ({
                  TAG: /* Tobject */4,
                  _0: copy$1(desc._0),
                  _1: {
                    contents: undefined
                  }
                }) : copy_type_desc(keep_names, copy$1, desc);
            break;
        case /* Tfield */5 :
            const r = field_kind_repr(desc._1);
            if (typeof r === "number") {
              tmp = r ? ({
                    TAG: /* Tlink */6,
                    _0: copy$1(desc._3)
                  }) : copy_type_desc(undefined, copy$1, desc);
            } else {
              dup_kind(r._0);
              tmp = copy_type_desc(undefined, copy$1, desc);
            }
            break;
        case /* Tvariant */8 :
            const row = row_repr_aux(/* [] */0, desc._0);
            const more = repr(row.row_more);
            const match = more.desc;
            let exit$2 = 0;
            if (typeof match === "number" || match.TAG !== /* Tsubst */7) {
              exit$2 = 2;
            } else {
              const match$1 = match._0.desc;
              if (typeof match$1 === "number" || match$1.TAG !== /* Ttuple */2) {
                exit$2 = 2;
              } else {
                const match$2 = match$1._0;
                if (match$2) {
                  const match$3 = match$2.tl;
                  if (match$3 && !match$3.tl) {
                    const ty2 = match$3.hd;
                    ty$1.desc = {
                      TAG: /* Tsubst */7,
                      _0: ty2
                    };
                    tmp = {
                      TAG: /* Tlink */6,
                      _0: ty2
                    };
                  } else {
                    exit$2 = 2;
                  }
                } else {
                  exit$2 = 2;
                }
              }
            }
            if (exit$2 === 2) {
              const keep = more.level !== 100000000;
              const ty$4 = more.desc;
              let more$p;
              let exit$3 = 0;
              if (typeof ty$4 === "number") {
                exit$3 = 3;
              } else {
                switch (ty$4.TAG | 0) {
                  case /* Tconstr */3 :
                      exit$3 = 3;
                      break;
                  case /* Tsubst */7 :
                      more$p = ty$4._0;
                      break;
                  case /* Tvar */0 :
                  case /* Tunivar */9 :
                      exit$3 = 4;
                      break;
                  default:
                    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                              MEL_EXN_ID: "Assert_failure",
                              _1: [
                                "jscomp/test/ocaml_typedtree_test.ml",
                                31059,
                                24
                              ]
                            });
                }
              }
              switch (exit$3) {
                case 3 :
                    if (keep) {
                      save_desc(more, more.desc);
                    }
                    more$p = copy$1(more);
                    break;
                case 4 :
                    save_desc(more, more.desc);
                    more$p = keep ? more : newty2(current_level.contents, more.desc);
                    break;
                
              }
              const match$4 = repr(more$p);
              const match$5 = match$4.desc;
              let row$1;
              row$1 = typeof match$5 === "number" || !(match$5.TAG === /* Tconstr */3 && !row.row_fixed) ? row : ({
                    row_fields: row.row_fields,
                    row_more: row.row_more,
                    row_bound: row.row_bound,
                    row_closed: row.row_closed,
                    row_fixed: true,
                    row_name: row.row_name
                  });
              let match$6;
              if (partial !== undefined && !partial[1]) {
                let more$p$1;
                if (more.id !== more$p.id) {
                  more$p$1 = more$p;
                } else {
                  const lv$1 = keep ? more.level : current_level.contents;
                  more$p$1 = newty2(lv$1, {
                        TAG: /* Tvar */0,
                        _0: undefined
                      });
                }
                const not_reither = function (param) {
                  const match = row_field_repr_aux(/* [] */0, param[1]);
                  if (typeof match === "number" || match.TAG === /* Rpresent */0) {
                    return true;
                  } else {
                    return false;
                  }
                };
                match$6 = row$1.row_closed && !row$1.row_fixed && Curry._1(is_empty$2, Curry._1(partial[0], ty$1)) && !Stdlib__List.for_all(not_reither, row$1.row_fields) ? [
                    more$p$1,
                    {
                      row_fields: Stdlib__List.filter(not_reither, row$1.row_fields),
                      row_more: more$p$1,
                      row_bound: undefined,
                      row_closed: false,
                      row_fixed: false,
                      row_name: undefined
                    }
                  ] : [
                    more$p$1,
                    row$1
                  ];
              } else {
                match$6 = [
                  more$p,
                  row$1
                ];
              }
              const more$p$2 = match$6[0];
              more.desc = {
                TAG: /* Tsubst */7,
                _0: newty2(100000000, {
                      TAG: /* Ttuple */2,
                      _0: {
                        hd: more$p$2,
                        tl: {
                          hd: t,
                          tl: /* [] */0
                        }
                      }
                    })
              };
              tmp = {
                TAG: /* Tvariant */8,
                _0: copy_row(copy$1, true, match$6[1], keep, more$p$2)
              };
            }
            break;
        default:
          tmp = copy_type_desc(keep_names, copy$1, desc);
      }
    }
    t.desc = tmp;
    return t;
  }
  
}

function simple_copy(t) {
  return copy(undefined, undefined, undefined, t);
}

function gadt_env(env) {
  if (env.local_constraints) {
    return Caml_option.some(env);
  }
  
}

function instance(partial, env, sch) {
  const env$1 = gadt_env(env);
  const partial$1 = partial !== undefined ? [
      compute_univars(sch),
      partial
    ] : undefined;
  const ty = copy(env$1, partial$1, undefined, sch);
  cleanup_types(undefined);
  return ty;
}

function instance_def(sch) {
  const ty = copy(undefined, undefined, undefined, sch);
  cleanup_types(undefined);
  return ty;
}

function instance_list(env, schl) {
  const env$1 = gadt_env(env);
  const tyl = Stdlib__List.map((function (t) {
          return copy(env$1, undefined, undefined, t);
        }), schl);
  cleanup_types(undefined);
  return tyl;
}

const reified_var_counter = {
  contents: Meths.empty
};

function get_new_abstract_name(s) {
  let index;
  try {
    index = Curry._2(Meths.find, s, reified_var_counter.contents) + 1 | 0;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      index = 0;
    } else {
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  }
  reified_var_counter.contents = Curry._3(Meths.add, s, index, reified_var_counter.contents);
  return Curry._2(Stdlib__Printf.sprintf(/* Format */{
                  _0: {
                    TAG: /* String */2,
                    _0: /* No_padding */0,
                    _1: {
                      TAG: /* Char_literal */12,
                      _0: /* '#' */35,
                      _1: {
                        TAG: /* Int */4,
                        _0: /* Int_d */0,
                        _1: /* No_padding */0,
                        _2: /* No_precision */0,
                        _3: /* End_of_format */0
                      }
                    }
                  },
                  _1: "%s#%d"
                }), s, index);
}

function new_declaration(newtype, manifest) {
  return {
          type_params: /* [] */0,
          type_arity: 0,
          type_kind: /* Type_abstract */0,
          type_private: /* Public */1,
          type_manifest: manifest,
          type_variance: /* [] */0,
          type_newtype_level: newtype,
          type_loc: none,
          type_attributes: /* [] */0
        };
}

function instance_constructor(in_pattern, cstr) {
  if (in_pattern !== undefined) {
    const newtype_lev = in_pattern[1];
    const env = in_pattern[0];
    const $$process = function (existential) {
      const decl = new_declaration([
            newtype_lev,
            newtype_lev
          ], undefined);
      const match = repr(existential);
      const match$1 = match.desc;
      let name;
      if (typeof match$1 === "number" || match$1.TAG !== /* Tvar */0) {
        name = "ex";
      } else {
        const name$1 = match$1._0;
        name = name$1 !== undefined ? name$1 : "ex";
      }
      const match$2 = enter_type(get_new_abstract_name(name), decl, env.contents);
      env.contents = match$2[1];
      const to_unify = newty2(current_level.contents, {
            TAG: /* Tconstr */3,
            _0: {
              TAG: /* Pident */0,
              _0: match$2[0]
            },
            _1: /* [] */0,
            _2: {
              contents: /* Mnil */0
            }
          });
      const tv = copy(undefined, undefined, undefined, existential);
      if (!is_Tvar(tv)) {
        throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                  MEL_EXN_ID: "Assert_failure",
                  _1: [
                    "jscomp/test/ocaml_typedtree_test.ml",
                    31182,
                    8
                  ]
                });
      }
      link_type(tv, to_unify);
    };
    Stdlib__List.iter($$process, cstr.cstr_existentials);
  }
  const ty_res = copy(undefined, undefined, undefined, cstr.cstr_res);
  const ty_args = Stdlib__List.map(simple_copy, cstr.cstr_args);
  cleanup_types(undefined);
  return [
          ty_args,
          ty_res
        ];
}

function instance_parameterized_type(keep_names, sch_args, sch) {
  const ty_args = Stdlib__List.map((function (t) {
          return copy(undefined, undefined, keep_names, t);
        }), sch_args);
  const ty = copy(undefined, undefined, undefined, sch);
  cleanup_types(undefined);
  return [
          ty_args,
          ty
        ];
}

function instance_declaration(decl) {
  const cl = decl.type_kind;
  let tmp;
  tmp = typeof cl === "number" ? (
      cl === /* Type_abstract */0 ? /* Type_abstract */0 : /* Type_open */1
    ) : (
      cl.TAG === /* Type_record */0 ? ({
            TAG: /* Type_record */0,
            _0: Stdlib__List.map((function (l) {
                    return {
                            ld_id: l.ld_id,
                            ld_mutable: l.ld_mutable,
                            ld_type: copy(undefined, undefined, undefined, l.ld_type),
                            ld_loc: l.ld_loc,
                            ld_attributes: l.ld_attributes
                          };
                  }), cl._0),
            _1: cl._1
          }) : ({
            TAG: /* Type_variant */1,
            _0: Stdlib__List.map((function (c) {
                    return {
                            cd_id: c.cd_id,
                            cd_args: Stdlib__List.map(simple_copy, c.cd_args),
                            cd_res: may_map(simple_copy, c.cd_res),
                            cd_loc: c.cd_loc,
                            cd_attributes: c.cd_attributes
                          };
                  }), cl._0)
          })
    );
  const decl_type_params = Stdlib__List.map(simple_copy, decl.type_params);
  const decl_type_arity = decl.type_arity;
  const decl_type_private = decl.type_private;
  const decl_type_manifest = may_map(simple_copy, decl.type_manifest);
  const decl_type_variance = decl.type_variance;
  const decl_type_newtype_level = decl.type_newtype_level;
  const decl_type_loc = decl.type_loc;
  const decl_type_attributes = decl.type_attributes;
  const decl$1 = {
    type_params: decl_type_params,
    type_arity: decl_type_arity,
    type_kind: tmp,
    type_private: decl_type_private,
    type_manifest: decl_type_manifest,
    type_variance: decl_type_variance,
    type_newtype_level: decl_type_newtype_level,
    type_loc: decl_type_loc,
    type_attributes: decl_type_attributes
  };
  cleanup_types(undefined);
  return decl$1;
}

function instance_class(params, cty) {
  const copy_class_type = function (sign) {
    switch (sign.TAG | 0) {
      case /* Cty_constr */0 :
          return {
                  TAG: /* Cty_constr */0,
                  _0: sign._0,
                  _1: Stdlib__List.map(simple_copy, sign._1),
                  _2: copy_class_type(sign._2)
                };
      case /* Cty_signature */1 :
          const sign$1 = sign._0;
          return {
                  TAG: /* Cty_signature */1,
                  _0: {
                    csig_self: copy(undefined, undefined, undefined, sign$1.csig_self),
                    csig_vars: Curry._2(Meths.map, (function (param) {
                            return [
                                    param[0],
                                    param[1],
                                    copy(undefined, undefined, undefined, param[2])
                                  ];
                          }), sign$1.csig_vars),
                    csig_concr: sign$1.csig_concr,
                    csig_inher: Stdlib__List.map((function (param) {
                            return [
                                    param[0],
                                    Stdlib__List.map(simple_copy, param[1])
                                  ];
                          }), sign$1.csig_inher)
                  }
                };
      case /* Cty_arrow */2 :
          return {
                  TAG: /* Cty_arrow */2,
                  _0: sign._0,
                  _1: copy(undefined, undefined, undefined, sign._1),
                  _2: copy_class_type(sign._2)
                };
      
    }
  };
  const params$p = Stdlib__List.map(simple_copy, params);
  const cty$p = copy_class_type(cty);
  cleanup_types(undefined);
  return [
          params$p,
          cty$p
        ];
}

function diff_list(l1, l2) {
  if (l1 === l2) {
    return /* [] */0;
  }
  if (l1) {
    return {
            hd: l1.hd,
            tl: diff_list(l1.tl, l2)
          };
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Ctype.diff_list"
          });
}

function conflicts(free, bound) {
  const bound$1 = Stdlib__List.map(repr, bound);
  return Curry._2(exists$1, (function (t) {
                return Stdlib__List.memq(repr(t), bound$1);
              }), free);
}

const delayed_copy = {
  contents: /* [] */0
};

function copy_sep(fixed, free, bound, visited, ty) {
  const ty$1 = repr(ty);
  const univars = Curry._1(free, ty$1);
  if (Curry._1(is_empty$2, univars)) {
    if (ty$1.level !== 100000000) {
      return ty$1;
    }
    const t = newvar(undefined, undefined);
    delayed_copy.contents = {
      hd: {
        LAZY_DONE: false,
        VAL: (function () {
            t.desc = {
              TAG: /* Tlink */6,
              _0: copy(undefined, undefined, undefined, ty$1)
            };
          })
      },
      tl: delayed_copy.contents
    };
    return t;
  }
  try {
    const match = Stdlib__List.assq(ty$1, visited);
    const dl = is_Tunivar(ty$1) ? /* [] */0 : diff_list(bound, match[1]);
    if (Caml_obj.caml_notequal(dl, /* [] */0) && conflicts(univars, dl)) {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
    }
    return match[0];
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      const t$1 = newvar(undefined, undefined);
      const match$1 = ty$1.desc;
      let visited$1;
      let exit = 0;
      if (typeof match$1 === "number") {
        visited$1 = visited;
      } else {
        switch (match$1.TAG | 0) {
          case /* Tarrow */1 :
          case /* Ttuple */2 :
          case /* Tconstr */3 :
          case /* Tobject */4 :
          case /* Tvariant */8 :
          case /* Tpackage */11 :
              exit = 1;
              break;
          default:
            visited$1 = visited;
        }
      }
      if (exit === 1) {
        visited$1 = {
          hd: [
            ty$1,
            [
              t$1,
              bound
            ]
          ],
          tl: visited
        };
      }
      const copy_rec = function (param) {
        return copy_sep(fixed, free, bound, visited$1, param);
      };
      const row0 = ty$1.desc;
      let tmp;
      if (typeof row0 === "number") {
        tmp = copy_type_desc(undefined, copy_rec, ty$1.desc);
      } else {
        switch (row0.TAG | 0) {
          case /* Tvariant */8 :
              const row = row_repr_aux(/* [] */0, row0._0);
              const more = repr(row.row_more);
              const keep = is_Tvar(more) && more.level !== 100000000;
              const more$p = copy_rec(more);
              const fixed$p = fixed && is_Tvar(repr(more$p));
              const row$1 = copy_row(copy_rec, fixed$p, row, keep, more$p);
              tmp = {
                TAG: /* Tvariant */8,
                _0: row$1
              };
              break;
          case /* Tpoly */10 :
              const tl = Stdlib__List.map(repr, row0._1);
              const tl$p = Stdlib__List.map((function (t) {
                      return newty2(current_level.contents, t.desc);
                    }), tl);
              const bound$1 = Stdlib.$at(tl, bound);
              const visited$2 = Stdlib.$at(Stdlib__List.map2((function (ty, t) {
                          return [
                                  ty,
                                  [
                                    t,
                                    bound$1
                                  ]
                                ];
                        }), tl, tl$p), visited$1);
              tmp = {
                TAG: /* Tpoly */10,
                _0: copy_sep(fixed, free, bound$1, visited$2, row0._0),
                _1: tl$p
              };
              break;
          default:
            tmp = copy_type_desc(undefined, copy_rec, ty$1.desc);
        }
      }
      t$1.desc = tmp;
      return t$1;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function instance_poly(keep_namesOpt, fixed, univars, sch) {
  const keep_names = keep_namesOpt !== undefined ? keep_namesOpt : false;
  const univars$1 = Stdlib__List.map(repr, univars);
  const copy_var = function (ty) {
    const name = ty.desc;
    if (typeof name === "number") {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  31319,
                  11
                ]
              });
    }
    if (name.TAG === /* Tunivar */9) {
      if (keep_names) {
        return newty2(current_level.contents, {
                    TAG: /* Tvar */0,
                    _0: name._0
                  });
      } else {
        return newvar(undefined, undefined);
      }
    }
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                31319,
                11
              ]
            });
  };
  const vars = Stdlib__List.map(copy_var, univars$1);
  const pairs = Stdlib__List.map2((function (u, v) {
          return [
                  u,
                  [
                    v,
                    /* [] */0
                  ]
                ];
        }), univars$1, vars);
  delayed_copy.contents = /* [] */0;
  const ty = copy_sep(fixed, compute_univars(sch), /* [] */0, pairs, sch);
  Stdlib__List.iter(CamlinternalLazy.force, delayed_copy.contents);
  delayed_copy.contents = /* [] */0;
  cleanup_types(undefined);
  return [
          vars,
          ty
        ];
}

function instance_label(fixed, lbl) {
  const ty_res = copy(undefined, undefined, undefined, lbl.lbl_res);
  const ty = repr(lbl.lbl_arg);
  let match;
  let exit = 0;
  const match$1 = ty.desc;
  if (typeof match$1 === "number" || match$1.TAG !== /* Tpoly */10) {
    exit = 1;
  } else {
    match = instance_poly(undefined, fixed, match$1._1, match$1._0);
  }
  if (exit === 1) {
    match = [
      /* [] */0,
      copy(undefined, undefined, undefined, lbl.lbl_arg)
    ];
  }
  cleanup_types(undefined);
  return [
          match[0],
          match[1],
          ty_res
        ];
}

const unify$p = {
  contents: (function (env, ty1, ty2) {
      throw new Caml_js_exceptions.MelangeError(Unify, {
                MEL_EXN_ID: Unify,
                _1: /* [] */0
              });
    })
};

function subst(env, level, priv, abbrev, ty, params, args, body) {
  if (Stdlib__List.length(params) !== Stdlib__List.length(args)) {
    throw new Caml_js_exceptions.MelangeError(Unify, {
              MEL_EXN_ID: Unify,
              _1: /* [] */0
            });
  }
  const old_level = current_level.contents;
  current_level.contents = level;
  try {
    const body0 = newvar(undefined, undefined);
    if (ty !== undefined) {
      const match = ty.desc;
      if (typeof match === "number") {
        throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                  MEL_EXN_ID: "Assert_failure",
                  _1: [
                    "jscomp/test/ocaml_typedtree_test.ml",
                    31359,
                    8
                  ]
                });
      }
      if (match.TAG === /* Tconstr */3) {
        const path = match._0;
        const abbrev$1 = proper_abbrevs(path, match._1, abbrev);
        memorize_abbrev(abbrev$1, priv, path, ty, body0);
      } else {
        throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                  MEL_EXN_ID: "Assert_failure",
                  _1: [
                    "jscomp/test/ocaml_typedtree_test.ml",
                    31359,
                    8
                  ]
                });
      }
    }
    abbreviations.contents = abbrev;
    const match$1 = instance_parameterized_type(undefined, params, body);
    const body$p = match$1[1];
    abbreviations.contents = {
      contents: /* Mnil */0
    };
    Curry._3(unify$p.contents, env, body0, body$p);
    Stdlib__List.iter2(Curry._1(unify$p.contents, env), match$1[0], args);
    current_level.contents = old_level;
    return body$p;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Unify) {
      current_level.contents = old_level;
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

const previous_env = {
  contents: empty
};

function check_abbrev_env(env) {
  if (env !== previous_env.contents) {
    cleanup_abbrev(undefined);
    previous_env.contents = env;
    return ;
  }
  
}

function expand_abbrev_gen(kind, find_type_expansion, env, ty) {
  check_abbrev_env(env);
  const match = ty.desc;
  if (typeof match === "number") {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                31468,
                6
              ]
            });
  }
  if (match.TAG === /* Tconstr */3) {
    const abbrev = match._2;
    const args = match._1;
    const path = match._0;
    const level = ty.level;
    const lookup_abbrev = proper_abbrevs(path, args, abbrev);
    const ty$1 = find_expans(kind, path, lookup_abbrev.contents);
    if (ty$1 !== undefined) {
      if (level !== 100000000) {
        try {
          update_level(env, level, ty$1);
        }
        catch (raw_exn){
          const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.MEL_EXN_ID !== Unify) {
            throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
          }
          
        }
      }
      return ty$1;
    }
    let match$1;
    try {
      match$1 = Curry._2(find_type_expansion, path, env);
    }
    catch (raw_exn$1){
      const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
      if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
        throw new Caml_js_exceptions.MelangeError(Cannot_expand, {
                  MEL_EXN_ID: Cannot_expand
                });
      }
      throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
    }
    const ty$p = subst(env, level, kind, abbrev, ty, match$1[0], args, match$1[1]);
    const ty$2 = repr(ty$p);
    const row = ty$2.desc;
    if (typeof row !== "number" && row.TAG === /* Tvariant */8) {
      const row$1 = row._0;
      if (static_row(row$1)) {
        ty$2.desc = {
          TAG: /* Tvariant */8,
          _0: {
            row_fields: row$1.row_fields,
            row_more: row$1.row_more,
            row_bound: row$1.row_bound,
            row_closed: row$1.row_closed,
            row_fixed: row$1.row_fixed,
            row_name: [
              path,
              args
            ]
          }
        };
      }
      
    }
    if (trace_gadt_instances.contents) {
      const lv = Caml_obj.caml_max(match$1[2], gadt_instance_level(env, ty));
      if (lv !== undefined) {
        if (level < lv) {
          throw new Caml_js_exceptions.MelangeError(Unify, {
                    MEL_EXN_ID: Unify,
                    _1: {
                      hd: [
                        ty,
                        newty2(level, {
                              TAG: /* Tvar */0,
                              _0: undefined
                            })
                      ],
                      tl: /* [] */0
                    }
                  });
        }
        add_gadt_instances(env, lv, {
              hd: ty,
              tl: {
                hd: ty$p,
                tl: /* [] */0
              }
            });
      }
      
    }
    return ty$p;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              31468,
              6
            ]
          });
}

function expand_abbrev(ty) {
  return function (param) {
    return expand_abbrev_gen(/* Public */1, find_type_expansion, ty, param);
  };
}

function expand_head_once(env, ty) {
  try {
    return expand_abbrev(env)(repr(ty));
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Cannot_expand) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  31476,
                  56
                ]
              });
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function safe_abbrev(env, ty) {
  const snap = snapshot(undefined);
  try {
    expand_abbrev(env)(ty);
    return true;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Cannot_expand) {
      backtrack(snap);
      return false;
    }
    if (exn.MEL_EXN_ID === Unify) {
      backtrack(snap);
      return false;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function try_expand_once(env, ty) {
  const ty$1 = repr(ty);
  const match = ty$1.desc;
  if (typeof match === "number") {
    throw new Caml_js_exceptions.MelangeError(Cannot_expand, {
              MEL_EXN_ID: Cannot_expand
            });
  }
  if (match.TAG === /* Tconstr */3) {
    return repr(expand_abbrev(env)(ty$1));
  }
  throw new Caml_js_exceptions.MelangeError(Cannot_expand, {
            MEL_EXN_ID: Cannot_expand
          });
}

function try_expand_safe(env, ty) {
  const snap = snapshot(undefined);
  try {
    return try_expand_once(env, ty);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Unify) {
      backtrack(snap);
      throw new Caml_js_exceptions.MelangeError(Cannot_expand, {
                MEL_EXN_ID: Cannot_expand
              });
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function try_expand_head(try_once, env, ty) {
  const ty$p = Curry._2(try_once, env, ty);
  try {
    return try_expand_head(try_once, env, ty$p);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Cannot_expand) {
      return ty$p;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function try_expand_head$1(try_once, env, ty) {
  const ty$p = try_expand_head(try_once, env, ty);
  const lv = gadt_instance_level(env, ty$p);
  if (lv !== undefined) {
    add_gadt_instance_chain(env, lv, ty);
  }
  return ty$p;
}

function expand_head_unif(env, ty) {
  try {
    return try_expand_head$1(try_expand_once, env, ty);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Cannot_expand) {
      return repr(ty);
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function expand_head(env, ty) {
  try {
    return try_expand_head$1(try_expand_safe, env, ty);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Cannot_expand) {
      return repr(ty);
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

forward_try_expand_once.contents = try_expand_safe;

function extract_concrete_typedecl(env, ty) {
  const ty$1 = repr(ty);
  const match = ty$1.desc;
  if (typeof match === "number") {
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
  }
  if (match.TAG === /* Tconstr */3) {
    const p = match._0;
    const decl = find_type_full(p, env)[0];
    if (Caml_obj.caml_notequal(decl.type_kind, /* Type_abstract */0)) {
      return [
              p,
              p,
              decl
            ];
    }
    let ty$2;
    try {
      ty$2 = try_expand_once(env, ty$1);
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Cannot_expand) {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                  MEL_EXN_ID: Stdlib.Not_found
                });
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
    const match$1 = extract_concrete_typedecl(env, ty$2);
    return [
            p,
            match$1[1],
            match$1[2]
          ];
  }
  throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
}

function expand_abbrev_opt(param, param$1) {
  return expand_abbrev_gen(/* Private */0, find_type_expansion_opt, param, param$1);
}

function try_expand_once_opt(env, ty) {
  const ty$1 = repr(ty);
  const match = ty$1.desc;
  if (typeof match === "number") {
    throw new Caml_js_exceptions.MelangeError(Cannot_expand, {
              MEL_EXN_ID: Cannot_expand
            });
  }
  if (match.TAG === /* Tconstr */3) {
    return repr(expand_abbrev_opt(env, ty$1));
  }
  throw new Caml_js_exceptions.MelangeError(Cannot_expand, {
            MEL_EXN_ID: Cannot_expand
          });
}

function try_expand_head_opt(env, ty) {
  const ty$p = try_expand_once_opt(env, ty);
  try {
    return try_expand_head_opt(env, ty$p);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Cannot_expand) {
      return ty$p;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function expand_head_opt(env, ty) {
  const snap = snapshot(undefined);
  try {
    return try_expand_head_opt(env, ty);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Cannot_expand) {
      backtrack(snap);
      return repr(ty);
    }
    if (exn.MEL_EXN_ID === Unify) {
      backtrack(snap);
      return repr(ty);
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function enforce_constraints(env, ty) {
  const match = ty.desc;
  if (typeof match === "number") {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                31586,
                6
              ]
            });
  }
  if (match.TAG === /* Tconstr */3) {
    const level = ty.level;
    try {
      const decl = find_type_full(match._0, env)[0];
      subst(env, level, /* Public */1, {
            contents: /* Mnil */0
          }, undefined, decl.type_params, match._1, newty2(level, {
                TAG: /* Tvar */0,
                _0: undefined
              }));
      return ;
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        return ;
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  } else {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                31586,
                6
              ]
            });
  }
}

function full_expand(env, ty) {
  const ty$1 = repr(expand_head(env, ty));
  const match = ty$1.desc;
  if (typeof match === "number") {
    return ty$1;
  }
  if (match.TAG !== /* Tobject */4) {
    return ty$1;
  }
  const match$1 = match._1.contents;
  if (match$1 === undefined) {
    return ty$1;
  }
  const match$2 = match$1[1];
  if (match$2 && is_Tvar(repr(match$2.hd))) {
    return newty2(ty$1.level, {
                TAG: /* Tobject */4,
                _0: match._0,
                _1: {
                  contents: undefined
                }
              });
  } else {
    return ty$1;
  }
}

function generic_abbrev(env, path) {
  try {
    const match = find_type_expansion(path, env);
    return repr(match[1]).level === 100000000;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return false;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function generic_private_abbrev(env, path) {
  try {
    const match = find_type_full(path, env)[0];
    const match$1 = match.type_kind;
    if (typeof match$1 !== "number") {
      return false;
    }
    if (match$1) {
      return false;
    }
    if (match.type_private) {
      return false;
    }
    const body = match.type_manifest;
    if (body !== undefined) {
      return repr(body).level === 100000000;
    } else {
      return false;
    }
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return false;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function is_contractive(env, ty) {
  const match = repr(ty).desc;
  if (typeof match === "number") {
    return true;
  }
  if (match.TAG !== /* Tconstr */3) {
    return true;
  }
  const p = match._0;
  if (in_pervasives(p)) {
    return true;
  }
  try {
    return is_datatype(find_type_full(p, env)[0]);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return false;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

const Occur = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Occur");

function occur_rec(env, visited, ty0, ty) {
  if (ty === ty0) {
    throw new Caml_js_exceptions.MelangeError(Occur, {
              MEL_EXN_ID: Occur
            });
  }
  const occur_ok = recursive_types.contents && is_contractive(env, ty);
  const match = ty.desc;
  if (typeof match !== "number") {
    switch (match.TAG | 0) {
      case /* Tconstr */3 :
          try {
            if (occur_ok || Stdlib__List.memq(ty, visited)) {
              throw new Caml_js_exceptions.MelangeError(Occur, {
                        MEL_EXN_ID: Occur
                      });
            }
            const partial_arg = {
              hd: ty,
              tl: visited
            };
            return iter_type_expr((function (param) {
                          return occur_rec(env, partial_arg, ty0, param);
                        }), ty);
          }
          catch (raw_exn){
            const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.MEL_EXN_ID === Occur) {
              try {
                const ty$p = try_expand_head$1(try_expand_once, env, ty);
                if (ty$p === ty0 || Stdlib__List.memq(ty$p, visited)) {
                  throw new Caml_js_exceptions.MelangeError(Occur, {
                            MEL_EXN_ID: Occur
                          });
                }
                const match$1 = ty$p.desc;
                let exit = 0;
                if (typeof match$1 === "number") {
                  exit = 2;
                } else {
                  switch (match$1.TAG | 0) {
                    case /* Tobject */4 :
                    case /* Tvariant */8 :
                        return ;
                    default:
                      exit = 2;
                  }
                }
                if (exit === 2) {
                  if (recursive_types.contents && is_contractive(env, ty$p)) {
                    return ;
                  }
                  const partial_arg$1 = {
                    hd: ty$p,
                    tl: visited
                  };
                  return iter_type_expr((function (param) {
                                return occur_rec(env, partial_arg$1, ty0, param);
                              }), ty$p);
                }
                
              }
              catch (raw_exn$1){
                const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
                if (exn$1.MEL_EXN_ID === Cannot_expand) {
                  if (occur_ok) {
                    return ;
                  }
                  throw new Caml_js_exceptions.MelangeError(Occur, {
                            MEL_EXN_ID: Occur
                          });
                }
                throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
              }
            } else {
              throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
            }
          }
          break;
      case /* Tobject */4 :
      case /* Tvariant */8 :
          return ;
      default:
        
    }
  }
  if (!occur_ok) {
    return iter_type_expr((function (param) {
                  return occur_rec(env, visited, ty0, param);
                }), ty);
  }
  
}

const type_changed = {
  contents: false
};

function merge$2(r, b) {
  if (b) {
    r.contents = true;
    return ;
  }
  
}

function occur(env, ty0, ty) {
  const old = type_changed.contents;
  try {
    while(type_changed.contents = false, occur_rec(env, /* [] */0, ty0, ty), type_changed.contents) {
      
    };
    return merge$2(type_changed, old);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    merge$2(type_changed, old);
    throw new Caml_js_exceptions.MelangeError((
              exn.MEL_EXN_ID === Occur ? ({
                    MEL_EXN_ID: Unify,
                    _1: /* [] */0
                  }) : exn
            ).MEL_EXN_ID, exn.MEL_EXN_ID === Occur ? ({
                  MEL_EXN_ID: Unify,
                  _1: /* [] */0
                }) : exn);
  }
}

function occur_in(env, ty0, t) {
  try {
    occur(env, ty0, t);
    return false;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Unify) {
      return true;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function unify_univar(t1, t2, _param) {
  while(true) {
    const param = _param;
    if (param) {
      const match = param.hd;
      const find_univ = function (t, cl) {
        try {
          const match = Stdlib__List.find((function (param) {
                  return t === repr(param[0]);
                }), cl);
          return Caml_option.some(match[1]);
        }
        catch (raw_exn){
          const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.MEL_EXN_ID === Stdlib.Not_found) {
            return ;
          }
          throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
        }
      };
      const match$1 = find_univ(t1, match[0]);
      const match$2 = find_univ(t2, match[1]);
      if (match$1 !== undefined) {
        const t$p2 = match$1.contents;
        if (t$p2 !== undefined) {
          if (match$2 !== undefined) {
            if (t2 === repr(t$p2)) {
              return ;
            }
            throw new Caml_js_exceptions.MelangeError(Unify, {
                      MEL_EXN_ID: Unify,
                      _1: /* [] */0
                    });
          }
          throw new Caml_js_exceptions.MelangeError(Unify, {
                    MEL_EXN_ID: Unify,
                    _1: /* [] */0
                  });
        }
        if (match$2 !== undefined) {
          const match$3 = match$2.contents;
          if (match$3 !== undefined) {
            throw new Caml_js_exceptions.MelangeError(Unify, {
                      MEL_EXN_ID: Unify,
                      _1: /* [] */0
                    });
          }
          set_univar(match$1, t2);
          return set_univar(match$2, t1);
        }
        throw new Caml_js_exceptions.MelangeError(Unify, {
                  MEL_EXN_ID: Unify,
                  _1: /* [] */0
                });
      }
      if (match$2 !== undefined) {
        throw new Caml_js_exceptions.MelangeError(Unify, {
                  MEL_EXN_ID: Unify,
                  _1: /* [] */0
                });
      }
      _param = param.tl;
      continue ;
    }
    throw new Caml_js_exceptions.MelangeError(Unify, {
              MEL_EXN_ID: Unify,
              _1: /* [] */0
            });
  };
}

function occur_univar(env, ty) {
  const visited = {
    contents: /* Empty */0
  };
  const occur_rec = function (_bound, _ty) {
    while(true) {
      const ty = _ty;
      const bound = _bound;
      const ty$1 = repr(ty);
      let tmp = false;
      if (ty$1.level >= 0) {
        let tmp$1;
        if (Curry._1(is_empty$2, bound)) {
          ty$1.level = pivot_level - ty$1.level | 0;
          tmp$1 = true;
        } else {
          try {
            const bound$p = Curry._2(find$1, ty$1, visited.contents);
            if (Curry._2(exists$1, (function (x) {
                      return !Curry._2(mem$3, x, bound);
                    }), bound$p)) {
              visited.contents = Curry._3(add$4, ty$1, Curry._2(inter$2, bound, bound$p), visited.contents);
              tmp$1 = true;
            } else {
              tmp$1 = false;
            }
          }
          catch (raw_exn){
            const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.MEL_EXN_ID === Stdlib.Not_found) {
              visited.contents = Curry._3(add$4, ty$1, bound, visited.contents);
              tmp$1 = true;
            } else {
              throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
            }
          }
        }
        tmp = tmp$1;
      }
      if (!tmp) {
        return ;
      }
      const match = ty$1.desc;
      if (typeof match === "number") {
        return iter_type_expr((function (param) {
                      return occur_rec(bound, param);
                    }), ty$1);
      }
      switch (match.TAG | 0) {
        case /* Tconstr */3 :
            if (!match._1) {
              return ;
            }
            const tl = match._1;
            try {
              const td = find_type_full(match._0, env)[0];
              return Stdlib__List.iter2((function (t, v) {
                            if (Curry._2(Types_Variance.mem, /* May_pos */0, v) || Curry._2(Types_Variance.mem, /* May_neg */1, v)) {
                              return occur_rec(bound, t);
                            }
                            
                          }), tl, td.type_variance);
            }
            catch (raw_exn$1){
              const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
              if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
                return Stdlib__List.iter((function (param) {
                              return occur_rec(bound, param);
                            }), tl);
              }
              throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
            }
        case /* Tunivar */9 :
            if (Curry._2(mem$3, ty$1, bound)) {
              return ;
            }
            throw new Caml_js_exceptions.MelangeError(Unify, {
                      MEL_EXN_ID: Unify,
                      _1: {
                        hd: [
                          ty$1,
                          newty2(100000000, {
                                TAG: /* Tvar */0,
                                _0: undefined
                              })
                        ],
                        tl: /* [] */0
                      }
                    });
        case /* Tpoly */10 :
            const bound$1 = Stdlib__List.fold_right(add$3, Stdlib__List.map(repr, match._1), bound);
            _ty = match._0;
            _bound = bound$1;
            continue ;
        default:
          return iter_type_expr((function (param) {
                        return occur_rec(bound, param);
                      }), ty$1);
      }
    };
  };
  try {
    occur_rec(/* Empty */0, ty);
    return unmark_type(ty);
  }
  catch (exn){
    unmark_type(ty);
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function add_univars(param, param$1) {
  return Stdlib__List.fold_left((function (s, param) {
                return Curry._2(add$3, repr(param[0]), s);
              }), param, param$1);
}

function get_univar_family(univar_pairs, univars) {
  if (Caml_obj.caml_equal(univars, /* [] */0)) {
    return /* Empty */0;
  }
  const insert = function (s, param) {
    const cl2 = param[1];
    if (cl2 && Stdlib__List.exists((function (param) {
              return Curry._2(mem$3, repr(param[0]), s);
            }), param[0])) {
      return add_univars(s, cl2);
    } else {
      return s;
    }
  };
  const s = Stdlib__List.fold_right(add$3, univars, /* Empty */0);
  return Stdlib__List.fold_left(insert, s, univar_pairs);
}

function univars_escape(env, univar_pairs, vl, ty) {
  const family = get_univar_family(univar_pairs, vl);
  const visited = {
    contents: /* Empty */0
  };
  const occur = function (_t) {
    while(true) {
      const t = _t;
      const t$1 = repr(t);
      if (Curry._2(mem$3, t$1, visited.contents)) {
        return ;
      }
      visited.contents = Curry._2(add$3, t$1, visited.contents);
      const match = t$1.desc;
      if (typeof match === "number") {
        return iter_type_expr(occur, t$1);
      }
      switch (match.TAG | 0) {
        case /* Tconstr */3 :
            if (!match._1) {
              return ;
            }
            const tl = match._1;
            try {
              const td = find_type_full(match._0, env)[0];
              return Stdlib__List.iter2((function (t, v) {
                            if (Curry._2(Types_Variance.mem, /* May_pos */0, v) || Curry._2(Types_Variance.mem, /* May_neg */1, v)) {
                              return occur(t);
                            }
                            
                          }), tl, td.type_variance);
            }
            catch (raw_exn){
              const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn.MEL_EXN_ID === Stdlib.Not_found) {
                return Stdlib__List.iter(occur, tl);
              }
              throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
            }
        case /* Tunivar */9 :
            if (!Curry._2(mem$3, t$1, family)) {
              return ;
            }
            throw new Caml_js_exceptions.MelangeError(Occur, {
                      MEL_EXN_ID: Occur
                    });
        case /* Tpoly */10 :
            if (Stdlib__List.exists((function (t) {
                      return Curry._2(mem$3, repr(t), family);
                    }), match._1)) {
              return ;
            }
            _t = match._0;
            continue ;
        default:
          return iter_type_expr(occur, t$1);
      }
    };
  };
  try {
    occur(ty);
    return false;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Occur) {
      return true;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function enter_poly(env, univar_pairs, t1, tl1, t2, tl2, f) {
  const old_univars = univar_pairs.contents;
  const known_univars = Stdlib__List.fold_left((function (s, param) {
          return add_univars(s, param[0]);
        }), /* Empty */0, old_univars);
  const tl1$1 = Stdlib__List.map(repr, tl1);
  const tl2$1 = Stdlib__List.map(repr, tl2);
  if (Stdlib__List.exists((function (t) {
            return Curry._2(mem$3, t, known_univars);
          }), tl1$1) && univars_escape(env, old_univars, tl1$1, newty2(current_level.contents, {
              TAG: /* Tpoly */10,
              _0: t2,
              _1: tl2$1
            })) || Stdlib__List.exists((function (t) {
            return Curry._2(mem$3, t, known_univars);
          }), tl2$1) && univars_escape(env, old_univars, tl2$1, newty2(current_level.contents, {
              TAG: /* Tpoly */10,
              _0: t1,
              _1: tl1$1
            }))) {
    throw new Caml_js_exceptions.MelangeError(Unify, {
              MEL_EXN_ID: Unify,
              _1: /* [] */0
            });
  }
  const cl1 = Stdlib__List.map((function (t) {
          return [
                  t,
                  {
                    contents: undefined
                  }
                ];
        }), tl1$1);
  const cl2 = Stdlib__List.map((function (t) {
          return [
                  t,
                  {
                    contents: undefined
                  }
                ];
        }), tl2$1);
  univar_pairs.contents = {
    hd: [
      cl1,
      cl2
    ],
    tl: {
      hd: [
        cl2,
        cl1
      ],
      tl: old_univars
    }
  };
  try {
    const res = Curry._2(f, t1, t2);
    univar_pairs.contents = old_univars;
    return res;
  }
  catch (exn){
    univar_pairs.contents = old_univars;
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

const univar_pairs = {
  contents: /* [] */0
};

function has_cached_expansion(p, _abbrev) {
  while(true) {
    const abbrev = _abbrev;
    if (typeof abbrev === "number") {
      return false;
    }
    if (abbrev.TAG === /* Mcons */0) {
      if (same(p, abbrev._1)) {
        return true;
      }
      _abbrev = abbrev._4;
      continue ;
    }
    _abbrev = abbrev._0.contents;
    continue ;
  };
}

function expand_trace(env, trace) {
  return Stdlib__List.fold_right((function (param, rem) {
                const t2 = param[1];
                const t1 = param[0];
                return {
                        hd: [
                          repr(t1),
                          full_expand(env, t1)
                        ],
                        tl: {
                          hd: [
                            repr(t2),
                            full_expand(env, t2)
                          ],
                          tl: rem
                        }
                      };
              }), trace, /* [] */0);
}

function mkvariant(fields, closed) {
  return newty2(100000000, {
              TAG: /* Tvariant */8,
              _0: {
                row_fields: fields,
                row_more: newvar(undefined, undefined),
                row_bound: undefined,
                row_closed: closed,
                row_fixed: false,
                row_name: undefined
              }
            });
}

const rigid_variants = {
  contents: false
};

function deep_occur(t0, ty) {
  const occur_rec = function (ty) {
    const ty$1 = repr(ty);
    if (ty$1.level < 0) {
      return ;
    }
    if (ty$1 === t0) {
      throw new Caml_js_exceptions.MelangeError(Occur, {
                MEL_EXN_ID: Occur
              });
    }
    ty$1.level = pivot_level - ty$1.level | 0;
    iter_type_expr(occur_rec, ty$1);
  };
  try {
    occur_rec(ty);
    unmark_type(ty);
    return false;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Occur) {
      unmark_type(ty);
      return true;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

const newtype_level = {
  contents: undefined
};

function get_newtype_level(param) {
  const x = newtype_level.contents;
  if (x !== undefined) {
    return x;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              31961,
              12
            ]
          });
}

function reify(env, t) {
  const newtype_level = get_newtype_level(undefined);
  const create_fresh_constr = function (lev, name) {
    const decl = new_declaration([
          newtype_level,
          newtype_level
        ], undefined);
    const name$1 = get_new_abstract_name(name);
    const match = enter_type(name$1, decl, env.contents);
    const t = newty2(lev, {
          TAG: /* Tconstr */3,
          _0: {
            TAG: /* Pident */0,
            _0: match[0]
          },
          _1: /* [] */0,
          _2: {
            contents: /* Mnil */0
          }
        });
    env.contents = match[1];
    return t;
  };
  const visited = {
    contents: /* Empty */0
  };
  const iterator = function (ty) {
    const ty$1 = repr(ty);
    if (Curry._2(mem$3, ty$1, visited.contents)) {
      return ;
    }
    visited.contents = Curry._2(add$3, ty$1, visited.contents);
    const o = ty$1.desc;
    if (typeof o === "number") {
      return iter_type_expr(iterator, ty$1);
    }
    switch (o.TAG | 0) {
      case /* Tvar */0 :
          const o$1 = o._0;
          const name = o$1 !== undefined ? o$1 : "ex";
          const t = create_fresh_constr(ty$1.level, name);
          return link_type(ty$1, t);
      case /* Tconstr */3 :
          if (is_object_type(o._0)) {
            return iter_type_expr(iterator, full_expand(env.contents, ty$1));
          } else {
            return iter_type_expr(iterator, ty$1);
          }
      case /* Tvariant */8 :
          const r = row_repr_aux(/* [] */0, o._0);
          if (!static_row(r)) {
            if (r.row_fixed) {
              iterator(row_more(r));
            } else {
              const m = r.row_more;
              const o$2 = m.desc;
              if (typeof o$2 === "number") {
                throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                          MEL_EXN_ID: "Assert_failure",
                          _1: [
                            "jscomp/test/ocaml_typedtree_test.ml",
                            31999,
                            19
                          ]
                        });
              }
              if (o$2.TAG === /* Tvar */0) {
                const o$3 = o$2._0;
                const name$1 = o$3 !== undefined ? o$3 : "ex";
                const t$1 = create_fresh_constr(m.level, name$1);
                const row_row_bound = r.row_bound;
                const row_row_closed = r.row_closed;
                const row_row_name = r.row_name;
                const row = {
                  row_fields: /* [] */0,
                  row_more: t$1,
                  row_bound: row_row_bound,
                  row_closed: row_row_closed,
                  row_fixed: true,
                  row_name: row_row_name
                };
                link_type(m, newty2(m.level, {
                          TAG: /* Tvariant */8,
                          _0: row
                        }));
              } else {
                throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                          MEL_EXN_ID: "Assert_failure",
                          _1: [
                            "jscomp/test/ocaml_typedtree_test.ml",
                            31999,
                            19
                          ]
                        });
              }
            }
          }
          return iter_row(iterator, r);
      default:
        return iter_type_expr(iterator, ty$1);
    }
  };
  iterator(t);
}

function is_newtype(env, p) {
  try {
    const decl = find_type_full(p, env)[0];
    if (decl.type_newtype_level !== undefined && Caml_obj.caml_equal(decl.type_kind, /* Type_abstract */0)) {
      return decl.type_private === /* Public */1;
    } else {
      return false;
    }
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return false;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function non_aliasable(p, decl) {
  if (in_current_module(p)) {
    return decl.type_newtype_level === undefined;
  } else {
    return false;
  }
}

function expands_to_datatype(env, ty) {
  const ty$1 = repr(ty);
  const match = ty$1.desc;
  if (typeof match === "number") {
    return false;
  }
  if (match.TAG !== /* Tconstr */3) {
    return false;
  }
  try {
    if (is_datatype(find_type_full(match._0, env)[0])) {
      return true;
    } else {
      return expands_to_datatype(env, try_expand_once(env, ty$1));
    }
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return false;
    }
    if (exn.MEL_EXN_ID === Cannot_expand) {
      return false;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function mcomp(type_pairs, env, _t1, _t2) {
  while(true) {
    const t2 = _t2;
    const t1 = _t1;
    if (t1 === t2) {
      return ;
    }
    const t1$1 = repr(t1);
    const t2$1 = repr(t2);
    if (t1$1 === t2$1) {
      return ;
    }
    const match = t1$1.desc;
    const match$1 = t2$1.desc;
    let exit = 0;
    let exit$1 = 0;
    if (typeof match === "number") {
      exit$1 = 2;
    } else {
      switch (match.TAG | 0) {
        case /* Tvar */0 :
            return ;
        case /* Tconstr */3 :
            if (match._1) {
              exit$1 = 2;
            } else if (typeof match$1 === "number") {
              exit = 1;
            } else {
              switch (match$1.TAG | 0) {
                case /* Tvar */0 :
                    exit$1 = 2;
                    break;
                case /* Tconstr */3 :
                    if (match$1._1) {
                      exit = 1;
                    } else {
                      if (same(match._0, match$1._0)) {
                        return ;
                      }
                      exit = 1;
                    }
                    break;
                default:
                  exit = 1;
              }
            }
            break;
        default:
          exit$1 = 2;
      }
    }
    if (exit$1 === 2) {
      if (typeof match$1 === "number") {
        exit = 1;
      } else {
        if (match$1.TAG === /* Tvar */0) {
          return ;
        }
        exit = 1;
      }
    }
    if (exit === 1) {
      const t1$p = expand_head_opt(env, t1$1);
      const t2$p = expand_head_opt(env, t2$1);
      const t1$p$1 = repr(t1$p);
      const t2$p$1 = repr(t2$p);
      if (t1$p$1 === t2$p$1) {
        return ;
      }
      try {
        return Curry._2(TypePairs.find, type_pairs, [
                    t1$p$1,
                    t2$p$1
                  ]);
      }
      catch (raw_exn){
        const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.MEL_EXN_ID === Stdlib.Not_found) {
          Curry._3(TypePairs.add, type_pairs, [
                t1$p$1,
                t2$p$1
              ], undefined);
          const match$2 = t1$p$1.desc;
          const match$3 = t2$p$1.desc;
          let exit$2 = 0;
          let p;
          let exit$3 = 0;
          if (typeof match$2 === "number") {
            if (typeof match$3 === "number") {
              return ;
            }
            if (match$3.TAG === /* Tconstr */3) {
              exit$3 = 3;
            } else {
              throw new Caml_js_exceptions.MelangeError(Unify, {
                        MEL_EXN_ID: Unify,
                        _1: /* [] */0
                      });
            }
          } else {
            switch (match$2.TAG | 0) {
              case /* Tvar */0 :
                  if (typeof match$3 === "number") {
                    throw new Caml_js_exceptions.MelangeError(Unify, {
                              MEL_EXN_ID: Unify,
                              _1: /* [] */0
                            });
                  }
                  switch (match$3.TAG | 0) {
                    case /* Tvar */0 :
                        throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                                  MEL_EXN_ID: "Assert_failure",
                                  _1: [
                                    "jscomp/test/ocaml_typedtree_test.ml",
                                    32063,
                                    30
                                  ]
                                });
                    case /* Tconstr */3 :
                        exit$3 = 3;
                        break;
                    default:
                      throw new Caml_js_exceptions.MelangeError(Unify, {
                                MEL_EXN_ID: Unify,
                                _1: /* [] */0
                              });
                  }
                  break;
              case /* Tarrow */1 :
                  const l1 = match$2._0;
                  if (typeof match$3 === "number") {
                    throw new Caml_js_exceptions.MelangeError(Unify, {
                              MEL_EXN_ID: Unify,
                              _1: /* [] */0
                            });
                  }
                  switch (match$3.TAG | 0) {
                    case /* Tarrow */1 :
                        const l2 = match$3._0;
                        if (l1 === l2 || !(is_optional(l1) || is_optional(l2))) {
                          mcomp(type_pairs, env, match$2._1, match$3._1);
                          _t2 = match$3._2;
                          _t1 = match$2._2;
                          continue ;
                        }
                        throw new Caml_js_exceptions.MelangeError(Unify, {
                                  MEL_EXN_ID: Unify,
                                  _1: /* [] */0
                                });
                    case /* Tconstr */3 :
                        exit$3 = 3;
                        break;
                    default:
                      throw new Caml_js_exceptions.MelangeError(Unify, {
                                MEL_EXN_ID: Unify,
                                _1: /* [] */0
                              });
                  }
                  break;
              case /* Ttuple */2 :
                  if (typeof match$3 === "number") {
                    throw new Caml_js_exceptions.MelangeError(Unify, {
                              MEL_EXN_ID: Unify,
                              _1: /* [] */0
                            });
                  }
                  switch (match$3.TAG | 0) {
                    case /* Ttuple */2 :
                        return mcomp_list(type_pairs, env, match$2._0, match$3._0);
                    case /* Tconstr */3 :
                        exit$3 = 3;
                        break;
                    default:
                      throw new Caml_js_exceptions.MelangeError(Unify, {
                                MEL_EXN_ID: Unify,
                                _1: /* [] */0
                              });
                  }
                  break;
              case /* Tconstr */3 :
                  const p1 = match$2._0;
                  if (typeof match$3 === "number") {
                    p = p1;
                    exit$2 = 2;
                  } else {
                    if (match$3.TAG === /* Tconstr */3) {
                      let p2 = match$3._0;
                      let tl1 = match$2._1;
                      let tl2 = match$3._1;
                      try {
                        const decl = find_type_full(p1, env)[0];
                        const decl$p = find_type_full(p2, env)[0];
                        if (same(p1, p2)) {
                          let inj;
                          try {
                            inj = Stdlib__List.map(Curry._1(Types_Variance.mem, /* Inj */3), find_type_full(p1, env)[0].type_variance);
                          }
                          catch (raw_exn$1){
                            const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
                            if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
                              inj = Stdlib__List.map((function (param) {
                                      return false;
                                    }), tl1);
                            } else {
                              throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
                            }
                          }
                          return Stdlib__List.iter2((function (i, param) {
                                        if (i) {
                                          return mcomp(type_pairs, env, param[0], param[1]);
                                        }
                                        
                                      }), inj, Stdlib__List.combine(tl1, tl2));
                        }
                        if (non_aliasable(p1, decl) && non_aliasable(p2, decl$p)) {
                          throw new Caml_js_exceptions.MelangeError(Unify, {
                                    MEL_EXN_ID: Unify,
                                    _1: /* [] */0
                                  });
                        }
                        const match$4 = decl.type_kind;
                        const match$5 = decl$p.type_kind;
                        let exit$4 = 0;
                        if (typeof match$4 === "number") {
                          if (match$4 === /* Type_abstract */0) {
                            let exit$5 = 0;
                            if (typeof match$5 === "number") {
                              if (!match$5) {
                                return ;
                              }
                              exit$5 = 2;
                            } else {
                              exit$5 = 2;
                            }
                            if (exit$5 === 2) {
                              if (!non_aliasable(p1, decl)) {
                                return ;
                              }
                              exit$4 = 1;
                            }
                            
                          } else if (typeof match$5 === "number") {
                            if (match$5) {
                              return mcomp_list(type_pairs, env, tl1, tl2);
                            }
                            exit$4 = 1;
                          } else {
                            throw new Caml_js_exceptions.MelangeError(Unify, {
                                      MEL_EXN_ID: Unify,
                                      _1: /* [] */0
                                    });
                          }
                        } else if (match$4.TAG === /* Type_record */0) {
                          if (typeof match$5 === "number") {
                            if (match$5 === /* Type_abstract */0) {
                              exit$4 = 1;
                            } else {
                              throw new Caml_js_exceptions.MelangeError(Unify, {
                                        MEL_EXN_ID: Unify,
                                        _1: /* [] */0
                                      });
                            }
                          } else {
                            if (match$5.TAG === /* Type_record */0) {
                              if (match$4._1 === match$5._1) {
                                mcomp_list(type_pairs, env, tl1, tl2);
                                return mcomp_record_description(type_pairs, env)(match$4._0, match$5._0);
                              }
                              throw new Caml_js_exceptions.MelangeError(Unify, {
                                        MEL_EXN_ID: Unify,
                                        _1: /* [] */0
                                      });
                            }
                            throw new Caml_js_exceptions.MelangeError(Unify, {
                                      MEL_EXN_ID: Unify,
                                      _1: /* [] */0
                                    });
                          }
                        } else if (typeof match$5 === "number") {
                          if (match$5 === /* Type_abstract */0) {
                            exit$4 = 1;
                          } else {
                            throw new Caml_js_exceptions.MelangeError(Unify, {
                                      MEL_EXN_ID: Unify,
                                      _1: /* [] */0
                                    });
                          }
                        } else {
                          if (match$5.TAG === /* Type_record */0) {
                            throw new Caml_js_exceptions.MelangeError(Unify, {
                                      MEL_EXN_ID: Unify,
                                      _1: /* [] */0
                                    });
                          }
                          mcomp_list(type_pairs, env, tl1, tl2);
                          let xs = match$4._0;
                          let ys = match$5._0;
                          let _x = xs;
                          let _y = ys;
                          while(true) {
                            const y = _y;
                            const x = _x;
                            if (x) {
                              if (y) {
                                const c2 = y.hd;
                                const c1 = x.hd;
                                mcomp_type_option(type_pairs, env, c1.cd_res, c2.cd_res);
                                mcomp_list(type_pairs, env, c1.cd_args, c2.cd_args);
                                if (c1.cd_id.name === c2.cd_id.name) {
                                  _y = y.tl;
                                  _x = x.tl;
                                  continue ;
                                }
                                throw new Caml_js_exceptions.MelangeError(Unify, {
                                          MEL_EXN_ID: Unify,
                                          _1: /* [] */0
                                        });
                              }
                              throw new Caml_js_exceptions.MelangeError(Unify, {
                                        MEL_EXN_ID: Unify,
                                        _1: /* [] */0
                                      });
                            }
                            if (!y) {
                              return ;
                            }
                            throw new Caml_js_exceptions.MelangeError(Unify, {
                                      MEL_EXN_ID: Unify,
                                      _1: /* [] */0
                                    });
                          };
                        }
                        if (exit$4 === 1) {
                          if (typeof match$5 === "number") {
                            if (match$5) {
                              throw new Caml_js_exceptions.MelangeError(Unify, {
                                        MEL_EXN_ID: Unify,
                                        _1: /* [] */0
                                      });
                            }
                            if (!non_aliasable(p2, decl$p)) {
                              return ;
                            }
                            throw new Caml_js_exceptions.MelangeError(Unify, {
                                      MEL_EXN_ID: Unify,
                                      _1: /* [] */0
                                    });
                          }
                          throw new Caml_js_exceptions.MelangeError(Unify, {
                                    MEL_EXN_ID: Unify,
                                    _1: /* [] */0
                                  });
                        }
                        
                      }
                      catch (raw_exn$2){
                        const exn$2 = Caml_js_exceptions.internalToOCamlException(raw_exn$2);
                        if (exn$2.MEL_EXN_ID === Stdlib.Not_found) {
                          return ;
                        }
                        throw new Caml_js_exceptions.MelangeError(exn$2.MEL_EXN_ID, exn$2);
                      }
                    }
                    p = p1;
                    exit$2 = 2;
                  }
                  break;
              case /* Tobject */4 :
                  if (typeof match$3 === "number") {
                    throw new Caml_js_exceptions.MelangeError(Unify, {
                              MEL_EXN_ID: Unify,
                              _1: /* [] */0
                            });
                  }
                  switch (match$3.TAG | 0) {
                    case /* Tconstr */3 :
                        exit$3 = 3;
                        break;
                    case /* Tobject */4 :
                        return mcomp_fields(type_pairs, env, match$2._0, match$3._0);
                    default:
                      throw new Caml_js_exceptions.MelangeError(Unify, {
                                MEL_EXN_ID: Unify,
                                _1: /* [] */0
                              });
                  }
                  break;
              case /* Tfield */5 :
                  if (typeof match$3 === "number") {
                    throw new Caml_js_exceptions.MelangeError(Unify, {
                              MEL_EXN_ID: Unify,
                              _1: /* [] */0
                            });
                  }
                  switch (match$3.TAG | 0) {
                    case /* Tconstr */3 :
                        exit$3 = 3;
                        break;
                    case /* Tfield */5 :
                        return mcomp_fields(type_pairs, env, t1$p$1, t2$p$1);
                    default:
                      throw new Caml_js_exceptions.MelangeError(Unify, {
                                MEL_EXN_ID: Unify,
                                _1: /* [] */0
                              });
                  }
                  break;
              case /* Tlink */6 :
              case /* Tsubst */7 :
                  exit$3 = 3;
                  break;
              case /* Tvariant */8 :
                  if (typeof match$3 === "number") {
                    throw new Caml_js_exceptions.MelangeError(Unify, {
                              MEL_EXN_ID: Unify,
                              _1: /* [] */0
                            });
                  }
                  switch (match$3.TAG | 0) {
                    case /* Tconstr */3 :
                        exit$3 = 3;
                        break;
                    case /* Tvariant */8 :
                        let row1 = match$2._0;
                        let row2 = match$3._0;
                        const row1$1 = row_repr_aux(/* [] */0, row1);
                        const row2$1 = row_repr_aux(/* [] */0, row2);
                        const match$6 = merge_row_fields(row1$1.row_fields, row2$1.row_fields);
                        const cannot_erase = function (param) {
                          const match = row_field_repr_aux(/* [] */0, param[1]);
                          if (typeof match === "number" || match.TAG !== /* Rpresent */0) {
                            return false;
                          } else {
                            return true;
                          }
                        };
                        if (row1$1.row_closed && Stdlib__List.exists(cannot_erase, match$6[1]) || row2$1.row_closed && Stdlib__List.exists(cannot_erase, match$6[0])) {
                          throw new Caml_js_exceptions.MelangeError(Unify, {
                                    MEL_EXN_ID: Unify,
                                    _1: /* [] */0
                                  });
                        }
                        return Stdlib__List.iter((function (param) {
                                      const match = row_field_repr_aux(/* [] */0, param[1]);
                                      const match$1 = row_field_repr_aux(/* [] */0, param[2]);
                                      let exit = 0;
                                      let exit$1 = 0;
                                      if (typeof match === "number") {
                                        exit$1 = 2;
                                      } else if (match.TAG === /* Rpresent */0) {
                                        const t1 = match._0;
                                        if (t1 !== undefined) {
                                          if (typeof match$1 === "number") {
                                            throw new Caml_js_exceptions.MelangeError(Unify, {
                                                      MEL_EXN_ID: Unify,
                                                      _1: /* [] */0
                                                    });
                                          }
                                          if (match$1.TAG === /* Rpresent */0) {
                                            const t2 = match$1._0;
                                            if (t2 !== undefined) {
                                              return mcomp(type_pairs, env, t1, t2);
                                            }
                                            throw new Caml_js_exceptions.MelangeError(Unify, {
                                                      MEL_EXN_ID: Unify,
                                                      _1: /* [] */0
                                                    });
                                          }
                                          if (match$1._0) {
                                            throw new Caml_js_exceptions.MelangeError(Unify, {
                                                      MEL_EXN_ID: Unify,
                                                      _1: /* [] */0
                                                    });
                                          }
                                          return Stdlib__List.iter((function (param) {
                                                        return mcomp(type_pairs, env, t1, param);
                                                      }), match$1._1);
                                        } else {
                                          if (typeof match$1 === "number") {
                                            throw new Caml_js_exceptions.MelangeError(Unify, {
                                                      MEL_EXN_ID: Unify,
                                                      _1: /* [] */0
                                                    });
                                          }
                                          if (match$1.TAG === /* Rpresent */0) {
                                            if (match$1._0 === undefined) {
                                              return ;
                                            }
                                            throw new Caml_js_exceptions.MelangeError(Unify, {
                                                      MEL_EXN_ID: Unify,
                                                      _1: /* [] */0
                                                    });
                                          }
                                          if (!match$1._1) {
                                            return ;
                                          }
                                          throw new Caml_js_exceptions.MelangeError(Unify, {
                                                    MEL_EXN_ID: Unify,
                                                    _1: /* [] */0
                                                  });
                                        }
                                      } else {
                                        let exit$2 = 0;
                                        if (match._0 || typeof match$1 === "number" || match$1.TAG !== /* Rpresent */0) {
                                          exit$2 = 3;
                                        } else {
                                          const t2$1 = match$1._0;
                                          if (t2$1 !== undefined) {
                                            return Stdlib__List.iter((function (param) {
                                                          return mcomp(type_pairs, env, t2$1, param);
                                                        }), match._1);
                                          }
                                          exit$2 = 3;
                                        }
                                        if (exit$2 === 3) {
                                          if (match._1) {
                                            exit$1 = 2;
                                          } else {
                                            exit = 1;
                                          }
                                        }
                                        
                                      }
                                      if (exit$1 === 2) {
                                        if (typeof match$1 === "number") {
                                          return ;
                                        }
                                        if (match$1.TAG !== /* Rpresent */0) {
                                          return ;
                                        }
                                        if (match$1._0 !== undefined) {
                                          exit = 1;
                                        } else {
                                          throw new Caml_js_exceptions.MelangeError(Unify, {
                                                    MEL_EXN_ID: Unify,
                                                    _1: /* [] */0
                                                  });
                                        }
                                      }
                                      if (exit === 1) {
                                        let exit$3 = 0;
                                        if (typeof match === "number") {
                                          exit$3 = 2;
                                        } else {
                                          if (!match._0) {
                                            return ;
                                          }
                                          exit$3 = 2;
                                        }
                                        if (exit$3 === 2) {
                                          if (typeof match$1 === "number") {
                                            return ;
                                          }
                                          if (match$1.TAG !== /* Rpresent */0) {
                                            return ;
                                          }
                                          if (match$1._0 === undefined) {
                                            return ;
                                          }
                                          throw new Caml_js_exceptions.MelangeError(Unify, {
                                                    MEL_EXN_ID: Unify,
                                                    _1: /* [] */0
                                                  });
                                        }
                                        
                                      }
                                      
                                    }), match$6[2]);
                    default:
                      throw new Caml_js_exceptions.MelangeError(Unify, {
                                MEL_EXN_ID: Unify,
                                _1: /* [] */0
                              });
                  }
                  break;
              case /* Tunivar */9 :
                  if (typeof match$3 === "number") {
                    throw new Caml_js_exceptions.MelangeError(Unify, {
                              MEL_EXN_ID: Unify,
                              _1: /* [] */0
                            });
                  }
                  switch (match$3.TAG | 0) {
                    case /* Tconstr */3 :
                        exit$3 = 3;
                        break;
                    case /* Tunivar */9 :
                        return unify_univar(t1$p$1, t2$p$1, univar_pairs.contents);
                    default:
                      throw new Caml_js_exceptions.MelangeError(Unify, {
                                MEL_EXN_ID: Unify,
                                _1: /* [] */0
                              });
                  }
                  break;
              case /* Tpoly */10 :
                  const tl1$1 = match$2._1;
                  const t1$2 = match$2._0;
                  let exit$6 = 0;
                  if (tl1$1) {
                    exit$6 = 4;
                  } else {
                    if (typeof match$3 === "number") {
                      throw new Caml_js_exceptions.MelangeError(Unify, {
                                MEL_EXN_ID: Unify,
                                _1: /* [] */0
                              });
                    }
                    switch (match$3.TAG | 0) {
                      case /* Tconstr */3 :
                          exit$3 = 3;
                          break;
                      case /* Tpoly */10 :
                          if (match$3._1) {
                            exit$6 = 4;
                          } else {
                            _t2 = match$3._0;
                            _t1 = t1$2;
                            continue ;
                          }
                          break;
                      default:
                        throw new Caml_js_exceptions.MelangeError(Unify, {
                                  MEL_EXN_ID: Unify,
                                  _1: /* [] */0
                                });
                    }
                  }
                  if (exit$6 === 4) {
                    if (typeof match$3 === "number") {
                      throw new Caml_js_exceptions.MelangeError(Unify, {
                                MEL_EXN_ID: Unify,
                                _1: /* [] */0
                              });
                    }
                    switch (match$3.TAG | 0) {
                      case /* Tconstr */3 :
                          exit$3 = 3;
                          break;
                      case /* Tpoly */10 :
                          return enter_poly(env, univar_pairs, t1$2, tl1$1, match$3._0, match$3._1, (function (param, param$1) {
                                        return mcomp(type_pairs, env, param, param$1);
                                      }));
                      default:
                        throw new Caml_js_exceptions.MelangeError(Unify, {
                                  MEL_EXN_ID: Unify,
                                  _1: /* [] */0
                                });
                    }
                  }
                  break;
              case /* Tpackage */11 :
                  if (typeof match$3 === "number") {
                    throw new Caml_js_exceptions.MelangeError(Unify, {
                              MEL_EXN_ID: Unify,
                              _1: /* [] */0
                            });
                  }
                  switch (match$3.TAG | 0) {
                    case /* Tconstr */3 :
                        exit$3 = 3;
                        break;
                    case /* Tpackage */11 :
                        return ;
                    default:
                      throw new Caml_js_exceptions.MelangeError(Unify, {
                                MEL_EXN_ID: Unify,
                                _1: /* [] */0
                              });
                  }
                  break;
              
            }
          }
          if (exit$3 === 3) {
            if (typeof match$3 === "number") {
              throw new Caml_js_exceptions.MelangeError(Unify, {
                        MEL_EXN_ID: Unify,
                        _1: /* [] */0
                      });
            }
            if (match$3.TAG === /* Tconstr */3) {
              p = match$3._0;
              exit$2 = 2;
            } else {
              throw new Caml_js_exceptions.MelangeError(Unify, {
                        MEL_EXN_ID: Unify,
                        _1: /* [] */0
                      });
            }
          }
          if (exit$2 === 2) {
            try {
              const decl$1 = find_type_full(p, env)[0];
              if (!(non_aliasable(p, decl$1) || is_datatype(decl$1))) {
                return ;
              }
              throw new Caml_js_exceptions.MelangeError(Unify, {
                        MEL_EXN_ID: Unify,
                        _1: /* [] */0
                      });
            }
            catch (raw_exn$3){
              const exn$3 = Caml_js_exceptions.internalToOCamlException(raw_exn$3);
              if (exn$3.MEL_EXN_ID === Stdlib.Not_found) {
                return ;
              }
              throw new Caml_js_exceptions.MelangeError(exn$3.MEL_EXN_ID, exn$3);
            }
          }
          
        } else {
          throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
        }
      }
    }
    
  };
}

function mcomp_list(type_pairs, env, tl1, tl2) {
  if (Stdlib__List.length(tl1) !== Stdlib__List.length(tl2)) {
    throw new Caml_js_exceptions.MelangeError(Unify, {
              MEL_EXN_ID: Unify,
              _1: /* [] */0
            });
  }
  Stdlib__List.iter2((function (param, param$1) {
          return mcomp(type_pairs, env, param, param$1);
        }), tl1, tl2);
}

function mcomp_fields(type_pairs, env, ty1, ty2) {
  if (!(concrete_object(ty1) && concrete_object(ty2))) {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                32108,
                59
              ]
            });
  }
  const match = flatten_fields(ty2);
  const match$1 = flatten_fields(ty1);
  const match$2 = associate_fields(match$1[0], match[0]);
  mcomp(type_pairs, env, match$1[1], match[1]);
  if (Caml_obj.caml_notequal(match$2[1], /* [] */0) && Caml_obj.caml_equal(object_row(ty1).desc, /* Tnil */0) || Caml_obj.caml_notequal(match$2[2], /* [] */0) && Caml_obj.caml_equal(object_row(ty2).desc, /* Tnil */0)) {
    throw new Caml_js_exceptions.MelangeError(Unify, {
              MEL_EXN_ID: Unify,
              _1: /* [] */0
            });
  }
  Stdlib__List.iter((function (param) {
          mcomp_kind(param[1], param[3]);
          mcomp(type_pairs, env, param[2], param[4]);
        }), match$2[0]);
}

function mcomp_kind(k1, k2) {
  const k1$1 = field_kind_repr(k1);
  const k2$1 = field_kind_repr(k2);
  if (typeof k1$1 === "number") {
    if (k1$1) {
      throw new Caml_js_exceptions.MelangeError(Unify, {
                MEL_EXN_ID: Unify,
                _1: /* [] */0
              });
    }
    if (typeof k2$1 === "number") {
      if (!k2$1) {
        return ;
      }
      throw new Caml_js_exceptions.MelangeError(Unify, {
                MEL_EXN_ID: Unify,
                _1: /* [] */0
              });
    }
    throw new Caml_js_exceptions.MelangeError(Unify, {
              MEL_EXN_ID: Unify,
              _1: /* [] */0
            });
  }
  if (typeof k2$1 === "number") {
    throw new Caml_js_exceptions.MelangeError(Unify, {
              MEL_EXN_ID: Unify,
              _1: /* [] */0
            });
  }
  
}

function mcomp_type_option(type_pairs, env, t, t$p) {
  if (t !== undefined) {
    if (t$p !== undefined) {
      return mcomp(type_pairs, env, t, t$p);
    }
    throw new Caml_js_exceptions.MelangeError(Unify, {
              MEL_EXN_ID: Unify,
              _1: /* [] */0
            });
  }
  if (t$p === undefined) {
    return ;
  }
  throw new Caml_js_exceptions.MelangeError(Unify, {
            MEL_EXN_ID: Unify,
            _1: /* [] */0
          });
}

function mcomp_record_description(type_pairs, env) {
  const iter = function (_x, _y) {
    while(true) {
      const y = _y;
      const x = _x;
      if (x) {
        if (y) {
          const l2 = y.hd;
          const l1 = x.hd;
          mcomp(type_pairs, env, l1.ld_type, l2.ld_type);
          if (l1.ld_id.name === l2.ld_id.name && l1.ld_mutable === l2.ld_mutable) {
            _y = y.tl;
            _x = x.tl;
            continue ;
          }
          throw new Caml_js_exceptions.MelangeError(Unify, {
                    MEL_EXN_ID: Unify,
                    _1: /* [] */0
                  });
        }
        throw new Caml_js_exceptions.MelangeError(Unify, {
                  MEL_EXN_ID: Unify,
                  _1: /* [] */0
                });
      }
      if (!y) {
        return ;
      }
      throw new Caml_js_exceptions.MelangeError(Unify, {
                MEL_EXN_ID: Unify,
                _1: /* [] */0
              });
    };
  };
  return iter;
}

function mcomp$1(env, t1, t2) {
  mcomp(Curry._1(TypePairs.create, 4), env, t1, t2);
}

function find_lowest_level(ty) {
  const lowest = {
    contents: 100000000
  };
  const find = function (ty) {
    const ty$1 = repr(ty);
    if (ty$1.level >= 0) {
      if (ty$1.level < lowest.contents) {
        lowest.contents = ty$1.level;
      }
      ty$1.level = pivot_level - ty$1.level | 0;
      return iter_type_expr(find, ty$1);
    }
    
  };
  find(ty);
  unmark_type(ty);
  return lowest.contents;
}

function find_newtype_level(env, path) {
  try {
    const x = find_type_full(path, env)[0].type_newtype_level;
    if (x !== undefined) {
      return x;
    }
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                32239,
                12
              ]
            });
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  32240,
                  20
                ]
              });
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function add_gadt_equation(env, source, destination) {
  const destination$1 = type_expr(identity, destination);
  const source_lev = find_newtype_level(env.contents, {
        TAG: /* Pident */0,
        _0: source
      });
  const decl = new_declaration(source_lev, destination$1);
  const newtype_level = get_newtype_level(undefined);
  env.contents = add_local_constraint(source, decl, newtype_level, env.contents);
  cleanup_abbrev(undefined);
}

const unify_eq_set = Curry._1(TypePairs.create, 11);

function order_type_pair(t1, t2) {
  if (t1.id <= t2.id) {
    return [
            t1,
            t2
          ];
  } else {
    return [
            t2,
            t1
          ];
  }
}

function add_type_equality(t1, t2) {
  Curry._3(TypePairs.add, unify_eq_set, order_type_pair(t1, t2), undefined);
}

function eq_package_path(env, p1, p2) {
  if (same(p1, p2)) {
    return true;
  } else {
    return same(normalize_package_path(env, p1), normalize_package_path(env, p2));
  }
}

const nondep_type$p = {
  contents: (function (param, param$1, param$2) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  32262,
                  37
                ]
              });
    })
};

const package_subtype = {
  contents: (function (param, param$1, param$2, param$3, param$4, param$5, param$6) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  32263,
                  48
                ]
              });
    })
};

function concat_longident(lid1) {
  return function (s) {
    switch (s.TAG | 0) {
      case /* Lident */0 :
          return {
                  TAG: /* Ldot */1,
                  _0: lid1,
                  _1: s._0
                };
      case /* Ldot */1 :
          return {
                  TAG: /* Ldot */1,
                  _0: concat_longident(lid1)(s._0),
                  _1: s._1
                };
      case /* Lapply */2 :
          return {
                  TAG: /* Lapply */2,
                  _0: concat_longident(lid1)(s._0),
                  _1: s._1
                };
      
    }
  };
}

function nondep_instance(env, level, id, ty) {
  const ty$1 = Curry._3(nondep_type$p.contents, env, id, ty);
  if (level === 100000000) {
    return type_expr(identity, ty$1);
  }
  const old = current_level.contents;
  current_level.contents = level;
  const ty$2 = instance(undefined, env, ty$1);
  current_level.contents = old;
  return ty$2;
}

function complete_type_list(allow_absentOpt, env, nl1, lv2, mty2, nl2, tl2) {
  const allow_absent = allow_absentOpt !== undefined ? allow_absentOpt : false;
  const id2 = create("Pkg");
  const env$p = add_module$1(undefined, id2, mty2, env);
  const complete = function (_nl1, ntl2) {
    while(true) {
      const nl1 = _nl1;
      if (!nl1) {
        return ntl2;
      }
      const n = nl1.hd;
      let exit = 0;
      if (ntl2) {
        const nt2 = ntl2.hd;
        const n2 = nt2[0];
        if (Caml_obj.caml_greaterequal(n, n2)) {
          return {
                  hd: nt2,
                  tl: complete(Caml_obj.caml_equal(n, n2) ? nl1.tl : nl1, ntl2.tl)
                };
        }
        exit = 1;
      } else {
        exit = 1;
      }
      if (exit === 1) {
        const nl = nl1.tl;
        try {
          const match = lookup_type$1(concat_longident({
                      TAG: /* Lident */0,
                      _0: "Pkg"
                    })(n), env$p);
          const decl = match[1];
          if (decl.type_arity !== 0) {
            throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                      MEL_EXN_ID: Stdlib.Exit
                    });
          }
          const match$1 = decl.type_kind;
          if (typeof match$1 === "number") {
            if (match$1) {
              throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                        MEL_EXN_ID: Stdlib.Exit
                      });
            }
            if (decl.type_private) {
              const t2 = decl.type_manifest;
              if (t2 !== undefined) {
                return {
                        hd: [
                          n,
                          nondep_instance(env$p, lv2, id2, t2)
                        ],
                        tl: complete(nl, ntl2)
                      };
              }
              if (allow_absent) {
                return complete(nl, ntl2);
              }
              throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                        MEL_EXN_ID: Stdlib.Exit
                      });
            }
            throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                      MEL_EXN_ID: Stdlib.Exit
                    });
          }
          throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                    MEL_EXN_ID: Stdlib.Exit
                  });
        }
        catch (raw_exn){
          const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          let exit$1 = 0;
          if (exn.MEL_EXN_ID === Stdlib.Not_found) {
            if (allow_absent) {
              _nl1 = nl;
              continue ;
            }
            exit$1 = 2;
          } else {
            exit$1 = 2;
          }
          if (exit$1 === 2) {
            if (exn.MEL_EXN_ID === Stdlib.Exit) {
              throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                        MEL_EXN_ID: Stdlib.Not_found
                      });
            }
            throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
          }
          
        }
      }
      
    };
  };
  return complete(nl1, Stdlib__List.combine(nl2, tl2));
}

function unify_package(env, unify_list, lv1, p1, n1, tl1, lv2, p2, n2, tl2) {
  const ntl2 = complete_type_list(undefined, env, n1, lv2, {
        TAG: /* Mty_ident */0,
        _0: p2
      }, n2, tl2);
  const ntl1 = complete_type_list(undefined, env, n2, lv2, {
        TAG: /* Mty_ident */0,
        _0: p1
      }, n1, tl1);
  Curry._2(unify_list, Stdlib__List.map((function (prim) {
              return prim[1];
            }), ntl1), Stdlib__List.map((function (prim) {
              return prim[1];
            }), ntl2));
  if (eq_package_path(env, p1, p2) || Curry._7(package_subtype.contents, env, p1, n1, tl1, p2, n2, tl2) && Curry._7(package_subtype.contents, env, p2, n2, tl2, p1, n1, tl1)) {
    return ;
  }
  throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
}

function unify_eq(env, t1, t2) {
  if (t1 === t2) {
    return true;
  }
  const match = umode.contents;
  if (!match) {
    return false;
  }
  try {
    Curry._2(TypePairs.find, unify_eq_set, order_type_pair(t1, t2));
    return true;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return false;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function unify(env, t1, t2) {
  if (t1 === t2) {
    return ;
  }
  const t1$1 = repr(t1);
  const t2$1 = repr(t2);
  if (unify_eq(env.contents, t1$1, t2$1)) {
    return ;
  }
  const reset_tracing = check_trace_gadt_instances(env.contents);
  try {
    type_changed.contents = true;
    const match = t1$1.desc;
    const match$1 = t2$1.desc;
    let exit = 0;
    if (typeof match === "number") {
      exit = 1;
    } else {
      switch (match.TAG | 0) {
        case /* Tvar */0 :
            let exit$1 = 0;
            if (typeof match$1 === "number" || !(match$1.TAG === /* Tconstr */3 && deep_occur(t1$1, t2$1))) {
              exit$1 = 2;
            } else {
              unify2(env, t1$1, t2$1);
            }
            if (exit$1 === 2) {
              occur(env.contents, t1$1, t2$1);
              occur_univar(env.contents, t2$1);
              link_type(t1$1, t2$1);
              update_level(env.contents, t1$1.level, t2$1);
            }
            break;
        case /* Tconstr */3 :
            const p1 = match._0;
            if (typeof match$1 === "number") {
              unify2(env, t1$1, t2$1);
            } else {
              switch (match$1.TAG | 0) {
                case /* Tvar */0 :
                    if (deep_occur(t2$1, t1$1)) {
                      unify2(env, t1$1, t2$1);
                    } else {
                      exit = 1;
                    }
                    break;
                case /* Tconstr */3 :
                    if (match._1 || match$1._1) {
                      unify2(env, t1$1, t2$1);
                    } else {
                      const p2 = match$1._0;
                      if (same(p1, p2) && !(has_cached_expansion(p1, match._2.contents) || has_cached_expansion(p2, match$1._2.contents))) {
                        update_level(env.contents, t1$1.level, t2$1);
                        link_type(t1$1, t2$1);
                      } else if (env.contents.local_constraints && is_newtype(env.contents, p1) && is_newtype(env.contents, p2)) {
                        try {
                          if (Caml_obj.caml_lessthan(find_newtype_level(env.contents, p1), find_newtype_level(env.contents, p2))) {
                            unify(env, t1$1, try_expand_once(env.contents, t2$1));
                          } else {
                            unify(env, try_expand_once(env.contents, t1$1), t2$1);
                          }
                        }
                        catch (raw_exn){
                          const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                          if (exn.MEL_EXN_ID === Cannot_expand) {
                            unify2(env, t1$1, t2$1);
                          } else {
                            throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
                          }
                        }
                      } else {
                        unify2(env, t1$1, t2$1);
                      }
                    }
                    break;
                default:
                  unify2(env, t1$1, t2$1);
              }
            }
            break;
        case /* Tunivar */9 :
            if (typeof match$1 === "number") {
              unify2(env, t1$1, t2$1);
            } else {
              switch (match$1.TAG | 0) {
                case /* Tvar */0 :
                    exit = 1;
                    break;
                case /* Tunivar */9 :
                    unify_univar(t1$1, t2$1, univar_pairs.contents);
                    update_level(env.contents, t1$1.level, t2$1);
                    link_type(t1$1, t2$1);
                    break;
                default:
                  unify2(env, t1$1, t2$1);
              }
            }
            break;
        default:
          exit = 1;
      }
    }
    if (exit === 1) {
      if (typeof match$1 === "number" || match$1.TAG !== /* Tvar */0) {
        unify2(env, t1$1, t2$1);
      } else {
        occur(env.contents, t2$1, t1$1);
        occur_univar(env.contents, t1$1);
        link_type(t2$1, t1$1);
        update_level(env.contents, t2$1.level, t1$1);
      }
    }
    return reset_trace_gadt_instances(reset_tracing);
  }
  catch (raw_trace){
    const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
    if (trace.MEL_EXN_ID === Unify) {
      reset_trace_gadt_instances(reset_tracing);
      throw new Caml_js_exceptions.MelangeError(Unify, {
                MEL_EXN_ID: Unify,
                _1: {
                  hd: [
                    t1$1,
                    t2$1
                  ],
                  tl: trace._1
                }
              });
    }
    throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
  }
}

function unify_row(env, row1, row2) {
  const row1$1 = row_repr_aux(/* [] */0, row1);
  const row2$1 = row_repr_aux(/* [] */0, row2);
  const rm1 = row_more(row1$1);
  const rm2 = row_more(row2$1);
  if (unify_eq(env.contents, rm1, rm2)) {
    return ;
  }
  const match = merge_row_fields(row1$1.row_fields, row2$1.row_fields);
  const pairs = match[2];
  const r2 = match[1];
  const r1 = match[0];
  if (Caml_obj.caml_notequal(r1, /* [] */0) && Caml_obj.caml_notequal(r2, /* [] */0)) {
    const ht = Stdlib__Hashtbl.create(undefined, Stdlib__List.length(r1));
    Stdlib__List.iter((function (param) {
            const l = param[0];
            Stdlib__Hashtbl.add(ht, hash_variant(l), l);
          }), r1);
    Stdlib__List.iter((function (param) {
            const l = param[0];
            try {
              throw new Caml_js_exceptions.MelangeError(Tags, {
                        MEL_EXN_ID: Tags,
                        _1: l,
                        _2: Stdlib__Hashtbl.find(ht, hash_variant(l))
                      });
            }
            catch (raw_exn){
              const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn.MEL_EXN_ID === Stdlib.Not_found) {
                return ;
              }
              throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
            }
          }), r2);
  }
  const fixed1 = row_fixed(row1$1);
  const fixed2 = row_fixed(row2$1);
  const more = fixed1 ? rm1 : (
      fixed2 ? rm2 : newty2(rm1.level < rm2.level ? rm1.level : rm2.level, {
              TAG: /* Tvar */0,
              _0: undefined
            })
    );
  const fixed = fixed1 || fixed2;
  const closed = row1$1.row_closed || row2$1.row_closed;
  const keep = function ($$switch) {
    return Stdlib__List.for_all((function (param) {
                  const match = Curry._2($$switch, param[1], param[2]);
                  if (Caml_obj.caml_equal(row_field_repr_aux(/* [] */0, match[0]), /* Rabsent */0)) {
                    return true;
                  } else {
                    return Caml_obj.caml_notequal(row_field_repr_aux(/* [] */0, match[1]), /* Rabsent */0);
                  }
                }), pairs);
  };
  const empty = function (fields) {
    return Stdlib__List.for_all((function (param) {
                  return Caml_obj.caml_equal(row_field_repr_aux(/* [] */0, param[1]), /* Rabsent */0);
                }), fields);
  };
  if (closed && (empty(r1) || row2$1.row_closed) && (empty(r2) || row1$1.row_closed) && Stdlib__List.for_all((function (param) {
            if (Caml_obj.caml_equal(row_field_repr_aux(/* [] */0, param[1]), /* Rabsent */0)) {
              return true;
            } else {
              return Caml_obj.caml_equal(row_field_repr_aux(/* [] */0, param[2]), /* Rabsent */0);
            }
          }), pairs)) {
    throw new Caml_js_exceptions.MelangeError(Unify, {
              MEL_EXN_ID: Unify,
              _1: {
                hd: [
                  mkvariant(/* [] */0, true),
                  mkvariant(/* [] */0, true)
                ],
                tl: /* [] */0
              }
            });
  }
  const name = row1$1.row_name !== undefined && (row1$1.row_closed || empty(r2)) && (!row2$1.row_closed || keep(function (f1, f2) {
          return [
                  f1,
                  f2
                ];
        }) && empty(r1)) ? row1$1.row_name : (
      row2$1.row_name !== undefined && (row2$1.row_closed || empty(r1)) && (!row1$1.row_closed || keep(function (f1, f2) {
              return [
                      f2,
                      f1
                    ];
            }) && empty(r2)) ? row2$1.row_name : undefined
    );
  const set_more = function (row, rest) {
    const rest$1 = closed ? filter_row_fields(row.row_closed, rest) : rest;
    if (Caml_obj.caml_notequal(rest$1, /* [] */0) && (row.row_closed || row_fixed(row)) || closed && row_fixed(row) && !row.row_closed) {
      const t1 = mkvariant(/* [] */0, true);
      const t2 = mkvariant(rest$1, false);
      throw new Caml_js_exceptions.MelangeError(Unify, {
                MEL_EXN_ID: Unify,
                _1: {
                  hd: row === row1$1 ? [
                      t1,
                      t2
                    ] : [
                      t2,
                      t1
                    ],
                  tl: /* [] */0
                }
              });
    }
    const rm = row_more(row);
    if (trace_gadt_instances.contents && Caml_obj.caml_equal(rm.desc, /* Tnil */0) || !trace_gadt_instances.contents) {
      
    } else {
      update_level(env.contents, rm.level, newty2(100000000, {
                TAG: /* Tvariant */8,
                _0: row
              }));
    }
    if (row_fixed(row)) {
      if (more === rm) {
        return ;
      } else if (is_Tvar(rm)) {
        return link_type(rm, more);
      } else {
        return unify(env, rm, more);
      }
    }
    const ty = newty2(100000000, {
          TAG: /* Tvariant */8,
          _0: {
            row_fields: rest$1,
            row_more: more,
            row_bound: undefined,
            row_closed: closed,
            row_fixed: fixed,
            row_name: name
          }
        });
    update_level(env.contents, rm.level, ty);
    link_type(rm, ty);
  };
  const md1 = rm1.desc;
  const md2 = rm2.desc;
  try {
    set_more(row2$1, r1);
    set_more(row1$1, r2);
    return Stdlib__List.iter((function (param) {
                  const f2 = param[2];
                  const f1 = param[1];
                  const l = param[0];
                  try {
                    let _f1 = f1;
                    let _f2 = f2;
                    while(true) {
                      const f2$1 = _f2;
                      const f1$1 = _f1;
                      const f1$2 = row_field_repr_aux(/* [] */0, f1$1);
                      const f2$2 = row_field_repr_aux(/* [] */0, f2$1);
                      if (f1$2 === f2$2) {
                        return ;
                      }
                      if (typeof f1$2 === "number") {
                        if (typeof f2$2 === "number") {
                          return ;
                        }
                        if (f2$2.TAG === /* Rpresent */0) {
                          throw new Caml_js_exceptions.MelangeError(Unify, {
                                    MEL_EXN_ID: Unify,
                                    _1: /* [] */0
                                  });
                        }
                        if (f2$2._2) {
                          throw new Caml_js_exceptions.MelangeError(Unify, {
                                    MEL_EXN_ID: Unify,
                                    _1: /* [] */0
                                  });
                        }
                        if (!fixed2) {
                          return set_row_field(f2$2._3, f1$2);
                        }
                        throw new Caml_js_exceptions.MelangeError(Unify, {
                                  MEL_EXN_ID: Unify,
                                  _1: /* [] */0
                                });
                      } else if (f1$2.TAG === /* Rpresent */0) {
                        const t1 = f1$2._0;
                        if (t1 !== undefined) {
                          if (typeof f2$2 === "number") {
                            throw new Caml_js_exceptions.MelangeError(Unify, {
                                      MEL_EXN_ID: Unify,
                                      _1: /* [] */0
                                    });
                          }
                          if (f2$2.TAG === /* Rpresent */0) {
                            const t2 = f2$2._0;
                            if (t2 !== undefined) {
                              return unify(env, t1, t2);
                            }
                            throw new Caml_js_exceptions.MelangeError(Unify, {
                                      MEL_EXN_ID: Unify,
                                      _1: /* [] */0
                                    });
                          }
                          if (f2$2._0) {
                            throw new Caml_js_exceptions.MelangeError(Unify, {
                                      MEL_EXN_ID: Unify,
                                      _1: /* [] */0
                                    });
                          }
                          if (fixed2) {
                            throw new Caml_js_exceptions.MelangeError(Unify, {
                                      MEL_EXN_ID: Unify,
                                      _1: /* [] */0
                                    });
                          }
                          const e2 = f2$2._3;
                          set_row_field(e2, f1$2);
                          update_level(env.contents, repr(more).level, t1);
                          try {
                            return Stdlib__List.iter((function (param) {
                                          return unify(env, t1, param);
                                        }), f2$2._1);
                          }
                          catch (exn){
                            e2.contents = undefined;
                            throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
                          }
                        } else {
                          if (typeof f2$2 === "number") {
                            throw new Caml_js_exceptions.MelangeError(Unify, {
                                      MEL_EXN_ID: Unify,
                                      _1: /* [] */0
                                    });
                          }
                          if (f2$2.TAG === /* Rpresent */0) {
                            if (f2$2._0 === undefined) {
                              return ;
                            }
                            throw new Caml_js_exceptions.MelangeError(Unify, {
                                      MEL_EXN_ID: Unify,
                                      _1: /* [] */0
                                    });
                          }
                          if (f2$2._0) {
                            if (f2$2._1) {
                              throw new Caml_js_exceptions.MelangeError(Unify, {
                                        MEL_EXN_ID: Unify,
                                        _1: /* [] */0
                                      });
                            }
                            if (!fixed2) {
                              return set_row_field(f2$2._3, f1$2);
                            }
                            throw new Caml_js_exceptions.MelangeError(Unify, {
                                      MEL_EXN_ID: Unify,
                                      _1: /* [] */0
                                    });
                          }
                          throw new Caml_js_exceptions.MelangeError(Unify, {
                                    MEL_EXN_ID: Unify,
                                    _1: /* [] */0
                                  });
                        }
                      } else {
                        const c1 = f1$2._0;
                        const m1 = f1$2._2;
                        const tl1 = f1$2._1;
                        const e1 = f1$2._3;
                        if (typeof f2$2 === "number") {
                          if (m1) {
                            throw new Caml_js_exceptions.MelangeError(Unify, {
                                      MEL_EXN_ID: Unify,
                                      _1: /* [] */0
                                    });
                          }
                          if (!fixed1) {
                            return set_row_field(f1$2._3, f2$2);
                          }
                          throw new Caml_js_exceptions.MelangeError(Unify, {
                                    MEL_EXN_ID: Unify,
                                    _1: /* [] */0
                                  });
                        }
                        if (f2$2.TAG === /* Rpresent */0) {
                          if (c1) {
                            if (f1$2._1) {
                              throw new Caml_js_exceptions.MelangeError(Unify, {
                                        MEL_EXN_ID: Unify,
                                        _1: /* [] */0
                                      });
                            }
                            if (f2$2._0 !== undefined) {
                              throw new Caml_js_exceptions.MelangeError(Unify, {
                                        MEL_EXN_ID: Unify,
                                        _1: /* [] */0
                                      });
                            }
                            if (!fixed1) {
                              return set_row_field(f1$2._3, f2$2);
                            }
                            throw new Caml_js_exceptions.MelangeError(Unify, {
                                      MEL_EXN_ID: Unify,
                                      _1: /* [] */0
                                    });
                          }
                          const t2$1 = f2$2._0;
                          if (t2$1 !== undefined) {
                            if (fixed1) {
                              throw new Caml_js_exceptions.MelangeError(Unify, {
                                        MEL_EXN_ID: Unify,
                                        _1: /* [] */0
                                      });
                            }
                            const e1$1 = f1$2._3;
                            set_row_field(e1$1, f2$2);
                            update_level(env.contents, repr(more).level, t2$1);
                            try {
                              return Stdlib__List.iter((function (t1) {
                                            unify(env, t1, t2$1);
                                          }), f1$2._1);
                            }
                            catch (exn$1){
                              e1$1.contents = undefined;
                              throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
                            }
                          } else {
                            throw new Caml_js_exceptions.MelangeError(Unify, {
                                      MEL_EXN_ID: Unify,
                                      _1: /* [] */0
                                    });
                          }
                        } else {
                          const e2$1 = f2$2._3;
                          if (e1 === e2$1) {
                            return ;
                          }
                          const m2 = f2$2._2;
                          const tl2 = f2$2._1;
                          const c2 = f2$2._0;
                          let redo = false;
                          if (m1 || m2 || fixed1 || fixed2 || rigid_variants.contents && (Stdlib__List.length(tl1) === 1 || Stdlib__List.length(tl2) === 1)) {
                            const match = Stdlib.$at(tl1, tl2);
                            let tmp;
                            if (match) {
                              const t1$1 = match.hd;
                              if (c1 || c2) {
                                throw new Caml_js_exceptions.MelangeError(Unify, {
                                          MEL_EXN_ID: Unify,
                                          _1: /* [] */0
                                        });
                              }
                              Stdlib__List.iter((function (param) {
                                      return unify(env, t1$1, param);
                                    }), match.tl);
                              tmp = e1.contents !== undefined || e2$1.contents !== undefined;
                            } else {
                              tmp = false;
                            }
                            redo = tmp;
                          }
                          if (redo) {
                            _f2 = f2$2;
                            _f1 = f1$2;
                            continue ;
                          }
                          const tl1$1 = Stdlib__List.map(repr, tl1);
                          const tl2$1 = Stdlib__List.map(repr, tl2);
                          const remq = function (tl, _param) {
                            while(true) {
                              const param = _param;
                              if (!param) {
                                return /* [] */0;
                              }
                              const tl$p = param.tl;
                              const ty = param.hd;
                              if (!Stdlib__List.memq(ty, tl)) {
                                return {
                                        hd: ty,
                                        tl: remq(tl, tl$p)
                                      };
                              }
                              _param = tl$p;
                              continue ;
                            };
                          };
                          const tl2$p = remq(tl2$1, tl1$1);
                          const tl1$p = remq(tl1$1, tl2$1);
                          const partial_arg = repr(more).level;
                          const partial_arg$1 = env.contents;
                          Stdlib__List.iter((function (param) {
                                  return update_level(partial_arg$1, partial_arg, param);
                                }), Stdlib.$at(tl1$p, tl2$p));
                          const e = {
                            contents: undefined
                          };
                          const f1$p_0 = c1 || c2;
                          const f1$p_2 = m1 || m2;
                          const f1$p = {
                            TAG: /* Reither */1,
                            _0: f1$p_0,
                            _1: tl1$p,
                            _2: f1$p_2,
                            _3: e
                          };
                          const f2$p_0 = c1 || c2;
                          const f2$p_2 = m1 || m2;
                          const f2$p = {
                            TAG: /* Reither */1,
                            _0: f2$p_0,
                            _1: tl2$p,
                            _2: f2$p_2,
                            _3: e
                          };
                          set_row_field(e1, f1$p);
                          return set_row_field(e2$1, f2$p);
                        }
                      }
                    };
                  }
                  catch (raw_trace){
                    const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
                    if (trace.MEL_EXN_ID === Unify) {
                      throw new Caml_js_exceptions.MelangeError(Unify, {
                                MEL_EXN_ID: Unify,
                                _1: {
                                  hd: [
                                    mkvariant({
                                          hd: [
                                            l,
                                            f1
                                          ],
                                          tl: /* [] */0
                                        }, true),
                                    mkvariant({
                                          hd: [
                                            l,
                                            f2
                                          ],
                                          tl: /* [] */0
                                        }, true)
                                  ],
                                  tl: trace._1
                                }
                              });
                    }
                    throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
                  }
                }), pairs);
  }
  catch (exn){
    log_type(rm1);
    rm1.desc = md1;
    log_type(rm2);
    rm2.desc = md2;
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function unify_list(env, tl1, tl2) {
  if (Stdlib__List.length(tl1) !== Stdlib__List.length(tl2)) {
    throw new Caml_js_exceptions.MelangeError(Unify, {
              MEL_EXN_ID: Unify,
              _1: /* [] */0
            });
  }
  Stdlib__List.iter2((function (param, param$1) {
          return unify(env, param, param$1);
        }), tl1, tl2);
}

function unify_fields(env, ty1, ty2) {
  const match = flatten_fields(ty1);
  const rest1 = match[1];
  const match$1 = flatten_fields(ty2);
  const rest2 = match$1[1];
  const match$2 = associate_fields(match[0], match$1[0]);
  const miss2 = match$2[2];
  const miss1 = match$2[1];
  const l1 = repr(ty1).level;
  const l2 = repr(ty2).level;
  const va = make_rowvar(l1 < l2 ? l1 : l2, Caml_obj.caml_equal(miss2, /* [] */0), rest1, Caml_obj.caml_equal(miss1, /* [] */0), rest2);
  const d1 = rest1.desc;
  const d2 = rest2.desc;
  try {
    unify(env, build_fields(l1)(miss1, va), rest2);
    unify(env, rest1, build_fields(l2)(miss2, va));
    return Stdlib__List.iter((function (param) {
                  const t2 = param[4];
                  const k2 = param[3];
                  const t1 = param[2];
                  const k1 = param[1];
                  const n = param[0];
                  unify_kind(k1, k2);
                  try {
                    if (trace_gadt_instances.contents) {
                      update_level(env.contents, va.level, t1);
                    }
                    return unify(env, t1, t2);
                  }
                  catch (raw_trace){
                    const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
                    if (trace.MEL_EXN_ID === Unify) {
                      const desc_3 = newty2(current_level.contents, /* Tnil */0);
                      const desc = {
                        TAG: /* Tfield */5,
                        _0: n,
                        _1: k1,
                        _2: t1,
                        _3: desc_3
                      };
                      const desc_3$1 = newty2(current_level.contents, /* Tnil */0);
                      const desc$1 = {
                        TAG: /* Tfield */5,
                        _0: n,
                        _1: k2,
                        _2: t2,
                        _3: desc_3$1
                      };
                      throw new Caml_js_exceptions.MelangeError(Unify, {
                                MEL_EXN_ID: Unify,
                                _1: {
                                  hd: [
                                    newty2(current_level.contents, desc),
                                    newty2(current_level.contents, desc$1)
                                  ],
                                  tl: trace._1
                                }
                              });
                    }
                    throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
                  }
                }), match$2[0]);
  }
  catch (exn){
    log_type(rest1);
    rest1.desc = d1;
    log_type(rest2);
    rest2.desc = d2;
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function unify2(env, t1, t2) {
  const expand_both = function (_t1$p$p, _t2$p$p) {
    while(true) {
      const t2$p$p = _t2$p$p;
      const t1$p$p = _t1$p$p;
      const t1$p = expand_head_unif(env.contents, t1);
      const t2$p = expand_head_unif(env.contents, t2);
      if (unify_eq(env.contents, t1$p, t1$p$p) && unify_eq(env.contents, t2$p, t2$p$p)) {
        return [
                t1$p,
                t2$p
              ];
      }
      _t2$p$p = t2$p;
      _t1$p$p = t1$p;
      continue ;
    };
  };
  const match = expand_both(t1, t2);
  const t2$p = match[1];
  const t1$p = match[0];
  const lv = t1$p.level < t2$p.level ? t1$p.level : t2$p.level;
  update_level(env.contents, lv, t2);
  update_level(env.contents, lv, t1);
  if (unify_eq(env.contents, t1$p, t2$p)) {
    return ;
  }
  const t1$1 = repr(t1);
  const t2$1 = repr(t2);
  if (trace_gadt_instances.contents) {
    const ilevel = function (t) {
      const lv = gadt_instance_level(env.contents, t);
      if (lv !== undefined) {
        return lv;
      } else {
        return 0;
      }
    };
    const lv1 = ilevel(t1$1);
    const lv2 = ilevel(t2$1);
    if (lv1 > lv2) {
      add_gadt_instance_chain(env.contents, lv1, t2$1);
    } else if (lv2 > lv1) {
      add_gadt_instance_chain(env.contents, lv2, t1$1);
    }
    
  }
  let match$1;
  if (principal.contents && (find_lowest_level(t1$p) < lv || find_lowest_level(t2$p) < lv)) {
    const match$2 = t1$1.desc;
    let tmp;
    tmp = typeof match$2 === "number" || !(match$2.TAG === /* Tconstr */3 && !match$2._1) ? t1$1 : t1$p;
    const match$3 = t2$1.desc;
    let tmp$1;
    tmp$1 = typeof match$3 === "number" || !(match$3.TAG === /* Tconstr */3 && !match$3._1) ? t2$1 : t2$p;
    match$1 = [
      tmp,
      tmp$1
    ];
  } else {
    match$1 = [
      t1$1,
      t2$1
    ];
  }
  const t2$2 = match$1[1];
  const t1$2 = match$1[0];
  if (unify_eq(env.contents, t1$2, t1$p) || !unify_eq(env.contents, t2$2, t2$p)) {
    return unify3(env, t1$2, t1$p, t2$2, t2$p);
  }
  try {
    return unify3(env, t2$2, t2$p, t1$2, t1$p);
  }
  catch (raw_trace){
    const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
    if (trace.MEL_EXN_ID === Unify) {
      throw new Caml_js_exceptions.MelangeError(Unify, {
                MEL_EXN_ID: Unify,
                _1: Stdlib__List.map((function (param) {
                        return [
                                param[1],
                                param[0]
                              ];
                      }), trace._1)
              });
    }
    throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
  }
}

function unify3(env, t1, t1$p, t2, t2$p) {
  const d1 = t1$p.desc;
  const d2 = t2$p.desc;
  const create_recursion = t2 !== t2$p && deep_occur(t1$p, t2);
  let exit = 0;
  let exit$1 = 0;
  if (typeof d1 === "number") {
    exit$1 = 2;
  } else {
    switch (d1.TAG | 0) {
      case /* Tvar */0 :
          occur(env.contents, t1$p, t2);
          occur_univar(env.contents, t2);
          return link_type(t1$p, t2);
      case /* Tfield */5 :
          if (typeof d2 === "number") {
            exit = 1;
          } else {
            switch (d2.TAG | 0) {
              case /* Tvar */0 :
                  exit$1 = 2;
                  break;
              case /* Tfield */5 :
                  return unify_fields(env, t1$p, t2$p);
              default:
                exit = 1;
            }
          }
          break;
      case /* Tunivar */9 :
          if (typeof d2 === "number") {
            exit = 1;
          } else {
            switch (d2.TAG | 0) {
              case /* Tvar */0 :
                  exit$1 = 2;
                  break;
              case /* Tunivar */9 :
                  unify_univar(t1$p, t2$p, univar_pairs.contents);
                  return link_type(t1$p, t2$p);
              default:
                exit = 1;
            }
          }
          break;
      default:
        exit$1 = 2;
    }
  }
  if (exit$1 === 2) {
    if (typeof d2 === "number") {
      exit = 1;
    } else {
      if (d2.TAG === /* Tvar */0) {
        occur(env.contents, t2$p, t1);
        occur_univar(env.contents, t1);
        return link_type(t2$p, t1);
      }
      exit = 1;
    }
  }
  if (exit === 1) {
    const match = umode.contents;
    if (match) {
      add_type_equality(t1$p, t2$p);
    } else {
      occur(env.contents, t1$p, t2$p);
      link_type(t1$p, t2);
    }
    try {
      let exit$2 = 0;
      let f;
      let kind;
      let rem;
      let exit$3 = 0;
      let exit$4 = 0;
      if (typeof d1 === "number") {
        if (typeof d2 !== "number") {
          switch (d2.TAG | 0) {
            case /* Tconstr */3 :
                exit$4 = 5;
                break;
            case /* Tfield */5 :
                f = d2._0;
                kind = d2._1;
                rem = d2._3;
                exit$2 = 3;
                break;
            default:
              throw new Caml_js_exceptions.MelangeError(Unify, {
                        MEL_EXN_ID: Unify,
                        _1: /* [] */0
                      });
          }
        }
        
      } else {
        switch (d1.TAG | 0) {
          case /* Tarrow */1 :
              const l1 = d1._0;
              if (typeof d2 === "number") {
                throw new Caml_js_exceptions.MelangeError(Unify, {
                          MEL_EXN_ID: Unify,
                          _1: /* [] */0
                        });
              }
              switch (d2.TAG | 0) {
                case /* Tarrow */1 :
                    const l2 = d2._0;
                    if (l1 === l2 || classic.contents && !(is_optional(l1) || is_optional(l2))) {
                      unify(env, d1._1, d2._1);
                      unify(env, d1._2, d2._2);
                      const match$1 = commu_repr(d1._3);
                      const match$2 = commu_repr(d2._3);
                      if (typeof match$1 === "number") {
                        if (typeof match$2 === "number") {
                          
                        } else {
                          set_commu(match$2._0, match$1);
                        }
                      } else {
                        set_commu(match$1._0, match$2);
                      }
                    } else {
                      throw new Caml_js_exceptions.MelangeError(Unify, {
                                MEL_EXN_ID: Unify,
                                _1: /* [] */0
                              });
                    }
                    break;
                case /* Tconstr */3 :
                    exit$4 = 5;
                    break;
                default:
                  throw new Caml_js_exceptions.MelangeError(Unify, {
                            MEL_EXN_ID: Unify,
                            _1: /* [] */0
                          });
              }
              break;
          case /* Ttuple */2 :
              if (typeof d2 === "number") {
                throw new Caml_js_exceptions.MelangeError(Unify, {
                          MEL_EXN_ID: Unify,
                          _1: /* [] */0
                        });
              }
              switch (d2.TAG | 0) {
                case /* Ttuple */2 :
                    unify_list(env, d1._0, d2._0);
                    break;
                case /* Tconstr */3 :
                    exit$4 = 5;
                    break;
                default:
                  throw new Caml_js_exceptions.MelangeError(Unify, {
                            MEL_EXN_ID: Unify,
                            _1: /* [] */0
                          });
              }
              break;
          case /* Tconstr */3 :
              const p1 = d1._0;
              let exit$5 = 0;
              if (typeof d2 === "number" || d2.TAG !== /* Tconstr */3) {
                exit$5 = 6;
              } else {
                const tl2 = d2._1;
                const tl1 = d1._1;
                if (same(p1, d2._0)) {
                  if (umode.contents === /* Expression */0 || !generate_equations.contents) {
                    unify_list(env, tl1, tl2);
                  } else if (assume_injective.contents) {
                    set_mode_pattern(true, false, (function (param) {
                            unify_list(env, tl1, tl2);
                          }));
                  } else {
                    let tmp = true;
                    if (!in_current_module(p1)) {
                      const partial_arg = env.contents;
                      tmp = Stdlib__List.exists((function (param) {
                              return expands_to_datatype(partial_arg, param);
                            }), {
                            hd: t1$p,
                            tl: {
                              hd: t1,
                              tl: {
                                hd: t2,
                                tl: /* [] */0
                              }
                            }
                          });
                    }
                    if (tmp) {
                      unify_list(env, tl1, tl2);
                    } else {
                      let inj;
                      try {
                        inj = Stdlib__List.map(Curry._1(Types_Variance.mem, /* Inj */3), find_type_full(p1, env.contents)[0].type_variance);
                      }
                      catch (raw_exn){
                        const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                        if (exn.MEL_EXN_ID === Stdlib.Not_found) {
                          inj = Stdlib__List.map((function (param) {
                                  return false;
                                }), tl1);
                        } else {
                          throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
                        }
                      }
                      Stdlib__List.iter2((function (i, param) {
                              const t2 = param[1];
                              const t1 = param[0];
                              if (i) {
                                return unify(env, t1, t2);
                              } else {
                                return set_mode_pattern(false, false, (function (param) {
                                              const snap = snapshot(undefined);
                                              try {
                                                return unify(env, t1, t2);
                                              }
                                              catch (raw_exn){
                                                const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                                                if (exn.MEL_EXN_ID === Unify) {
                                                  backtrack(snap);
                                                  reify(env, t1);
                                                  return reify(env, t2);
                                                }
                                                throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
                                              }
                                            }));
                              }
                            }), inj, Stdlib__List.combine(tl1, tl2));
                    }
                  }
                } else {
                  exit$5 = 6;
                }
              }
              if (exit$5 === 6) {
                switch (p1.TAG | 0) {
                  case /* Pident */0 :
                      if (d1._1) {
                        exit$4 = 5;
                      } else {
                        const p = p1._0;
                        let exit$6 = 0;
                        if (typeof d2 === "number" || d2.TAG !== /* Tconstr */3) {
                          exit$6 = 7;
                        } else {
                          const path$p = d2._0;
                          switch (path$p.TAG | 0) {
                            case /* Pident */0 :
                                if (d2._1 || !(is_newtype(env.contents, p1) && is_newtype(env.contents, path$p) && generate_equations.contents)) {
                                  exit$6 = 7;
                                } else {
                                  const match$3 = Caml_obj.caml_greaterthan(find_newtype_level(env.contents, p1), find_newtype_level(env.contents, path$p)) ? [
                                      p,
                                      t2$p
                                    ] : [
                                      path$p._0,
                                      t1$p
                                    ];
                                  add_gadt_equation(env, match$3[0], match$3[1]);
                                }
                                break;
                            case /* Pdot */1 :
                            case /* Papply */2 :
                                exit$6 = 7;
                                break;
                            
                          }
                        }
                        if (exit$6 === 7) {
                          if (is_newtype(env.contents, p1) && generate_equations.contents) {
                            reify(env, t2$p);
                            add_gadt_equation(env, p, t2$p);
                          } else {
                            exit$4 = 5;
                          }
                        }
                        
                      }
                      break;
                  case /* Pdot */1 :
                  case /* Papply */2 :
                      exit$4 = 5;
                      break;
                  
                }
              }
              break;
          case /* Tobject */4 :
              if (typeof d2 === "number") {
                throw new Caml_js_exceptions.MelangeError(Unify, {
                          MEL_EXN_ID: Unify,
                          _1: /* [] */0
                        });
              }
              switch (d2.TAG | 0) {
                case /* Tconstr */3 :
                    exit$4 = 5;
                    break;
                case /* Tobject */4 :
                    unify_fields(env, d1._0, d2._0);
                    const match$4 = repr(t2$p).desc;
                    if (typeof match$4 !== "number" && match$4.TAG === /* Tobject */4) {
                      let exit$7 = 0;
                      const match$5 = match$4._1.contents;
                      if (match$5 !== undefined) {
                        const match$6 = match$5[1];
                        if (match$6) {
                          const match$7 = repr(match$6.hd).desc;
                          let tmp$1;
                          if (typeof match$7 === "number") {
                            tmp$1 = true;
                          } else {
                            switch (match$7.TAG | 0) {
                              case /* Tvar */0 :
                              case /* Tunivar */9 :
                                  tmp$1 = true;
                                  break;
                              default:
                                tmp$1 = false;
                            }
                          }
                          if (!tmp$1) {
                            exit$7 = 6;
                          }
                          
                        } else {
                          exit$7 = 6;
                        }
                      } else {
                        exit$7 = 6;
                      }
                      if (exit$7 === 6) {
                        set_name(match$4._1, d1._1.contents);
                      }
                      
                    }
                    break;
                default:
                  throw new Caml_js_exceptions.MelangeError(Unify, {
                            MEL_EXN_ID: Unify,
                            _1: /* [] */0
                          });
              }
              break;
          case /* Tfield */5 :
              if (typeof d2 === "number") {
                f = d1._0;
                kind = d1._1;
                rem = d1._3;
                exit$2 = 3;
              } else if (d2.TAG === /* Tconstr */3) {
                exit$4 = 5;
              } else {
                throw new Caml_js_exceptions.MelangeError(Unify, {
                          MEL_EXN_ID: Unify,
                          _1: /* [] */0
                        });
              }
              break;
          case /* Tvariant */8 :
              const row1 = d1._0;
              if (typeof d2 === "number") {
                throw new Caml_js_exceptions.MelangeError(Unify, {
                          MEL_EXN_ID: Unify,
                          _1: /* [] */0
                        });
              }
              switch (d2.TAG | 0) {
                case /* Tconstr */3 :
                    exit$4 = 5;
                    break;
                case /* Tvariant */8 :
                    const row2 = d2._0;
                    if (umode.contents === /* Expression */0) {
                      unify_row(env, row1, row2);
                    } else {
                      const snap = snapshot(undefined);
                      try {
                        unify_row(env, row1, row2);
                      }
                      catch (raw_exn$1){
                        const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
                        if (exn$1.MEL_EXN_ID === Unify) {
                          backtrack(snap);
                          reify(env, t1$p);
                          reify(env, t2$p);
                          if (generate_equations.contents) {
                            mcomp$1(env.contents, t1$p, t2$p);
                          }
                          
                        } else {
                          throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
                        }
                      }
                    }
                    break;
                default:
                  throw new Caml_js_exceptions.MelangeError(Unify, {
                            MEL_EXN_ID: Unify,
                            _1: /* [] */0
                          });
              }
              break;
          case /* Tpoly */10 :
              const tl1$1 = d1._1;
              const t1$1 = d1._0;
              let exit$8 = 0;
              if (tl1$1) {
                exit$8 = 6;
              } else {
                if (typeof d2 === "number") {
                  throw new Caml_js_exceptions.MelangeError(Unify, {
                            MEL_EXN_ID: Unify,
                            _1: /* [] */0
                          });
                }
                switch (d2.TAG | 0) {
                  case /* Tconstr */3 :
                      exit$4 = 5;
                      break;
                  case /* Tpoly */10 :
                      if (d2._1) {
                        exit$8 = 6;
                      } else {
                        unify(env, t1$1, d2._0);
                      }
                      break;
                  default:
                    throw new Caml_js_exceptions.MelangeError(Unify, {
                              MEL_EXN_ID: Unify,
                              _1: /* [] */0
                            });
                }
              }
              if (exit$8 === 6) {
                if (typeof d2 === "number") {
                  throw new Caml_js_exceptions.MelangeError(Unify, {
                            MEL_EXN_ID: Unify,
                            _1: /* [] */0
                          });
                }
                switch (d2.TAG | 0) {
                  case /* Tconstr */3 :
                      exit$4 = 5;
                      break;
                  case /* Tpoly */10 :
                      enter_poly(env.contents, univar_pairs, t1$1, tl1$1, d2._0, d2._1, (function (param, param$1) {
                              return unify(env, param, param$1);
                            }));
                      break;
                  default:
                    throw new Caml_js_exceptions.MelangeError(Unify, {
                              MEL_EXN_ID: Unify,
                              _1: /* [] */0
                            });
                }
              }
              break;
          case /* Tpackage */11 :
              const tl1$2 = d1._2;
              if (typeof d2 === "number") {
                throw new Caml_js_exceptions.MelangeError(Unify, {
                          MEL_EXN_ID: Unify,
                          _1: /* [] */0
                        });
              }
              switch (d2.TAG | 0) {
                case /* Tconstr */3 :
                    exit$4 = 5;
                    break;
                case /* Tpackage */11 :
                    const tl2$1 = d2._2;
                    try {
                      unify_package(env.contents, (function (param, param$1) {
                              return unify_list(env, param, param$1);
                            }), t1.level, d1._0, d1._1, tl1$2, t2.level, d2._0, d2._1, tl2$1);
                    }
                    catch (raw_exn$2){
                      const exn$2 = Caml_js_exceptions.internalToOCamlException(raw_exn$2);
                      if (exn$2.MEL_EXN_ID === Stdlib.Not_found) {
                        if (umode.contents === /* Expression */0) {
                          throw new Caml_js_exceptions.MelangeError(Unify, {
                                    MEL_EXN_ID: Unify,
                                    _1: /* [] */0
                                  });
                        }
                        Stdlib__List.iter((function (param) {
                                return reify(env, param);
                              }), Stdlib.$at(tl1$2, tl2$1));
                      } else {
                        throw new Caml_js_exceptions.MelangeError(exn$2.MEL_EXN_ID, exn$2);
                      }
                    }
                    break;
                default:
                  throw new Caml_js_exceptions.MelangeError(Unify, {
                            MEL_EXN_ID: Unify,
                            _1: /* [] */0
                          });
              }
              break;
          default:
            exit$4 = 5;
        }
      }
      if (exit$4 === 5) {
        if (typeof d2 === "number" || d2.TAG !== /* Tconstr */3) {
          exit$3 = 4;
        } else {
          const path = d2._0;
          switch (path.TAG | 0) {
            case /* Pident */0 :
                if (d2._1 || !(is_newtype(env.contents, path) && generate_equations.contents)) {
                  exit$2 = 2;
                } else {
                  reify(env, t1$p);
                  add_gadt_equation(env, path._0, t1$p);
                }
                break;
            case /* Pdot */1 :
            case /* Papply */2 :
                exit$2 = 2;
                break;
            
          }
        }
      }
      if (exit$3 === 4) {
        if (typeof d1 === "number") {
          throw new Caml_js_exceptions.MelangeError(Unify, {
                    MEL_EXN_ID: Unify,
                    _1: /* [] */0
                  });
        }
        if (d1.TAG === /* Tconstr */3) {
          exit$2 = 2;
        } else {
          throw new Caml_js_exceptions.MelangeError(Unify, {
                    MEL_EXN_ID: Unify,
                    _1: /* [] */0
                  });
        }
      }
      switch (exit$2) {
        case 2 :
            if (umode.contents === /* Pattern */1) {
              reify(env, t1$p);
              reify(env, t2$p);
              if (generate_equations.contents) {
                mcomp$1(env.contents, t1$p, t2$p);
              }
              
            } else {
              throw new Caml_js_exceptions.MelangeError(Unify, {
                        MEL_EXN_ID: Unify,
                        _1: /* [] */0
                      });
            }
            break;
        case 3 :
            const r = field_kind_repr(kind);
            if (typeof r === "number") {
              throw new Caml_js_exceptions.MelangeError(Unify, {
                        MEL_EXN_ID: Unify,
                        _1: /* [] */0
                      });
            }
            if (f !== dummy_method) {
              set_kind(r._0, /* Fabsent */1);
              if (Caml_obj.caml_equal(d2, /* Tnil */0)) {
                unify(env, rem, t2$p);
              } else {
                unify(env, newty2(rem.level, /* Tnil */0), rem);
              }
            } else {
              throw new Caml_js_exceptions.MelangeError(Unify, {
                        MEL_EXN_ID: Unify,
                        _1: /* [] */0
                      });
            }
            break;
        
      }
      if (!create_recursion) {
        return ;
      }
      const match$8 = t2.desc;
      if (typeof match$8 === "number") {
        return ;
      }
      if (match$8.TAG !== /* Tconstr */3) {
        return ;
      }
      forget_abbrev(match$8._2, match$8._0);
      const t2$p$p = expand_head_unif(env.contents, t2);
      if (!closed_parameterized_type(match$8._1, t2$p$p)) {
        return link_type(repr(t2), repr(t2$p));
      } else {
        return ;
      }
    }
    catch (raw_trace){
      const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
      if (trace.MEL_EXN_ID === Unify) {
        t1$p.desc = d1;
        throw new Caml_js_exceptions.MelangeError(Unify, {
                  MEL_EXN_ID: Unify,
                  _1: trace._1
                });
      }
      throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
    }
  }
  
}

function unify_kind(k1, k2) {
  const k1$1 = field_kind_repr(k1);
  const k2$1 = field_kind_repr(k2);
  if (k1$1 === k2$1) {
    return ;
  }
  if (typeof k1$1 === "number") {
    if (!k1$1) {
      if (typeof k2$1 !== "number") {
        return set_kind(k2$1._0, k1$1);
      }
      if (!k2$1) {
        return ;
      }
      
    }
    
  } else {
    const r = k1$1._0;
    if (typeof k2$1 !== "number") {
      return set_kind(r, k2$1);
    }
    if (!k2$1) {
      return set_kind(r, k2$1);
    }
    
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              32636,
              37
            ]
          });
}

function make_rowvar(level, use1, rest1, use2, rest2) {
  const set_name = function (ty, name) {
    const match = ty.desc;
    if (typeof match === "number" || !(match.TAG === /* Tvar */0 && match._0 === undefined)) {
      return ;
    } else {
      log_type(ty);
      ty.desc = {
        TAG: /* Tvar */0,
        _0: name
      };
      return ;
    }
  };
  const match = rest1.desc;
  const match$1 = rest2.desc;
  let name;
  let exit = 0;
  if (typeof match === "number" || match.TAG !== /* Tvar */0) {
    exit = 1;
  } else {
    const name1 = match._0;
    if (name1 !== undefined) {
      let exit$1 = 0;
      if (typeof match$1 === "number" || match$1.TAG !== /* Tvar */0) {
        exit$1 = 2;
      } else {
        const name2 = match$1._0;
        if (name2 !== undefined) {
          name = rest1.level <= rest2.level ? name1 : name2;
        } else {
          exit$1 = 2;
        }
      }
      if (exit$1 === 2) {
        if (use2) {
          set_name(rest2, name1);
        }
        name = name1;
      }
      
    } else {
      exit = 1;
    }
  }
  if (exit === 1) {
    if (typeof match$1 === "number" || match$1.TAG !== /* Tvar */0) {
      name = undefined;
    } else {
      const name$1 = match$1._0;
      if (name$1 !== undefined) {
        if (use1) {
          set_name(rest2, name$1);
        }
        name = name$1;
      } else {
        name = undefined;
      }
    }
  }
  if (use1) {
    return rest1;
  } else if (use2) {
    return rest2;
  } else {
    return newty2(level, {
                TAG: /* Tvar */0,
                _0: name
              });
  }
}

function unify$1(env, ty1, ty2) {
  try {
    return unify(env, ty1, ty2);
  }
  catch (raw_trace){
    const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
    if (trace.MEL_EXN_ID === Unify) {
      throw new Caml_js_exceptions.MelangeError(Unify, {
                MEL_EXN_ID: Unify,
                _1: expand_trace(env.contents, trace._1)
              });
    }
    if (trace.MEL_EXN_ID === Recursive_abbrev) {
      throw new Caml_js_exceptions.MelangeError(Unification_recursive_abbrev, {
                MEL_EXN_ID: Unification_recursive_abbrev,
                _1: expand_trace(env.contents, {
                      hd: [
                        ty1,
                        ty2
                      ],
                      tl: /* [] */0
                    })
              });
    }
    throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
  }
}

function unify_var(env, t1, t2) {
  const t1$1 = repr(t1);
  const t2$1 = repr(t2);
  if (t1$1 === t2$1) {
    return ;
  }
  const match = t1$1.desc;
  if (typeof match === "number") {
    return unify$1({
                contents: env
              }, t1$1, t2$1);
  }
  if (match.TAG !== /* Tvar */0) {
    return unify$1({
                contents: env
              }, t1$1, t2$1);
  }
  const reset_tracing = check_trace_gadt_instances(env);
  try {
    occur(env, t1$1, t2$1);
    update_level(env, t1$1.level, t2$1);
    link_type(t1$1, t2$1);
    return reset_trace_gadt_instances(reset_tracing);
  }
  catch (raw_trace){
    const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
    if (trace.MEL_EXN_ID === Unify) {
      reset_trace_gadt_instances(reset_tracing);
      const expanded_trace = expand_trace(env, {
            hd: [
              t1$1,
              t2$1
            ],
            tl: trace._1
          });
      throw new Caml_js_exceptions.MelangeError(Unify, {
                MEL_EXN_ID: Unify,
                _1: expanded_trace
              });
    }
    throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
  }
}

unify$p.contents = unify_var;

function unify_pairs(env, ty1, ty2, pairs) {
  univar_pairs.contents = pairs;
  unify$1(env, ty1, ty2);
}

function unify$2(env, ty1, ty2) {
  unify_pairs({
        contents: env
      }, ty1, ty2, /* [] */0);
}

function expand_head_trace(env, t) {
  const reset_tracing = check_trace_gadt_instances(env);
  const t$1 = expand_head_unif(env, t);
  reset_trace_gadt_instances(reset_tracing);
  return t$1;
}

function filter_arrow(env, t, l) {
  const t$1 = expand_head_trace(env, t);
  const match = t$1.desc;
  if (typeof match === "number") {
    throw new Caml_js_exceptions.MelangeError(Unify, {
              MEL_EXN_ID: Unify,
              _1: /* [] */0
            });
  }
  switch (match.TAG | 0) {
    case /* Tvar */0 :
        const lv = t$1.level;
        const t1 = newty2(lv, {
              TAG: /* Tvar */0,
              _0: undefined
            });
        const t2 = newty2(lv, {
              TAG: /* Tvar */0,
              _0: undefined
            });
        const t$p = newty2(lv, {
              TAG: /* Tarrow */1,
              _0: l,
              _1: t1,
              _2: t2,
              _3: /* Cok */0
            });
        link_type(t$1, t$p);
        return [
                t1,
                t2
              ];
    case /* Tarrow */1 :
        const l$p = match._0;
        if (l === l$p || classic.contents && l === "" && !is_optional(l$p)) {
          return [
                  match._1,
                  match._2
                ];
        }
        throw new Caml_js_exceptions.MelangeError(Unify, {
                  MEL_EXN_ID: Unify,
                  _1: /* [] */0
                });
    default:
      throw new Caml_js_exceptions.MelangeError(Unify, {
                MEL_EXN_ID: Unify,
                _1: /* [] */0
              });
  }
}

function filter_method_field(env, name, priv, _ty) {
  while(true) {
    const ty = _ty;
    const ty$1 = expand_head_trace(env, ty);
    const match = ty$1.desc;
    if (typeof match === "number") {
      throw new Caml_js_exceptions.MelangeError(Unify, {
                MEL_EXN_ID: Unify,
                _1: /* [] */0
              });
    }
    switch (match.TAG | 0) {
      case /* Tvar */0 :
          const level = ty$1.level;
          const ty1 = newty2(level, {
                TAG: /* Tvar */0,
                _0: undefined
              });
          const ty2 = newty2(level, {
                TAG: /* Tvar */0,
                _0: undefined
              });
          const ty$p = newty2(level, {
                TAG: /* Tfield */5,
                _0: name,
                _1: priv ? /* Fpresent */0 : /* Fvar */({
                      _0: {
                        contents: undefined
                      }
                    }),
                _2: ty1,
                _3: ty2
              });
          link_type(ty$1, ty$p);
          return ty1;
      case /* Tfield */5 :
          const kind = field_kind_repr(match._1);
          if (match._0 === name && Caml_obj.caml_notequal(kind, /* Fabsent */1)) {
            if (priv === /* Public */1) {
              unify_kind(kind, /* Fpresent */0);
            }
            return match._2;
          }
          _ty = match._3;
          continue ;
      default:
        throw new Caml_js_exceptions.MelangeError(Unify, {
                  MEL_EXN_ID: Unify,
                  _1: /* [] */0
                });
    }
  };
}

function filter_method(env, name, priv, ty) {
  const ty$1 = expand_head_trace(env, ty);
  const match = ty$1.desc;
  if (typeof match === "number") {
    throw new Caml_js_exceptions.MelangeError(Unify, {
              MEL_EXN_ID: Unify,
              _1: /* [] */0
            });
  }
  switch (match.TAG | 0) {
    case /* Tvar */0 :
        const ty1 = newvar(undefined, undefined);
        const ty$p = newobj(ty1);
        update_level(env, ty$1.level, ty$p);
        link_type(ty$1, ty$p);
        return filter_method_field(env, name, priv, ty1);
    case /* Tobject */4 :
        return filter_method_field(env, name, priv, match._0);
    default:
      throw new Caml_js_exceptions.MelangeError(Unify, {
                MEL_EXN_ID: Unify,
                _1: /* [] */0
              });
  }
}

function filter_self_method(env, lab, priv, meths, ty) {
  const ty$p = filter_method(env, lab, priv, ty);
  try {
    return Curry._2(find, lab, meths.contents);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      const pair_0 = create(lab);
      const pair = [
        pair_0,
        ty$p
      ];
      meths.contents = Curry._3(add$1, lab, pair, meths.contents);
      return pair;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function moregen_occur(env, level, ty) {
  const occur = function (ty) {
    const ty$1 = repr(ty);
    if (ty$1.level <= level) {
      return ;
    }
    if (is_Tvar(ty$1) && ty$1.level >= 99999999) {
      throw new Caml_js_exceptions.MelangeError(Occur, {
                MEL_EXN_ID: Occur
              });
    }
    ty$1.level = pivot_level - ty$1.level | 0;
    const row = ty$1.desc;
    if (typeof row === "number") {
      return iter_type_expr(occur, ty$1);
    }
    if (row.TAG !== /* Tvariant */8) {
      return iter_type_expr(occur, ty$1);
    }
    const row$1 = row._0;
    if (static_row(row$1)) {
      return iter_row(occur, row$1);
    } else {
      return iter_type_expr(occur, ty$1);
    }
  };
  try {
    occur(ty);
    unmark_type(ty);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Occur) {
      unmark_type(ty);
      throw new Caml_js_exceptions.MelangeError(Unify, {
                MEL_EXN_ID: Unify,
                _1: /* [] */0
              });
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
  occur_univar(env, ty);
  update_level(env, level, ty);
}

function may_instantiate(inst_nongen, t1) {
  if (inst_nongen) {
    return t1.level !== 99999999;
  } else {
    return t1.level === 100000000;
  }
}

function moregen(inst_nongen, type_pairs, env, t1, t2) {
  if (t1 === t2) {
    return ;
  }
  const t1$1 = repr(t1);
  const t2$1 = repr(t2);
  if (t1$1 === t2$1) {
    return ;
  }
  try {
    const match = t1$1.desc;
    const match$1 = t2$1.desc;
    let exit = 0;
    if (typeof match === "number") {
      exit = 1;
    } else {
      switch (match.TAG | 0) {
        case /* Tvar */0 :
            if (may_instantiate(inst_nongen, t1$1)) {
              moregen_occur(env, t1$1.level, t2$1);
              occur(env, t1$1, t2$1);
              return link_type(t1$1, t2$1);
            }
            exit = 1;
            break;
        case /* Tconstr */3 :
            if (match._1 || typeof match$1 === "number" || !(match$1.TAG === /* Tconstr */3 && !match$1._1)) {
              exit = 1;
            } else {
              if (same(match._0, match$1._0)) {
                return ;
              }
              exit = 1;
            }
            break;
        default:
          exit = 1;
      }
    }
    if (exit === 1) {
      const t1$p = expand_head(env, t1$1);
      const t2$p = expand_head(env, t2$1);
      const t1$p$1 = repr(t1$p);
      const t2$p$1 = repr(t2$p);
      if (t1$p$1 === t2$p$1) {
        return ;
      }
      try {
        return Curry._2(TypePairs.find, type_pairs, [
                    t1$p$1,
                    t2$p$1
                  ]);
      }
      catch (raw_exn){
        const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.MEL_EXN_ID === Stdlib.Not_found) {
          Curry._3(TypePairs.add, type_pairs, [
                t1$p$1,
                t2$p$1
              ], undefined);
          const match$2 = t1$p$1.desc;
          const match$3 = t2$p$1.desc;
          if (typeof match$2 === "number") {
            if (typeof match$3 === "number") {
              return ;
            }
            throw new Caml_js_exceptions.MelangeError(Unify, {
                      MEL_EXN_ID: Unify,
                      _1: /* [] */0
                    });
          }
          switch (match$2.TAG | 0) {
            case /* Tvar */0 :
                if (may_instantiate(inst_nongen, t1$p$1)) {
                  moregen_occur(env, t1$p$1.level, t2$1);
                  return link_type(t1$p$1, t2$1);
                }
                throw new Caml_js_exceptions.MelangeError(Unify, {
                          MEL_EXN_ID: Unify,
                          _1: /* [] */0
                        });
            case /* Tarrow */1 :
                if (typeof match$3 === "number") {
                  throw new Caml_js_exceptions.MelangeError(Unify, {
                            MEL_EXN_ID: Unify,
                            _1: /* [] */0
                          });
                }
                if (match$3.TAG === /* Tarrow */1) {
                  const l2 = match$3._0;
                  const l1 = match$2._0;
                  if (l1 === l2 || classic.contents && !(is_optional(l1) || is_optional(l2))) {
                    moregen(inst_nongen, type_pairs, env, match$2._1, match$3._1);
                    return moregen(inst_nongen, type_pairs, env, match$2._2, match$3._2);
                  }
                  throw new Caml_js_exceptions.MelangeError(Unify, {
                            MEL_EXN_ID: Unify,
                            _1: /* [] */0
                          });
                }
                throw new Caml_js_exceptions.MelangeError(Unify, {
                          MEL_EXN_ID: Unify,
                          _1: /* [] */0
                        });
            case /* Ttuple */2 :
                if (typeof match$3 === "number") {
                  throw new Caml_js_exceptions.MelangeError(Unify, {
                            MEL_EXN_ID: Unify,
                            _1: /* [] */0
                          });
                }
                if (match$3.TAG === /* Ttuple */2) {
                  return moregen_list(inst_nongen, type_pairs, env, match$2._0, match$3._0);
                }
                throw new Caml_js_exceptions.MelangeError(Unify, {
                          MEL_EXN_ID: Unify,
                          _1: /* [] */0
                        });
            case /* Tconstr */3 :
                if (typeof match$3 === "number") {
                  throw new Caml_js_exceptions.MelangeError(Unify, {
                            MEL_EXN_ID: Unify,
                            _1: /* [] */0
                          });
                }
                if (match$3.TAG === /* Tconstr */3) {
                  if (same(match$2._0, match$3._0)) {
                    return moregen_list(inst_nongen, type_pairs, env, match$2._1, match$3._1);
                  }
                  throw new Caml_js_exceptions.MelangeError(Unify, {
                            MEL_EXN_ID: Unify,
                            _1: /* [] */0
                          });
                }
                throw new Caml_js_exceptions.MelangeError(Unify, {
                          MEL_EXN_ID: Unify,
                          _1: /* [] */0
                        });
            case /* Tobject */4 :
                if (typeof match$3 === "number") {
                  throw new Caml_js_exceptions.MelangeError(Unify, {
                            MEL_EXN_ID: Unify,
                            _1: /* [] */0
                          });
                }
                if (match$3.TAG === /* Tobject */4) {
                  return moregen_fields(inst_nongen, type_pairs, env, match$2._0, match$3._0);
                }
                throw new Caml_js_exceptions.MelangeError(Unify, {
                          MEL_EXN_ID: Unify,
                          _1: /* [] */0
                        });
            case /* Tfield */5 :
                if (typeof match$3 === "number") {
                  throw new Caml_js_exceptions.MelangeError(Unify, {
                            MEL_EXN_ID: Unify,
                            _1: /* [] */0
                          });
                }
                if (match$3.TAG === /* Tfield */5) {
                  return moregen_fields(inst_nongen, type_pairs, env, t1$p$1, t2$p$1);
                }
                throw new Caml_js_exceptions.MelangeError(Unify, {
                          MEL_EXN_ID: Unify,
                          _1: /* [] */0
                        });
            case /* Tlink */6 :
            case /* Tsubst */7 :
                throw new Caml_js_exceptions.MelangeError(Unify, {
                          MEL_EXN_ID: Unify,
                          _1: /* [] */0
                        });
            case /* Tvariant */8 :
                if (typeof match$3 === "number") {
                  throw new Caml_js_exceptions.MelangeError(Unify, {
                            MEL_EXN_ID: Unify,
                            _1: /* [] */0
                          });
                }
                if (match$3.TAG === /* Tvariant */8) {
                  let row1 = match$2._0;
                  let row2 = match$3._0;
                  const row1$1 = row_repr_aux(/* [] */0, row1);
                  const row2$1 = row_repr_aux(/* [] */0, row2);
                  const rm1 = repr(row1$1.row_more);
                  const rm2 = repr(row2$1.row_more);
                  if (rm1 === rm2) {
                    return ;
                  }
                  const may_inst = is_Tvar(rm1) && may_instantiate(inst_nongen, rm1) || Caml_obj.caml_equal(rm1.desc, /* Tnil */0);
                  const match$4 = merge_row_fields(row1$1.row_fields, row2$1.row_fields);
                  const r2 = match$4[1];
                  const r1 = match$4[0];
                  const match$5 = row2$1.row_closed ? [
                      filter_row_fields(may_inst, r1),
                      filter_row_fields(false, r2)
                    ] : [
                      r1,
                      r2
                    ];
                  const r2$1 = match$5[1];
                  if (Caml_obj.caml_notequal(match$5[0], /* [] */0) || row1$1.row_closed && (!row2$1.row_closed || Caml_obj.caml_notequal(r2$1, /* [] */0))) {
                    throw new Caml_js_exceptions.MelangeError(Unify, {
                              MEL_EXN_ID: Unify,
                              _1: /* [] */0
                            });
                  }
                  const match$6 = rm1.desc;
                  const match$7 = rm2.desc;
                  let exit$1 = 0;
                  let exit$2 = 0;
                  if (typeof match$6 === "number" || match$6.TAG !== /* Tunivar */9) {
                    exit$2 = 2;
                  } else {
                    if (typeof match$7 === "number") {
                      throw new Caml_js_exceptions.MelangeError(Unify, {
                                MEL_EXN_ID: Unify,
                                _1: /* [] */0
                              });
                    }
                    if (match$7.TAG === /* Tunivar */9) {
                      unify_univar(rm1, rm2, univar_pairs.contents);
                    } else {
                      throw new Caml_js_exceptions.MelangeError(Unify, {
                                MEL_EXN_ID: Unify,
                                _1: /* [] */0
                              });
                    }
                  }
                  if (exit$2 === 2) {
                    if (typeof match$7 === "number") {
                      exit$1 = 1;
                    } else {
                      if (match$7.TAG === /* Tunivar */9) {
                        throw new Caml_js_exceptions.MelangeError(Unify, {
                                  MEL_EXN_ID: Unify,
                                  _1: /* [] */0
                                });
                      }
                      exit$1 = 1;
                    }
                  }
                  if (exit$1 === 1 && !static_row(row1$1)) {
                    if (may_inst) {
                      const ext = newty2(100000000, {
                            TAG: /* Tvariant */8,
                            _0: {
                              row_fields: r2$1,
                              row_more: row2$1.row_more,
                              row_bound: row2$1.row_bound,
                              row_closed: row2$1.row_closed,
                              row_fixed: row2$1.row_fixed,
                              row_name: row2$1.row_name
                            }
                          });
                      moregen_occur(env, rm1.level, ext);
                      link_type(rm1, ext);
                    } else {
                      if (typeof match$6 === "number") {
                        throw new Caml_js_exceptions.MelangeError(Unify, {
                                  MEL_EXN_ID: Unify,
                                  _1: /* [] */0
                                });
                      }
                      if (match$6.TAG === /* Tconstr */3) {
                        if (typeof match$7 === "number") {
                          throw new Caml_js_exceptions.MelangeError(Unify, {
                                    MEL_EXN_ID: Unify,
                                    _1: /* [] */0
                                  });
                        }
                        if (match$7.TAG === /* Tconstr */3) {
                          moregen(inst_nongen, type_pairs, env, rm1, rm2);
                        } else {
                          throw new Caml_js_exceptions.MelangeError(Unify, {
                                    MEL_EXN_ID: Unify,
                                    _1: /* [] */0
                                  });
                        }
                      } else {
                        throw new Caml_js_exceptions.MelangeError(Unify, {
                                  MEL_EXN_ID: Unify,
                                  _1: /* [] */0
                                });
                      }
                    }
                  }
                  return Stdlib__List.iter((function (param) {
                                const f1 = row_field_repr_aux(/* [] */0, param[1]);
                                const f2 = row_field_repr_aux(/* [] */0, param[2]);
                                if (f1 === f2) {
                                  return ;
                                }
                                if (typeof f1 === "number") {
                                  if (typeof f2 === "number") {
                                    return ;
                                  }
                                  throw new Caml_js_exceptions.MelangeError(Unify, {
                                            MEL_EXN_ID: Unify,
                                            _1: /* [] */0
                                          });
                                }
                                if (f1.TAG === /* Rpresent */0) {
                                  const t1 = f1._0;
                                  if (t1 !== undefined) {
                                    if (typeof f2 === "number") {
                                      throw new Caml_js_exceptions.MelangeError(Unify, {
                                                MEL_EXN_ID: Unify,
                                                _1: /* [] */0
                                              });
                                    }
                                    if (f2.TAG === /* Rpresent */0) {
                                      const t2 = f2._0;
                                      if (t2 !== undefined) {
                                        return moregen(inst_nongen, type_pairs, env, t1, t2);
                                      }
                                      throw new Caml_js_exceptions.MelangeError(Unify, {
                                                MEL_EXN_ID: Unify,
                                                _1: /* [] */0
                                              });
                                    }
                                    throw new Caml_js_exceptions.MelangeError(Unify, {
                                              MEL_EXN_ID: Unify,
                                              _1: /* [] */0
                                            });
                                  } else {
                                    if (typeof f2 === "number") {
                                      throw new Caml_js_exceptions.MelangeError(Unify, {
                                                MEL_EXN_ID: Unify,
                                                _1: /* [] */0
                                              });
                                    }
                                    if (f2.TAG === /* Rpresent */0) {
                                      if (f2._0 === undefined) {
                                        return ;
                                      }
                                      throw new Caml_js_exceptions.MelangeError(Unify, {
                                                MEL_EXN_ID: Unify,
                                                _1: /* [] */0
                                              });
                                    }
                                    throw new Caml_js_exceptions.MelangeError(Unify, {
                                              MEL_EXN_ID: Unify,
                                              _1: /* [] */0
                                            });
                                  }
                                } else {
                                  const c1 = f1._0;
                                  if (c1) {
                                    if (!f1._1 && typeof f2 !== "number" && f2.TAG === /* Rpresent */0) {
                                      if (f2._0 !== undefined) {
                                        throw new Caml_js_exceptions.MelangeError(Unify, {
                                                  MEL_EXN_ID: Unify,
                                                  _1: /* [] */0
                                                });
                                      }
                                      if (may_inst) {
                                        return set_row_field(f1._3, f2);
                                      }
                                      throw new Caml_js_exceptions.MelangeError(Unify, {
                                                MEL_EXN_ID: Unify,
                                                _1: /* [] */0
                                              });
                                    }
                                    
                                  } else if (typeof f2 !== "number" && f2.TAG === /* Rpresent */0) {
                                    const t2$1 = f2._0;
                                    if (t2$1 !== undefined) {
                                      if (may_inst) {
                                        set_row_field(f1._3, f2);
                                        return Stdlib__List.iter((function (t1) {
                                                      moregen(inst_nongen, type_pairs, env, t1, t2$1);
                                                    }), f1._1);
                                      }
                                      throw new Caml_js_exceptions.MelangeError(Unify, {
                                                MEL_EXN_ID: Unify,
                                                _1: /* [] */0
                                              });
                                    }
                                    throw new Caml_js_exceptions.MelangeError(Unify, {
                                              MEL_EXN_ID: Unify,
                                              _1: /* [] */0
                                            });
                                  }
                                  const e1 = f1._3;
                                  const tl1 = f1._1;
                                  if (typeof f2 === "number") {
                                    if (may_inst) {
                                      return set_row_field(e1, f2);
                                    }
                                    throw new Caml_js_exceptions.MelangeError(Unify, {
                                              MEL_EXN_ID: Unify,
                                              _1: /* [] */0
                                            });
                                  }
                                  if (f2.TAG === /* Rpresent */0) {
                                    throw new Caml_js_exceptions.MelangeError(Unify, {
                                              MEL_EXN_ID: Unify,
                                              _1: /* [] */0
                                            });
                                  }
                                  const e2 = f2._3;
                                  if (e1 === e2) {
                                    return ;
                                  }
                                  const tl2 = f2._1;
                                  const c2 = f2._0;
                                  if (c1 && !c2) {
                                    throw new Caml_js_exceptions.MelangeError(Unify, {
                                              MEL_EXN_ID: Unify,
                                              _1: /* [] */0
                                            });
                                  }
                                  set_row_field(e1, {
                                        TAG: /* Reither */1,
                                        _0: c2,
                                        _1: /* [] */0,
                                        _2: f2._2,
                                        _3: e2
                                      });
                                  if (Stdlib__List.length(tl1) === Stdlib__List.length(tl2)) {
                                    return Stdlib__List.iter2((function (param, param$1) {
                                                  return moregen(inst_nongen, type_pairs, env, param, param$1);
                                                }), tl1, tl2);
                                  }
                                  if (tl2) {
                                    const t2$2 = tl2.hd;
                                    return Stdlib__List.iter((function (t1) {
                                                  moregen(inst_nongen, type_pairs, env, t1, t2$2);
                                                }), tl1);
                                  }
                                  if (!Caml_obj.caml_notequal(tl1, /* [] */0)) {
                                    return ;
                                  }
                                  throw new Caml_js_exceptions.MelangeError(Unify, {
                                            MEL_EXN_ID: Unify,
                                            _1: /* [] */0
                                          });
                                }
                              }), match$4[2]);
                }
                throw new Caml_js_exceptions.MelangeError(Unify, {
                          MEL_EXN_ID: Unify,
                          _1: /* [] */0
                        });
            case /* Tunivar */9 :
                if (typeof match$3 === "number") {
                  throw new Caml_js_exceptions.MelangeError(Unify, {
                            MEL_EXN_ID: Unify,
                            _1: /* [] */0
                          });
                }
                if (match$3.TAG === /* Tunivar */9) {
                  return unify_univar(t1$p$1, t2$p$1, univar_pairs.contents);
                }
                throw new Caml_js_exceptions.MelangeError(Unify, {
                          MEL_EXN_ID: Unify,
                          _1: /* [] */0
                        });
            case /* Tpoly */10 :
                const tl1 = match$2._1;
                const t1$2 = match$2._0;
                let exit$3 = 0;
                if (tl1) {
                  exit$3 = 2;
                } else {
                  if (typeof match$3 === "number") {
                    throw new Caml_js_exceptions.MelangeError(Unify, {
                              MEL_EXN_ID: Unify,
                              _1: /* [] */0
                            });
                  }
                  if (match$3.TAG === /* Tpoly */10) {
                    if (!match$3._1) {
                      return moregen(inst_nongen, type_pairs, env, t1$2, match$3._0);
                    }
                    exit$3 = 2;
                  } else {
                    throw new Caml_js_exceptions.MelangeError(Unify, {
                              MEL_EXN_ID: Unify,
                              _1: /* [] */0
                            });
                  }
                }
                if (exit$3 === 2) {
                  if (typeof match$3 === "number") {
                    throw new Caml_js_exceptions.MelangeError(Unify, {
                              MEL_EXN_ID: Unify,
                              _1: /* [] */0
                            });
                  }
                  if (match$3.TAG === /* Tpoly */10) {
                    return enter_poly(env, univar_pairs, t1$2, tl1, match$3._0, match$3._1, (function (param, param$1) {
                                  return moregen(inst_nongen, type_pairs, env, param, param$1);
                                }));
                  }
                  throw new Caml_js_exceptions.MelangeError(Unify, {
                            MEL_EXN_ID: Unify,
                            _1: /* [] */0
                          });
                }
                break;
            case /* Tpackage */11 :
                if (typeof match$3 === "number") {
                  throw new Caml_js_exceptions.MelangeError(Unify, {
                            MEL_EXN_ID: Unify,
                            _1: /* [] */0
                          });
                }
                if (match$3.TAG === /* Tpackage */11) {
                  try {
                    return unify_package(env, (function (param, param$1) {
                                  return moregen_list(inst_nongen, type_pairs, env, param, param$1);
                                }), t1$p$1.level, match$2._0, match$2._1, match$2._2, t2$p$1.level, match$3._0, match$3._1, match$3._2);
                  }
                  catch (raw_exn$1){
                    const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
                    if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
                      throw new Caml_js_exceptions.MelangeError(Unify, {
                                MEL_EXN_ID: Unify,
                                _1: /* [] */0
                              });
                    }
                    throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
                  }
                } else {
                  throw new Caml_js_exceptions.MelangeError(Unify, {
                            MEL_EXN_ID: Unify,
                            _1: /* [] */0
                          });
                }
            
          }
        } else {
          throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
        }
      }
    }
    
  }
  catch (raw_trace){
    const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
    if (trace.MEL_EXN_ID === Unify) {
      throw new Caml_js_exceptions.MelangeError(Unify, {
                MEL_EXN_ID: Unify,
                _1: {
                  hd: [
                    t1$1,
                    t2$1
                  ],
                  tl: trace._1
                }
              });
    }
    throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
  }
}

function moregen_list(inst_nongen, type_pairs, env, tl1, tl2) {
  if (Stdlib__List.length(tl1) !== Stdlib__List.length(tl2)) {
    throw new Caml_js_exceptions.MelangeError(Unify, {
              MEL_EXN_ID: Unify,
              _1: /* [] */0
            });
  }
  Stdlib__List.iter2((function (param, param$1) {
          return moregen(inst_nongen, type_pairs, env, param, param$1);
        }), tl1, tl2);
}

function moregen_fields(inst_nongen, type_pairs, env, ty1, ty2) {
  const match = flatten_fields(ty1);
  const match$1 = flatten_fields(ty2);
  const rest2 = match$1[1];
  const match$2 = associate_fields(match[0], match$1[0]);
  if (Caml_obj.caml_notequal(match$2[1], /* [] */0)) {
    throw new Caml_js_exceptions.MelangeError(Unify, {
              MEL_EXN_ID: Unify,
              _1: /* [] */0
            });
  }
  moregen(inst_nongen, type_pairs, env, match[1], build_fields(repr(ty2).level)(match$2[2], rest2));
  Stdlib__List.iter((function (param) {
          const t2 = param[4];
          const k2 = param[3];
          const t1 = param[2];
          const k1 = param[1];
          const n = param[0];
          moregen_kind(k1, k2);
          try {
            return moregen(inst_nongen, type_pairs, env, t1, t2);
          }
          catch (raw_trace){
            const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
            if (trace.MEL_EXN_ID === Unify) {
              throw new Caml_js_exceptions.MelangeError(Unify, {
                        MEL_EXN_ID: Unify,
                        _1: {
                          hd: [
                            newty2(current_level.contents, {
                                  TAG: /* Tfield */5,
                                  _0: n,
                                  _1: k1,
                                  _2: t1,
                                  _3: rest2
                                }),
                            newty2(current_level.contents, {
                                  TAG: /* Tfield */5,
                                  _0: n,
                                  _1: k2,
                                  _2: t2,
                                  _3: rest2
                                })
                          ],
                          tl: trace._1
                        }
                      });
            }
            throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
          }
        }), match$2[0]);
}

function moregen_kind(k1, k2) {
  const k1$1 = field_kind_repr(k1);
  const k2$1 = field_kind_repr(k2);
  if (k1$1 === k2$1) {
    return ;
  }
  if (typeof k1$1 === "number") {
    if (k1$1) {
      throw new Caml_js_exceptions.MelangeError(Unify, {
                MEL_EXN_ID: Unify,
                _1: /* [] */0
              });
    }
    if (typeof k2$1 === "number") {
      if (!k2$1) {
        return ;
      }
      throw new Caml_js_exceptions.MelangeError(Unify, {
                MEL_EXN_ID: Unify,
                _1: /* [] */0
              });
    }
    throw new Caml_js_exceptions.MelangeError(Unify, {
              MEL_EXN_ID: Unify,
              _1: /* [] */0
            });
  }
  const r = k1$1._0;
  if (typeof k2$1 !== "number") {
    return set_kind(r, k2$1);
  }
  if (k2$1) {
    throw new Caml_js_exceptions.MelangeError(Unify, {
              MEL_EXN_ID: Unify,
              _1: /* [] */0
            });
  }
  set_kind(r, k2$1);
}

function moregen$1(inst_nongen, type_pairs, env, patt, subj) {
  univar_pairs.contents = /* [] */0;
  moregen(inst_nongen, type_pairs, env, patt, subj);
}

function moregeneral(env, inst_nongen, pat_sch, subj_sch) {
  const old_level = current_level.contents;
  current_level.contents = 99999999;
  const ty = instance(undefined, env, subj_sch);
  const subj = type_expr(identity, ty);
  current_level.contents = 100000000;
  const patt = instance(undefined, env, pat_sch);
  let res;
  try {
    moregen$1(inst_nongen, Curry._1(TypePairs.create, 13), env, patt, subj);
    res = true;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Unify) {
      res = false;
    } else {
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  }
  current_level.contents = old_level;
  return res;
}

function rigidify_rec(vars, _ty) {
  while(true) {
    const ty = _ty;
    const ty$1 = repr(ty);
    if (ty$1.level < 0) {
      return ;
    }
    ty$1.level = pivot_level - ty$1.level | 0;
    const row = ty$1.desc;
    if (typeof row === "number") {
      return iter_type_expr((function (param) {
                    return rigidify_rec(vars, param);
                  }), ty$1);
    }
    switch (row.TAG | 0) {
      case /* Tvar */0 :
          if (!Stdlib__List.memq(ty$1, vars.contents)) {
            vars.contents = {
              hd: ty$1,
              tl: vars.contents
            };
            return ;
          } else {
            return ;
          }
      case /* Tvariant */8 :
          const row$1 = row_repr_aux(/* [] */0, row._0);
          const more = repr(row$1.row_more);
          if (is_Tvar(more) && !row_fixed(row$1)) {
            const more$p = newty2(more.level, more.desc);
            const row$p_row_bound = row$1.row_bound;
            const row$p_row_closed = row$1.row_closed;
            const row$p_row_name = row$1.row_name;
            const row$p = {
              row_fields: /* [] */0,
              row_more: more$p,
              row_bound: row$p_row_bound,
              row_closed: row$p_row_closed,
              row_fixed: true,
              row_name: row$p_row_name
            };
            link_type(more, newty2(ty$1.level, {
                      TAG: /* Tvariant */8,
                      _0: row$p
                    }));
          }
          iter_row((function (param) {
                  return rigidify_rec(vars, param);
                }), row$1);
          if (static_row(row$1)) {
            return ;
          }
          _ty = row_more(row$1);
          continue ;
      default:
        return iter_type_expr((function (param) {
                      return rigidify_rec(vars, param);
                    }), ty$1);
    }
  };
}

function rigidify(ty) {
  const vars = {
    contents: /* [] */0
  };
  rigidify_rec(vars, ty);
  unmark_type(ty);
  return vars.contents;
}

function all_distinct_vars(env, vars) {
  const tyl = {
    contents: /* [] */0
  };
  return Stdlib__List.for_all((function (ty) {
                const ty$1 = expand_head(env, ty);
                if (Stdlib__List.memq(ty$1, tyl.contents)) {
                  return false;
                } else {
                  tyl.contents = {
                    hd: ty$1,
                    tl: tyl.contents
                  };
                  return is_Tvar(ty$1);
                }
              }), vars);
}

function matches(env, ty, ty$p) {
  const snap = snapshot(undefined);
  const vars = rigidify(ty);
  cleanup_abbrev(undefined);
  let ok;
  try {
    unify$2(env, ty, ty$p);
    ok = all_distinct_vars(env, vars);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Unify) {
      ok = false;
    } else {
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  }
  backtrack(snap);
  return ok;
}

function expand_head_rigid(env, ty) {
  const old = rigid_variants.contents;
  rigid_variants.contents = true;
  const ty$p = expand_head(env, ty);
  rigid_variants.contents = old;
  return ty$p;
}

function normalize_subst(subst) {
  if (Stdlib__List.exists((function (param) {
            const match = param[0].desc;
            if (typeof match !== "number" && match.TAG === /* Tlink */6) {
              return true;
            }
            const match$1 = param[1].desc;
            return typeof match$1 === "number" || match$1.TAG !== /* Tlink */6 ? false : true;
          }), subst.contents)) {
    subst.contents = Stdlib__List.map((function (param) {
            return [
                    repr(param[0]),
                    repr(param[1])
                  ];
          }), subst.contents);
    return ;
  }
  
}

function eqtype(rename, type_pairs, subst, env, t1, t2) {
  if (t1 === t2) {
    return ;
  }
  const t1$1 = repr(t1);
  const t2$1 = repr(t2);
  if (t1$1 === t2$1) {
    return ;
  }
  try {
    const match = t1$1.desc;
    const match$1 = t2$1.desc;
    let exit = 0;
    if (typeof match === "number") {
      exit = 1;
    } else {
      switch (match.TAG | 0) {
        case /* Tvar */0 :
            if (typeof match$1 === "number" || !(match$1.TAG === /* Tvar */0 && rename)) {
              exit = 1;
            } else {
              try {
                normalize_subst(subst);
                if (Stdlib__List.assq(t1$1, subst.contents) === t2$1) {
                  return ;
                }
                throw new Caml_js_exceptions.MelangeError(Unify, {
                          MEL_EXN_ID: Unify,
                          _1: /* [] */0
                        });
              }
              catch (raw_exn){
                const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                if (exn.MEL_EXN_ID === Stdlib.Not_found) {
                  if (Stdlib__List.exists((function (param) {
                            return param[1] === t2$1;
                          }), subst.contents)) {
                    throw new Caml_js_exceptions.MelangeError(Unify, {
                              MEL_EXN_ID: Unify,
                              _1: /* [] */0
                            });
                  }
                  subst.contents = {
                    hd: [
                      t1$1,
                      t2$1
                    ],
                    tl: subst.contents
                  };
                  return ;
                }
                throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
              }
            }
            break;
        case /* Tconstr */3 :
            if (match._1 || typeof match$1 === "number" || !(match$1.TAG === /* Tconstr */3 && !match$1._1)) {
              exit = 1;
            } else {
              if (same(match._0, match$1._0)) {
                return ;
              }
              exit = 1;
            }
            break;
        default:
          exit = 1;
      }
    }
    if (exit === 1) {
      const t1$p = expand_head_rigid(env, t1$1);
      const t2$p = expand_head_rigid(env, t2$1);
      const t1$p$1 = repr(t1$p);
      const t2$p$1 = repr(t2$p);
      if (t1$p$1 === t2$p$1) {
        return ;
      }
      try {
        return Curry._2(TypePairs.find, type_pairs, [
                    t1$p$1,
                    t2$p$1
                  ]);
      }
      catch (raw_exn$1){
        const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
        if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
          Curry._3(TypePairs.add, type_pairs, [
                t1$p$1,
                t2$p$1
              ], undefined);
          const match$2 = t1$p$1.desc;
          const match$3 = t2$p$1.desc;
          if (typeof match$2 === "number") {
            if (typeof match$3 === "number") {
              return ;
            }
            throw new Caml_js_exceptions.MelangeError(Unify, {
                      MEL_EXN_ID: Unify,
                      _1: /* [] */0
                    });
          }
          switch (match$2.TAG | 0) {
            case /* Tvar */0 :
                if (typeof match$3 === "number") {
                  throw new Caml_js_exceptions.MelangeError(Unify, {
                            MEL_EXN_ID: Unify,
                            _1: /* [] */0
                          });
                }
                if (match$3.TAG === /* Tvar */0) {
                  if (rename) {
                    try {
                      normalize_subst(subst);
                      if (Stdlib__List.assq(t1$p$1, subst.contents) === t2$p$1) {
                        return ;
                      }
                      throw new Caml_js_exceptions.MelangeError(Unify, {
                                MEL_EXN_ID: Unify,
                                _1: /* [] */0
                              });
                    }
                    catch (raw_exn$2){
                      const exn$2 = Caml_js_exceptions.internalToOCamlException(raw_exn$2);
                      if (exn$2.MEL_EXN_ID === Stdlib.Not_found) {
                        if (Stdlib__List.exists((function (param) {
                                  return param[1] === t2$p$1;
                                }), subst.contents)) {
                          throw new Caml_js_exceptions.MelangeError(Unify, {
                                    MEL_EXN_ID: Unify,
                                    _1: /* [] */0
                                  });
                        }
                        subst.contents = {
                          hd: [
                            t1$p$1,
                            t2$p$1
                          ],
                          tl: subst.contents
                        };
                        return ;
                      }
                      throw new Caml_js_exceptions.MelangeError(exn$2.MEL_EXN_ID, exn$2);
                    }
                  } else {
                    throw new Caml_js_exceptions.MelangeError(Unify, {
                              MEL_EXN_ID: Unify,
                              _1: /* [] */0
                            });
                  }
                } else {
                  throw new Caml_js_exceptions.MelangeError(Unify, {
                            MEL_EXN_ID: Unify,
                            _1: /* [] */0
                          });
                }
            case /* Tarrow */1 :
                if (typeof match$3 === "number") {
                  throw new Caml_js_exceptions.MelangeError(Unify, {
                            MEL_EXN_ID: Unify,
                            _1: /* [] */0
                          });
                }
                if (match$3.TAG === /* Tarrow */1) {
                  const l2 = match$3._0;
                  const l1 = match$2._0;
                  if (l1 === l2 || classic.contents && !(is_optional(l1) || is_optional(l2))) {
                    eqtype(rename, type_pairs, subst, env, match$2._1, match$3._1);
                    return eqtype(rename, type_pairs, subst, env, match$2._2, match$3._2);
                  }
                  throw new Caml_js_exceptions.MelangeError(Unify, {
                            MEL_EXN_ID: Unify,
                            _1: /* [] */0
                          });
                }
                throw new Caml_js_exceptions.MelangeError(Unify, {
                          MEL_EXN_ID: Unify,
                          _1: /* [] */0
                        });
            case /* Ttuple */2 :
                if (typeof match$3 === "number") {
                  throw new Caml_js_exceptions.MelangeError(Unify, {
                            MEL_EXN_ID: Unify,
                            _1: /* [] */0
                          });
                }
                if (match$3.TAG === /* Ttuple */2) {
                  return eqtype_list(rename, type_pairs, subst, env, match$2._0, match$3._0);
                }
                throw new Caml_js_exceptions.MelangeError(Unify, {
                          MEL_EXN_ID: Unify,
                          _1: /* [] */0
                        });
            case /* Tconstr */3 :
                if (typeof match$3 === "number") {
                  throw new Caml_js_exceptions.MelangeError(Unify, {
                            MEL_EXN_ID: Unify,
                            _1: /* [] */0
                          });
                }
                if (match$3.TAG === /* Tconstr */3) {
                  if (same(match$2._0, match$3._0)) {
                    return eqtype_list(rename, type_pairs, subst, env, match$2._1, match$3._1);
                  }
                  throw new Caml_js_exceptions.MelangeError(Unify, {
                            MEL_EXN_ID: Unify,
                            _1: /* [] */0
                          });
                }
                throw new Caml_js_exceptions.MelangeError(Unify, {
                          MEL_EXN_ID: Unify,
                          _1: /* [] */0
                        });
            case /* Tobject */4 :
                if (typeof match$3 === "number") {
                  throw new Caml_js_exceptions.MelangeError(Unify, {
                            MEL_EXN_ID: Unify,
                            _1: /* [] */0
                          });
                }
                if (match$3.TAG === /* Tobject */4) {
                  return eqtype_fields(rename, type_pairs, subst, env, match$2._0, match$3._0);
                }
                throw new Caml_js_exceptions.MelangeError(Unify, {
                          MEL_EXN_ID: Unify,
                          _1: /* [] */0
                        });
            case /* Tfield */5 :
                if (typeof match$3 === "number") {
                  throw new Caml_js_exceptions.MelangeError(Unify, {
                            MEL_EXN_ID: Unify,
                            _1: /* [] */0
                          });
                }
                if (match$3.TAG === /* Tfield */5) {
                  return eqtype_fields(rename, type_pairs, subst, env, t1$p$1, t2$p$1);
                }
                throw new Caml_js_exceptions.MelangeError(Unify, {
                          MEL_EXN_ID: Unify,
                          _1: /* [] */0
                        });
            case /* Tlink */6 :
            case /* Tsubst */7 :
                throw new Caml_js_exceptions.MelangeError(Unify, {
                          MEL_EXN_ID: Unify,
                          _1: /* [] */0
                        });
            case /* Tvariant */8 :
                if (typeof match$3 === "number") {
                  throw new Caml_js_exceptions.MelangeError(Unify, {
                            MEL_EXN_ID: Unify,
                            _1: /* [] */0
                          });
                }
                if (match$3.TAG === /* Tvariant */8) {
                  let row1 = match$2._0;
                  let _row2 = match$3._0;
                  while(true) {
                    const row2 = _row2;
                    const match$4 = expand_head_rigid(env, row_more(row2));
                    const row2$1 = match$4.desc;
                    if (typeof row2$1 !== "number" && row2$1.TAG === /* Tvariant */8) {
                      _row2 = row2$1._0;
                      continue ;
                    }
                    const row1$1 = row_repr_aux(/* [] */0, row1);
                    const row2$2 = row_repr_aux(/* [] */0, row2);
                    const match$5 = merge_row_fields(row1$1.row_fields, row2$2.row_fields);
                    const r2 = match$5[1];
                    const r1 = match$5[0];
                    if (row1$1.row_closed !== row2$2.row_closed || !row1$1.row_closed && (Caml_obj.caml_notequal(r1, /* [] */0) || Caml_obj.caml_notequal(r2, /* [] */0)) || Caml_obj.caml_notequal(filter_row_fields(false, Stdlib.$at(r1, r2)), /* [] */0)) {
                      throw new Caml_js_exceptions.MelangeError(Unify, {
                                MEL_EXN_ID: Unify,
                                _1: /* [] */0
                              });
                    }
                    if (!static_row(row1$1)) {
                      eqtype(rename, type_pairs, subst, env, row1$1.row_more, row2$2.row_more);
                    }
                    return Stdlib__List.iter((function (param) {
                                  const match = row_field_repr_aux(/* [] */0, param[1]);
                                  const match$1 = row_field_repr_aux(/* [] */0, param[2]);
                                  if (typeof match === "number") {
                                    if (typeof match$1 === "number") {
                                      return ;
                                    }
                                    throw new Caml_js_exceptions.MelangeError(Unify, {
                                              MEL_EXN_ID: Unify,
                                              _1: /* [] */0
                                            });
                                  }
                                  if (match.TAG === /* Rpresent */0) {
                                    const t1 = match._0;
                                    if (t1 !== undefined) {
                                      if (typeof match$1 === "number") {
                                        throw new Caml_js_exceptions.MelangeError(Unify, {
                                                  MEL_EXN_ID: Unify,
                                                  _1: /* [] */0
                                                });
                                      }
                                      if (match$1.TAG === /* Rpresent */0) {
                                        const t2 = match$1._0;
                                        if (t2 !== undefined) {
                                          return eqtype(rename, type_pairs, subst, env, t1, t2);
                                        }
                                        throw new Caml_js_exceptions.MelangeError(Unify, {
                                                  MEL_EXN_ID: Unify,
                                                  _1: /* [] */0
                                                });
                                      }
                                      throw new Caml_js_exceptions.MelangeError(Unify, {
                                                MEL_EXN_ID: Unify,
                                                _1: /* [] */0
                                              });
                                    } else {
                                      if (typeof match$1 === "number") {
                                        throw new Caml_js_exceptions.MelangeError(Unify, {
                                                  MEL_EXN_ID: Unify,
                                                  _1: /* [] */0
                                                });
                                      }
                                      if (match$1.TAG === /* Rpresent */0) {
                                        if (match$1._0 === undefined) {
                                          return ;
                                        }
                                        throw new Caml_js_exceptions.MelangeError(Unify, {
                                                  MEL_EXN_ID: Unify,
                                                  _1: /* [] */0
                                                });
                                      }
                                      throw new Caml_js_exceptions.MelangeError(Unify, {
                                                MEL_EXN_ID: Unify,
                                                _1: /* [] */0
                                              });
                                    }
                                  } else if (match._0) {
                                    if (match._1) {
                                      throw new Caml_js_exceptions.MelangeError(Unify, {
                                                MEL_EXN_ID: Unify,
                                                _1: /* [] */0
                                              });
                                    }
                                    if (typeof match$1 === "number") {
                                      throw new Caml_js_exceptions.MelangeError(Unify, {
                                                MEL_EXN_ID: Unify,
                                                _1: /* [] */0
                                              });
                                    }
                                    if (match$1.TAG === /* Rpresent */0) {
                                      throw new Caml_js_exceptions.MelangeError(Unify, {
                                                MEL_EXN_ID: Unify,
                                                _1: /* [] */0
                                              });
                                    }
                                    if (match$1._0) {
                                      if (match$1._1) {
                                        throw new Caml_js_exceptions.MelangeError(Unify, {
                                                  MEL_EXN_ID: Unify,
                                                  _1: /* [] */0
                                                });
                                      }
                                      return ;
                                    }
                                    throw new Caml_js_exceptions.MelangeError(Unify, {
                                              MEL_EXN_ID: Unify,
                                              _1: /* [] */0
                                            });
                                  } else {
                                    const match$2 = match._1;
                                    if (match$2) {
                                      const tl1 = match$2.tl;
                                      const t1$1 = match$2.hd;
                                      if (typeof match$1 === "number") {
                                        throw new Caml_js_exceptions.MelangeError(Unify, {
                                                  MEL_EXN_ID: Unify,
                                                  _1: /* [] */0
                                                });
                                      }
                                      if (match$1.TAG === /* Rpresent */0) {
                                        throw new Caml_js_exceptions.MelangeError(Unify, {
                                                  MEL_EXN_ID: Unify,
                                                  _1: /* [] */0
                                                });
                                      }
                                      if (match$1._0) {
                                        throw new Caml_js_exceptions.MelangeError(Unify, {
                                                  MEL_EXN_ID: Unify,
                                                  _1: /* [] */0
                                                });
                                      }
                                      const match$3 = match$1._1;
                                      if (match$3) {
                                        const tl2 = match$3.tl;
                                        const t2$1 = match$3.hd;
                                        eqtype(rename, type_pairs, subst, env, t1$1, t2$1);
                                        if (Stdlib__List.length(tl1) === Stdlib__List.length(tl2)) {
                                          return Stdlib__List.iter2((function (param, param$1) {
                                                        return eqtype(rename, type_pairs, subst, env, param, param$1);
                                                      }), tl1, tl2);
                                        } else {
                                          Stdlib__List.iter((function (param) {
                                                  return eqtype(rename, type_pairs, subst, env, t1$1, param);
                                                }), tl2);
                                          return Stdlib__List.iter((function (t1) {
                                                        eqtype(rename, type_pairs, subst, env, t1, t2$1);
                                                      }), tl1);
                                        }
                                      }
                                      throw new Caml_js_exceptions.MelangeError(Unify, {
                                                MEL_EXN_ID: Unify,
                                                _1: /* [] */0
                                              });
                                    } else {
                                      throw new Caml_js_exceptions.MelangeError(Unify, {
                                                MEL_EXN_ID: Unify,
                                                _1: /* [] */0
                                              });
                                    }
                                  }
                                }), match$5[2]);
                  };
                }
                throw new Caml_js_exceptions.MelangeError(Unify, {
                          MEL_EXN_ID: Unify,
                          _1: /* [] */0
                        });
            case /* Tunivar */9 :
                if (typeof match$3 === "number") {
                  throw new Caml_js_exceptions.MelangeError(Unify, {
                            MEL_EXN_ID: Unify,
                            _1: /* [] */0
                          });
                }
                if (match$3.TAG === /* Tunivar */9) {
                  return unify_univar(t1$p$1, t2$p$1, univar_pairs.contents);
                }
                throw new Caml_js_exceptions.MelangeError(Unify, {
                          MEL_EXN_ID: Unify,
                          _1: /* [] */0
                        });
            case /* Tpoly */10 :
                const tl1 = match$2._1;
                const t1$2 = match$2._0;
                let exit$1 = 0;
                if (tl1) {
                  exit$1 = 2;
                } else {
                  if (typeof match$3 === "number") {
                    throw new Caml_js_exceptions.MelangeError(Unify, {
                              MEL_EXN_ID: Unify,
                              _1: /* [] */0
                            });
                  }
                  if (match$3.TAG === /* Tpoly */10) {
                    if (!match$3._1) {
                      return eqtype(rename, type_pairs, subst, env, t1$2, match$3._0);
                    }
                    exit$1 = 2;
                  } else {
                    throw new Caml_js_exceptions.MelangeError(Unify, {
                              MEL_EXN_ID: Unify,
                              _1: /* [] */0
                            });
                  }
                }
                if (exit$1 === 2) {
                  if (typeof match$3 === "number") {
                    throw new Caml_js_exceptions.MelangeError(Unify, {
                              MEL_EXN_ID: Unify,
                              _1: /* [] */0
                            });
                  }
                  if (match$3.TAG === /* Tpoly */10) {
                    return enter_poly(env, univar_pairs, t1$2, tl1, match$3._0, match$3._1, (function (param, param$1) {
                                  return eqtype(rename, type_pairs, subst, env, param, param$1);
                                }));
                  }
                  throw new Caml_js_exceptions.MelangeError(Unify, {
                            MEL_EXN_ID: Unify,
                            _1: /* [] */0
                          });
                }
                break;
            case /* Tpackage */11 :
                if (typeof match$3 === "number") {
                  throw new Caml_js_exceptions.MelangeError(Unify, {
                            MEL_EXN_ID: Unify,
                            _1: /* [] */0
                          });
                }
                if (match$3.TAG === /* Tpackage */11) {
                  try {
                    return unify_package(env, (function (param, param$1) {
                                  return eqtype_list(rename, type_pairs, subst, env, param, param$1);
                                }), t1$p$1.level, match$2._0, match$2._1, match$2._2, t2$p$1.level, match$3._0, match$3._1, match$3._2);
                  }
                  catch (raw_exn$3){
                    const exn$3 = Caml_js_exceptions.internalToOCamlException(raw_exn$3);
                    if (exn$3.MEL_EXN_ID === Stdlib.Not_found) {
                      throw new Caml_js_exceptions.MelangeError(Unify, {
                                MEL_EXN_ID: Unify,
                                _1: /* [] */0
                              });
                    }
                    throw new Caml_js_exceptions.MelangeError(exn$3.MEL_EXN_ID, exn$3);
                  }
                } else {
                  throw new Caml_js_exceptions.MelangeError(Unify, {
                            MEL_EXN_ID: Unify,
                            _1: /* [] */0
                          });
                }
            
          }
        } else {
          throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
        }
      }
    }
    
  }
  catch (raw_trace){
    const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
    if (trace.MEL_EXN_ID === Unify) {
      throw new Caml_js_exceptions.MelangeError(Unify, {
                MEL_EXN_ID: Unify,
                _1: {
                  hd: [
                    t1$1,
                    t2$1
                  ],
                  tl: trace._1
                }
              });
    }
    throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
  }
}

function eqtype_list(rename, type_pairs, subst, env, tl1, tl2) {
  if (Stdlib__List.length(tl1) !== Stdlib__List.length(tl2)) {
    throw new Caml_js_exceptions.MelangeError(Unify, {
              MEL_EXN_ID: Unify,
              _1: /* [] */0
            });
  }
  Stdlib__List.iter2((function (param, param$1) {
          return eqtype(rename, type_pairs, subst, env, param, param$1);
        }), tl1, tl2);
}

function eqtype_fields(rename, type_pairs, subst, env, ty1, _ty2) {
  while(true) {
    const ty2 = _ty2;
    const match = flatten_fields(ty1);
    const rest1 = match[1];
    const match$1 = flatten_fields(ty2);
    const rest2 = match$1[1];
    const same_row = rest1 === rest2 || Curry._2(TypePairs.mem, type_pairs, [
          rest1,
          rest2
        ]) || rename && Stdlib__List.mem([
          rest1,
          rest2
        ], subst.contents);
    if (same_row) {
      return ;
    }
    const match$2 = expand_head_rigid(env, rest2);
    const match$3 = match$2.desc;
    if (typeof match$3 !== "number" && match$3.TAG === /* Tobject */4) {
      _ty2 = match$3._0;
      continue ;
    }
    const match$4 = associate_fields(match[0], match$1[0]);
    eqtype(rename, type_pairs, subst, env, rest1, rest2);
    if (Caml_obj.caml_notequal(match$4[1], /* [] */0) || Caml_obj.caml_notequal(match$4[2], /* [] */0)) {
      throw new Caml_js_exceptions.MelangeError(Unify, {
                MEL_EXN_ID: Unify,
                _1: /* [] */0
              });
    }
    return Stdlib__List.iter((function (param) {
                  const t2 = param[4];
                  const k2 = param[3];
                  const t1 = param[2];
                  const k1 = param[1];
                  const n = param[0];
                  eqtype_kind(k1, k2);
                  try {
                    return eqtype(rename, type_pairs, subst, env, t1, t2);
                  }
                  catch (raw_trace){
                    const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
                    if (trace.MEL_EXN_ID === Unify) {
                      throw new Caml_js_exceptions.MelangeError(Unify, {
                                MEL_EXN_ID: Unify,
                                _1: {
                                  hd: [
                                    newty2(current_level.contents, {
                                          TAG: /* Tfield */5,
                                          _0: n,
                                          _1: k1,
                                          _2: t1,
                                          _3: rest2
                                        }),
                                    newty2(current_level.contents, {
                                          TAG: /* Tfield */5,
                                          _0: n,
                                          _1: k2,
                                          _2: t2,
                                          _3: rest2
                                        })
                                  ],
                                  tl: trace._1
                                }
                              });
                    }
                    throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
                  }
                }), match$4[0]);
  };
}

function eqtype_kind(k1, k2) {
  const k1$1 = field_kind_repr(k1);
  const k2$1 = field_kind_repr(k2);
  if (typeof k1$1 === "number") {
    if (k1$1) {
      throw new Caml_js_exceptions.MelangeError(Unify, {
                MEL_EXN_ID: Unify,
                _1: /* [] */0
              });
    }
    if (typeof k2$1 === "number") {
      if (!k2$1) {
        return ;
      }
      throw new Caml_js_exceptions.MelangeError(Unify, {
                MEL_EXN_ID: Unify,
                _1: /* [] */0
              });
    }
    throw new Caml_js_exceptions.MelangeError(Unify, {
              MEL_EXN_ID: Unify,
              _1: /* [] */0
            });
  }
  if (typeof k2$1 === "number") {
    throw new Caml_js_exceptions.MelangeError(Unify, {
              MEL_EXN_ID: Unify,
              _1: /* [] */0
            });
  }
  
}

function equal$5(env, rename, tyl1, tyl2) {
  try {
    univar_pairs.contents = /* [] */0;
    eqtype_list(rename, Curry._1(TypePairs.create, 11), {
          contents: /* [] */0
        }, env, tyl1, tyl2);
    return true;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Unify) {
      return false;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function eqtype$1(rename, type_pairs, subst, env, t1, t2) {
  univar_pairs.contents = /* [] */0;
  eqtype(rename, type_pairs, subst, env, t1, t2);
}

const Failure = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Failure");

function moregen_clty(trace, type_pairs, env, cty1, cty2) {
  try {
    let exit = 0;
    switch (cty1.TAG | 0) {
      case /* Cty_constr */0 :
          return moregen_clty(true, type_pairs, env, cty1._2, cty2);
      case /* Cty_signature */1 :
          const sign1 = cty1._0;
          switch (cty2.TAG | 0) {
            case /* Cty_constr */0 :
                exit = 1;
                break;
            case /* Cty_signature */1 :
                const sign2 = cty2._0;
                const ty1 = object_fields(repr(sign1.csig_self));
                const ty2 = object_fields(repr(sign2.csig_self));
                const match = flatten_fields(ty1);
                const match$1 = flatten_fields(ty2);
                const match$2 = associate_fields(match[0], match$1[0]);
                Stdlib__List.iter((function (param) {
                        try {
                          return moregen$1(true, type_pairs, env, param[2], param[4]);
                        }
                        catch (raw_trace){
                          const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
                          if (trace.MEL_EXN_ID === Unify) {
                            throw new Caml_js_exceptions.MelangeError(Failure, {
                                      MEL_EXN_ID: Failure,
                                      _1: {
                                        hd: {
                                          TAG: /* CM_Meth_type_mismatch */5,
                                          _0: param[0],
                                          _1: env,
                                          _2: expand_trace(env, trace._1)
                                        },
                                        tl: /* [] */0
                                      }
                                    });
                          }
                          throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
                        }
                      }), match$2[0]);
                return Curry._2(Meths.iter, (function (lab, param) {
                              const match = Curry._2(Meths.find, lab, sign1.csig_vars);
                              try {
                                return moregen$1(true, type_pairs, env, match[2], param[2]);
                              }
                              catch (raw_trace){
                                const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
                                if (trace.MEL_EXN_ID === Unify) {
                                  throw new Caml_js_exceptions.MelangeError(Failure, {
                                            MEL_EXN_ID: Failure,
                                            _1: {
                                              hd: {
                                                TAG: /* CM_Val_type_mismatch */4,
                                                _0: lab,
                                                _1: env,
                                                _2: expand_trace(env, trace._1)
                                              },
                                              tl: /* [] */0
                                            }
                                          });
                                }
                                throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
                              }
                            }), sign2.csig_vars);
            case /* Cty_arrow */2 :
                throw new Caml_js_exceptions.MelangeError(Failure, {
                          MEL_EXN_ID: Failure,
                          _1: /* [] */0
                        });
            
          }
          break;
      case /* Cty_arrow */2 :
          switch (cty2.TAG | 0) {
            case /* Cty_constr */0 :
                exit = 1;
                break;
            case /* Cty_signature */1 :
                throw new Caml_js_exceptions.MelangeError(Failure, {
                          MEL_EXN_ID: Failure,
                          _1: /* [] */0
                        });
            case /* Cty_arrow */2 :
                if (cty1._0 === cty2._0) {
                  try {
                    moregen$1(true, type_pairs, env, cty1._1, cty2._1);
                  }
                  catch (raw_trace){
                    const trace$1 = Caml_js_exceptions.internalToOCamlException(raw_trace);
                    if (trace$1.MEL_EXN_ID === Unify) {
                      throw new Caml_js_exceptions.MelangeError(Failure, {
                                MEL_EXN_ID: Failure,
                                _1: {
                                  hd: {
                                    TAG: /* CM_Parameter_mismatch */3,
                                    _0: env,
                                    _1: expand_trace(env, trace$1._1)
                                  },
                                  tl: /* [] */0
                                }
                              });
                    }
                    throw new Caml_js_exceptions.MelangeError(trace$1.MEL_EXN_ID, trace$1);
                  }
                  return moregen_clty(false, type_pairs, env, cty1._2, cty2._2);
                }
                throw new Caml_js_exceptions.MelangeError(Failure, {
                          MEL_EXN_ID: Failure,
                          _1: /* [] */0
                        });
            
          }
          break;
      
    }
    if (exit === 1) {
      return moregen_clty(true, type_pairs, env, cty1, cty2._2);
    }
    
  }
  catch (raw_error){
    const error = Caml_js_exceptions.internalToOCamlException(raw_error);
    if (error.MEL_EXN_ID === Failure) {
      const error$1 = error._1;
      if (trace || Caml_obj.caml_equal(error$1, /* [] */0)) {
        throw new Caml_js_exceptions.MelangeError(Failure, {
                  MEL_EXN_ID: Failure,
                  _1: {
                    hd: {
                      TAG: /* CM_Class_type_mismatch */2,
                      _0: env,
                      _1: cty1,
                      _2: cty2
                    },
                    tl: error$1
                  }
                });
      }
      throw new Caml_js_exceptions.MelangeError(error.MEL_EXN_ID, error);
    }
    throw new Caml_js_exceptions.MelangeError(error.MEL_EXN_ID, error);
  }
}

function match_class_types(traceOpt, env, pat_sch, subj_sch) {
  const trace = traceOpt !== undefined ? traceOpt : true;
  const type_pairs = Curry._1(TypePairs.create, 53);
  const old_level = current_level.contents;
  current_level.contents = 99999999;
  const match = instance_class(/* [] */0, subj_sch);
  const subj = class_type$1(identity, match[1]);
  current_level.contents = 100000000;
  const match$1 = instance_class(/* [] */0, pat_sch);
  const patt = match$1[1];
  const sign1 = signature_of_class_type(patt);
  const sign2 = signature_of_class_type(subj);
  const t1 = repr(sign1.csig_self);
  const t2 = repr(sign2.csig_self);
  Curry._3(TypePairs.add, type_pairs, [
        t1,
        t2
      ], undefined);
  const match$2 = flatten_fields(object_fields(t1));
  const match$3 = flatten_fields(object_fields(t2));
  const match$4 = associate_fields(match$2[0], match$3[0]);
  const error = Stdlib__List.fold_right((function (param, err) {
          const lab = param[0];
          const k = field_kind_repr(param[1]);
          const err$1 = typeof k === "number" ? ({
                hd: {
                  TAG: /* CM_Hide_public */10,
                  _0: lab
                },
                tl: err
              }) : (set_kind(k._0, /* Fabsent */1), err);
          if (Curry._2(mem$2, lab, sign1.csig_concr)) {
            return err$1;
          } else {
            return {
                    hd: {
                      TAG: /* CM_Hide_virtual */11,
                      _0: "method",
                      _1: lab
                    },
                    tl: err$1
                  };
          }
        }), match$4[1], /* [] */0);
  const missing_method = Stdlib__List.map((function (param) {
          return param[0];
        }), match$4[2]);
  const error$1 = Stdlib.$at(Stdlib__List.map((function (m) {
              return {
                      TAG: /* CM_Missing_method */9,
                      _0: m
                    };
            }), missing_method), error);
  moregen$1(true, type_pairs, env, match$2[1], match$3[1]);
  const error$2 = Stdlib__List.fold_right((function (param, err) {
          try {
            moregen_kind(param[1], param[3]);
            return err;
          }
          catch (raw_exn){
            const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.MEL_EXN_ID === Unify) {
              return {
                      hd: {
                        TAG: /* CM_Public_method */12,
                        _0: param[0]
                      },
                      tl: err
                    };
            }
            throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
          }
        }), match$4[0], error$1);
  const error$3 = Curry._3(Meths.fold, (function (lab, param, err) {
          try {
            const match = Curry._2(Meths.find, lab, sign1.csig_vars);
            if (param[0] === /* Mutable */1 && match[0] !== /* Mutable */1) {
              return {
                      hd: {
                        TAG: /* CM_Non_mutable_value */6,
                        _0: lab
                      },
                      tl: err
                    };
            } else if (param[1] === /* Concrete */1 && match[1] !== /* Concrete */1) {
              return {
                      hd: {
                        TAG: /* CM_Non_concrete_value */7,
                        _0: lab
                      },
                      tl: err
                    };
            } else {
              return err;
            }
          }
          catch (raw_exn){
            const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.MEL_EXN_ID === Stdlib.Not_found) {
              return {
                      hd: {
                        TAG: /* CM_Missing_value */8,
                        _0: lab
                      },
                      tl: err
                    };
            }
            throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
          }
        }), sign2.csig_vars, error$2);
  const error$4 = Curry._3(Meths.fold, (function (lab, param, err) {
          if (param[1] === /* Virtual */0 && !Curry._2(Meths.mem, lab, sign2.csig_vars)) {
            return {
                    hd: {
                      TAG: /* CM_Hide_virtual */11,
                      _0: "instance variable",
                      _1: lab
                    },
                    tl: err
                  };
          } else {
            return err;
          }
        }), sign1.csig_vars, error$3);
  const error$5 = Stdlib__List.fold_right((function (e, l) {
          if (Stdlib__List.mem(e, missing_method)) {
            return l;
          } else {
            return {
                    hd: {
                      TAG: /* CM_Virtual_method */14,
                      _0: e
                    },
                    tl: l
                  };
          }
        }), Curry._1(elements, Curry._2(diff, sign2.csig_concr, sign1.csig_concr)), error$4);
  let res;
  if (error$5) {
    res = {
      hd: {
        TAG: /* CM_Class_type_mismatch */2,
        _0: env,
        _1: patt,
        _2: subj
      },
      tl: error$5
    };
  } else {
    try {
      moregen_clty(trace, type_pairs, env, patt, subj);
      res = /* [] */0;
    }
    catch (raw_r){
      const r = Caml_js_exceptions.internalToOCamlException(raw_r);
      if (r.MEL_EXN_ID === Failure) {
        res = r._1;
      } else {
        throw new Caml_js_exceptions.MelangeError(r.MEL_EXN_ID, r);
      }
    }
  }
  current_level.contents = old_level;
  return res;
}

function equal_clty(trace, type_pairs, subst, env, cty1, cty2) {
  try {
    let exit = 0;
    switch (cty1.TAG | 0) {
      case /* Cty_constr */0 :
          let exit$1 = 0;
          switch (cty2.TAG | 0) {
            case /* Cty_constr */0 :
                return equal_clty(true, type_pairs, subst, env, cty1._2, cty2._2);
            case /* Cty_signature */1 :
            case /* Cty_arrow */2 :
                exit$1 = 3;
                break;
            
          }
          if (exit$1 === 3) {
            return equal_clty(true, type_pairs, subst, env, cty1._2, cty2);
          }
          break;
      case /* Cty_signature */1 :
          const sign1 = cty1._0;
          switch (cty2.TAG | 0) {
            case /* Cty_constr */0 :
                exit = 1;
                break;
            case /* Cty_signature */1 :
                const sign2 = cty2._0;
                const ty1 = object_fields(repr(sign1.csig_self));
                const ty2 = object_fields(repr(sign2.csig_self));
                const match = flatten_fields(ty1);
                const match$1 = flatten_fields(ty2);
                const match$2 = associate_fields(match[0], match$1[0]);
                Stdlib__List.iter((function (param) {
                        try {
                          return eqtype$1(true, type_pairs, subst, env, param[2], param[4]);
                        }
                        catch (raw_trace){
                          const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
                          if (trace.MEL_EXN_ID === Unify) {
                            throw new Caml_js_exceptions.MelangeError(Failure, {
                                      MEL_EXN_ID: Failure,
                                      _1: {
                                        hd: {
                                          TAG: /* CM_Meth_type_mismatch */5,
                                          _0: param[0],
                                          _1: env,
                                          _2: expand_trace(env, trace._1)
                                        },
                                        tl: /* [] */0
                                      }
                                    });
                          }
                          throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
                        }
                      }), match$2[0]);
                return Curry._2(Meths.iter, (function (lab, param) {
                              const match = Curry._2(Meths.find, lab, sign1.csig_vars);
                              try {
                                return eqtype$1(true, type_pairs, subst, env, match[2], param[2]);
                              }
                              catch (raw_trace){
                                const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
                                if (trace.MEL_EXN_ID === Unify) {
                                  throw new Caml_js_exceptions.MelangeError(Failure, {
                                            MEL_EXN_ID: Failure,
                                            _1: {
                                              hd: {
                                                TAG: /* CM_Val_type_mismatch */4,
                                                _0: lab,
                                                _1: env,
                                                _2: expand_trace(env, trace._1)
                                              },
                                              tl: /* [] */0
                                            }
                                          });
                                }
                                throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
                              }
                            }), sign2.csig_vars);
            case /* Cty_arrow */2 :
                exit = 2;
                break;
            
          }
          break;
      case /* Cty_arrow */2 :
          switch (cty2.TAG | 0) {
            case /* Cty_constr */0 :
                exit = 1;
                break;
            case /* Cty_signature */1 :
                exit = 2;
                break;
            case /* Cty_arrow */2 :
                if (cty1._0 === cty2._0) {
                  try {
                    eqtype$1(true, type_pairs, subst, env, cty1._1, cty2._1);
                  }
                  catch (raw_trace){
                    const trace$1 = Caml_js_exceptions.internalToOCamlException(raw_trace);
                    if (trace$1.MEL_EXN_ID === Unify) {
                      throw new Caml_js_exceptions.MelangeError(Failure, {
                                MEL_EXN_ID: Failure,
                                _1: {
                                  hd: {
                                    TAG: /* CM_Parameter_mismatch */3,
                                    _0: env,
                                    _1: expand_trace(env, trace$1._1)
                                  },
                                  tl: /* [] */0
                                }
                              });
                    }
                    throw new Caml_js_exceptions.MelangeError(trace$1.MEL_EXN_ID, trace$1);
                  }
                  return equal_clty(false, type_pairs, subst, env, cty1._2, cty2._2);
                }
                exit = 2;
                break;
            
          }
          break;
      
    }
    switch (exit) {
      case 1 :
          return equal_clty(true, type_pairs, subst, env, cty1, cty2._2);
      case 2 :
          throw new Caml_js_exceptions.MelangeError(Failure, {
                    MEL_EXN_ID: Failure,
                    _1: trace ? /* [] */0 : ({
                          hd: {
                            TAG: /* CM_Class_type_mismatch */2,
                            _0: env,
                            _1: cty1,
                            _2: cty2
                          },
                          tl: /* [] */0
                        })
                  });
      
    }
  }
  catch (raw_error){
    const error = Caml_js_exceptions.internalToOCamlException(raw_error);
    if (error.MEL_EXN_ID === Failure) {
      if (trace) {
        throw new Caml_js_exceptions.MelangeError(Failure, {
                  MEL_EXN_ID: Failure,
                  _1: {
                    hd: {
                      TAG: /* CM_Class_type_mismatch */2,
                      _0: env,
                      _1: cty1,
                      _2: cty2
                    },
                    tl: error._1
                  }
                });
      }
      throw new Caml_js_exceptions.MelangeError(error.MEL_EXN_ID, error);
    }
    throw new Caml_js_exceptions.MelangeError(error.MEL_EXN_ID, error);
  }
}

function match_class_declarations(env, patt_params, patt_type, subj_params, subj_type) {
  const type_pairs = Curry._1(TypePairs.create, 53);
  const subst = {
    contents: /* [] */0
  };
  const sign1 = signature_of_class_type(patt_type);
  const sign2 = signature_of_class_type(subj_type);
  const t1 = repr(sign1.csig_self);
  const t2 = repr(sign2.csig_self);
  Curry._3(TypePairs.add, type_pairs, [
        t1,
        t2
      ], undefined);
  const match = flatten_fields(object_fields(t1));
  const match$1 = flatten_fields(object_fields(t2));
  const match$2 = associate_fields(match[0], match$1[0]);
  const error = Stdlib__List.fold_right((function (param, err) {
          const lab = param[0];
          const k = field_kind_repr(param[1]);
          const err$1 = typeof k === "number" ? ({
                hd: {
                  TAG: /* CM_Hide_public */10,
                  _0: lab
                },
                tl: err
              }) : err;
          if (Curry._2(mem$2, lab, sign1.csig_concr)) {
            return err$1;
          } else {
            return {
                    hd: {
                      TAG: /* CM_Hide_virtual */11,
                      _0: "method",
                      _1: lab
                    },
                    tl: err$1
                  };
          }
        }), match$2[1], /* [] */0);
  const missing_method = Stdlib__List.map((function (param) {
          return param[0];
        }), match$2[2]);
  const error$1 = Stdlib.$at(Stdlib__List.map((function (m) {
              return {
                      TAG: /* CM_Missing_method */9,
                      _0: m
                    };
            }), missing_method), error);
  eqtype$1(true, type_pairs, subst, env, match[1], match$1[1]);
  const error$2 = Stdlib__List.fold_right((function (param, err) {
          const lab = param[0];
          const k1 = field_kind_repr(param[1]);
          const k2 = field_kind_repr(param[3]);
          if (typeof k1 === "number") {
            if (!k1) {
              if (typeof k2 !== "number") {
                return {
                        hd: {
                          TAG: /* CM_Public_method */12,
                          _0: lab
                        },
                        tl: err
                      };
              }
              if (!k2) {
                return err;
              }
              
            }
            
          } else {
            if (typeof k2 !== "number") {
              return err;
            }
            if (!k2) {
              return {
                      hd: {
                        TAG: /* CM_Private_method */13,
                        _0: lab
                      },
                      tl: err
                    };
            }
            
          }
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                    MEL_EXN_ID: "Assert_failure",
                    _1: [
                      "jscomp/test/ocaml_typedtree_test.ml",
                      33612,
                      34
                    ]
                  });
        }), match$2[0], error$1);
  const error$3 = Curry._3(Meths.fold, (function (lab, param, err) {
          try {
            const match = Curry._2(Meths.find, lab, sign1.csig_vars);
            if (param[0] === /* Mutable */1 && match[0] !== /* Mutable */1) {
              return {
                      hd: {
                        TAG: /* CM_Non_mutable_value */6,
                        _0: lab
                      },
                      tl: err
                    };
            } else if (param[1] === /* Concrete */1 && match[1] !== /* Concrete */1) {
              return {
                      hd: {
                        TAG: /* CM_Non_concrete_value */7,
                        _0: lab
                      },
                      tl: err
                    };
            } else {
              return err;
            }
          }
          catch (raw_exn){
            const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.MEL_EXN_ID === Stdlib.Not_found) {
              return {
                      hd: {
                        TAG: /* CM_Missing_value */8,
                        _0: lab
                      },
                      tl: err
                    };
            }
            throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
          }
        }), sign2.csig_vars, error$2);
  const error$4 = Curry._3(Meths.fold, (function (lab, param, err) {
          if (param[1] === /* Virtual */0 && !Curry._2(Meths.mem, lab, sign2.csig_vars)) {
            return {
                    hd: {
                      TAG: /* CM_Hide_virtual */11,
                      _0: "instance variable",
                      _1: lab
                    },
                    tl: err
                  };
          } else {
            return err;
          }
        }), sign1.csig_vars, error$3);
  const error$5 = Stdlib__List.fold_right((function (e, l) {
          if (Stdlib__List.mem(e, missing_method)) {
            return l;
          } else {
            return {
                    hd: {
                      TAG: /* CM_Virtual_method */14,
                      _0: e
                    },
                    tl: l
                  };
          }
        }), Curry._1(elements, Curry._2(diff, sign2.csig_concr, sign1.csig_concr)), error$4);
  if (error$5) {
    return error$5;
  }
  try {
    const lp = Stdlib__List.length(patt_params);
    const ls = Stdlib__List.length(subj_params);
    if (lp !== ls) {
      throw new Caml_js_exceptions.MelangeError(Failure, {
                MEL_EXN_ID: Failure,
                _1: {
                  hd: {
                    TAG: /* CM_Parameter_arity_mismatch */0,
                    _0: lp,
                    _1: ls
                  },
                  tl: /* [] */0
                }
              });
    }
    Stdlib__List.iter2((function (p, s) {
            try {
              return eqtype$1(true, type_pairs, subst, env, p, s);
            }
            catch (raw_trace){
              const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
              if (trace.MEL_EXN_ID === Unify) {
                throw new Caml_js_exceptions.MelangeError(Failure, {
                          MEL_EXN_ID: Failure,
                          _1: {
                            hd: {
                              TAG: /* CM_Type_parameter_mismatch */1,
                              _0: env,
                              _1: expand_trace(env, trace._1)
                            },
                            tl: /* [] */0
                          }
                        });
              }
              throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
            }
          }), patt_params, subj_params);
    equal_clty(false, type_pairs, subst, env, {
          TAG: /* Cty_signature */1,
          _0: sign1
        }, {
          TAG: /* Cty_signature */1,
          _0: sign2
        });
    const clty_params = function (param, param$1) {
      return Stdlib__List.fold_right((function (ty, cty) {
                    return {
                            TAG: /* Cty_arrow */2,
                            _0: "*",
                            _1: ty,
                            _2: cty
                          };
                  }), param, param$1);
    };
    return match_class_types(false, env, clty_params(patt_params, patt_type), clty_params(subj_params, subj_type));
  }
  catch (raw_r){
    const r = Caml_js_exceptions.internalToOCamlException(raw_r);
    if (r.MEL_EXN_ID === Failure) {
      return r._1;
    }
    throw new Caml_js_exceptions.MelangeError(r.MEL_EXN_ID, r);
  }
}

const warn = {
  contents: false
};

function pred_expand(n) {
  if (n % 2 === 0 && n > 0) {
    return n - 1 | 0;
  } else {
    return n;
  }
}

function pred_enlarge(n) {
  if (n % 2 === 1) {
    return n - 1 | 0;
  } else {
    return n;
  }
}

function collect(l) {
  return Stdlib__List.fold_left((function (c1, param) {
                return Caml.caml_int_max(c1, param[1]);
              }), /* Unchanged */0, l);
}

function filter_visited(_l) {
  while(true) {
    const l = _l;
    if (!l) {
      return /* [] */0;
    }
    const match = l.hd.desc;
    if (typeof match === "number") {
      _l = l.tl;
      continue ;
    }
    switch (match.TAG | 0) {
      case /* Tobject */4 :
      case /* Tvariant */8 :
          return l;
      default:
        _l = l.tl;
        continue ;
    }
  };
}

function memq_warn(t, visited) {
  if (Stdlib__List.memq(t, visited)) {
    warn.contents = true;
    return true;
  } else {
    return false;
  }
}

function lid_of_path(sharpOpt, id) {
  const sharp = sharpOpt !== undefined ? sharpOpt : "";
  switch (id.TAG | 0) {
    case /* Pident */0 :
        return {
                TAG: /* Lident */0,
                _0: sharp + id._0.name
              };
    case /* Pdot */1 :
        return {
                TAG: /* Ldot */1,
                _0: lid_of_path(undefined, id._0),
                _1: sharp + id._1
              };
    case /* Papply */2 :
        return {
                TAG: /* Lapply */2,
                _0: lid_of_path(sharp, id._0),
                _1: lid_of_path(undefined, id._1)
              };
    
  }
}

function find_cltype_for_path(env, p) {
  const match = lookup_type$1(lid_of_path("#", p), env);
  const cl_abbr = match[1];
  const ty = cl_abbr.type_manifest;
  if (ty !== undefined) {
    const match$1 = repr(ty).desc;
    if (typeof match$1 === "number") {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
    }
    if (match$1.TAG === /* Tobject */4) {
      const match$2 = match$1._1.contents;
      if (match$2 !== undefined) {
        if (same(p, match$2[0])) {
          return [
                  cl_abbr,
                  ty
                ];
        }
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                  MEL_EXN_ID: Stdlib.Not_found
                });
      }
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
  } else {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                33719,
                12
              ]
            });
  }
}

function build_subtype(env, visited, loops, posi, level, t) {
  const t$1 = repr(t);
  const tlist = t$1.desc;
  if (typeof tlist === "number") {
    if (posi) {
      const v = newvar(undefined, undefined);
      return [
              v,
              /* Changed */2
            ];
    }
    warn.contents = true;
    return [
            t$1,
            /* Unchanged */0
          ];
  }
  switch (tlist.TAG | 0) {
    case /* Tvar */0 :
        if (!posi) {
          return [
                  t$1,
                  /* Unchanged */0
                ];
        }
        try {
          const t$p = Stdlib__List.assq(t$1, loops);
          warn.contents = true;
          return [
                  t$p,
                  /* Equiv */1
                ];
        }
        catch (raw_exn){
          const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.MEL_EXN_ID === Stdlib.Not_found) {
            return [
                    t$1,
                    /* Unchanged */0
                  ];
          }
          throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
        }
    case /* Tarrow */1 :
        if (memq_warn(t$1, visited)) {
          return [
                  t$1,
                  /* Unchanged */0
                ];
        }
        const visited$1 = {
          hd: t$1,
          tl: visited
        };
        const match = build_subtype(env, visited$1, loops, !posi, level, tlist._1);
        const match$1 = build_subtype(env, visited$1, loops, posi, level, tlist._2);
        const c = Caml.caml_int_max(match[1], match$1[1]);
        if (c > /* Unchanged */0) {
          return [
                  newty2(current_level.contents, {
                        TAG: /* Tarrow */1,
                        _0: tlist._0,
                        _1: match[0],
                        _2: match$1[0],
                        _3: /* Cok */0
                      }),
                  c
                ];
        } else {
          return [
                  t$1,
                  /* Unchanged */0
                ];
        }
    case /* Ttuple */2 :
        if (memq_warn(t$1, visited)) {
          return [
                  t$1,
                  /* Unchanged */0
                ];
        }
        const visited$2 = {
          hd: t$1,
          tl: visited
        };
        const tlist$p = Stdlib__List.map((function (param) {
                return build_subtype(env, visited$2, loops, posi, level, param);
              }), tlist._0);
        const c$1 = collect(tlist$p);
        if (c$1 <= /* Unchanged */0) {
          return [
                  t$1,
                  /* Unchanged */0
                ];
        }
        const desc = {
          TAG: /* Ttuple */2,
          _0: Stdlib__List.map((function (prim) {
                  return prim[0];
                }), tlist$p)
        };
        return [
                newty2(current_level.contents, desc),
                c$1
              ];
    case /* Tconstr */3 :
        const p = tlist._0;
        if (level > 0 && generic_abbrev(env, p) && safe_abbrev(env, t$1) && !has_constr_row(expand_abbrev(env)(t$1))) {
          const t$p$1 = repr(expand_abbrev(env)(t$1));
          const level$p = pred_expand(level);
          try {
            const match$2 = t$p$1.desc;
            if (typeof match$2 === "number") {
              throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                        MEL_EXN_ID: Stdlib.Not_found
                      });
            }
            if (match$2.TAG === /* Tobject */4) {
              if (posi && !opened_object(t$p$1)) {
                const match$3 = find_cltype_for_path(env, p);
                const ty = subst(env, current_level.contents, /* Public */1, tlist._2, undefined, match$3[0].type_params, tlist._1, match$3[1]);
                const ty$1 = repr(ty);
                const match$4 = ty$1.desc;
                let match$5;
                if (typeof match$4 === "number") {
                  throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                            MEL_EXN_ID: Stdlib.Not_found
                          });
                }
                if (match$4.TAG === /* Tobject */4) {
                  const match$6 = match$4._1.contents;
                  if (match$6 !== undefined) {
                    if (same(p, match$6[0])) {
                      match$5 = [
                        match$4._0,
                        match$6[1]
                      ];
                    } else {
                      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                                MEL_EXN_ID: Stdlib.Not_found
                              });
                    }
                  } else {
                    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                              MEL_EXN_ID: Stdlib.Not_found
                            });
                  }
                } else {
                  throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                            MEL_EXN_ID: Stdlib.Not_found
                          });
                }
                const tl1 = match$5[1];
                if (Stdlib__List.exists((function (param) {
                          return deep_occur(ty$1, param);
                        }), tl1)) {
                  throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                            MEL_EXN_ID: Stdlib.Not_found
                          });
                }
                ty$1.desc = {
                  TAG: /* Tvar */0,
                  _0: undefined
                };
                const t$p$p = newvar(undefined, undefined);
                const loops_0 = [
                  ty$1,
                  t$p$p
                ];
                const loops$1 = {
                  hd: loops_0,
                  tl: loops
                };
                const match$7 = build_subtype(env, {
                      hd: t$p$1,
                      tl: /* [] */0
                    }, loops$1, posi, pred_enlarge(level$p), match$5[0]);
                const ty1$p = match$7[0];
                if (!is_Tvar(t$p$p)) {
                  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                            MEL_EXN_ID: "Assert_failure",
                            _1: [
                              "jscomp/test/ocaml_typedtree_test.ml",
                              33782,
                              10
                            ]
                          });
                }
                const nm = match$7[1] > /* Equiv */1 || deep_occur(ty$1, ty1$p) ? undefined : [
                    p,
                    tl1
                  ];
                t$p$p.desc = {
                  TAG: /* Tobject */4,
                  _0: ty1$p,
                  _1: {
                    contents: nm
                  }
                };
                try {
                  unify_var(env, ty$1, t$1);
                }
                catch (raw_exn$1){
                  const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
                  if (exn$1.MEL_EXN_ID === Unify) {
                    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                              MEL_EXN_ID: "Assert_failure",
                              _1: [
                                "jscomp/test/ocaml_typedtree_test.ml",
                                33786,
                                50
                              ]
                            });
                  }
                  throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
                }
                return [
                        t$p$p,
                        /* Changed */2
                      ];
              }
              throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                        MEL_EXN_ID: Stdlib.Not_found
                      });
            }
            throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                      MEL_EXN_ID: Stdlib.Not_found
                    });
          }
          catch (raw_exn$2){
            const exn$2 = Caml_js_exceptions.internalToOCamlException(raw_exn$2);
            if (exn$2.MEL_EXN_ID === Stdlib.Not_found) {
              const match$8 = build_subtype(env, visited, loops, posi, level$p, t$p$1);
              const c$2 = match$8[1];
              if (c$2 > /* Unchanged */0) {
                return [
                        match$8[0],
                        c$2
                      ];
              } else {
                return [
                        t$1,
                        /* Unchanged */0
                      ];
              }
            }
            throw new Caml_js_exceptions.MelangeError(exn$2.MEL_EXN_ID, exn$2);
          }
        } else {
          if (memq_warn(t$1, visited)) {
            return [
                    t$1,
                    /* Unchanged */0
                  ];
          }
          const visited$3 = {
            hd: t$1,
            tl: visited
          };
          try {
            const decl = find_type_full(p, env)[0];
            if (level === 0 && generic_abbrev(env, p) && safe_abbrev(env, t$1) && !has_constr_row(expand_abbrev(env)(t$1))) {
              warn.contents = true;
            }
            const tl$p = Stdlib__List.map2((function (v, t) {
                    const match = Curry._1(Types_Variance.get_upper, v);
                    const co = match[0];
                    if (match[1]) {
                      if (co) {
                        return [
                                t,
                                /* Unchanged */0
                              ];
                      } else {
                        return build_subtype(env, visited$3, loops, !posi, level, t);
                      }
                    } else if (co) {
                      return build_subtype(env, visited$3, loops, posi, level, t);
                    } else {
                      return [
                              newvar(undefined, undefined),
                              /* Changed */2
                            ];
                    }
                  }), decl.type_variance, tlist._1);
            const c$3 = collect(tl$p);
            if (c$3 > /* Unchanged */0) {
              return [
                      newconstr(p, Stdlib__List.map((function (prim) {
                                  return prim[0];
                                }), tl$p)),
                      c$3
                    ];
            } else {
              return [
                      t$1,
                      /* Unchanged */0
                    ];
            }
          }
          catch (raw_exn$3){
            const exn$3 = Caml_js_exceptions.internalToOCamlException(raw_exn$3);
            if (exn$3.MEL_EXN_ID === Stdlib.Not_found) {
              return [
                      t$1,
                      /* Unchanged */0
                    ];
            }
            throw new Caml_js_exceptions.MelangeError(exn$3.MEL_EXN_ID, exn$3);
          }
        }
    case /* Tobject */4 :
        const t1 = tlist._0;
        if (memq_warn(t$1, visited) || opened_object(t1)) {
          return [
                  t$1,
                  /* Unchanged */0
                ];
        }
        const level$p$1 = pred_enlarge(level);
        const visited_1 = level$p$1 < level ? /* [] */0 : filter_visited(visited);
        const visited$4 = {
          hd: t$1,
          tl: visited_1
        };
        const match$9 = build_subtype(env, visited$4, loops, posi, level$p$1, t1);
        const c$4 = match$9[1];
        if (c$4 > /* Unchanged */0) {
          return [
                  newty2(current_level.contents, {
                        TAG: /* Tobject */4,
                        _0: match$9[0],
                        _1: {
                          contents: undefined
                        }
                      }),
                  c$4
                ];
        } else {
          return [
                  t$1,
                  /* Unchanged */0
                ];
        }
    case /* Tfield */5 :
        const match$10 = build_subtype(env, visited, loops, posi, level, tlist._2);
        const match$11 = build_subtype(env, visited, loops, posi, level, tlist._3);
        const c$5 = Caml.caml_int_max(match$10[1], match$11[1]);
        if (c$5 > /* Unchanged */0) {
          return [
                  newty2(current_level.contents, {
                        TAG: /* Tfield */5,
                        _0: tlist._0,
                        _1: /* Fpresent */0,
                        _2: match$10[0],
                        _3: match$11[0]
                      }),
                  c$5
                ];
        } else {
          return [
                  t$1,
                  /* Unchanged */0
                ];
        }
    case /* Tlink */6 :
    case /* Tsubst */7 :
        throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                  MEL_EXN_ID: "Assert_failure",
                  _1: [
                    "jscomp/test/ocaml_typedtree_test.ml",
                    33877,
                    6
                  ]
                });
    case /* Tvariant */8 :
        const row = row_repr_aux(/* [] */0, tlist._0);
        if (memq_warn(t$1, visited) || !static_row(row)) {
          return [
                  t$1,
                  /* Unchanged */0
                ];
        }
        const level$p$2 = pred_enlarge(level);
        const visited_1$1 = level$p$2 < level ? /* [] */0 : filter_visited(visited);
        const visited$5 = {
          hd: t$1,
          tl: visited_1$1
        };
        const fields = filter_row_fields(false, row.row_fields);
        const fields$1 = Stdlib__List.map((function (orig) {
                const l = orig[0];
                const match = row_field_repr_aux(/* [] */0, orig[1]);
                if (typeof match === "number") {
                  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                            MEL_EXN_ID: "Assert_failure",
                            _1: [
                              "jscomp/test/ocaml_typedtree_test.ml",
                              33844,
                              17
                            ]
                          });
                }
                if (match.TAG === /* Rpresent */0) {
                  const t = match._0;
                  if (t === undefined) {
                    if (posi) {
                      return [
                              [
                                l,
                                {
                                  TAG: /* Reither */1,
                                  _0: true,
                                  _1: /* [] */0,
                                  _2: false,
                                  _3: {
                                    contents: undefined
                                  }
                                }
                              ],
                              /* Unchanged */0
                            ];
                    } else {
                      return [
                              orig,
                              /* Unchanged */0
                            ];
                    }
                  }
                  const match$1 = build_subtype(env, visited$5, loops, posi, level$p$2, t);
                  const t$p = match$1[0];
                  const f = posi && level > 0 ? ({
                        TAG: /* Reither */1,
                        _0: false,
                        _1: {
                          hd: t$p,
                          tl: /* [] */0
                        },
                        _2: false,
                        _3: {
                          contents: undefined
                        }
                      }) : ({
                        TAG: /* Rpresent */0,
                        _0: t$p
                      });
                  return [
                          [
                            l,
                            f
                          ],
                          match$1[1]
                        ];
                }
                throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                          MEL_EXN_ID: "Assert_failure",
                          _1: [
                            "jscomp/test/ocaml_typedtree_test.ml",
                            33844,
                            17
                          ]
                        });
              }), fields);
        const c$6 = collect(fields$1);
        const row_row_fields = Stdlib__List.map((function (prim) {
                return prim[0];
              }), fields$1);
        const row_row_more = newvar(undefined, undefined);
        const row_row_name = c$6 > /* Unchanged */0 ? undefined : row.row_name;
        const row$1 = {
          row_fields: row_row_fields,
          row_more: row_row_more,
          row_bound: undefined,
          row_closed: posi,
          row_fixed: false,
          row_name: row_row_name
        };
        return [
                newty2(current_level.contents, {
                      TAG: /* Tvariant */8,
                      _0: row$1
                    }),
                /* Changed */2
              ];
    case /* Tpoly */10 :
        const match$12 = build_subtype(env, visited, loops, posi, level, tlist._0);
        const c$7 = match$12[1];
        if (c$7 > /* Unchanged */0) {
          return [
                  newty2(current_level.contents, {
                        TAG: /* Tpoly */10,
                        _0: match$12[0],
                        _1: tlist._1
                      }),
                  c$7
                ];
        } else {
          return [
                  t$1,
                  /* Unchanged */0
                ];
        }
    case /* Tunivar */9 :
    case /* Tpackage */11 :
        return [
                t$1,
                /* Unchanged */0
              ];
    
  }
}

function enlarge_type(env, ty) {
  warn.contents = false;
  const match = build_subtype(env, /* [] */0, /* [] */0, true, 4, ty);
  return [
          match[0],
          warn.contents
        ];
}

const subtypes = Curry._1(TypePairs.create, 17);

function subtype_error(env, trace) {
  throw new Caml_js_exceptions.MelangeError(Subtype, {
            MEL_EXN_ID: Subtype,
            _1: expand_trace(env, Stdlib__List.rev(trace)),
            _2: /* [] */0
          });
}

function subtype_rec(env, _trace, _t1, _t2, _cstrs) {
  while(true) {
    const cstrs = _cstrs;
    const t2 = _t2;
    const t1 = _t1;
    const trace = _trace;
    const t1$1 = repr(t1);
    const t2$1 = repr(t2);
    if (t1$1 === t2$1) {
      return cstrs;
    }
    try {
      Curry._2(TypePairs.find, subtypes, [
            t1$1,
            t2$1
          ]);
      return cstrs;
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        Curry._3(TypePairs.add, subtypes, [
              t1$1,
              t2$1
            ], undefined);
        const match = t1$1.desc;
        const match$1 = t2$1.desc;
        let exit = 0;
        let exit$1 = 0;
        let exit$2 = 0;
        let exit$3 = 0;
        let exit$4 = 0;
        if (typeof match === "number") {
          exit$4 = 6;
        } else {
          switch (match.TAG | 0) {
            case /* Tvar */0 :
                exit = 2;
                break;
            case /* Tarrow */1 :
                const u1 = match._2;
                const t1$2 = match._1;
                const l1 = match._0;
                if (typeof match$1 === "number") {
                  exit = 1;
                } else {
                  switch (match$1.TAG | 0) {
                    case /* Tvar */0 :
                        exit$4 = 6;
                        break;
                    case /* Tarrow */1 :
                        const u2 = match$1._2;
                        const t2$2 = match$1._1;
                        const l2 = match$1._0;
                        if (l1 === l2 || classic.contents && !(is_optional(l1) || is_optional(l2))) {
                          const cstrs$1 = subtype_rec(env, {
                                hd: [
                                  t2$2,
                                  t1$2
                                ],
                                tl: trace
                              }, t2$2, t1$2, cstrs);
                          _cstrs = cstrs$1;
                          _t2 = u2;
                          _t1 = u1;
                          _trace = {
                            hd: [
                              u1,
                              u2
                            ],
                            tl: trace
                          };
                          continue ;
                        }
                        exit = 1;
                        break;
                    case /* Tconstr */3 :
                        exit$2 = 4;
                        break;
                    default:
                      exit = 1;
                  }
                }
                break;
            case /* Ttuple */2 :
                if (typeof match$1 === "number") {
                  exit = 1;
                } else {
                  switch (match$1.TAG | 0) {
                    case /* Tvar */0 :
                        exit$4 = 6;
                        break;
                    case /* Ttuple */2 :
                        let tl1 = match._0;
                        let tl2 = match$1._0;
                        if (Stdlib__List.length(tl1) !== Stdlib__List.length(tl2)) {
                          subtype_error(env, trace);
                        }
                        return Stdlib__List.fold_left2((function (cstrs, t1, t2) {
                                      return subtype_rec(env, {
                                                  hd: [
                                                    t1,
                                                    t2
                                                  ],
                                                  tl: trace
                                                }, t1, t2, cstrs);
                                    }), cstrs, tl1, tl2);
                    case /* Tconstr */3 :
                        exit$2 = 4;
                        break;
                    default:
                      exit = 1;
                  }
                }
                break;
            case /* Tconstr */3 :
                if (match._1) {
                  exit$4 = 6;
                } else if (typeof match$1 === "number") {
                  exit$3 = 5;
                } else {
                  switch (match$1.TAG | 0) {
                    case /* Tvar */0 :
                        exit$4 = 6;
                        break;
                    case /* Tconstr */3 :
                        if (match$1._1) {
                          exit$3 = 5;
                        } else {
                          if (same(match._0, match$1._0)) {
                            return cstrs;
                          }
                          exit$3 = 5;
                        }
                        break;
                    default:
                      exit$3 = 5;
                  }
                }
                break;
            case /* Tobject */4 :
                const f1 = match._0;
                if (typeof match$1 === "number") {
                  exit = 1;
                } else {
                  switch (match$1.TAG | 0) {
                    case /* Tvar */0 :
                        exit$4 = 6;
                        break;
                    case /* Tconstr */3 :
                        exit$2 = 4;
                        break;
                    case /* Tobject */4 :
                        const f2 = match$1._0;
                        if (is_Tvar(object_row(f1)) && is_Tvar(object_row(f2))) {
                          return {
                                  hd: [
                                    trace,
                                    t1$1,
                                    t2$1,
                                    univar_pairs.contents
                                  ],
                                  tl: cstrs
                                };
                        } else {
                          const match$2 = flatten_fields(f1);
                          const rest1 = match$2[1];
                          const match$3 = flatten_fields(f2);
                          const rest2 = match$3[1];
                          const match$4 = associate_fields(match$2[0], match$3[0]);
                          const miss2 = match$4[2];
                          const miss1 = match$4[1];
                          const cstrs$2 = Caml_obj.caml_equal(rest2.desc, /* Tnil */0) ? cstrs : (
                              Caml_obj.caml_equal(miss1, /* [] */0) ? subtype_rec(env, {
                                      hd: [
                                        rest1,
                                        rest2
                                      ],
                                      tl: trace
                                    }, rest1, rest2, cstrs) : ({
                                    hd: [
                                      trace,
                                      build_fields(repr(f1).level)(miss1, rest1),
                                      rest2,
                                      univar_pairs.contents
                                    ],
                                    tl: cstrs
                                  })
                            );
                          const cstrs$3 = Caml_obj.caml_equal(miss2, /* [] */0) ? cstrs$2 : ({
                                hd: [
                                  trace,
                                  rest1,
                                  build_fields(repr(f2).level)(miss2, newvar(undefined, undefined)),
                                  univar_pairs.contents
                                ],
                                tl: cstrs$2
                              });
                          return Stdlib__List.fold_left((function (cstrs, param) {
                                        const t2 = param[4];
                                        const t1 = param[2];
                                        return subtype_rec(env, {
                                                    hd: [
                                                      t1,
                                                      t2
                                                    ],
                                                    tl: trace
                                                  }, t1, t2, cstrs);
                                      }), cstrs$3, match$4[0]);
                        }
                    default:
                      exit = 1;
                  }
                }
                break;
            case /* Tvariant */8 :
                if (typeof match$1 === "number") {
                  exit = 1;
                } else {
                  switch (match$1.TAG | 0) {
                    case /* Tvar */0 :
                        exit$4 = 6;
                        break;
                    case /* Tconstr */3 :
                        exit$2 = 4;
                        break;
                    case /* Tvariant */8 :
                        try {
                          let row1 = match._0;
                          let row2 = match$1._0;
                          const row1$1 = row_repr_aux(/* [] */0, row1);
                          const row2$1 = row_repr_aux(/* [] */0, row2);
                          const match$5 = merge_row_fields(row1$1.row_fields, row2$1.row_fields);
                          const pairs = match$5[2];
                          const r1 = match$5[0];
                          const more1 = repr(row1$1.row_more);
                          const more2 = repr(row2$1.row_more);
                          const match$6 = more1.desc;
                          const match$7 = more2.desc;
                          let exit$5 = 0;
                          if (typeof match$6 === "number") {
                            exit$5 = 1;
                          } else {
                            switch (match$6.TAG | 0) {
                              case /* Tvar */0 :
                                  exit$5 = 1;
                                  break;
                              case /* Tconstr */3 :
                                  if (typeof match$7 === "number" || match$7.TAG !== /* Tconstr */3) {
                                    exit$5 = 1;
                                  } else {
                                    if (same(match$6._0, match$7._0)) {
                                      return subtype_rec(env, {
                                                  hd: [
                                                    more1,
                                                    more2
                                                  ],
                                                  tl: trace
                                                }, more1, more2, cstrs);
                                    }
                                    exit$5 = 1;
                                  }
                                  break;
                              case /* Tunivar */9 :
                                  if (typeof match$7 === "number") {
                                    throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                              MEL_EXN_ID: Stdlib.Exit
                                            });
                                  }
                                  if (match$7.TAG === /* Tunivar */9) {
                                    if (row1$1.row_closed === row2$1.row_closed && Caml_obj.caml_equal(r1, /* [] */0) && Caml_obj.caml_equal(match$5[1], /* [] */0)) {
                                      const cstrs$4 = subtype_rec(env, {
                                            hd: [
                                              more1,
                                              more2
                                            ],
                                            tl: trace
                                          }, more1, more2, cstrs);
                                      return Stdlib__List.fold_left((function (cstrs, param) {
                                                    const match = row_field_repr_aux(/* [] */0, param[1]);
                                                    const match$1 = row_field_repr_aux(/* [] */0, param[2]);
                                                    let t1;
                                                    let t2;
                                                    if (typeof match === "number") {
                                                      if (typeof match$1 === "number") {
                                                        return cstrs;
                                                      }
                                                      throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                                                MEL_EXN_ID: Stdlib.Exit
                                                              });
                                                    }
                                                    if (match.TAG === /* Rpresent */0) {
                                                      const t1$1 = match._0;
                                                      if (t1$1 !== undefined) {
                                                        if (typeof match$1 === "number") {
                                                          throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                                                    MEL_EXN_ID: Stdlib.Exit
                                                                  });
                                                        }
                                                        if (match$1.TAG === /* Rpresent */0) {
                                                          const t2$1 = match$1._0;
                                                          if (t2$1 !== undefined) {
                                                            t1 = t1$1;
                                                            t2 = t2$1;
                                                          } else {
                                                            throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                                                      MEL_EXN_ID: Stdlib.Exit
                                                                    });
                                                          }
                                                        } else {
                                                          throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                                                    MEL_EXN_ID: Stdlib.Exit
                                                                  });
                                                        }
                                                      } else {
                                                        if (typeof match$1 === "number") {
                                                          throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                                                    MEL_EXN_ID: Stdlib.Exit
                                                                  });
                                                        }
                                                        if (match$1.TAG === /* Rpresent */0) {
                                                          if (match$1._0 !== undefined) {
                                                            throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                                                      MEL_EXN_ID: Stdlib.Exit
                                                                    });
                                                          }
                                                          return cstrs;
                                                        }
                                                        throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                                                  MEL_EXN_ID: Stdlib.Exit
                                                                });
                                                      }
                                                    } else if (match._0) {
                                                      if (match._1) {
                                                        throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                                                  MEL_EXN_ID: Stdlib.Exit
                                                                });
                                                      }
                                                      if (typeof match$1 === "number") {
                                                        throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                                                  MEL_EXN_ID: Stdlib.Exit
                                                                });
                                                      }
                                                      if (match$1.TAG === /* Rpresent */0) {
                                                        throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                                                  MEL_EXN_ID: Stdlib.Exit
                                                                });
                                                      }
                                                      if (match$1._0) {
                                                        if (match$1._1) {
                                                          throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                                                    MEL_EXN_ID: Stdlib.Exit
                                                                  });
                                                        }
                                                        return cstrs;
                                                      }
                                                      throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                                                MEL_EXN_ID: Stdlib.Exit
                                                              });
                                                    } else {
                                                      const match$2 = match._1;
                                                      if (match$2) {
                                                        if (match$2.tl) {
                                                          throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                                                    MEL_EXN_ID: Stdlib.Exit
                                                                  });
                                                        }
                                                        if (typeof match$1 === "number") {
                                                          throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                                                    MEL_EXN_ID: Stdlib.Exit
                                                                  });
                                                        }
                                                        if (match$1.TAG === /* Rpresent */0) {
                                                          throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                                                    MEL_EXN_ID: Stdlib.Exit
                                                                  });
                                                        }
                                                        if (match$1._0) {
                                                          throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                                                    MEL_EXN_ID: Stdlib.Exit
                                                                  });
                                                        }
                                                        const match$3 = match$1._1;
                                                        if (match$3) {
                                                          if (match$3.tl) {
                                                            throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                                                      MEL_EXN_ID: Stdlib.Exit
                                                                    });
                                                          }
                                                          t1 = match$2.hd;
                                                          t2 = match$3.hd;
                                                        } else {
                                                          throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                                                    MEL_EXN_ID: Stdlib.Exit
                                                                  });
                                                        }
                                                      } else {
                                                        throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                                                  MEL_EXN_ID: Stdlib.Exit
                                                                });
                                                      }
                                                    }
                                                    return subtype_rec(env, {
                                                                hd: [
                                                                  t1,
                                                                  t2
                                                                ],
                                                                tl: trace
                                                              }, t1, t2, cstrs);
                                                  }), cstrs$4, pairs);
                                    }
                                    throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                              MEL_EXN_ID: Stdlib.Exit
                                            });
                                  }
                                  throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                            MEL_EXN_ID: Stdlib.Exit
                                          });
                              default:
                                throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                          MEL_EXN_ID: Stdlib.Exit
                                        });
                            }
                          }
                          if (exit$5 === 1) {
                            let exit$6 = 0;
                            if (typeof match$7 === "number") {
                              exit$6 = 2;
                            } else {
                              switch (match$7.TAG | 0) {
                                case /* Tvar */0 :
                                case /* Tconstr */3 :
                                    exit$6 = 2;
                                    break;
                                default:
                                  throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                            MEL_EXN_ID: Stdlib.Exit
                                          });
                              }
                            }
                            if (exit$6 === 2) {
                              if (row1$1.row_closed && Caml_obj.caml_equal(r1, /* [] */0)) {
                                return Stdlib__List.fold_left((function (cstrs, param) {
                                              const match = row_field_repr_aux(/* [] */0, param[1]);
                                              const match$1 = row_field_repr_aux(/* [] */0, param[2]);
                                              if (typeof match === "number") {
                                                return cstrs;
                                              }
                                              if (match.TAG === /* Rpresent */0) {
                                                const t1 = match._0;
                                                if (t1 !== undefined) {
                                                  if (typeof match$1 === "number") {
                                                    throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                                              MEL_EXN_ID: Stdlib.Exit
                                                            });
                                                  }
                                                  if (match$1.TAG === /* Rpresent */0) {
                                                    const t2 = match$1._0;
                                                    if (t2 !== undefined) {
                                                      return subtype_rec(env, {
                                                                  hd: [
                                                                    t1,
                                                                    t2
                                                                  ],
                                                                  tl: trace
                                                                }, t1, t2, cstrs);
                                                    }
                                                    throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                                              MEL_EXN_ID: Stdlib.Exit
                                                            });
                                                  }
                                                  throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                                            MEL_EXN_ID: Stdlib.Exit
                                                          });
                                                }
                                                
                                              } else if (!match._0) {
                                                const match$2 = match._1;
                                                if (match$2) {
                                                  const t1$1 = match$2.hd;
                                                  if (typeof match$1 === "number") {
                                                    throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                                              MEL_EXN_ID: Stdlib.Exit
                                                            });
                                                  }
                                                  if (match$1.TAG === /* Rpresent */0) {
                                                    const t2$1 = match$1._0;
                                                    if (t2$1 !== undefined) {
                                                      return subtype_rec(env, {
                                                                  hd: [
                                                                    t1$1,
                                                                    t2$1
                                                                  ],
                                                                  tl: trace
                                                                }, t1$1, t2$1, cstrs);
                                                    }
                                                    throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                                              MEL_EXN_ID: Stdlib.Exit
                                                            });
                                                  }
                                                  throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                                            MEL_EXN_ID: Stdlib.Exit
                                                          });
                                                } else {
                                                  throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                                            MEL_EXN_ID: Stdlib.Exit
                                                          });
                                                }
                                              }
                                              if (typeof match$1 === "number") {
                                                throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                                          MEL_EXN_ID: Stdlib.Exit
                                                        });
                                              }
                                              if (match$1.TAG === /* Rpresent */0) {
                                                if (match$1._0 !== undefined) {
                                                  throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                                            MEL_EXN_ID: Stdlib.Exit
                                                          });
                                                }
                                                return cstrs;
                                              }
                                              throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                                        MEL_EXN_ID: Stdlib.Exit
                                                      });
                                            }), cstrs, pairs);
                              }
                              throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                        MEL_EXN_ID: Stdlib.Exit
                                      });
                            }
                            
                          }
                          
                        }
                        catch (raw_exn$1){
                          const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
                          if (exn$1.MEL_EXN_ID === Stdlib.Exit) {
                            return {
                                    hd: [
                                      trace,
                                      t1$1,
                                      t2$1,
                                      univar_pairs.contents
                                    ],
                                    tl: cstrs
                                  };
                          }
                          throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
                        }
                    default:
                      exit = 1;
                  }
                }
                break;
            case /* Tpoly */10 :
                const tl1$1 = match._1;
                const u1$1 = match._0;
                let exit$7 = 0;
                if (tl1$1) {
                  exit$7 = 7;
                } else if (typeof match$1 === "number") {
                  exit = 1;
                } else {
                  switch (match$1.TAG | 0) {
                    case /* Tvar */0 :
                        exit$4 = 6;
                        break;
                    case /* Tconstr */3 :
                        exit$2 = 4;
                        break;
                    case /* Tpoly */10 :
                        if (match$1._1) {
                          exit$7 = 7;
                        } else {
                          _t2 = match$1._0;
                          _t1 = u1$1;
                          continue ;
                        }
                        break;
                    default:
                      exit = 1;
                  }
                }
                if (exit$7 === 7) {
                  if (typeof match$1 === "number") {
                    exit = 1;
                  } else {
                    switch (match$1.TAG | 0) {
                      case /* Tvar */0 :
                          exit$4 = 6;
                          break;
                      case /* Tconstr */3 :
                          exit$2 = 4;
                          break;
                      case /* Tpoly */10 :
                          const u2$1 = match$1._0;
                          if (match$1._1) {
                            try {
                              return enter_poly(env, univar_pairs, u1$1, tl1$1, u2$1, match$1._1, (function (t1, t2) {
                                            return subtype_rec(env, trace, t1, t2, cstrs);
                                          }));
                            }
                            catch (raw_exn$2){
                              const exn$2 = Caml_js_exceptions.internalToOCamlException(raw_exn$2);
                              if (exn$2.MEL_EXN_ID === Unify) {
                                return {
                                        hd: [
                                          trace,
                                          t1$1,
                                          t2$1,
                                          univar_pairs.contents
                                        ],
                                        tl: cstrs
                                      };
                              }
                              throw new Caml_js_exceptions.MelangeError(exn$2.MEL_EXN_ID, exn$2);
                            }
                          } else {
                            const match$8 = instance_poly(undefined, false, tl1$1, u1$1);
                            _t2 = u2$1;
                            _t1 = match$8[1];
                            continue ;
                          }
                      default:
                        exit = 1;
                    }
                  }
                }
                break;
            case /* Tpackage */11 :
                const tl1$2 = match._2;
                const nl1 = match._1;
                const p1 = match._0;
                if (typeof match$1 === "number") {
                  exit = 1;
                } else {
                  switch (match$1.TAG | 0) {
                    case /* Tvar */0 :
                        exit$4 = 6;
                        break;
                    case /* Tconstr */3 :
                        exit$2 = 4;
                        break;
                    case /* Tpackage */11 :
                        const tl2$1 = match$1._2;
                        const nl2 = match$1._1;
                        const p2 = match$1._0;
                        try {
                          const ntl1 = complete_type_list(undefined, env, nl2, t1$1.level, {
                                TAG: /* Mty_ident */0,
                                _0: p1
                              }, nl1, tl1$2);
                          const ntl2 = complete_type_list(true, env, nl1, t2$1.level, {
                                TAG: /* Mty_ident */0,
                                _0: p2
                              }, nl2, tl2$1);
                          const cstrs$p = Stdlib__List.map((function (param) {
                                  return [
                                          trace,
                                          Stdlib__List.assoc(param[0], ntl1),
                                          param[1],
                                          univar_pairs.contents
                                        ];
                                }), ntl2);
                          if (eq_package_path(env, p1, p2)) {
                            return Stdlib.$at(cstrs$p, cstrs);
                          }
                          const snap = snapshot(undefined);
                          try {
                            Stdlib__List.iter((function (param) {
                                    unify$2(env, param[1], param[2]);
                                  }), cstrs$p);
                            if (Curry._7(package_subtype.contents, env, p1, nl1, tl1$2, p2, nl2, tl2$1)) {
                              backtrack(snap);
                              return Stdlib.$at(cstrs$p, cstrs);
                            }
                            throw new Caml_js_exceptions.MelangeError(Unify, {
                                      MEL_EXN_ID: Unify,
                                      _1: /* [] */0
                                    });
                          }
                          catch (raw_exn$3){
                            const exn$3 = Caml_js_exceptions.internalToOCamlException(raw_exn$3);
                            if (exn$3.MEL_EXN_ID === Unify) {
                              backtrack(snap);
                              throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                                        MEL_EXN_ID: Stdlib.Not_found
                                      });
                            }
                            throw new Caml_js_exceptions.MelangeError(exn$3.MEL_EXN_ID, exn$3);
                          }
                        }
                        catch (raw_exn$4){
                          const exn$4 = Caml_js_exceptions.internalToOCamlException(raw_exn$4);
                          if (exn$4.MEL_EXN_ID === Stdlib.Not_found) {
                            return {
                                    hd: [
                                      trace,
                                      t1$1,
                                      t2$1,
                                      univar_pairs.contents
                                    ],
                                    tl: cstrs
                                  };
                          }
                          throw new Caml_js_exceptions.MelangeError(exn$4.MEL_EXN_ID, exn$4);
                        }
                    default:
                      exit = 1;
                  }
                }
                break;
            default:
              exit$4 = 6;
          }
        }
        if (exit$4 === 6) {
          if (typeof match$1 === "number" || match$1.TAG !== /* Tvar */0) {
            exit$3 = 5;
          } else {
            exit = 2;
          }
        }
        if (exit$3 === 5) {
          if (typeof match === "number" || match.TAG !== /* Tconstr */3) {
            exit$2 = 4;
          } else {
            if (generic_abbrev(env, match._0) && safe_abbrev(env, t1$1)) {
              _t2 = t2$1;
              _t1 = expand_abbrev(env)(t1$1);
              continue ;
            }
            exit$2 = 4;
          }
        }
        if (exit$2 === 4) {
          if (typeof match$1 === "number" || match$1.TAG !== /* Tconstr */3) {
            exit$1 = 3;
          } else {
            if (generic_abbrev(env, match$1._0) && safe_abbrev(env, t2$1)) {
              _t2 = expand_abbrev(env)(t2$1);
              _t1 = t1$1;
              continue ;
            }
            exit$1 = 3;
          }
        }
        if (exit$1 === 3) {
          if (typeof match === "number" || match.TAG !== /* Tconstr */3) {
            exit = 1;
          } else {
            const p1$1 = match._0;
            let exit$8 = 0;
            if (typeof match$1 === "number" || !(match$1.TAG === /* Tconstr */3 && same(p1$1, match$1._0))) {
              exit$8 = 4;
            } else {
              try {
                const decl = find_type_full(p1$1, env)[0];
                return Stdlib__List.fold_left2((function (cstrs, v, param) {
                              const t2 = param[1];
                              const t1 = param[0];
                              const match = Curry._1(Types_Variance.get_upper, v);
                              const cn = match[1];
                              if (match[0]) {
                                if (cn) {
                                  return {
                                          hd: [
                                            trace,
                                            newty2(t1.level, {
                                                  TAG: /* Ttuple */2,
                                                  _0: {
                                                    hd: t1,
                                                    tl: /* [] */0
                                                  }
                                                }),
                                            newty2(t2.level, {
                                                  TAG: /* Ttuple */2,
                                                  _0: {
                                                    hd: t2,
                                                    tl: /* [] */0
                                                  }
                                                }),
                                            univar_pairs.contents
                                          ],
                                          tl: cstrs
                                        };
                                } else {
                                  return subtype_rec(env, {
                                              hd: [
                                                t1,
                                                t2
                                              ],
                                              tl: trace
                                            }, t1, t2, cstrs);
                                }
                              } else if (cn) {
                                return subtype_rec(env, {
                                            hd: [
                                              t2,
                                              t1
                                            ],
                                            tl: trace
                                          }, t2, t1, cstrs);
                              } else {
                                return cstrs;
                              }
                            }), cstrs, decl.type_variance, Stdlib__List.combine(match._1, match$1._1));
              }
              catch (raw_exn$5){
                const exn$5 = Caml_js_exceptions.internalToOCamlException(raw_exn$5);
                if (exn$5.MEL_EXN_ID === Stdlib.Not_found) {
                  return {
                          hd: [
                            trace,
                            t1$1,
                            t2$1,
                            univar_pairs.contents
                          ],
                          tl: cstrs
                        };
                }
                throw new Caml_js_exceptions.MelangeError(exn$5.MEL_EXN_ID, exn$5);
              }
            }
            if (exit$8 === 4) {
              if (generic_private_abbrev(env, p1$1)) {
                _t2 = t2$1;
                _t1 = expand_abbrev_opt(env, t1$1);
                continue ;
              }
              exit = 1;
            }
            
          }
        }
        switch (exit) {
          case 1 :
          case 2 :
              return {
                      hd: [
                        trace,
                        t1$1,
                        t2$1,
                        univar_pairs.contents
                      ],
                      tl: cstrs
                    };
          
        }
      } else {
        throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
      }
    }
  };
}

function subtype(env, ty1, ty2) {
  Curry._1(TypePairs.clear, subtypes);
  univar_pairs.contents = /* [] */0;
  const cstrs = subtype_rec(env, {
        hd: [
          ty1,
          ty2
        ],
        tl: /* [] */0
      }, ty1, ty2, /* [] */0);
  Curry._1(TypePairs.clear, subtypes);
  return function (param) {
    Stdlib__List.iter((function (param) {
            try {
              return unify_pairs({
                          contents: env
                        }, param[1], param[2], param[3]);
            }
            catch (raw_trace){
              const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
              if (trace.MEL_EXN_ID === Unify) {
                throw new Caml_js_exceptions.MelangeError(Subtype, {
                          MEL_EXN_ID: Subtype,
                          _1: expand_trace(env, Stdlib__List.rev(param[0])),
                          _2: Stdlib__List.tl(Stdlib__List.tl(trace._1))
                        });
              }
              throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
            }
          }), Stdlib__List.rev(cstrs));
  };
}

function unalias_object(ty) {
  const ty$1 = repr(ty);
  const match = ty$1.desc;
  if (typeof match === "number") {
    return newty2(ty$1.level, ty$1.desc);
  }
  switch (match.TAG | 0) {
    case /* Tvar */0 :
        return newty2(ty$1.level, ty$1.desc);
    case /* Tconstr */3 :
        return newty2(ty$1.level, {
                    TAG: /* Tvar */0,
                    _0: undefined
                  });
    case /* Tfield */5 :
        return newty2(ty$1.level, {
                    TAG: /* Tfield */5,
                    _0: match._0,
                    _1: match._1,
                    _2: match._2,
                    _3: unalias_object(match._3)
                  });
    case /* Tunivar */9 :
        return ty$1;
    default:
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  34141,
                  6
                ]
              });
  }
}

function unalias(ty) {
  const ty$1 = repr(ty);
  const row = ty$1.desc;
  if (typeof row === "number") {
    return newty2(ty$1.level, ty$1.desc);
  }
  switch (row.TAG | 0) {
    case /* Tobject */4 :
        const ty$2 = row._0;
        return newty2(ty$2.level, {
                    TAG: /* Tobject */4,
                    _0: unalias_object(ty$2),
                    _1: row._1
                  });
    case /* Tvariant */8 :
        const row$1 = row_repr_aux(/* [] */0, row._0);
        const more = row$1.row_more;
        return newty2(ty$1.level, {
                    TAG: /* Tvariant */8,
                    _0: {
                      row_fields: row$1.row_fields,
                      row_more: newty2(more.level, more.desc),
                      row_bound: row$1.row_bound,
                      row_closed: row$1.row_closed,
                      row_fixed: row$1.row_fixed,
                      row_name: row$1.row_name
                    }
                  });
    case /* Tvar */0 :
    case /* Tunivar */9 :
        return ty$1;
    default:
      return newty2(ty$1.level, ty$1.desc);
  }
}

function arity(ty) {
  const match = repr(ty).desc;
  if (typeof match === "number" || match.TAG !== /* Tarrow */1) {
    return 0;
  } else {
    return 1 + arity(match._2) | 0;
  }
}

function cyclic_abbrev(env, id, ty) {
  const check_cycle = function (seen, ty) {
    const ty$1 = repr(ty);
    const match = ty$1.desc;
    if (typeof match === "number") {
      return false;
    }
    if (match.TAG !== /* Tconstr */3) {
      return false;
    }
    if (Caml_obj.caml_equal(match._0, {
            TAG: /* Pident */0,
            _0: id
          })) {
      return true;
    }
    if (Stdlib__List.memq(ty$1, seen)) {
      return true;
    }
    try {
      return check_cycle({
                  hd: ty$1,
                  tl: seen
                }, expand_abbrev_opt(env, ty$1));
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Cannot_expand) {
        return false;
      }
      if (exn.MEL_EXN_ID === Unify) {
        return true;
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  };
  return check_cycle(/* [] */0, ty);
}

function normalize_type_rec(env, visited, ty) {
  const ty$1 = repr(ty);
  if (Curry._2(mem$3, ty$1, visited.contents)) {
    return ;
  }
  visited.contents = Curry._2(add$3, ty$1, visited.contents);
  const row = ty$1.desc;
  if (typeof row !== "number") {
    switch (row.TAG | 0) {
      case /* Tobject */4 :
          const nm = row._1;
          const match = nm.contents;
          if (match !== undefined) {
            const match$1 = match[1];
            if (match$1) {
              const l = match$1.tl;
              const v = match$1.hd;
              const n = match[0];
              if (deep_occur(ty$1, newty2(100000000, {
                          TAG: /* Ttuple */2,
                          _0: l
                        }))) {
                set_name(nm, undefined);
              } else {
                const v$p = repr(v);
                const match$2 = v$p.desc;
                let exit = 0;
                if (typeof match$2 === "number") {
                  log_type(ty$1);
                  ty$1.desc = {
                    TAG: /* Tconstr */3,
                    _0: n,
                    _1: l,
                    _2: {
                      contents: /* Mnil */0
                    }
                  };
                } else {
                  switch (match$2.TAG | 0) {
                    case /* Tvar */0 :
                    case /* Tunivar */9 :
                        exit = 1;
                        break;
                    default:
                      set_name(nm, undefined);
                  }
                }
                if (exit === 1) {
                  if (v$p !== v) {
                    set_name(nm, [
                          n,
                          {
                            hd: v$p,
                            tl: l
                          }
                        ]);
                  }
                  
                }
                
              }
            } else {
              fatal_error("Ctype.normalize_type_rec");
            }
          }
          const fi = repr(row._0);
          if (fi.level >= 0) {
            const match$3 = flatten_fields(fi);
            const fi$p = build_fields(fi.level)(match$3[0], match$3[1]);
            log_type(ty$1);
            fi.desc = fi$p.desc;
          }
          break;
      case /* Tvariant */8 :
          const row$1 = row_repr_aux(/* [] */0, row._0);
          const fields = Stdlib__List.map((function (param) {
                  const f0 = param[1];
                  const f = row_field_repr_aux(/* [] */0, f0);
                  let tmp;
                  if (typeof f === "number" || f.TAG === /* Rpresent */0) {
                    tmp = f;
                  } else {
                    const match = f._1;
                    if (match) {
                      const tyl = match.tl;
                      if (tyl) {
                        const tyl$p = Stdlib__List.fold_left((function (tyl, ty) {
                                if (Stdlib__List.exists((function (ty$p) {
                                          return equal$5(env, false, {
                                                      hd: ty,
                                                      tl: /* [] */0
                                                    }, {
                                                      hd: ty$p,
                                                      tl: /* [] */0
                                                    });
                                        }), tyl)) {
                                  return tyl;
                                } else {
                                  return {
                                          hd: ty,
                                          tl: tyl
                                        };
                                }
                              }), {
                              hd: match.hd,
                              tl: /* [] */0
                            }, tyl);
                        tmp = f !== f0 || Stdlib__List.length(tyl$p) < Stdlib__List.length(tyl) ? ({
                              TAG: /* Reither */1,
                              _0: f._0,
                              _1: Stdlib__List.rev(tyl$p),
                              _2: f._2,
                              _3: f._3
                            }) : f;
                      } else {
                        tmp = f;
                      }
                    } else {
                      tmp = f;
                    }
                  }
                  return [
                          param[0],
                          tmp
                        ];
                }), row$1.row_fields);
          const fields$1 = Stdlib__List.sort((function (param, param$1) {
                  return Caml.caml_string_compare(param[0], param$1[0]);
                }), Stdlib__List.filter((function (param) {
                      return Caml_obj.caml_notequal(param[1], /* Rabsent */0);
                    }), fields));
          log_type(ty$1);
          ty$1.desc = {
            TAG: /* Tvariant */8,
            _0: {
              row_fields: fields$1,
              row_more: row$1.row_more,
              row_bound: row$1.row_bound,
              row_closed: row$1.row_closed,
              row_fixed: row$1.row_fixed,
              row_name: row$1.row_name
            }
          };
          break;
      default:
        
    }
  }
  iter_type_expr((function (param) {
          return normalize_type_rec(env, visited, param);
        }), ty$1);
}

function normalize_type(env, ty) {
  normalize_type_rec(env, {
        contents: /* Empty */0
      }, ty);
}

const nondep_hash = Curry._1(TypeHash.create, 47);

const nondep_variants = Curry._1(TypeHash.create, 17);

function nondep_type_rec(env, id, _ty) {
  while(true) {
    const ty = _ty;
    const ty$1 = ty.desc;
    let exit = 0;
    if (typeof ty$1 === "number") {
      exit = 1;
    } else {
      switch (ty$1.TAG | 0) {
        case /* Tlink */6 :
            _ty = ty$1._0;
            continue ;
        case /* Tvar */0 :
        case /* Tunivar */9 :
            return ty;
        default:
          exit = 1;
      }
    }
    if (exit === 1) {
      try {
        return Curry._2(TypeHash.find, nondep_hash, ty);
      }
      catch (raw_exn){
        const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.MEL_EXN_ID === Stdlib.Not_found) {
          const ty$p = newty2(100000000, {
                TAG: /* Tvar */0,
                _0: undefined
              });
          Curry._3(TypeHash.add, nondep_hash, ty, ty$p);
          const row = ty.desc;
          let tmp;
          let exit$1 = 0;
          if (typeof row === "number") {
            exit$1 = 2;
          } else {
            switch (row.TAG | 0) {
              case /* Tconstr */3 :
                  const p = row._0;
                  if (isfree(id, p)) {
                    try {
                      tmp = {
                        TAG: /* Tlink */6,
                        _0: nondep_type_rec(env, id, expand_abbrev(env)(newty2(ty.level, ty.desc)))
                      };
                    }
                    catch (raw_exn$1){
                      const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
                      if (exn$1.MEL_EXN_ID === Cannot_expand) {
                        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                                  MEL_EXN_ID: Stdlib.Not_found
                                });
                      }
                      if (exn$1.MEL_EXN_ID === Unify) {
                        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                                  MEL_EXN_ID: Stdlib.Not_found
                                });
                      }
                      throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
                    }
                  } else {
                    tmp = {
                      TAG: /* Tconstr */3,
                      _0: p,
                      _1: Stdlib__List.map((function (param) {
                              return nondep_type_rec(env, id, param);
                            }), row._1),
                      _2: {
                        contents: /* Mnil */0
                      }
                    };
                  }
                  break;
              case /* Tobject */4 :
                  const match = row._1.contents;
                  let tmp$1;
                  if (match !== undefined) {
                    const p$1 = match[0];
                    tmp$1 = isfree(id, p$1) ? undefined : [
                        p$1,
                        Stdlib__List.map((function (param) {
                                return nondep_type_rec(env, id, param);
                              }), match[1])
                      ];
                  } else {
                    tmp$1 = undefined;
                  }
                  tmp = {
                    TAG: /* Tobject */4,
                    _0: nondep_type_rec(env, id, row._0),
                    _1: {
                      contents: tmp$1
                    }
                  };
                  break;
              case /* Tvariant */8 :
                  const row$1 = row_repr_aux(/* [] */0, row._0);
                  const more = repr(row$1.row_more);
                  try {
                    const ty2 = Curry._2(TypeHash.find, nondep_variants, more);
                    Curry._3(TypeHash.add, nondep_hash, ty, ty2);
                    tmp = {
                      TAG: /* Tlink */6,
                      _0: ty2
                    };
                  }
                  catch (raw_exn$2){
                    const exn$2 = Caml_js_exceptions.internalToOCamlException(raw_exn$2);
                    if (exn$2.MEL_EXN_ID === Stdlib.Not_found) {
                      Curry._3(TypeHash.add, nondep_variants, more, ty$p);
                      const $$static = static_row(row$1);
                      const more$p = $$static ? newty2(100000000, /* Tnil */0) : more;
                      const row$2 = copy_row((function (param) {
                              return nondep_type_rec(env, id, param);
                            }), true, row$1, true, more$p);
                      const match$1 = row$2.row_name;
                      tmp = match$1 !== undefined && isfree(id, match$1[0]) ? ({
                            TAG: /* Tvariant */8,
                            _0: {
                              row_fields: row$2.row_fields,
                              row_more: row$2.row_more,
                              row_bound: row$2.row_bound,
                              row_closed: row$2.row_closed,
                              row_fixed: row$2.row_fixed,
                              row_name: undefined
                            }
                          }) : ({
                            TAG: /* Tvariant */8,
                            _0: row$2
                          });
                    } else {
                      throw new Caml_js_exceptions.MelangeError(exn$2.MEL_EXN_ID, exn$2);
                    }
                  }
                  break;
              case /* Tpackage */11 :
                  const p$2 = row._0;
                  if (isfree(id, p$2)) {
                    const p$p = normalize_package_path(env, p$2);
                    if (isfree(id, p$p)) {
                      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                                MEL_EXN_ID: Stdlib.Not_found
                              });
                    }
                    tmp = {
                      TAG: /* Tpackage */11,
                      _0: p$p,
                      _1: row._1,
                      _2: Stdlib__List.map((function (param) {
                              return nondep_type_rec(env, id, param);
                            }), row._2)
                    };
                  } else {
                    exit$1 = 2;
                  }
                  break;
              default:
                exit$1 = 2;
            }
          }
          if (exit$1 === 2) {
            tmp = copy_type_desc(undefined, (function (param) {
                    return nondep_type_rec(env, id, param);
                  }), ty.desc);
          }
          ty$p.desc = tmp;
          return ty$p;
        }
        throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
      }
    }
    
  };
}

function nondep_type(env, id, ty) {
  try {
    const ty$p = nondep_type_rec(env, id, ty);
    Curry._1(TypeHash.clear, nondep_hash);
    Curry._1(TypeHash.clear, nondep_variants);
    return ty$p;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      Curry._1(TypeHash.clear, nondep_hash);
      Curry._1(TypeHash.clear, nondep_variants);
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

nondep_type$p.contents = nondep_type;

function unroll_abbrev(id, tl, ty) {
  const ty$1 = repr(ty);
  const path = {
    TAG: /* Pident */0,
    _0: id
  };
  if (is_Tvar(ty$1) || Stdlib__List.exists((function (param) {
            return deep_occur(ty$1, param);
          }), tl) || is_object_type(path)) {
    return ty$1;
  }
  const ty$p = newty2(ty$1.level, ty$1.desc);
  link_type(ty$1, newty2(ty$1.level, {
            TAG: /* Tconstr */3,
            _0: path,
            _1: tl,
            _2: {
              contents: /* Mnil */0
            }
          }));
  return ty$p;
}

function nondep_type_decl(env, mid, id, is_covariant, decl) {
  try {
    const params = Stdlib__List.map((function (param) {
            return nondep_type_rec(env, mid, param);
          }), decl.type_params);
    let tk;
    try {
      const cstrs = decl.type_kind;
      tk = typeof cstrs === "number" ? (
          cstrs === /* Type_abstract */0 ? /* Type_abstract */0 : /* Type_open */1
        ) : (
          cstrs.TAG === /* Type_record */0 ? ({
                TAG: /* Type_record */0,
                _0: Stdlib__List.map((function (l) {
                        return {
                                ld_id: l.ld_id,
                                ld_mutable: l.ld_mutable,
                                ld_type: nondep_type_rec(env, mid, l.ld_type),
                                ld_loc: l.ld_loc,
                                ld_attributes: l.ld_attributes
                              };
                      }), cstrs._0),
                _1: cstrs._1
              }) : ({
                TAG: /* Type_variant */1,
                _0: Stdlib__List.map((function (c) {
                        return {
                                cd_id: c.cd_id,
                                cd_args: Stdlib__List.map((function (param) {
                                        return nondep_type_rec(env, mid, param);
                                      }), c.cd_args),
                                cd_res: may_map((function (param) {
                                        return nondep_type_rec(env, mid, param);
                                      }), c.cd_res),
                                cd_loc: c.cd_loc,
                                cd_attributes: c.cd_attributes
                              };
                      }), cstrs._0)
              })
        );
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        if (is_covariant) {
          tk = /* Type_abstract */0;
        } else {
          throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
        }
      } else {
        throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
      }
    }
    let tm;
    try {
      const ty = decl.type_manifest;
      tm = ty !== undefined ? unroll_abbrev(id, params, nondep_type_rec(env, mid, ty)) : undefined;
    }
    catch (raw_exn$1){
      const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
      if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
        if (is_covariant) {
          tm = undefined;
        } else {
          throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
        }
      } else {
        throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
      }
    }
    Curry._1(TypeHash.clear, nondep_hash);
    Curry._1(TypeHash.clear, nondep_variants);
    const priv = tm !== undefined && has_constr_row(tm) ? /* Private */0 : decl.type_private;
    return {
            type_params: params,
            type_arity: decl.type_arity,
            type_kind: tk,
            type_private: priv,
            type_manifest: tm,
            type_variance: decl.type_variance,
            type_newtype_level: undefined,
            type_loc: decl.type_loc,
            type_attributes: decl.type_attributes
          };
  }
  catch (raw_exn$2){
    const exn$2 = Caml_js_exceptions.internalToOCamlException(raw_exn$2);
    if (exn$2.MEL_EXN_ID === Stdlib.Not_found) {
      Curry._1(TypeHash.clear, nondep_hash);
      Curry._1(TypeHash.clear, nondep_variants);
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
    }
    throw new Caml_js_exceptions.MelangeError(exn$2.MEL_EXN_ID, exn$2);
  }
}

function nondep_extension_constructor(env, mid, ext) {
  try {
    let match;
    if (isfree(mid, ext.ext_type_path)) {
      const ty = newty2(100000000, {
            TAG: /* Tconstr */3,
            _0: ext.ext_type_path,
            _1: ext.ext_type_params,
            _2: {
              contents: /* Mnil */0
            }
          });
      const ty$p = nondep_type_rec(env, mid, ty);
      const match$1 = repr(ty$p).desc;
      if (typeof match$1 === "number") {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                  MEL_EXN_ID: Stdlib.Not_found
                });
      }
      if (match$1.TAG === /* Tconstr */3) {
        match = [
          match$1._0,
          match$1._1
        ];
      } else {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                  MEL_EXN_ID: Stdlib.Not_found
                });
      }
    } else {
      const type_params = Stdlib__List.map((function (param) {
              return nondep_type_rec(env, mid, param);
            }), ext.ext_type_params);
      match = [
        ext.ext_type_path,
        type_params
      ];
    }
    const args = Stdlib__List.map((function (param) {
            return nondep_type_rec(env, mid, param);
          }), ext.ext_args);
    const ret_type = may_map((function (param) {
            return nondep_type_rec(env, mid, param);
          }), ext.ext_ret_type);
    Curry._1(TypeHash.clear, nondep_hash);
    Curry._1(TypeHash.clear, nondep_variants);
    return {
            ext_type_path: match[0],
            ext_type_params: match[1],
            ext_args: args,
            ext_ret_type: ret_type,
            ext_private: ext.ext_private,
            ext_loc: ext.ext_loc,
            ext_attributes: ext.ext_attributes
          };
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      Curry._1(TypeHash.clear, nondep_hash);
      Curry._1(TypeHash.clear, nondep_variants);
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function nondep_class_signature(env, id, sign) {
  return {
          csig_self: nondep_type_rec(env, id, sign.csig_self),
          csig_vars: Curry._2(Meths.map, (function (param) {
                  return [
                          param[0],
                          param[1],
                          nondep_type_rec(env, id, param[2])
                        ];
                }), sign.csig_vars),
          csig_concr: sign.csig_concr,
          csig_inher: Stdlib__List.map((function (param) {
                  return [
                          param[0],
                          Stdlib__List.map((function (param) {
                                  return nondep_type_rec(env, id, param);
                                }), param[1])
                        ];
                }), sign.csig_inher)
        };
}

function nondep_class_type(env, id, _sign) {
  while(true) {
    const sign = _sign;
    switch (sign.TAG | 0) {
      case /* Cty_constr */0 :
          const p = sign._0;
          if (!isfree(id, p)) {
            return {
                    TAG: /* Cty_constr */0,
                    _0: p,
                    _1: Stdlib__List.map((function (param) {
                            return nondep_type_rec(env, id, param);
                          }), sign._1),
                    _2: nondep_class_type(env, id, sign._2)
                  };
          }
          _sign = sign._2;
          continue ;
      case /* Cty_signature */1 :
          return {
                  TAG: /* Cty_signature */1,
                  _0: nondep_class_signature(env, id, sign._0)
                };
      case /* Cty_arrow */2 :
          return {
                  TAG: /* Cty_arrow */2,
                  _0: sign._0,
                  _1: nondep_type_rec(env, id, sign._1),
                  _2: nondep_class_type(env, id, sign._2)
                };
      
    }
  };
}

function nondep_class_declaration(env, id, decl) {
  if (isfree(id, decl.cty_path)) {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                34461,
                2
              ]
            });
  }
  const ty = decl.cty_new;
  const decl$1 = {
    cty_params: Stdlib__List.map((function (param) {
            return nondep_type_rec(env, id, param);
          }), decl.cty_params),
    cty_type: nondep_class_type(env, id, decl.cty_type),
    cty_path: decl.cty_path,
    cty_new: ty !== undefined ? nondep_type_rec(env, id, ty) : undefined,
    cty_variance: decl.cty_variance,
    cty_loc: decl.cty_loc,
    cty_attributes: decl.cty_attributes
  };
  Curry._1(TypeHash.clear, nondep_hash);
  Curry._1(TypeHash.clear, nondep_variants);
  return decl$1;
}

function nondep_cltype_declaration(env, id, decl) {
  if (isfree(id, decl.clty_path)) {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                34480,
                2
              ]
            });
  }
  const decl_clty_params = Stdlib__List.map((function (param) {
          return nondep_type_rec(env, id, param);
        }), decl.clty_params);
  const decl_clty_type = nondep_class_type(env, id, decl.clty_type);
  const decl_clty_path = decl.clty_path;
  const decl_clty_variance = decl.clty_variance;
  const decl_clty_loc = decl.clty_loc;
  const decl_clty_attributes = decl.clty_attributes;
  const decl$1 = {
    clty_params: decl_clty_params,
    clty_type: decl_clty_type,
    clty_path: decl_clty_path,
    clty_variance: decl_clty_variance,
    clty_loc: decl_clty_loc,
    clty_attributes: decl_clty_attributes
  };
  Curry._1(TypeHash.clear, nondep_hash);
  Curry._1(TypeHash.clear, nondep_variants);
  return decl$1;
}

function collapse_conj(env, visited, ty) {
  const ty$1 = repr(ty);
  if (Stdlib__List.memq(ty$1, visited)) {
    return ;
  }
  const visited$1 = {
    hd: ty$1,
    tl: visited
  };
  const row = ty$1.desc;
  if (typeof row === "number") {
    return iter_type_expr((function (param) {
                  return collapse_conj(env, visited$1, param);
                }), ty$1);
  }
  if (row.TAG !== /* Tvariant */8) {
    return iter_type_expr((function (param) {
                  return collapse_conj(env, visited$1, param);
                }), ty$1);
  }
  const row$1 = row_repr_aux(/* [] */0, row._0);
  Stdlib__List.iter((function (param) {
          const match = row_field_repr_aux(/* [] */0, param[1]);
          if (typeof match === "number") {
            return ;
          }
          if (match.TAG === /* Rpresent */0) {
            return ;
          }
          const match$1 = match._1;
          if (!match$1) {
            return ;
          }
          const tl = match$1.tl;
          if (!tl) {
            return ;
          }
          const t1 = match$1.hd;
          Stdlib__List.iter((function (param) {
                  return unify$2(env, t1, param);
                }), tl);
          set_row_field(match._3, {
                TAG: /* Reither */1,
                _0: match._0,
                _1: {
                  hd: t1,
                  tl: /* [] */0
                },
                _2: match._2,
                _3: {
                  contents: undefined
                }
              });
        }), row$1.row_fields);
  iter_row((function (param) {
          return collapse_conj(env, visited$1, param);
        }), row$1);
}

function collapse_conj_params(env, params) {
  Stdlib__List.iter((function (param) {
          return collapse_conj(env, /* [] */0, param);
        }), params);
}

const out_ident = {
  contents: Stdlib__Format.pp_print_string
};

function print_ident(ppf, s) {
  switch (s.TAG | 0) {
    case /* Oide_apply */0 :
        return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Alpha */15,
                          _0: {
                            TAG: /* Char_literal */12,
                            _0: /* '(' */40,
                            _1: {
                              TAG: /* Alpha */15,
                              _0: {
                                TAG: /* Char_literal */12,
                                _0: /* ')' */41,
                                _1: /* End_of_format */0
                              }
                            }
                          }
                        },
                        _1: "%a(%a)"
                      }), print_ident, s._0, print_ident, s._1);
    case /* Oide_dot */1 :
        print_ident(ppf, s._0);
        Stdlib__Format.pp_print_char(ppf, /* '.' */46);
        return Curry._2(out_ident.contents, ppf, s._1);
    case /* Oide_ident */2 :
        return Curry._2(out_ident.contents, ppf, s._0);
    
  }
}

function parenthesized_ident(name) {
  if (Stdlib__List.mem(name, {
          hd: "or",
          tl: {
            hd: "mod",
            tl: {
              hd: "land",
              tl: {
                hd: "lor",
                tl: {
                  hd: "lxor",
                  tl: {
                    hd: "lsl",
                    tl: {
                      hd: "lsr",
                      tl: {
                        hd: "asr",
                        tl: /* [] */0
                      }
                    }
                  }
                }
              }
            }
          }
        })) {
    return true;
  }
  const match = Caml_string.get(name, 0);
  if (match >= 97) {
    if (match >= 223) {
      return match === 247;
    } else {
      return match >= 123;
    }
  } else if (match >= 91) {
    return match !== 95;
  } else {
    return match < 65;
  }
}

function value_ident(ppf, name) {
  if (parenthesized_ident(name)) {
    return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "( ",
                      _1: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* String_literal */11,
                          _0: " )",
                          _1: /* End_of_format */0
                        }
                      }
                    },
                    _1: "( %s )"
                  }), name);
  } else {
    return Stdlib__Format.pp_print_string(ppf, name);
  }
}

function print_list(pr, sep, ppf, _param) {
  while(true) {
    const param = _param;
    if (!param) {
      return ;
    }
    const a = param.hd;
    if (!param.tl) {
      return Curry._2(pr, ppf, a);
    }
    Curry._2(pr, ppf, a);
    Curry._1(sep, ppf);
    _param = param.tl;
    continue ;
  };
}

function pr_present(param, param$1) {
  return print_list((function (ppf, s) {
                Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* Char_literal */12,
                            _0: /* '`' */96,
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: /* End_of_format */0
                            }
                          },
                          _1: "`%s"
                        }), s);
              }), (function (ppf) {
                Stdlib__Format.fprintf(ppf)(/* Format */{
                      _0: {
                        TAG: /* Formatting_lit */17,
                        _0: {
                          TAG: /* Break */0,
                          _0: "@ ",
                          _1: 1,
                          _2: 0
                        },
                        _1: /* End_of_format */0
                      },
                      _1: "@ "
                    });
              }), param, param$1);
}

function pr_vars(param, param$1) {
  return print_list((function (ppf, s) {
                Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* Char_literal */12,
                            _0: /* '\'' */39,
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: /* End_of_format */0
                            }
                          },
                          _1: "'%s"
                        }), s);
              }), (function (ppf) {
                Stdlib__Format.fprintf(ppf)(/* Format */{
                      _0: {
                        TAG: /* Formatting_lit */17,
                        _0: {
                          TAG: /* Break */0,
                          _0: "@ ",
                          _1: 1,
                          _2: 0
                        },
                        _1: /* End_of_format */0
                      },
                      _1: "@ "
                    });
              }), param, param$1);
}

function print_out_type(ppf, ty) {
  if (typeof ty === "number") {
    return print_out_type_1(ppf, ty);
  }
  switch (ty.TAG | 0) {
    case /* Otyp_alias */0 :
        return Curry._3(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: /* End_of_format */0,
                              _1: ""
                            }
                          },
                          _1: {
                            TAG: /* Alpha */15,
                            _0: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@ ",
                                _1: 1,
                                _2: 0
                              },
                              _1: {
                                TAG: /* String_literal */11,
                                _0: "as '",
                                _1: {
                                  TAG: /* String */2,
                                  _0: /* No_padding */0,
                                  _1: {
                                    TAG: /* Formatting_lit */17,
                                    _0: /* Close_box */0,
                                    _1: /* End_of_format */0
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@[%a@ as '%s@]"
                      }), print_out_type, ty._0, ty._1);
    case /* Otyp_poly */12 :
        return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<hov 2>",
                                _1: /* End_of_format */0
                              },
                              _1: "<hov 2>"
                            }
                          },
                          _1: {
                            TAG: /* Alpha */15,
                            _0: {
                              TAG: /* Char_literal */12,
                              _0: /* '.' */46,
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@ ",
                                  _1: 1,
                                  _2: 0
                                },
                                _1: {
                                  TAG: /* Alpha */15,
                                  _0: {
                                    TAG: /* Formatting_lit */17,
                                    _0: /* Close_box */0,
                                    _1: /* End_of_format */0
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@[<hov 2>%a.@ %a@]"
                      }), pr_vars, ty._0, print_out_type, ty._1);
    default:
      return print_out_type_1(ppf, ty);
  }
}

function print_out_type_1(ppf, ty) {
  if (typeof ty === "number") {
    return print_out_type_2(ppf, ty);
  }
  if (ty.TAG !== /* Otyp_arrow */1) {
    return print_out_type_2(ppf, ty);
  }
  const lab = ty._0;
  Stdlib__Format.pp_open_box(ppf, 0);
  if (lab !== "") {
    Stdlib__Format.pp_print_string(ppf, lab);
    Stdlib__Format.pp_print_char(ppf, /* ':' */58);
  }
  print_out_type_2(ppf, ty._1);
  Stdlib__Format.pp_print_string(ppf, " ->");
  Stdlib__Format.pp_print_space(ppf, undefined);
  print_out_type_1(ppf, ty._2);
  Stdlib__Format.pp_close_box(ppf, undefined);
}

function print_out_type_2(ppf, tyl) {
  if (typeof tyl === "number" || tyl.TAG !== /* Otyp_tuple */9) {
    return print_simple_out_type(ppf, tyl);
  } else {
    return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                    _0: {
                      TAG: /* Formatting_gen */18,
                      _0: {
                        TAG: /* Open_box */1,
                        _0: /* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "<0>",
                            _1: /* End_of_format */0
                          },
                          _1: "<0>"
                        }
                      },
                      _1: {
                        TAG: /* Alpha */15,
                        _0: {
                          TAG: /* Formatting_lit */17,
                          _0: /* Close_box */0,
                          _1: /* End_of_format */0
                        }
                      }
                    },
                    _1: "@[<0>%a@]"
                  }), (function (param, param$1) {
                  return print_typlist(print_simple_out_type, " *", param, param$1);
                }), tyl._0);
  }
}

function print_simple_out_type(ppf, s) {
  if (typeof s === "number") {
    return ;
  }
  switch (s.TAG | 0) {
    case /* Otyp_class */2 :
        return Curry._5(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: /* End_of_format */0,
                              _1: ""
                            }
                          },
                          _1: {
                            TAG: /* Alpha */15,
                            _0: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Char_literal */12,
                                _0: /* '#' */35,
                                _1: {
                                  TAG: /* Alpha */15,
                                  _0: {
                                    TAG: /* Formatting_lit */17,
                                    _0: /* Close_box */0,
                                    _1: /* End_of_format */0
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@[%a%s#%a@]"
                      }), print_typargs, s._2, s._0 ? "_" : "", print_ident, s._1);
    case /* Otyp_constr */3 :
        const id = s._0;
        let exit = 0;
        switch (id.TAG | 0) {
          case /* Oide_dot */1 :
              const match = id._0;
              let exit$1 = 0;
              switch (match.TAG | 0) {
                case /* Oide_apply */0 :
                    exit = 2;
                    break;
                case /* Oide_dot */1 :
                    const match$1 = match._0;
                    switch (match$1.TAG | 0) {
                      case /* Oide_apply */0 :
                      case /* Oide_dot */1 :
                          exit = 2;
                          break;
                      case /* Oide_ident */2 :
                          if (match$1._0 === "Js" && match._1 === "Internal") {
                            exit$1 = 3;
                          } else {
                            exit = 2;
                          }
                          break;
                      
                    }
                    break;
                case /* Oide_ident */2 :
                    if (match._0 === "Js_internal") {
                      exit$1 = 3;
                    } else {
                      exit = 2;
                    }
                    break;
                
              }
              if (exit$1 === 3) {
                const name = id._1;
                let exit$2 = 0;
                switch (name) {
                  case "fn" :
                  case "meth" :
                      exit$2 = 4;
                      break;
                  case "meth_callback" :
                      const tyl = s._1;
                      if (tyl) {
                        const match$2 = tyl.hd;
                        if (typeof match$2 === "number" || match$2.TAG !== /* Otyp_variant */11) {
                          exit = 2;
                        } else {
                          const match$3 = match$2._1;
                          if (match$3.TAG === /* Ovar_fields */0) {
                            const match$4 = match$3._0;
                            if (match$4 && !match$4.tl) {
                              const match$5 = tyl.tl;
                              if (match$5 && !match$5.tl) {
                                const match$6 = match$4.hd;
                                const variant = match$6[0];
                                const make = function (tys, result) {
                                  if (tys) {
                                    const single = tys.hd;
                                    if (typeof single !== "number" && single.TAG === /* Otyp_tuple */9) {
                                      if (tys.tl) {
                                        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                                                  MEL_EXN_ID: Stdlib.Not_found
                                                });
                                      }
                                      if (variant === "Arity_1") {
                                        return {
                                                TAG: /* Otyp_arrow */1,
                                                _0: "",
                                                _1: single,
                                                _2: result
                                              };
                                      } else {
                                        return Stdlib__List.fold_right((function (x, acc) {
                                                      return {
                                                              TAG: /* Otyp_arrow */1,
                                                              _0: "",
                                                              _1: x,
                                                              _2: acc
                                                            };
                                                    }), single._0, result);
                                      }
                                    }
                                    if (tys.tl) {
                                      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                                                MEL_EXN_ID: Stdlib.Not_found
                                              });
                                    }
                                    return {
                                            TAG: /* Otyp_arrow */1,
                                            _0: "",
                                            _1: single,
                                            _2: result
                                          };
                                  }
                                  throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                                            MEL_EXN_ID: Stdlib.Not_found
                                          });
                                };
                                let exit$3 = 0;
                                let res;
                                try {
                                  res = make(match$6[2], match$5.hd);
                                  exit$3 = 5;
                                }
                                catch (exn){
                                  Stdlib__Format.pp_open_box(ppf, 0);
                                  print_typargs(ppf, tyl);
                                  print_ident(ppf, id);
                                  return Stdlib__Format.pp_close_box(ppf, undefined);
                                }
                                if (exit$3 === 5) {
                                  return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                                                  _0: {
                                                    TAG: /* Formatting_gen */18,
                                                    _0: {
                                                      TAG: /* Open_box */1,
                                                      _0: /* Format */{
                                                        _0: {
                                                          TAG: /* String_literal */11,
                                                          _0: "<0>",
                                                          _1: /* End_of_format */0
                                                        },
                                                        _1: "<0>"
                                                      }
                                                    },
                                                    _1: {
                                                      TAG: /* Char_literal */12,
                                                      _0: /* '(' */40,
                                                      _1: {
                                                        TAG: /* Alpha */15,
                                                        _0: {
                                                          TAG: /* Formatting_lit */17,
                                                          _0: {
                                                            TAG: /* Break */0,
                                                            _0: "@ ",
                                                            _1: 1,
                                                            _2: 0
                                                          },
                                                          _1: {
                                                            TAG: /* Char_literal */12,
                                                            _0: /* '[' */91,
                                                            _1: {
                                                              TAG: /* Formatting_lit */17,
                                                              _0: {
                                                                TAG: /* Scan_indic */2,
                                                                _0: /* 'm' */109
                                                              },
                                                              _1: {
                                                                TAG: /* String_literal */11,
                                                                _0: "el.this])",
                                                                _1: {
                                                                  TAG: /* Formatting_lit */17,
                                                                  _0: /* Close_box */0,
                                                                  _1: /* End_of_format */0
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  },
                                                  _1: "@[<0>(%a@ [@mel.this])@]"
                                                }), print_out_type_1, res);
                                }
                                
                              } else {
                                exit = 2;
                              }
                            } else {
                              exit = 2;
                            }
                          } else {
                            exit = 2;
                          }
                        }
                      } else {
                        exit = 2;
                      }
                      break;
                  default:
                    exit = 2;
                }
                if (exit$2 === 4) {
                  const tyl$1 = s._1;
                  if (tyl$1) {
                    const match$7 = tyl$1.hd;
                    if (typeof match$7 === "number" || match$7.TAG !== /* Otyp_variant */11) {
                      exit = 2;
                    } else {
                      const match$8 = match$7._1;
                      if (match$8.TAG === /* Ovar_fields */0) {
                        const match$9 = match$8._0;
                        if (match$9 && !match$9.tl) {
                          const match$10 = tyl$1.tl;
                          if (match$10 && !match$10.tl) {
                            const match$11 = match$9.hd;
                            const variant$1 = match$11[0];
                            const make$1 = function (tys, result) {
                              if (Caml_obj.caml_equal(tys, /* [] */0)) {
                                return {
                                        TAG: /* Otyp_arrow */1,
                                        _0: "",
                                        _1: {
                                          TAG: /* Otyp_constr */3,
                                          _0: {
                                            TAG: /* Oide_ident */2,
                                            _0: "unit"
                                          },
                                          _1: /* [] */0
                                        },
                                        _2: result
                                      };
                              }
                              if (tys) {
                                const single = tys.hd;
                                if (typeof single !== "number" && single.TAG === /* Otyp_tuple */9) {
                                  if (tys.tl) {
                                    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                                              MEL_EXN_ID: Stdlib.Not_found
                                            });
                                  }
                                  if (variant$1 === "Arity_1") {
                                    return {
                                            TAG: /* Otyp_arrow */1,
                                            _0: "",
                                            _1: single,
                                            _2: result
                                          };
                                  } else {
                                    return Stdlib__List.fold_right((function (x, acc) {
                                                  return {
                                                          TAG: /* Otyp_arrow */1,
                                                          _0: "",
                                                          _1: x,
                                                          _2: acc
                                                        };
                                                }), single._0, result);
                                  }
                                }
                                if (tys.tl) {
                                  throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                                            MEL_EXN_ID: Stdlib.Not_found
                                          });
                                }
                                return {
                                        TAG: /* Otyp_arrow */1,
                                        _0: "",
                                        _1: single,
                                        _2: result
                                      };
                              }
                              throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                                        MEL_EXN_ID: Stdlib.Not_found
                                      });
                            };
                            let exit$4 = 0;
                            let res$1;
                            try {
                              res$1 = make$1(match$11[2], match$10.hd);
                              exit$4 = 5;
                            }
                            catch (exn$1){
                              Stdlib__Format.pp_open_box(ppf, 0);
                              print_typargs(ppf, tyl$1);
                              print_ident(ppf, id);
                              return Stdlib__Format.pp_close_box(ppf, undefined);
                            }
                            if (exit$4 === 5) {
                              switch (name) {
                                case "fn" :
                                    return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                                                    _0: {
                                                      TAG: /* Formatting_gen */18,
                                                      _0: {
                                                        TAG: /* Open_box */1,
                                                        _0: /* Format */{
                                                          _0: {
                                                            TAG: /* String_literal */11,
                                                            _0: "<0>",
                                                            _1: /* End_of_format */0
                                                          },
                                                          _1: "<0>"
                                                        }
                                                      },
                                                      _1: {
                                                        TAG: /* Char_literal */12,
                                                        _0: /* '(' */40,
                                                        _1: {
                                                          TAG: /* Alpha */15,
                                                          _0: {
                                                            TAG: /* Formatting_lit */17,
                                                            _0: {
                                                              TAG: /* Break */0,
                                                              _0: "@ ",
                                                              _1: 1,
                                                              _2: 0
                                                            },
                                                            _1: {
                                                              TAG: /* Char_literal */12,
                                                              _0: /* '[' */91,
                                                              _1: {
                                                                TAG: /* Formatting_lit */17,
                                                                _0: {
                                                                  TAG: /* Scan_indic */2,
                                                                  _0: /* 'u' */117
                                                                },
                                                                _1: {
                                                                  TAG: /* String_literal */11,
                                                                  _0: "])",
                                                                  _1: {
                                                                    TAG: /* Formatting_lit */17,
                                                                    _0: /* Close_box */0,
                                                                    _1: /* End_of_format */0
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    },
                                                    _1: "@[<0>(%a@ [@u])@]"
                                                  }), print_out_type_1, res$1);
                                case "meth" :
                                    return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                                                    _0: {
                                                      TAG: /* Formatting_gen */18,
                                                      _0: {
                                                        TAG: /* Open_box */1,
                                                        _0: /* Format */{
                                                          _0: {
                                                            TAG: /* String_literal */11,
                                                            _0: "<0>",
                                                            _1: /* End_of_format */0
                                                          },
                                                          _1: "<0>"
                                                        }
                                                      },
                                                      _1: {
                                                        TAG: /* Char_literal */12,
                                                        _0: /* '(' */40,
                                                        _1: {
                                                          TAG: /* Alpha */15,
                                                          _0: {
                                                            TAG: /* Formatting_lit */17,
                                                            _0: {
                                                              TAG: /* Break */0,
                                                              _0: "@ ",
                                                              _1: 1,
                                                              _2: 0
                                                            },
                                                            _1: {
                                                              TAG: /* Char_literal */12,
                                                              _0: /* '[' */91,
                                                              _1: {
                                                                TAG: /* Formatting_lit */17,
                                                                _0: {
                                                                  TAG: /* Scan_indic */2,
                                                                  _0: /* 'm' */109
                                                                },
                                                                _1: {
                                                                  TAG: /* String_literal */11,
                                                                  _0: "el.meth])",
                                                                  _1: {
                                                                    TAG: /* Formatting_lit */17,
                                                                    _0: /* Close_box */0,
                                                                    _1: /* End_of_format */0
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    },
                                                    _1: "@[<0>(%a@ [@mel.meth])@]"
                                                  }), print_out_type_1, res$1);
                                default:
                                  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                                            MEL_EXN_ID: "Assert_failure",
                                            _1: [
                                              "jscomp/test/ocaml_typedtree_test.ml",
                                              34910,
                                              17
                                            ]
                                          });
                              }
                            }
                            
                          } else {
                            exit = 2;
                          }
                        } else {
                          exit = 2;
                        }
                      } else {
                        exit = 2;
                      }
                    }
                  } else {
                    exit = 2;
                  }
                }
                
              }
              break;
          case /* Oide_apply */0 :
          case /* Oide_ident */2 :
              exit = 2;
              break;
          
        }
        if (exit === 2) {
          Stdlib__Format.pp_open_box(ppf, 0);
          print_typargs(ppf, s._1);
          print_ident(ppf, id);
          return Stdlib__Format.pp_close_box(ppf, undefined);
        }
        break;
    case /* Otyp_object */5 :
        const rest = s._1;
        return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<2>",
                                _1: /* End_of_format */0
                              },
                              _1: "<2>"
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "< ",
                            _1: {
                              TAG: /* Alpha */15,
                              _0: {
                                TAG: /* String_literal */11,
                                _0: " >",
                                _1: {
                                  TAG: /* Formatting_lit */17,
                                  _0: /* Close_box */0,
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          }
                        },
                        _1: "@[<2>< %a >@]"
                      }), (function (param, param$1) {
                      return print_fields(rest, param, param$1);
                    }), s._0);
    case /* Otyp_stuff */7 :
        return Stdlib__Format.pp_print_string(ppf, s._0);
    case /* Otyp_var */10 :
        return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Char_literal */12,
                          _0: /* '\'' */39,
                          _1: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: /* End_of_format */0
                            }
                          }
                        },
                        _1: "'%s%s"
                      }), s._0 ? "_" : "", s._1);
    case /* Otyp_variant */11 :
        const tags = s._3;
        const print_present = function (ppf, l) {
          if (l !== undefined && l) {
            return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                            _0: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@;<1 -2>",
                                _1: 1,
                                _2: -2
                              },
                              _1: {
                                TAG: /* String_literal */11,
                                _0: "> ",
                                _1: {
                                  TAG: /* Formatting_gen */18,
                                  _0: {
                                    TAG: /* Open_box */1,
                                    _0: /* Format */{
                                      _0: {
                                        TAG: /* String_literal */11,
                                        _0: "<hov>",
                                        _1: /* End_of_format */0
                                      },
                                      _1: "<hov>"
                                    }
                                  },
                                  _1: {
                                    TAG: /* Alpha */15,
                                    _0: {
                                      TAG: /* Formatting_lit */17,
                                      _0: /* Close_box */0,
                                      _1: /* End_of_format */0
                                    }
                                  }
                                }
                              }
                            },
                            _1: "@;<1 -2>> @[<hov>%a@]"
                          }), pr_present, l);
          }
          
        };
        const print_fields$1 = function (ppf, fields) {
          if (fields.TAG === /* Ovar_fields */0) {
            return print_list(print_row_field, (function (ppf) {
                          Stdlib__Format.fprintf(ppf)(/* Format */{
                                _0: {
                                  TAG: /* Formatting_lit */17,
                                  _0: {
                                    TAG: /* Break */0,
                                    _0: "@;<1 -2>",
                                    _1: 1,
                                    _2: -2
                                  },
                                  _1: {
                                    TAG: /* String_literal */11,
                                    _0: "| ",
                                    _1: /* End_of_format */0
                                  }
                                },
                                _1: "@;<1 -2>| "
                              });
                        }), ppf, fields._0);
          } else {
            return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                            _0: {
                              TAG: /* Formatting_gen */18,
                              _0: {
                                TAG: /* Open_box */1,
                                _0: /* Format */{
                                  _0: /* End_of_format */0,
                                  _1: ""
                                }
                              },
                              _1: {
                                TAG: /* Alpha */15,
                                _0: {
                                  TAG: /* Alpha */15,
                                  _0: {
                                    TAG: /* Formatting_lit */17,
                                    _0: /* Close_box */0,
                                    _1: /* End_of_format */0
                                  }
                                }
                              }
                            },
                            _1: "@[%a%a@]"
                          }), print_typargs, fields._1, print_ident, fields._0);
          }
        };
        return Curry._6(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* Char_literal */12,
                            _0: /* '[' */91,
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Formatting_gen */18,
                                _0: {
                                  TAG: /* Open_box */1,
                                  _0: /* Format */{
                                    _0: {
                                      TAG: /* String_literal */11,
                                      _0: "<hv>",
                                      _1: /* End_of_format */0
                                    },
                                    _1: "<hv>"
                                  }
                                },
                                _1: {
                                  TAG: /* Formatting_gen */18,
                                  _0: {
                                    TAG: /* Open_box */1,
                                    _0: /* Format */{
                                      _0: {
                                        TAG: /* String_literal */11,
                                        _0: "<hv>",
                                        _1: /* End_of_format */0
                                      },
                                      _1: "<hv>"
                                    }
                                  },
                                  _1: {
                                    TAG: /* Alpha */15,
                                    _0: {
                                      TAG: /* Formatting_lit */17,
                                      _0: /* Close_box */0,
                                      _1: {
                                        TAG: /* Alpha */15,
                                        _0: {
                                          TAG: /* String_literal */11,
                                          _0: " ]",
                                          _1: {
                                            TAG: /* Formatting_lit */17,
                                            _0: /* Close_box */0,
                                            _1: /* End_of_format */0
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "%s[%s@[<hv>@[<hv>%a@]%a ]@]"
                      }), s._0 ? "_" : "", s._2 ? (
                      tags === undefined ? " " : "< "
                    ) : (
                      tags === undefined ? "> " : "? "
                    ), print_fields$1, s._1, print_present, tags);
    case /* Otyp_alias */0 :
    case /* Otyp_arrow */1 :
    case /* Otyp_tuple */9 :
    case /* Otyp_poly */12 :
        break;
    case /* Otyp_module */13 :
        Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                  _0: {
                    TAG: /* Formatting_gen */18,
                    _0: {
                      TAG: /* Open_box */1,
                      _0: /* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "<1>",
                          _1: /* End_of_format */0
                        },
                        _1: "<1>"
                      }
                    },
                    _1: {
                      TAG: /* String_literal */11,
                      _0: "(module ",
                      _1: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: /* End_of_format */0
                      }
                    }
                  },
                  _1: "@[<1>(module %s"
                }), s._0);
        const first = {
          contents: true
        };
        Stdlib__List.iter2((function (s, t) {
                const sep = first.contents ? (first.contents = false, "with") : "and";
                Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* Char_literal */12,
                            _0: /* ' ' */32,
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* String_literal */11,
                                _0: " type ",
                                _1: {
                                  TAG: /* String */2,
                                  _0: /* No_padding */0,
                                  _1: {
                                    TAG: /* String_literal */11,
                                    _0: " = ",
                                    _1: {
                                      TAG: /* Alpha */15,
                                      _0: /* End_of_format */0
                                    }
                                  }
                                }
                              }
                            }
                          },
                          _1: " %s type %s = %a"
                        }), sep, s, print_out_type, t);
              }), s._1, s._2);
        return Stdlib__Format.fprintf(ppf)(/* Format */{
                    _0: {
                      TAG: /* Char_literal */12,
                      _0: /* ')' */41,
                      _1: {
                        TAG: /* Formatting_lit */17,
                        _0: /* Close_box */0,
                        _1: /* End_of_format */0
                      }
                    },
                    _1: ")@]"
                  });
    default:
      return ;
  }
  Stdlib__Format.pp_open_box(ppf, 1);
  Stdlib__Format.pp_print_char(ppf, /* '(' */40);
  print_out_type(ppf, s);
  Stdlib__Format.pp_print_char(ppf, /* ')' */41);
  Stdlib__Format.pp_close_box(ppf, undefined);
}

function print_fields(rest, ppf, _param) {
  while(true) {
    const param = _param;
    if (!param) {
      if (rest !== undefined) {
        return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "..",
                            _1: /* End_of_format */0
                          }
                        },
                        _1: "%s.."
                      }), rest ? "_" : "");
      } else {
        return ;
      }
    }
    const match = param.hd;
    const s = match[0];
    if (param.tl) {
      return Curry._5(Stdlib__Format.fprintf(ppf)(/* Format */{
                      _0: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* String_literal */11,
                          _0: " : ",
                          _1: {
                            TAG: /* Alpha */15,
                            _0: {
                              TAG: /* Char_literal */12,
                              _0: /* ';' */59,
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@ ",
                                  _1: 1,
                                  _2: 0
                                },
                                _1: {
                                  TAG: /* Alpha */15,
                                  _0: /* End_of_format */0
                                }
                              }
                            }
                          }
                        }
                      },
                      _1: "%s : %a;@ %a"
                    }), s, print_out_type, match[1], (function (param, param$1) {
                    return print_fields(rest, param, param$1);
                  }), param.tl);
    }
    Curry._3(Stdlib__Format.fprintf(ppf)(/* Format */{
              _0: {
                TAG: /* String */2,
                _0: /* No_padding */0,
                _1: {
                  TAG: /* String_literal */11,
                  _0: " : ",
                  _1: {
                    TAG: /* Alpha */15,
                    _0: /* End_of_format */0
                  }
                }
              },
              _1: "%s : %a"
            }), s, print_out_type, match[1]);
    if (rest !== undefined) {
      Stdlib__Format.fprintf(ppf)(/* Format */{
            _0: {
              TAG: /* Char_literal */12,
              _0: /* ';' */59,
              _1: {
                TAG: /* Formatting_lit */17,
                _0: {
                  TAG: /* Break */0,
                  _0: "@ ",
                  _1: 1,
                  _2: 0
                },
                _1: /* End_of_format */0
              }
            },
            _1: ";@ "
          });
    }
    _param = /* [] */0;
    continue ;
  };
}

function print_row_field(ppf, param) {
  const tyl = param[2];
  const opt_amp = param[1];
  const pr_of = function (ppf) {
    if (opt_amp) {
      return Stdlib__Format.fprintf(ppf)(/* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: " of",
                    _1: {
                      TAG: /* Formatting_lit */17,
                      _0: {
                        TAG: /* Break */0,
                        _0: "@ ",
                        _1: 1,
                        _2: 0
                      },
                      _1: {
                        TAG: /* Char_literal */12,
                        _0: /* '&' */38,
                        _1: {
                          TAG: /* Formatting_lit */17,
                          _0: {
                            TAG: /* Break */0,
                            _0: "@ ",
                            _1: 1,
                            _2: 0
                          },
                          _1: /* End_of_format */0
                        }
                      }
                    }
                  },
                  _1: " of@ &@ "
                });
    } else if (Caml_obj.caml_notequal(tyl, /* [] */0)) {
      return Stdlib__Format.fprintf(ppf)(/* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: " of",
                    _1: {
                      TAG: /* Formatting_lit */17,
                      _0: {
                        TAG: /* Break */0,
                        _0: "@ ",
                        _1: 1,
                        _2: 0
                      },
                      _1: /* End_of_format */0
                    }
                  },
                  _1: " of@ "
                });
    } else {
      return Stdlib__Format.fprintf(ppf)(/* Format */{
                  _0: /* End_of_format */0,
                  _1: ""
                });
    }
  };
  Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
            _0: {
              TAG: /* Formatting_gen */18,
              _0: {
                TAG: /* Open_box */1,
                _0: /* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "<hv 2>",
                    _1: /* End_of_format */0
                  },
                  _1: "<hv 2>"
                }
              },
              _1: {
                TAG: /* Char_literal */12,
                _0: /* '`' */96,
                _1: {
                  TAG: /* String */2,
                  _0: /* No_padding */0,
                  _1: {
                    TAG: /* Theta */16,
                    _0: {
                      TAG: /* Alpha */15,
                      _0: {
                        TAG: /* Formatting_lit */17,
                        _0: /* Close_box */0,
                        _1: /* End_of_format */0
                      }
                    }
                  }
                }
              }
            },
            _1: "@[<hv 2>`%s%t%a@]"
          }), param[0], pr_of, (function (param, param$1) {
          return print_typlist(print_out_type, " &", param, param$1);
        }), tyl);
}

function print_typlist(print_elem, sep, ppf, _param) {
  while(true) {
    const param = _param;
    if (!param) {
      return ;
    }
    const ty = param.hd;
    if (!param.tl) {
      return Curry._2(print_elem, ppf, ty);
    }
    Curry._2(print_elem, ppf, ty);
    Stdlib__Format.pp_print_string(ppf, sep);
    Stdlib__Format.pp_print_space(ppf, undefined);
    _param = param.tl;
    continue ;
  };
}

function print_typargs(ppf, tyl) {
  if (tyl) {
    if (tyl.tl) {
      Stdlib__Format.pp_open_box(ppf, 1);
      Stdlib__Format.pp_print_char(ppf, /* '(' */40);
      print_typlist(print_out_type, ",", ppf, tyl);
      Stdlib__Format.pp_print_char(ppf, /* ')' */41);
      Stdlib__Format.pp_close_box(ppf, undefined);
      return Stdlib__Format.pp_print_space(ppf, undefined);
    } else {
      print_simple_out_type(ppf, tyl.hd);
      return Stdlib__Format.pp_print_space(ppf, undefined);
    }
  }
  
}

const out_type = {
  contents: print_out_type
};

function type_parameter(ppf, param) {
  const match = param[1];
  const ty = param[0];
  Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
            _0: {
              TAG: /* String */2,
              _0: /* No_padding */0,
              _1: {
                TAG: /* String */2,
                _0: /* No_padding */0,
                _1: /* End_of_format */0
              }
            },
            _1: "%s%s"
          }), match[1] ? (
          match[0] ? "" : "-"
        ) : "+", ty === "_" ? ty : "'" + ty);
}

function print_out_class_params(ppf, tyl) {
  if (tyl) {
    return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                    _0: {
                      TAG: /* Formatting_gen */18,
                      _0: {
                        TAG: /* Open_box */1,
                        _0: /* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "<1>",
                            _1: /* End_of_format */0
                          },
                          _1: "<1>"
                        }
                      },
                      _1: {
                        TAG: /* Char_literal */12,
                        _0: /* '[' */91,
                        _1: {
                          TAG: /* Alpha */15,
                          _0: {
                            TAG: /* Char_literal */12,
                            _0: /* ']' */93,
                            _1: {
                              TAG: /* Formatting_lit */17,
                              _0: /* Close_box */0,
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@ ",
                                  _1: 1,
                                  _2: 0
                                },
                                _1: /* End_of_format */0
                              }
                            }
                          }
                        }
                      }
                    },
                    _1: "@[<1>[%a]@]@ "
                  }), (function (param, param$1) {
                  return print_list(type_parameter, (function (ppf) {
                                Stdlib__Format.fprintf(ppf)(/* Format */{
                                      _0: {
                                        TAG: /* String_literal */11,
                                        _0: ", ",
                                        _1: /* End_of_format */0
                                      },
                                      _1: ", "
                                    });
                              }), param, param$1);
                }), tyl);
  }
  
}

function print_out_class_type(ppf, param) {
  switch (param.TAG | 0) {
    case /* Octy_constr */0 :
        const pr_tyl = function (ppf, tyl) {
          if (!tyl) {
            return ;
          }
          const partial_arg = out_type.contents;
          Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                    _0: {
                      TAG: /* Formatting_gen */18,
                      _0: {
                        TAG: /* Open_box */1,
                        _0: /* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "<1>",
                            _1: /* End_of_format */0
                          },
                          _1: "<1>"
                        }
                      },
                      _1: {
                        TAG: /* Char_literal */12,
                        _0: /* '[' */91,
                        _1: {
                          TAG: /* Alpha */15,
                          _0: {
                            TAG: /* Char_literal */12,
                            _0: /* ']' */93,
                            _1: {
                              TAG: /* Formatting_lit */17,
                              _0: /* Close_box */0,
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@ ",
                                  _1: 1,
                                  _2: 0
                                },
                                _1: /* End_of_format */0
                              }
                            }
                          }
                        }
                      }
                    },
                    _1: "@[<1>[%a]@]@ "
                  }), (function (param, param$1) {
                  return print_typlist(partial_arg, ",", param, param$1);
                }), tyl);
        };
        return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: /* End_of_format */0,
                              _1: ""
                            }
                          },
                          _1: {
                            TAG: /* Alpha */15,
                            _0: {
                              TAG: /* Alpha */15,
                              _0: {
                                TAG: /* Formatting_lit */17,
                                _0: /* Close_box */0,
                                _1: /* End_of_format */0
                              }
                            }
                          }
                        },
                        _1: "@[%a%a@]"
                      }), pr_tyl, param._1, print_ident, param._0);
    case /* Octy_arrow */1 :
        const lab = param._0;
        return Curry._5(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: /* End_of_format */0,
                              _1: ""
                            }
                          },
                          _1: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: {
                              TAG: /* Alpha */15,
                              _0: {
                                TAG: /* String_literal */11,
                                _0: " ->",
                                _1: {
                                  TAG: /* Formatting_lit */17,
                                  _0: {
                                    TAG: /* Break */0,
                                    _0: "@ ",
                                    _1: 1,
                                    _2: 0
                                  },
                                  _1: {
                                    TAG: /* Alpha */15,
                                    _0: {
                                      TAG: /* Formatting_lit */17,
                                      _0: /* Close_box */0,
                                      _1: /* End_of_format */0
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@[%s%a ->@ %a@]"
                      }), lab !== "" ? lab + ":" : "", print_out_type_2, param._1, print_out_class_type, param._2);
    case /* Octy_signature */2 :
        const pr_param = function (ppf, ty) {
          if (ty !== undefined) {
            return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                            _0: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@ ",
                                _1: 1,
                                _2: 0
                              },
                              _1: {
                                TAG: /* Formatting_gen */18,
                                _0: {
                                  TAG: /* Open_box */1,
                                  _0: /* Format */{
                                    _0: /* End_of_format */0,
                                    _1: ""
                                  }
                                },
                                _1: {
                                  TAG: /* Char_literal */12,
                                  _0: /* '(' */40,
                                  _1: {
                                    TAG: /* Alpha */15,
                                    _0: {
                                      TAG: /* Char_literal */12,
                                      _0: /* ')' */41,
                                      _1: {
                                        TAG: /* Formatting_lit */17,
                                        _0: /* Close_box */0,
                                        _1: /* End_of_format */0
                                      }
                                    }
                                  }
                                }
                              }
                            },
                            _1: "@ @[(%a)@]"
                          }), out_type.contents, ty);
          }
          
        };
        return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<hv 2>",
                                _1: /* End_of_format */0
                              },
                              _1: "<hv 2>"
                            }
                          },
                          _1: {
                            TAG: /* Formatting_gen */18,
                            _0: {
                              TAG: /* Open_box */1,
                              _0: /* Format */{
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: "<2>",
                                  _1: /* End_of_format */0
                                },
                                _1: "<2>"
                              }
                            },
                            _1: {
                              TAG: /* String_literal */11,
                              _0: "object",
                              _1: {
                                TAG: /* Alpha */15,
                                _0: {
                                  TAG: /* Formatting_lit */17,
                                  _0: /* Close_box */0,
                                  _1: {
                                    TAG: /* Formatting_lit */17,
                                    _0: {
                                      TAG: /* Break */0,
                                      _0: "@ ",
                                      _1: 1,
                                      _2: 0
                                    },
                                    _1: {
                                      TAG: /* Alpha */15,
                                      _0: {
                                        TAG: /* Formatting_lit */17,
                                        _0: {
                                          TAG: /* Break */0,
                                          _0: "@;<1 -2>",
                                          _1: 1,
                                          _2: -2
                                        },
                                        _1: {
                                          TAG: /* String_literal */11,
                                          _0: "end",
                                          _1: {
                                            TAG: /* Formatting_lit */17,
                                            _0: /* Close_box */0,
                                            _1: /* End_of_format */0
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@[<hv 2>@[<2>object%a@]@ %a@;<1 -2>end@]"
                      }), pr_param, param._0, (function (param, param$1) {
                      return print_list(print_out_class_sig_item, (function (ppf) {
                                    Stdlib__Format.fprintf(ppf)(/* Format */{
                                          _0: {
                                            TAG: /* Formatting_lit */17,
                                            _0: {
                                              TAG: /* Break */0,
                                              _0: "@ ",
                                              _1: 1,
                                              _2: 0
                                            },
                                            _1: /* End_of_format */0
                                          },
                                          _1: "@ "
                                        });
                                  }), param, param$1);
                    }), param._1);
    
  }
}

function print_out_class_sig_item(ppf, param) {
  switch (param.TAG | 0) {
    case /* Ocsg_constraint */0 :
        return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<2>",
                                _1: /* End_of_format */0
                              },
                              _1: "<2>"
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "constraint ",
                            _1: {
                              TAG: /* Alpha */15,
                              _0: {
                                TAG: /* String_literal */11,
                                _0: " =",
                                _1: {
                                  TAG: /* Formatting_lit */17,
                                  _0: {
                                    TAG: /* Break */0,
                                    _0: "@ ",
                                    _1: 1,
                                    _2: 0
                                  },
                                  _1: {
                                    TAG: /* Alpha */15,
                                    _0: {
                                      TAG: /* Formatting_lit */17,
                                      _0: /* Close_box */0,
                                      _1: /* End_of_format */0
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@[<2>constraint %a =@ %a@]"
                      }), out_type.contents, param._0, out_type.contents, param._1);
    case /* Ocsg_method */1 :
        return Curry._5(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<2>",
                                _1: /* End_of_format */0
                              },
                              _1: "<2>"
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "method ",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* String */2,
                                _0: /* No_padding */0,
                                _1: {
                                  TAG: /* String */2,
                                  _0: /* No_padding */0,
                                  _1: {
                                    TAG: /* String_literal */11,
                                    _0: " :",
                                    _1: {
                                      TAG: /* Formatting_lit */17,
                                      _0: {
                                        TAG: /* Break */0,
                                        _0: "@ ",
                                        _1: 1,
                                        _2: 0
                                      },
                                      _1: {
                                        TAG: /* Alpha */15,
                                        _0: {
                                          TAG: /* Formatting_lit */17,
                                          _0: /* Close_box */0,
                                          _1: /* End_of_format */0
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@[<2>method %s%s%s :@ %a@]"
                      }), param._1 ? "private " : "", param._2 ? "virtual " : "", param._0, out_type.contents, param._3);
    case /* Ocsg_value */2 :
        return Curry._5(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<2>",
                                _1: /* End_of_format */0
                              },
                              _1: "<2>"
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "val ",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* String */2,
                                _0: /* No_padding */0,
                                _1: {
                                  TAG: /* String */2,
                                  _0: /* No_padding */0,
                                  _1: {
                                    TAG: /* String_literal */11,
                                    _0: " :",
                                    _1: {
                                      TAG: /* Formatting_lit */17,
                                      _0: {
                                        TAG: /* Break */0,
                                        _0: "@ ",
                                        _1: 1,
                                        _2: 0
                                      },
                                      _1: {
                                        TAG: /* Alpha */15,
                                        _0: {
                                          TAG: /* Formatting_lit */17,
                                          _0: /* Close_box */0,
                                          _1: /* End_of_format */0
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@[<2>val %s%s%s :@ %a@]"
                      }), param._1 ? "mutable " : "", param._2 ? "virtual " : "", param._0, out_type.contents, param._3);
    
  }
}

const out_class_type = {
  contents: print_out_class_type
};

const out_module_type = {
  contents: (function (param) {
      throw new Caml_js_exceptions.MelangeError("Failure", {
                MEL_EXN_ID: "Failure",
                _1: "Oprint.out_module_type"
              });
    })
};

const out_sig_item = {
  contents: (function (param) {
      throw new Caml_js_exceptions.MelangeError("Failure", {
                MEL_EXN_ID: "Failure",
                _1: "Oprint.out_sig_item"
              });
    })
};

const out_signature = {
  contents: (function (param) {
      throw new Caml_js_exceptions.MelangeError("Failure", {
                MEL_EXN_ID: "Failure",
                _1: "Oprint.out_signature"
              });
    })
};

const out_type_extension = {
  contents: (function (param) {
      throw new Caml_js_exceptions.MelangeError("Failure", {
                MEL_EXN_ID: "Failure",
                _1: "Oprint.out_type_extension"
              });
    })
};

function print_out_functor(ppf, m) {
  if (typeof m !== "number" && m.TAG === /* Omty_functor */0) {
    const mty_arg = m._1;
    if (mty_arg !== undefined) {
      return Curry._5(Stdlib__Format.fprintf(ppf)(/* Format */{
                      _0: {
                        TAG: /* Char_literal */12,
                        _0: /* '(' */40,
                        _1: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* String_literal */11,
                            _0: " : ",
                            _1: {
                              TAG: /* Alpha */15,
                              _0: {
                                TAG: /* String_literal */11,
                                _0: ") ",
                                _1: {
                                  TAG: /* Alpha */15,
                                  _0: /* End_of_format */0
                                }
                              }
                            }
                          }
                        }
                      },
                      _1: "(%s : %a) %a"
                    }), m._0, print_out_module_type, mty_arg, print_out_functor, m._2);
    } else {
      return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "() ",
                        _1: {
                          TAG: /* Alpha */15,
                          _0: /* End_of_format */0
                        }
                      },
                      _1: "() %a"
                    }), print_out_functor, m._2);
    }
  }
  Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
            _0: {
              TAG: /* String_literal */11,
              _0: "->",
              _1: {
                TAG: /* Formatting_lit */17,
                _0: {
                  TAG: /* Break */0,
                  _0: "@ ",
                  _1: 1,
                  _2: 0
                },
                _1: {
                  TAG: /* Alpha */15,
                  _0: /* End_of_format */0
                }
              }
            },
            _1: "->@ %a"
          }), print_out_module_type, m);
}

function print_out_constr(ppf, param) {
  const ret_type_opt = param[2];
  const tyl = param[1];
  const name = param[0];
  if (ret_type_opt !== undefined) {
    if (tyl) {
      return Curry._5(Stdlib__Format.fprintf(ppf)(/* Format */{
                      _0: {
                        TAG: /* Formatting_gen */18,
                        _0: {
                          TAG: /* Open_box */1,
                          _0: /* Format */{
                            _0: {
                              TAG: /* String_literal */11,
                              _0: "<2>",
                              _1: /* End_of_format */0
                            },
                            _1: "<2>"
                          }
                        },
                        _1: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* String_literal */11,
                            _0: " :",
                            _1: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@ ",
                                _1: 1,
                                _2: 0
                              },
                              _1: {
                                TAG: /* Alpha */15,
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: " -> ",
                                  _1: {
                                    TAG: /* Alpha */15,
                                    _0: {
                                      TAG: /* Formatting_lit */17,
                                      _0: /* Close_box */0,
                                      _1: /* End_of_format */0
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      },
                      _1: "@[<2>%s :@ %a -> %a@]"
                    }), name, (function (param, param$1) {
                    return print_typlist(print_simple_out_type, " *", param, param$1);
                  }), tyl, print_simple_out_type, ret_type_opt);
    } else {
      return Curry._3(Stdlib__Format.fprintf(ppf)(/* Format */{
                      _0: {
                        TAG: /* Formatting_gen */18,
                        _0: {
                          TAG: /* Open_box */1,
                          _0: /* Format */{
                            _0: {
                              TAG: /* String_literal */11,
                              _0: "<2>",
                              _1: /* End_of_format */0
                            },
                            _1: "<2>"
                          }
                        },
                        _1: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* String_literal */11,
                            _0: " :",
                            _1: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@ ",
                                _1: 1,
                                _2: 0
                              },
                              _1: {
                                TAG: /* Alpha */15,
                                _0: {
                                  TAG: /* Formatting_lit */17,
                                  _0: /* Close_box */0,
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          }
                        }
                      },
                      _1: "@[<2>%s :@ %a@]"
                    }), name, print_simple_out_type, ret_type_opt);
    }
  } else if (tyl) {
    return Curry._3(Stdlib__Format.fprintf(ppf)(/* Format */{
                    _0: {
                      TAG: /* Formatting_gen */18,
                      _0: {
                        TAG: /* Open_box */1,
                        _0: /* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "<2>",
                            _1: /* End_of_format */0
                          },
                          _1: "<2>"
                        }
                      },
                      _1: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* String_literal */11,
                          _0: " of",
                          _1: {
                            TAG: /* Formatting_lit */17,
                            _0: {
                              TAG: /* Break */0,
                              _0: "@ ",
                              _1: 1,
                              _2: 0
                            },
                            _1: {
                              TAG: /* Alpha */15,
                              _0: {
                                TAG: /* Formatting_lit */17,
                                _0: /* Close_box */0,
                                _1: /* End_of_format */0
                              }
                            }
                          }
                        }
                      }
                    },
                    _1: "@[<2>%s of@ %a@]"
                  }), name, (function (param, param$1) {
                  return print_typlist(print_simple_out_type, " *", param, param$1);
                }), tyl);
  } else {
    return Stdlib__Format.pp_print_string(ppf, name);
  }
}

function print_out_label(ppf, param) {
  Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
            _0: {
              TAG: /* Formatting_gen */18,
              _0: {
                TAG: /* Open_box */1,
                _0: /* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "<2>",
                    _1: /* End_of_format */0
                  },
                  _1: "<2>"
                }
              },
              _1: {
                TAG: /* String */2,
                _0: /* No_padding */0,
                _1: {
                  TAG: /* String */2,
                  _0: /* No_padding */0,
                  _1: {
                    TAG: /* String_literal */11,
                    _0: " :",
                    _1: {
                      TAG: /* Formatting_lit */17,
                      _0: {
                        TAG: /* Break */0,
                        _0: "@ ",
                        _1: 1,
                        _2: 0
                      },
                      _1: {
                        TAG: /* Alpha */15,
                        _0: {
                          TAG: /* Formatting_lit */17,
                          _0: /* Close_box */0,
                          _1: {
                            TAG: /* Char_literal */12,
                            _0: /* ';' */59,
                            _1: /* End_of_format */0
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
            _1: "@[<2>%s%s :@ %a@];"
          }), param[1] ? "mutable " : "", param[0], out_type.contents, param[2]);
}

function print_out_module_type(ppf, t) {
  if (typeof t === "number") {
    return ;
  }
  switch (t.TAG | 0) {
    case /* Omty_functor */0 :
        return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<2>",
                                _1: /* End_of_format */0
                              },
                              _1: "<2>"
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "functor",
                            _1: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@ ",
                                _1: 1,
                                _2: 0
                              },
                              _1: {
                                TAG: /* Alpha */15,
                                _0: {
                                  TAG: /* Formatting_lit */17,
                                  _0: /* Close_box */0,
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          }
                        },
                        _1: "@[<2>functor@ %a@]"
                      }), print_out_functor, t);
    case /* Omty_ident */1 :
        return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Alpha */15,
                          _0: /* End_of_format */0
                        },
                        _1: "%a"
                      }), print_ident, t._0);
    case /* Omty_signature */2 :
        return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<hv 2>",
                                _1: /* End_of_format */0
                              },
                              _1: "<hv 2>"
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "sig",
                            _1: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@ ",
                                _1: 1,
                                _2: 0
                              },
                              _1: {
                                TAG: /* Alpha */15,
                                _0: {
                                  TAG: /* Formatting_lit */17,
                                  _0: {
                                    TAG: /* Break */0,
                                    _0: "@;<1 -2>",
                                    _1: 1,
                                    _2: -2
                                  },
                                  _1: {
                                    TAG: /* String_literal */11,
                                    _0: "end",
                                    _1: {
                                      TAG: /* Formatting_lit */17,
                                      _0: /* Close_box */0,
                                      _1: /* End_of_format */0
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@[<hv 2>sig@ %a@;<1 -2>end@]"
                      }), out_signature.contents, t._0);
    case /* Omty_alias */3 :
        return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "(module ",
                          _1: {
                            TAG: /* Alpha */15,
                            _0: {
                              TAG: /* Char_literal */12,
                              _0: /* ')' */41,
                              _1: /* End_of_format */0
                            }
                          }
                        },
                        _1: "(module %a)"
                      }), print_ident, t._0);
    
  }
}

function print_out_signature(ppf, param) {
  if (!param) {
    return ;
  }
  const item = param.hd;
  if (!param.tl) {
    return Curry._2(out_sig_item.contents, ppf, item);
  }
  if (item.TAG === /* Osig_typext */2 && !item._1) {
    const ext = item._0;
    const gather_extensions = function (_acc, _items) {
      while(true) {
        const items = _items;
        const acc = _acc;
        if (!items) {
          return [
                  Stdlib__List.rev(acc),
                  items
                ];
        }
        const match = items.hd;
        if (match.TAG !== /* Osig_typext */2) {
          return [
                  Stdlib__List.rev(acc),
                  items
                ];
        }
        if (match._1 !== 1) {
          return [
                  Stdlib__List.rev(acc),
                  items
                ];
        }
        const ext = match._0;
        _items = items.tl;
        _acc = {
          hd: [
            ext.oext_name,
            ext.oext_args,
            ext.oext_ret_type
          ],
          tl: acc
        };
        continue ;
      };
    };
    const match = gather_extensions({
          hd: [
            ext.oext_name,
            ext.oext_args,
            ext.oext_ret_type
          ],
          tl: /* [] */0
        }, param.tl);
    const te_otyext_name = ext.oext_type_name;
    const te_otyext_params = ext.oext_type_params;
    const te_otyext_constructors = match[0];
    const te_otyext_private = ext.oext_private;
    const te = {
      otyext_name: te_otyext_name,
      otyext_params: te_otyext_params,
      otyext_constructors: te_otyext_constructors,
      otyext_private: te_otyext_private
    };
    return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                    _0: {
                      TAG: /* Alpha */15,
                      _0: {
                        TAG: /* Formatting_lit */17,
                        _0: {
                          TAG: /* Break */0,
                          _0: "@ ",
                          _1: 1,
                          _2: 0
                        },
                        _1: {
                          TAG: /* Alpha */15,
                          _0: /* End_of_format */0
                        }
                      }
                    },
                    _1: "%a@ %a"
                  }), out_type_extension.contents, te, print_out_signature, match[1]);
  }
  Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
            _0: {
              TAG: /* Alpha */15,
              _0: {
                TAG: /* Formatting_lit */17,
                _0: {
                  TAG: /* Break */0,
                  _0: "@ ",
                  _1: 1,
                  _2: 0
                },
                _1: {
                  TAG: /* Alpha */15,
                  _0: /* End_of_format */0
                }
              }
            },
            _1: "%a@ %a"
          }), out_sig_item.contents, item, print_out_signature, param.tl);
}

function print_out_sig_item(ppf, param) {
  switch (param.TAG | 0) {
    case /* Osig_class */0 :
        return Curry._7(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<2>",
                                _1: /* End_of_format */0
                              },
                              _1: "<2>"
                            }
                          },
                          _1: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@ ",
                                  _1: 1,
                                  _2: 0
                                },
                                _1: {
                                  TAG: /* Alpha */15,
                                  _0: {
                                    TAG: /* String */2,
                                    _0: /* No_padding */0,
                                    _1: {
                                      TAG: /* Formatting_lit */17,
                                      _0: {
                                        TAG: /* Break */0,
                                        _0: "@ ",
                                        _1: 1,
                                        _2: 0
                                      },
                                      _1: {
                                        TAG: /* Char_literal */12,
                                        _0: /* ':' */58,
                                        _1: {
                                          TAG: /* Formatting_lit */17,
                                          _0: {
                                            TAG: /* Break */0,
                                            _0: "@ ",
                                            _1: 1,
                                            _2: 0
                                          },
                                          _1: {
                                            TAG: /* Alpha */15,
                                            _0: {
                                              TAG: /* Formatting_lit */17,
                                              _0: /* Close_box */0,
                                              _1: /* End_of_format */0
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@[<2>%s%s@ %a%s@ :@ %a@]"
                      }), param._4 === /* Orec_next */2 ? "and" : "class", param._0 ? " virtual" : "", print_out_class_params, param._2, param._1, out_class_type.contents, param._3);
    case /* Osig_class_type */1 :
        return Curry._7(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<2>",
                                _1: /* End_of_format */0
                              },
                              _1: "<2>"
                            }
                          },
                          _1: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@ ",
                                  _1: 1,
                                  _2: 0
                                },
                                _1: {
                                  TAG: /* Alpha */15,
                                  _0: {
                                    TAG: /* String */2,
                                    _0: /* No_padding */0,
                                    _1: {
                                      TAG: /* Formatting_lit */17,
                                      _0: {
                                        TAG: /* Break */0,
                                        _0: "@ ",
                                        _1: 1,
                                        _2: 0
                                      },
                                      _1: {
                                        TAG: /* Char_literal */12,
                                        _0: /* '=' */61,
                                        _1: {
                                          TAG: /* Formatting_lit */17,
                                          _0: {
                                            TAG: /* Break */0,
                                            _0: "@ ",
                                            _1: 1,
                                            _2: 0
                                          },
                                          _1: {
                                            TAG: /* Alpha */15,
                                            _0: {
                                              TAG: /* Formatting_lit */17,
                                              _0: /* Close_box */0,
                                              _1: /* End_of_format */0
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@[<2>%s%s@ %a%s@ =@ %a@]"
                      }), param._4 === /* Orec_next */2 ? "and" : "class type", param._0 ? " virtual" : "", print_out_class_params, param._2, param._1, out_class_type.contents, param._3);
    case /* Osig_typext */2 :
        const ext = param._0;
        if (param._1 >= 2) {
          return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* Formatting_gen */18,
                            _0: {
                              TAG: /* Open_box */1,
                              _0: /* Format */{
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: "<2>",
                                  _1: /* End_of_format */0
                                },
                                _1: "<2>"
                              }
                            },
                            _1: {
                              TAG: /* String_literal */11,
                              _0: "exception ",
                              _1: {
                                TAG: /* Alpha */15,
                                _0: {
                                  TAG: /* Formatting_lit */17,
                                  _0: /* Close_box */0,
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          },
                          _1: "@[<2>exception %a@]"
                        }), print_out_constr, [
                      ext.oext_name,
                      ext.oext_args,
                      ext.oext_ret_type
                    ]);
        } else {
          const print_extended_type = function (ppf) {
            const print_type_parameter = function (ppf, ty) {
              Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: /* End_of_format */0
                        },
                        _1: "%s"
                      }), ty === "_" ? ty : "'" + ty);
            };
            const match = ext.oext_type_params;
            if (match) {
              if (match.tl) {
                return Curry._3(Stdlib__Format.fprintf(ppf)(/* Format */{
                                _0: {
                                  TAG: /* Formatting_gen */18,
                                  _0: {
                                    TAG: /* Open_box */1,
                                    _0: /* Format */{
                                      _0: /* End_of_format */0,
                                      _1: ""
                                    }
                                  },
                                  _1: {
                                    TAG: /* Char_literal */12,
                                    _0: /* '(' */40,
                                    _1: {
                                      TAG: /* Formatting_gen */18,
                                      _0: {
                                        TAG: /* Open_box */1,
                                        _0: /* Format */{
                                          _0: /* End_of_format */0,
                                          _1: ""
                                        }
                                      },
                                      _1: {
                                        TAG: /* Alpha */15,
                                        _0: {
                                          TAG: /* Char_literal */12,
                                          _0: /* ')' */41,
                                          _1: {
                                            TAG: /* Formatting_lit */17,
                                            _0: /* Close_box */0,
                                            _1: {
                                              TAG: /* Formatting_lit */17,
                                              _0: {
                                                TAG: /* Break */0,
                                                _0: "@ ",
                                                _1: 1,
                                                _2: 0
                                              },
                                              _1: {
                                                TAG: /* String */2,
                                                _0: /* No_padding */0,
                                                _1: {
                                                  TAG: /* Formatting_lit */17,
                                                  _0: /* Close_box */0,
                                                  _1: /* End_of_format */0
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                },
                                _1: "@[(@[%a)@]@ %s@]"
                              }), (function (param, param$1) {
                              return print_list(print_type_parameter, (function (ppf) {
                                            Stdlib__Format.fprintf(ppf)(/* Format */{
                                                  _0: {
                                                    TAG: /* Char_literal */12,
                                                    _0: /* ',' */44,
                                                    _1: {
                                                      TAG: /* Formatting_lit */17,
                                                      _0: {
                                                        TAG: /* Break */0,
                                                        _0: "@ ",
                                                        _1: 1,
                                                        _2: 0
                                                      },
                                                      _1: /* End_of_format */0
                                                    }
                                                  },
                                                  _1: ",@ "
                                                });
                                          }), param, param$1);
                            }), ext.oext_type_params, ext.oext_type_name);
              } else {
                return Curry._3(Stdlib__Format.fprintf(ppf)(/* Format */{
                                _0: {
                                  TAG: /* Formatting_gen */18,
                                  _0: {
                                    TAG: /* Open_box */1,
                                    _0: /* Format */{
                                      _0: /* End_of_format */0,
                                      _1: ""
                                    }
                                  },
                                  _1: {
                                    TAG: /* Alpha */15,
                                    _0: {
                                      TAG: /* Formatting_lit */17,
                                      _0: {
                                        TAG: /* Break */0,
                                        _0: "@ ",
                                        _1: 1,
                                        _2: 0
                                      },
                                      _1: {
                                        TAG: /* String */2,
                                        _0: /* No_padding */0,
                                        _1: {
                                          TAG: /* Formatting_lit */17,
                                          _0: /* Close_box */0,
                                          _1: /* End_of_format */0
                                        }
                                      }
                                    }
                                  }
                                },
                                _1: "@[%a@ %s@]"
                              }), print_type_parameter, match.hd, ext.oext_type_name);
              }
            } else {
              return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                              _0: {
                                TAG: /* String */2,
                                _0: /* No_padding */0,
                                _1: /* End_of_format */0
                              },
                              _1: "%s"
                            }), ext.oext_type_name);
            }
          };
          return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* Formatting_gen */18,
                            _0: {
                              TAG: /* Open_box */1,
                              _0: /* Format */{
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: "<hv 2>",
                                  _1: /* End_of_format */0
                                },
                                _1: "<hv 2>"
                              }
                            },
                            _1: {
                              TAG: /* String_literal */11,
                              _0: "type ",
                              _1: {
                                TAG: /* Theta */16,
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: " +=",
                                  _1: {
                                    TAG: /* String */2,
                                    _0: /* No_padding */0,
                                    _1: {
                                      TAG: /* Formatting_lit */17,
                                      _0: {
                                        TAG: /* Break */0,
                                        _0: "@;<1 2>",
                                        _1: 1,
                                        _2: 2
                                      },
                                      _1: {
                                        TAG: /* Alpha */15,
                                        _0: {
                                          TAG: /* Formatting_lit */17,
                                          _0: /* Close_box */0,
                                          _1: /* End_of_format */0
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          },
                          _1: "@[<hv 2>type %t +=%s@;<1 2>%a@]"
                        }), print_extended_type, ext.oext_private === /* Private */0 ? " private" : "", print_out_constr, [
                      ext.oext_name,
                      ext.oext_args,
                      ext.oext_ret_type
                    ]);
        }
    case /* Osig_modtype */3 :
        const name = param._0;
        if (typeof param._1 === "number") {
          return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* Formatting_gen */18,
                            _0: {
                              TAG: /* Open_box */1,
                              _0: /* Format */{
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: "<2>",
                                  _1: /* End_of_format */0
                                },
                                _1: "<2>"
                              }
                            },
                            _1: {
                              TAG: /* String_literal */11,
                              _0: "module type ",
                              _1: {
                                TAG: /* String */2,
                                _0: /* No_padding */0,
                                _1: {
                                  TAG: /* Formatting_lit */17,
                                  _0: /* Close_box */0,
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          },
                          _1: "@[<2>module type %s@]"
                        }), name);
        } else {
          return Curry._3(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* Formatting_gen */18,
                            _0: {
                              TAG: /* Open_box */1,
                              _0: /* Format */{
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: "<2>",
                                  _1: /* End_of_format */0
                                },
                                _1: "<2>"
                              }
                            },
                            _1: {
                              TAG: /* String_literal */11,
                              _0: "module type ",
                              _1: {
                                TAG: /* String */2,
                                _0: /* No_padding */0,
                                _1: {
                                  TAG: /* String_literal */11,
                                  _0: " =",
                                  _1: {
                                    TAG: /* Formatting_lit */17,
                                    _0: {
                                      TAG: /* Break */0,
                                      _0: "@ ",
                                      _1: 1,
                                      _2: 0
                                    },
                                    _1: {
                                      TAG: /* Alpha */15,
                                      _0: {
                                        TAG: /* Formatting_lit */17,
                                        _0: /* Close_box */0,
                                        _1: /* End_of_format */0
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          },
                          _1: "@[<2>module type %s =@ %a@]"
                        }), name, out_module_type.contents, param._1);
        }
    case /* Osig_module */4 :
        const name$1 = param._0;
        const id = param._1;
        if (typeof id !== "number" && id.TAG === /* Omty_alias */3) {
          return Curry._3(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* Formatting_gen */18,
                            _0: {
                              TAG: /* Open_box */1,
                              _0: /* Format */{
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: "<2>",
                                  _1: /* End_of_format */0
                                },
                                _1: "<2>"
                              }
                            },
                            _1: {
                              TAG: /* String_literal */11,
                              _0: "module ",
                              _1: {
                                TAG: /* String */2,
                                _0: /* No_padding */0,
                                _1: {
                                  TAG: /* String_literal */11,
                                  _0: " =",
                                  _1: {
                                    TAG: /* Formatting_lit */17,
                                    _0: {
                                      TAG: /* Break */0,
                                      _0: "@ ",
                                      _1: 1,
                                      _2: 0
                                    },
                                    _1: {
                                      TAG: /* Alpha */15,
                                      _0: {
                                        TAG: /* Formatting_lit */17,
                                        _0: /* Close_box */0,
                                        _1: /* End_of_format */0
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          },
                          _1: "@[<2>module %s =@ %a@]"
                        }), name$1, print_ident, id._0);
        }
        let tmp;
        switch (param._2) {
          case /* Orec_not */0 :
              tmp = "module";
              break;
          case /* Orec_first */1 :
              tmp = "module rec";
              break;
          case /* Orec_next */2 :
              tmp = "and";
              break;
          
        }
        return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<2>",
                                _1: /* End_of_format */0
                              },
                              _1: "<2>"
                            }
                          },
                          _1: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: {
                              TAG: /* Char_literal */12,
                              _0: /* ' ' */32,
                              _1: {
                                TAG: /* String */2,
                                _0: /* No_padding */0,
                                _1: {
                                  TAG: /* String_literal */11,
                                  _0: " :",
                                  _1: {
                                    TAG: /* Formatting_lit */17,
                                    _0: {
                                      TAG: /* Break */0,
                                      _0: "@ ",
                                      _1: 1,
                                      _2: 0
                                    },
                                    _1: {
                                      TAG: /* Alpha */15,
                                      _0: {
                                        TAG: /* Formatting_lit */17,
                                        _0: /* Close_box */0,
                                        _1: /* End_of_format */0
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@[<2>%s %s :@ %a@]"
                      }), tmp, name$1, out_module_type.contents, param._1);
    case /* Osig_type */5 :
        let tmp$1;
        switch (param._1) {
          case /* Orec_not */0 :
              tmp$1 = "type nonrec";
              break;
          case /* Orec_first */1 :
              tmp$1 = "type";
              break;
          case /* Orec_next */2 :
              tmp$1 = "and";
              break;
          
        }
        let td = param._0;
        const print_constraints = function (ppf) {
          Stdlib__List.iter((function (param) {
                  Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                            _0: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@ ",
                                _1: 1,
                                _2: 0
                              },
                              _1: {
                                TAG: /* Formatting_gen */18,
                                _0: {
                                  TAG: /* Open_box */1,
                                  _0: /* Format */{
                                    _0: {
                                      TAG: /* String_literal */11,
                                      _0: "<2>",
                                      _1: /* End_of_format */0
                                    },
                                    _1: "<2>"
                                  }
                                },
                                _1: {
                                  TAG: /* String_literal */11,
                                  _0: "constraint ",
                                  _1: {
                                    TAG: /* Alpha */15,
                                    _0: {
                                      TAG: /* String_literal */11,
                                      _0: " =",
                                      _1: {
                                        TAG: /* Formatting_lit */17,
                                        _0: {
                                          TAG: /* Break */0,
                                          _0: "@ ",
                                          _1: 1,
                                          _2: 0
                                        },
                                        _1: {
                                          TAG: /* Alpha */15,
                                          _0: {
                                            TAG: /* Formatting_lit */17,
                                            _0: /* Close_box */0,
                                            _1: /* End_of_format */0
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            },
                            _1: "@ @[<2>constraint %a =@ %a@]"
                          }), out_type.contents, param[0], out_type.contents, param[1]);
                }), td.otype_cstrs);
        };
        const type_defined = function (ppf) {
          const match = td.otype_params;
          if (match) {
            if (match.tl) {
              return Curry._3(Stdlib__Format.fprintf(ppf)(/* Format */{
                              _0: {
                                TAG: /* Formatting_gen */18,
                                _0: {
                                  TAG: /* Open_box */1,
                                  _0: /* Format */{
                                    _0: /* End_of_format */0,
                                    _1: ""
                                  }
                                },
                                _1: {
                                  TAG: /* Char_literal */12,
                                  _0: /* '(' */40,
                                  _1: {
                                    TAG: /* Formatting_gen */18,
                                    _0: {
                                      TAG: /* Open_box */1,
                                      _0: /* Format */{
                                        _0: /* End_of_format */0,
                                        _1: ""
                                      }
                                    },
                                    _1: {
                                      TAG: /* Alpha */15,
                                      _0: {
                                        TAG: /* Char_literal */12,
                                        _0: /* ')' */41,
                                        _1: {
                                          TAG: /* Formatting_lit */17,
                                          _0: /* Close_box */0,
                                          _1: {
                                            TAG: /* Formatting_lit */17,
                                            _0: {
                                              TAG: /* Break */0,
                                              _0: "@ ",
                                              _1: 1,
                                              _2: 0
                                            },
                                            _1: {
                                              TAG: /* String */2,
                                              _0: /* No_padding */0,
                                              _1: {
                                                TAG: /* Formatting_lit */17,
                                                _0: /* Close_box */0,
                                                _1: /* End_of_format */0
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              },
                              _1: "@[(@[%a)@]@ %s@]"
                            }), (function (param, param$1) {
                            return print_list(type_parameter, (function (ppf) {
                                          Stdlib__Format.fprintf(ppf)(/* Format */{
                                                _0: {
                                                  TAG: /* Char_literal */12,
                                                  _0: /* ',' */44,
                                                  _1: {
                                                    TAG: /* Formatting_lit */17,
                                                    _0: {
                                                      TAG: /* Break */0,
                                                      _0: "@ ",
                                                      _1: 1,
                                                      _2: 0
                                                    },
                                                    _1: /* End_of_format */0
                                                  }
                                                },
                                                _1: ",@ "
                                              });
                                        }), param, param$1);
                          }), td.otype_params, td.otype_name);
            } else {
              return Curry._3(Stdlib__Format.fprintf(ppf)(/* Format */{
                              _0: {
                                TAG: /* Formatting_gen */18,
                                _0: {
                                  TAG: /* Open_box */1,
                                  _0: /* Format */{
                                    _0: /* End_of_format */0,
                                    _1: ""
                                  }
                                },
                                _1: {
                                  TAG: /* Alpha */15,
                                  _0: {
                                    TAG: /* Formatting_lit */17,
                                    _0: {
                                      TAG: /* Break */0,
                                      _0: "@ ",
                                      _1: 1,
                                      _2: 0
                                    },
                                    _1: {
                                      TAG: /* String */2,
                                      _0: /* No_padding */0,
                                      _1: {
                                        TAG: /* Formatting_lit */17,
                                        _0: /* Close_box */0,
                                        _1: /* End_of_format */0
                                      }
                                    }
                                  }
                                }
                              },
                              _1: "@[%a@ %s@]"
                            }), type_parameter, match.hd, td.otype_name);
            }
          } else {
            return Stdlib__Format.pp_print_string(ppf, td.otype_name);
          }
        };
        const print_manifest = function (ppf, param) {
          if (typeof param === "number" || param.TAG !== /* Otyp_manifest */4) {
            return ;
          } else {
            return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                            _0: {
                              TAG: /* String_literal */11,
                              _0: " =",
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@ ",
                                  _1: 1,
                                  _2: 0
                                },
                                _1: {
                                  TAG: /* Alpha */15,
                                  _0: /* End_of_format */0
                                }
                              }
                            },
                            _1: " =@ %a"
                          }), out_type.contents, param._0);
          }
        };
        const print_name_params = function (ppf) {
          Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                    _0: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* Char_literal */12,
                        _0: /* ' ' */32,
                        _1: {
                          TAG: /* Theta */16,
                          _0: {
                            TAG: /* Alpha */15,
                            _0: /* End_of_format */0
                          }
                        }
                      }
                    },
                    _1: "%s %t%a"
                  }), tmp$1, type_defined, print_manifest, td.otype_type);
        };
        const match = td.otype_type;
        let ty;
        ty = typeof match === "number" || match.TAG !== /* Otyp_manifest */4 ? td.otype_type : match._1;
        const print_private = function (ppf, param) {
          if (param) {
            return ;
          } else {
            return Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: " private",
                          _1: /* End_of_format */0
                        },
                        _1: " private"
                      });
          }
        };
        const print_out_tkind = function (ppf, lbls) {
          if (typeof lbls === "number") {
            if (lbls === /* Otyp_abstract */0) {
              return ;
            } else {
              return Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: " = ..",
                            _1: /* End_of_format */0
                          },
                          _1: " = .."
                        });
            }
          }
          switch (lbls.TAG | 0) {
            case /* Otyp_record */6 :
                return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: " =",
                                  _1: {
                                    TAG: /* Alpha */15,
                                    _0: {
                                      TAG: /* String_literal */11,
                                      _0: " {",
                                      _1: {
                                        TAG: /* Alpha */15,
                                        _0: {
                                          TAG: /* Formatting_lit */17,
                                          _0: {
                                            TAG: /* Break */0,
                                            _0: "@;<1 -2>",
                                            _1: 1,
                                            _2: -2
                                          },
                                          _1: {
                                            TAG: /* Char_literal */12,
                                            _0: /* '}' */125,
                                            _1: /* End_of_format */0
                                          }
                                        }
                                      }
                                    }
                                  }
                                },
                                _1: " =%a {%a@;<1 -2>}"
                              }), print_private, td.otype_private, (function (param, param$1) {
                              const sep = function (ppf) {
                                Stdlib__Format.fprintf(ppf)(/* Format */{
                                      _0: {
                                        TAG: /* Formatting_lit */17,
                                        _0: {
                                          TAG: /* Break */0,
                                          _0: "@ ",
                                          _1: 1,
                                          _2: 0
                                        },
                                        _1: /* End_of_format */0
                                      },
                                      _1: "@ "
                                    });
                              };
                              let _param = param$1;
                              while(true) {
                                const param$2 = _param;
                                if (!param$2) {
                                  return ;
                                }
                                Curry._1(sep, param);
                                Curry._2(print_out_label, param, param$2.hd);
                                _param = param$2.tl;
                                continue ;
                              };
                            }), lbls._0);
            case /* Otyp_sum */8 :
                return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: " =",
                                  _1: {
                                    TAG: /* Alpha */15,
                                    _0: {
                                      TAG: /* Formatting_lit */17,
                                      _0: {
                                        TAG: /* Break */0,
                                        _0: "@;<1 2>",
                                        _1: 1,
                                        _2: 2
                                      },
                                      _1: {
                                        TAG: /* Alpha */15,
                                        _0: /* End_of_format */0
                                      }
                                    }
                                  }
                                },
                                _1: " =%a@;<1 2>%a"
                              }), print_private, td.otype_private, (function (param, param$1) {
                              return print_list(print_out_constr, (function (ppf) {
                                            Stdlib__Format.fprintf(ppf)(/* Format */{
                                                  _0: {
                                                    TAG: /* Formatting_lit */17,
                                                    _0: {
                                                      TAG: /* Break */0,
                                                      _0: "@ ",
                                                      _1: 1,
                                                      _2: 0
                                                    },
                                                    _1: {
                                                      TAG: /* String_literal */11,
                                                      _0: "| ",
                                                      _1: /* End_of_format */0
                                                    }
                                                  },
                                                  _1: "@ | "
                                                });
                                          }), param, param$1);
                            }), lbls._0);
            default:
              return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: " =",
                                _1: {
                                  TAG: /* Alpha */15,
                                  _0: {
                                    TAG: /* Formatting_lit */17,
                                    _0: {
                                      TAG: /* Break */0,
                                      _0: "@;<1 2>",
                                      _1: 1,
                                      _2: 2
                                    },
                                    _1: {
                                      TAG: /* Alpha */15,
                                      _0: /* End_of_format */0
                                    }
                                  }
                                }
                              },
                              _1: " =%a@;<1 2>%a"
                            }), print_private, td.otype_private, out_type.contents, lbls);
          }
        };
        return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<2>",
                                _1: /* End_of_format */0
                              },
                              _1: "<2>"
                            }
                          },
                          _1: {
                            TAG: /* Formatting_gen */18,
                            _0: {
                              TAG: /* Open_box */1,
                              _0: /* Format */{
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: "<hv 2>",
                                  _1: /* End_of_format */0
                                },
                                _1: "<hv 2>"
                              }
                            },
                            _1: {
                              TAG: /* Theta */16,
                              _0: {
                                TAG: /* Alpha */15,
                                _0: {
                                  TAG: /* Formatting_lit */17,
                                  _0: /* Close_box */0,
                                  _1: {
                                    TAG: /* Theta */16,
                                    _0: {
                                      TAG: /* Formatting_lit */17,
                                      _0: /* Close_box */0,
                                      _1: /* End_of_format */0
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@[<2>@[<hv 2>%t%a@]%t@]"
                      }), print_name_params, print_out_tkind, ty, print_constraints);
    case /* Osig_value */6 :
        const prims = param._2;
        const kwd = Caml_obj.caml_equal(prims, /* [] */0) ? "val" : "external";
        const pr_prims = function (ppf, param) {
          if (param) {
            Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                      _0: {
                        TAG: /* Formatting_lit */17,
                        _0: {
                          TAG: /* Break */0,
                          _0: "@ ",
                          _1: 1,
                          _2: 0
                        },
                        _1: {
                          TAG: /* String_literal */11,
                          _0: "= \"",
                          _1: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: {
                              TAG: /* Char_literal */12,
                              _0: /* '"' */34,
                              _1: /* End_of_format */0
                            }
                          }
                        }
                      },
                      _1: "@ = \"%s\""
                    }), param.hd);
            return Stdlib__List.iter((function (s) {
                          const len = s.length;
                          if (len >= 3 && Caml_string.get(s, 0) === /* 'B' */66 && Caml_string.get(s, 1) === /* 'S' */83 && Caml_string.get(s, 2) === /* ':' */58) {
                            return Stdlib__Format.fprintf(ppf)(/* Format */{
                                        _0: {
                                          TAG: /* Formatting_lit */17,
                                          _0: {
                                            TAG: /* Break */0,
                                            _0: "@ ",
                                            _1: 1,
                                            _2: 0
                                          },
                                          _1: {
                                            TAG: /* String_literal */11,
                                            _0: "\"BS-EXTERNAL\"",
                                            _1: /* End_of_format */0
                                          }
                                        },
                                        _1: "@ \"BS-EXTERNAL\""
                                      });
                          } else {
                            return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                                            _0: {
                                              TAG: /* Formatting_lit */17,
                                              _0: {
                                                TAG: /* Break */0,
                                                _0: "@ ",
                                                _1: 1,
                                                _2: 0
                                              },
                                              _1: {
                                                TAG: /* Char_literal */12,
                                                _0: /* '"' */34,
                                                _1: {
                                                  TAG: /* String */2,
                                                  _0: /* No_padding */0,
                                                  _1: {
                                                    TAG: /* Char_literal */12,
                                                    _0: /* '"' */34,
                                                    _1: /* End_of_format */0
                                                  }
                                                }
                                              }
                                            },
                                            _1: "@ \"%s\""
                                          }), s);
                          }
                        }), param.tl);
          }
          
        };
        return Curry._7(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<2>",
                                _1: /* End_of_format */0
                              },
                              _1: "<2>"
                            }
                          },
                          _1: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: {
                              TAG: /* Char_literal */12,
                              _0: /* ' ' */32,
                              _1: {
                                TAG: /* Alpha */15,
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: " :",
                                  _1: {
                                    TAG: /* Formatting_lit */17,
                                    _0: {
                                      TAG: /* Break */0,
                                      _0: "@ ",
                                      _1: 1,
                                      _2: 0
                                    },
                                    _1: {
                                      TAG: /* Alpha */15,
                                      _0: {
                                        TAG: /* Alpha */15,
                                        _0: {
                                          TAG: /* Formatting_lit */17,
                                          _0: /* Close_box */0,
                                          _1: /* End_of_format */0
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@[<2>%s %a :@ %a%a@]"
                      }), kwd, value_ident, param._0, out_type.contents, param._1, pr_prims, prims);
    
  }
}

function print_out_type_extension(ppf, te) {
  const print_extended_type = function (ppf) {
    const print_type_parameter = function (ppf, ty) {
      Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                _0: {
                  TAG: /* String */2,
                  _0: /* No_padding */0,
                  _1: /* End_of_format */0
                },
                _1: "%s"
              }), ty === "_" ? ty : "'" + ty);
    };
    const match = te.otyext_params;
    if (match) {
      if (match.tl) {
        return Curry._3(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: /* End_of_format */0,
                              _1: ""
                            }
                          },
                          _1: {
                            TAG: /* Char_literal */12,
                            _0: /* '(' */40,
                            _1: {
                              TAG: /* Formatting_gen */18,
                              _0: {
                                TAG: /* Open_box */1,
                                _0: /* Format */{
                                  _0: /* End_of_format */0,
                                  _1: ""
                                }
                              },
                              _1: {
                                TAG: /* Alpha */15,
                                _0: {
                                  TAG: /* Char_literal */12,
                                  _0: /* ')' */41,
                                  _1: {
                                    TAG: /* Formatting_lit */17,
                                    _0: /* Close_box */0,
                                    _1: {
                                      TAG: /* Formatting_lit */17,
                                      _0: {
                                        TAG: /* Break */0,
                                        _0: "@ ",
                                        _1: 1,
                                        _2: 0
                                      },
                                      _1: {
                                        TAG: /* String */2,
                                        _0: /* No_padding */0,
                                        _1: {
                                          TAG: /* Formatting_lit */17,
                                          _0: /* Close_box */0,
                                          _1: /* End_of_format */0
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@[(@[%a)@]@ %s@]"
                      }), (function (param, param$1) {
                      return print_list(print_type_parameter, (function (ppf) {
                                    Stdlib__Format.fprintf(ppf)(/* Format */{
                                          _0: {
                                            TAG: /* Char_literal */12,
                                            _0: /* ',' */44,
                                            _1: {
                                              TAG: /* Formatting_lit */17,
                                              _0: {
                                                TAG: /* Break */0,
                                                _0: "@ ",
                                                _1: 1,
                                                _2: 0
                                              },
                                              _1: /* End_of_format */0
                                            }
                                          },
                                          _1: ",@ "
                                        });
                                  }), param, param$1);
                    }), te.otyext_params, te.otyext_name);
      } else {
        return Curry._3(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: /* End_of_format */0,
                              _1: ""
                            }
                          },
                          _1: {
                            TAG: /* Alpha */15,
                            _0: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@ ",
                                _1: 1,
                                _2: 0
                              },
                              _1: {
                                TAG: /* String */2,
                                _0: /* No_padding */0,
                                _1: {
                                  TAG: /* Formatting_lit */17,
                                  _0: /* Close_box */0,
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          }
                        },
                        _1: "@[%a@ %s@]"
                      }), print_type_parameter, match.hd, te.otyext_name);
      }
    } else {
      return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                      _0: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: /* End_of_format */0
                      },
                      _1: "%s"
                    }), te.otyext_name);
    }
  };
  Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
            _0: {
              TAG: /* Formatting_gen */18,
              _0: {
                TAG: /* Open_box */1,
                _0: /* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "<hv 2>",
                    _1: /* End_of_format */0
                  },
                  _1: "<hv 2>"
                }
              },
              _1: {
                TAG: /* String_literal */11,
                _0: "type ",
                _1: {
                  TAG: /* Theta */16,
                  _0: {
                    TAG: /* String_literal */11,
                    _0: " +=",
                    _1: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* Formatting_lit */17,
                        _0: {
                          TAG: /* Break */0,
                          _0: "@;<1 2>",
                          _1: 1,
                          _2: 2
                        },
                        _1: {
                          TAG: /* Alpha */15,
                          _0: {
                            TAG: /* Formatting_lit */17,
                            _0: /* Close_box */0,
                            _1: /* End_of_format */0
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
            _1: "@[<hv 2>type %t +=%s@;<1 2>%a@]"
          }), print_extended_type, te.otyext_private === /* Private */0 ? " private" : "", (function (param, param$1) {
          return print_list(print_out_constr, (function (ppf) {
                        Stdlib__Format.fprintf(ppf)(/* Format */{
                              _0: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@ ",
                                  _1: 1,
                                  _2: 0
                                },
                                _1: {
                                  TAG: /* String_literal */11,
                                  _0: "| ",
                                  _1: /* End_of_format */0
                                }
                              },
                              _1: "@ | "
                            });
                      }), param, param$1);
        }), te.otyext_constructors);
}

out_module_type.contents = print_out_module_type;

out_signature.contents = print_out_signature;

out_sig_item.contents = print_out_sig_item;

out_type_extension.contents = print_out_type_extension;

function longident(ppf, s) {
  switch (s.TAG | 0) {
    case /* Lident */0 :
        return Stdlib__Format.pp_print_string(ppf, s._0);
    case /* Ldot */1 :
        return Curry._3(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Alpha */15,
                          _0: {
                            TAG: /* Char_literal */12,
                            _0: /* '.' */46,
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: /* End_of_format */0
                            }
                          }
                        },
                        _1: "%a.%s"
                      }), longident, s._0, s._1);
    case /* Lapply */2 :
        return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Alpha */15,
                          _0: {
                            TAG: /* Char_literal */12,
                            _0: /* '(' */40,
                            _1: {
                              TAG: /* Alpha */15,
                              _0: {
                                TAG: /* Char_literal */12,
                                _0: /* ')' */41,
                                _1: /* End_of_format */0
                              }
                            }
                          }
                        },
                        _1: "%a(%a)"
                      }), longident, s._0, longident, s._1);
    
  }
}

const unique_names = {
  contents: /* Empty */0
};

function ident_name(id) {
  try {
    return find_same(id, unique_names.contents);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return id.name;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function add_unique(id) {
  try {
    find_same(id, unique_names.contents);
    return ;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      unique_names.contents = add(id, unique_toplevel_name(id), unique_names.contents);
      return ;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function ident$3(ppf, id) {
  Stdlib__Format.pp_print_string(ppf, ident_name(id));
}

const ident_pervasive = {
  stamp: 0,
  name: "Stdlib",
  flags: 1
};

function tree_of_path(id) {
  switch (id.TAG | 0) {
    case /* Pident */0 :
        return {
                TAG: /* Oide_ident */2,
                _0: ident_name(id._0)
              };
    case /* Pdot */1 :
        const id$1 = id._0;
        switch (id$1.TAG | 0) {
          case /* Pident */0 :
              if (Caml_obj.caml_equal(id$1._0, ident_pervasive)) {
                return {
                        TAG: /* Oide_ident */2,
                        _0: id._1
                      };
              }
              break;
          case /* Pdot */1 :
          case /* Papply */2 :
              break;
          
        }
        return {
                TAG: /* Oide_dot */1,
                _0: tree_of_path(id$1),
                _1: id._1
              };
    case /* Papply */2 :
        return {
                TAG: /* Oide_apply */0,
                _0: tree_of_path(id._0),
                _1: tree_of_path(id._1)
              };
    
  }
}

function path(ppf, id) {
  switch (id.TAG | 0) {
    case /* Pident */0 :
        return Stdlib__Format.pp_print_string(ppf, ident_name(id._0));
    case /* Pdot */1 :
        const id$1 = id._0;
        switch (id$1.TAG | 0) {
          case /* Pident */0 :
              if (Caml_obj.caml_equal(id$1._0, ident_pervasive)) {
                return Stdlib__Format.pp_print_string(ppf, id._1);
              }
              break;
          case /* Pdot */1 :
          case /* Papply */2 :
              break;
          
        }
        path(ppf, id$1);
        Stdlib__Format.pp_print_char(ppf, /* '.' */46);
        return Stdlib__Format.pp_print_string(ppf, id._1);
    case /* Papply */2 :
        return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Alpha */15,
                          _0: {
                            TAG: /* Char_literal */12,
                            _0: /* '(' */40,
                            _1: {
                              TAG: /* Alpha */15,
                              _0: {
                                TAG: /* Char_literal */12,
                                _0: /* ')' */41,
                                _1: /* End_of_format */0
                              }
                            }
                          }
                        },
                        _1: "%a(%a)"
                      }), path, id._0, path, id._1);
    
  }
}

function string_of_out_ident(s) {
  switch (s.TAG | 0) {
    case /* Oide_apply */0 :
        return Stdlib__String.concat("", {
                    hd: string_of_out_ident(s._0),
                    tl: {
                      hd: "(",
                      tl: {
                        hd: string_of_out_ident(s._1),
                        tl: {
                          hd: ")",
                          tl: /* [] */0
                        }
                      }
                    }
                  });
    case /* Oide_dot */1 :
        return Stdlib__String.concat(".", {
                    hd: string_of_out_ident(s._0),
                    tl: {
                      hd: s._1,
                      tl: /* [] */0
                    }
                  });
    case /* Oide_ident */2 :
        return s._0;
    
  }
}

function string_of_path(p) {
  return string_of_out_ident(tree_of_path(p));
}

function raw_list(pr, ppf, param) {
  if (!param) {
    return Stdlib__Format.fprintf(ppf)(/* Format */{
                _0: {
                  TAG: /* String_literal */11,
                  _0: "[]",
                  _1: /* End_of_format */0
                },
                _1: "[]"
              });
  }
  const l = param.tl;
  Curry._3(Stdlib__Format.fprintf(ppf)(/* Format */{
            _0: {
              TAG: /* Formatting_gen */18,
              _0: {
                TAG: /* Open_box */1,
                _0: /* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "<1>",
                    _1: /* End_of_format */0
                  },
                  _1: "<1>"
                }
              },
              _1: {
                TAG: /* Char_literal */12,
                _0: /* '[' */91,
                _1: {
                  TAG: /* Alpha */15,
                  _0: {
                    TAG: /* Theta */16,
                    _0: {
                      TAG: /* Char_literal */12,
                      _0: /* ']' */93,
                      _1: {
                        TAG: /* Formatting_lit */17,
                        _0: /* Close_box */0,
                        _1: /* End_of_format */0
                      }
                    }
                  }
                }
              }
            },
            _1: "@[<1>[%a%t]@]"
          }), pr, param.hd, (function (ppf) {
          Stdlib__List.iter((function (x) {
                  Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                            _0: {
                              TAG: /* Char_literal */12,
                              _0: /* ';' */59,
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@,",
                                  _1: 0,
                                  _2: 0
                                },
                                _1: {
                                  TAG: /* Alpha */15,
                                  _0: /* End_of_format */0
                                }
                              }
                            },
                            _1: ";@,%a"
                          }), pr, x);
                }), l);
        }));
}

function safe_kind_repr(_v, _param) {
  while(true) {
    const param = _param;
    const v = _v;
    if (typeof param === "number") {
      if (param) {
        return "Fabsent";
      } else {
        return "Fpresent";
      }
    }
    const k = param._0.contents;
    if (k === undefined) {
      return "Fvar None";
    }
    if (Stdlib__List.memq(k, v)) {
      return "Fvar loop";
    }
    _param = k;
    _v = {
      hd: k,
      tl: v
    };
    continue ;
  };
}

function safe_commu_repr(_v, _r) {
  while(true) {
    const r = _r;
    const v = _v;
    if (typeof r === "number") {
      if (r) {
        return "Cunknown";
      } else {
        return "Cok";
      }
    }
    const r$1 = r._0;
    if (Stdlib__List.memq(r$1, v)) {
      return "Clink loop";
    }
    _r = r$1.contents;
    _v = {
      hd: r$1,
      tl: v
    };
    continue ;
  };
}

function safe_repr(_v, _t) {
  while(true) {
    const t = _t;
    const v = _v;
    const t$1 = t.desc;
    if (typeof t$1 === "number") {
      return t;
    }
    if (t$1.TAG !== /* Tlink */6) {
      return t;
    }
    const t$2 = t$1._0;
    if (Stdlib__List.memq(t$2, v)) {
      return t;
    }
    _t = t$2;
    _v = {
      hd: t$2,
      tl: v
    };
    continue ;
  };
}

function list_of_memo(_rem) {
  while(true) {
    const rem = _rem;
    if (typeof rem === "number") {
      return /* [] */0;
    }
    if (rem.TAG === /* Mcons */0) {
      return {
              hd: rem._1,
              tl: list_of_memo(rem._4)
            };
    }
    _rem = rem._0.contents;
    continue ;
  };
}

function print_name(ppf, name) {
  if (name !== undefined) {
    return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                    _0: {
                      TAG: /* Char_literal */12,
                      _0: /* '"' */34,
                      _1: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* Char_literal */12,
                          _0: /* '"' */34,
                          _1: /* End_of_format */0
                        }
                      }
                    },
                    _1: "\"%s\""
                  }), name);
  } else {
    return Stdlib__Format.fprintf(ppf)(/* Format */{
                _0: {
                  TAG: /* String_literal */11,
                  _0: "None",
                  _1: /* End_of_format */0
                },
                _1: "None"
              });
  }
}

const visited = {
  contents: /* [] */0
};

function raw_type(ppf, ty) {
  const ty$1 = safe_repr(/* [] */0, ty);
  if (Stdlib__List.memq(ty$1, visited.contents)) {
    return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "{id=",
                      _1: {
                        TAG: /* Int */4,
                        _0: /* Int_d */0,
                        _1: /* No_padding */0,
                        _2: /* No_precision */0,
                        _3: {
                          TAG: /* Char_literal */12,
                          _0: /* '}' */125,
                          _1: /* End_of_format */0
                        }
                      }
                    },
                    _1: "{id=%d}"
                  }), ty$1.id);
  } else {
    visited.contents = {
      hd: ty$1,
      tl: visited.contents
    };
    return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                    _0: {
                      TAG: /* Formatting_gen */18,
                      _0: {
                        TAG: /* Open_box */1,
                        _0: /* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "<1>",
                            _1: /* End_of_format */0
                          },
                          _1: "<1>"
                        }
                      },
                      _1: {
                        TAG: /* String_literal */11,
                        _0: "{id=",
                        _1: {
                          TAG: /* Int */4,
                          _0: /* Int_d */0,
                          _1: /* No_padding */0,
                          _2: /* No_precision */0,
                          _3: {
                            TAG: /* String_literal */11,
                            _0: ";level=",
                            _1: {
                              TAG: /* Int */4,
                              _0: /* Int_d */0,
                              _1: /* No_padding */0,
                              _2: /* No_precision */0,
                              _3: {
                                TAG: /* String_literal */11,
                                _0: ";desc=",
                                _1: {
                                  TAG: /* Formatting_lit */17,
                                  _0: {
                                    TAG: /* Break */0,
                                    _0: "@,",
                                    _1: 0,
                                    _2: 0
                                  },
                                  _1: {
                                    TAG: /* Alpha */15,
                                    _0: {
                                      TAG: /* Char_literal */12,
                                      _0: /* '}' */125,
                                      _1: {
                                        TAG: /* Formatting_lit */17,
                                        _0: /* Close_box */0,
                                        _1: /* End_of_format */0
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    _1: "@[<1>{id=%d;level=%d;desc=@,%a}@]"
                  }), ty$1.id, ty$1.level, raw_type_desc, ty$1.desc);
  }
}

function raw_type_list(tl) {
  return function (param) {
    return raw_list(raw_type, tl, param);
  };
}

function raw_type_desc(ppf, name) {
  if (typeof name === "number") {
    return Stdlib__Format.fprintf(ppf)(/* Format */{
                _0: {
                  TAG: /* String_literal */11,
                  _0: "Tnil",
                  _1: /* End_of_format */0
                },
                _1: "Tnil"
              });
  }
  switch (name.TAG | 0) {
    case /* Tvar */0 :
        return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "Tvar ",
                          _1: {
                            TAG: /* Alpha */15,
                            _0: /* End_of_format */0
                          }
                        },
                        _1: "Tvar %a"
                      }), print_name, name._0);
    case /* Tarrow */1 :
        return Curry._6(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<hov1>",
                                _1: /* End_of_format */0
                              },
                              _1: "<hov1>"
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "Tarrow(",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Char_literal */12,
                                _0: /* ',' */44,
                                _1: {
                                  TAG: /* Formatting_lit */17,
                                  _0: {
                                    TAG: /* Break */0,
                                    _0: "@,",
                                    _1: 0,
                                    _2: 0
                                  },
                                  _1: {
                                    TAG: /* Alpha */15,
                                    _0: {
                                      TAG: /* Char_literal */12,
                                      _0: /* ',' */44,
                                      _1: {
                                        TAG: /* Formatting_lit */17,
                                        _0: {
                                          TAG: /* Break */0,
                                          _0: "@,",
                                          _1: 0,
                                          _2: 0
                                        },
                                        _1: {
                                          TAG: /* Alpha */15,
                                          _0: {
                                            TAG: /* Char_literal */12,
                                            _0: /* ',' */44,
                                            _1: {
                                              TAG: /* Formatting_lit */17,
                                              _0: {
                                                TAG: /* Break */0,
                                                _0: "@,",
                                                _1: 0,
                                                _2: 0
                                              },
                                              _1: {
                                                TAG: /* String */2,
                                                _0: /* No_padding */0,
                                                _1: {
                                                  TAG: /* Char_literal */12,
                                                  _0: /* ')' */41,
                                                  _1: {
                                                    TAG: /* Formatting_lit */17,
                                                    _0: /* Close_box */0,
                                                    _1: /* End_of_format */0
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@[<hov1>Tarrow(%s,@,%a,@,%a,@,%s)@]"
                      }), name._0, raw_type, name._1, raw_type, name._2, safe_commu_repr(/* [] */0, name._3));
    case /* Ttuple */2 :
        return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<1>",
                                _1: /* End_of_format */0
                              },
                              _1: "<1>"
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "Ttuple",
                            _1: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@,",
                                _1: 0,
                                _2: 0
                              },
                              _1: {
                                TAG: /* Alpha */15,
                                _0: {
                                  TAG: /* Formatting_lit */17,
                                  _0: /* Close_box */0,
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          }
                        },
                        _1: "@[<1>Ttuple@,%a@]"
                      }), raw_type_list, name._0);
    case /* Tconstr */3 :
        return Curry._6(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<hov1>",
                                _1: /* End_of_format */0
                              },
                              _1: "<hov1>"
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "Tconstr(",
                            _1: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@,",
                                _1: 0,
                                _2: 0
                              },
                              _1: {
                                TAG: /* Alpha */15,
                                _0: {
                                  TAG: /* Char_literal */12,
                                  _0: /* ',' */44,
                                  _1: {
                                    TAG: /* Formatting_lit */17,
                                    _0: {
                                      TAG: /* Break */0,
                                      _0: "@,",
                                      _1: 0,
                                      _2: 0
                                    },
                                    _1: {
                                      TAG: /* Alpha */15,
                                      _0: {
                                        TAG: /* Char_literal */12,
                                        _0: /* ',' */44,
                                        _1: {
                                          TAG: /* Formatting_lit */17,
                                          _0: {
                                            TAG: /* Break */0,
                                            _0: "@,",
                                            _1: 0,
                                            _2: 0
                                          },
                                          _1: {
                                            TAG: /* Alpha */15,
                                            _0: {
                                              TAG: /* Char_literal */12,
                                              _0: /* ')' */41,
                                              _1: {
                                                TAG: /* Formatting_lit */17,
                                                _0: /* Close_box */0,
                                                _1: /* End_of_format */0
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@[<hov1>Tconstr(@,%a,@,%a,@,%a)@]"
                      }), path, name._0, raw_type_list, name._1, (function (param, param$1) {
                      return raw_list(path, param, param$1);
                    }), list_of_memo(name._2.contents));
    case /* Tobject */4 :
        const nm = name._1;
        return Curry._3(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<hov1>",
                                _1: /* End_of_format */0
                              },
                              _1: "<hov1>"
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "Tobject(",
                            _1: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@,",
                                _1: 0,
                                _2: 0
                              },
                              _1: {
                                TAG: /* Alpha */15,
                                _0: {
                                  TAG: /* Char_literal */12,
                                  _0: /* ',' */44,
                                  _1: {
                                    TAG: /* Formatting_lit */17,
                                    _0: {
                                      TAG: /* Break */0,
                                      _0: "@,",
                                      _1: 0,
                                      _2: 0
                                    },
                                    _1: {
                                      TAG: /* Formatting_gen */18,
                                      _0: {
                                        TAG: /* Open_box */1,
                                        _0: /* Format */{
                                          _0: {
                                            TAG: /* String_literal */11,
                                            _0: "<1>",
                                            _1: /* End_of_format */0
                                          },
                                          _1: "<1>"
                                        }
                                      },
                                      _1: {
                                        TAG: /* String_literal */11,
                                        _0: "ref",
                                        _1: {
                                          TAG: /* Theta */16,
                                          _0: {
                                            TAG: /* Formatting_lit */17,
                                            _0: /* Close_box */0,
                                            _1: {
                                              TAG: /* Char_literal */12,
                                              _0: /* ')' */41,
                                              _1: {
                                                TAG: /* Formatting_lit */17,
                                                _0: /* Close_box */0,
                                                _1: /* End_of_format */0
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@[<hov1>Tobject(@,%a,@,@[<1>ref%t@])@]"
                      }), raw_type, name._0, (function (ppf) {
                      const match = nm.contents;
                      if (match !== undefined) {
                        return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                                        _0: {
                                          TAG: /* String_literal */11,
                                          _0: "(Some(",
                                          _1: {
                                            TAG: /* Formatting_lit */17,
                                            _0: {
                                              TAG: /* Break */0,
                                              _0: "@,",
                                              _1: 0,
                                              _2: 0
                                            },
                                            _1: {
                                              TAG: /* Alpha */15,
                                              _0: {
                                                TAG: /* Char_literal */12,
                                                _0: /* ',' */44,
                                                _1: {
                                                  TAG: /* Formatting_lit */17,
                                                  _0: {
                                                    TAG: /* Break */0,
                                                    _0: "@,",
                                                    _1: 0,
                                                    _2: 0
                                                  },
                                                  _1: {
                                                    TAG: /* Alpha */15,
                                                    _0: {
                                                      TAG: /* String_literal */11,
                                                      _0: "))",
                                                      _1: /* End_of_format */0
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        },
                                        _1: "(Some(@,%a,@,%a))"
                                      }), path, match[0], raw_type_list, match[1]);
                      } else {
                        return Stdlib__Format.fprintf(ppf)(/* Format */{
                                    _0: {
                                      TAG: /* String_literal */11,
                                      _0: " None",
                                      _1: /* End_of_format */0
                                    },
                                    _1: " None"
                                  });
                      }
                    }));
    case /* Tfield */5 :
        return Curry._6(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<hov1>",
                                _1: /* End_of_format */0
                              },
                              _1: "<hov1>"
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "Tfield(",
                            _1: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@,",
                                _1: 0,
                                _2: 0
                              },
                              _1: {
                                TAG: /* String */2,
                                _0: /* No_padding */0,
                                _1: {
                                  TAG: /* Char_literal */12,
                                  _0: /* ',' */44,
                                  _1: {
                                    TAG: /* Formatting_lit */17,
                                    _0: {
                                      TAG: /* Break */0,
                                      _0: "@,",
                                      _1: 0,
                                      _2: 0
                                    },
                                    _1: {
                                      TAG: /* String */2,
                                      _0: /* No_padding */0,
                                      _1: {
                                        TAG: /* Char_literal */12,
                                        _0: /* ',' */44,
                                        _1: {
                                          TAG: /* Formatting_lit */17,
                                          _0: {
                                            TAG: /* Break */0,
                                            _0: "@,",
                                            _1: 0,
                                            _2: 0
                                          },
                                          _1: {
                                            TAG: /* Alpha */15,
                                            _0: {
                                              TAG: /* Char_literal */12,
                                              _0: /* ',' */44,
                                              _1: {
                                                TAG: /* Formatting_lit */17,
                                                _0: {
                                                  TAG: /* Break */0,
                                                  _0: "@;<0 -1>",
                                                  _1: 0,
                                                  _2: -1
                                                },
                                                _1: {
                                                  TAG: /* Alpha */15,
                                                  _0: {
                                                    TAG: /* Char_literal */12,
                                                    _0: /* ')' */41,
                                                    _1: {
                                                      TAG: /* Formatting_lit */17,
                                                      _0: /* Close_box */0,
                                                      _1: /* End_of_format */0
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@[<hov1>Tfield(@,%s,@,%s,@,%a,@;<0 -1>%a)@]"
                      }), name._0, safe_kind_repr(/* [] */0, name._1), raw_type, name._2, raw_type, name._3);
    case /* Tlink */6 :
        return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<1>",
                                _1: /* End_of_format */0
                              },
                              _1: "<1>"
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "Tlink",
                            _1: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@,",
                                _1: 0,
                                _2: 0
                              },
                              _1: {
                                TAG: /* Alpha */15,
                                _0: {
                                  TAG: /* Formatting_lit */17,
                                  _0: /* Close_box */0,
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          }
                        },
                        _1: "@[<1>Tlink@,%a@]"
                      }), raw_type, name._0);
    case /* Tsubst */7 :
        return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<1>",
                                _1: /* End_of_format */0
                              },
                              _1: "<1>"
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "Tsubst",
                            _1: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@,",
                                _1: 0,
                                _2: 0
                              },
                              _1: {
                                TAG: /* Alpha */15,
                                _0: {
                                  TAG: /* Formatting_lit */17,
                                  _0: /* Close_box */0,
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          }
                        },
                        _1: "@[<1>Tsubst@,%a@]"
                      }), raw_type, name._0);
    case /* Tvariant */8 :
        const row = name._0;
        return Curry.app(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<hov1>",
                                _1: /* End_of_format */0
                              },
                              _1: "<hov1>"
                            }
                          },
                          _1: {
                            TAG: /* Char_literal */12,
                            _0: /* '{' */123,
                            _1: {
                              TAG: /* Formatting_gen */18,
                              _0: {
                                TAG: /* Open_box */1,
                                _0: /* Format */{
                                  _0: /* End_of_format */0,
                                  _1: ""
                                }
                              },
                              _1: {
                                TAG: /* String */2,
                                _0: /* No_padding */0,
                                _1: {
                                  TAG: /* Formatting_lit */17,
                                  _0: {
                                    TAG: /* Break */0,
                                    _0: "@,",
                                    _1: 0,
                                    _2: 0
                                  },
                                  _1: {
                                    TAG: /* Alpha */15,
                                    _0: {
                                      TAG: /* Char_literal */12,
                                      _0: /* ';' */59,
                                      _1: {
                                        TAG: /* Formatting_lit */17,
                                        _0: /* Close_box */0,
                                        _1: {
                                          TAG: /* Formatting_lit */17,
                                          _0: {
                                            TAG: /* Break */0,
                                            _0: "@ ",
                                            _1: 1,
                                            _2: 0
                                          },
                                          _1: {
                                            TAG: /* Formatting_gen */18,
                                            _0: {
                                              TAG: /* Open_box */1,
                                              _0: /* Format */{
                                                _0: /* End_of_format */0,
                                                _1: ""
                                              }
                                            },
                                            _1: {
                                              TAG: /* String */2,
                                              _0: /* No_padding */0,
                                              _1: {
                                                TAG: /* Formatting_lit */17,
                                                _0: {
                                                  TAG: /* Break */0,
                                                  _0: "@,",
                                                  _1: 0,
                                                  _2: 0
                                                },
                                                _1: {
                                                  TAG: /* Alpha */15,
                                                  _0: {
                                                    TAG: /* Char_literal */12,
                                                    _0: /* ';' */59,
                                                    _1: {
                                                      TAG: /* Formatting_lit */17,
                                                      _0: /* Close_box */0,
                                                      _1: {
                                                        TAG: /* Formatting_lit */17,
                                                        _0: {
                                                          TAG: /* Break */0,
                                                          _0: "@ ",
                                                          _1: 1,
                                                          _2: 0
                                                        },
                                                        _1: {
                                                          TAG: /* String */2,
                                                          _0: /* No_padding */0,
                                                          _1: {
                                                            TAG: /* Bool */9,
                                                            _0: /* No_padding */0,
                                                            _1: {
                                                              TAG: /* Char_literal */12,
                                                              _0: /* ';' */59,
                                                              _1: {
                                                                TAG: /* Formatting_lit */17,
                                                                _0: {
                                                                  TAG: /* Break */0,
                                                                  _0: "@ ",
                                                                  _1: 1,
                                                                  _2: 0
                                                                },
                                                                _1: {
                                                                  TAG: /* String */2,
                                                                  _0: /* No_padding */0,
                                                                  _1: {
                                                                    TAG: /* Bool */9,
                                                                    _0: /* No_padding */0,
                                                                    _1: {
                                                                      TAG: /* Char_literal */12,
                                                                      _0: /* ';' */59,
                                                                      _1: {
                                                                        TAG: /* Formatting_lit */17,
                                                                        _0: {
                                                                          TAG: /* Break */0,
                                                                          _0: "@ ",
                                                                          _1: 1,
                                                                          _2: 0
                                                                        },
                                                                        _1: {
                                                                          TAG: /* Formatting_gen */18,
                                                                          _0: {
                                                                            TAG: /* Open_box */1,
                                                                            _0: /* Format */{
                                                                              _0: {
                                                                                TAG: /* String_literal */11,
                                                                                _0: "<1>",
                                                                                _1: /* End_of_format */0
                                                                              },
                                                                              _1: "<1>"
                                                                            }
                                                                          },
                                                                          _1: {
                                                                            TAG: /* String */2,
                                                                            _0: /* No_padding */0,
                                                                            _1: {
                                                                              TAG: /* Theta */16,
                                                                              _0: {
                                                                                TAG: /* Formatting_lit */17,
                                                                                _0: /* Close_box */0,
                                                                                _1: {
                                                                                  TAG: /* Char_literal */12,
                                                                                  _0: /* '}' */125,
                                                                                  _1: {
                                                                                    TAG: /* Formatting_lit */17,
                                                                                    _0: /* Close_box */0,
                                                                                    _1: /* End_of_format */0
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@[<hov1>{@[%s@,%a;@]@ @[%s@,%a;@]@ %s%b;@ %s%b;@ @[<1>%s%t@]}@]"
                      }), [
                    "row_fields=",
                    (function (param, param$1) {
                        return raw_list((function (ppf, param) {
                                      Curry._3(Stdlib__Format.fprintf(ppf)(/* Format */{
                                                _0: {
                                                  TAG: /* Formatting_gen */18,
                                                  _0: {
                                                    TAG: /* Open_box */1,
                                                    _0: /* Format */{
                                                      _0: /* End_of_format */0,
                                                      _1: ""
                                                    }
                                                  },
                                                  _1: {
                                                    TAG: /* String */2,
                                                    _0: /* No_padding */0,
                                                    _1: {
                                                      TAG: /* Char_literal */12,
                                                      _0: /* ',' */44,
                                                      _1: {
                                                        TAG: /* Formatting_lit */17,
                                                        _0: {
                                                          TAG: /* Break */0,
                                                          _0: "@ ",
                                                          _1: 1,
                                                          _2: 0
                                                        },
                                                        _1: {
                                                          TAG: /* Alpha */15,
                                                          _0: {
                                                            TAG: /* Formatting_lit */17,
                                                            _0: /* Close_box */0,
                                                            _1: /* End_of_format */0
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                },
                                                _1: "@[%s,@ %a@]"
                                              }), param[0], raw_field, param[1]);
                                    }), param, param$1);
                      }),
                    row.row_fields,
                    "row_more=",
                    raw_type,
                    row.row_more,
                    "row_closed=",
                    row.row_closed,
                    "row_fixed=",
                    row.row_fixed,
                    "row_name=",
                    (function (ppf) {
                        const match = row.row_name;
                        if (match !== undefined) {
                          return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                                          _0: {
                                            TAG: /* String_literal */11,
                                            _0: "Some(",
                                            _1: {
                                              TAG: /* Formatting_lit */17,
                                              _0: {
                                                TAG: /* Break */0,
                                                _0: "@,",
                                                _1: 0,
                                                _2: 0
                                              },
                                              _1: {
                                                TAG: /* Alpha */15,
                                                _0: {
                                                  TAG: /* Char_literal */12,
                                                  _0: /* ',' */44,
                                                  _1: {
                                                    TAG: /* Formatting_lit */17,
                                                    _0: {
                                                      TAG: /* Break */0,
                                                      _0: "@,",
                                                      _1: 0,
                                                      _2: 0
                                                    },
                                                    _1: {
                                                      TAG: /* Alpha */15,
                                                      _0: {
                                                        TAG: /* Char_literal */12,
                                                        _0: /* ')' */41,
                                                        _1: /* End_of_format */0
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          },
                                          _1: "Some(@,%a,@,%a)"
                                        }), path, match[0], raw_type_list, match[1]);
                        } else {
                          return Stdlib__Format.fprintf(ppf)(/* Format */{
                                      _0: {
                                        TAG: /* String_literal */11,
                                        _0: "None",
                                        _1: /* End_of_format */0
                                      },
                                      _1: "None"
                                    });
                        }
                      })
                  ]);
    case /* Tunivar */9 :
        return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "Tunivar ",
                          _1: {
                            TAG: /* Alpha */15,
                            _0: /* End_of_format */0
                          }
                        },
                        _1: "Tunivar %a"
                      }), print_name, name._0);
    case /* Tpoly */10 :
        return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<hov1>",
                                _1: /* End_of_format */0
                              },
                              _1: "<hov1>"
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "Tpoly(",
                            _1: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@,",
                                _1: 0,
                                _2: 0
                              },
                              _1: {
                                TAG: /* Alpha */15,
                                _0: {
                                  TAG: /* Char_literal */12,
                                  _0: /* ',' */44,
                                  _1: {
                                    TAG: /* Formatting_lit */17,
                                    _0: {
                                      TAG: /* Break */0,
                                      _0: "@,",
                                      _1: 0,
                                      _2: 0
                                    },
                                    _1: {
                                      TAG: /* Alpha */15,
                                      _0: {
                                        TAG: /* Char_literal */12,
                                        _0: /* ')' */41,
                                        _1: {
                                          TAG: /* Formatting_lit */17,
                                          _0: /* Close_box */0,
                                          _1: /* End_of_format */0
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@[<hov1>Tpoly(@,%a,@,%a)@]"
                      }), raw_type, name._0, raw_type_list, name._1);
    case /* Tpackage */11 :
        return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<hov1>",
                                _1: /* End_of_format */0
                              },
                              _1: "<hov1>"
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "Tpackage(",
                            _1: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@,",
                                _1: 0,
                                _2: 0
                              },
                              _1: {
                                TAG: /* Alpha */15,
                                _0: {
                                  TAG: /* Formatting_lit */17,
                                  _0: {
                                    TAG: /* Break */0,
                                    _0: "@,",
                                    _1: 0,
                                    _2: 0
                                  },
                                  _1: {
                                    TAG: /* Alpha */15,
                                    _0: {
                                      TAG: /* Char_literal */12,
                                      _0: /* ')' */41,
                                      _1: {
                                        TAG: /* Formatting_lit */17,
                                        _0: /* Close_box */0,
                                        _1: /* End_of_format */0
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@[<hov1>Tpackage(@,%a@,%a)@]"
                      }), path, name._0, raw_type_list, name._2);
    
  }
}

function raw_field(ppf, param) {
  if (typeof param === "number") {
    return Stdlib__Format.fprintf(ppf)(/* Format */{
                _0: {
                  TAG: /* String_literal */11,
                  _0: "Rabsent",
                  _1: /* End_of_format */0
                },
                _1: "Rabsent"
              });
  }
  if (param.TAG === /* Rpresent */0) {
    const t = param._0;
    if (t !== undefined) {
      return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                      _0: {
                        TAG: /* Formatting_gen */18,
                        _0: {
                          TAG: /* Open_box */1,
                          _0: /* Format */{
                            _0: {
                              TAG: /* String_literal */11,
                              _0: "<1>",
                              _1: /* End_of_format */0
                            },
                            _1: "<1>"
                          }
                        },
                        _1: {
                          TAG: /* String_literal */11,
                          _0: "Rpresent(Some",
                          _1: {
                            TAG: /* Formatting_lit */17,
                            _0: {
                              TAG: /* Break */0,
                              _0: "@,",
                              _1: 0,
                              _2: 0
                            },
                            _1: {
                              TAG: /* Alpha */15,
                              _0: {
                                TAG: /* Char_literal */12,
                                _0: /* ')' */41,
                                _1: {
                                  TAG: /* Formatting_lit */17,
                                  _0: /* Close_box */0,
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          }
                        }
                      },
                      _1: "@[<1>Rpresent(Some@,%a)@]"
                    }), raw_type, t);
    } else {
      return Stdlib__Format.fprintf(ppf)(/* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "Rpresent None",
                    _1: /* End_of_format */0
                  },
                  _1: "Rpresent None"
                });
    }
  }
  const e = param._3;
  Curry._5(Stdlib__Format.fprintf(ppf)(/* Format */{
            _0: {
              TAG: /* Formatting_gen */18,
              _0: {
                TAG: /* Open_box */1,
                _0: /* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "<hov1>",
                    _1: /* End_of_format */0
                  },
                  _1: "<hov1>"
                }
              },
              _1: {
                TAG: /* String_literal */11,
                _0: "Reither(",
                _1: {
                  TAG: /* Bool */9,
                  _0: /* No_padding */0,
                  _1: {
                    TAG: /* Char_literal */12,
                    _0: /* ',' */44,
                    _1: {
                      TAG: /* Formatting_lit */17,
                      _0: {
                        TAG: /* Break */0,
                        _0: "@,",
                        _1: 0,
                        _2: 0
                      },
                      _1: {
                        TAG: /* Alpha */15,
                        _0: {
                          TAG: /* Char_literal */12,
                          _0: /* ',' */44,
                          _1: {
                            TAG: /* Formatting_lit */17,
                            _0: {
                              TAG: /* Break */0,
                              _0: "@,",
                              _1: 0,
                              _2: 0
                            },
                            _1: {
                              TAG: /* Bool */9,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Char_literal */12,
                                _0: /* ',' */44,
                                _1: {
                                  TAG: /* Formatting_lit */17,
                                  _0: {
                                    TAG: /* Break */0,
                                    _0: "@,",
                                    _1: 0,
                                    _2: 0
                                  },
                                  _1: {
                                    TAG: /* Formatting_gen */18,
                                    _0: {
                                      TAG: /* Open_box */1,
                                      _0: /* Format */{
                                        _0: {
                                          TAG: /* String_literal */11,
                                          _0: "<1>",
                                          _1: /* End_of_format */0
                                        },
                                        _1: "<1>"
                                      }
                                    },
                                    _1: {
                                      TAG: /* String_literal */11,
                                      _0: "ref",
                                      _1: {
                                        TAG: /* Theta */16,
                                        _0: {
                                          TAG: /* Formatting_lit */17,
                                          _0: /* Close_box */0,
                                          _1: {
                                            TAG: /* Char_literal */12,
                                            _0: /* ')' */41,
                                            _1: {
                                              TAG: /* Formatting_lit */17,
                                              _0: /* Close_box */0,
                                              _1: /* End_of_format */0
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
            _1: "@[<hov1>Reither(%b,@,%a,@,%b,@,@[<1>ref%t@])@]"
          }), param._0, raw_type_list, param._1, param._2, (function (ppf) {
          const f = e.contents;
          if (f !== undefined) {
            return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                            _0: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@,",
                                _1: 0,
                                _2: 0
                              },
                              _1: {
                                TAG: /* Formatting_gen */18,
                                _0: {
                                  TAG: /* Open_box */1,
                                  _0: /* Format */{
                                    _0: {
                                      TAG: /* String_literal */11,
                                      _0: "<1>",
                                      _1: /* End_of_format */0
                                    },
                                    _1: "<1>"
                                  }
                                },
                                _1: {
                                  TAG: /* Char_literal */12,
                                  _0: /* '(' */40,
                                  _1: {
                                    TAG: /* Alpha */15,
                                    _0: {
                                      TAG: /* Char_literal */12,
                                      _0: /* ')' */41,
                                      _1: {
                                        TAG: /* Formatting_lit */17,
                                        _0: /* Close_box */0,
                                        _1: /* End_of_format */0
                                      }
                                    }
                                  }
                                }
                              }
                            },
                            _1: "@,@[<1>(%a)@]"
                          }), raw_field, f);
          } else {
            return Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: " None",
                          _1: /* End_of_format */0
                        },
                        _1: " None"
                      });
          }
        }));
}

function raw_type_expr(ppf, t) {
  visited.contents = /* [] */0;
  raw_type(ppf, t);
  visited.contents = /* [] */0;
}

print_raw = raw_type_expr;

function is_nth(param) {
  if (typeof param === "number" || param.TAG !== /* Nth */0) {
    return false;
  } else {
    return true;
  }
}

function compose(l1, l2) {
  if (typeof l2 === "number") {
    return {
            TAG: /* Map */1,
            _0: l1
          };
  } else if (l2.TAG === /* Nth */0) {
    return {
            TAG: /* Nth */0,
            _0: Stdlib__List.nth(l1, l2._0)
          };
  } else {
    return {
            TAG: /* Map */1,
            _0: Stdlib__List.map((function (param) {
                    return Stdlib__List.nth(l1, param);
                  }), l2._0)
          };
  }
}

function apply_subst(s1, tyl) {
  if (typeof s1 === "number") {
    return tyl;
  } else if (s1.TAG === /* Nth */0) {
    return {
            hd: Stdlib__List.nth(tyl, s1._0),
            tl: /* [] */0
          };
  } else {
    return Stdlib__List.map((function (param) {
                  return Stdlib__List.nth(tyl, param);
                }), s1._0);
  }
}

const printing_env = {
  contents: empty
};

const printing_depth = {
  contents: 0
};

const printing_cont = {
  contents: /* [] */0
};

const printing_old = {
  contents: empty
};

const printing_pers = {
  contents: /* Empty */0
};

function compare$4(_p1, _p2) {
  while(true) {
    const p2 = _p2;
    const p1 = _p1;
    switch (p1.TAG | 0) {
      case /* Pident */0 :
          return Caml_obj.caml_compare(p1, p2);
      case /* Pdot */1 :
          switch (p2.TAG | 0) {
            case /* Pdot */1 :
                const c = compare$4(p1._0, p2._0);
                if (c !== 0) {
                  return c;
                } else {
                  return Caml.caml_string_compare(p1._1, p2._1);
                }
            case /* Pident */0 :
            case /* Papply */2 :
                return Caml_obj.caml_compare(p1, p2);
            
          }
      case /* Papply */2 :
          switch (p2.TAG | 0) {
            case /* Pident */0 :
            case /* Pdot */1 :
                return Caml_obj.caml_compare(p1, p2);
            case /* Papply */2 :
                const c$1 = compare$4(p1._0, p2._0);
                if (c$1 !== 0) {
                  return c$1;
                }
                _p2 = p2._1;
                _p1 = p1._1;
                continue ;
            
          }
      
    }
  };
}

const funarg$3 = {
  compare: compare$4
};

function height$6(param) {
  if (param) {
    return param.h;
  } else {
    return 0;
  }
}

function create$7(l, x, d, r) {
  const hl = height$6(l);
  const hr = height$6(r);
  return /* Node */{
          l: l,
          v: x,
          d: d,
          r: r,
          h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        };
}

function bal$6(l, x, d, r) {
  const hl = l ? l.h : 0;
  const hr = r ? r.h : 0;
  if (hl > (hr + 2 | 0)) {
    if (l) {
      const lr = l.r;
      const ld = l.d;
      const lv = l.v;
      const ll = l.l;
      if (height$6(ll) >= height$6(lr)) {
        return create$7(ll, lv, ld, create$7(lr, x, d, r));
      }
      if (lr) {
        return create$7(create$7(ll, lv, ld, lr.l), lr.v, lr.d, create$7(lr.r, x, d, r));
      }
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
                MEL_EXN_ID: "Invalid_argument",
                _1: "Map.bal"
              });
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Map.bal"
            });
  }
  if (hr <= (hl + 2 | 0)) {
    return /* Node */{
            l: l,
            v: x,
            d: d,
            r: r,
            h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          };
  }
  if (r) {
    const rr = r.r;
    const rd = r.d;
    const rv = r.v;
    const rl = r.l;
    if (height$6(rr) >= height$6(rl)) {
      return create$7(create$7(l, x, d, rl), rv, rd, rr);
    }
    if (rl) {
      return create$7(create$7(l, x, d, rl.l), rl.v, rl.d, create$7(rl.r, rv, rd, rr));
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Map.bal"
            });
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Map.bal"
          });
}

function add$8(x, data, m) {
  if (!m) {
    return /* Node */{
            l: /* Empty */0,
            v: x,
            d: data,
            r: /* Empty */0,
            h: 1
          };
  }
  const r = m.r;
  const d = m.d;
  const v = m.v;
  const l = m.l;
  const c = Curry._2(funarg$3.compare, x, v);
  if (c === 0) {
    if (d === data) {
      return m;
    } else {
      return /* Node */{
              l: l,
              v: x,
              d: data,
              r: r,
              h: m.h
            };
    }
  }
  if (c < 0) {
    const ll = add$8(x, data, l);
    if (l === ll) {
      return m;
    } else {
      return bal$6(ll, v, d, r);
    }
  }
  const rr = add$8(x, data, r);
  if (r === rr) {
    return m;
  } else {
    return bal$6(l, v, d, rr);
  }
}

function find$4(x, _param) {
  while(true) {
    const param = _param;
    if (param) {
      const c = Curry._2(funarg$3.compare, x, param.v);
      if (c === 0) {
        return param.d;
      }
      _param = c < 0 ? param.l : param.r;
      continue ;
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
  };
}

const printing_map = {
  contents: /* Empty */0
};

function same_type(t, t$p) {
  return repr(t) === repr(t$p);
}

function index(l, x) {
  if (l) {
    if (x === l.hd) {
      return 0;
    } else {
      return 1 + index(l.tl, x) | 0;
    }
  }
  throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
}

function uniq(_param) {
  while(true) {
    const param = _param;
    if (!param) {
      return true;
    }
    const l = param.tl;
    if (Stdlib__List.memq(param.hd, l)) {
      return false;
    }
    _param = l;
    continue ;
  };
}

function normalize_type_path(cacheOpt, env, p) {
  const cache = cacheOpt !== undefined ? cacheOpt : false;
  try {
    const match = find_type_expansion(p, env);
    const params = Stdlib__List.map(repr, match[0]);
    const ty = repr(match[1]);
    const match$1 = ty.desc;
    if (typeof match$1 === "number") {
      return [
              p,
              {
                TAG: /* Nth */0,
                _0: index(params, ty)
              }
            ];
    }
    if (match$1.TAG !== /* Tconstr */3) {
      return [
              p,
              {
                TAG: /* Nth */0,
                _0: index(params, ty)
              }
            ];
    }
    const p1 = match$1._0;
    const tyl = Stdlib__List.map(repr, match$1._1);
    if (Stdlib__List.length(params) === Stdlib__List.length(tyl) && Stdlib__List.for_all2((function (prim0, prim1) {
              return prim0 === prim1;
            }), params, tyl)) {
      return normalize_type_path(cache, env, p1);
    }
    if (cache || Stdlib__List.length(params) <= Stdlib__List.length(tyl) || !uniq(tyl)) {
      return [
              p,
              /* Id */0
            ];
    }
    const l1 = Stdlib__List.map((function (param) {
            return index(params, param);
          }), tyl);
    const match$2 = normalize_type_path(cache, env, p1);
    return [
            match$2[0],
            compose(l1, match$2[1])
          ];
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return [
              p,
              /* Id */0
            ];
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function path_size(id) {
  switch (id.TAG | 0) {
    case /* Pident */0 :
        const id$1 = id._0;
        const s = id$1.name;
        return [
                s !== "" && Caml_string.get(s, 0) === /* '_' */95 ? 10 : 1,
                -id$1.stamp | 0
              ];
    case /* Pdot */1 :
        const match = path_size(id._0);
        return [
                1 + match[0] | 0,
                match[1]
              ];
    case /* Papply */2 :
        const match$1 = path_size(id._0);
        return [
                match$1[0] + path_size(id._1)[0] | 0,
                match$1[1]
              ];
    
  }
}

function same_printing_env(env) {
  const used_pers = used_persistent(undefined);
  if (same_types(printing_old.contents, env)) {
    return Curry._2(equal$3, printing_pers.contents, used_pers);
  } else {
    return false;
  }
}

function set_printing_env(env) {
  printing_env.contents = real_paths.contents ? empty : env;
  if (printing_env.contents === empty || same_printing_env(env)) {
    return ;
  }
  printing_old.contents = env;
  printing_pers.contents = used_persistent(undefined);
  printing_map.contents = /* Empty */0;
  printing_depth.contents = 0;
  const partial_arg = iter_types(function (p, param) {
        const match = normalize_type_path(true, env, param[0]);
        if (!Caml_obj.caml_equal(match[1], /* Id */0)) {
          return ;
        }
        const p1 = match[0];
        try {
          const r = Curry._2(find$4, p1, printing_map.contents);
          const l = r.contents;
          if (l.TAG === /* Paths */0) {
            r.contents = {
              TAG: /* Paths */0,
              _0: {
                hd: p,
                tl: l._0
              }
            };
          } else {
            r.contents = {
              TAG: /* Paths */0,
              _0: {
                hd: p,
                tl: {
                  hd: l._0,
                  tl: /* [] */0
                }
              }
            };
          }
          return ;
        }
        catch (raw_exn){
          const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.MEL_EXN_ID === Stdlib.Not_found) {
            printing_map.contents = Curry._3(add$8, p1, {
                  contents: {
                    TAG: /* Paths */0,
                    _0: {
                      hd: p,
                      tl: /* [] */0
                    }
                  }
                }, printing_map.contents);
            return ;
          }
          throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
        }
      });
  const cont = function (param) {
    return partial_arg(env, param);
  };
  printing_cont.contents = {
    hd: cont,
    tl: /* [] */0
  };
}

function wrap_printing_env(env, f) {
  set_printing_env(env);
  return try_finally(f, (function (param) {
                set_printing_env(empty);
              }));
}

function is_unambiguous(path, env) {
  const l = find_shadowed_types(path, env);
  if (Stdlib__List.exists((function (param) {
            return same(path, param);
          }), l)) {
    return true;
  }
  if (!l) {
    return true;
  }
  const rem = l.tl;
  const p = l.hd;
  const normalize = function (p) {
    return normalize_type_path(true, env, p)[0];
  };
  const p$p = normalize(p);
  if (Stdlib__List.for_all((function (p) {
            return same(normalize(p), p$p);
          }), rem)) {
    return true;
  }
  const id = lid_of_path(undefined, p);
  if (Stdlib__List.for_all((function (p) {
            return Caml_obj.caml_equal(lid_of_path(undefined, p), id);
          }), rem)) {
    return same(p, lookup_type$1(id, env)[0]);
  } else {
    return false;
  }
}

function best_type_path(p) {
  if (real_paths.contents || printing_env.contents === empty) {
    return [
            p,
            /* Id */0
          ];
  }
  const match = normalize_type_path(undefined, printing_env.contents, p);
  const p$p = match[0];
  const get_path = function (param) {
    let r = Curry._2(find$4, p$p, printing_map.contents);
    while(true) {
      const p$p$1 = r.contents;
      if (p$p$1.TAG !== /* Paths */0) {
        return p$p$1._0;
      }
      const l = p$p$1._0;
      if (l) {
        r.contents = {
          TAG: /* Paths */0,
          _0: /* [] */0
        };
        Stdlib__List.iter((function (p) {
                const p$p = r.contents;
                if (p$p.TAG !== /* Paths */0 && Caml_obj.caml_greaterequal(path_size(p), path_size(p$p._0))) {
                  return ;
                }
                if (is_unambiguous(p, printing_env.contents)) {
                  r.contents = {
                    TAG: /* Best */1,
                    _0: p
                  };
                  return ;
                }
                
              }), l);
        continue ;
      }
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
    };
  };
  while((function () {
          let tmp = false;
          if (Caml_obj.caml_notequal(printing_cont.contents, /* [] */0)) {
            let tmp$1;
            try {
              get_path(undefined);
              tmp$1 = false;
            }
            catch (raw_exn){
              const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn.MEL_EXN_ID === Stdlib.Not_found) {
                tmp$1 = true;
              } else {
                throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
              }
            }
            tmp = tmp$1;
          }
          return tmp;
        })()) {
    printing_cont.contents = Stdlib__List.map((function (prim) {
            return prim[1];
          }), run_iter_cont(printing_cont.contents));
    printing_depth.contents = printing_depth.contents + 1 | 0;
  };
  let p$p$p;
  try {
    p$p$p = get_path(undefined);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      p$p$p = p$p;
    } else {
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  }
  return [
          p$p$p,
          match[1]
        ];
}

const names = {
  contents: /* [] */0
};

const name_counter = {
  contents: 0
};

const named_vars = {
  contents: /* [] */0
};

function reset_names(param) {
  names.contents = /* [] */0;
  name_counter.contents = 0;
  named_vars.contents = /* [] */0;
}

function add_named_var(ty) {
  const match = ty.desc;
  if (typeof match === "number") {
    return ;
  }
  switch (match.TAG | 0) {
    case /* Tvar */0 :
    case /* Tunivar */9 :
        break;
    default:
      return ;
  }
  const name = match._0;
  if (name !== undefined && !Stdlib__List.mem(name, named_vars.contents)) {
    named_vars.contents = {
      hd: name,
      tl: named_vars.contents
    };
    return ;
  }
  
}

function new_name(_param) {
  while(true) {
    let name;
    if (name_counter.contents < 26) {
      const c = Stdlib__Char.chr(97 + name_counter.contents | 0);
      name = Caml_bytes.bytes_to_string(Stdlib__Bytes.make(1, c));
    } else {
      const c$1 = Stdlib__Char.chr(97 + name_counter.contents % 26 | 0);
      name = Caml_bytes.bytes_to_string(Stdlib__Bytes.make(1, c$1)) + String(name_counter.contents / 26 | 0);
    }
    name_counter.contents = name_counter.contents + 1 | 0;
    if (!(Stdlib__List.mem(name, named_vars.contents) || Stdlib__List.exists((function (param) {
                return name === param[1];
              }), names.contents))) {
      return name;
    }
    _param = undefined;
    continue ;
  };
}

function name_of_type(t) {
  try {
    return Stdlib__List.assq(t, names.contents);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      const match = t.desc;
      let name;
      let exit = 0;
      if (typeof match === "number") {
        name = new_name(undefined);
      } else {
        switch (match.TAG | 0) {
          case /* Tvar */0 :
          case /* Tunivar */9 :
              exit = 1;
              break;
          default:
            name = new_name(undefined);
        }
      }
      if (exit === 1) {
        const name$1 = match._0;
        if (name$1 !== undefined) {
          const current_name = {
            contents: name$1
          };
          let i = 0;
          while(Stdlib__List.exists((function (param) {
                    return current_name.contents === param[1];
                  }), names.contents)) {
            current_name.contents = name$1 + String(i);
            i = i + 1 | 0;
          };
          name = current_name.contents;
        } else {
          name = new_name(undefined);
        }
      }
      if (name !== "_") {
        names.contents = {
          hd: [
            t,
            name
          ],
          tl: names.contents
        };
      }
      return name;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function check_name_of_type(t) {
  name_of_type(t);
}

function remove_names(tyl) {
  const tyl$1 = Stdlib__List.map(repr, tyl);
  names.contents = Stdlib__List.filter((function (param) {
          return !Stdlib__List.memq(param[0], tyl$1);
        }), names.contents);
}

const visited_objects = {
  contents: /* [] */0
};

const aliased = {
  contents: /* [] */0
};

const delayed = {
  contents: /* [] */0
};

function add_delayed(t) {
  if (!Stdlib__List.memq(t, delayed.contents)) {
    delayed.contents = {
      hd: t,
      tl: delayed.contents
    };
    return ;
  }
  
}

function is_aliased(ty) {
  return Stdlib__List.memq(proxy(ty), aliased.contents);
}

function add_alias(ty) {
  const px = proxy(ty);
  if (!is_aliased(px)) {
    aliased.contents = {
      hd: px,
      tl: aliased.contents
    };
    return add_named_var(px);
  }
  
}

function aliasable(ty) {
  const match = ty.desc;
  if (typeof match === "number") {
    return true;
  }
  switch (match.TAG | 0) {
    case /* Tconstr */3 :
        return !is_nth(best_type_path(match._0)[1]);
    case /* Tvar */0 :
    case /* Tunivar */9 :
    case /* Tpoly */10 :
        return false;
    default:
      return true;
  }
}

function namable_row(row) {
  if (row.row_name !== undefined) {
    return Stdlib__List.for_all((function (param) {
                  const match = row_field_repr_aux(/* [] */0, param[1]);
                  if (typeof match === "number") {
                    return true;
                  }
                  if (match.TAG === /* Rpresent */0) {
                    return true;
                  }
                  const l = match._1;
                  if (row.row_closed) {
                    if (match._0) {
                      return Caml_obj.caml_equal(l, /* [] */0);
                    } else {
                      return Stdlib__List.length(l) === 1;
                    }
                  } else {
                    return false;
                  }
                }), row.row_fields);
  } else {
    return false;
  }
}

function mark_loops_rec(_visited, _ty) {
  while(true) {
    const ty = _ty;
    const visited = _visited;
    const ty$1 = repr(ty);
    const px = proxy(ty$1);
    if (Stdlib__List.memq(px, visited) && aliasable(ty$1)) {
      return add_alias(px);
    }
    const visited$1 = {
      hd: px,
      tl: visited
    };
    const tyl = ty$1.desc;
    if (typeof tyl === "number") {
      return ;
    }
    switch (tyl.TAG | 0) {
      case /* Tarrow */1 :
          mark_loops_rec(visited$1, tyl._1);
          _ty = tyl._2;
          _visited = visited$1;
          continue ;
      case /* Ttuple */2 :
          return Stdlib__List.iter((function (param) {
                        return mark_loops_rec(visited$1, param);
                      }), tyl._0);
      case /* Tconstr */3 :
          const match = best_type_path(tyl._0);
          return Stdlib__List.iter((function (param) {
                        return mark_loops_rec(visited$1, param);
                      }), apply_subst(match[1], tyl._1));
      case /* Tobject */4 :
          if (Stdlib__List.memq(px, visited_objects.contents)) {
            return add_alias(px);
          }
          if (opened_object(ty$1)) {
            visited_objects.contents = {
              hd: px,
              tl: visited_objects.contents
            };
          }
          const match$1 = tyl._1.contents;
          if (match$1 !== undefined) {
            return Stdlib__List.iter((function (param) {
                          return mark_loops_rec(visited$1, param);
                        }), Stdlib__List.tl(match$1[1]));
          }
          const match$2 = flatten_fields(tyl._0);
          return Stdlib__List.iter((function (param) {
                        if (Caml_obj.caml_equal(field_kind_repr(param[1]), /* Fpresent */0)) {
                          return mark_loops_rec(visited$1, param[2]);
                        }
                        
                      }), match$2[0]);
      case /* Tfield */5 :
          if (Caml_obj.caml_equal(field_kind_repr(tyl._1), /* Fpresent */0)) {
            mark_loops_rec(visited$1, tyl._2);
            _ty = tyl._3;
            _visited = visited$1;
            continue ;
          }
          _ty = tyl._3;
          _visited = visited$1;
          continue ;
      case /* Tlink */6 :
          return fatal_error("Printtyp.mark_loops_rec (2)");
      case /* Tsubst */7 :
          _ty = tyl._0;
          _visited = visited$1;
          continue ;
      case /* Tvariant */8 :
          if (Stdlib__List.memq(px, visited_objects.contents)) {
            return add_alias(px);
          }
          const row = row_repr_aux(/* [] */0, tyl._0);
          if (!static_row(row)) {
            visited_objects.contents = {
              hd: px,
              tl: visited_objects.contents
            };
          }
          const match$3 = row.row_name;
          if (match$3 !== undefined) {
            if (namable_row(row)) {
              return Stdlib__List.iter((function (param) {
                            return mark_loops_rec(visited$1, param);
                          }), match$3[1]);
            } else {
              return iter_row((function (param) {
                            return mark_loops_rec(visited$1, param);
                          }), row);
            }
          } else {
            return iter_row((function (param) {
                          return mark_loops_rec(visited$1, param);
                        }), row);
          }
      case /* Tvar */0 :
      case /* Tunivar */9 :
          return add_named_var(ty$1);
      case /* Tpoly */10 :
          Stdlib__List.iter(add_alias, tyl._1);
          _ty = tyl._0;
          _visited = visited$1;
          continue ;
      case /* Tpackage */11 :
          return Stdlib__List.iter((function (param) {
                        return mark_loops_rec(visited$1, param);
                      }), tyl._2);
      
    }
  };
}

function mark_loops(ty) {
  normalize_type(empty, ty);
  mark_loops_rec(/* [] */0, ty);
}

function reset(param) {
  unique_names.contents = /* Empty */0;
  reset_names(undefined);
  visited_objects.contents = /* [] */0;
  aliased.contents = /* [] */0;
  delayed.contents = /* [] */0;
}

function reset_and_mark_loops_list(tyl) {
  reset(undefined);
  Stdlib__List.iter(mark_loops, tyl);
}

const print_labels = {
  contents: true
};

function tree_of_typexp(sch, ty) {
  const ty$1 = repr(ty);
  const px = proxy(ty$1);
  if (Stdlib__List.mem_assq(px, names.contents) && !Stdlib__List.memq(px, delayed.contents)) {
    const mark = is_non_gen(sch, ty$1);
    return {
            TAG: /* Otyp_var */10,
            _0: mark,
            _1: name_of_type(px)
          };
  }
  const pr_typ = function (param) {
    const tyl = ty$1.desc;
    if (typeof tyl === "number") {
      return tree_of_typobject(sch, ty$1, undefined);
    }
    switch (tyl.TAG | 0) {
      case /* Tvar */0 :
          return {
                  TAG: /* Otyp_var */10,
                  _0: is_non_gen(sch, ty$1),
                  _1: name_of_type(ty$1)
                };
      case /* Tarrow */1 :
          let l = tyl._0;
          let ty1 = tyl._1;
          let ty2 = tyl._2;
          const lab = print_labels.contents && l !== "" || is_optional(l) ? l : "";
          let t1;
          if (is_optional(l)) {
            const match = repr(ty1).desc;
            if (typeof match === "number" || match.TAG !== /* Tconstr */3) {
              t1 = {
                TAG: /* Otyp_stuff */7,
                _0: "<hidden>"
              };
            } else {
              const match$1 = match._1;
              t1 = match$1 && !(match$1.tl || !same(match._0, path_option)) ? tree_of_typexp(sch, match$1.hd) : ({
                    TAG: /* Otyp_stuff */7,
                    _0: "<hidden>"
                  });
            }
          } else {
            t1 = tree_of_typexp(sch, ty1);
          }
          return {
                  TAG: /* Otyp_arrow */1,
                  _0: lab,
                  _1: t1,
                  _2: tree_of_typexp(sch, ty2)
                };
      case /* Ttuple */2 :
          return {
                  TAG: /* Otyp_tuple */9,
                  _0: Stdlib__List.map((function (param) {
                          return tree_of_typexp(sch, param);
                        }), tyl._0)
                };
      case /* Tconstr */3 :
          const match$2 = best_type_path(tyl._0);
          const s = match$2[1];
          const tyl$p = apply_subst(s, tyl._1);
          if (is_nth(s)) {
            return tree_of_typexp(sch, Stdlib__List.hd(tyl$p));
          } else {
            return {
                    TAG: /* Otyp_constr */3,
                    _0: tree_of_path(match$2[0]),
                    _1: Stdlib__List.map((function (param) {
                            return tree_of_typexp(sch, param);
                          }), tyl$p)
                  };
          }
      case /* Tobject */4 :
          return tree_of_typobject(sch, tyl._0, tyl._1.contents);
      case /* Tfield */5 :
          return tree_of_typobject(sch, ty$1, undefined);
      case /* Tlink */6 :
          return fatal_error("Printtyp.tree_of_typexp");
      case /* Tsubst */7 :
          return tree_of_typexp(sch, tyl._0);
      case /* Tvariant */8 :
          const row = row_repr_aux(/* [] */0, tyl._0);
          const fields = row.row_closed ? Stdlib__List.filter((function (param) {
                    return Caml_obj.caml_notequal(row_field_repr_aux(/* [] */0, param[1]), /* Rabsent */0);
                  }), row.row_fields) : row.row_fields;
          const present = Stdlib__List.filter((function (param) {
                  const match = row_field_repr_aux(/* [] */0, param[1]);
                  if (typeof match === "number" || match.TAG !== /* Rpresent */0) {
                    return false;
                  } else {
                    return true;
                  }
                }), fields);
          const all_present = Stdlib__List.length(present) === Stdlib__List.length(fields);
          const match$3 = row.row_name;
          if (match$3 !== undefined) {
            const tyl$1 = match$3[1];
            const p = match$3[0];
            if (namable_row(row)) {
              const match$4 = best_type_path(p);
              const s$1 = match$4[1];
              const id = tree_of_path(match$4[0]);
              const tyl$2 = apply_subst(s$1, tyl$1);
              const args = Stdlib__List.map((function (param) {
                      return tree_of_typexp(sch, param);
                    }), tyl$2);
              if (row.row_closed && all_present) {
                if (is_nth(s$1)) {
                  return Stdlib__List.hd(args);
                } else {
                  return {
                          TAG: /* Otyp_constr */3,
                          _0: id,
                          _1: args
                        };
                }
              }
              const non_gen = is_non_gen(sch, px);
              const tags = all_present ? undefined : Stdlib__List.map((function (prim) {
                        return prim[0];
                      }), present);
              let inh;
              let exit = 0;
              if (args) {
                const match$5 = args.hd;
                if (typeof match$5 === "number" || !(match$5.TAG === /* Otyp_constr */3 && !(args.tl || !is_nth(s$1)))) {
                  exit = 2;
                } else {
                  inh = {
                    TAG: /* Ovar_name */1,
                    _0: match$5._0,
                    _1: match$5._1
                  };
                }
              } else {
                exit = 2;
              }
              if (exit === 2) {
                inh = {
                  TAG: /* Ovar_name */1,
                  _0: tree_of_path(p),
                  _1: Stdlib__List.map((function (param) {
                          return tree_of_typexp(sch, param);
                        }), tyl$1)
                };
              }
              return {
                      TAG: /* Otyp_variant */11,
                      _0: non_gen,
                      _1: inh,
                      _2: row.row_closed,
                      _3: tags
                    };
            }
            
          }
          const non_gen$1 = !(row.row_closed && all_present) && is_non_gen(sch, px);
          const fields$1 = Stdlib__List.map((function (param) {
                  const l = param[0];
                  const match = row_field_repr_aux(/* [] */0, param[1]);
                  if (typeof match === "number") {
                    return [
                            l,
                            false,
                            /* [] */0
                          ];
                  }
                  if (match.TAG === /* Rpresent */0) {
                    const ty = match._0;
                    if (ty !== undefined) {
                      return [
                              l,
                              false,
                              {
                                hd: tree_of_typexp(sch, ty),
                                tl: /* [] */0
                              }
                            ];
                    } else {
                      return [
                              l,
                              false,
                              /* [] */0
                            ];
                    }
                  }
                  const c = match._0;
                  if (c && !match._1) {
                    return [
                            l,
                            false,
                            /* [] */0
                          ];
                  }
                  const tyl = match._1;
                  if (c) {
                    return [
                            l,
                            true,
                            Stdlib__List.map((function (param) {
                                    return tree_of_typexp(sch, param);
                                  }), tyl)
                          ];
                  } else {
                    return [
                            l,
                            false,
                            Stdlib__List.map((function (param) {
                                    return tree_of_typexp(sch, param);
                                  }), tyl)
                          ];
                  }
                }), fields);
          const tags$1 = all_present ? undefined : Stdlib__List.map((function (prim) {
                    return prim[0];
                  }), present);
          return {
                  TAG: /* Otyp_variant */11,
                  _0: non_gen$1,
                  _1: {
                    TAG: /* Ovar_fields */0,
                    _0: fields$1
                  },
                  _2: row.row_closed,
                  _3: tags$1
                };
      case /* Tunivar */9 :
          return {
                  TAG: /* Otyp_var */10,
                  _0: false,
                  _1: name_of_type(ty$1)
                };
      case /* Tpoly */10 :
          const ty$2 = tyl._0;
          if (!tyl._1) {
            return tree_of_typexp(sch, ty$2);
          }
          const tyl$3 = Stdlib__List.map(repr, tyl._1);
          if (Caml_obj.caml_equal(tyl$3, /* [] */0)) {
            return tree_of_typexp(sch, ty$2);
          }
          const old_delayed = delayed.contents;
          Stdlib__List.iter(add_delayed, tyl$3);
          const tl = Stdlib__List.map(name_of_type, tyl$3);
          const tr_1 = tree_of_typexp(sch, ty$2);
          const tr = {
            TAG: /* Otyp_poly */12,
            _0: tl,
            _1: tr_1
          };
          remove_names(tyl$3);
          delayed.contents = old_delayed;
          return tr;
      case /* Tpackage */11 :
          const n = Stdlib__List.map((function (li) {
                  return Stdlib__String.concat(".", flat(/* [] */0, li));
                }), tyl._1);
          return {
                  TAG: /* Otyp_module */13,
                  _0: name(undefined, tyl._0),
                  _1: n,
                  _2: Stdlib__List.map((function (param) {
                          return tree_of_typexp(sch, param);
                        }), tyl._2)
                };
      
    }
  };
  if (Stdlib__List.memq(px, delayed.contents)) {
    delayed.contents = Stdlib__List.filter((function (param) {
            return px !== param;
          }), delayed.contents);
  }
  if (is_aliased(px) && aliasable(ty$1)) {
    name_of_type(px);
    return {
            TAG: /* Otyp_alias */0,
            _0: pr_typ(undefined),
            _1: name_of_type(px)
          };
  } else {
    return pr_typ(undefined);
  }
}

function tree_of_typobject(sch, fi, nm) {
  if (nm !== undefined) {
    const match = nm[1];
    if (!match) {
      return fatal_error("Printtyp.tree_of_typobject");
    }
    const non_gen = is_non_gen(sch, repr(match.hd));
    const args = Stdlib__List.map((function (param) {
            return tree_of_typexp(sch, param);
          }), match.tl);
    const match$1 = best_type_path(nm[0]);
    if (!Caml_obj.caml_equal(match$1[1], /* Id */0)) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  36171,
                  6
                ]
              });
    }
    return {
            TAG: /* Otyp_class */2,
            _0: non_gen,
            _1: tree_of_path(match$1[0]),
            _2: args
          };
  }
  const pr_fields = function (fi) {
    const match = flatten_fields(fi);
    const present_fields = Stdlib__List.fold_right((function (param, l) {
            const match = field_kind_repr(param[1]);
            if (typeof match === "number" && !match) {
              return {
                      hd: [
                        param[0],
                        param[2]
                      ],
                      tl: l
                    };
            } else {
              return l;
            }
          }), match[0], /* [] */0);
    const sorted_fields = Stdlib__List.sort((function (param, param$1) {
            return Caml.caml_string_compare(param[0], param$1[0]);
          }), present_fields);
    return tree_of_typfields(sch, match[1], sorted_fields);
  };
  const match$2 = pr_fields(fi);
  return {
          TAG: /* Otyp_object */5,
          _0: match$2[0],
          _1: match$2[1]
        };
}

function is_non_gen(sch, ty) {
  if (sch && is_Tvar(ty)) {
    return ty.level !== 100000000;
  } else {
    return false;
  }
}

function tree_of_typfields(sch, rest, param) {
  if (param) {
    const match = param.hd;
    const field_0 = match[0];
    const field_1 = tree_of_typexp(sch, match[1]);
    const field = [
      field_0,
      field_1
    ];
    const match$1 = tree_of_typfields(sch, rest, param.tl);
    return [
            {
              hd: field,
              tl: match$1[0]
            },
            match$1[1]
          ];
  }
  const match$2 = rest.desc;
  let rest$1;
  if (typeof match$2 === "number") {
    rest$1 = undefined;
  } else {
    switch (match$2.TAG | 0) {
      case /* Tconstr */3 :
          rest$1 = false;
          break;
      case /* Tvar */0 :
      case /* Tunivar */9 :
          rest$1 = is_non_gen(sch, rest);
          break;
      default:
        rest$1 = fatal_error("typfields (1)");
    }
  }
  return [
          /* [] */0,
          rest$1
        ];
}

function typexp$1(sch, prio, ppf, ty) {
  Curry._2(out_type.contents, ppf, tree_of_typexp(sch, ty));
}

function type_expr$1(ppf, ty) {
  typexp$1(false, 0, ppf, ty);
}

function type_scheme(ppf, ty) {
  reset(undefined);
  mark_loops(ty);
  typexp$1(true, 0, ppf, ty);
}

function tree_of_type_scheme(ty) {
  reset(undefined);
  mark_loops(ty);
  return tree_of_typexp(true, ty);
}

function tree_of_constraints(params) {
  return Stdlib__List.fold_right((function (ty, list) {
                const ty$p = unalias(ty);
                if (proxy(ty) === proxy(ty$p)) {
                  return list;
                }
                const tr = tree_of_typexp(true, ty);
                return {
                        hd: [
                          tr,
                          tree_of_typexp(true, ty$p)
                        ],
                        tl: list
                      };
              }), params, /* [] */0);
}

function filter_params(tyl) {
  return Stdlib__List.rev(Stdlib__List.fold_left((function (tyl, ty) {
                    const ty$1 = repr(ty);
                    if (Stdlib__List.memq(ty$1, tyl)) {
                      return {
                              hd: newty2(100000000, {
                                    TAG: /* Tsubst */7,
                                    _0: ty$1
                                  }),
                              tl: tyl
                            };
                    } else {
                      return {
                              hd: ty$1,
                              tl: tyl
                            };
                    }
                  }), /* [] */0, tyl));
}

function tree_of_label(l) {
  return [
          l.ld_id.name,
          l.ld_mutable === /* Mutable */1,
          tree_of_typexp(false, l.ld_type)
        ];
}

function tree_of_constructor(cd) {
  const name = cd.cd_id.name;
  const res = cd.cd_res;
  if (res === undefined) {
    return [
            name,
            Stdlib__List.map((function (param) {
                    return tree_of_typexp(false, param);
                  }), cd.cd_args),
            undefined
          ];
  }
  const nm = names.contents;
  names.contents = /* [] */0;
  const ret = tree_of_typexp(false, res);
  const args = Stdlib__List.map((function (param) {
          return tree_of_typexp(false, param);
        }), cd.cd_args);
  names.contents = nm;
  return [
          name,
          args,
          ret
        ];
}

function tree_of_type_decl(id, decl) {
  reset(undefined);
  const params = filter_params(decl.type_params);
  const ty = decl.type_manifest;
  if (ty !== undefined) {
    const vars = free_variables$1(undefined, ty);
    Stdlib__List.iter((function (ty) {
            const match = ty.desc;
            if (typeof match === "number") {
              return ;
            }
            if (match.TAG !== /* Tvar */0) {
              return ;
            }
            const match$1 = match._0;
            if (match$1 !== undefined && match$1 === "_" && Stdlib__List.memq(ty, vars)) {
              ty.desc = {
                TAG: /* Tvar */0,
                _0: undefined
              };
              return ;
            }
            
          }), params);
  }
  Stdlib__List.iter(add_alias, params);
  Stdlib__List.iter(mark_loops, params);
  Stdlib__List.iter(check_name_of_type, Stdlib__List.map(proxy, params));
  const ty$1 = decl.type_manifest;
  let ty_manifest;
  if (ty$1 !== undefined) {
    const match = repr(ty$1);
    const row = match.desc;
    let ty$2;
    if (typeof row === "number" || row.TAG !== /* Tvariant */8) {
      ty$2 = ty$1;
    } else {
      const row$1 = row_repr_aux(/* [] */0, row._0);
      const match$1 = row$1.row_name;
      if (match$1 !== undefined) {
        const id$p = match$1[0];
        switch (id$p.TAG | 0) {
          case /* Pident */0 :
              ty$2 = Caml_obj.caml_equal(id, id$p._0) ? newty2(100000000, {
                      TAG: /* Tvariant */8,
                      _0: {
                        row_fields: row$1.row_fields,
                        row_more: row$1.row_more,
                        row_bound: row$1.row_bound,
                        row_closed: row$1.row_closed,
                        row_fixed: row$1.row_fixed,
                        row_name: undefined
                      }
                    }) : ty$1;
              break;
          case /* Pdot */1 :
          case /* Papply */2 :
              ty$2 = ty$1;
              break;
          
        }
      } else {
        ty$2 = ty$1;
      }
    }
    mark_loops(ty$2);
    ty_manifest = ty$2;
  } else {
    ty_manifest = undefined;
  }
  const cstrs = decl.type_kind;
  if (typeof cstrs === "number") {
    cstrs === /* Type_abstract */0;
  } else if (cstrs.TAG === /* Type_record */0) {
    Stdlib__List.iter((function (l) {
            mark_loops(l.ld_type);
          }), cstrs._0);
  } else {
    Stdlib__List.iter((function (c) {
            Stdlib__List.iter(mark_loops, c.cd_args);
            may(mark_loops, c.cd_res);
          }), cstrs._0);
  }
  const type_param = function (param) {
    if (typeof param === "number" || param.TAG !== /* Otyp_var */10) {
      return "?";
    } else {
      return param._1;
    }
  };
  const type_defined = function (decl) {
    const tll = decl.type_kind;
    let abstr;
    abstr = typeof tll === "number" ? (
        tll === /* Type_abstract */0 ? decl.type_manifest === undefined || decl.type_private === /* Private */0 : decl.type_manifest === undefined
      ) : (
        tll.TAG === /* Type_record */0 ? decl.type_private === /* Private */0 : decl.type_private === /* Private */0 || Stdlib__List.exists((function (cd) {
                  return cd.cd_res !== undefined;
                }), tll._0)
      );
    const vari = Stdlib__List.map2((function (ty, v) {
            if (abstr || !is_Tvar(repr(ty))) {
              return Curry._1(Types_Variance.get_upper, v);
            } else {
              return [
                      true,
                      true
                    ];
            }
          }), decl.type_params, decl.type_variance);
    return [
            id.name,
            Stdlib__List.map2((function (ty, cocn) {
                    return [
                            type_param(tree_of_typexp(false, ty)),
                            cocn
                          ];
                  }), params, vari)
          ];
  };
  const tree_of_manifest = function (ty1) {
    if (ty_manifest !== undefined) {
      return {
              TAG: /* Otyp_manifest */4,
              _0: tree_of_typexp(false, ty_manifest),
              _1: ty1
            };
    } else {
      return ty1;
    }
  };
  const match$2 = type_defined(decl);
  const constraints = tree_of_constraints(params);
  const cstrs$1 = decl.type_kind;
  let match$3;
  match$3 = typeof cstrs$1 === "number" ? (
      cstrs$1 === /* Type_abstract */0 ? (
          ty_manifest !== undefined ? [
              tree_of_typexp(false, ty_manifest),
              decl.type_private
            ] : [
              /* Otyp_abstract */0,
              /* Public */1
            ]
        ) : [
          tree_of_manifest(/* Otyp_open */1),
          /* Public */1
        ]
    ) : (
      cstrs$1.TAG === /* Type_record */0 ? [
          tree_of_manifest({
                TAG: /* Otyp_record */6,
                _0: Stdlib__List.map(tree_of_label, cstrs$1._0)
              }),
          decl.type_private
        ] : [
          tree_of_manifest({
                TAG: /* Otyp_sum */8,
                _0: Stdlib__List.map(tree_of_constructor, cstrs$1._0)
              }),
          decl.type_private
        ]
    );
  return {
          otype_name: match$2[0],
          otype_params: match$2[1],
          otype_type: match$3[0],
          otype_private: match$3[1],
          otype_cstrs: constraints
        };
}

function tree_of_type_declaration(id, decl, rs) {
  return {
          TAG: /* Osig_type */5,
          _0: tree_of_type_decl(id, decl),
          _1: rs
        };
}

function type_declaration$1(id, ppf, decl) {
  Curry._2(out_sig_item.contents, ppf, tree_of_type_declaration(id, decl, /* Trec_first */1));
}

function tree_of_extension_constructor(id, ext, es) {
  reset(undefined);
  const ty_name = name(undefined, ext.ext_type_path);
  const ty_params = filter_params(ext.ext_type_params);
  Stdlib__List.iter(add_alias, ty_params);
  Stdlib__List.iter(mark_loops, ty_params);
  Stdlib__List.iter(check_name_of_type, Stdlib__List.map(proxy, ty_params));
  Stdlib__List.iter(mark_loops, ext.ext_args);
  may(mark_loops, ext.ext_ret_type);
  const ty_params$1 = Stdlib__List.map((function (ty) {
          let param = tree_of_typexp(false, ty);
          if (typeof param === "number" || param.TAG !== /* Otyp_var */10) {
            return "?";
          } else {
            return param._1;
          }
        }), ty_params);
  const name$1 = id.name;
  const res = ext.ext_ret_type;
  let match;
  if (res !== undefined) {
    const nm = names.contents;
    names.contents = /* [] */0;
    const ret = tree_of_typexp(false, res);
    const args = Stdlib__List.map((function (param) {
            return tree_of_typexp(false, param);
          }), ext.ext_args);
    names.contents = nm;
    match = [
      args,
      ret
    ];
  } else {
    match = [
      Stdlib__List.map((function (param) {
              return tree_of_typexp(false, param);
            }), ext.ext_args),
      undefined
    ];
  }
  const ext_oext_args = match[0];
  const ext_oext_ret_type = match[1];
  const ext_oext_private = ext.ext_private;
  const ext$1 = {
    oext_name: name$1,
    oext_type_name: ty_name,
    oext_type_params: ty_params$1,
    oext_args: ext_oext_args,
    oext_ret_type: ext_oext_ret_type,
    oext_private: ext_oext_private
  };
  return {
          TAG: /* Osig_typext */2,
          _0: ext$1,
          _1: es
        };
}

function extension_constructor$1(id, ppf, ext) {
  Curry._2(out_sig_item.contents, ppf, tree_of_extension_constructor(id, ext, /* Text_first */0));
}

function tree_of_value_description(id, decl) {
  const id$1 = id.name;
  const ty = tree_of_type_scheme(decl.val_type);
  const p = decl.val_kind;
  let prims;
  prims = typeof p === "number" || p.TAG !== /* Val_prim */0 ? /* [] */0 : description_list(p._0);
  return {
          TAG: /* Osig_value */6,
          _0: id$1,
          _1: ty,
          _2: prims
        };
}

function value_description$1(id, ppf, decl) {
  Curry._2(out_sig_item.contents, ppf, tree_of_value_description(id, decl));
}

function method_type(param) {
  const match = field_kind_repr(param[1]);
  const match$1 = repr(param[2]);
  if (typeof match !== "number") {
    return [
            match$1,
            /* [] */0
          ];
  }
  if (match) {
    return [
            match$1,
            /* [] */0
          ];
  }
  const match$2 = match$1.desc;
  if (typeof match$2 === "number" || match$2.TAG !== /* Tpoly */10) {
    return [
            match$1,
            /* [] */0
          ];
  } else {
    return [
            match$2._0,
            match$2._1
          ];
  }
}

function prepare_class_type(params, _sign) {
  while(true) {
    const sign = _sign;
    switch (sign.TAG | 0) {
      case /* Cty_constr */0 :
          const cty = sign._2;
          const tyl = sign._1;
          const sty = repr(signature_of_class_type(cty).csig_self);
          if (!(Stdlib__List.memq(proxy(sty), visited_objects.contents) || !Stdlib__List.for_all(is_Tvar, params) || Stdlib__List.exists((function (param) {
                      return deep_occur(sty, param);
                    }), tyl))) {
            return Stdlib__List.iter(mark_loops, tyl);
          }
          _sign = cty;
          continue ;
      case /* Cty_signature */1 :
          const sign$1 = sign._0;
          const sty$1 = repr(sign$1.csig_self);
          const px = proxy(sty$1);
          if (Stdlib__List.memq(px, visited_objects.contents)) {
            add_alias(sty$1);
          } else {
            visited_objects.contents = {
              hd: px,
              tl: visited_objects.contents
            };
          }
          const match = flatten_fields(object_fields(sign$1.csig_self));
          Stdlib__List.iter((function (met) {
                  mark_loops(method_type(met)[0]);
                }), match[0]);
          return Curry._2(Meths.iter, (function (param, param$1) {
                        mark_loops(param$1[2]);
                      }), sign$1.csig_vars);
      case /* Cty_arrow */2 :
          mark_loops(sign._1);
          _sign = sign._2;
          continue ;
      
    }
  };
}

function tree_of_class_type(sch, params, _sign) {
  while(true) {
    const sign = _sign;
    switch (sign.TAG | 0) {
      case /* Cty_constr */0 :
          const cty = sign._2;
          const sty = repr(signature_of_class_type(cty).csig_self);
          if (!(Stdlib__List.memq(proxy(sty), visited_objects.contents) || !Stdlib__List.for_all(is_Tvar, params))) {
            return {
                    TAG: /* Octy_constr */0,
                    _0: tree_of_path(sign._0),
                    _1: Stdlib__List.map((function (param) {
                            return tree_of_typexp(true, param);
                          }), sign._1)
                  };
          }
          _sign = cty;
          continue ;
      case /* Cty_signature */1 :
          const sign$1 = sign._0;
          const sty$1 = repr(sign$1.csig_self);
          const self_ty = is_aliased(sty$1) ? ({
                TAG: /* Otyp_var */10,
                _0: false,
                _1: name_of_type(proxy(sty$1))
              }) : undefined;
          const match = flatten_fields(object_fields(sign$1.csig_self));
          const csil = Stdlib__List.fold_left((function (csil, param) {
                  return {
                          hd: {
                            TAG: /* Ocsg_constraint */0,
                            _0: param[0],
                            _1: param[1]
                          },
                          tl: csil
                        };
                }), /* [] */0, tree_of_constraints(params));
          const all_vars = Curry._3(Meths.fold, (function (l, param, all) {
                  return {
                          hd: [
                            l,
                            param[0],
                            param[1],
                            param[2]
                          ],
                          tl: all
                        };
                }), sign$1.csig_vars, /* [] */0);
          const all_vars$1 = Stdlib__List.rev(all_vars);
          const csil$1 = Stdlib__List.fold_left((function (csil, param) {
                  return {
                          hd: {
                            TAG: /* Ocsg_value */2,
                            _0: param[0],
                            _1: param[1] === /* Mutable */1,
                            _2: param[2] === /* Virtual */0,
                            _3: tree_of_typexp(sch, param[3])
                          },
                          tl: csil
                        };
                }), csil, all_vars$1);
          const partial_arg = sign$1.csig_concr;
          const csil$2 = Stdlib__List.fold_left((function (param, param$1) {
                  const lab = param$1[0];
                  if (lab === dummy_method) {
                    return param;
                  }
                  const kind = field_kind_repr(param$1[1]);
                  const priv = Caml_obj.caml_notequal(kind, /* Fpresent */0);
                  const virt = !Curry._2(mem$2, lab, partial_arg);
                  const match = method_type([
                        lab,
                        kind,
                        param$1[2]
                      ]);
                  const tty = tree_of_typexp(sch, match[0]);
                  remove_names(match[1]);
                  return {
                          hd: {
                            TAG: /* Ocsg_method */1,
                            _0: lab,
                            _1: priv,
                            _2: virt,
                            _3: tty
                          },
                          tl: param
                        };
                }), csil$1, match[0]);
          return {
                  TAG: /* Octy_signature */2,
                  _0: self_ty,
                  _1: Stdlib__List.rev(csil$2)
                };
      case /* Cty_arrow */2 :
          const ty = sign._1;
          const l = sign._0;
          const lab = print_labels.contents && l !== "" || is_optional(l) ? l : "";
          let ty$1;
          if (is_optional(l)) {
            const match$1 = repr(ty).desc;
            let exit = 0;
            if (typeof match$1 === "number" || match$1.TAG !== /* Tconstr */3) {
              exit = 1;
            } else {
              const match$2 = match$1._1;
              if (match$2 && !(match$2.tl || !same(match$1._0, path_option))) {
                ty$1 = match$2.hd;
              } else {
                exit = 1;
              }
            }
            if (exit === 1) {
              ty$1 = newconstr({
                    TAG: /* Pident */0,
                    _0: create("<hidden>")
                  }, /* [] */0);
            }
            
          } else {
            ty$1 = ty;
          }
          const tr = tree_of_typexp(sch, ty$1);
          return {
                  TAG: /* Octy_arrow */1,
                  _0: lab,
                  _1: tr,
                  _2: tree_of_class_type(sch, params, sign._2)
                };
      
    }
  };
}

function class_type$2(ppf, cty) {
  reset(undefined);
  prepare_class_type(/* [] */0, cty);
  Curry._2(out_class_type.contents, ppf, tree_of_class_type(false, /* [] */0, cty));
}

function tree_of_class_param(param, variance) {
  const match = tree_of_typexp(true, param);
  let tmp;
  tmp = typeof match === "number" || match.TAG !== /* Otyp_var */10 ? "?" : match._1;
  return [
          tmp,
          is_Tvar(repr(param)) ? [
              true,
              true
            ] : variance
        ];
}

function class_variance(param) {
  return Stdlib__List.map((function (v) {
                return [
                        Curry._2(Types_Variance.mem, /* May_pos */0, v),
                        Curry._2(Types_Variance.mem, /* May_neg */1, v)
                      ];
              }), param);
}

function tree_of_class_declaration(id, cl, rs) {
  const params = filter_params(cl.cty_params);
  reset(undefined);
  Stdlib__List.iter(add_alias, params);
  prepare_class_type(params, cl.cty_type);
  const sty = repr(signature_of_class_type(cl.cty_type).csig_self);
  Stdlib__List.iter(mark_loops, params);
  Stdlib__List.iter(check_name_of_type, Stdlib__List.map(proxy, params));
  if (is_aliased(sty)) {
    const t = proxy(sty);
    name_of_type(t);
  }
  const vir_flag = cl.cty_new === undefined;
  return {
          TAG: /* Osig_class */0,
          _0: vir_flag,
          _1: id.name,
          _2: Stdlib__List.map2(tree_of_class_param, params, class_variance(cl.cty_variance)),
          _3: tree_of_class_type(true, params, cl.cty_type),
          _4: rs
        };
}

function class_declaration$1(id, ppf, cl) {
  Curry._2(out_sig_item.contents, ppf, tree_of_class_declaration(id, cl, /* Trec_first */1));
}

function tree_of_cltype_declaration(id, cl, rs) {
  const params = Stdlib__List.map(repr, cl.clty_params);
  reset(undefined);
  Stdlib__List.iter(add_alias, params);
  prepare_class_type(params, cl.clty_type);
  const sty = repr(signature_of_class_type(cl.clty_type).csig_self);
  Stdlib__List.iter(mark_loops, params);
  Stdlib__List.iter(check_name_of_type, Stdlib__List.map(proxy, params));
  if (is_aliased(sty)) {
    const t = proxy(sty);
    name_of_type(t);
  }
  const sign = signature_of_class_type(cl.clty_type);
  const match = flatten_fields(object_fields(sign.csig_self));
  const virt = Stdlib__List.exists((function (param) {
          const lab = param[0];
          return !(lab === dummy_method || Curry._2(mem$2, lab, sign.csig_concr));
        }), match[0]) || Curry._3(Meths.fold, (function (param, param$1, b) {
          if (param$1[1] === /* Virtual */0) {
            return true;
          } else {
            return b;
          }
        }), sign.csig_vars, false);
  return {
          TAG: /* Osig_class_type */1,
          _0: virt,
          _1: id.name,
          _2: Stdlib__List.map2(tree_of_class_param, params, class_variance(cl.clty_variance)),
          _3: tree_of_class_type(true, params, cl.clty_type),
          _4: rs
        };
}

function cltype_declaration$1(id, ppf, cl) {
  Curry._2(out_sig_item.contents, ppf, tree_of_cltype_declaration(id, cl, /* Trec_first */1));
}

function wrap_env(fenv, ftree, arg) {
  const env = printing_env.contents;
  set_printing_env(Curry._1(fenv, env));
  const tree = Curry._1(ftree, arg);
  set_printing_env(env);
  return tree;
}

function filter_rem_sig(item, rem) {
  switch (item.TAG | 0) {
    case /* Sig_class */5 :
        if (!rem) {
          return [
                  /* [] */0,
                  rem
                ];
        }
        const match = rem.tl;
        if (!match) {
          return [
                  /* [] */0,
                  rem
                ];
        }
        const match$1 = match.tl;
        if (match$1) {
          return [
                  {
                    hd: rem.hd,
                    tl: {
                      hd: match.hd,
                      tl: {
                        hd: match$1.hd,
                        tl: /* [] */0
                      }
                    }
                  },
                  match$1.tl
                ];
        } else {
          return [
                  /* [] */0,
                  rem
                ];
        }
    case /* Sig_class_type */6 :
        if (!rem) {
          return [
                  /* [] */0,
                  rem
                ];
        }
        const match$2 = rem.tl;
        if (match$2) {
          return [
                  {
                    hd: rem.hd,
                    tl: {
                      hd: match$2.hd,
                      tl: /* [] */0
                    }
                  },
                  match$2.tl
                ];
        } else {
          return [
                  /* [] */0,
                  rem
                ];
        }
    default:
      return [
              /* [] */0,
              rem
            ];
  }
}

const dummy = {
  type_params: /* [] */0,
  type_arity: 0,
  type_kind: /* Type_abstract */0,
  type_private: /* Public */1,
  type_manifest: undefined,
  type_variance: /* [] */0,
  type_newtype_level: undefined,
  type_loc: none,
  type_attributes: /* [] */0
};

function hide_rec_items(param) {
  if (!param) {
    return ;
  }
  const match = param.hd;
  if (match.TAG !== /* Sig_type */1) {
    return ;
  }
  if (!(match._2 === /* Trec_first */1 && !real_paths.contents)) {
    return ;
  }
  const get_ids = function (param) {
    if (!param) {
      return /* [] */0;
    }
    const match = param.hd;
    if (match.TAG === /* Sig_type */1 && match._2 >= 2) {
      return {
              hd: match._0,
              tl: get_ids(param.tl)
            };
    } else {
      return /* [] */0;
    }
  };
  const ids_0 = match._0;
  const ids_1 = get_ids(param.tl);
  const ids = {
    hd: ids_0,
    tl: ids_1
  };
  set_printing_env(Stdlib__List.fold_right((function (id) {
              const partial_arg = rename(id);
              return function (param) {
                return add_type$1(false, partial_arg, dummy, param);
              };
            }), ids, printing_env.contents));
}

function tree_of_modtype(p) {
  switch (p.TAG | 0) {
    case /* Mty_ident */0 :
        return {
                TAG: /* Omty_ident */1,
                _0: tree_of_path(p._0)
              };
    case /* Mty_signature */1 :
        return {
                TAG: /* Omty_signature */2,
                _0: tree_of_signature(p._0)
              };
    case /* Mty_functor */2 :
        const ty_res = p._2;
        const ty_arg = p._1;
        const param = p._0;
        let res;
        if (ty_arg !== undefined) {
          const partial_arg = true;
          res = wrap_env((function (param$1) {
                  return add_module$1(partial_arg, param, ty_arg, param$1);
                }), tree_of_modtype, ty_res);
        } else {
          res = tree_of_modtype(ty_res);
        }
        return {
                TAG: /* Omty_functor */0,
                _0: param.name,
                _1: may_map(tree_of_modtype, ty_arg),
                _2: res
              };
    case /* Mty_alias */3 :
        return {
                TAG: /* Omty_alias */3,
                _0: tree_of_path(p._0)
              };
    
  }
}

function tree_of_signature(sg) {
  const partial_arg = printing_env.contents;
  return wrap_env((function (env) {
                return env;
              }), (function (param) {
                return tree_of_signature_rec(partial_arg, false, param);
              }), sg);
}

function tree_of_signature_rec(env$p, in_type_group, param) {
  if (!param) {
    return /* [] */0;
  }
  const item = param.hd;
  let in_type_group$1;
  let exit = 0;
  if (in_type_group) {
    if (item.TAG === /* Sig_type */1) {
      if (item._2 >= 2) {
        in_type_group$1 = true;
      } else {
        exit = 1;
      }
    } else {
      set_printing_env(env$p);
      in_type_group$1 = false;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    set_printing_env(env$p);
    in_type_group$1 = item.TAG === /* Sig_type */1 && item._2 < 2 ? true : false;
  }
  const match = filter_rem_sig(item, param.tl);
  const rem = match[1];
  let trees;
  switch (item.TAG | 0) {
    case /* Sig_value */0 :
        trees = {
          hd: tree_of_value_description(item._0, item._1),
          tl: /* [] */0
        };
        break;
    case /* Sig_type */1 :
        const id = item._0;
        if (is_row_name(id.name)) {
          trees = /* [] */0;
        } else {
          hide_rec_items({
                hd: item,
                tl: rem
              });
          trees = {
            hd: {
              TAG: /* Osig_type */5,
              _0: tree_of_type_decl(id, item._1),
              _1: item._2
            },
            tl: /* [] */0
          };
        }
        break;
    case /* Sig_typext */2 :
        trees = {
          hd: tree_of_extension_constructor(item._0, item._1, item._2),
          tl: /* [] */0
        };
        break;
    case /* Sig_module */3 :
        trees = {
          hd: {
            TAG: /* Osig_module */4,
            _0: item._0.name,
            _1: tree_of_modtype(item._1.md_type),
            _2: item._2
          },
          tl: /* [] */0
        };
        break;
    case /* Sig_modtype */4 :
        trees = {
          hd: tree_of_modtype_declaration(item._0, item._1),
          tl: /* [] */0
        };
        break;
    case /* Sig_class */5 :
        trees = {
          hd: tree_of_class_declaration(item._0, item._1, item._2),
          tl: /* [] */0
        };
        break;
    case /* Sig_class_type */6 :
        trees = {
          hd: tree_of_cltype_declaration(item._0, item._1, item._2),
          tl: /* [] */0
        };
        break;
    
  }
  const env$p$1 = add_signature({
        hd: item,
        tl: match[0]
      }, env$p);
  return Stdlib.$at(trees, tree_of_signature_rec(env$p$1, in_type_group$1, rem));
}

function tree_of_modtype_declaration(id, decl) {
  const mty = decl.mtd_type;
  const mty$1 = mty !== undefined ? tree_of_modtype(mty) : /* Omty_abstract */0;
  return {
          TAG: /* Osig_modtype */3,
          _0: id.name,
          _1: mty$1
        };
}

function modtype$1(ppf, mty) {
  Curry._2(out_module_type.contents, ppf, tree_of_modtype(mty));
}

function modtype_declaration$1(id, ppf, decl) {
  Curry._2(out_sig_item.contents, ppf, tree_of_modtype_declaration(id, decl));
}

function print_signature(ppf, tree) {
  Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
            _0: {
              TAG: /* Formatting_gen */18,
              _0: {
                TAG: /* Open_box */1,
                _0: /* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "<v>",
                    _1: /* End_of_format */0
                  },
                  _1: "<v>"
                }
              },
              _1: {
                TAG: /* Alpha */15,
                _0: {
                  TAG: /* Formatting_lit */17,
                  _0: /* Close_box */0,
                  _1: /* End_of_format */0
                }
              }
            },
            _1: "@[<v>%a@]"
          }), out_signature.contents, tree);
}

function signature$3(ppf, sg) {
  Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
            _0: {
              TAG: /* Alpha */15,
              _0: /* End_of_format */0
            },
            _1: "%a"
          }), print_signature, tree_of_signature(sg));
}

function same_path(t, t$p) {
  const t$1 = repr(t);
  const t$p$1 = repr(t$p);
  if (t$1 === t$p$1) {
    return true;
  }
  const match = t$1.desc;
  const match$1 = t$p$1.desc;
  if (typeof match === "number") {
    return false;
  }
  if (match.TAG !== /* Tconstr */3) {
    return false;
  }
  if (typeof match$1 === "number") {
    return false;
  }
  if (match$1.TAG !== /* Tconstr */3) {
    return false;
  }
  const match$2 = best_type_path(match._0);
  const s1 = match$2[1];
  const match$3 = best_type_path(match$1._0);
  const s2 = match$3[1];
  let exit = 0;
  if (typeof s1 === "number") {
    exit = 1;
  } else {
    if (s1.TAG === /* Nth */0) {
      if (typeof s2 === "number" || s2.TAG !== /* Nth */0) {
        return false;
      } else {
        return s1._0 === s2._0;
      }
    }
    exit = 1;
  }
  if (exit === 1) {
    let exit$1 = 0;
    if (typeof s2 === "number") {
      exit$1 = 2;
    } else {
      if (s2.TAG === /* Nth */0) {
        return false;
      }
      exit$1 = 2;
    }
    if (exit$1 === 2) {
      if (!same(match$2[0], match$3[0])) {
        return false;
      }
      const tl = apply_subst(s1, match._1);
      const tl$p = apply_subst(s2, match$1._1);
      if (Stdlib__List.length(tl) === Stdlib__List.length(tl$p)) {
        return Stdlib__List.for_all2(same_type, tl, tl$p);
      } else {
        return false;
      }
    }
    
  }
  
}

function type_expansion(t, ppf, t$p) {
  if (same_path(t, t$p)) {
    return type_expr$1(ppf, t);
  }
  const t$p$1 = proxy(t) === proxy(t$p) ? unalias(t$p) : t$p;
  Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
            _0: {
              TAG: /* Formatting_gen */18,
              _0: {
                TAG: /* Open_box */1,
                _0: /* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "<2>",
                    _1: /* End_of_format */0
                  },
                  _1: "<2>"
                }
              },
              _1: {
                TAG: /* Alpha */15,
                _0: {
                  TAG: /* Formatting_lit */17,
                  _0: {
                    TAG: /* Break */0,
                    _0: "@ ",
                    _1: 1,
                    _2: 0
                  },
                  _1: {
                    TAG: /* Char_literal */12,
                    _0: /* '=' */61,
                    _1: {
                      TAG: /* Formatting_lit */17,
                      _0: {
                        TAG: /* Break */0,
                        _0: "@ ",
                        _1: 1,
                        _2: 0
                      },
                      _1: {
                        TAG: /* Alpha */15,
                        _0: {
                          TAG: /* Formatting_lit */17,
                          _0: /* Close_box */0,
                          _1: /* End_of_format */0
                        }
                      }
                    }
                  }
                }
              }
            },
            _1: "@[<2>%a@ =@ %a@]"
          }), type_expr$1, t, type_expr$1, t$p$1);
}

function type_path_expansion(tp, ppf, tp$p) {
  if (same(tp, tp$p)) {
    return path(ppf, tp);
  } else {
    return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                    _0: {
                      TAG: /* Formatting_gen */18,
                      _0: {
                        TAG: /* Open_box */1,
                        _0: /* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "<2>",
                            _1: /* End_of_format */0
                          },
                          _1: "<2>"
                        }
                      },
                      _1: {
                        TAG: /* Alpha */15,
                        _0: {
                          TAG: /* Formatting_lit */17,
                          _0: {
                            TAG: /* Break */0,
                            _0: "@ ",
                            _1: 1,
                            _2: 0
                          },
                          _1: {
                            TAG: /* Char_literal */12,
                            _0: /* '=' */61,
                            _1: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@ ",
                                _1: 1,
                                _2: 0
                              },
                              _1: {
                                TAG: /* Alpha */15,
                                _0: {
                                  TAG: /* Formatting_lit */17,
                                  _0: /* Close_box */0,
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    _1: "@[<2>%a@ =@ %a@]"
                  }), path, tp, path, tp$p);
  }
}

function trace(fst, txt, ppf, param) {
  if (!param) {
    return ;
  }
  const match = param.tl;
  if (!match) {
    return ;
  }
  const match$1 = match.hd;
  const t2 = match$1[0];
  const match$2 = param.hd;
  const t1 = match$2[0];
  if (!fst) {
    Stdlib__Format.fprintf(ppf)(/* Format */{
          _0: {
            TAG: /* Formatting_lit */17,
            _0: {
              TAG: /* Break */0,
              _0: "@,",
              _1: 0,
              _2: 0
            },
            _1: /* End_of_format */0
          },
          _1: "@,"
        });
  }
  Curry._7(Stdlib__Format.fprintf(ppf)(/* Format */{
            _0: {
              TAG: /* Formatting_gen */18,
              _0: {
                TAG: /* Open_box */1,
                _0: /* Format */{
                  _0: /* End_of_format */0,
                  _1: ""
                }
              },
              _1: {
                TAG: /* String_literal */11,
                _0: "Type",
                _1: {
                  TAG: /* Formatting_lit */17,
                  _0: {
                    TAG: /* Break */0,
                    _0: "@;<1 2>",
                    _1: 1,
                    _2: 2
                  },
                  _1: {
                    TAG: /* Alpha */15,
                    _0: {
                      TAG: /* Formatting_lit */17,
                      _0: {
                        TAG: /* Break */0,
                        _0: "@ ",
                        _1: 1,
                        _2: 0
                      },
                      _1: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* Formatting_lit */17,
                          _0: {
                            TAG: /* Break */0,
                            _0: "@;<1 2>",
                            _1: 1,
                            _2: 2
                          },
                          _1: {
                            TAG: /* Alpha */15,
                            _0: {
                              TAG: /* Formatting_lit */17,
                              _0: /* Close_box */0,
                              _1: {
                                TAG: /* Char_literal */12,
                                _0: /* ' ' */32,
                                _1: {
                                  TAG: /* Alpha */15,
                                  _0: /* End_of_format */0
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
            _1: "@[Type@;<1 2>%a@ %s@;<1 2>%a@] %a"
          }), (function (param, param$1) {
          return type_expansion(t1, param, param$1);
        }), match$2[1], txt, (function (param, param$1) {
          return type_expansion(t2, param, param$1);
        }), match$1[1], (function (param, param$1) {
          return trace(false, txt, param, param$1);
        }), match.tl);
}

function filter_trace(keep_last, param) {
  if (!param) {
    return /* [] */0;
  }
  const match = param.tl;
  if (!match) {
    return /* [] */0;
  }
  const match$1 = match.hd;
  const t2 = match$1[0];
  const match$2 = param.hd;
  const t1$p = match$2[1];
  const t1 = match$2[0];
  if (!match.tl && (is_Tvar(t1$p) || is_Tvar(match$1[1]))) {
    return /* [] */0;
  }
  const t2$p = match$1[1];
  const rem$p = filter_trace(keep_last, match.tl);
  if (is_constr_row(t1$p) || is_constr_row(t2$p) || same_path(t1, t1$p) && same_path(t2, t2$p) && !(keep_last && Caml_obj.caml_equal(rem$p, /* [] */0))) {
    return rem$p;
  } else {
    return {
            hd: [
              t1,
              t1$p
            ],
            tl: {
              hd: [
                t2,
                t2$p
              ],
              tl: rem$p
            }
          };
  }
}

function type_path_list(ppf, param) {
  if (!param) {
    return ;
  }
  const match = param.hd;
  const tp = match[0];
  if (param.tl) {
    return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                    _0: {
                      TAG: /* Alpha */15,
                      _0: {
                        TAG: /* Formatting_lit */17,
                        _0: {
                          TAG: /* Break */0,
                          _0: "@;<2 0>",
                          _1: 2,
                          _2: 0
                        },
                        _1: {
                          TAG: /* Alpha */15,
                          _0: /* End_of_format */0
                        }
                      }
                    },
                    _1: "%a@;<2 0>%a"
                  }), (function (param, param$1) {
                  return type_path_expansion(tp, param, param$1);
                }), match[1], type_path_list, param.tl);
  } else {
    return type_path_expansion(tp, ppf, match[1]);
  }
}

function hide_variant_name(t) {
  const t$1 = repr(t);
  const row = t$1.desc;
  if (typeof row === "number") {
    return t;
  }
  if (row.TAG !== /* Tvariant */8) {
    return t;
  }
  const row$1 = row._0;
  if (row_repr_aux(/* [] */0, row$1).row_name === undefined) {
    return t;
  }
  const init = row_repr_aux(/* [] */0, row$1);
  const level = row_more(row$1).level;
  return newty2(t$1.level, {
              TAG: /* Tvariant */8,
              _0: {
                row_fields: init.row_fields,
                row_more: newty2(level, {
                      TAG: /* Tvar */0,
                      _0: undefined
                    }),
                row_bound: init.row_bound,
                row_closed: init.row_closed,
                row_fixed: init.row_fixed,
                row_name: undefined
              }
            });
}

function prepare_expansion(param) {
  const t = param[0];
  const t$p = hide_variant_name(param[1]);
  mark_loops(t);
  if (!same_path(t, t$p)) {
    mark_loops(t$p);
  }
  return [
          t,
          t$p
        ];
}

function may_prepare_expansion(compact, param) {
  const t$p = param[1];
  const t = param[0];
  const match = repr(t$p).desc;
  if (typeof match === "number") {
    return prepare_expansion([
                t,
                t$p
              ]);
  }
  switch (match.TAG | 0) {
    case /* Tobject */4 :
    case /* Tvariant */8 :
        break;
    default:
      return prepare_expansion([
                  t,
                  t$p
                ]);
  }
  if (compact) {
    mark_loops(t);
    return [
            t,
            t
          ];
  } else {
    return prepare_expansion([
                t,
                t$p
              ]);
  }
}

function print_tags(ppf, fields) {
  if (fields) {
    Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
              _0: {
                TAG: /* Char_literal */12,
                _0: /* '`' */96,
                _1: {
                  TAG: /* String */2,
                  _0: /* No_padding */0,
                  _1: /* End_of_format */0
                }
              },
              _1: "`%s"
            }), fields.hd[0]);
    return Stdlib__List.iter((function (param) {
                  Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                            _0: {
                              TAG: /* Char_literal */12,
                              _0: /* ',' */44,
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@ ",
                                  _1: 1,
                                  _2: 0
                                },
                                _1: {
                                  TAG: /* Char_literal */12,
                                  _0: /* '`' */96,
                                  _1: {
                                    TAG: /* String */2,
                                    _0: /* No_padding */0,
                                    _1: /* End_of_format */0
                                  }
                                }
                              }
                            },
                            _1: ",@ `%s"
                          }), param[0]);
                }), fields.tl);
  }
  
}

function has_explanation(unif, t3, t4) {
  const match = t3.desc;
  const match$1 = t4.desc;
  let exit = 0;
  let exit$1 = 0;
  if (typeof match === "number") {
    if (typeof match$1 === "number") {
      exit = 2;
    } else {
      switch (match$1.TAG | 0) {
        case /* Tvar */0 :
            exit$1 = 3;
            break;
        case /* Tconstr */3 :
            return true;
        default:
          exit = 2;
      }
    }
  } else {
    switch (match.TAG | 0) {
      case /* Tvar */0 :
          return true;
      case /* Tconstr */3 :
          if (typeof match$1 === "number") {
            return true;
          }
          if (match$1.TAG === /* Tvar */0) {
            exit$1 = 3;
          } else {
            exit = 2;
          }
          break;
      case /* Tfield */5 :
          const match$2 = match._3.desc;
          let exit$2 = 0;
          if (typeof match$2 === "number" && typeof match$1 !== "number") {
            switch (match$1.TAG | 0) {
              case /* Tvar */0 :
                  exit$1 = 3;
                  break;
              case /* Tconstr */3 :
                  exit$2 = 4;
                  break;
              case /* Tfield */5 :
                  const match$3 = match$1._3.desc;
                  if (typeof match$3 === "number") {
                    return match._0 === match$1._0;
                  } else {
                    return false;
                  }
              default:
                return false;
            }
          } else {
            exit$2 = 4;
          }
          if (exit$2 === 4) {
            if (typeof match$1 === "number") {
              return true;
            }
            switch (match$1.TAG | 0) {
              case /* Tvar */0 :
                  exit$1 = 3;
                  break;
              case /* Tconstr */3 :
                  return true;
              default:
                return false;
            }
          }
          break;
      case /* Tvariant */8 :
          if (typeof match$1 === "number") {
            return false;
          }
          switch (match$1.TAG | 0) {
            case /* Tvar */0 :
                exit$1 = 3;
                break;
            case /* Tvariant */8 :
                return true;
            default:
              return false;
          }
          break;
      default:
        exit$1 = 3;
    }
  }
  if (exit$1 === 3) {
    if (typeof match$1 === "number") {
      exit = 2;
    } else {
      if (match$1.TAG === /* Tvar */0) {
        return true;
      }
      exit = 2;
    }
  }
  if (exit === 2 && typeof match !== "number" && match.TAG !== /* Tconstr */3) {
    return false;
  }
  if (typeof match$1 === "number" || match$1.TAG !== /* Tfield */5) {
    return false;
  } else {
    return true;
  }
}

function mismatch(unif, param) {
  if (!param) {
    return ;
  }
  const match = param.tl;
  if (match) {
    const t$p = match.hd[1];
    const t = param.hd[1];
    const m = mismatch(unif, match.tl);
    if (m !== undefined) {
      return m;
    } else if (has_explanation(unif, t, t$p)) {
      return [
              t,
              t$p
            ];
    } else {
      return ;
    }
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              36822,
              9
            ]
          });
}

function explanation(unif, mis, ppf) {
  if (mis !== undefined) {
    let t3 = mis[0];
    let t4 = mis[1];
    const match = t3.desc;
    const match$1 = t4.desc;
    let exit = 0;
    let exit$1 = 0;
    let lab;
    let exit$2 = 0;
    let exit$3 = 0;
    let exit$4 = 0;
    if (typeof match === "number") {
      if (typeof match$1 === "number") {
        return ;
      }
      switch (match$1.TAG | 0) {
        case /* Tvar */0 :
            exit$4 = 9;
            break;
        case /* Tconstr */3 :
            exit = 1;
            break;
        case /* Tfield */5 :
            exit$2 = 7;
            break;
        default:
          return ;
      }
    } else {
      switch (match.TAG | 0) {
        case /* Tvar */0 :
            if (typeof match$1 === "number") {
              exit$1 = 5;
            } else {
              switch (match$1.TAG | 0) {
                case /* Ttuple */2 :
                    exit$1 = match$1._0 ? 5 : 3;
                    break;
                case /* Tconstr */3 :
                    const p = match$1._0;
                    if (unif && t3.level < binding_time(p)) {
                      return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                                      _0: {
                                        TAG: /* Formatting_lit */17,
                                        _0: {
                                          TAG: /* Break */0,
                                          _0: "@,",
                                          _1: 0,
                                          _2: 0
                                        },
                                        _1: {
                                          TAG: /* Formatting_gen */18,
                                          _0: {
                                            TAG: /* Open_box */1,
                                            _0: /* Format */{
                                              _0: /* End_of_format */0,
                                              _1: ""
                                            }
                                          },
                                          _1: {
                                            TAG: /* String_literal */11,
                                            _0: "The type constructor",
                                            _1: {
                                              TAG: /* Formatting_lit */17,
                                              _0: {
                                                TAG: /* Break */0,
                                                _0: "@;<1 2>",
                                                _1: 1,
                                                _2: 2
                                              },
                                              _1: {
                                                TAG: /* Alpha */15,
                                                _0: {
                                                  TAG: /* Formatting_lit */17,
                                                  _0: {
                                                    TAG: /* Break */0,
                                                    _0: "@ ",
                                                    _1: 1,
                                                    _2: 0
                                                  },
                                                  _1: {
                                                    TAG: /* String_literal */11,
                                                    _0: "would escape its scope",
                                                    _1: {
                                                      TAG: /* Formatting_lit */17,
                                                      _0: /* Close_box */0,
                                                      _1: /* End_of_format */0
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      },
                                      _1: "@,@[The type constructor@;<1 2>%a@ would escape its scope@]"
                                    }), path, p);
                    }
                    exit$1 = 5;
                    break;
                case /* Tunivar */9 :
                    exit$1 = 4;
                    break;
                default:
                  exit$1 = 5;
              }
            }
            break;
        case /* Ttuple */2 :
            if (match._0) {
              exit$4 = 9;
            } else {
              if (typeof match$1 === "number") {
                return ;
              }
              switch (match$1.TAG | 0) {
                case /* Tvar */0 :
                    exit$1 = 3;
                    break;
                case /* Tfield */5 :
                    exit$2 = 7;
                    break;
                default:
                  return ;
              }
            }
            break;
        case /* Tconstr */3 :
            const p$1 = match._0;
            if (typeof match$1 === "number") {
              exit = 1;
            } else {
              switch (match$1.TAG | 0) {
                case /* Tvar */0 :
                    if (unif && t4.level < binding_time(p$1)) {
                      return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                                      _0: {
                                        TAG: /* Formatting_lit */17,
                                        _0: {
                                          TAG: /* Break */0,
                                          _0: "@,",
                                          _1: 0,
                                          _2: 0
                                        },
                                        _1: {
                                          TAG: /* Formatting_gen */18,
                                          _0: {
                                            TAG: /* Open_box */1,
                                            _0: /* Format */{
                                              _0: /* End_of_format */0,
                                              _1: ""
                                            }
                                          },
                                          _1: {
                                            TAG: /* String_literal */11,
                                            _0: "The type constructor",
                                            _1: {
                                              TAG: /* Formatting_lit */17,
                                              _0: {
                                                TAG: /* Break */0,
                                                _0: "@;<1 2>",
                                                _1: 1,
                                                _2: 2
                                              },
                                              _1: {
                                                TAG: /* Alpha */15,
                                                _0: {
                                                  TAG: /* Formatting_lit */17,
                                                  _0: {
                                                    TAG: /* Break */0,
                                                    _0: "@ ",
                                                    _1: 1,
                                                    _2: 0
                                                  },
                                                  _1: {
                                                    TAG: /* String_literal */11,
                                                    _0: "would escape its scope",
                                                    _1: {
                                                      TAG: /* Formatting_lit */17,
                                                      _0: /* Close_box */0,
                                                      _1: /* End_of_format */0
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      },
                                      _1: "@,@[The type constructor@;<1 2>%a@ would escape its scope@]"
                                    }), path, p$1);
                    }
                    exit$4 = 9;
                    break;
                case /* Tfield */5 :
                    exit$2 = 7;
                    break;
                default:
                  return ;
              }
            }
            break;
        case /* Tvariant */8 :
            if (typeof match$1 === "number") {
              return ;
            }
            switch (match$1.TAG | 0) {
              case /* Tvar */0 :
                  exit$4 = 9;
                  break;
              case /* Tfield */5 :
                  exit$2 = 7;
                  break;
              case /* Tvariant */8 :
                  const row1 = row_repr_aux(/* [] */0, match._0);
                  const row2 = row_repr_aux(/* [] */0, match$1._0);
                  const match$2 = row1.row_fields;
                  const match$3 = row1.row_closed;
                  const match$4 = row2.row_fields;
                  const match$5 = row2.row_closed;
                  let exit$5 = 0;
                  if (match$2) {
                    if (match$2.tl || !match$3) {
                      exit$5 = 10;
                    } else {
                      if (match$4) {
                        if (match$4.tl) {
                          return ;
                        }
                        if (!match$5) {
                          return ;
                        }
                        const l1 = match$2.hd[0];
                        if (l1 === match$4.hd[0]) {
                          return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                                          _0: {
                                            TAG: /* Formatting_lit */17,
                                            _0: {
                                              TAG: /* Break */0,
                                              _0: "@,",
                                              _1: 0,
                                              _2: 0
                                            },
                                            _1: {
                                              TAG: /* String_literal */11,
                                              _0: "Types for tag `",
                                              _1: {
                                                TAG: /* String */2,
                                                _0: /* No_padding */0,
                                                _1: {
                                                  TAG: /* String_literal */11,
                                                  _0: " are incompatible",
                                                  _1: /* End_of_format */0
                                                }
                                              }
                                            }
                                          },
                                          _1: "@,Types for tag `%s are incompatible"
                                        }), l1);
                        } else {
                          return ;
                        }
                      }
                      exit$5 = 10;
                    }
                  } else if (match$3) {
                    let exit$6 = 0;
                    if (match$4) {
                      exit$6 = 11;
                    } else {
                      if (match$5) {
                        return Stdlib__Format.fprintf(ppf)(/* Format */{
                                    _0: {
                                      TAG: /* Formatting_lit */17,
                                      _0: {
                                        TAG: /* Break */0,
                                        _0: "@,",
                                        _1: 0,
                                        _2: 0
                                      },
                                      _1: {
                                        TAG: /* String_literal */11,
                                        _0: "These two variant types have no intersection",
                                        _1: /* End_of_format */0
                                      }
                                    },
                                    _1: "@,These two variant types have no intersection"
                                  });
                      }
                      exit$6 = 11;
                    }
                    if (exit$6 === 11) {
                      return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                                      _0: {
                                        TAG: /* Formatting_lit */17,
                                        _0: {
                                          TAG: /* Break */0,
                                          _0: "@,",
                                          _1: 0,
                                          _2: 0
                                        },
                                        _1: {
                                          TAG: /* Formatting_gen */18,
                                          _0: {
                                            TAG: /* Open_box */1,
                                            _0: /* Format */{
                                              _0: /* End_of_format */0,
                                              _1: ""
                                            }
                                          },
                                          _1: {
                                            TAG: /* String_literal */11,
                                            _0: "The first variant type does not allow tag(s)",
                                            _1: {
                                              TAG: /* Formatting_lit */17,
                                              _0: {
                                                TAG: /* Break */0,
                                                _0: "@ ",
                                                _1: 1,
                                                _2: 0
                                              },
                                              _1: {
                                                TAG: /* Formatting_gen */18,
                                                _0: {
                                                  TAG: /* Open_box */1,
                                                  _0: /* Format */{
                                                    _0: {
                                                      TAG: /* String_literal */11,
                                                      _0: "<hov>",
                                                      _1: /* End_of_format */0
                                                    },
                                                    _1: "<hov>"
                                                  }
                                                },
                                                _1: {
                                                  TAG: /* Alpha */15,
                                                  _0: {
                                                    TAG: /* Formatting_lit */17,
                                                    _0: /* Close_box */0,
                                                    _1: {
                                                      TAG: /* Formatting_lit */17,
                                                      _0: /* Close_box */0,
                                                      _1: /* End_of_format */0
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      },
                                      _1: "@,@[The first variant type does not allow tag(s)@ @[<hov>%a@]@]"
                                    }), print_tags, match$4);
                    }
                    
                  } else {
                    exit$5 = 10;
                  }
                  if (exit$5 === 10) {
                    if (match$4 || !match$5) {
                      return ;
                    } else {
                      return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                                      _0: {
                                        TAG: /* Formatting_lit */17,
                                        _0: {
                                          TAG: /* Break */0,
                                          _0: "@,",
                                          _1: 0,
                                          _2: 0
                                        },
                                        _1: {
                                          TAG: /* Formatting_gen */18,
                                          _0: {
                                            TAG: /* Open_box */1,
                                            _0: /* Format */{
                                              _0: /* End_of_format */0,
                                              _1: ""
                                            }
                                          },
                                          _1: {
                                            TAG: /* String_literal */11,
                                            _0: "The second variant type does not allow tag(s)",
                                            _1: {
                                              TAG: /* Formatting_lit */17,
                                              _0: {
                                                TAG: /* Break */0,
                                                _0: "@ ",
                                                _1: 1,
                                                _2: 0
                                              },
                                              _1: {
                                                TAG: /* Formatting_gen */18,
                                                _0: {
                                                  TAG: /* Open_box */1,
                                                  _0: /* Format */{
                                                    _0: {
                                                      TAG: /* String_literal */11,
                                                      _0: "<hov>",
                                                      _1: /* End_of_format */0
                                                    },
                                                    _1: "<hov>"
                                                  }
                                                },
                                                _1: {
                                                  TAG: /* Alpha */15,
                                                  _0: {
                                                    TAG: /* Formatting_lit */17,
                                                    _0: /* Close_box */0,
                                                    _1: {
                                                      TAG: /* Formatting_lit */17,
                                                      _0: /* Close_box */0,
                                                      _1: /* End_of_format */0
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      },
                                      _1: "@,@[The second variant type does not allow tag(s)@ @[<hov>%a@]@]"
                                    }), print_tags, match$2);
                    }
                  }
                  break;
              default:
                return ;
            }
            break;
        case /* Tunivar */9 :
            if (typeof match$1 === "number") {
              return ;
            }
            switch (match$1.TAG | 0) {
              case /* Tvar */0 :
                  exit$1 = 4;
                  break;
              case /* Tfield */5 :
                  exit$2 = 7;
                  break;
              default:
                return ;
            }
            break;
        default:
          exit$4 = 9;
      }
    }
    if (exit$4 === 9) {
      if (typeof match$1 === "number" || match$1.TAG !== /* Tvar */0) {
        exit$3 = 8;
      } else {
        exit$1 = 5;
      }
    }
    if (exit$3 === 8) {
      if (typeof match === "number" || match.TAG !== /* Tfield */5) {
        exit$2 = 7;
      } else {
        lab = match._0;
        exit$1 = 6;
      }
    }
    if (exit$2 === 7) {
      if (typeof match$1 === "number") {
        exit = 2;
      } else {
        switch (match$1.TAG | 0) {
          case /* Tconstr */3 :
              exit = 2;
              break;
          case /* Tfield */5 :
              lab = match$1._0;
              exit$1 = 6;
              break;
          default:
            return ;
        }
      }
    }
    switch (exit$1) {
      case 3 :
          return Stdlib__Format.fprintf(ppf)(/* Format */{
                      _0: {
                        TAG: /* Formatting_lit */17,
                        _0: {
                          TAG: /* Break */0,
                          _0: "@,",
                          _1: 0,
                          _2: 0
                        },
                        _1: {
                          TAG: /* String_literal */11,
                          _0: "Self type cannot escape its class",
                          _1: /* End_of_format */0
                        }
                      },
                      _1: "@,Self type cannot escape its class"
                    });
      case 4 :
          return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* Formatting_lit */17,
                            _0: {
                              TAG: /* Break */0,
                              _0: "@,",
                              _1: 0,
                              _2: 0
                            },
                            _1: {
                              TAG: /* String_literal */11,
                              _0: "The universal variable ",
                              _1: {
                                TAG: /* Alpha */15,
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: " would escape its scope",
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          },
                          _1: "@,The universal variable %a would escape its scope"
                        }), type_expr$1, is_Tunivar(t3) ? t3 : t4);
      case 5 :
          const match$6 = is_Tvar(t3) ? [
              t3,
              t4
            ] : [
              t4,
              t3
            ];
          const t$p = match$6[1];
          const t = match$6[0];
          if (occur_in(empty, t, t$p)) {
            return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                            _0: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@,",
                                _1: 0,
                                _2: 0
                              },
                              _1: {
                                TAG: /* Formatting_gen */18,
                                _0: {
                                  TAG: /* Open_box */1,
                                  _0: /* Format */{
                                    _0: {
                                      TAG: /* String_literal */11,
                                      _0: "<hov>",
                                      _1: /* End_of_format */0
                                    },
                                    _1: "<hov>"
                                  }
                                },
                                _1: {
                                  TAG: /* String_literal */11,
                                  _0: "The type variable ",
                                  _1: {
                                    TAG: /* Alpha */15,
                                    _0: {
                                      TAG: /* String_literal */11,
                                      _0: " occurs inside",
                                      _1: {
                                        TAG: /* Formatting_lit */17,
                                        _0: {
                                          TAG: /* Break */0,
                                          _0: "@ ",
                                          _1: 1,
                                          _2: 0
                                        },
                                        _1: {
                                          TAG: /* Alpha */15,
                                          _0: {
                                            TAG: /* Formatting_lit */17,
                                            _0: /* Close_box */0,
                                            _1: /* End_of_format */0
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            },
                            _1: "@,@[<hov>The type variable %a occurs inside@ %a@]"
                          }), type_expr$1, t, type_expr$1, t$p);
          } else {
            return Curry._3(Stdlib__Format.fprintf(ppf)(/* Format */{
                            _0: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@,",
                                _1: 0,
                                _2: 0
                              },
                              _1: {
                                TAG: /* Formatting_gen */18,
                                _0: {
                                  TAG: /* Open_box */1,
                                  _0: /* Format */{
                                    _0: {
                                      TAG: /* String_literal */11,
                                      _0: "<hov>",
                                      _1: /* End_of_format */0
                                    },
                                    _1: "<hov>"
                                  }
                                },
                                _1: {
                                  TAG: /* String_literal */11,
                                  _0: "This instance of ",
                                  _1: {
                                    TAG: /* Alpha */15,
                                    _0: {
                                      TAG: /* String_literal */11,
                                      _0: " is ambiguous:",
                                      _1: {
                                        TAG: /* Formatting_lit */17,
                                        _0: {
                                          TAG: /* Break */0,
                                          _0: "@ ",
                                          _1: 1,
                                          _2: 0
                                        },
                                        _1: {
                                          TAG: /* String */2,
                                          _0: /* No_padding */0,
                                          _1: {
                                            TAG: /* Formatting_lit */17,
                                            _0: /* Close_box */0,
                                            _1: /* End_of_format */0
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            },
                            _1: "@,@[<hov>This instance of %a is ambiguous:@ %s@]"
                          }), type_expr$1, t$p, "it would escape the scope of its equation");
          }
      case 6 :
          if (lab === dummy_method) {
            return Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_lit */17,
                          _0: {
                            TAG: /* Break */0,
                            _0: "@,",
                            _1: 0,
                            _2: 0
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "Self type cannot be unified with a closed object type",
                            _1: /* End_of_format */0
                          }
                        },
                        _1: "@,Self type cannot be unified with a closed object type"
                      });
          }
          exit = 2;
          break;
      
    }
    switch (exit) {
      case 1 :
          return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* Formatting_lit */17,
                            _0: {
                              TAG: /* Break */0,
                              _0: "@,",
                              _1: 0,
                              _2: 0
                            },
                            _1: {
                              TAG: /* Formatting_gen */18,
                              _0: {
                                TAG: /* Open_box */1,
                                _0: /* Format */{
                                  _0: /* End_of_format */0,
                                  _1: ""
                                }
                              },
                              _1: {
                                TAG: /* String_literal */11,
                                _0: "The ",
                                _1: {
                                  TAG: /* String */2,
                                  _0: /* No_padding */0,
                                  _1: {
                                    TAG: /* String_literal */11,
                                    _0: " object type has an abstract row, it cannot be closed",
                                    _1: {
                                      TAG: /* Formatting_lit */17,
                                      _0: /* Close_box */0,
                                      _1: /* End_of_format */0
                                    }
                                  }
                                }
                              }
                            }
                          },
                          _1: "@,@[The %s object type has an abstract row, it cannot be closed@]"
                        }), Caml_obj.caml_equal(t4.desc, /* Tnil */0) ? "first" : "second");
      case 2 :
          let exit$7 = 0;
          if (typeof match === "number") {
            exit$7 = 3;
          } else {
            switch (match.TAG | 0) {
              case /* Tconstr */3 :
                  exit$7 = 3;
                  break;
              case /* Tfield */5 :
                  const l = match._0;
                  const match$7 = match._3.desc;
                  let exit$8 = 0;
                  if (typeof match$7 === "number" && typeof match$1 !== "number") {
                    switch (match$1.TAG | 0) {
                      case /* Tconstr */3 :
                          exit$8 = 4;
                          break;
                      case /* Tfield */5 :
                          const match$8 = match$1._3.desc;
                          if (typeof match$8 === "number" && l === match$1._0) {
                            return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                                            _0: {
                                              TAG: /* Formatting_lit */17,
                                              _0: {
                                                TAG: /* Break */0,
                                                _0: "@,",
                                                _1: 0,
                                                _2: 0
                                              },
                                              _1: {
                                                TAG: /* String_literal */11,
                                                _0: "Types for method ",
                                                _1: {
                                                  TAG: /* String */2,
                                                  _0: /* No_padding */0,
                                                  _1: {
                                                    TAG: /* String_literal */11,
                                                    _0: " are incompatible",
                                                    _1: /* End_of_format */0
                                                  }
                                                }
                                              }
                                            },
                                            _1: "@,Types for method %s are incompatible"
                                          }), l);
                          } else {
                            return ;
                          }
                      default:
                        return ;
                    }
                  } else {
                    exit$8 = 4;
                  }
                  if (exit$8 === 4) {
                    let exit$9 = 0;
                    if (typeof match$1 === "number") {
                      exit$9 = 5;
                    } else {
                      if (match$1.TAG !== /* Tconstr */3) {
                        return ;
                      }
                      exit$9 = 5;
                    }
                    if (exit$9 === 5) {
                      return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                                      _0: {
                                        TAG: /* Formatting_lit */17,
                                        _0: {
                                          TAG: /* Break */0,
                                          _0: "@,",
                                          _1: 0,
                                          _2: 0
                                        },
                                        _1: {
                                          TAG: /* Formatting_gen */18,
                                          _0: {
                                            TAG: /* Open_box */1,
                                            _0: /* Format */{
                                              _0: /* End_of_format */0,
                                              _1: ""
                                            }
                                          },
                                          _1: {
                                            TAG: /* String_literal */11,
                                            _0: "The second object type has no method ",
                                            _1: {
                                              TAG: /* String */2,
                                              _0: /* No_padding */0,
                                              _1: {
                                                TAG: /* Formatting_lit */17,
                                                _0: /* Close_box */0,
                                                _1: /* End_of_format */0
                                              }
                                            }
                                          }
                                        }
                                      },
                                      _1: "@,@[The second object type has no method %s@]"
                                    }), l);
                    }
                    
                  }
                  break;
              default:
                return ;
            }
          }
          if (exit$7 === 3) {
            return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                            _0: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@,",
                                _1: 0,
                                _2: 0
                              },
                              _1: {
                                TAG: /* Formatting_gen */18,
                                _0: {
                                  TAG: /* Open_box */1,
                                  _0: /* Format */{
                                    _0: /* End_of_format */0,
                                    _1: ""
                                  }
                                },
                                _1: {
                                  TAG: /* String_literal */11,
                                  _0: "The first object type has no method ",
                                  _1: {
                                    TAG: /* String */2,
                                    _0: /* No_padding */0,
                                    _1: {
                                      TAG: /* Formatting_lit */17,
                                      _0: /* Close_box */0,
                                      _1: /* End_of_format */0
                                    }
                                  }
                                }
                              }
                            },
                            _1: "@,@[The first object type has no method %s@]"
                          }), match$1._0);
          }
          break;
      
    }
  }
  
}

function path_same_name(_p1, _p2) {
  while(true) {
    const p2 = _p2;
    const p1 = _p1;
    switch (p1.TAG | 0) {
      case /* Pident */0 :
          switch (p2.TAG | 0) {
            case /* Pident */0 :
                let id1 = p1._0;
                let id2 = p2._0;
                if (equal(id1, id2) && !Caml_obj.caml_equal(id1, id2)) {
                  add_unique(id1);
                  return add_unique(id2);
                } else {
                  return ;
                }
            case /* Pdot */1 :
            case /* Papply */2 :
                return ;
            
          }
      case /* Pdot */1 :
          switch (p2.TAG | 0) {
            case /* Pdot */1 :
                if (p1._1 !== p2._1) {
                  return ;
                }
                _p2 = p2._0;
                _p1 = p1._0;
                continue ;
            case /* Pident */0 :
            case /* Papply */2 :
                return ;
            
          }
      case /* Papply */2 :
          switch (p2.TAG | 0) {
            case /* Pident */0 :
            case /* Pdot */1 :
                return ;
            case /* Papply */2 :
                path_same_name(p1._0, p2._0);
                _p2 = p2._1;
                _p1 = p1._1;
                continue ;
            
          }
      
    }
  };
}

function type_same_name(t1, t2) {
  const match = repr(t1).desc;
  const match$1 = repr(t2).desc;
  if (typeof match === "number" || !(match.TAG === /* Tconstr */3 && !(typeof match$1 === "number" || match$1.TAG !== /* Tconstr */3))) {
    return ;
  } else {
    return path_same_name(best_type_path(match._0)[0], best_type_path(match$1._0)[0]);
  }
}

function trace_same_names(_param) {
  while(true) {
    const param = _param;
    if (!param) {
      return ;
    }
    const match = param.tl;
    if (!match) {
      return ;
    }
    const match$1 = match.hd;
    const match$2 = param.hd;
    type_same_name(match$2[0], match$1[0]);
    type_same_name(match$2[1], match$1[1]);
    _param = match.tl;
    continue ;
  };
}

function report_unification_error(ppf, env, unifOpt, tr, txt1, txt2) {
  const unif = unifOpt !== undefined ? unifOpt : true;
  wrap_printing_env(env, (function (param) {
          reset(undefined);
          trace_same_names(tr);
          const tr$1 = Stdlib__List.map((function (param) {
                  return [
                          param[0],
                          hide_variant_name(param[1])
                        ];
                }), tr);
          const mis = mismatch(unif, tr$1);
          if (tr$1) {
            const match = tr$1.tl;
            if (match) {
              try {
                const tr$2 = filter_trace(mis === undefined, match.tl);
                const match$1 = may_prepare_expansion(Caml_obj.caml_equal(tr$2, /* [] */0), tr$1.hd);
                const t1 = match$1[0];
                const match$2 = may_prepare_expansion(Caml_obj.caml_equal(tr$2, /* [] */0), match.hd);
                const t2 = match$2[0];
                print_labels.contents = !classic.contents;
                const tr$3 = Stdlib__List.map(prepare_expansion, tr$2);
                Curry.app(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* Formatting_gen */18,
                            _0: {
                              TAG: /* Open_box */1,
                              _0: /* Format */{
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: "<v>",
                                  _1: /* End_of_format */0
                                },
                                _1: "<v>"
                              }
                            },
                            _1: {
                              TAG: /* Formatting_gen */18,
                              _0: {
                                TAG: /* Open_box */1,
                                _0: /* Format */{
                                  _0: /* End_of_format */0,
                                  _1: ""
                                }
                              },
                              _1: {
                                TAG: /* Theta */16,
                                _0: {
                                  TAG: /* Formatting_lit */17,
                                  _0: {
                                    TAG: /* Break */0,
                                    _0: "@;<1 2>",
                                    _1: 1,
                                    _2: 2
                                  },
                                  _1: {
                                    TAG: /* Alpha */15,
                                    _0: {
                                      TAG: /* Formatting_lit */17,
                                      _0: {
                                        TAG: /* Break */0,
                                        _0: "@ ",
                                        _1: 1,
                                        _2: 0
                                      },
                                      _1: {
                                        TAG: /* Theta */16,
                                        _0: {
                                          TAG: /* Formatting_lit */17,
                                          _0: {
                                            TAG: /* Break */0,
                                            _0: "@;<1 2>",
                                            _1: 1,
                                            _2: 2
                                          },
                                          _1: {
                                            TAG: /* Alpha */15,
                                            _0: {
                                              TAG: /* Formatting_lit */17,
                                              _0: /* Close_box */0,
                                              _1: {
                                                TAG: /* Alpha */15,
                                                _0: {
                                                  TAG: /* Theta */16,
                                                  _0: {
                                                    TAG: /* Formatting_lit */17,
                                                    _0: /* Close_box */0,
                                                    _1: /* End_of_format */0
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          },
                          _1: "@[<v>@[%t@;<1 2>%a@ %t@;<1 2>%a@]%a%t@]"
                        }), [
                      txt1,
                      (function (param, param$1) {
                          return type_expansion(t1, param, param$1);
                        }),
                      match$1[1],
                      txt2,
                      (function (param, param$1) {
                          return type_expansion(t2, param, param$1);
                        }),
                      match$2[1],
                      (function (param, param$1) {
                          return trace(false, "is not compatible with type", param, param$1);
                        }),
                      tr$3,
                      (function (param) {
                          return explanation(unif, mis, param);
                        })
                    ]);
                print_labels.contents = true;
                return ;
              }
              catch (exn){
                print_labels.contents = true;
                throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
              }
            } else {
              throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                        MEL_EXN_ID: "Assert_failure",
                        _1: [
                          "jscomp/test/ocaml_typedtree_test.ml",
                          36921,
                          20
                        ]
                      });
            }
          } else {
            throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                      MEL_EXN_ID: "Assert_failure",
                      _1: [
                        "jscomp/test/ocaml_typedtree_test.ml",
                        36921,
                        20
                      ]
                    });
          }
        }));
}

function trace$1(fst, keep_last, txt, ppf, tr) {
  print_labels.contents = !classic.contents;
  trace_same_names(tr);
  try {
    if (!tr) {
      return ;
    }
    const match = tr.tl;
    if (match) {
      if (fst) {
        trace(fst, txt, ppf, {
              hd: tr.hd,
              tl: {
                hd: match.hd,
                tl: filter_trace(keep_last, match.tl)
              }
            });
      } else {
        trace(fst, txt, ppf, filter_trace(keep_last, tr));
      }
      print_labels.contents = true;
      return ;
    } else {
      return ;
    }
  }
  catch (exn){
    print_labels.contents = true;
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function class_types(env, cty1, cty2) {
  return match_class_types(undefined, env, cty1, cty2);
}

function class_type_declarations(env, cty1, cty2) {
  return match_class_declarations(env, cty1.clty_params, cty1.clty_type, cty2.clty_params, cty2.clty_type);
}

function class_declarations(env, cty1, cty2) {
  const match = cty1.cty_new;
  const match$1 = cty2.cty_new;
  if (match === undefined && match$1 !== undefined) {
    return {
            hd: /* CM_Virtual_class */0,
            tl: /* [] */0
          };
  }
  return match_class_declarations(env, cty1.cty_params, cty1.cty_type, cty2.cty_params, cty2.cty_type);
}

function include_err(ppf, lab) {
  if (typeof lab === "number") {
    return Stdlib__Format.fprintf(ppf)(/* Format */{
                _0: {
                  TAG: /* String_literal */11,
                  _0: "A class cannot be changed from virtual to concrete",
                  _1: /* End_of_format */0
                },
                _1: "A class cannot be changed from virtual to concrete"
              });
  }
  switch (lab.TAG | 0) {
    case /* CM_Parameter_arity_mismatch */0 :
        return Stdlib__Format.fprintf(ppf)(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "The classes do not have the same number of type parameters",
                      _1: /* End_of_format */0
                    },
                    _1: "The classes do not have the same number of type parameters"
                  });
    case /* CM_Type_parameter_mismatch */1 :
        return report_unification_error(ppf, lab._0, false, lab._1, (function (ppf) {
                      Stdlib__Format.fprintf(ppf)(/* Format */{
                            _0: {
                              TAG: /* String_literal */11,
                              _0: "A type parameter has type",
                              _1: /* End_of_format */0
                            },
                            _1: "A type parameter has type"
                          });
                    }), (function (ppf) {
                      Stdlib__Format.fprintf(ppf)(/* Format */{
                            _0: {
                              TAG: /* String_literal */11,
                              _0: "but is expected to have type",
                              _1: /* End_of_format */0
                            },
                            _1: "but is expected to have type"
                          });
                    }));
    case /* CM_Class_type_mismatch */2 :
        const cty2 = lab._2;
        const cty1 = lab._1;
        return wrap_printing_env(lab._0, (function (param) {
                      Curry._5(Stdlib__Format.fprintf(ppf)(/* Format */{
                                _0: {
                                  TAG: /* Formatting_gen */18,
                                  _0: {
                                    TAG: /* Open_box */1,
                                    _0: /* Format */{
                                      _0: /* End_of_format */0,
                                      _1: ""
                                    }
                                  },
                                  _1: {
                                    TAG: /* String_literal */11,
                                    _0: "The class type",
                                    _1: {
                                      TAG: /* Formatting_lit */17,
                                      _0: {
                                        TAG: /* Break */0,
                                        _0: "@;<1 2>",
                                        _1: 1,
                                        _2: 2
                                      },
                                      _1: {
                                        TAG: /* Alpha */15,
                                        _0: {
                                          TAG: /* Formatting_lit */17,
                                          _0: {
                                            TAG: /* Break */0,
                                            _0: "@ ",
                                            _1: 1,
                                            _2: 0
                                          },
                                          _1: {
                                            TAG: /* String */2,
                                            _0: /* No_padding */0,
                                            _1: {
                                              TAG: /* Formatting_lit */17,
                                              _0: {
                                                TAG: /* Break */0,
                                                _0: "@;<1 2>",
                                                _1: 1,
                                                _2: 2
                                              },
                                              _1: {
                                                TAG: /* Alpha */15,
                                                _0: {
                                                  TAG: /* Formatting_lit */17,
                                                  _0: /* Close_box */0,
                                                  _1: /* End_of_format */0
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                },
                                _1: "@[The class type@;<1 2>%a@ %s@;<1 2>%a@]"
                              }), class_type$2, cty1, "is not matched by the class type", class_type$2, cty2);
                    }));
    case /* CM_Parameter_mismatch */3 :
        return report_unification_error(ppf, lab._0, false, lab._1, (function (ppf) {
                      Stdlib__Format.fprintf(ppf)(/* Format */{
                            _0: {
                              TAG: /* String_literal */11,
                              _0: "A parameter has type",
                              _1: /* End_of_format */0
                            },
                            _1: "A parameter has type"
                          });
                    }), (function (ppf) {
                      Stdlib__Format.fprintf(ppf)(/* Format */{
                            _0: {
                              TAG: /* String_literal */11,
                              _0: "but is expected to have type",
                              _1: /* End_of_format */0
                            },
                            _1: "but is expected to have type"
                          });
                    }));
    case /* CM_Val_type_mismatch */4 :
        const lab$1 = lab._0;
        return report_unification_error(ppf, lab._1, false, lab._2, (function (ppf) {
                      Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: "The instance variable ",
                                  _1: {
                                    TAG: /* String */2,
                                    _0: /* No_padding */0,
                                    _1: {
                                      TAG: /* Formatting_lit */17,
                                      _0: {
                                        TAG: /* Break */0,
                                        _0: "@ ",
                                        _1: 1,
                                        _2: 0
                                      },
                                      _1: {
                                        TAG: /* String_literal */11,
                                        _0: "has type",
                                        _1: /* End_of_format */0
                                      }
                                    }
                                  }
                                },
                                _1: "The instance variable %s@ has type"
                              }), lab$1);
                    }), (function (ppf) {
                      Stdlib__Format.fprintf(ppf)(/* Format */{
                            _0: {
                              TAG: /* String_literal */11,
                              _0: "but is expected to have type",
                              _1: /* End_of_format */0
                            },
                            _1: "but is expected to have type"
                          });
                    }));
    case /* CM_Meth_type_mismatch */5 :
        const lab$2 = lab._0;
        return report_unification_error(ppf, lab._1, false, lab._2, (function (ppf) {
                      Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: "The method ",
                                  _1: {
                                    TAG: /* String */2,
                                    _0: /* No_padding */0,
                                    _1: {
                                      TAG: /* Formatting_lit */17,
                                      _0: {
                                        TAG: /* Break */0,
                                        _0: "@ ",
                                        _1: 1,
                                        _2: 0
                                      },
                                      _1: {
                                        TAG: /* String_literal */11,
                                        _0: "has type",
                                        _1: /* End_of_format */0
                                      }
                                    }
                                  }
                                },
                                _1: "The method %s@ has type"
                              }), lab$2);
                    }), (function (ppf) {
                      Stdlib__Format.fprintf(ppf)(/* Format */{
                            _0: {
                              TAG: /* String_literal */11,
                              _0: "but is expected to have type",
                              _1: /* End_of_format */0
                            },
                            _1: "but is expected to have type"
                          });
                    }));
    case /* CM_Non_mutable_value */6 :
        return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: /* End_of_format */0,
                              _1: ""
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "The non-mutable instance variable ",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* String_literal */11,
                                _0: " cannot become mutable",
                                _1: {
                                  TAG: /* Formatting_lit */17,
                                  _0: /* Close_box */0,
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          }
                        },
                        _1: "@[The non-mutable instance variable %s cannot become mutable@]"
                      }), lab._0);
    case /* CM_Non_concrete_value */7 :
        return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: /* End_of_format */0,
                              _1: ""
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "The virtual instance variable ",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* String_literal */11,
                                _0: " cannot become concrete",
                                _1: {
                                  TAG: /* Formatting_lit */17,
                                  _0: /* Close_box */0,
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          }
                        },
                        _1: "@[The virtual instance variable %s cannot become concrete@]"
                      }), lab._0);
    case /* CM_Missing_value */8 :
        return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: /* End_of_format */0,
                              _1: ""
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "The first class type has no instance variable ",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: /* Close_box */0,
                                _1: /* End_of_format */0
                              }
                            }
                          }
                        },
                        _1: "@[The first class type has no instance variable %s@]"
                      }), lab._0);
    case /* CM_Missing_method */9 :
        return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: /* End_of_format */0,
                              _1: ""
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "The first class type has no method ",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: /* Close_box */0,
                                _1: /* End_of_format */0
                              }
                            }
                          }
                        },
                        _1: "@[The first class type has no method %s@]"
                      }), lab._0);
    case /* CM_Hide_public */10 :
        return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: /* End_of_format */0,
                              _1: ""
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "The public method ",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* String_literal */11,
                                _0: " cannot be hidden",
                                _1: {
                                  TAG: /* Formatting_lit */17,
                                  _0: /* Close_box */0,
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          }
                        },
                        _1: "@[The public method %s cannot be hidden@]"
                      }), lab._0);
    case /* CM_Hide_virtual */11 :
        return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: /* End_of_format */0,
                              _1: ""
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "The virtual ",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Char_literal */12,
                                _0: /* ' ' */32,
                                _1: {
                                  TAG: /* String */2,
                                  _0: /* No_padding */0,
                                  _1: {
                                    TAG: /* String_literal */11,
                                    _0: " cannot be hidden",
                                    _1: {
                                      TAG: /* Formatting_lit */17,
                                      _0: /* Close_box */0,
                                      _1: /* End_of_format */0
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@[The virtual %s %s cannot be hidden@]"
                      }), lab._0, lab._1);
    case /* CM_Public_method */12 :
        return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: /* End_of_format */0,
                              _1: ""
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "The public method ",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* String_literal */11,
                                _0: " cannot become private",
                                _1: /* End_of_format */0
                              }
                            }
                          }
                        },
                        _1: "@[The public method %s cannot become private"
                      }), lab._0);
    case /* CM_Private_method */13 :
        return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "The private method ",
                          _1: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: {
                              TAG: /* String_literal */11,
                              _0: " cannot become public",
                              _1: /* End_of_format */0
                            }
                          }
                        },
                        _1: "The private method %s cannot become public"
                      }), lab._0);
    case /* CM_Virtual_method */14 :
        return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: /* End_of_format */0,
                              _1: ""
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "The virtual method ",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* String_literal */11,
                                _0: " cannot become concrete",
                                _1: /* End_of_format */0
                              }
                            }
                          }
                        },
                        _1: "@[The virtual method %s cannot become concrete"
                      }), lab._0);
    
  }
}

function report_error$3(ppf, param) {
  if (!param) {
    return ;
  }
  const print_errs = function (ppf, errs) {
    Stdlib__List.iter((function (err) {
            Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                      _0: {
                        TAG: /* Formatting_lit */17,
                        _0: {
                          TAG: /* Break */0,
                          _0: "@ ",
                          _1: 1,
                          _2: 0
                        },
                        _1: {
                          TAG: /* Alpha */15,
                          _0: /* End_of_format */0
                        }
                      },
                      _1: "@ %a"
                    }), include_err, err);
          }), errs);
  };
  Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
            _0: {
              TAG: /* Formatting_gen */18,
              _0: {
                TAG: /* Open_box */1,
                _0: /* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "<v>",
                    _1: /* End_of_format */0
                  },
                  _1: "<v>"
                }
              },
              _1: {
                TAG: /* Alpha */15,
                _0: {
                  TAG: /* Alpha */15,
                  _0: {
                    TAG: /* Formatting_lit */17,
                    _0: /* Close_box */0,
                    _1: /* End_of_format */0
                  }
                }
              }
            },
            _1: "@[<v>%a%a@]"
          }), include_err, param.hd, print_errs, param.tl);
}

const Dont_match = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Includecore.Dont_match");

function private_flags(decl1, decl2) {
  const match = decl1.type_private;
  const match$1 = decl2.type_private;
  if (match || !match$1) {
    return true;
  } else if (Caml_obj.caml_equal(decl2.type_kind, /* Type_abstract */0)) {
    if (decl2.type_manifest === undefined) {
      return true;
    } else {
      return Caml_obj.caml_notequal(decl1.type_kind, /* Type_abstract */0);
    }
  } else {
    return false;
  }
}

function is_absrow(env, ty) {
  const match = ty.desc;
  if (typeof match === "number") {
    return false;
  }
  if (match.TAG !== /* Tconstr */3) {
    return false;
  }
  switch (match._0.TAG | 0) {
    case /* Pident */0 :
        const match$1 = expand_head(env, ty);
        const match$2 = match$1.desc;
        if (typeof match$2 === "number") {
          return false;
        }
        switch (match$2.TAG | 0) {
          case /* Tobject */4 :
          case /* Tvariant */8 :
              return true;
          default:
            return false;
        }
    case /* Pdot */1 :
    case /* Papply */2 :
        return false;
    
  }
}

function type_manifest(env, ty1, params1, ty2, params2, priv2) {
  const ty1$p = expand_head(env, ty1);
  const ty2$p = expand_head(env, ty2);
  const match = ty1$p.desc;
  const match$1 = ty2$p.desc;
  if (typeof match !== "number") {
    switch (match.TAG | 0) {
      case /* Tobject */4 :
          if (typeof match$1 !== "number" && match$1.TAG === /* Tobject */4) {
            const fi2 = match$1._0;
            if (is_absrow(env, flatten_fields(fi2)[1])) {
              const match$2 = flatten_fields(fi2);
              if (!equal$5(env, true, {
                      hd: ty1,
                      tl: params1
                    }, {
                      hd: match$2[1],
                      tl: params2
                    })) {
                return false;
              }
              const match$3 = flatten_fields(match._0);
              const match$4 = match$3[1].desc;
              let tmp;
              if (typeof match$4 === "number") {
                tmp = true;
              } else {
                switch (match$4.TAG | 0) {
                  case /* Tvar */0 :
                  case /* Tconstr */3 :
                      tmp = true;
                      break;
                  default:
                    tmp = false;
                }
              }
              if (!tmp) {
                return false;
              }
              const match$5 = associate_fields(match$3[0], match$2[0]);
              if (!Caml_obj.caml_equal(match$5[2], /* [] */0)) {
                return false;
              }
              const match$6 = Stdlib__List.split(Stdlib__List.map((function (param) {
                          return [
                                  param[2],
                                  param[4]
                                ];
                        }), match$5[0]));
              return equal$5(env, true, Stdlib.$at(params1, match$6[0]), Stdlib.$at(params2, match$6[1]));
            }
            
          }
          break;
      case /* Tvariant */8 :
          if (typeof match$1 !== "number" && match$1.TAG === /* Tvariant */8) {
            const row2 = match$1._0;
            if (is_absrow(env, row_more(row2))) {
              const row1 = row_repr_aux(/* [] */0, match._0);
              const row2$1 = row_repr_aux(/* [] */0, row2);
              if (!equal$5(env, true, {
                      hd: ty1,
                      tl: params1
                    }, {
                      hd: row2$1.row_more,
                      tl: params2
                    })) {
                return false;
              }
              const match$7 = row1.row_more;
              const match$8 = match$7.desc;
              let tmp$1;
              if (typeof match$8 === "number") {
                tmp$1 = true;
              } else {
                switch (match$8.TAG | 0) {
                  case /* Tvar */0 :
                  case /* Tconstr */3 :
                      tmp$1 = true;
                      break;
                  default:
                    tmp$1 = false;
                }
              }
              if (!tmp$1) {
                return false;
              }
              const match$9 = merge_row_fields(row1.row_fields, row2$1.row_fields);
              if (!(!row2$1.row_closed || row1.row_closed && Caml_obj.caml_equal(filter_row_fields(false, match$9[0]), /* [] */0))) {
                return false;
              }
              if (!Stdlib__List.for_all((function (param) {
                        const match = row_field_repr_aux(/* [] */0, param[1]);
                        if (typeof match === "number" || match.TAG !== /* Rpresent */0) {
                          return true;
                        } else {
                          return false;
                        }
                      }), match$9[1])) {
                return false;
              }
              const to_equal = {
                contents: Stdlib__List.combine(params1, params2)
              };
              if (!Stdlib__List.for_all((function (param) {
                        const match = row_field_repr_aux(/* [] */0, param[1]);
                        const match$1 = row_field_repr_aux(/* [] */0, param[2]);
                        if (typeof match === "number") {
                          if (typeof match$1 === "number" || match$1.TAG !== /* Rpresent */0) {
                            return true;
                          } else {
                            return false;
                          }
                        }
                        if (match.TAG === /* Rpresent */0) {
                          const t1 = match._0;
                          if (t1 === undefined) {
                            if (typeof match$1 === "number") {
                              return false;
                            } else if (match$1.TAG === /* Rpresent */0) {
                              return match$1._0 === undefined;
                            } else if (match$1._0 && !match$1._1) {
                              return true;
                            } else {
                              return false;
                            }
                          }
                          let t2;
                          if (typeof match$1 === "number") {
                            return false;
                          }
                          if (match$1.TAG === /* Rpresent */0) {
                            const t2$1 = match$1._0;
                            if (t2$1 === undefined) {
                              return false;
                            }
                            t2 = t2$1;
                          } else {
                            if (match$1._0) {
                              return false;
                            }
                            const match$2 = match$1._1;
                            if (!match$2) {
                              return false;
                            }
                            if (match$2.tl) {
                              return false;
                            }
                            t2 = match$2.hd;
                          }
                          to_equal.contents = {
                            hd: [
                              t1,
                              t2
                            ],
                            tl: to_equal.contents
                          };
                          return true;
                        }
                        const tl1 = match._1;
                        if (typeof match$1 === "number") {
                          return false;
                        }
                        if (match$1.TAG === /* Rpresent */0) {
                          return false;
                        }
                        const tl2 = match$1._1;
                        if (Stdlib__List.length(tl1) === Stdlib__List.length(tl2) && match._0 === match$1._0) {
                          to_equal.contents = Stdlib.$at(Stdlib__List.combine(tl1, tl2), to_equal.contents);
                          return true;
                        } else {
                          return false;
                        }
                      }), match$9[2])) {
                return false;
              }
              const match$10 = Stdlib__List.split(to_equal.contents);
              return equal$5(env, true, match$10[0], match$10[1]);
            }
            
          }
          break;
      default:
        
    }
  }
  const check_super = function (ty1) {
    if (equal$5(env, true, {
            hd: ty1,
            tl: params1
          }, {
            hd: ty2,
            tl: params2
          })) {
      return true;
    }
    if (priv2 !== /* Private */0) {
      return false;
    }
    try {
      return check_super(try_expand_once_opt(env, expand_head(env, ty1)));
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Cannot_expand) {
        return false;
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  };
  return check_super(ty1);
}

function report_type_mismatch(first, second, decl, ppf) {
  return function (param) {
    return Stdlib__List.iter((function (err) {
                  if (Caml_obj.caml_equal(err, /* Manifest */4)) {
                    return ;
                  } else {
                    return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                                    _0: {
                                      TAG: /* Formatting_lit */17,
                                      _0: {
                                        TAG: /* Break */0,
                                        _0: "@ ",
                                        _1: 1,
                                        _2: 0
                                      },
                                      _1: {
                                        TAG: /* Alpha */15,
                                        _0: {
                                          TAG: /* Char_literal */12,
                                          _0: /* '.' */46,
                                          _1: /* End_of_format */0
                                        }
                                      }
                                    },
                                    _1: "@ %a."
                                  }), (function (param, param$1) {
                                  if (typeof param$1 === "number") {
                                    switch (param$1) {
                                      case /* Arity */0 :
                                          return Stdlib__Format.fprintf(param)(/* Format */{
                                                      _0: {
                                                        TAG: /* String_literal */11,
                                                        _0: "They have different arities",
                                                        _1: /* End_of_format */0
                                                      },
                                                      _1: "They have different arities"
                                                    });
                                      case /* Privacy */1 :
                                          return Stdlib__Format.fprintf(param)(/* Format */{
                                                      _0: {
                                                        TAG: /* String_literal */11,
                                                        _0: "A private type would be revealed",
                                                        _1: /* End_of_format */0
                                                      },
                                                      _1: "A private type would be revealed"
                                                    });
                                      case /* Kind */2 :
                                          return Stdlib__Format.fprintf(param)(/* Format */{
                                                      _0: {
                                                        TAG: /* String_literal */11,
                                                        _0: "Their kinds differ",
                                                        _1: /* End_of_format */0
                                                      },
                                                      _1: "Their kinds differ"
                                                    });
                                      case /* Constraint */3 :
                                          return Stdlib__Format.fprintf(param)(/* Format */{
                                                      _0: {
                                                        TAG: /* String_literal */11,
                                                        _0: "Their constraints differ",
                                                        _1: /* End_of_format */0
                                                      },
                                                      _1: "Their constraints differ"
                                                    });
                                      case /* Manifest */4 :
                                          return ;
                                      case /* Variance */5 :
                                          return Stdlib__Format.fprintf(param)(/* Format */{
                                                      _0: {
                                                        TAG: /* String_literal */11,
                                                        _0: "Their variances do not agree",
                                                        _1: /* End_of_format */0
                                                      },
                                                      _1: "Their variances do not agree"
                                                    });
                                      
                                    }
                                  } else {
                                    switch (param$1.TAG | 0) {
                                      case /* Field_type */0 :
                                          return Curry._1(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* String_literal */11,
                                                            _0: "The types for field ",
                                                            _1: {
                                                              TAG: /* String */2,
                                                              _0: /* No_padding */0,
                                                              _1: {
                                                                TAG: /* String_literal */11,
                                                                _0: " are not equal",
                                                                _1: /* End_of_format */0
                                                              }
                                                            }
                                                          },
                                                          _1: "The types for field %s are not equal"
                                                        }), param$1._0.name);
                                      case /* Field_mutable */1 :
                                          return Curry._1(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* String_literal */11,
                                                            _0: "The mutability of field ",
                                                            _1: {
                                                              TAG: /* String */2,
                                                              _0: /* No_padding */0,
                                                              _1: {
                                                                TAG: /* String_literal */11,
                                                                _0: " is different",
                                                                _1: /* End_of_format */0
                                                              }
                                                            }
                                                          },
                                                          _1: "The mutability of field %s is different"
                                                        }), param$1._0.name);
                                      case /* Field_arity */2 :
                                          return Curry._1(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* String_literal */11,
                                                            _0: "The arities for field ",
                                                            _1: {
                                                              TAG: /* String */2,
                                                              _0: /* No_padding */0,
                                                              _1: {
                                                                TAG: /* String_literal */11,
                                                                _0: " differ",
                                                                _1: /* End_of_format */0
                                                              }
                                                            }
                                                          },
                                                          _1: "The arities for field %s differ"
                                                        }), param$1._0.name);
                                      case /* Field_names */3 :
                                          return Curry._3(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* String_literal */11,
                                                            _0: "Fields number ",
                                                            _1: {
                                                              TAG: /* Int */4,
                                                              _0: /* Int_i */3,
                                                              _1: /* No_padding */0,
                                                              _2: /* No_precision */0,
                                                              _3: {
                                                                TAG: /* String_literal */11,
                                                                _0: " have different names, ",
                                                                _1: {
                                                                  TAG: /* String */2,
                                                                  _0: /* No_padding */0,
                                                                  _1: {
                                                                    TAG: /* String_literal */11,
                                                                    _0: " and ",
                                                                    _1: {
                                                                      TAG: /* String */2,
                                                                      _0: /* No_padding */0,
                                                                      _1: /* End_of_format */0
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          },
                                                          _1: "Fields number %i have different names, %s and %s"
                                                        }), param$1._0, param$1._1.name, param$1._2.name);
                                      case /* Field_missing */4 :
                                          return Curry._3(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* String_literal */11,
                                                            _0: "The field ",
                                                            _1: {
                                                              TAG: /* String */2,
                                                              _0: /* No_padding */0,
                                                              _1: {
                                                                TAG: /* String_literal */11,
                                                                _0: " is only present in ",
                                                                _1: {
                                                                  TAG: /* String */2,
                                                                  _0: /* No_padding */0,
                                                                  _1: {
                                                                    TAG: /* Char_literal */12,
                                                                    _0: /* ' ' */32,
                                                                    _1: {
                                                                      TAG: /* String */2,
                                                                      _0: /* No_padding */0,
                                                                      _1: /* End_of_format */0
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          },
                                                          _1: "The field %s is only present in %s %s"
                                                        }), param$1._1.name, param$1._0 ? second : first, decl);
                                      case /* Record_representation */5 :
                                          return Curry._3(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* String_literal */11,
                                                            _0: "Their internal representations differ:",
                                                            _1: {
                                                              TAG: /* Formatting_lit */17,
                                                              _0: {
                                                                TAG: /* Break */0,
                                                                _0: "@ ",
                                                                _1: 1,
                                                                _2: 0
                                                              },
                                                              _1: {
                                                                TAG: /* String */2,
                                                                _0: /* No_padding */0,
                                                                _1: {
                                                                  TAG: /* Char_literal */12,
                                                                  _0: /* ' ' */32,
                                                                  _1: {
                                                                    TAG: /* String */2,
                                                                    _0: /* No_padding */0,
                                                                    _1: {
                                                                      TAG: /* Char_literal */12,
                                                                      _0: /* ' ' */32,
                                                                      _1: {
                                                                        TAG: /* String */2,
                                                                        _0: /* No_padding */0,
                                                                        _1: /* End_of_format */0
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          },
                                                          _1: "Their internal representations differ:@ %s %s %s"
                                                        }), param$1._0 ? second : first, decl, "uses unboxed float representation");
                                      
                                    }
                                  }
                                }), err);
                  }
                }), param);
  };
}

function compare_variants(env, decl1, decl2, _n, _cstrs1, _cstrs2) {
  while(true) {
    const cstrs2 = _cstrs2;
    const cstrs1 = _cstrs1;
    const n = _n;
    if (!cstrs1) {
      if (cstrs2) {
        return {
                hd: {
                  TAG: /* Field_missing */4,
                  _0: true,
                  _1: cstrs2.hd.cd_id
                },
                tl: /* [] */0
              };
      } else {
        return /* [] */0;
      }
    }
    const c = cstrs1.hd;
    if (!cstrs2) {
      return {
              hd: {
                TAG: /* Field_missing */4,
                _0: false,
                _1: c.cd_id
              },
              tl: /* [] */0
            };
    }
    const match = cstrs2.hd;
    const ret2 = match.cd_res;
    const arg2 = match.cd_args;
    const cstr2 = match.cd_id;
    const ret1 = c.cd_res;
    const arg1 = c.cd_args;
    const cstr1 = c.cd_id;
    if (cstr1.name !== cstr2.name) {
      return {
              hd: {
                TAG: /* Field_names */3,
                _0: n,
                _1: cstr1,
                _2: cstr2
              },
              tl: /* [] */0
            };
    }
    if (Stdlib__List.length(arg1) !== Stdlib__List.length(arg2)) {
      return {
              hd: {
                TAG: /* Field_arity */2,
                _0: cstr1
              },
              tl: /* [] */0
            };
    }
    if (ret1 !== undefined) {
      if (ret2 === undefined) {
        return {
                hd: {
                  TAG: /* Field_type */0,
                  _0: cstr1
                },
                tl: /* [] */0
              };
      }
      if (!equal$5(env, true, {
              hd: ret1,
              tl: /* [] */0
            }, {
              hd: ret2,
              tl: /* [] */0
            })) {
        return {
                hd: {
                  TAG: /* Field_type */0,
                  _0: cstr1
                },
                tl: /* [] */0
              };
      }
      
    } else if (ret2 !== undefined) {
      return {
              hd: {
                TAG: /* Field_type */0,
                _0: cstr1
              },
              tl: /* [] */0
            };
    }
    if (!for_all2((function (ty1, ty2) {
              return equal$5(env, true, {
                          hd: ty1,
                          tl: decl1.type_params
                        }, {
                          hd: ty2,
                          tl: decl2.type_params
                        });
            }), arg1, arg2)) {
      return {
              hd: {
                TAG: /* Field_type */0,
                _0: cstr1
              },
              tl: /* [] */0
            };
    }
    _cstrs2 = cstrs2.tl;
    _cstrs1 = cstrs1.tl;
    _n = n + 1 | 0;
    continue ;
  };
}

function compare_records(env, decl1, decl2, _n, _labels1, _labels2) {
  while(true) {
    const labels2 = _labels2;
    const labels1 = _labels1;
    const n = _n;
    if (!labels1) {
      if (labels2) {
        return {
                hd: {
                  TAG: /* Field_missing */4,
                  _0: true,
                  _1: labels2.hd.ld_id
                },
                tl: /* [] */0
              };
      } else {
        return /* [] */0;
      }
    }
    const l = labels1.hd;
    if (!labels2) {
      return {
              hd: {
                TAG: /* Field_missing */4,
                _0: false,
                _1: l.ld_id
              },
              tl: /* [] */0
            };
    }
    const match = labels2.hd;
    const lab2 = match.ld_id;
    const lab1 = l.ld_id;
    if (lab1.name !== lab2.name) {
      return {
              hd: {
                TAG: /* Field_names */3,
                _0: n,
                _1: lab1,
                _2: lab2
              },
              tl: /* [] */0
            };
    }
    if (l.ld_mutable !== match.ld_mutable) {
      return {
              hd: {
                TAG: /* Field_mutable */1,
                _0: lab1
              },
              tl: /* [] */0
            };
    }
    if (!equal$5(env, true, {
            hd: l.ld_type,
            tl: decl1.type_params
          }, {
            hd: match.ld_type,
            tl: decl2.type_params
          })) {
      return {
              hd: {
                TAG: /* Field_type */0,
                _0: lab1
              },
              tl: /* [] */0
            };
    }
    _labels2 = labels2.tl;
    _labels1 = labels1.tl;
    _n = n + 1 | 0;
    continue ;
  };
}

function type_declarations$1(equalityOpt, env, name, decl1, id, decl2) {
  const equality = equalityOpt !== undefined ? equalityOpt : false;
  if (decl1.type_arity !== decl2.type_arity) {
    return {
            hd: /* Arity */0,
            tl: /* [] */0
          };
  }
  if (!private_flags(decl1, decl2)) {
    return {
            hd: /* Privacy */1,
            tl: /* [] */0
          };
  }
  const match = decl1.type_kind;
  const match$1 = decl2.type_kind;
  let err;
  let exit = 0;
  if (typeof match$1 === "number" && !match$1) {
    err = /* [] */0;
  } else {
    exit = 1;
  }
  if (exit === 1) {
    if (typeof match === "number") {
      err = match === /* Type_abstract */0 || typeof match$1 !== "number" ? ({
            hd: /* Kind */2,
            tl: /* [] */0
          }) : /* [] */0;
    } else if (match.TAG === /* Type_record */0) {
      if (typeof match$1 === "number" || match$1.TAG !== /* Type_record */0) {
        err = {
          hd: /* Kind */2,
          tl: /* [] */0
        };
      } else {
        const rep2 = match$1._1;
        const err$1 = compare_records(env, decl1, decl2, 1, match._0, match$1._0);
        err = Caml_obj.caml_notequal(err$1, /* [] */0) || match._1 === rep2 ? err$1 : ({
              hd: {
                TAG: /* Record_representation */5,
                _0: rep2 === /* Record_float */1
              },
              tl: /* [] */0
            });
      }
    } else {
      const cstrs1 = match._0;
      if (typeof match$1 === "number" || match$1.TAG === /* Type_record */0) {
        err = {
          hd: /* Kind */2,
          tl: /* [] */0
        };
      } else {
        const cstrs2 = match$1._0;
        const mark = function (cstrs, usage, name, decl) {
          Stdlib__List.iter((function (c) {
                  mark_constructor_used(usage, env, name, decl, c.cd_id.name);
                }), cstrs);
        };
        const usage = decl1.type_private === /* Private */0 || decl2.type_private === /* Public */1 ? /* Positive */0 : /* Privatize */2;
        mark(cstrs1, usage, name, decl1);
        if (equality) {
          mark(cstrs2, /* Positive */0, id.name, decl2);
        }
        err = compare_variants(env, decl1, decl2, 1, cstrs1, cstrs2);
      }
    }
  }
  if (Caml_obj.caml_notequal(err, /* [] */0)) {
    return err;
  }
  const match$2 = decl1.type_manifest;
  const match$3 = decl2.type_manifest;
  let err$2;
  if (match$3 !== undefined) {
    if (match$2 !== undefined) {
      err$2 = type_manifest(env, match$2, decl1.type_params, match$3, decl2.type_params, decl2.type_private) ? /* [] */0 : ({
            hd: /* Manifest */4,
            tl: /* [] */0
          });
    } else {
      const ty1 = newty2(100000000, {
            TAG: /* Tconstr */3,
            _0: {
              TAG: /* Pident */0,
              _0: id
            },
            _1: decl2.type_params,
            _2: {
              contents: /* Mnil */0
            }
          });
      err$2 = equal$5(env, true, decl1.type_params, decl2.type_params) ? (
          equal$5(env, false, {
                hd: ty1,
                tl: /* [] */0
              }, {
                hd: match$3,
                tl: /* [] */0
              }) ? /* [] */0 : ({
                hd: /* Manifest */4,
                tl: /* [] */0
              })
        ) : ({
            hd: /* Constraint */3,
            tl: /* [] */0
          });
    }
  } else {
    err$2 = equal$5(env, true, decl1.type_params, decl2.type_params) ? /* [] */0 : ({
          hd: /* Constraint */3,
          tl: /* [] */0
        });
  }
  if (Caml_obj.caml_notequal(err$2, /* [] */0)) {
    return err$2;
  }
  const abstr = decl2.type_private === /* Private */0 || Caml_obj.caml_equal(decl2.type_kind, /* Type_abstract */0) && decl2.type_manifest === undefined;
  const opn = Caml_obj.caml_equal(decl2.type_kind, /* Type_open */1) && decl2.type_manifest === undefined;
  if (Stdlib__List.for_all2((function (ty, param) {
            const v2 = param[1];
            const v1 = param[0];
            const match = Curry._1(Types_Variance.get_upper, v1);
            const cn1 = match[1];
            const co1 = match[0];
            const match$1 = Curry._1(Types_Variance.get_upper, v2);
            const cn2 = match$1[1];
            const co2 = match$1[0];
            if (!(
                abstr ? (!co1 || co2) && (!cn1 || cn2) : (
                    opn || !is_Tvar(repr(ty)) ? co1 === co2 && cn1 === cn2 : true
                  )
              )) {
              return false;
            }
            const match$2 = Curry._1(Types_Variance.get_lower, v1);
            const match$3 = Curry._1(Types_Variance.get_lower, v2);
            return abstr ? (
                      (!match$3[0] || match$2[0]) && (!match$3[1] || match$2[1]) && (!match$3[2] || match$2[2]) ? (
                          match$3[3] ? match$2[3] : true
                        ) : false
                    ) : true;
          }), decl2.type_params, Stdlib__List.combine(decl1.type_variance, decl2.type_variance))) {
    return /* [] */0;
  } else {
    return {
            hd: /* Variance */5,
            tl: /* [] */0
          };
  }
}

function extension_constructors(env, id, ext1, ext2) {
  const usage = ext1.ext_private === /* Private */0 || ext2.ext_private === /* Public */1 ? /* Positive */0 : /* Privatize */2;
  mark_extension_used(usage, env, ext1, id.name);
  const ty1 = newty2(100000000, {
        TAG: /* Tconstr */3,
        _0: ext1.ext_type_path,
        _1: ext1.ext_type_params,
        _2: {
          contents: /* Mnil */0
        }
      });
  const ty2 = newty2(100000000, {
        TAG: /* Tconstr */3,
        _0: ext2.ext_type_path,
        _1: ext2.ext_type_params,
        _2: {
          contents: /* Mnil */0
        }
      });
  if (!equal$5(env, true, {
          hd: ty1,
          tl: ext1.ext_type_params
        }, {
          hd: ty2,
          tl: ext2.ext_type_params
        })) {
    return false;
  }
  if (Stdlib__List.length(ext1.ext_args) !== Stdlib__List.length(ext2.ext_args)) {
    return false;
  }
  const match = ext1.ext_ret_type;
  const match$1 = ext2.ext_ret_type;
  let tmp;
  let exit = 0;
  if (match !== undefined) {
    if (match$1 !== undefined && equal$5(env, true, {
            hd: match,
            tl: /* [] */0
          }, {
            hd: match$1,
            tl: /* [] */0
          })) {
      exit = 1;
    } else {
      tmp = false;
    }
  } else if (match$1 !== undefined) {
    tmp = false;
  } else {
    exit = 1;
  }
  if (exit === 1) {
    tmp = for_all2((function (ty1, ty2) {
            return equal$5(env, true, {
                        hd: ty1,
                        tl: ext1.ext_type_params
                      }, {
                        hd: ty2,
                        tl: ext2.ext_type_params
                      });
          }), ext1.ext_args, ext2.ext_args);
  }
  if (!tmp) {
    return false;
  }
  const match$2 = ext1.ext_private;
  const match$3 = ext2.ext_private;
  if (match$2 || !match$3) {
    return true;
  } else {
    return false;
  }
}

function scrape(env, mty) {
  if (mty.TAG !== /* Mty_ident */0) {
    return mty;
  }
  try {
    return scrape(env, find_modtype_expansion(mty._0, env));
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return mty;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function strengthen$1(env, mty, p) {
  const sg = scrape(env, mty);
  switch (sg.TAG | 0) {
    case /* Mty_signature */1 :
        return {
                TAG: /* Mty_signature */1,
                _0: strengthen_sig(env, sg._0, p)
              };
    case /* Mty_functor */2 :
        const param = sg._0;
        if (applicative_functors.contents && param.name !== "*") {
          return {
                  TAG: /* Mty_functor */2,
                  _0: param,
                  _1: sg._1,
                  _2: strengthen$1(env, sg._2, {
                        TAG: /* Papply */2,
                        _0: p,
                        _1: {
                          TAG: /* Pident */0,
                          _0: param
                        }
                      })
                };
        } else {
          return sg;
        }
    case /* Mty_ident */0 :
    case /* Mty_alias */3 :
        return sg;
    
  }
}

function strengthen_sig(env, sg, p) {
  if (!sg) {
    return /* [] */0;
  }
  const sigelt = sg.hd;
  switch (sigelt.TAG | 0) {
    case /* Sig_type */1 :
        const decl = sigelt._1;
        const id = sigelt._0;
        const match = decl.type_manifest;
        const match$1 = decl.type_private;
        const match$2 = decl.type_kind;
        let newdecl;
        let exit = 0;
        if (match !== undefined && (match$1 || typeof match$2 !== "number")) {
          newdecl = decl;
        } else {
          exit = 1;
        }
        if (exit === 1) {
          const manif = newty2(100000000, {
                TAG: /* Tconstr */3,
                _0: {
                  TAG: /* Pdot */1,
                  _0: p,
                  _1: id.name,
                  _2: -1
                },
                _1: decl.type_params,
                _2: {
                  contents: /* Mnil */0
                }
              });
          newdecl = Caml_obj.caml_equal(decl.type_kind, /* Type_abstract */0) ? ({
                type_params: decl.type_params,
                type_arity: decl.type_arity,
                type_kind: decl.type_kind,
                type_private: /* Public */1,
                type_manifest: manif,
                type_variance: decl.type_variance,
                type_newtype_level: decl.type_newtype_level,
                type_loc: decl.type_loc,
                type_attributes: decl.type_attributes
              }) : ({
                type_params: decl.type_params,
                type_arity: decl.type_arity,
                type_kind: decl.type_kind,
                type_private: decl.type_private,
                type_manifest: manif,
                type_variance: decl.type_variance,
                type_newtype_level: decl.type_newtype_level,
                type_loc: decl.type_loc,
                type_attributes: decl.type_attributes
              });
        }
        return {
                hd: {
                  TAG: /* Sig_type */1,
                  _0: id,
                  _1: newdecl,
                  _2: sigelt._2
                },
                tl: strengthen_sig(env, sg.tl, p)
              };
    case /* Sig_module */3 :
        const md = sigelt._1;
        const id$1 = sigelt._0;
        const str = strengthen_decl(env, md, {
              TAG: /* Pdot */1,
              _0: p,
              _1: id$1.name,
              _2: -1
            });
        return {
                hd: {
                  TAG: /* Sig_module */3,
                  _0: id$1,
                  _1: str,
                  _2: sigelt._2
                },
                tl: strengthen_sig(add_module_declaration(undefined, id$1, md, env), sg.tl, p)
              };
    case /* Sig_modtype */4 :
        const decl$1 = sigelt._1;
        const id$2 = sigelt._0;
        const match$3 = decl$1.mtd_type;
        const newdecl$1 = match$3 !== undefined ? decl$1 : ({
              mtd_type: {
                TAG: /* Mty_ident */0,
                _0: {
                  TAG: /* Pdot */1,
                  _0: p,
                  _1: id$2.name,
                  _2: -1
                }
              },
              mtd_attributes: decl$1.mtd_attributes,
              mtd_loc: decl$1.mtd_loc
            });
        return {
                hd: {
                  TAG: /* Sig_modtype */4,
                  _0: id$2,
                  _1: newdecl$1
                },
                tl: strengthen_sig(add_modtype$1(id$2, decl$1, env), sg.tl, p)
              };
    default:
      return {
              hd: sigelt,
              tl: strengthen_sig(env, sg.tl, p)
            };
  }
}

function strengthen_decl(env, md, p) {
  return {
          md_type: strengthen$1(env, md.md_type, p),
          md_attributes: md.md_attributes,
          md_loc: md.md_loc
        };
}

strengthen.contents = strengthen$1;

function nondep_supertype(env, mid, mty) {
  const nondep_mty = function (env, va, _mty) {
    while(true) {
      const mty = _mty;
      switch (mty.TAG | 0) {
        case /* Mty_ident */0 :
            const p = mty._0;
            if (!isfree(mid, p)) {
              return mty;
            }
            _mty = find_modtype_expansion(p, env);
            continue ;
        case /* Mty_signature */1 :
            return {
                    TAG: /* Mty_signature */1,
                    _0: nondep_sig(env, va, mty._0)
                  };
        case /* Mty_functor */2 :
            const arg = mty._1;
            const param = mty._0;
            let var_inv;
            switch (va) {
              case /* Co */0 :
                  var_inv = /* Contra */1;
                  break;
              case /* Contra */1 :
                  var_inv = /* Co */0;
                  break;
              case /* Strict */2 :
                  var_inv = /* Strict */2;
                  break;
              
            }
            return {
                    TAG: /* Mty_functor */2,
                    _0: param,
                    _1: may_map((function (param) {
                            return nondep_mty(env, var_inv, param);
                          }), arg),
                    _2: nondep_mty(add_module$1(true, param, arg !== undefined ? arg : ({
                                  TAG: /* Mty_signature */1,
                                  _0: /* [] */0
                                }), env), va, mty._2)
                  };
        case /* Mty_alias */3 :
            const p$1 = mty._0;
            if (!isfree(mid, p$1)) {
              return mty;
            }
            _mty = find_module(false, p$1, env).md_type;
            continue ;
        
      }
    };
  };
  const nondep_sig = function (env, va, param) {
    if (!param) {
      return /* [] */0;
    }
    const item = param.hd;
    const rem$p = nondep_sig(env, va, param.tl);
    switch (item.TAG | 0) {
      case /* Sig_value */0 :
          const d = item._1;
          return {
                  hd: {
                    TAG: /* Sig_value */0,
                    _0: item._0,
                    _1: {
                      val_type: nondep_type(env, mid, d.val_type),
                      val_kind: d.val_kind,
                      val_loc: d.val_loc,
                      val_attributes: d.val_attributes
                    }
                  },
                  tl: rem$p
                };
      case /* Sig_type */1 :
          const id = item._0;
          return {
                  hd: {
                    TAG: /* Sig_type */1,
                    _0: id,
                    _1: nondep_type_decl(env, mid, id, va === /* Co */0, item._1),
                    _2: item._2
                  },
                  tl: rem$p
                };
      case /* Sig_typext */2 :
          return {
                  hd: {
                    TAG: /* Sig_typext */2,
                    _0: item._0,
                    _1: nondep_extension_constructor(env, mid, item._1),
                    _2: item._2
                  },
                  tl: rem$p
                };
      case /* Sig_module */3 :
          const md = item._1;
          return {
                  hd: {
                    TAG: /* Sig_module */3,
                    _0: item._0,
                    _1: {
                      md_type: nondep_mty(env, va, md.md_type),
                      md_attributes: md.md_attributes,
                      md_loc: md.md_loc
                    },
                    _2: item._2
                  },
                  tl: rem$p
                };
      case /* Sig_modtype */4 :
          const id$1 = item._0;
          try {
            return {
                    hd: {
                      TAG: /* Sig_modtype */4,
                      _0: id$1,
                      _1: nondep_modtype_decl(env, item._1)
                    },
                    tl: rem$p
                  };
          }
          catch (raw_exn){
            const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.MEL_EXN_ID === Stdlib.Not_found) {
              if (va) {
                throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                          MEL_EXN_ID: Stdlib.Not_found
                        });
              }
              return {
                      hd: {
                        TAG: /* Sig_modtype */4,
                        _0: id$1,
                        _1: {
                          mtd_type: undefined,
                          mtd_attributes: /* [] */0,
                          mtd_loc: none
                        }
                      },
                      tl: rem$p
                    };
            }
            throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
          }
      case /* Sig_class */5 :
          return {
                  hd: {
                    TAG: /* Sig_class */5,
                    _0: item._0,
                    _1: nondep_class_declaration(env, mid, item._1),
                    _2: item._2
                  },
                  tl: rem$p
                };
      case /* Sig_class_type */6 :
          return {
                  hd: {
                    TAG: /* Sig_class_type */6,
                    _0: item._0,
                    _1: nondep_cltype_declaration(env, mid, item._1),
                    _2: item._2
                  },
                  tl: rem$p
                };
      
    }
  };
  const nondep_modtype_decl = function (env, mtd) {
    return {
            mtd_type: may_map((function (param) {
                    return nondep_mty(env, /* Strict */2, param);
                  }), mtd.mtd_type),
            mtd_attributes: mtd.mtd_attributes,
            mtd_loc: mtd.mtd_loc
          };
  };
  return nondep_mty(env, /* Co */0, mty);
}

function enrich_typedecl(env, p, decl) {
  const ty = decl.type_manifest;
  if (ty !== undefined) {
    return decl;
  }
  try {
    const orig_decl = find_type_full(p, env)[0];
    if (orig_decl.type_arity !== decl.type_arity) {
      return decl;
    } else {
      return {
              type_params: decl.type_params,
              type_arity: decl.type_arity,
              type_kind: decl.type_kind,
              type_private: decl.type_private,
              type_manifest: newty2(100000000, {
                    TAG: /* Tconstr */3,
                    _0: p,
                    _1: decl.type_params,
                    _2: {
                      contents: /* Mnil */0
                    }
                  }),
              type_variance: decl.type_variance,
              type_newtype_level: decl.type_newtype_level,
              type_loc: decl.type_loc,
              type_attributes: decl.type_attributes
            };
    }
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return decl;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function enrich_modtype(env, p, mty) {
  if (mty.TAG === /* Mty_signature */1) {
    return {
            TAG: /* Mty_signature */1,
            _0: Stdlib__List.map((function (param) {
                    switch (param.TAG | 0) {
                      case /* Sig_type */1 :
                          const id = param._0;
                          return {
                                  TAG: /* Sig_type */1,
                                  _0: id,
                                  _1: enrich_typedecl(env, {
                                        TAG: /* Pdot */1,
                                        _0: p,
                                        _1: id.name,
                                        _2: -1
                                      }, param._1),
                                  _2: param._2
                                };
                      case /* Sig_module */3 :
                          const md = param._1;
                          const id$1 = param._0;
                          return {
                                  TAG: /* Sig_module */3,
                                  _0: id$1,
                                  _1: {
                                    md_type: enrich_modtype(env, {
                                          TAG: /* Pdot */1,
                                          _0: p,
                                          _1: id$1.name,
                                          _2: -1
                                        }, md.md_type),
                                    md_attributes: md.md_attributes,
                                    md_loc: md.md_loc
                                  },
                                  _2: param._2
                                };
                      default:
                        return param;
                    }
                  }), mty._0)
          };
  } else {
    return mty;
  }
}

function type_paths(env, p, mty) {
  const p$1 = scrape(env, mty);
  if (p$1.TAG === /* Mty_signature */1) {
    return type_paths_sig(env, p, 0, p$1._0);
  } else {
    return /* [] */0;
  }
}

function type_paths_sig(_env, p, _pos, _sg) {
  while(true) {
    const sg = _sg;
    const pos = _pos;
    const env = _env;
    if (!sg) {
      return /* [] */0;
    }
    const match = sg.hd;
    switch (match.TAG | 0) {
      case /* Sig_value */0 :
          const match$1 = match._1.val_kind;
          let pos$p;
          pos$p = typeof match$1 === "number" || match$1.TAG !== /* Val_prim */0 ? pos + 1 | 0 : pos;
          _sg = sg.tl;
          _pos = pos$p;
          continue ;
      case /* Sig_type */1 :
          return {
                  hd: {
                    TAG: /* Pdot */1,
                    _0: p,
                    _1: match._0.name,
                    _2: -1
                  },
                  tl: type_paths_sig(env, p, pos, sg.tl)
                };
      case /* Sig_module */3 :
          const md = match._1;
          const id = match._0;
          return Stdlib.$at(type_paths(env, {
                          TAG: /* Pdot */1,
                          _0: p,
                          _1: id.name,
                          _2: pos
                        }, md.md_type), type_paths_sig(add_module_declaration(undefined, id, md, env), p, pos + 1 | 0, sg.tl));
      case /* Sig_modtype */4 :
          _sg = sg.tl;
          _env = add_modtype$1(match._0, match._1, env);
          continue ;
      case /* Sig_typext */2 :
      case /* Sig_class */5 :
          break;
      case /* Sig_class_type */6 :
          _sg = sg.tl;
          continue ;
      
    }
    _sg = sg.tl;
    _pos = pos + 1 | 0;
    continue ;
  };
}

function contains_type(env, _path) {
  while(true) {
    const path = _path;
    switch (path.TAG | 0) {
      case /* Mty_ident */0 :
          try {
            const mty = find_modtype(path._0, env).mtd_type;
            if (mty !== undefined) {
              return contains_type(env, mty);
            }
            throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                      MEL_EXN_ID: Stdlib.Exit
                    });
          }
          catch (raw_exn){
            const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.MEL_EXN_ID === Stdlib.Not_found) {
              throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                        MEL_EXN_ID: Stdlib.Exit
                      });
            }
            throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
          }
      case /* Mty_signature */1 :
          return contains_type_sig(env)(path._0);
      case /* Mty_functor */2 :
          _path = path._2;
          continue ;
      case /* Mty_alias */3 :
          return ;
      
    }
  };
}

function contains_type_sig(env) {
  return function (param) {
    return Stdlib__List.iter((function (param) {
                  switch (param.TAG | 0) {
                    case /* Sig_type */1 :
                        const match = param._1;
                        const match$1 = match.type_kind;
                        if (match.type_manifest !== undefined) {
                          if (typeof match$1 !== "number") {
                            return ;
                          }
                          if (match$1) {
                            return ;
                          }
                          if (match.type_private) {
                            return ;
                          }
                          throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                    MEL_EXN_ID: Stdlib.Exit
                                  });
                        }
                        throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                  MEL_EXN_ID: Stdlib.Exit
                                });
                    case /* Sig_module */3 :
                        return contains_type(env, param._1.md_type);
                    case /* Sig_modtype */4 :
                        throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                  MEL_EXN_ID: Stdlib.Exit
                                });
                    default:
                      return ;
                  }
                }), param);
  };
}

function contains_type$1(env, mty) {
  try {
    contains_type(env, mty);
    return false;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Exit) {
      return true;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function compare$5(p1, p2) {
  if (same(p1, p2)) {
    return 0;
  } else {
    return Caml_obj.caml_compare(p1, p2);
  }
}

const P = {
  compare: compare$5
};

function height$7(param) {
  if (param) {
    return param.h;
  } else {
    return 0;
  }
}

function create$8(l, v, r) {
  const hl = l ? l.h : 0;
  const hr = r ? r.h : 0;
  return /* Node */{
          l: l,
          v: v,
          r: r,
          h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        };
}

function bal$7(l, v, r) {
  const hl = l ? l.h : 0;
  const hr = r ? r.h : 0;
  if (hl > (hr + 2 | 0)) {
    if (l) {
      const lr = l.r;
      const lv = l.v;
      const ll = l.l;
      if (height$7(ll) >= height$7(lr)) {
        return create$8(ll, lv, create$8(lr, v, r));
      }
      if (lr) {
        return create$8(create$8(ll, lv, lr.l), lr.v, create$8(lr.r, v, r));
      }
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
                MEL_EXN_ID: "Invalid_argument",
                _1: "Set.bal"
              });
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Set.bal"
            });
  }
  if (hr <= (hl + 2 | 0)) {
    return /* Node */{
            l: l,
            v: v,
            r: r,
            h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          };
  }
  if (r) {
    const rr = r.r;
    const rv = r.v;
    const rl = r.l;
    if (height$7(rr) >= height$7(rl)) {
      return create$8(create$8(l, v, rl), rv, rr);
    }
    if (rl) {
      return create$8(create$8(l, v, rl.l), rl.v, create$8(rl.r, rv, rr));
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Set.bal"
            });
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Set.bal"
          });
}

function add$9(x, t) {
  if (!t) {
    return /* Node */{
            l: /* Empty */0,
            v: x,
            r: /* Empty */0,
            h: 1
          };
  }
  const r = t.r;
  const v = t.v;
  const l = t.l;
  const c = Curry._2(P.compare, x, v);
  if (c === 0) {
    return t;
  }
  if (c < 0) {
    const ll = add$9(x, l);
    if (l === ll) {
      return t;
    } else {
      return bal$7(ll, v, r);
    }
  }
  const rr = add$9(x, r);
  if (r === rr) {
    return t;
  } else {
    return bal$7(l, v, rr);
  }
}

function singleton$3(x) {
  return /* Node */{
          l: /* Empty */0,
          v: x,
          r: /* Empty */0,
          h: 1
        };
}

function add_min_element$2(x, param) {
  if (param) {
    return bal$7(add_min_element$2(x, param.l), param.v, param.r);
  } else {
    return singleton$3(x);
  }
}

function add_max_element$2(x, param) {
  if (param) {
    return bal$7(param.l, param.v, add_max_element$2(x, param.r));
  } else {
    return singleton$3(x);
  }
}

function join$3(l, v, r) {
  if (!l) {
    return add_min_element$2(v, r);
  }
  if (!r) {
    return add_max_element$2(v, l);
  }
  const rh = r.h;
  const lh = l.h;
  if (lh > (rh + 2 | 0)) {
    return bal$7(l.l, l.v, join$3(l.r, v, r));
  } else if (rh > (lh + 2 | 0)) {
    return bal$7(join$3(l, v, r.l), r.v, r.r);
  } else {
    return create$8(l, v, r);
  }
}

function split$3(x, param) {
  if (!param) {
    return [
            /* Empty */0,
            false,
            /* Empty */0
          ];
  }
  const r = param.r;
  const v = param.v;
  const l = param.l;
  const c = Curry._2(P.compare, x, v);
  if (c === 0) {
    return [
            l,
            true,
            r
          ];
  }
  if (c < 0) {
    const match = split$3(x, l);
    return [
            match[0],
            match[1],
            join$3(match[2], v, r)
          ];
  }
  const match$1 = split$3(x, r);
  return [
          join$3(l, v, match$1[0]),
          match$1[1],
          match$1[2]
        ];
}

function union$4(s1, s2) {
  if (!s1) {
    return s2;
  }
  if (!s2) {
    return s1;
  }
  const h2 = s2.h;
  const v2 = s2.v;
  const h1 = s1.h;
  const v1 = s1.v;
  if (h1 >= h2) {
    if (h2 === 1) {
      return add$9(v2, s1);
    }
    const match = split$3(v1, s2);
    return join$3(union$4(s1.l, match[0]), v1, union$4(s1.r, match[2]));
  }
  if (h1 === 1) {
    return add$9(v1, s2);
  }
  const match$1 = split$3(v2, s1);
  return join$3(union$4(match$1[0], s2.l), v2, union$4(match$1[2], s2.r));
}

function fold$6(f, _s, _accu) {
  while(true) {
    const accu = _accu;
    const s = _s;
    if (!s) {
      return accu;
    }
    _accu = Curry._2(f, s.v, fold$6(f, s.l, accu));
    _s = s.r;
    continue ;
  };
}

function height$8(param) {
  if (param) {
    return param.h;
  } else {
    return 0;
  }
}

function create$9(l, x, d, r) {
  const hl = height$8(l);
  const hr = height$8(r);
  return /* Node */{
          l: l,
          v: x,
          d: d,
          r: r,
          h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        };
}

function bal$8(l, x, d, r) {
  const hl = l ? l.h : 0;
  const hr = r ? r.h : 0;
  if (hl > (hr + 2 | 0)) {
    if (l) {
      const lr = l.r;
      const ld = l.d;
      const lv = l.v;
      const ll = l.l;
      if (height$8(ll) >= height$8(lr)) {
        return create$9(ll, lv, ld, create$9(lr, x, d, r));
      }
      if (lr) {
        return create$9(create$9(ll, lv, ld, lr.l), lr.v, lr.d, create$9(lr.r, x, d, r));
      }
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
                MEL_EXN_ID: "Invalid_argument",
                _1: "Map.bal"
              });
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Map.bal"
            });
  }
  if (hr <= (hl + 2 | 0)) {
    return /* Node */{
            l: l,
            v: x,
            d: d,
            r: r,
            h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          };
  }
  if (r) {
    const rr = r.r;
    const rd = r.d;
    const rv = r.v;
    const rl = r.l;
    if (height$8(rr) >= height$8(rl)) {
      return create$9(create$9(l, x, d, rl), rv, rd, rr);
    }
    if (rl) {
      return create$9(create$9(l, x, d, rl.l), rl.v, rl.d, create$9(rl.r, rv, rd, rr));
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Map.bal"
            });
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Map.bal"
          });
}

function add$10(x, data, m) {
  if (!m) {
    return /* Node */{
            l: /* Empty */0,
            v: x,
            d: data,
            r: /* Empty */0,
            h: 1
          };
  }
  const r = m.r;
  const d = m.d;
  const v = m.v;
  const l = m.l;
  const c = Curry._2(P.compare, x, v);
  if (c === 0) {
    if (d === data) {
      return m;
    } else {
      return /* Node */{
              l: l,
              v: x,
              d: data,
              r: r,
              h: m.h
            };
    }
  }
  if (c < 0) {
    const ll = add$10(x, data, l);
    if (l === ll) {
      return m;
    } else {
      return bal$8(ll, v, d, r);
    }
  }
  const rr = add$10(x, data, r);
  if (r === rr) {
    return m;
  } else {
    return bal$8(l, v, d, rr);
  }
}

function find$5(x, _param) {
  while(true) {
    const param = _param;
    if (param) {
      const c = Curry._2(P.compare, x, param.v);
      if (c === 0) {
        return param.d;
      }
      _param = c < 0 ? param.l : param.r;
      continue ;
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
  };
}

const compare$6 = Caml_obj.caml_compare;

const funarg$4 = {
  compare: compare$6
};

function height$9(param) {
  if (param) {
    return param.h;
  } else {
    return 0;
  }
}

function create$10(l, v, r) {
  const hl = l ? l.h : 0;
  const hr = r ? r.h : 0;
  return /* Node */{
          l: l,
          v: v,
          r: r,
          h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        };
}

function bal$9(l, v, r) {
  const hl = l ? l.h : 0;
  const hr = r ? r.h : 0;
  if (hl > (hr + 2 | 0)) {
    if (l) {
      const lr = l.r;
      const lv = l.v;
      const ll = l.l;
      if (height$9(ll) >= height$9(lr)) {
        return create$10(ll, lv, create$10(lr, v, r));
      }
      if (lr) {
        return create$10(create$10(ll, lv, lr.l), lr.v, create$10(lr.r, v, r));
      }
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
                MEL_EXN_ID: "Invalid_argument",
                _1: "Set.bal"
              });
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Set.bal"
            });
  }
  if (hr <= (hl + 2 | 0)) {
    return /* Node */{
            l: l,
            v: v,
            r: r,
            h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          };
  }
  if (r) {
    const rr = r.r;
    const rv = r.v;
    const rl = r.l;
    if (height$9(rr) >= height$9(rl)) {
      return create$10(create$10(l, v, rl), rv, rr);
    }
    if (rl) {
      return create$10(create$10(l, v, rl.l), rl.v, create$10(rl.r, rv, rr));
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Set.bal"
            });
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Set.bal"
          });
}

function add$11(x, t) {
  if (!t) {
    return /* Node */{
            l: /* Empty */0,
            v: x,
            r: /* Empty */0,
            h: 1
          };
  }
  const r = t.r;
  const v = t.v;
  const l = t.l;
  const c = Curry._2(funarg$4.compare, x, v);
  if (c === 0) {
    return t;
  }
  if (c < 0) {
    const ll = add$11(x, l);
    if (l === ll) {
      return t;
    } else {
      return bal$9(ll, v, r);
    }
  }
  const rr = add$11(x, r);
  if (r === rr) {
    return t;
  } else {
    return bal$9(l, v, rr);
  }
}

function singleton$4(x) {
  return /* Node */{
          l: /* Empty */0,
          v: x,
          r: /* Empty */0,
          h: 1
        };
}

function add_min_element$3(x, param) {
  if (param) {
    return bal$9(add_min_element$3(x, param.l), param.v, param.r);
  } else {
    return singleton$4(x);
  }
}

function add_max_element$3(x, param) {
  if (param) {
    return bal$9(param.l, param.v, add_max_element$3(x, param.r));
  } else {
    return singleton$4(x);
  }
}

function join$4(l, v, r) {
  if (!l) {
    return add_min_element$3(v, r);
  }
  if (!r) {
    return add_max_element$3(v, l);
  }
  const rh = r.h;
  const lh = l.h;
  if (lh > (rh + 2 | 0)) {
    return bal$9(l.l, l.v, join$4(l.r, v, r));
  } else if (rh > (lh + 2 | 0)) {
    return bal$9(join$4(l, v, r.l), r.v, r.r);
  } else {
    return create$10(l, v, r);
  }
}

function split$4(x, param) {
  if (!param) {
    return [
            /* Empty */0,
            false,
            /* Empty */0
          ];
  }
  const r = param.r;
  const v = param.v;
  const l = param.l;
  const c = Curry._2(funarg$4.compare, x, v);
  if (c === 0) {
    return [
            l,
            true,
            r
          ];
  }
  if (c < 0) {
    const match = split$4(x, l);
    return [
            match[0],
            match[1],
            join$4(match[2], v, r)
          ];
  }
  const match$1 = split$4(x, r);
  return [
          join$4(l, v, match$1[0]),
          match$1[1],
          match$1[2]
        ];
}

function mem$5(x, _param) {
  while(true) {
    const param = _param;
    if (!param) {
      return false;
    }
    const c = Curry._2(funarg$4.compare, x, param.v);
    if (c === 0) {
      return true;
    }
    _param = c < 0 ? param.l : param.r;
    continue ;
  };
}

function union$5(s1, s2) {
  if (!s1) {
    return s2;
  }
  if (!s2) {
    return s1;
  }
  const h2 = s2.h;
  const v2 = s2.v;
  const h1 = s1.h;
  const v1 = s1.v;
  if (h1 >= h2) {
    if (h2 === 1) {
      return add$11(v2, s1);
    }
    const match = split$4(v1, s2);
    return join$4(union$5(s1.l, match[0]), v1, union$5(s1.r, match[2]));
  }
  if (h1 === 1) {
    return add$11(v1, s2);
  }
  const match$1 = split$4(v2, s1);
  return join$4(union$5(match$1[0], s2.l), v2, union$5(match$1[2], s2.r));
}

function get_prefixes(param) {
  switch (param.TAG | 0) {
    case /* Pident */0 :
        return /* Empty */0;
    case /* Pdot */1 :
    case /* Papply */2 :
        break;
    
  }
  const p = param._0;
  return Curry._2(add$9, p, get_prefixes(p));
}

function get_arg_paths(_param) {
  while(true) {
    const param = _param;
    switch (param.TAG | 0) {
      case /* Pident */0 :
          return /* Empty */0;
      case /* Pdot */1 :
          _param = param._0;
          continue ;
      case /* Papply */2 :
          const p2 = param._1;
          return Curry._2(add$9, p2, Curry._2(union$4, get_prefixes(p2), Curry._2(union$4, get_arg_paths(param._0), get_arg_paths(p2))));
      
    }
  };
}

function rollback_path(subst, _p) {
  while(true) {
    const p = _p;
    try {
      return {
              TAG: /* Pident */0,
              _0: Curry._2(find$5, p, subst)
            };
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        switch (p.TAG | 0) {
          case /* Pdot */1 :
              const p1 = p._0;
              const p1$p = rollback_path(subst, p1);
              if (same(p1, p1$p)) {
                return p;
              }
              _p = {
                TAG: /* Pdot */1,
                _0: p1$p,
                _1: p._1,
                _2: p._2
              };
              continue ;
          case /* Pident */0 :
          case /* Papply */2 :
              return p;
          
        }
      } else {
        throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
      }
    }
  };
}

function collect_ids(subst, bindings, p) {
  const id = rollback_path(subst, p);
  switch (id.TAG | 0) {
    case /* Pident */0 :
        const id$1 = id._0;
        let ids;
        try {
          ids = collect_ids(subst, bindings, find_same(id$1, bindings));
        }
        catch (raw_exn){
          const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.MEL_EXN_ID === Stdlib.Not_found) {
            ids = /* Empty */0;
          } else {
            throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
          }
        }
        return Curry._2(add$11, id$1, ids);
    case /* Pdot */1 :
    case /* Papply */2 :
        return /* Empty */0;
    
  }
}

function collect_arg_paths(mty) {
  const paths = {
    contents: /* Empty */0
  };
  const subst = {
    contents: /* Empty */0
  };
  const bindings = {
    contents: /* Empty */0
  };
  const it_path = function (p) {
    paths.contents = Curry._2(union$4, get_arg_paths(p), paths.contents);
  };
  const it_signature_item$1 = function (it, si) {
    it_signature_item(it, si);
    if (si.TAG !== /* Sig_module */3) {
      return ;
    }
    const p = si._1.md_type;
    const id = si._0;
    switch (p.TAG | 0) {
      case /* Mty_signature */1 :
          return Stdlib__List.iter((function (param) {
                        if (param.TAG !== /* Sig_module */3) {
                          return ;
                        }
                        const id$p = param._0;
                        subst.contents = Curry._3(add$10, {
                              TAG: /* Pdot */1,
                              _0: {
                                TAG: /* Pident */0,
                                _0: id
                              },
                              _1: id$p.name,
                              _2: -1
                            }, id$p, subst.contents);
                      }), p._0);
      case /* Mty_ident */0 :
      case /* Mty_functor */2 :
          return ;
      case /* Mty_alias */3 :
          bindings.contents = add(id, p._0, bindings.contents);
          return ;
      
    }
  };
  const it = {
    it_signature: it_signature,
    it_signature_item: it_signature_item$1,
    it_value_description: it_value_description,
    it_type_declaration: it_type_declaration,
    it_extension_constructor: it_extension_constructor,
    it_module_declaration: it_module_declaration,
    it_modtype_declaration: it_modtype_declaration,
    it_class_declaration: it_class_declaration,
    it_class_type_declaration: it_class_type_declaration,
    it_module_type: it_module_type,
    it_class_type: it_class_type,
    it_type_kind: it_type_kind,
    it_do_type_expr: it_do_type_expr,
    it_type_expr: it_type_expr,
    it_path: it_path
  };
  it_module_type(it, mty);
  it_module_type(unmark_iterators, mty);
  return Curry._3(fold$6, (function (p) {
                return Curry._1(union$5, collect_ids(subst.contents, bindings.contents, p));
              }), paths.contents, /* Empty */0);
}

function remove_aliases(env, excl, _mty) {
  while(true) {
    const mty = _mty;
    switch (mty.TAG | 0) {
      case /* Mty_signature */1 :
          return {
                  TAG: /* Mty_signature */1,
                  _0: remove_aliases_sig(env, excl, mty._0)
                };
      case /* Mty_ident */0 :
      case /* Mty_functor */2 :
          return mty;
      case /* Mty_alias */3 :
          const mty$p = scrape_alias(env, undefined, mty);
          if (Caml_obj.caml_equal(mty$p, mty)) {
            return mty;
          }
          _mty = mty$p;
          continue ;
      
    }
  };
}

function remove_aliases_sig(env, excl, sg) {
  if (!sg) {
    return /* [] */0;
  }
  const it = sg.hd;
  switch (it.TAG | 0) {
    case /* Sig_module */3 :
        const md = it._1;
        const id = it._0;
        const mty = md.md_type;
        let mty$1;
        mty$1 = mty.TAG === /* Mty_alias */3 && Curry._2(mem$5, id, excl) ? md.md_type : remove_aliases(env, excl, mty);
        return {
                hd: {
                  TAG: /* Sig_module */3,
                  _0: id,
                  _1: {
                    md_type: mty$1,
                    md_attributes: md.md_attributes,
                    md_loc: md.md_loc
                  },
                  _2: it._2
                },
                tl: remove_aliases_sig(add_module$1(undefined, id, mty$1, env), excl, sg.tl)
              };
    case /* Sig_modtype */4 :
        const mtd = it._1;
        const id$1 = it._0;
        return {
                hd: {
                  TAG: /* Sig_modtype */4,
                  _0: id$1,
                  _1: mtd
                },
                tl: remove_aliases_sig(add_modtype$1(id$1, mtd, env), excl, sg.tl)
              };
    default:
      return {
              hd: it,
              tl: remove_aliases_sig(env, excl, sg.tl)
            };
  }
}

function remove_aliases$1(env, sg) {
  const excl = collect_arg_paths(sg);
  return remove_aliases(env, excl, sg);
}

const $$Error$5 = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Includemod.Error");

function value_descriptions(env, cxt, subst, id, vd1, vd2) {
  record_value_dependency(vd1, vd2);
  mark_value_used(env, id.name, vd1);
  const vd2$1 = value_description(subst, vd2);
  try {
    if (moregeneral(env, true, vd1.val_type, vd2$1.val_type)) {
      const match = vd1.val_kind;
      const match$1 = vd2$1.val_kind;
      if (typeof match !== "number" && match.TAG === /* Val_prim */0) {
        const p1 = match._0;
        if (typeof match$1 === "number") {
          return {
                  TAG: /* Tcoerce_primitive */2,
                  _0: id,
                  _1: p1
                };
        }
        if (match$1.TAG !== /* Val_prim */0) {
          return {
                  TAG: /* Tcoerce_primitive */2,
                  _0: id,
                  _1: p1
                };
        }
        if (Caml_obj.caml_equal(p1, match$1._0)) {
          return /* Tcoerce_none */0;
        }
        throw new Caml_js_exceptions.MelangeError(Dont_match, {
                  MEL_EXN_ID: Dont_match
                });
      }
      if (typeof match$1 === "number") {
        return /* Tcoerce_none */0;
      }
      if (match$1.TAG !== /* Val_prim */0) {
        return /* Tcoerce_none */0;
      }
      throw new Caml_js_exceptions.MelangeError(Dont_match, {
                MEL_EXN_ID: Dont_match
              });
    } else {
      throw new Caml_js_exceptions.MelangeError(Dont_match, {
                MEL_EXN_ID: Dont_match
              });
    }
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Dont_match) {
      throw new Caml_js_exceptions.MelangeError($$Error$5, {
                MEL_EXN_ID: $$Error$5,
                _1: {
                  hd: [
                    cxt,
                    env,
                    {
                      TAG: /* Value_descriptions */1,
                      _0: id,
                      _1: vd1,
                      _2: vd2$1
                    }
                  ],
                  tl: /* [] */0
                }
              });
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function type_declarations$2(env, old_envOpt, cxt, subst, id, decl1, decl2) {
  const old_env = old_envOpt !== undefined ? Caml_option.valFromOption(old_envOpt) : env;
  mark_type_used(env, id.name, decl1);
  const decl2$1 = type_declaration(subst, decl2);
  const err = type_declarations$1(undefined, env, id.name, decl1, id, decl2$1);
  if (!Caml_obj.caml_notequal(err, /* [] */0)) {
    return ;
  }
  throw new Caml_js_exceptions.MelangeError($$Error$5, {
            MEL_EXN_ID: $$Error$5,
            _1: {
              hd: [
                cxt,
                old_env,
                {
                  TAG: /* Type_declarations */2,
                  _0: id,
                  _1: decl1,
                  _2: decl2$1,
                  _3: err
                }
              ],
              tl: /* [] */0
            }
          });
}

function extension_constructors$1(env, cxt, subst, id, ext1, ext2) {
  const ext2$1 = extension_constructor(subst, ext2);
  if (extension_constructors(env, id, ext1, ext2$1)) {
    return ;
  }
  throw new Caml_js_exceptions.MelangeError($$Error$5, {
            MEL_EXN_ID: $$Error$5,
            _1: {
              hd: [
                cxt,
                env,
                {
                  TAG: /* Extension_constructors */3,
                  _0: id,
                  _1: ext1,
                  _2: ext2$1
                }
              ],
              tl: /* [] */0
            }
          });
}

function class_type_declarations$1(old_env, env, cxt, subst, id, decl1, decl2) {
  const decl2$1 = cltype_declaration(subst, decl2);
  const reason = class_type_declarations(env, decl1, decl2$1);
  if (!reason) {
    return ;
  }
  throw new Caml_js_exceptions.MelangeError($$Error$5, {
            MEL_EXN_ID: $$Error$5,
            _1: {
              hd: [
                cxt,
                old_env,
                {
                  TAG: /* Class_type_declarations */7,
                  _0: id,
                  _1: decl1,
                  _2: decl2$1,
                  _3: reason
                }
              ],
              tl: /* [] */0
            }
          });
}

function class_declarations$1(old_env, env, cxt, subst, id, decl1, decl2) {
  const decl2$1 = class_declaration(subst, decl2);
  const reason = class_declarations(env, decl1, decl2$1);
  if (!reason) {
    return ;
  }
  throw new Caml_js_exceptions.MelangeError($$Error$5, {
            MEL_EXN_ID: $$Error$5,
            _1: {
              hd: [
                cxt,
                old_env,
                {
                  TAG: /* Class_declarations */8,
                  _0: id,
                  _1: decl1,
                  _2: decl2$1,
                  _3: reason
                }
              ],
              tl: /* [] */0
            }
          });
}

const Dont_match$1 = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Includemod.Dont_match");

function may_expand_module_path(env, path) {
  try {
    find_modtype_expansion(path, env);
    return true;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return false;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function expand_module_path(env, cxt, path) {
  try {
    return find_modtype_expansion(path, env);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      throw new Caml_js_exceptions.MelangeError($$Error$5, {
                MEL_EXN_ID: $$Error$5,
                _1: {
                  hd: [
                    cxt,
                    env,
                    {
                      TAG: /* Unbound_modtype_path */9,
                      _0: path
                    }
                  ],
                  tl: /* [] */0
                }
              });
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function expand_module_alias(env, cxt, path) {
  try {
    return find_module(false, path, env).md_type;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      throw new Caml_js_exceptions.MelangeError($$Error$5, {
                MEL_EXN_ID: $$Error$5,
                _1: {
                  hd: [
                    cxt,
                    env,
                    {
                      TAG: /* Unbound_module_path */10,
                      _0: path
                    }
                  ],
                  tl: /* [] */0
                }
              });
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function kind_of_field_desc(param) {
  switch (param.TAG | 0) {
    case /* Field_value */0 :
        return "value";
    case /* Field_type */1 :
        return "type";
    case /* Field_typext */2 :
        return "extension constructor";
    case /* Field_module */3 :
        return "module";
    case /* Field_modtype */4 :
        return "module type";
    case /* Field_class */5 :
        return "class";
    case /* Field_classtype */6 :
        return "class type";
    
  }
}

function item_ident_name(param) {
  switch (param.TAG | 0) {
    case /* Sig_value */0 :
        const id = param._0;
        return [
                id,
                param._1.val_loc,
                {
                  TAG: /* Field_value */0,
                  _0: id.name
                }
              ];
    case /* Sig_type */1 :
        const id$1 = param._0;
        return [
                id$1,
                param._1.type_loc,
                {
                  TAG: /* Field_type */1,
                  _0: id$1.name
                }
              ];
    case /* Sig_typext */2 :
        const id$2 = param._0;
        return [
                id$2,
                param._1.ext_loc,
                {
                  TAG: /* Field_typext */2,
                  _0: id$2.name
                }
              ];
    case /* Sig_module */3 :
        const id$3 = param._0;
        return [
                id$3,
                param._1.md_loc,
                {
                  TAG: /* Field_module */3,
                  _0: id$3.name
                }
              ];
    case /* Sig_modtype */4 :
        const id$4 = param._0;
        return [
                id$4,
                param._1.mtd_loc,
                {
                  TAG: /* Field_modtype */4,
                  _0: id$4.name
                }
              ];
    case /* Sig_class */5 :
        const id$5 = param._0;
        return [
                id$5,
                param._1.cty_loc,
                {
                  TAG: /* Field_class */5,
                  _0: id$5.name
                }
              ];
    case /* Sig_class_type */6 :
        const id$6 = param._0;
        return [
                id$6,
                param._1.clty_loc,
                {
                  TAG: /* Field_classtype */6,
                  _0: id$6.name
                }
              ];
    
  }
}

function is_runtime_component(param) {
  switch (param.TAG | 0) {
    case /* Sig_value */0 :
        let tmp = param._1.val_kind;
        if (typeof tmp === "number" || tmp.TAG !== /* Val_prim */0) {
          return true;
        } else {
          return false;
        }
    case /* Sig_typext */2 :
    case /* Sig_module */3 :
    case /* Sig_class */5 :
        return true;
    default:
      return false;
  }
}

function modtypes(env, cxt, subst, mty1, mty2) {
  try {
    return try_modtypes(env, cxt, subst, mty1, mty2);
  }
  catch (raw_err){
    const err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.MEL_EXN_ID === Dont_match$1) {
      throw new Caml_js_exceptions.MelangeError($$Error$5, {
                MEL_EXN_ID: $$Error$5,
                _1: {
                  hd: [
                    cxt,
                    env,
                    {
                      TAG: /* Module_types */4,
                      _0: mty1,
                      _1: modtype(subst, mty2)
                    }
                  ],
                  tl: /* [] */0
                }
              });
    }
    if (err.MEL_EXN_ID === $$Error$5) {
      if (mty1.TAG === /* Mty_alias */3) {
        throw new Caml_js_exceptions.MelangeError(err.MEL_EXN_ID, err);
      }
      if (mty2.TAG === /* Mty_alias */3) {
        throw new Caml_js_exceptions.MelangeError(err.MEL_EXN_ID, err);
      }
      throw new Caml_js_exceptions.MelangeError($$Error$5, {
                MEL_EXN_ID: $$Error$5,
                _1: {
                  hd: [
                    cxt,
                    env,
                    {
                      TAG: /* Module_types */4,
                      _0: mty1,
                      _1: modtype(subst, mty2)
                    }
                  ],
                  tl: err._1
                }
              });
    }
    throw new Caml_js_exceptions.MelangeError(err.MEL_EXN_ID, err);
  }
}

function try_modtypes(env, cxt, subst, _mty1, mty2) {
  while(true) {
    const mty1 = _mty1;
    switch (mty1.TAG | 0) {
      case /* Mty_ident */0 :
          const p1 = mty1._0;
          if (may_expand_module_path(env, p1)) {
            _mty1 = expand_module_path(env, cxt, p1);
            continue ;
          }
          break;
      case /* Mty_signature */1 :
          switch (mty2.TAG | 0) {
            case /* Mty_ident */0 :
                break;
            case /* Mty_signature */1 :
                return signatures(env, cxt, subst, mty1._0, mty2._0);
            case /* Mty_functor */2 :
            case /* Mty_alias */3 :
                throw new Caml_js_exceptions.MelangeError(Dont_match$1, {
                          MEL_EXN_ID: Dont_match$1
                        });
            
          }
          break;
      case /* Mty_functor */2 :
          const arg1 = mty1._1;
          const param1 = mty1._0;
          if (arg1 !== undefined) {
            switch (mty2.TAG | 0) {
              case /* Mty_ident */0 :
                  break;
              case /* Mty_functor */2 :
                  const arg2 = mty2._1;
                  if (arg2 !== undefined) {
                    const arg2$p = modtype(subst, arg2);
                    const cc_arg = modtypes(env, {
                          hd: {
                            TAG: /* Arg */2,
                            _0: param1
                          },
                          tl: cxt
                        }, identity, arg2$p, arg1);
                    const cc_res = modtypes(add_module$1(undefined, param1, arg2$p, env), {
                          hd: {
                            TAG: /* Body */3,
                            _0: param1
                          },
                          tl: cxt
                        }, add_module(mty2._0, {
                              TAG: /* Pident */0,
                              _0: param1
                            }, subst), mty1._2, mty2._2);
                    if (typeof cc_arg === "number" && typeof cc_res === "number") {
                      return /* Tcoerce_none */0;
                    } else {
                      return {
                              TAG: /* Tcoerce_functor */1,
                              _0: cc_arg,
                              _1: cc_res
                            };
                    }
                  }
                  throw new Caml_js_exceptions.MelangeError(Dont_match$1, {
                            MEL_EXN_ID: Dont_match$1
                          });
              case /* Mty_signature */1 :
              case /* Mty_alias */3 :
                  throw new Caml_js_exceptions.MelangeError(Dont_match$1, {
                            MEL_EXN_ID: Dont_match$1
                          });
              
            }
          } else {
            switch (mty2.TAG | 0) {
              case /* Mty_ident */0 :
                  break;
              case /* Mty_functor */2 :
                  if (mty2._1 !== undefined) {
                    throw new Caml_js_exceptions.MelangeError(Dont_match$1, {
                              MEL_EXN_ID: Dont_match$1
                            });
                  }
                  const cc = modtypes(env, {
                        hd: {
                          TAG: /* Body */3,
                          _0: param1
                        },
                        tl: cxt
                      }, subst, mty1._2, mty2._2);
                  if (typeof cc === "number") {
                    return /* Tcoerce_none */0;
                  } else {
                    return {
                            TAG: /* Tcoerce_functor */1,
                            _0: /* Tcoerce_none */0,
                            _1: cc
                          };
                  }
              case /* Mty_signature */1 :
              case /* Mty_alias */3 :
                  throw new Caml_js_exceptions.MelangeError(Dont_match$1, {
                            MEL_EXN_ID: Dont_match$1
                          });
              
            }
          }
          break;
      case /* Mty_alias */3 :
          const p1$1 = mty1._0;
          if (mty2.TAG === /* Mty_alias */3) {
            const p2 = mty2._0;
            if (is_functor_arg(p2, env)) {
              throw new Caml_js_exceptions.MelangeError($$Error$5, {
                        MEL_EXN_ID: $$Error$5,
                        _1: {
                          hd: [
                            cxt,
                            env,
                            {
                              TAG: /* Invalid_module_alias */11,
                              _0: p2
                            }
                          ],
                          tl: /* [] */0
                        }
                      });
            }
            if (same(p1$1, p2)) {
              return /* Tcoerce_none */0;
            }
            const p1$2 = normalize_path$1(undefined, env, p1$1);
            const p2$1 = normalize_path$1(undefined, env, module_path(subst, p2));
            if (same(p1$2, p2$1)) {
              return /* Tcoerce_none */0;
            }
            throw new Caml_js_exceptions.MelangeError(Dont_match$1, {
                      MEL_EXN_ID: Dont_match$1
                    });
          }
          let p1$3;
          try {
            p1$3 = normalize_path$1(none, env, p1$1);
          }
          catch (raw_exn){
            const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.MEL_EXN_ID === $$Error$2) {
              const match = exn._1;
              if (match.TAG === /* Missing_module */3) {
                throw new Caml_js_exceptions.MelangeError($$Error$5, {
                          MEL_EXN_ID: $$Error$5,
                          _1: {
                            hd: [
                              cxt,
                              env,
                              {
                                TAG: /* Unbound_module_path */10,
                                _0: match._2
                              }
                            ],
                            tl: /* [] */0
                          }
                        });
              }
              throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
            }
            throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
          }
          const mty1$1 = strengthen$1(env, expand_module_alias(env, cxt, p1$3), p1$3);
          return {
                  TAG: /* Tcoerce_alias */3,
                  _0: p1$3,
                  _1: modtypes(env, cxt, subst, mty1$1, mty2)
                };
      
    }
    if (mty2.TAG === /* Mty_ident */0) {
      let mty2$1 = modtype(subst, mty2);
      if (mty1.TAG === /* Mty_ident */0) {
        if (mty2$1.TAG === /* Mty_ident */0) {
          if (same(mty1._0, mty2$1._0)) {
            return /* Tcoerce_none */0;
          }
          
        } else {
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                    MEL_EXN_ID: "Assert_failure",
                    _1: [
                      "jscomp/test/ocaml_typedtree_test.ml",
                      38374,
                      6
                    ]
                  });
        }
      }
      if (mty2$1.TAG === /* Mty_ident */0) {
        return try_modtypes(env, cxt, identity, mty1, expand_module_path(env, cxt, mty2$1._0));
      }
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  38374,
                  6
                ]
              });
    }
    throw new Caml_js_exceptions.MelangeError(Dont_match$1, {
              MEL_EXN_ID: Dont_match$1
            });
  };
}

function signatures(env, cxt, subst, sig1, sig2) {
  const new_env = add_signature(sig1, in_signature(env));
  const match = Stdlib__List.fold_left((function (param, item) {
          const pos = param[1];
          const l = param[0];
          if (item.TAG === /* Sig_module */3) {
            return [
                    {
                      hd: [
                        item._0,
                        pos,
                        /* Tcoerce_none */0
                      ],
                      tl: l
                    },
                    pos + 1 | 0
                  ];
          } else {
            return [
                    l,
                    is_runtime_component(item) ? pos + 1 | 0 : pos
                  ];
          }
        }), [
        /* [] */0,
        0
      ], sig1);
  const id_pos_list = match[0];
  const build_component_table = function (_pos, _tbl, _param) {
    while(true) {
      const param = _param;
      const tbl = _tbl;
      const pos = _pos;
      if (!param) {
        return [
                pos,
                tbl
              ];
      }
      const item = param.hd;
      const match = item_ident_name(item);
      const nextpos = is_runtime_component(item) ? pos + 1 | 0 : pos;
      _param = param.tl;
      _tbl = add$5(match[2], [
            match[0],
            item,
            pos
          ], tbl);
      _pos = nextpos;
      continue ;
    };
  };
  const match$1 = build_component_table(0, /* Empty */0, sig1);
  const comps1 = match$1[1];
  const len1 = match$1[0];
  const len2 = Stdlib__List.fold_left((function (n, i) {
          if (is_runtime_component(i)) {
            return n + 1 | 0;
          } else {
            return n;
          }
        }), 0, sig2);
  const pair_components = function (subst, paired, _unpaired, _param) {
    while(true) {
      const param = _param;
      const unpaired = _unpaired;
      if (param) {
        const rem = param.tl;
        const item2 = param.hd;
        const match = item_ident_name(item2);
        const name2 = match[2];
        const id2 = match[0];
        let match$1;
        if (item2.TAG === /* Sig_type */1 && !(item2._1.type_manifest !== undefined || name2.TAG !== /* Field_type */1)) {
          const s = name2._0;
          const l = s.length;
          match$1 = l >= 4 && Stdlib__String.sub(s, l - 4 | 0, 4) === "#row" ? [
              {
                TAG: /* Field_type */1,
                _0: Stdlib__String.sub(s, 0, s.length - 4 | 0)
              },
              false
            ] : [
              name2,
              true
            ];
        } else {
          match$1 = [
            name2,
            true
          ];
        }
        const name2$1 = match$1[0];
        try {
          const match$2 = find$2(name2$1, comps1);
          const id1 = match$2[0];
          let new_subst;
          switch (item2.TAG | 0) {
            case /* Sig_type */1 :
                new_subst = add_type(id2, {
                      TAG: /* Pident */0,
                      _0: id1
                    }, subst);
                break;
            case /* Sig_module */3 :
                new_subst = add_module(id2, {
                      TAG: /* Pident */0,
                      _0: id1
                    }, subst);
                break;
            case /* Sig_modtype */4 :
                new_subst = add_modtype(id2, {
                      TAG: /* Mty_ident */0,
                      _0: {
                        TAG: /* Pident */0,
                        _0: id1
                      }
                    }, subst);
                break;
            default:
              new_subst = subst;
          }
          return pair_components(new_subst, {
                      hd: [
                        match$2[1],
                        item2,
                        match$2[2]
                      ],
                      tl: paired
                    }, unpaired, rem);
        }
        catch (raw_exn){
          const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.MEL_EXN_ID === Stdlib.Not_found) {
            const unpaired$1 = match$1[1] ? ({
                  hd: [
                    cxt,
                    env,
                    {
                      TAG: /* Missing_field */0,
                      _0: id2,
                      _1: match[1],
                      _2: kind_of_field_desc(name2$1)
                    }
                  ],
                  tl: unpaired
                }) : unpaired;
            _param = rem;
            _unpaired = unpaired$1;
            continue ;
          }
          throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
        }
      } else {
        if (unpaired) {
          throw new Caml_js_exceptions.MelangeError($$Error$5, {
                    MEL_EXN_ID: $$Error$5,
                    _1: unpaired
                  });
        }
        const cc = signature_components(env, new_env, cxt, subst, Stdlib__List.rev(paired));
        if (len1 === len2) {
          const is_identity_coercion = function (_pos, _param) {
            while(true) {
              const param = _param;
              const pos = _pos;
              if (!param) {
                return true;
              }
              const match = param.hd;
              if (match[0] !== pos) {
                return false;
              }
              if (!Caml_obj.caml_equal(match[1], /* Tcoerce_none */0)) {
                return false;
              }
              _param = param.tl;
              _pos = pos + 1 | 0;
              continue ;
            };
          };
          if (is_identity_coercion(0, cc)) {
            return /* Tcoerce_none */0;
          } else {
            return {
                    TAG: /* Tcoerce_structure */0,
                    _0: cc,
                    _1: id_pos_list
                  };
          }
        } else {
          return {
                  TAG: /* Tcoerce_structure */0,
                  _0: cc,
                  _1: id_pos_list
                };
        }
      }
    };
  };
  return pair_components(subst, /* [] */0, /* [] */0, sig2);
}

function signature_components(old_env, env, cxt, subst, paired) {
  const comps_rec = function (rem) {
    return signature_components(old_env, env, cxt, subst, rem);
  };
  if (!paired) {
    return /* [] */0;
  }
  const match = paired.hd;
  const match$1 = match[0];
  switch (match$1.TAG | 0) {
    case /* Sig_value */0 :
        const match$2 = match[1];
        if (match$2.TAG === /* Sig_value */0) {
          const rem = paired.tl;
          const pos = match[2];
          const valdecl2 = match$2._1;
          const cc = value_descriptions(env, cxt, subst, match$1._0, match$1._1, valdecl2);
          const p = valdecl2.val_kind;
          if (typeof p === "number" || p.TAG !== /* Val_prim */0) {
            return {
                    hd: [
                      pos,
                      cc
                    ],
                    tl: comps_rec(rem)
                  };
          } else {
            return comps_rec(rem);
          }
        }
        break;
    case /* Sig_type */1 :
        const match$3 = match[1];
        if (match$3.TAG === /* Sig_type */1) {
          type_declarations$2(env, Caml_option.some(old_env), cxt, subst, match$1._0, match$1._1, match$3._1);
          return comps_rec(paired.tl);
        }
        break;
    case /* Sig_typext */2 :
        const match$4 = match[1];
        if (match$4.TAG === /* Sig_typext */2) {
          extension_constructors$1(env, cxt, subst, match$1._0, match$1._1, match$4._1);
          return {
                  hd: [
                    match[2],
                    /* Tcoerce_none */0
                  ],
                  tl: comps_rec(paired.tl)
                };
        }
        break;
    case /* Sig_module */3 :
        const match$5 = match[1];
        if (match$5.TAG === /* Sig_module */3) {
          const id1 = match$1._0;
          const cc$1 = modtypes(env, {
                hd: {
                  TAG: /* Module */0,
                  _0: id1
                },
                tl: cxt
              }, subst, strengthen$1(env, match$1._1.md_type, {
                    TAG: /* Pident */0,
                    _0: id1
                  }), match$5._1.md_type);
          return {
                  hd: [
                    match[2],
                    cc$1
                  ],
                  tl: comps_rec(paired.tl)
                };
        }
        break;
    case /* Sig_modtype */4 :
        const match$6 = match[1];
        if (match$6.TAG === /* Sig_modtype */4) {
          modtype_infos(env, cxt, subst, match$1._0, match$1._1, match$6._1);
          return comps_rec(paired.tl);
        }
        break;
    case /* Sig_class */5 :
        const match$7 = match[1];
        if (match$7.TAG === /* Sig_class */5) {
          class_declarations$1(old_env, env, cxt, subst, match$1._0, match$1._1, match$7._1);
          return {
                  hd: [
                    match[2],
                    /* Tcoerce_none */0
                  ],
                  tl: comps_rec(paired.tl)
                };
        }
        break;
    case /* Sig_class_type */6 :
        const match$8 = match[1];
        if (match$8.TAG === /* Sig_class_type */6) {
          class_type_declarations$1(old_env, env, cxt, subst, match$1._0, match$1._1, match$8._1);
          return comps_rec(paired.tl);
        }
        break;
    
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              38499,
              6
            ]
          });
}

function modtype_infos(env, cxt, subst, id, info1, info2) {
  const info2$1 = modtype_declaration(subst, info2);
  const cxt$p_0 = {
    TAG: /* Modtype */1,
    _0: id
  };
  const cxt$p = {
    hd: cxt$p_0,
    tl: cxt
  };
  try {
    const match = info1.mtd_type;
    const match$1 = info2$1.mtd_type;
    if (match !== undefined) {
      if (match$1 !== undefined) {
        return check_modtype_equiv(env, cxt$p, match, match$1);
      } else {
        return ;
      }
    } else if (match$1 !== undefined) {
      return check_modtype_equiv(env, cxt$p, {
                  TAG: /* Mty_ident */0,
                  _0: {
                    TAG: /* Pident */0,
                    _0: id
                  }
                }, match$1);
    } else {
      return ;
    }
  }
  catch (raw_reasons){
    const reasons = Caml_js_exceptions.internalToOCamlException(raw_reasons);
    if (reasons.MEL_EXN_ID === $$Error$5) {
      throw new Caml_js_exceptions.MelangeError($$Error$5, {
                MEL_EXN_ID: $$Error$5,
                _1: {
                  hd: [
                    cxt,
                    env,
                    {
                      TAG: /* Modtype_infos */5,
                      _0: id,
                      _1: info1,
                      _2: info2$1
                    }
                  ],
                  tl: reasons._1
                }
              });
    }
    throw new Caml_js_exceptions.MelangeError(reasons.MEL_EXN_ID, reasons);
  }
}

function check_modtype_equiv(env, cxt, mty1, mty2) {
  const match = modtypes(env, cxt, identity, mty1, mty2);
  const match$1 = modtypes(env, cxt, identity, mty2, mty1);
  if (typeof match === "number" && typeof match$1 === "number") {
    return ;
  }
  throw new Caml_js_exceptions.MelangeError($$Error$5, {
            MEL_EXN_ID: $$Error$5,
            _1: {
              hd: [
                cxt,
                env,
                /* Modtype_permutation */0
              ],
              tl: /* [] */0
            }
          });
}

function check_modtype_inclusion$1(env, mty1, path1, mty2) {
  try {
    modtypes(env, /* [] */0, identity, strengthen$1(env, mty1, path1), mty2);
    return ;
  }
  catch (raw_reasons){
    const reasons = Caml_js_exceptions.internalToOCamlException(raw_reasons);
    if (reasons.MEL_EXN_ID === $$Error$5) {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
    }
    throw new Caml_js_exceptions.MelangeError(reasons.MEL_EXN_ID, reasons);
  }
}

check_modtype_inclusion.contents = check_modtype_inclusion$1;

function compunit(env, impl_name, impl_sig, intf_name, intf_sig) {
  try {
    return signatures(env, /* [] */0, identity, impl_sig, intf_sig);
  }
  catch (raw_reasons){
    const reasons = Caml_js_exceptions.internalToOCamlException(raw_reasons);
    if (reasons.MEL_EXN_ID === $$Error$5) {
      throw new Caml_js_exceptions.MelangeError($$Error$5, {
                MEL_EXN_ID: $$Error$5,
                _1: {
                  hd: [
                    /* [] */0,
                    empty,
                    {
                      TAG: /* Interface_mismatch */6,
                      _0: impl_name,
                      _1: intf_name
                    }
                  ],
                  tl: reasons._1
                }
              });
    }
    throw new Caml_js_exceptions.MelangeError(reasons.MEL_EXN_ID, reasons);
  }
}

function modtypes$1(env, mty1, mty2) {
  return modtypes(env, /* [] */0, identity, mty1, mty2);
}

function type_declarations$3(env, id, decl1, decl2) {
  type_declarations$2(env, undefined, /* [] */0, identity, id, decl1, decl2);
}

function show_loc(msg, ppf, loc) {
  const pos = loc.loc_start;
  if (Stdlib__List.mem(pos.pos_fname, {
          hd: "",
          tl: {
            hd: "_none_",
            tl: {
              hd: "//toplevel//",
              tl: /* [] */0
            }
          }
        })) {
    return ;
  } else {
    return Curry._3(Stdlib__Format.fprintf(ppf)(/* Format */{
                    _0: {
                      TAG: /* Formatting_lit */17,
                      _0: /* Force_newline */3,
                      _1: {
                        TAG: /* Formatting_gen */18,
                        _0: {
                          TAG: /* Open_box */1,
                          _0: /* Format */{
                            _0: {
                              TAG: /* String_literal */11,
                              _0: "<2>",
                              _1: /* End_of_format */0
                            },
                            _1: "<2>"
                          }
                        },
                        _1: {
                          TAG: /* Alpha */15,
                          _0: {
                            TAG: /* Char_literal */12,
                            _0: /* ':' */58,
                            _1: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@ ",
                                _1: 1,
                                _2: 0
                              },
                              _1: {
                                TAG: /* String */2,
                                _0: /* No_padding */0,
                                _1: {
                                  TAG: /* Formatting_lit */17,
                                  _0: /* Close_box */0,
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    _1: "@\n@[<2>%a:@ %s@]"
                  }), print_loc, loc, msg);
  }
}

function show_locs(ppf, param) {
  show_loc("Expected declaration", ppf, param[1]);
  show_loc("Actual declaration", ppf, param[0]);
}

function include_err$1(ppf, path$1) {
  if (typeof path$1 === "number") {
    return Stdlib__Format.fprintf(ppf)(/* Format */{
                _0: {
                  TAG: /* String_literal */11,
                  _0: "Illegal permutation of structure fields",
                  _1: /* End_of_format */0
                },
                _1: "Illegal permutation of structure fields"
              });
  }
  switch (path$1.TAG | 0) {
    case /* Missing_field */0 :
        Curry._3(Stdlib__Format.fprintf(ppf)(/* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "The ",
                    _1: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* String_literal */11,
                        _0: " `",
                        _1: {
                          TAG: /* Alpha */15,
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "' is required but not provided",
                            _1: /* End_of_format */0
                          }
                        }
                      }
                    }
                  },
                  _1: "The %s `%a' is required but not provided"
                }), path$1._2, ident$3, path$1._0);
        return show_loc("Expected declaration", ppf, path$1._1);
    case /* Value_descriptions */1 :
        const d2 = path$1._2;
        const d1 = path$1._1;
        const id = path$1._0;
        Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                  _0: {
                    TAG: /* Formatting_gen */18,
                    _0: {
                      TAG: /* Open_box */1,
                      _0: /* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "<hv 2>",
                          _1: /* End_of_format */0
                        },
                        _1: "<hv 2>"
                      }
                    },
                    _1: {
                      TAG: /* String_literal */11,
                      _0: "Values do not match:",
                      _1: {
                        TAG: /* Formatting_lit */17,
                        _0: {
                          TAG: /* Break */0,
                          _0: "@ ",
                          _1: 1,
                          _2: 0
                        },
                        _1: {
                          TAG: /* Alpha */15,
                          _0: {
                            TAG: /* Formatting_lit */17,
                            _0: {
                              TAG: /* Break */0,
                              _0: "@;<1 -2>",
                              _1: 1,
                              _2: -2
                            },
                            _1: {
                              TAG: /* String_literal */11,
                              _0: "is not included in",
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@ ",
                                  _1: 1,
                                  _2: 0
                                },
                                _1: {
                                  TAG: /* Alpha */15,
                                  _0: {
                                    TAG: /* Formatting_lit */17,
                                    _0: /* Close_box */0,
                                    _1: /* End_of_format */0
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  _1: "@[<hv 2>Values do not match:@ %a@;<1 -2>is not included in@ %a@]"
                }), (function (param, param$1) {
                return value_description$1(id, param, param$1);
              }), d1, (function (param, param$1) {
                return value_description$1(id, param, param$1);
              }), d2);
        return show_locs(ppf, [
                    d1.val_loc,
                    d2.val_loc
                  ]);
    case /* Type_declarations */2 :
        const d2$1 = path$1._2;
        const d1$1 = path$1._1;
        const id$1 = path$1._0;
        return Curry.app(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<v>",
                                _1: /* End_of_format */0
                              },
                              _1: "<v>"
                            }
                          },
                          _1: {
                            TAG: /* Formatting_gen */18,
                            _0: {
                              TAG: /* Open_box */1,
                              _0: /* Format */{
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: "<hv>",
                                  _1: /* End_of_format */0
                                },
                                _1: "<hv>"
                              }
                            },
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Char_literal */12,
                                _0: /* ':' */58,
                                _1: {
                                  TAG: /* Formatting_lit */17,
                                  _0: {
                                    TAG: /* Break */0,
                                    _0: "@;<1 2>",
                                    _1: 1,
                                    _2: 2
                                  },
                                  _1: {
                                    TAG: /* Alpha */15,
                                    _0: {
                                      TAG: /* Formatting_lit */17,
                                      _0: {
                                        TAG: /* Break */0,
                                        _0: "@ ",
                                        _1: 1,
                                        _2: 0
                                      },
                                      _1: {
                                        TAG: /* String */2,
                                        _0: /* No_padding */0,
                                        _1: {
                                          TAG: /* Formatting_lit */17,
                                          _0: {
                                            TAG: /* Break */0,
                                            _0: "@;<1 2>",
                                            _1: 1,
                                            _2: 2
                                          },
                                          _1: {
                                            TAG: /* Alpha */15,
                                            _0: {
                                              TAG: /* Formatting_lit */17,
                                              _0: /* Close_box */0,
                                              _1: {
                                                TAG: /* Alpha */15,
                                                _0: {
                                                  TAG: /* Alpha */15,
                                                  _0: {
                                                    TAG: /* Formatting_lit */17,
                                                    _0: /* Close_box */0,
                                                    _1: /* End_of_format */0
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@[<v>@[<hv>%s:@;<1 2>%a@ %s@;<1 2>%a@]%a%a@]"
                      }), [
                    "Type declarations do not match",
                    (function (param, param$1) {
                        return type_declaration$1(id$1, param, param$1);
                      }),
                    d1$1,
                    "is not included in",
                    (function (param, param$1) {
                        return type_declaration$1(id$1, param, param$1);
                      }),
                    d2$1,
                    show_locs,
                    [
                      d1$1.type_loc,
                      d2$1.type_loc
                    ],
                    (function (param) {
                        return report_type_mismatch("the first", "the second", "declaration", param);
                      }),
                    path$1._3
                  ]);
    case /* Extension_constructors */3 :
        const x2 = path$1._2;
        const x1 = path$1._1;
        const id$2 = path$1._0;
        Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                  _0: {
                    TAG: /* Formatting_gen */18,
                    _0: {
                      TAG: /* Open_box */1,
                      _0: /* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "<hv 2>",
                          _1: /* End_of_format */0
                        },
                        _1: "<hv 2>"
                      }
                    },
                    _1: {
                      TAG: /* String_literal */11,
                      _0: "Extension declarations do not match:",
                      _1: {
                        TAG: /* Formatting_lit */17,
                        _0: {
                          TAG: /* Break */0,
                          _0: "@ ",
                          _1: 1,
                          _2: 0
                        },
                        _1: {
                          TAG: /* Alpha */15,
                          _0: {
                            TAG: /* Formatting_lit */17,
                            _0: {
                              TAG: /* Break */0,
                              _0: "@;<1 -2>",
                              _1: 1,
                              _2: -2
                            },
                            _1: {
                              TAG: /* String_literal */11,
                              _0: "is not included in",
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@ ",
                                  _1: 1,
                                  _2: 0
                                },
                                _1: {
                                  TAG: /* Alpha */15,
                                  _0: {
                                    TAG: /* Formatting_lit */17,
                                    _0: /* Close_box */0,
                                    _1: /* End_of_format */0
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  _1: "@[<hv 2>Extension declarations do not match:@ %a@;<1 -2>is not included in@ %a@]"
                }), (function (param, param$1) {
                return extension_constructor$1(id$2, param, param$1);
              }), x1, (function (param, param$1) {
                return extension_constructor$1(id$2, param, param$1);
              }), x2);
        return show_locs(ppf, [
                    x1.ext_loc,
                    x2.ext_loc
                  ]);
    case /* Module_types */4 :
        return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<hv 2>",
                                _1: /* End_of_format */0
                              },
                              _1: "<hv 2>"
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "Modules do not match:",
                            _1: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@ ",
                                _1: 1,
                                _2: 0
                              },
                              _1: {
                                TAG: /* Alpha */15,
                                _0: {
                                  TAG: /* Formatting_lit */17,
                                  _0: {
                                    TAG: /* Break */0,
                                    _0: "@;<1 -2>",
                                    _1: 1,
                                    _2: -2
                                  },
                                  _1: {
                                    TAG: /* String_literal */11,
                                    _0: "is not included in",
                                    _1: {
                                      TAG: /* Formatting_lit */17,
                                      _0: {
                                        TAG: /* Break */0,
                                        _0: "@ ",
                                        _1: 1,
                                        _2: 0
                                      },
                                      _1: {
                                        TAG: /* Alpha */15,
                                        _0: {
                                          TAG: /* Formatting_lit */17,
                                          _0: /* Close_box */0,
                                          _1: /* End_of_format */0
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@[<hv 2>Modules do not match:@ %a@;<1 -2>is not included in@ %a@]"
                      }), modtype$1, path$1._0, modtype$1, path$1._1);
    case /* Modtype_infos */5 :
        const id$3 = path$1._0;
        return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<hv 2>",
                                _1: /* End_of_format */0
                              },
                              _1: "<hv 2>"
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "Module type declarations do not match:",
                            _1: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@ ",
                                _1: 1,
                                _2: 0
                              },
                              _1: {
                                TAG: /* Alpha */15,
                                _0: {
                                  TAG: /* Formatting_lit */17,
                                  _0: {
                                    TAG: /* Break */0,
                                    _0: "@;<1 -2>",
                                    _1: 1,
                                    _2: -2
                                  },
                                  _1: {
                                    TAG: /* String_literal */11,
                                    _0: "does not match",
                                    _1: {
                                      TAG: /* Formatting_lit */17,
                                      _0: {
                                        TAG: /* Break */0,
                                        _0: "@ ",
                                        _1: 1,
                                        _2: 0
                                      },
                                      _1: {
                                        TAG: /* Alpha */15,
                                        _0: {
                                          TAG: /* Formatting_lit */17,
                                          _0: /* Close_box */0,
                                          _1: /* End_of_format */0
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@[<hv 2>Module type declarations do not match:@ %a@;<1 -2>does not match@ %a@]"
                      }), (function (param, param$1) {
                      return modtype_declaration$1(id$3, param, param$1);
                    }), path$1._1, (function (param, param$1) {
                      return modtype_declaration$1(id$3, param, param$1);
                    }), path$1._2);
    case /* Interface_mismatch */6 :
        return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: /* End_of_format */0,
                              _1: ""
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "The implementation ",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@ ",
                                  _1: 1,
                                  _2: 0
                                },
                                _1: {
                                  TAG: /* String_literal */11,
                                  _0: "does not match the interface ",
                                  _1: {
                                    TAG: /* String */2,
                                    _0: /* No_padding */0,
                                    _1: {
                                      TAG: /* Char_literal */12,
                                      _0: /* ':' */58,
                                      _1: /* End_of_format */0
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@[The implementation %s@ does not match the interface %s:"
                      }), path$1._0, path$1._1);
    case /* Class_type_declarations */7 :
        const id$4 = path$1._0;
        return Curry._6(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<hv 2>",
                                _1: /* End_of_format */0
                              },
                              _1: "<hv 2>"
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "Class type declarations do not match:",
                            _1: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@ ",
                                _1: 1,
                                _2: 0
                              },
                              _1: {
                                TAG: /* Alpha */15,
                                _0: {
                                  TAG: /* Formatting_lit */17,
                                  _0: {
                                    TAG: /* Break */0,
                                    _0: "@;<1 -2>",
                                    _1: 1,
                                    _2: -2
                                  },
                                  _1: {
                                    TAG: /* String_literal */11,
                                    _0: "does not match",
                                    _1: {
                                      TAG: /* Formatting_lit */17,
                                      _0: {
                                        TAG: /* Break */0,
                                        _0: "@ ",
                                        _1: 1,
                                        _2: 0
                                      },
                                      _1: {
                                        TAG: /* Alpha */15,
                                        _0: {
                                          TAG: /* Formatting_lit */17,
                                          _0: /* Close_box */0,
                                          _1: {
                                            TAG: /* Formatting_lit */17,
                                            _0: {
                                              TAG: /* Break */0,
                                              _0: "@ ",
                                              _1: 1,
                                              _2: 0
                                            },
                                            _1: {
                                              TAG: /* Alpha */15,
                                              _0: /* End_of_format */0
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@[<hv 2>Class type declarations do not match:@ %a@;<1 -2>does not match@ %a@]@ %a"
                      }), (function (param, param$1) {
                      return cltype_declaration$1(id$4, param, param$1);
                    }), path$1._1, (function (param, param$1) {
                      return cltype_declaration$1(id$4, param, param$1);
                    }), path$1._2, report_error$3, path$1._3);
    case /* Class_declarations */8 :
        const id$5 = path$1._0;
        return Curry._6(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<hv 2>",
                                _1: /* End_of_format */0
                              },
                              _1: "<hv 2>"
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "Class declarations do not match:",
                            _1: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@ ",
                                _1: 1,
                                _2: 0
                              },
                              _1: {
                                TAG: /* Alpha */15,
                                _0: {
                                  TAG: /* Formatting_lit */17,
                                  _0: {
                                    TAG: /* Break */0,
                                    _0: "@;<1 -2>",
                                    _1: 1,
                                    _2: -2
                                  },
                                  _1: {
                                    TAG: /* String_literal */11,
                                    _0: "does not match",
                                    _1: {
                                      TAG: /* Formatting_lit */17,
                                      _0: {
                                        TAG: /* Break */0,
                                        _0: "@ ",
                                        _1: 1,
                                        _2: 0
                                      },
                                      _1: {
                                        TAG: /* Alpha */15,
                                        _0: {
                                          TAG: /* Formatting_lit */17,
                                          _0: /* Close_box */0,
                                          _1: {
                                            TAG: /* Formatting_lit */17,
                                            _0: {
                                              TAG: /* Break */0,
                                              _0: "@ ",
                                              _1: 1,
                                              _2: 0
                                            },
                                            _1: {
                                              TAG: /* Alpha */15,
                                              _0: /* End_of_format */0
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@[<hv 2>Class declarations do not match:@ %a@;<1 -2>does not match@ %a@]@ %a"
                      }), (function (param, param$1) {
                      return class_declaration$1(id$5, param, param$1);
                    }), path$1._1, (function (param, param$1) {
                      return class_declaration$1(id$5, param, param$1);
                    }), path$1._2, report_error$3, path$1._3);
    case /* Unbound_modtype_path */9 :
        return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "Unbound module type ",
                          _1: {
                            TAG: /* Alpha */15,
                            _0: /* End_of_format */0
                          }
                        },
                        _1: "Unbound module type %a"
                      }), path, path$1._0);
    case /* Unbound_module_path */10 :
        return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "Unbound module ",
                          _1: {
                            TAG: /* Alpha */15,
                            _0: /* End_of_format */0
                          }
                        },
                        _1: "Unbound module %a"
                      }), path, path$1._0);
    case /* Invalid_module_alias */11 :
        return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "Module ",
                          _1: {
                            TAG: /* Alpha */15,
                            _0: {
                              TAG: /* String_literal */11,
                              _0: " cannot be aliased",
                              _1: /* End_of_format */0
                            }
                          }
                        },
                        _1: "Module %a cannot be aliased"
                      }), path, path$1._0);
    
  }
}

function context(ppf, param) {
  if (!param) {
    return Stdlib__Format.fprintf(ppf)(/* Format */{
                _0: {
                  TAG: /* String_literal */11,
                  _0: "<here>",
                  _1: /* End_of_format */0
                },
                _1: "<here>"
              });
  }
  const id = param.hd;
  switch (id.TAG | 0) {
    case /* Module */0 :
        return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<2>",
                                _1: /* End_of_format */0
                              },
                              _1: "<2>"
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "module ",
                            _1: {
                              TAG: /* Alpha */15,
                              _0: {
                                TAG: /* Alpha */15,
                                _0: {
                                  TAG: /* Formatting_lit */17,
                                  _0: /* Close_box */0,
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          }
                        },
                        _1: "@[<2>module %a%a@]"
                      }), ident$3, id._0, args, param.tl);
    case /* Modtype */1 :
        return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<2>",
                                _1: /* End_of_format */0
                              },
                              _1: "<2>"
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "module type ",
                            _1: {
                              TAG: /* Alpha */15,
                              _0: {
                                TAG: /* String_literal */11,
                                _0: " =",
                                _1: {
                                  TAG: /* Formatting_lit */17,
                                  _0: {
                                    TAG: /* Break */0,
                                    _0: "@ ",
                                    _1: 1,
                                    _2: 0
                                  },
                                  _1: {
                                    TAG: /* Alpha */15,
                                    _0: {
                                      TAG: /* Formatting_lit */17,
                                      _0: /* Close_box */0,
                                      _1: /* End_of_format */0
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@[<2>module type %a =@ %a@]"
                      }), ident$3, id._0, context_mty, param.tl);
    case /* Arg */2 :
        return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "functor (",
                          _1: {
                            TAG: /* Alpha */15,
                            _0: {
                              TAG: /* String_literal */11,
                              _0: " : ",
                              _1: {
                                TAG: /* Alpha */15,
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: ") -> ...",
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          }
                        },
                        _1: "functor (%a : %a) -> ..."
                      }), ident$3, id._0, context_mty, param.tl);
    case /* Body */3 :
        return Curry._3(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "functor (",
                          _1: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: {
                              TAG: /* String_literal */11,
                              _0: ") ->",
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@ ",
                                  _1: 1,
                                  _2: 0
                                },
                                _1: {
                                  TAG: /* Alpha */15,
                                  _0: /* End_of_format */0
                                }
                              }
                            }
                          }
                        },
                        _1: "functor (%s) ->@ %a"
                      }), argname(id._0), context_mty, param.tl);
    
  }
}

function context_mty(ppf, rem) {
  if (!rem) {
    return context(ppf, rem);
  }
  switch (rem.hd.TAG | 0) {
    case /* Module */0 :
    case /* Modtype */1 :
        break;
    case /* Arg */2 :
    case /* Body */3 :
        return context(ppf, rem);
    
  }
  Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
            _0: {
              TAG: /* Formatting_gen */18,
              _0: {
                TAG: /* Open_box */1,
                _0: /* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "<2>",
                    _1: /* End_of_format */0
                  },
                  _1: "<2>"
                }
              },
              _1: {
                TAG: /* String_literal */11,
                _0: "sig",
                _1: {
                  TAG: /* Formatting_lit */17,
                  _0: {
                    TAG: /* Break */0,
                    _0: "@ ",
                    _1: 1,
                    _2: 0
                  },
                  _1: {
                    TAG: /* Alpha */15,
                    _0: {
                      TAG: /* Formatting_lit */17,
                      _0: {
                        TAG: /* Break */0,
                        _0: "@;<1 -2>",
                        _1: 1,
                        _2: -2
                      },
                      _1: {
                        TAG: /* String_literal */11,
                        _0: "end",
                        _1: {
                          TAG: /* Formatting_lit */17,
                          _0: /* Close_box */0,
                          _1: /* End_of_format */0
                        }
                      }
                    }
                  }
                }
              }
            },
            _1: "@[<2>sig@ %a@;<1 -2>end@]"
          }), context, rem);
}

function args(ppf, cxt) {
  if (cxt) {
    const x = cxt.hd;
    switch (x.TAG | 0) {
      case /* Module */0 :
      case /* Modtype */1 :
          break;
      case /* Arg */2 :
          return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* Char_literal */12,
                            _0: /* '(' */40,
                            _1: {
                              TAG: /* Alpha */15,
                              _0: {
                                TAG: /* String_literal */11,
                                _0: " :",
                                _1: {
                                  TAG: /* Formatting_lit */17,
                                  _0: {
                                    TAG: /* Break */0,
                                    _0: "@ ",
                                    _1: 1,
                                    _2: 0
                                  },
                                  _1: {
                                    TAG: /* Alpha */15,
                                    _0: {
                                      TAG: /* String_literal */11,
                                      _0: ") : ...",
                                      _1: /* End_of_format */0
                                    }
                                  }
                                }
                              }
                            }
                          },
                          _1: "(%a :@ %a) : ..."
                        }), ident$3, x._0, context_mty, cxt.tl);
      case /* Body */3 :
          return Curry._3(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* Char_literal */12,
                            _0: /* '(' */40,
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Char_literal */12,
                                _0: /* ')' */41,
                                _1: {
                                  TAG: /* Alpha */15,
                                  _0: /* End_of_format */0
                                }
                              }
                            }
                          },
                          _1: "(%s)%a"
                        }), argname(x._0), args, cxt.tl);
      
    }
  }
  Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
            _0: {
              TAG: /* String_literal */11,
              _0: " :",
              _1: {
                TAG: /* Formatting_lit */17,
                _0: {
                  TAG: /* Break */0,
                  _0: "@ ",
                  _1: 1,
                  _2: 0
                },
                _1: {
                  TAG: /* Alpha */15,
                  _0: /* End_of_format */0
                }
              }
            },
            _1: " :@ %a"
          }), context_mty, cxt);
}

function argname(x) {
  const s = x.name;
  if (s === "*") {
    return "";
  } else {
    return s;
  }
}

function path_of_context(param) {
  if (param) {
    const id = param.hd;
    if (id.TAG === /* Module */0) {
      let _path = {
        TAG: /* Pident */0,
        _0: id._0
      };
      let _param = param.tl;
      while(true) {
        const param$1 = _param;
        const path = _path;
        if (!param$1) {
          return path;
        }
        const id$1 = param$1.hd;
        if (id$1.TAG === /* Module */0) {
          _param = param$1.tl;
          _path = {
            TAG: /* Pdot */1,
            _0: path,
            _1: id$1._0.name,
            _2: -1
          };
          continue ;
        }
        throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                  MEL_EXN_ID: "Assert_failure",
                  _1: [
                    "jscomp/test/ocaml_typedtree_test.ml",
                    38670,
                    15
                  ]
                });
      };
    }
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                38672,
                9
              ]
            });
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              38672,
              9
            ]
          });
}

function context$1(ppf, cxt) {
  if (Caml_obj.caml_equal(cxt, /* [] */0)) {
    return ;
  } else if (Stdlib__List.for_all((function (param) {
            return param.TAG === /* Module */0 ? true : false;
          }), cxt)) {
    return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "In module ",
                      _1: {
                        TAG: /* Alpha */15,
                        _0: {
                          TAG: /* Char_literal */12,
                          _0: /* ':' */58,
                          _1: {
                            TAG: /* Formatting_lit */17,
                            _0: {
                              TAG: /* Break */0,
                              _0: "@ ",
                              _1: 1,
                              _2: 0
                            },
                            _1: /* End_of_format */0
                          }
                        }
                      }
                    },
                    _1: "In module %a:@ "
                  }), path, path_of_context(cxt));
  } else {
    return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                    _0: {
                      TAG: /* Formatting_gen */18,
                      _0: {
                        TAG: /* Open_box */1,
                        _0: /* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "<hv 2>",
                            _1: /* End_of_format */0
                          },
                          _1: "<hv 2>"
                        }
                      },
                      _1: {
                        TAG: /* String_literal */11,
                        _0: "At position",
                        _1: {
                          TAG: /* Formatting_lit */17,
                          _0: {
                            TAG: /* Break */0,
                            _0: "@ ",
                            _1: 1,
                            _2: 0
                          },
                          _1: {
                            TAG: /* Alpha */15,
                            _0: {
                              TAG: /* Formatting_lit */17,
                              _0: /* Close_box */0,
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@ ",
                                  _1: 1,
                                  _2: 0
                                },
                                _1: /* End_of_format */0
                              }
                            }
                          }
                        }
                      }
                    },
                    _1: "@[<hv 2>At position@ %a@]@ "
                  }), context, cxt);
  }
}

function include_err$2(ppf, param) {
  const err = param[2];
  const cxt = param[0];
  wrap_printing_env(param[1], (function (param) {
          Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                    _0: {
                      TAG: /* Formatting_gen */18,
                      _0: {
                        TAG: /* Open_box */1,
                        _0: /* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "<v>",
                            _1: /* End_of_format */0
                          },
                          _1: "<v>"
                        }
                      },
                      _1: {
                        TAG: /* Alpha */15,
                        _0: {
                          TAG: /* Alpha */15,
                          _0: {
                            TAG: /* Formatting_lit */17,
                            _0: /* Close_box */0,
                            _1: /* End_of_format */0
                          }
                        }
                      }
                    },
                    _1: "@[<v>%a%a@]"
                  }), context$1, Stdlib__List.rev(cxt), include_err$1, err);
        }));
}

const buffer = {
  contents: Stdlib__Bytes.empty
};

function is_big(obj) {
  const size = error_size.contents;
  if (size <= 0) {
    return false;
  }
  if (buffer.contents.length < size) {
    buffer.contents = Caml_bytes.caml_create_bytes(size);
  }
  try {
    Stdlib__Marshal.to_buffer(buffer.contents, 0, size, obj, /* [] */0);
    return false;
  }
  catch (exn){
    return true;
  }
}

function report_error$4(ppf, errs) {
  if (Caml_obj.caml_equal(errs, /* [] */0)) {
    return ;
  }
  const match = split_last(errs);
  const pe = {
    contents: true
  };
  const print_errs = function (ppf) {
    return function (param) {
      return Stdlib__List.iter((function (param) {
                    if (is_big(param[2])) {
                      if (pe.contents) {
                        Stdlib__Format.fprintf(ppf)(/* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "...",
                                _1: {
                                  TAG: /* Formatting_lit */17,
                                  _0: {
                                    TAG: /* Break */0,
                                    _0: "@ ",
                                    _1: 1,
                                    _2: 0
                                  },
                                  _1: /* End_of_format */0
                                }
                              },
                              _1: "...@ "
                            });
                        pe.contents = false;
                        return ;
                      } else {
                        return ;
                      }
                    } else {
                      return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                                      _0: {
                                        TAG: /* Alpha */15,
                                        _0: {
                                          TAG: /* Formatting_lit */17,
                                          _0: {
                                            TAG: /* Break */0,
                                            _0: "@ ",
                                            _1: 1,
                                            _2: 0
                                          },
                                          _1: /* End_of_format */0
                                        }
                                      },
                                      _1: "%a@ "
                                    }), include_err$2, param);
                    }
                  }), param);
    };
  };
  Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
            _0: {
              TAG: /* Formatting_gen */18,
              _0: {
                TAG: /* Open_box */1,
                _0: /* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "<v>",
                    _1: /* End_of_format */0
                  },
                  _1: "<v>"
                }
              },
              _1: {
                TAG: /* Alpha */15,
                _0: {
                  TAG: /* Alpha */15,
                  _0: {
                    TAG: /* Formatting_lit */17,
                    _0: /* Close_box */0,
                    _1: /* End_of_format */0
                  }
                }
              }
            },
            _1: "@[<v>%a%a@]"
          }), print_errs, match[0], include_err$2, match[1]);
}

register_error_of_exn(function (err) {
      if (err.MEL_EXN_ID === $$Error$5) {
        return error_of_printer_file(report_error$4, err._1);
      }
      
    });

function get_location(ti) {
  switch (ti.TAG | 0) {
    case /* Ti_pat */0 :
        return ti._0.pat_loc;
    case /* Ti_expr */1 :
        return ti._0.exp_loc;
    case /* Ti_class */2 :
        return ti._0.cl_loc;
    case /* Ti_mod */3 :
        return ti._0.mod_loc;
    case /* An_call */4 :
    case /* An_ident */5 :
        return ti._0;
    
  }
}

const annotations$1 = {
  contents: /* [] */0
};

const phrases = {
  contents: /* [] */0
};

function record$2(ti) {
  if (annotations.contents && !get_location(ti).loc_ghost) {
    annotations$1.contents = {
      hd: ti,
      tl: annotations$1.contents
    };
    return ;
  }
  
}

function make_pat(desc, ty, tenv) {
  return {
          pat_desc: desc,
          pat_loc: none,
          pat_extra: /* [] */0,
          pat_type: ty,
          pat_env: tenv,
          pat_attributes: /* [] */0
        };
}

const omega = make_pat(/* Tpat_any */0, none$2, empty);

const extra_pat = make_pat({
      TAG: /* Tpat_var */0,
      _0: create("+"),
      _1: {
        txt: "+",
        loc: none
      }
    }, none$2, empty);

function omegas(i) {
  if (i <= 0) {
    return /* [] */0;
  } else {
    return {
            hd: omega,
            tl: omegas(i - 1 | 0)
          };
  }
}

const zero = make_pat({
      TAG: /* Tpat_constant */2,
      _0: {
        TAG: /* Const_int */0,
        _0: 0
      }
    }, none$2, empty);

function is_absent(tag, row) {
  return Caml_obj.caml_equal(row_field(tag, row.contents), /* Rabsent */0);
}

function is_absent_pat(p) {
  const match = p.pat_desc;
  if (typeof match === "number" || match.TAG !== /* Tpat_variant */5) {
    return false;
  } else {
    return is_absent(match._0, match._2);
  }
}

function const_compare(x, y) {
  switch (x.TAG | 0) {
    case /* Const_string */2 :
        if (y.TAG === /* Const_string */2) {
          return Caml.caml_string_compare(x._0, y._0);
        } else {
          return Caml_obj.caml_compare(x, y);
        }
    case /* Const_float */3 :
        if (y.TAG === /* Const_float */3) {
          return Caml.caml_float_compare(Caml_format.caml_float_of_string(x._0), Caml_format.caml_float_of_string(y._0));
        } else {
          return Caml_obj.caml_compare(x, y);
        }
    default:
      return Caml_obj.caml_compare(x, y);
  }
}

function records_args(l1, l2) {
  let _r1 = /* [] */0;
  let _r2 = /* [] */0;
  let _l1 = l1;
  let _l2 = l2;
  while(true) {
    const l2$1 = _l2;
    const l1$1 = _l1;
    const r2 = _r2;
    const r1 = _r1;
    if (l1$1) {
      const rem1 = l1$1.tl;
      const match = l1$1.hd;
      const p1 = match[2];
      const lbl1 = match[1];
      if (l2$1) {
        const rem2 = l2$1.tl;
        const match$1 = l2$1.hd;
        const p2 = match$1[2];
        const lbl2 = match$1[1];
        if (lbl1.lbl_pos < lbl2.lbl_pos) {
          _l1 = rem1;
          _r2 = {
            hd: omega,
            tl: r2
          };
          _r1 = {
            hd: p1,
            tl: r1
          };
          continue ;
        }
        if (lbl1.lbl_pos > lbl2.lbl_pos) {
          _l2 = rem2;
          _r2 = {
            hd: p2,
            tl: r2
          };
          _r1 = {
            hd: omega,
            tl: r1
          };
          continue ;
        }
        _l2 = rem2;
        _l1 = rem1;
        _r2 = {
          hd: p2,
          tl: r2
        };
        _r1 = {
          hd: p1,
          tl: r1
        };
        continue ;
      }
      _l2 = /* [] */0;
      _l1 = rem1;
      _r2 = {
        hd: omega,
        tl: r2
      };
      _r1 = {
        hd: p1,
        tl: r1
      };
      continue ;
    }
    if (!l2$1) {
      return [
              Stdlib__List.rev(r1),
              Stdlib__List.rev(r2)
            ];
    }
    _l2 = l2$1.tl;
    _l1 = /* [] */0;
    _r2 = {
      hd: l2$1.hd[2],
      tl: r2
    };
    _r1 = {
      hd: omega,
      tl: r1
    };
    continue ;
  };
}

function compat(_p, _q) {
  while(true) {
    const q = _q;
    const p = _p;
    const match = p.pat_desc;
    const match$1 = q.pat_desc;
    let exit = 0;
    if (typeof match === "number") {
      exit = 1;
    } else {
      switch (match.TAG | 0) {
        case /* Tpat_alias */1 :
            _p = match._0;
            continue ;
        case /* Tpat_constant */2 :
            if (typeof match$1 === "number") {
              exit = 1;
            } else {
              switch (match$1.TAG | 0) {
                case /* Tpat_var */0 :
                case /* Tpat_alias */1 :
                    exit = 1;
                    break;
                case /* Tpat_constant */2 :
                    return const_compare(match._0, match$1._0) === 0;
                case /* Tpat_or */8 :
                    exit = 2;
                    break;
                default:
                  exit = 3;
              }
            }
            break;
        case /* Tpat_tuple */3 :
            if (typeof match$1 === "number") {
              exit = 1;
            } else {
              switch (match$1.TAG | 0) {
                case /* Tpat_var */0 :
                case /* Tpat_alias */1 :
                    exit = 1;
                    break;
                case /* Tpat_tuple */3 :
                    return compats(match._0, match$1._0);
                case /* Tpat_or */8 :
                    exit = 2;
                    break;
                default:
                  exit = 3;
              }
            }
            break;
        case /* Tpat_construct */4 :
            if (typeof match$1 === "number") {
              exit = 1;
            } else {
              switch (match$1.TAG | 0) {
                case /* Tpat_var */0 :
                case /* Tpat_alias */1 :
                    exit = 1;
                    break;
                case /* Tpat_construct */4 :
                    if (equal_tag(match._1.cstr_tag, match$1._1.cstr_tag)) {
                      return compats(match._2, match$1._2);
                    } else {
                      return false;
                    }
                case /* Tpat_or */8 :
                    exit = 2;
                    break;
                default:
                  exit = 3;
              }
            }
            break;
        case /* Tpat_variant */5 :
            const p1 = match._1;
            const l1 = match._0;
            if (p1 !== undefined) {
              if (typeof match$1 === "number") {
                exit = 1;
              } else {
                switch (match$1.TAG | 0) {
                  case /* Tpat_var */0 :
                  case /* Tpat_alias */1 :
                      exit = 1;
                      break;
                  case /* Tpat_variant */5 :
                      const p2 = match$1._1;
                      if (p2 === undefined) {
                        return false;
                      }
                      if (l1 !== match$1._0) {
                        return false;
                      }
                      _q = p2;
                      _p = p1;
                      continue ;
                  case /* Tpat_or */8 :
                      exit = 2;
                      break;
                  default:
                    exit = 3;
                }
              }
            } else if (typeof match$1 === "number") {
              exit = 1;
            } else {
              switch (match$1.TAG | 0) {
                case /* Tpat_var */0 :
                case /* Tpat_alias */1 :
                    exit = 1;
                    break;
                case /* Tpat_variant */5 :
                    if (match$1._1 !== undefined) {
                      return false;
                    } else {
                      return l1 === match$1._0;
                    }
                case /* Tpat_or */8 :
                    exit = 2;
                    break;
                default:
                  exit = 3;
              }
            }
            break;
        case /* Tpat_record */6 :
            if (typeof match$1 === "number") {
              exit = 1;
            } else {
              switch (match$1.TAG | 0) {
                case /* Tpat_var */0 :
                case /* Tpat_alias */1 :
                    exit = 1;
                    break;
                case /* Tpat_record */6 :
                    const match$2 = records_args(match._0, match$1._0);
                    return compats(match$2[0], match$2[1]);
                case /* Tpat_or */8 :
                    exit = 2;
                    break;
                default:
                  exit = 3;
              }
            }
            break;
        case /* Tpat_array */7 :
            const ps = match._0;
            if (typeof match$1 === "number") {
              exit = 1;
            } else {
              switch (match$1.TAG | 0) {
                case /* Tpat_var */0 :
                case /* Tpat_alias */1 :
                    exit = 1;
                    break;
                case /* Tpat_array */7 :
                    const qs = match$1._0;
                    if (Stdlib__List.length(ps) === Stdlib__List.length(qs)) {
                      return compats(ps, qs);
                    } else {
                      return false;
                    }
                case /* Tpat_or */8 :
                    exit = 2;
                    break;
                default:
                  exit = 3;
              }
            }
            break;
        case /* Tpat_lazy */9 :
            if (typeof match$1 === "number") {
              exit = 1;
            } else {
              switch (match$1.TAG | 0) {
                case /* Tpat_var */0 :
                case /* Tpat_alias */1 :
                    exit = 1;
                    break;
                case /* Tpat_or */8 :
                    exit = 2;
                    break;
                case /* Tpat_lazy */9 :
                    _q = match$1._0;
                    _p = match._0;
                    continue ;
                default:
                  exit = 3;
              }
            }
            break;
        default:
          exit = 1;
      }
    }
    switch (exit) {
      case 1 :
          if (typeof match$1 === "number") {
            return true;
          }
          switch (match$1.TAG | 0) {
            case /* Tpat_var */0 :
                return true;
            case /* Tpat_alias */1 :
                _q = match$1._0;
                continue ;
            default:
              if (typeof match === "number") {
                return true;
              }
              if (match.TAG === /* Tpat_var */0) {
                return true;
              }
              if (compat(match._0, q)) {
                return true;
              }
              _p = match._1;
              continue ;
          }
      case 2 :
          if (compat(p, match$1._0)) {
            return true;
          }
          _q = match$1._1;
          continue ;
      case 3 :
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                    MEL_EXN_ID: "Assert_failure",
                    _1: [
                      "jscomp/test/ocaml_typedtree_test.ml",
                      39141,
                      6
                    ]
                  });
      
    }
  };
}

function compats(_ps, _qs) {
  while(true) {
    const qs = _qs;
    const ps = _ps;
    if (ps) {
      if (qs) {
        if (!compat(ps.hd, qs.hd)) {
          return false;
        }
        _qs = qs.tl;
        _ps = ps.tl;
        continue ;
      }
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  39146,
                  12
                ]
              });
    }
    if (!qs) {
      return true;
    }
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                39146,
                12
              ]
            });
  };
}

const Empty = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Parmatch.Empty");

function clean_copy(ty) {
  if (ty.level === 100000000) {
    return ty;
  } else {
    return type_expr(identity, ty);
  }
}

function get_type_path(ty, tenv) {
  const ty$1 = repr(expand_head(tenv, clean_copy(ty)));
  const match = ty$1.desc;
  if (typeof match === "number" || match.TAG !== /* Tconstr */3) {
    return fatal_error("Parmatch.get_type_path");
  } else {
    return match._0;
  }
}

function is_cons(param) {
  if (param.cstr_name === "::") {
    return true;
  } else {
    return false;
  }
}

function pretty_const(c) {
  switch (c.TAG | 0) {
    case /* Const_int */0 :
        return Curry._1(Stdlib__Printf.sprintf(/* Format */{
                        _0: {
                          TAG: /* Int */4,
                          _0: /* Int_d */0,
                          _1: /* No_padding */0,
                          _2: /* No_precision */0,
                          _3: /* End_of_format */0
                        },
                        _1: "%d"
                      }), c._0);
    case /* Const_char */1 :
        return Curry._1(Stdlib__Printf.sprintf(/* Format */{
                        _0: {
                          TAG: /* Caml_char */1,
                          _0: /* End_of_format */0
                        },
                        _1: "%C"
                      }), c._0);
    case /* Const_string */2 :
        return Curry._1(Stdlib__Printf.sprintf(/* Format */{
                        _0: {
                          TAG: /* Caml_string */3,
                          _0: /* No_padding */0,
                          _1: /* End_of_format */0
                        },
                        _1: "%S"
                      }), c._0);
    case /* Const_float */3 :
        return Curry._1(Stdlib__Printf.sprintf(/* Format */{
                        _0: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: /* End_of_format */0
                        },
                        _1: "%s"
                      }), c._0);
    case /* Const_int32 */4 :
        return Curry._1(Stdlib__Printf.sprintf(/* Format */{
                        _0: {
                          TAG: /* Int32 */5,
                          _0: /* Int_d */0,
                          _1: /* No_padding */0,
                          _2: /* No_precision */0,
                          _3: {
                            TAG: /* Char_literal */12,
                            _0: /* 'l' */108,
                            _1: /* End_of_format */0
                          }
                        },
                        _1: "%ldl"
                      }), c._0);
    case /* Const_int64 */5 :
        return Curry._1(Stdlib__Printf.sprintf(/* Format */{
                        _0: {
                          TAG: /* Int64 */7,
                          _0: /* Int_d */0,
                          _1: /* No_padding */0,
                          _2: /* No_precision */0,
                          _3: {
                            TAG: /* Char_literal */12,
                            _0: /* 'L' */76,
                            _1: /* End_of_format */0
                          }
                        },
                        _1: "%LdL"
                      }), c._0);
    case /* Const_nativeint */6 :
        return Curry._1(Stdlib__Printf.sprintf(/* Format */{
                        _0: {
                          TAG: /* Nativeint */6,
                          _0: /* Int_d */0,
                          _1: /* No_padding */0,
                          _2: /* No_precision */0,
                          _3: {
                            TAG: /* Char_literal */12,
                            _0: /* 'n' */110,
                            _1: /* End_of_format */0
                          }
                        },
                        _1: "%ndn"
                      }), c._0);
    
  }
}

function pretty_val(ppf, v) {
  const match = v.pat_extra;
  if (match) {
    const rem = match.tl;
    let tmp = match.hd[0];
    if (typeof tmp === "number") {
      return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                      _0: {
                        TAG: /* Formatting_gen */18,
                        _0: {
                          TAG: /* Open_box */1,
                          _0: /* Format */{
                            _0: /* End_of_format */0,
                            _1: ""
                          }
                        },
                        _1: {
                          TAG: /* String_literal */11,
                          _0: "(module ",
                          _1: {
                            TAG: /* Alpha */15,
                            _0: {
                              TAG: /* Char_literal */12,
                              _0: /* ')' */41,
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: /* Close_box */0,
                                _1: /* End_of_format */0
                              }
                            }
                          }
                        }
                      },
                      _1: "@[(module %a)@]"
                    }), pretty_val, {
                  pat_desc: v.pat_desc,
                  pat_loc: v.pat_loc,
                  pat_extra: rem,
                  pat_type: v.pat_type,
                  pat_env: v.pat_env,
                  pat_attributes: v.pat_attributes
                });
    } else if (tmp.TAG === /* Tpat_constraint */0) {
      return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                      _0: {
                        TAG: /* Formatting_gen */18,
                        _0: {
                          TAG: /* Open_box */1,
                          _0: /* Format */{
                            _0: /* End_of_format */0,
                            _1: ""
                          }
                        },
                        _1: {
                          TAG: /* Char_literal */12,
                          _0: /* '(' */40,
                          _1: {
                            TAG: /* Alpha */15,
                            _0: {
                              TAG: /* String_literal */11,
                              _0: " : _)",
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: /* Close_box */0,
                                _1: /* End_of_format */0
                              }
                            }
                          }
                        }
                      },
                      _1: "@[(%a : _)@]"
                    }), pretty_val, {
                  pat_desc: v.pat_desc,
                  pat_loc: v.pat_loc,
                  pat_extra: rem,
                  pat_type: v.pat_type,
                  pat_env: v.pat_env,
                  pat_attributes: v.pat_attributes
                });
    } else {
      return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                      _0: {
                        TAG: /* Formatting_gen */18,
                        _0: {
                          TAG: /* Open_box */1,
                          _0: /* Format */{
                            _0: /* End_of_format */0,
                            _1: ""
                          }
                        },
                        _1: {
                          TAG: /* String_literal */11,
                          _0: "(# ",
                          _1: {
                            TAG: /* Alpha */15,
                            _0: {
                              TAG: /* Char_literal */12,
                              _0: /* ')' */41,
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: /* Close_box */0,
                                _1: /* End_of_format */0
                              }
                            }
                          }
                        }
                      },
                      _1: "@[(# %a)@]"
                    }), pretty_val, {
                  pat_desc: v.pat_desc,
                  pat_loc: v.pat_loc,
                  pat_extra: rem,
                  pat_type: v.pat_type,
                  pat_env: v.pat_env,
                  pat_attributes: v.pat_attributes
                });
    }
  }
  const c = v.pat_desc;
  if (typeof c === "number") {
    return Stdlib__Format.fprintf(ppf)(/* Format */{
                _0: {
                  TAG: /* Char_literal */12,
                  _0: /* '_' */95,
                  _1: /* End_of_format */0
                },
                _1: "_"
              });
  }
  switch (c.TAG | 0) {
    case /* Tpat_var */0 :
        return print$2(ppf, c._0);
    case /* Tpat_alias */1 :
        return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: /* End_of_format */0,
                              _1: ""
                            }
                          },
                          _1: {
                            TAG: /* Char_literal */12,
                            _0: /* '(' */40,
                            _1: {
                              TAG: /* Alpha */15,
                              _0: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@ ",
                                  _1: 1,
                                  _2: 0
                                },
                                _1: {
                                  TAG: /* String_literal */11,
                                  _0: "as ",
                                  _1: {
                                    TAG: /* Alpha */15,
                                    _0: {
                                      TAG: /* Char_literal */12,
                                      _0: /* ')' */41,
                                      _1: {
                                        TAG: /* Formatting_lit */17,
                                        _0: /* Close_box */0,
                                        _1: /* End_of_format */0
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@[(%a@ as %a)@]"
                      }), pretty_val, c._0, print$2, c._1);
    case /* Tpat_constant */2 :
        return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: /* End_of_format */0
                        },
                        _1: "%s"
                      }), pretty_const(c._0));
    case /* Tpat_tuple */3 :
        return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: /* End_of_format */0,
                              _1: ""
                            }
                          },
                          _1: {
                            TAG: /* Char_literal */12,
                            _0: /* '(' */40,
                            _1: {
                              TAG: /* Alpha */15,
                              _0: {
                                TAG: /* Char_literal */12,
                                _0: /* ')' */41,
                                _1: {
                                  TAG: /* Formatting_lit */17,
                                  _0: /* Close_box */0,
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          }
                        },
                        _1: "@[(%a)@]"
                      }), (function (param, param$1) {
                      return pretty_vals(",", param, param$1);
                    }), c._0);
    case /* Tpat_construct */4 :
        const match$1 = c._2;
        const cstr = c._1;
        if (!match$1) {
          return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: /* End_of_format */0
                          },
                          _1: "%s"
                        }), cstr.cstr_name);
        }
        if (!match$1.tl) {
          return Curry._3(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* Formatting_gen */18,
                            _0: {
                              TAG: /* Open_box */1,
                              _0: /* Format */{
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: "<2>",
                                  _1: /* End_of_format */0
                                },
                                _1: "<2>"
                              }
                            },
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@ ",
                                  _1: 1,
                                  _2: 0
                                },
                                _1: {
                                  TAG: /* Alpha */15,
                                  _0: {
                                    TAG: /* Formatting_lit */17,
                                    _0: /* Close_box */0,
                                    _1: /* End_of_format */0
                                  }
                                }
                              }
                            }
                          },
                          _1: "@[<2>%s@ %a@]"
                        }), cstr.cstr_name, pretty_arg, match$1.hd);
        }
        const vs = c._2;
        const name = c._1.cstr_name;
        if (name === "::" && vs) {
          const match$2 = vs.tl;
          if (match$2 && !match$2.tl) {
            return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                            _0: {
                              TAG: /* Formatting_gen */18,
                              _0: {
                                TAG: /* Open_box */1,
                                _0: /* Format */{
                                  _0: /* End_of_format */0,
                                  _1: ""
                                }
                              },
                              _1: {
                                TAG: /* Alpha */15,
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: "::",
                                  _1: {
                                    TAG: /* Formatting_lit */17,
                                    _0: {
                                      TAG: /* Break */0,
                                      _0: "@,",
                                      _1: 0,
                                      _2: 0
                                    },
                                    _1: {
                                      TAG: /* Alpha */15,
                                      _0: {
                                        TAG: /* Formatting_lit */17,
                                        _0: /* Close_box */0,
                                        _1: /* End_of_format */0
                                      }
                                    }
                                  }
                                }
                              }
                            },
                            _1: "@[%a::@,%a@]"
                          }), pretty_car, vs.hd, pretty_cdr, match$2.hd);
          }
          
        }
        return Curry._3(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<2>",
                                _1: /* End_of_format */0
                              },
                              _1: "<2>"
                            }
                          },
                          _1: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@ ",
                                _1: 1,
                                _2: 0
                              },
                              _1: {
                                TAG: /* Formatting_gen */18,
                                _0: {
                                  TAG: /* Open_box */1,
                                  _0: /* Format */{
                                    _0: /* End_of_format */0,
                                    _1: ""
                                  }
                                },
                                _1: {
                                  TAG: /* Char_literal */12,
                                  _0: /* '(' */40,
                                  _1: {
                                    TAG: /* Alpha */15,
                                    _0: {
                                      TAG: /* Char_literal */12,
                                      _0: /* ')' */41,
                                      _1: {
                                        TAG: /* Formatting_lit */17,
                                        _0: /* Close_box */0,
                                        _1: {
                                          TAG: /* Formatting_lit */17,
                                          _0: /* Close_box */0,
                                          _1: /* End_of_format */0
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@[<2>%s@ @[(%a)@]@]"
                      }), name, (function (param, param$1) {
                      return pretty_vals(",", param, param$1);
                    }), vs);
        break;
    case /* Tpat_variant */5 :
        const w = c._1;
        const l = c._0;
        if (w !== undefined) {
          return Curry._3(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* Formatting_gen */18,
                            _0: {
                              TAG: /* Open_box */1,
                              _0: /* Format */{
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: "<2>",
                                  _1: /* End_of_format */0
                                },
                                _1: "<2>"
                              }
                            },
                            _1: {
                              TAG: /* Char_literal */12,
                              _0: /* '`' */96,
                              _1: {
                                TAG: /* String */2,
                                _0: /* No_padding */0,
                                _1: {
                                  TAG: /* Formatting_lit */17,
                                  _0: {
                                    TAG: /* Break */0,
                                    _0: "@ ",
                                    _1: 1,
                                    _2: 0
                                  },
                                  _1: {
                                    TAG: /* Alpha */15,
                                    _0: {
                                      TAG: /* Formatting_lit */17,
                                      _0: /* Close_box */0,
                                      _1: /* End_of_format */0
                                    }
                                  }
                                }
                              }
                            }
                          },
                          _1: "@[<2>`%s@ %a@]"
                        }), l, pretty_arg, w);
        } else {
          return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* Char_literal */12,
                            _0: /* '`' */96,
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: /* End_of_format */0
                            }
                          },
                          _1: "`%s"
                        }), l);
        }
    case /* Tpat_record */6 :
        return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: /* End_of_format */0,
                              _1: ""
                            }
                          },
                          _1: {
                            TAG: /* Char_literal */12,
                            _0: /* '{' */123,
                            _1: {
                              TAG: /* Alpha */15,
                              _0: {
                                TAG: /* Char_literal */12,
                                _0: /* '}' */125,
                                _1: {
                                  TAG: /* Formatting_lit */17,
                                  _0: /* Close_box */0,
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          }
                        },
                        _1: "@[{%a}@]"
                      }), pretty_lvals, Stdlib__List.filter((function (param) {
                          if (typeof param[2].pat_desc === "number") {
                            return false;
                          } else {
                            return true;
                          }
                        }), c._0));
    case /* Tpat_array */7 :
        return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: /* End_of_format */0,
                              _1: ""
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "[| ",
                            _1: {
                              TAG: /* Alpha */15,
                              _0: {
                                TAG: /* String_literal */11,
                                _0: " |]",
                                _1: {
                                  TAG: /* Formatting_lit */17,
                                  _0: /* Close_box */0,
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          }
                        },
                        _1: "@[[| %a |]@]"
                      }), (function (param, param$1) {
                      return pretty_vals(" ;", param, param$1);
                    }), c._0);
    case /* Tpat_or */8 :
        return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: /* End_of_format */0,
                              _1: ""
                            }
                          },
                          _1: {
                            TAG: /* Char_literal */12,
                            _0: /* '(' */40,
                            _1: {
                              TAG: /* Alpha */15,
                              _0: {
                                TAG: /* Char_literal */12,
                                _0: /* '|' */124,
                                _1: {
                                  TAG: /* Formatting_lit */17,
                                  _0: {
                                    TAG: /* Break */0,
                                    _0: "@,",
                                    _1: 0,
                                    _2: 0
                                  },
                                  _1: {
                                    TAG: /* Alpha */15,
                                    _0: {
                                      TAG: /* Char_literal */12,
                                      _0: /* ')' */41,
                                      _1: {
                                        TAG: /* Formatting_lit */17,
                                        _0: /* Close_box */0,
                                        _1: /* End_of_format */0
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        _1: "@[(%a|@,%a)@]"
                      }), pretty_or, c._0, pretty_or, c._1);
    case /* Tpat_lazy */9 :
        return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<2>",
                                _1: /* End_of_format */0
                              },
                              _1: "<2>"
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "lazy",
                            _1: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@ ",
                                _1: 1,
                                _2: 0
                              },
                              _1: {
                                TAG: /* Alpha */15,
                                _0: {
                                  TAG: /* Formatting_lit */17,
                                  _0: /* Close_box */0,
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          }
                        },
                        _1: "@[<2>lazy@ %a@]"
                      }), pretty_arg, c._0);
    
  }
}

function pretty_car(ppf, v) {
  const match = v.pat_desc;
  if (typeof match === "number") {
    return pretty_val(ppf, v);
  }
  if (match.TAG !== /* Tpat_construct */4) {
    return pretty_val(ppf, v);
  }
  const match$1 = match._2;
  if (!match$1) {
    return pretty_val(ppf, v);
  }
  const match$2 = match$1.tl;
  if (match$2 && !(match$2.tl || !is_cons(match._1))) {
    return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                    _0: {
                      TAG: /* Char_literal */12,
                      _0: /* '(' */40,
                      _1: {
                        TAG: /* Alpha */15,
                        _0: {
                          TAG: /* Char_literal */12,
                          _0: /* ')' */41,
                          _1: /* End_of_format */0
                        }
                      }
                    },
                    _1: "(%a)"
                  }), pretty_val, v);
  } else {
    return pretty_val(ppf, v);
  }
}

function pretty_cdr(ppf, v) {
  const match = v.pat_desc;
  if (typeof match === "number") {
    return pretty_val(ppf, v);
  }
  if (match.TAG !== /* Tpat_construct */4) {
    return pretty_val(ppf, v);
  }
  const match$1 = match._2;
  if (!match$1) {
    return pretty_val(ppf, v);
  }
  const match$2 = match$1.tl;
  if (match$2 && !(match$2.tl || !is_cons(match._1))) {
    return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                    _0: {
                      TAG: /* Alpha */15,
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "::",
                        _1: {
                          TAG: /* Formatting_lit */17,
                          _0: {
                            TAG: /* Break */0,
                            _0: "@,",
                            _1: 0,
                            _2: 0
                          },
                          _1: {
                            TAG: /* Alpha */15,
                            _0: /* End_of_format */0
                          }
                        }
                      }
                    },
                    _1: "%a::@,%a"
                  }), pretty_car, match$1.hd, pretty_cdr, match$2.hd);
  } else {
    return pretty_val(ppf, v);
  }
}

function pretty_arg(ppf, v) {
  const match = v.pat_desc;
  if (typeof match === "number") {
    return pretty_val(ppf, v);
  }
  switch (match.TAG | 0) {
    case /* Tpat_construct */4 :
        if (!match._2) {
          return pretty_val(ppf, v);
        }
        break;
    case /* Tpat_variant */5 :
        if (match._1 === undefined) {
          return pretty_val(ppf, v);
        }
        break;
    default:
      return pretty_val(ppf, v);
  }
  Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
            _0: {
              TAG: /* Char_literal */12,
              _0: /* '(' */40,
              _1: {
                TAG: /* Alpha */15,
                _0: {
                  TAG: /* Char_literal */12,
                  _0: /* ')' */41,
                  _1: /* End_of_format */0
                }
              }
            },
            _1: "(%a)"
          }), pretty_val, v);
}

function pretty_or(ppf, v) {
  const match = v.pat_desc;
  if (typeof match === "number" || match.TAG !== /* Tpat_or */8) {
    return pretty_val(ppf, v);
  } else {
    return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                    _0: {
                      TAG: /* Alpha */15,
                      _0: {
                        TAG: /* Char_literal */12,
                        _0: /* '|' */124,
                        _1: {
                          TAG: /* Formatting_lit */17,
                          _0: {
                            TAG: /* Break */0,
                            _0: "@,",
                            _1: 0,
                            _2: 0
                          },
                          _1: {
                            TAG: /* Alpha */15,
                            _0: /* End_of_format */0
                          }
                        }
                      }
                    },
                    _1: "%a|@,%a"
                  }), pretty_or, match._0, pretty_or, match._1);
  }
}

function pretty_vals(sep, ppf, param) {
  if (!param) {
    return ;
  }
  const v = param.hd;
  if (param.tl) {
    return Curry._5(Stdlib__Format.fprintf(ppf)(/* Format */{
                    _0: {
                      TAG: /* Alpha */15,
                      _0: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* Formatting_lit */17,
                          _0: {
                            TAG: /* Break */0,
                            _0: "@ ",
                            _1: 1,
                            _2: 0
                          },
                          _1: {
                            TAG: /* Alpha */15,
                            _0: /* End_of_format */0
                          }
                        }
                      }
                    },
                    _1: "%a%s@ %a"
                  }), pretty_val, v, sep, (function (param, param$1) {
                  return pretty_vals(sep, param, param$1);
                }), param.tl);
  } else {
    return pretty_val(ppf, v);
  }
}

function pretty_lvals(ppf, param) {
  if (!param) {
    return ;
  }
  const match = param.hd;
  if (param.tl) {
    return Curry._5(Stdlib__Format.fprintf(ppf)(/* Format */{
                    _0: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* Char_literal */12,
                        _0: /* '=' */61,
                        _1: {
                          TAG: /* Alpha */15,
                          _0: {
                            TAG: /* Char_literal */12,
                            _0: /* ';' */59,
                            _1: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@ ",
                                _1: 1,
                                _2: 0
                              },
                              _1: {
                                TAG: /* Alpha */15,
                                _0: /* End_of_format */0
                              }
                            }
                          }
                        }
                      }
                    },
                    _1: "%s=%a;@ %a"
                  }), match[1].lbl_name, pretty_val, match[2], pretty_lvals, param.tl);
  } else {
    return Curry._3(Stdlib__Format.fprintf(ppf)(/* Format */{
                    _0: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* Char_literal */12,
                        _0: /* '=' */61,
                        _1: {
                          TAG: /* Alpha */15,
                          _0: /* End_of_format */0
                        }
                      }
                    },
                    _1: "%s=%a"
                  }), match[1].lbl_name, pretty_val, match[2]);
  }
}

function top_pretty(ppf, v) {
  Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
            _0: {
              TAG: /* Formatting_gen */18,
              _0: {
                TAG: /* Open_box */1,
                _0: /* Format */{
                  _0: /* End_of_format */0,
                  _1: ""
                }
              },
              _1: {
                TAG: /* Alpha */15,
                _0: {
                  TAG: /* Formatting_lit */17,
                  _0: /* Close_box */0,
                  _1: {
                    TAG: /* Formatting_lit */17,
                    _0: /* FFlush */2,
                    _1: /* End_of_format */0
                  }
                }
              }
            },
            _1: "@[%a@]@?"
          }), pretty_val, v);
}

function simple_match(p1, p2) {
  const match = p1.pat_desc;
  const match$1 = p2.pat_desc;
  if (typeof match !== "number") {
    switch (match.TAG | 0) {
      case /* Tpat_constant */2 :
          if (typeof match$1 !== "number") {
            switch (match$1.TAG | 0) {
              case /* Tpat_var */0 :
                  break;
              case /* Tpat_constant */2 :
                  return const_compare(match._0, match$1._0) === 0;
              default:
                return false;
            }
          }
          break;
      case /* Tpat_tuple */3 :
          if (typeof match$1 !== "number") {
            switch (match$1.TAG | 0) {
              case /* Tpat_var */0 :
                  break;
              case /* Tpat_tuple */3 :
                  return true;
              default:
                return false;
            }
          }
          break;
      case /* Tpat_construct */4 :
          if (typeof match$1 !== "number") {
            switch (match$1.TAG | 0) {
              case /* Tpat_var */0 :
                  break;
              case /* Tpat_construct */4 :
                  return equal_tag(match._1.cstr_tag, match$1._1.cstr_tag);
              default:
                return false;
            }
          }
          break;
      case /* Tpat_variant */5 :
          if (typeof match$1 !== "number") {
            switch (match$1.TAG | 0) {
              case /* Tpat_var */0 :
                  break;
              case /* Tpat_variant */5 :
                  return match._0 === match$1._0;
              default:
                return false;
            }
          }
          break;
      case /* Tpat_record */6 :
          if (typeof match$1 !== "number") {
            switch (match$1.TAG | 0) {
              case /* Tpat_var */0 :
                  break;
              case /* Tpat_record */6 :
                  return true;
              default:
                return false;
            }
          }
          break;
      case /* Tpat_array */7 :
          if (typeof match$1 !== "number") {
            switch (match$1.TAG | 0) {
              case /* Tpat_var */0 :
                  break;
              case /* Tpat_array */7 :
                  return Stdlib__List.length(match._0) === Stdlib__List.length(match$1._0);
              default:
                return false;
            }
          }
          break;
      case /* Tpat_lazy */9 :
          if (typeof match$1 !== "number") {
            switch (match$1.TAG | 0) {
              case /* Tpat_var */0 :
                  break;
              case /* Tpat_lazy */9 :
                  return true;
              default:
                return false;
            }
          }
          break;
      default:
        
    }
  }
  if (typeof match$1 === "number" || match$1.TAG === /* Tpat_var */0) {
    return true;
  } else {
    return false;
  }
}

function record_arg(p) {
  const match = p.pat_desc;
  if (typeof match === "number") {
    return /* [] */0;
  } else if (match.TAG === /* Tpat_record */6) {
    return match._0;
  } else {
    return fatal_error("Parmatch.as_record");
  }
}

function get_field(pos, arg) {
  return Stdlib__List.find((function (param) {
                  return pos === param[1].lbl_pos;
                }), arg)[2];
}

function simple_match_args(p1, _p2) {
  while(true) {
    const p2 = _p2;
    const args = p2.pat_desc;
    if (typeof args !== "number") {
      switch (args.TAG | 0) {
        case /* Tpat_var */0 :
            break;
        case /* Tpat_alias */1 :
            _p2 = args._0;
            continue ;
        case /* Tpat_construct */4 :
            return args._2;
        case /* Tpat_variant */5 :
            const arg = args._1;
            if (arg !== undefined) {
              return {
                      hd: arg,
                      tl: /* [] */0
                    };
            } else {
              return /* [] */0;
            }
        case /* Tpat_record */6 :
            let omegas = record_arg(p1);
            let arg$1 = args._0;
            return Stdlib__List.map((function (param) {
                          try {
                            return get_field(param[1].lbl_pos, arg$1);
                          }
                          catch (raw_exn){
                            const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                            if (exn.MEL_EXN_ID === Stdlib.Not_found) {
                              return omega;
                            }
                            throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
                          }
                        }), omegas);
        case /* Tpat_tuple */3 :
        case /* Tpat_array */7 :
            return args._0;
        case /* Tpat_constant */2 :
        case /* Tpat_or */8 :
            return /* [] */0;
        case /* Tpat_lazy */9 :
            return {
                    hd: args._0,
                    tl: /* [] */0
                  };
        
      }
    }
    const args$1 = p1.pat_desc;
    if (typeof args$1 === "number") {
      return /* [] */0;
    }
    switch (args$1.TAG | 0) {
      case /* Tpat_tuple */3 :
          return Stdlib__List.map((function (param) {
                        return omega;
                      }), args$1._0);
      case /* Tpat_construct */4 :
          return Stdlib__List.map((function (param) {
                        return omega;
                      }), args$1._2);
      case /* Tpat_variant */5 :
          if (args$1._1 !== undefined) {
            return {
                    hd: omega,
                    tl: /* [] */0
                  };
          } else {
            return /* [] */0;
          }
      case /* Tpat_record */6 :
          return Stdlib__List.map((function (param) {
                        return omega;
                      }), args$1._0);
      case /* Tpat_array */7 :
          return Stdlib__List.map((function (param) {
                        return omega;
                      }), args$1._0);
      case /* Tpat_lazy */9 :
          return {
                  hd: omega,
                  tl: /* [] */0
                };
      default:
        return /* [] */0;
    }
  };
}

function normalize_pat(_q) {
  while(true) {
    const q = _q;
    const args = q.pat_desc;
    if (typeof args === "number") {
      return q;
    }
    switch (args.TAG | 0) {
      case /* Tpat_var */0 :
          return make_pat(/* Tpat_any */0, q.pat_type, q.pat_env);
      case /* Tpat_alias */1 :
          _q = args._0;
          continue ;
      case /* Tpat_constant */2 :
          return q;
      case /* Tpat_tuple */3 :
          return make_pat({
                      TAG: /* Tpat_tuple */3,
                      _0: Stdlib__List.map((function (param) {
                              return omega;
                            }), args._0)
                    }, q.pat_type, q.pat_env);
      case /* Tpat_construct */4 :
          return make_pat({
                      TAG: /* Tpat_construct */4,
                      _0: args._0,
                      _1: args._1,
                      _2: Stdlib__List.map((function (param) {
                              return omega;
                            }), args._2)
                    }, q.pat_type, q.pat_env);
      case /* Tpat_variant */5 :
          return make_pat({
                      TAG: /* Tpat_variant */5,
                      _0: args._0,
                      _1: may_map((function (param) {
                              return omega;
                            }), args._1),
                      _2: args._2
                    }, q.pat_type, q.pat_env);
      case /* Tpat_record */6 :
          return make_pat({
                      TAG: /* Tpat_record */6,
                      _0: Stdlib__List.map((function (param) {
                              return [
                                      param[0],
                                      param[1],
                                      omega
                                    ];
                            }), args._0),
                      _1: args._1
                    }, q.pat_type, q.pat_env);
      case /* Tpat_array */7 :
          return make_pat({
                      TAG: /* Tpat_array */7,
                      _0: Stdlib__List.map((function (param) {
                              return omega;
                            }), args._0)
                    }, q.pat_type, q.pat_env);
      case /* Tpat_or */8 :
          return fatal_error("Parmatch.normalize_pat");
      case /* Tpat_lazy */9 :
          return make_pat({
                      TAG: /* Tpat_lazy */9,
                      _0: omega
                    }, q.pat_type, q.pat_env);
      
    }
  };
}

function discr_pat(q, pss) {
  const q$1 = normalize_pat(q);
  let tmp = q$1.pat_desc;
  if (typeof tmp === "number" || tmp.TAG === /* Tpat_record */6) {
    let _acc = q$1;
    let _pss = pss;
    while(true) {
      const pss$1 = _pss;
      const acc = _acc;
      if (!pss$1) {
        return acc;
      }
      const match = pss$1.hd;
      if (!match) {
        return acc;
      }
      const p = match.hd;
      const match$1 = p.pat_desc;
      if (typeof match$1 === "number") {
        _pss = pss$1.tl;
        continue ;
      }
      switch (match$1.TAG | 0) {
        case /* Tpat_var */0 :
            _pss = pss$1.tl;
            continue ;
        case /* Tpat_alias */1 :
            _pss = {
              hd: {
                hd: match$1._0,
                tl: match.tl
              },
              tl: pss$1.tl
            };
            continue ;
        case /* Tpat_record */6 :
            const new_omegas = Stdlib__List.fold_right((function (param, r) {
                    const lbl = param[1];
                    try {
                      get_field(lbl.lbl_pos, r);
                      return r;
                    }
                    catch (raw_exn){
                      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
                        return {
                                hd: [
                                  param[0],
                                  lbl,
                                  omega
                                ],
                                tl: r
                              };
                      }
                      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
                    }
                  }), match$1._0, record_arg(acc));
            _pss = pss$1.tl;
            _acc = make_pat({
                  TAG: /* Tpat_record */6,
                  _0: new_omegas,
                  _1: match$1._1
                }, p.pat_type, p.pat_env);
            continue ;
        case /* Tpat_or */8 :
            const ps = match.tl;
            _pss = {
              hd: {
                hd: match$1._0,
                tl: ps
              },
              tl: {
                hd: {
                  hd: match$1._1,
                  tl: ps
                },
                tl: pss$1.tl
              }
            };
            continue ;
        case /* Tpat_tuple */3 :
        case /* Tpat_lazy */9 :
            return normalize_pat(p);
        default:
          return acc;
      }
    };
  } else {
    return q$1;
  }
}

function read_args(xs, r) {
  if (!xs) {
    return [
            /* [] */0,
            r
          ];
  }
  if (!r) {
    return fatal_error("Parmatch.read_args");
  }
  const match = read_args(xs.tl, r.tl);
  return [
          {
            hd: r.hd,
            tl: match[0]
          },
          match[1]
        ];
}

function do_set_args(erase_mutable, q, r) {
  const omegas = q.pat_desc;
  if (typeof omegas === "number") {
    return {
            hd: q,
            tl: r
          };
  }
  switch (omegas.TAG | 0) {
    case /* Tpat_constant */2 :
        return {
                hd: q,
                tl: r
              };
    case /* Tpat_tuple */3 :
        const match = read_args(omegas._0, r);
        return {
                hd: make_pat({
                      TAG: /* Tpat_tuple */3,
                      _0: match[0]
                    }, q.pat_type, q.pat_env),
                tl: match[1]
              };
    case /* Tpat_construct */4 :
        const match$1 = read_args(omegas._2, r);
        return {
                hd: make_pat({
                      TAG: /* Tpat_construct */4,
                      _0: omegas._0,
                      _1: omegas._1,
                      _2: match$1[0]
                    }, q.pat_type, q.pat_env),
                tl: match$1[1]
              };
    case /* Tpat_variant */5 :
        let match$2;
        if (omegas._1 !== undefined) {
          if (r) {
            match$2 = [
              r.hd,
              r.tl
            ];
          } else {
            throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                      MEL_EXN_ID: "Assert_failure",
                      _1: [
                        "jscomp/test/ocaml_typedtree_test.ml",
                        39485,
                        13
                      ]
                    });
          }
        } else {
          match$2 = [
            undefined,
            r
          ];
        }
        return {
                hd: make_pat({
                      TAG: /* Tpat_variant */5,
                      _0: omegas._0,
                      _1: match$2[0],
                      _2: omegas._2
                    }, q.pat_type, q.pat_env),
                tl: match$2[1]
              };
    case /* Tpat_record */6 :
        const omegas$1 = omegas._0;
        const match$3 = read_args(omegas$1, r);
        return {
                hd: make_pat({
                      TAG: /* Tpat_record */6,
                      _0: Stdlib__List.map2((function (param, arg) {
                              const lbl = param[1];
                              const lid = param[0];
                              let tmp = false;
                              if (erase_mutable) {
                                const match = lbl.lbl_mut;
                                tmp = match ? true : false;
                              }
                              if (tmp) {
                                return [
                                        lid,
                                        lbl,
                                        omega
                                      ];
                              } else {
                                return [
                                        lid,
                                        lbl,
                                        arg
                                      ];
                              }
                            }), omegas$1, match$3[0]),
                      _1: omegas._1
                    }, q.pat_type, q.pat_env),
                tl: match$3[1]
              };
    case /* Tpat_array */7 :
        const match$4 = read_args(omegas._0, r);
        return {
                hd: make_pat({
                      TAG: /* Tpat_array */7,
                      _0: match$4[0]
                    }, q.pat_type, q.pat_env),
                tl: match$4[1]
              };
    case /* Tpat_lazy */9 :
        if (r) {
          return {
                  hd: make_pat({
                        TAG: /* Tpat_lazy */9,
                        _0: r.hd
                      }, q.pat_type, q.pat_env),
                  tl: r.tl
                };
        } else {
          return fatal_error("Parmatch.do_set_args (lazy)");
        }
    default:
      return fatal_error("Parmatch.set_args");
  }
}

function filter_one(q, pss) {
  const filter_rec = function (_param) {
    while(true) {
      const param = _param;
      if (!param) {
        return /* [] */0;
      }
      const match = param.hd;
      if (!match) {
        return /* [] */0;
      }
      const p = match.hd;
      const match$1 = p.pat_desc;
      if (typeof match$1 !== "number") {
        switch (match$1.TAG | 0) {
          case /* Tpat_alias */1 :
              _param = {
                hd: {
                  hd: match$1._0,
                  tl: match.tl
                },
                tl: param.tl
              };
              continue ;
          case /* Tpat_or */8 :
              const ps = match.tl;
              _param = {
                hd: {
                  hd: match$1._0,
                  tl: ps
                },
                tl: {
                  hd: {
                    hd: match$1._1,
                    tl: ps
                  },
                  tl: param.tl
                }
              };
              continue ;
          default:
            
        }
      }
      const pss = param.tl;
      if (simple_match(q, p)) {
        return {
                hd: Stdlib.$at(simple_match_args(q, p), match.tl),
                tl: filter_rec(pss)
              };
      }
      _param = pss;
      continue ;
    };
  };
  return filter_rec(pss);
}

function filter_extra(pss) {
  const filter_rec = function (_param) {
    while(true) {
      const param = _param;
      if (!param) {
        return /* [] */0;
      }
      const match = param.hd;
      if (match) {
        const match$1 = match.hd.pat_desc;
        if (typeof match$1 === "number") {
          return {
                  hd: match.tl,
                  tl: filter_rec(param.tl)
                };
        }
        switch (match$1.TAG | 0) {
          case /* Tpat_var */0 :
              return {
                      hd: match.tl,
                      tl: filter_rec(param.tl)
                    };
          case /* Tpat_alias */1 :
              _param = {
                hd: {
                  hd: match$1._0,
                  tl: match.tl
                },
                tl: param.tl
              };
              continue ;
          case /* Tpat_or */8 :
              const ps = match.tl;
              _param = {
                hd: {
                  hd: match$1._0,
                  tl: ps
                },
                tl: {
                  hd: {
                    hd: match$1._1,
                    tl: ps
                  },
                  tl: param.tl
                }
              };
              continue ;
          default:
            _param = param.tl;
            continue ;
        }
      } else {
        _param = param.tl;
        continue ;
      }
    };
  };
  return filter_rec(pss);
}

function filter_all(pat0, pss) {
  const insert = function (q, qs, env) {
    if (env) {
      const env$1 = env.tl;
      const c = env.hd;
      const q0 = c[0];
      if (simple_match(q0, q)) {
        return {
                hd: [
                  q0,
                  {
                    hd: Stdlib.$at(simple_match_args(q0, q), qs),
                    tl: c[1]
                  }
                ],
                tl: env$1
              };
      } else {
        return {
                hd: c,
                tl: insert(q, qs, env$1)
              };
      }
    }
    const q0$1 = normalize_pat(q);
    return {
            hd: [
              q0$1,
              {
                hd: Stdlib.$at(simple_match_args(q0$1, q), qs),
                tl: /* [] */0
              }
            ],
            tl: /* [] */0
          };
  };
  const filter_rec = function (_env, _param) {
    while(true) {
      const param = _param;
      const env = _env;
      if (!param) {
        return env;
      }
      const match = param.hd;
      if (!match) {
        return env;
      }
      const p = match.hd;
      const match$1 = p.pat_desc;
      if (typeof match$1 === "number") {
        _param = param.tl;
        continue ;
      }
      switch (match$1.TAG | 0) {
        case /* Tpat_var */0 :
            _param = param.tl;
            continue ;
        case /* Tpat_alias */1 :
            _param = {
              hd: {
                hd: match$1._0,
                tl: match.tl
              },
              tl: param.tl
            };
            continue ;
        case /* Tpat_or */8 :
            const ps = match.tl;
            _param = {
              hd: {
                hd: match$1._0,
                tl: ps
              },
              tl: {
                hd: {
                  hd: match$1._1,
                  tl: ps
                },
                tl: param.tl
              }
            };
            continue ;
        default:
          _param = param.tl;
          _env = insert(p, match.tl, env);
          continue ;
      }
    };
  };
  const match = pat0.pat_desc;
  let tmp;
  let exit = 0;
  if (typeof match === "number") {
    tmp = /* [] */0;
  } else {
    switch (match.TAG | 0) {
      case /* Tpat_tuple */3 :
      case /* Tpat_record */6 :
      case /* Tpat_lazy */9 :
          exit = 1;
          break;
      default:
        tmp = /* [] */0;
    }
  }
  if (exit === 1) {
    tmp = {
      hd: [
        pat0,
        /* [] */0
      ],
      tl: /* [] */0
    };
  }
  let _env = filter_rec(tmp, pss);
  let _param = pss;
  while(true) {
    const param = _param;
    const env = _env;
    if (!param) {
      return env;
    }
    const match$1 = param.hd;
    if (match$1) {
      const match$2 = match$1.hd.pat_desc;
      if (typeof match$2 !== "number") {
        switch (match$2.TAG | 0) {
          case /* Tpat_var */0 :
              break;
          case /* Tpat_alias */1 :
              _param = {
                hd: {
                  hd: match$2._0,
                  tl: match$1.tl
                },
                tl: param.tl
              };
              continue ;
          case /* Tpat_or */8 :
              const ps = match$1.tl;
              _param = {
                hd: {
                  hd: match$2._0,
                  tl: ps
                },
                tl: {
                  hd: {
                    hd: match$2._1,
                    tl: ps
                  },
                  tl: param.tl
                }
              };
              continue ;
          default:
            _param = param.tl;
            continue ;
        }
      }
      const ps$1 = match$1.tl;
      _param = param.tl;
      _env = Stdlib__List.map((function (param) {
              const q = param[0];
              return [
                      q,
                      {
                        hd: Stdlib.$at(simple_match_args(q, omega), ps$1),
                        tl: param[1]
                      }
                    ];
            }), env);
      continue ;
    }
    _param = param.tl;
    continue ;
  };
}

function set_last(a, param) {
  if (param) {
    if (param.tl) {
      return {
              hd: param.hd,
              tl: set_last(a, param.tl)
            };
    } else {
      return {
              hd: a,
              tl: /* [] */0
            };
    }
  } else {
    return /* [] */0;
  }
}

function mark_partial(_param) {
  while(true) {
    const param = _param;
    if (!param) {
      return /* [] */0;
    }
    const ps = param.hd;
    if (ps) {
      const match = ps.hd.pat_desc;
      if (typeof match === "number") {
        return {
                hd: ps,
                tl: mark_partial(param.tl)
              };
      }
      switch (match.TAG | 0) {
        case /* Tpat_var */0 :
            return {
                    hd: ps,
                    tl: mark_partial(param.tl)
                  };
        case /* Tpat_alias */1 :
            _param = {
              hd: {
                hd: match._0,
                tl: ps.tl
              },
              tl: param.tl
            };
            continue ;
        case /* Tpat_or */8 :
            const ps$1 = ps.tl;
            _param = {
              hd: {
                hd: match._0,
                tl: ps$1
              },
              tl: {
                hd: {
                  hd: match._1,
                  tl: ps$1
                },
                tl: param.tl
              }
            };
            continue ;
        default:
          
      }
    }
    return {
            hd: set_last(zero, ps),
            tl: mark_partial(param.tl)
          };
  };
}

function close_variant(env, row) {
  const row$1 = row_repr_aux(/* [] */0, row);
  const nm = Stdlib__List.fold_left((function (nm, param) {
          const match = row_field_repr_aux(/* [] */0, param[1]);
          if (typeof match === "number" || match.TAG === /* Rpresent */0 || match._2) {
            return nm;
          } else {
            set_row_field(match._3, /* Rabsent */0);
            return ;
          }
        }), row$1.row_name, row$1.row_fields);
  if (!row$1.row_closed || nm !== row$1.row_name) {
    return unify$2(env, row$1.row_more, newty2(100000000, {
                    TAG: /* Tvariant */8,
                    _0: {
                      row_fields: /* [] */0,
                      row_more: newty2(100000000, {
                            TAG: /* Tvar */0,
                            _0: undefined
                          }),
                      row_bound: row$1.row_bound,
                      row_closed: true,
                      row_fixed: row$1.row_fixed,
                      row_name: nm
                    }
                  }));
  }
  
}

function row_of_pat(pat) {
  const match = expand_head(pat.pat_env, pat.pat_type);
  const row = match.desc;
  if (typeof row === "number") {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                39637,
                9
              ]
            });
  }
  if (row.TAG === /* Tvariant */8) {
    return row_repr_aux(/* [] */0, row._0);
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              39637,
              9
            ]
          });
}

function generalized_constructor(x) {
  const match = x[0].pat_desc;
  if (typeof match === "number") {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                39648,
                9
              ]
            });
  }
  if (match.TAG === /* Tpat_construct */4) {
    return match._1.cstr_generalized;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              39648,
              9
            ]
          });
}

function clean_env(env) {
  const loop = function (_param) {
    while(true) {
      const param = _param;
      if (!param) {
        return /* [] */0;
      }
      const xs = param.tl;
      const x = param.hd;
      if (!generalized_constructor(x)) {
        return {
                hd: x,
                tl: loop(xs)
              };
      }
      _param = xs;
      continue ;
    };
  };
  return loop(env);
}

function full_match(ignore_generalized, closing, env) {
  if (!env) {
    return fatal_error("Parmatch.full_match");
  }
  const p = env.hd[0];
  const match = p.pat_desc;
  if (typeof match === "number") {
    return fatal_error("Parmatch.full_match");
  }
  switch (match.TAG | 0) {
    case /* Tpat_constant */2 :
        if (match._0.TAG === /* Const_char */1) {
          return Stdlib__List.length(env) === 256;
        } else {
          return false;
        }
    case /* Tpat_construct */4 :
        const c = match._1;
        if (c.cstr_consts < 0) {
          return false;
        }
        if (!ignore_generalized) {
          return Stdlib__List.length(env) === (c.cstr_consts + c.cstr_nonconsts | 0);
        }
        const env$1 = clean_env(env);
        return Stdlib__List.length(env$1) === c.cstr_normal;
    case /* Tpat_variant */5 :
        const fields = Stdlib__List.map((function (param) {
                const match = param[0].pat_desc;
                if (typeof match === "number") {
                  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                            MEL_EXN_ID: "Assert_failure",
                            _1: [
                              "jscomp/test/ocaml_typedtree_test.ml",
                              39675,
                              17
                            ]
                          });
                }
                if (match.TAG === /* Tpat_variant */5) {
                  return match._0;
                }
                throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                          MEL_EXN_ID: "Assert_failure",
                          _1: [
                            "jscomp/test/ocaml_typedtree_test.ml",
                            39675,
                            17
                          ]
                        });
              }), env);
        const row = row_of_pat(p);
        if (closing && !row_fixed(row)) {
          return Stdlib__List.for_all((function (param) {
                        const tag = param[0];
                        const match = row_field_repr_aux(/* [] */0, param[1]);
                        if (typeof match === "number" || !(match.TAG === /* Rpresent */0 || match._2)) {
                          return true;
                        } else {
                          return Stdlib__List.mem(tag, fields);
                        }
                      }), row.row_fields);
        } else if (row.row_closed) {
          return Stdlib__List.for_all((function (param) {
                        if (Caml_obj.caml_equal(row_field_repr_aux(/* [] */0, param[1]), /* Rabsent */0)) {
                          return true;
                        } else {
                          return Stdlib__List.mem(param[0], fields);
                        }
                      }), row.row_fields);
        } else {
          return false;
        }
    case /* Tpat_array */7 :
        return false;
    case /* Tpat_tuple */3 :
    case /* Tpat_record */6 :
    case /* Tpat_lazy */9 :
        return true;
    default:
      return fatal_error("Parmatch.full_match");
  }
}

function full_match_gadt(env) {
  if (!env) {
    return true;
  }
  const match = env.hd[0].pat_desc;
  if (typeof match === "number") {
    return true;
  }
  if (match.TAG !== /* Tpat_construct */4) {
    return true;
  }
  const c = match._1;
  return Stdlib__List.length(env) === (c.cstr_consts + c.cstr_nonconsts | 0);
}

function should_extend(ext, env) {
  if (ext === undefined) {
    return false;
  }
  if (!env) {
    return false;
  }
  const p = env.hd[0];
  const match = p.pat_desc;
  if (typeof match === "number") {
    return false;
  }
  if (match.TAG !== /* Tpat_construct */4) {
    return false;
  }
  switch (match._1.cstr_tag.TAG | 0) {
    case /* Cstr_constant */0 :
    case /* Cstr_block */1 :
        break;
    case /* Cstr_extension */2 :
        return false;
    
  }
  const path = get_type_path(p.pat_type, p.pat_env);
  return same(path, ext);
}

function complete_tags(nconsts, nconstrs, tags) {
  const seen_const = Caml_array.make(nconsts, false);
  const seen_constr = Caml_array.make(nconstrs, false);
  Stdlib__List.iter((function (i) {
          switch (i.TAG | 0) {
            case /* Cstr_constant */0 :
                return Caml_array.set(seen_const, i._0, true);
            case /* Cstr_block */1 :
                return Caml_array.set(seen_constr, i._0, true);
            case /* Cstr_extension */2 :
                throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                          MEL_EXN_ID: "Assert_failure",
                          _1: [
                            "jscomp/test/ocaml_typedtree_test.ml",
                            39738,
                            14
                          ]
                        });
            
          }
        }), tags);
  let r = /* [] */0;
  for(let i = 0; i < nconsts; ++i){
    if (!Caml_array.get(seen_const, i)) {
      r = {
        hd: {
          TAG: /* Cstr_constant */0,
          _0: i
        },
        tl: r
      };
    }
    
  }
  for(let i$1 = 0; i$1 < nconstrs; ++i$1){
    if (!Caml_array.get(seen_constr, i$1)) {
      r = {
        hd: {
          TAG: /* Cstr_block */1,
          _0: i$1
        },
        tl: r
      };
    }
    
  }
  return r;
}

function pat_of_constr(ex_pat, cstr) {
  return {
          pat_desc: {
            TAG: /* Tpat_construct */4,
            _0: {
              txt: {
                TAG: /* Lident */0,
                _0: "?pat_of_constr?"
              },
              loc: none
            },
            _1: cstr,
            _2: omegas(cstr.cstr_arity)
          },
          pat_loc: ex_pat.pat_loc,
          pat_extra: ex_pat.pat_extra,
          pat_type: ex_pat.pat_type,
          pat_env: ex_pat.pat_env,
          pat_attributes: ex_pat.pat_attributes
        };
}

function pat_of_constrs(ex_pat, param) {
  if (param) {
    const cstr = param.hd;
    if (param.tl) {
      return {
              pat_desc: {
                TAG: /* Tpat_or */8,
                _0: pat_of_constr(ex_pat, cstr),
                _1: pat_of_constrs(ex_pat, param.tl),
                _2: undefined
              },
              pat_loc: ex_pat.pat_loc,
              pat_extra: ex_pat.pat_extra,
              pat_type: ex_pat.pat_type,
              pat_env: ex_pat.pat_env,
              pat_attributes: ex_pat.pat_attributes
            };
    } else {
      return pat_of_constr(ex_pat, cstr);
    }
  }
  throw new Caml_js_exceptions.MelangeError(Empty, {
            MEL_EXN_ID: Empty
          });
}

function get_variant_constructors(env, _ty) {
  while(true) {
    const ty = _ty;
    const match = repr(ty).desc;
    if (typeof match === "number") {
      return fatal_error("Parmatch.get_variant_constructors");
    }
    if (match.TAG !== /* Tconstr */3) {
      return fatal_error("Parmatch.get_variant_constructors");
    }
    const path = match._0;
    const match$1 = find_type_full(path, env)[0];
    let tmp = match$1.type_kind;
    if (typeof tmp !== "number" && tmp.TAG === /* Type_variant */1) {
      return find_type_full(path, env)[1][0];
    }
    if (match$1.type_manifest === undefined) {
      return fatal_error("Parmatch.get_variant_constructors");
    }
    _ty = expand_head_once(env, clean_copy(ty));
    continue ;
  };
}

function map_filter(f, _param) {
  while(true) {
    const param = _param;
    if (!param) {
      return /* [] */0;
    }
    const xs = param.tl;
    const y = Curry._1(f, param.hd);
    if (y !== undefined) {
      return {
              hd: Caml_option.valFromOption(y),
              tl: map_filter(f, xs)
            };
    }
    _param = xs;
    continue ;
  };
}

function complete_constrs(p, all_tags) {
  const match = p.pat_desc;
  if (typeof match === "number") {
    return fatal_error("Parmatch.complete_constr");
  }
  if (match.TAG !== /* Tpat_construct */4) {
    return fatal_error("Parmatch.complete_constr");
  }
  const c = match._1;
  const not_tags = complete_tags(c.cstr_consts, c.cstr_nonconsts, all_tags);
  const constrs = get_variant_constructors(p.pat_env, c.cstr_res);
  return map_filter((function (cnstr) {
                if (Stdlib__List.exists((function (tag) {
                          return equal_tag(tag, cnstr.cstr_tag);
                        }), not_tags)) {
                  return cnstr;
                }
                
              }), constrs);
}

function build_other_constant(proj, make, first, next, p, env) {
  const all = Stdlib__List.map((function (param) {
          return Curry._1(proj, param[0].pat_desc);
        }), env);
  let _i = first;
  while(true) {
    const i = _i;
    if (!Stdlib__List.mem(i, all)) {
      return make_pat(Curry._1(make, i), p.pat_type, p.pat_env);
    }
    _i = Curry._1(next, i);
    continue ;
  };
}

function build_other(ext, env) {
  if (!env) {
    return omega;
  }
  const p = env.hd[0];
  const args = p.pat_desc;
  if (typeof args === "number") {
    return omega;
  }
  switch (args.TAG | 0) {
    case /* Tpat_constant */2 :
        switch (args._0.TAG | 0) {
          case /* Const_int */0 :
              return build_other_constant((function (param) {
                            if (typeof param !== "number" && param.TAG === /* Tpat_constant */2) {
                              const i = param._0;
                              if (i.TAG === /* Const_int */0) {
                                return i._0;
                              }
                              
                            }
                            throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                                      MEL_EXN_ID: "Assert_failure",
                                      _1: [
                                        "jscomp/test/ocaml_typedtree_test.ml",
                                        39892,
                                        55
                                      ]
                                    });
                          }), (function (i) {
                            return {
                                    TAG: /* Tpat_constant */2,
                                    _0: {
                                      TAG: /* Const_int */0,
                                      _0: i
                                    }
                                  };
                          }), 0, (function (prim) {
                            return prim + 1 | 0;
                          }), p, env);
          case /* Const_char */1 :
              const all_chars = Stdlib__List.map((function (param) {
                      const match = param[0].pat_desc;
                      if (typeof match !== "number" && match.TAG === /* Tpat_constant */2) {
                        const c = match._0;
                        if (c.TAG === /* Const_char */1) {
                          return c._0;
                        }
                        
                      }
                      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                                MEL_EXN_ID: "Assert_failure",
                                _1: [
                                  "jscomp/test/ocaml_typedtree_test.ml",
                                  39867,
                                  15
                                ]
                              });
                    }), env);
              let _param = {
                hd: [
                  /* 'a' */97,
                  /* 'z' */122
                ],
                tl: {
                  hd: [
                    /* 'A' */65,
                    /* 'Z' */90
                  ],
                  tl: {
                    hd: [
                      /* '0' */48,
                      /* '9' */57
                    ],
                    tl: {
                      hd: [
                        /* ' ' */32,
                        /* '~' */126
                      ],
                      tl: {
                        hd: [
                          Stdlib__Char.chr(0),
                          Stdlib__Char.chr(255)
                        ],
                        tl: /* [] */0
                      }
                    }
                  }
                }
              };
              while(true) {
                const param = _param;
                if (!param) {
                  return omega;
                }
                const match = param.hd;
                try {
                  let _i = match[0];
                  let imax = match[1];
                  while(true) {
                    const i = _i;
                    if (i > imax) {
                      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                                MEL_EXN_ID: Stdlib.Not_found
                              });
                    }
                    const ci = Stdlib__Char.chr(i);
                    if (!Stdlib__List.mem(ci, all_chars)) {
                      return make_pat({
                                  TAG: /* Tpat_constant */2,
                                  _0: {
                                    TAG: /* Const_char */1,
                                    _0: ci
                                  }
                                }, p.pat_type, p.pat_env);
                    }
                    _i = i + 1 | 0;
                    continue ;
                  };
                }
                catch (raw_exn){
                  const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                  if (exn.MEL_EXN_ID === Stdlib.Not_found) {
                    _param = param.tl;
                    continue ;
                  }
                  throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
                }
              };
          case /* Const_string */2 :
              return build_other_constant((function (param) {
                            if (typeof param !== "number" && param.TAG === /* Tpat_constant */2) {
                              const match = param._0;
                              if (match.TAG === /* Const_string */2) {
                                return match._0.length;
                              }
                              
                            }
                            throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                                      MEL_EXN_ID: "Assert_failure",
                                      _1: [
                                        "jscomp/test/ocaml_typedtree_test.ml",
                                        39913,
                                        21
                                      ]
                                    });
                          }), (function (i) {
                            return {
                                    TAG: /* Tpat_constant */2,
                                    _0: {
                                      TAG: /* Const_string */2,
                                      _0: Caml_bytes.bytes_to_string(Stdlib__Bytes.make(i, /* '*' */42)),
                                      _1: undefined
                                    }
                                  };
                          }), 0, (function (prim) {
                            return prim + 1 | 0;
                          }), p, env);
          case /* Const_float */3 :
              return build_other_constant((function (param) {
                            if (typeof param !== "number" && param.TAG === /* Tpat_constant */2) {
                              const f = param._0;
                              if (f.TAG === /* Const_float */3) {
                                return Caml_format.caml_float_of_string(f._0);
                              }
                              
                            }
                            throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                                      MEL_EXN_ID: "Assert_failure",
                                      _1: [
                                        "jscomp/test/ocaml_typedtree_test.ml",
                                        39919,
                                        21
                                      ]
                                    });
                          }), (function (f) {
                            return {
                                    TAG: /* Tpat_constant */2,
                                    _0: {
                                      TAG: /* Const_float */3,
                                      _0: Stdlib.string_of_float(f)
                                    }
                                  };
                          }), 0.0, (function (f) {
                            return f + 1.0;
                          }), p, env);
          case /* Const_int32 */4 :
              return build_other_constant((function (param) {
                            if (typeof param !== "number" && param.TAG === /* Tpat_constant */2) {
                              const i = param._0;
                              if (i.TAG === /* Const_int32 */4) {
                                return i._0;
                              }
                              
                            }
                            throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                                      MEL_EXN_ID: "Assert_failure",
                                      _1: [
                                        "jscomp/test/ocaml_typedtree_test.ml",
                                        39897,
                                        57
                                      ]
                                    });
                          }), (function (i) {
                            return {
                                    TAG: /* Tpat_constant */2,
                                    _0: {
                                      TAG: /* Const_int32 */4,
                                      _0: i
                                    }
                                  };
                          }), 0, Stdlib__Int32.succ, p, env);
          case /* Const_int64 */5 :
              return build_other_constant((function (param) {
                            if (typeof param !== "number" && param.TAG === /* Tpat_constant */2) {
                              const i = param._0;
                              if (i.TAG === /* Const_int64 */5) {
                                return i._0;
                              }
                              
                            }
                            throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                                      MEL_EXN_ID: "Assert_failure",
                                      _1: [
                                        "jscomp/test/ocaml_typedtree_test.ml",
                                        39902,
                                        57
                                      ]
                                    });
                          }), (function (i) {
                            return {
                                    TAG: /* Tpat_constant */2,
                                    _0: {
                                      TAG: /* Const_int64 */5,
                                      _0: i
                                    }
                                  };
                          }), Caml_int64.zero, Stdlib__Int64.succ, p, env);
          case /* Const_nativeint */6 :
              throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                        MEL_EXN_ID: "Assert_failure",
                        _1: [
                          "jscomp/test/ocaml_typedtree_test.ml",
                          39909,
                          33
                        ]
                      });
          
        }
    case /* Tpat_construct */4 :
        let exit = 0;
        const c = args._1;
        switch (c.cstr_tag.TAG | 0) {
          case /* Cstr_constant */0 :
          case /* Cstr_block */1 :
              exit = 1;
              break;
          case /* Cstr_extension */2 :
              const c_cstr_res = c.cstr_res;
              const c_cstr_existentials = c.cstr_existentials;
              const c_cstr_args = c.cstr_args;
              const c_cstr_arity = c.cstr_arity;
              const c_cstr_tag = c.cstr_tag;
              const c_cstr_consts = c.cstr_consts;
              const c_cstr_nonconsts = c.cstr_nonconsts;
              const c_cstr_normal = c.cstr_normal;
              const c_cstr_generalized = c.cstr_generalized;
              const c_cstr_private = c.cstr_private;
              const c_cstr_loc = c.cstr_loc;
              const c_cstr_attributes = c.cstr_attributes;
              const c$1 = {
                cstr_name: "*extension*",
                cstr_res: c_cstr_res,
                cstr_existentials: c_cstr_existentials,
                cstr_args: c_cstr_args,
                cstr_arity: c_cstr_arity,
                cstr_tag: c_cstr_tag,
                cstr_consts: c_cstr_consts,
                cstr_nonconsts: c_cstr_nonconsts,
                cstr_normal: c_cstr_normal,
                cstr_generalized: c_cstr_generalized,
                cstr_private: c_cstr_private,
                cstr_loc: c_cstr_loc,
                cstr_attributes: c_cstr_attributes
              };
              return make_pat({
                          TAG: /* Tpat_construct */4,
                          _0: args._0,
                          _1: c$1,
                          _2: /* [] */0
                        }, none$2, empty);
          
        }
        if (exit === 1) {
          let exit$1 = 0;
          if (ext !== undefined) {
            if (same(ext, get_type_path(p.pat_type, p.pat_env))) {
              return extra_pat;
            }
            exit$1 = 2;
          } else {
            exit$1 = 2;
          }
          if (exit$1 === 2) {
            const all_tags = Stdlib__List.map((function (param) {
                    let param$1 = param[0];
                    const match = param$1.pat_desc;
                    if (typeof match === "number" || match.TAG !== /* Tpat_construct */4) {
                      return fatal_error("Parmatch.get_tag");
                    } else {
                      return match._1.cstr_tag;
                    }
                  }), env);
            return pat_of_constrs(p, complete_constrs(p, all_tags));
          }
          
        }
        break;
    case /* Tpat_variant */5 :
        const r = args._2;
        const tags = Stdlib__List.map((function (param) {
                const match = param[0].pat_desc;
                if (typeof match === "number") {
                  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                            MEL_EXN_ID: "Assert_failure",
                            _1: [
                              "jscomp/test/ocaml_typedtree_test.ml",
                              39836,
                              23
                            ]
                          });
                }
                if (match.TAG === /* Tpat_variant */5) {
                  return match._0;
                }
                throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                          MEL_EXN_ID: "Assert_failure",
                          _1: [
                            "jscomp/test/ocaml_typedtree_test.ml",
                            39836,
                            23
                          ]
                        });
              }), env);
        const row = row_of_pat(p);
        const make_other_pat = function (tag, $$const) {
          const arg = $$const ? undefined : omega;
          return make_pat({
                      TAG: /* Tpat_variant */5,
                      _0: tag,
                      _1: arg,
                      _2: r
                    }, p.pat_type, p.pat_env);
        };
        const match$1 = Stdlib__List.fold_left((function (others, param) {
                const tag = param[0];
                if (Stdlib__List.mem(tag, tags)) {
                  return others;
                }
                const arg = row_field_repr_aux(/* [] */0, param[1]);
                if (typeof arg === "number") {
                  return others;
                } else if (arg.TAG === /* Rpresent */0) {
                  return {
                          hd: make_other_pat(tag, arg._0 === undefined),
                          tl: others
                        };
                } else {
                  return {
                          hd: make_other_pat(tag, arg._0),
                          tl: others
                        };
                }
              }), /* [] */0, row.row_fields);
        if (match$1) {
          return Stdlib__List.fold_left((function (p_res, pat) {
                        return make_pat({
                                    TAG: /* Tpat_or */8,
                                    _0: pat,
                                    _1: p_res,
                                    _2: undefined
                                  }, p.pat_type, p.pat_env);
                      }), match$1.hd, match$1.tl);
        } else {
          return make_other_pat("AnyExtraTag", true);
        }
    case /* Tpat_array */7 :
        const all_lengths = Stdlib__List.map((function (param) {
                const args = param[0].pat_desc;
                if (typeof args === "number") {
                  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                            MEL_EXN_ID: "Assert_failure",
                            _1: [
                              "jscomp/test/ocaml_typedtree_test.ml",
                              39928,
                              15
                            ]
                          });
                }
                if (args.TAG === /* Tpat_array */7) {
                  return Stdlib__List.length(args._0);
                }
                throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                          MEL_EXN_ID: "Assert_failure",
                          _1: [
                            "jscomp/test/ocaml_typedtree_test.ml",
                            39928,
                            15
                          ]
                        });
              }), env);
        let _l = 0;
        while(true) {
          const l = _l;
          if (!Stdlib__List.mem(l, all_lengths)) {
            return make_pat({
                        TAG: /* Tpat_array */7,
                        _0: omegas(l)
                      }, p.pat_type, p.pat_env);
          }
          _l = l + 1 | 0;
          continue ;
        };
    default:
      return omega;
  }
}

function build_other_gadt(ext, env) {
  if (env) {
    const p = env.hd[0];
    let tmp = p.pat_desc;
    if (typeof tmp !== "number" && tmp.TAG === /* Tpat_construct */4) {
      const all_tags = Stdlib__List.map((function (param) {
              let param$1 = param[0];
              const match = param$1.pat_desc;
              if (typeof match === "number" || match.TAG !== /* Tpat_construct */4) {
                return fatal_error("Parmatch.get_tag");
              } else {
                return match._1.cstr_tag;
              }
            }), env);
      const cnstrs = complete_constrs(p, all_tags);
      return Stdlib__List.map((function (param) {
                    return pat_of_constr(p, param);
                  }), cnstrs);
    }
    
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              39952,
              11
            ]
          });
}

function has_instance(_p) {
  while(true) {
    const p = _p;
    const p$1 = p.pat_desc;
    if (typeof p$1 === "number") {
      return true;
    }
    switch (p$1.TAG | 0) {
      case /* Tpat_construct */4 :
          return has_instances(p$1._2);
      case /* Tpat_variant */5 :
          const p$2 = p$1._1;
          if (is_absent(p$1._0, p$1._2)) {
            return false;
          }
          if (p$2 === undefined) {
            return true;
          }
          _p = p$2;
          continue ;
      case /* Tpat_record */6 :
          return has_instances(Stdlib__List.map((function (param) {
                            return param[2];
                          }), p$1._0));
      case /* Tpat_tuple */3 :
      case /* Tpat_array */7 :
          return has_instances(p$1._0);
      case /* Tpat_or */8 :
          if (has_instance(p$1._0)) {
            return true;
          }
          _p = p$1._1;
          continue ;
      case /* Tpat_alias */1 :
      case /* Tpat_lazy */9 :
          _p = p$1._0;
          continue ;
      default:
        return true;
    }
  };
}

function has_instances(_param) {
  while(true) {
    const param = _param;
    if (!param) {
      return true;
    }
    if (!has_instance(param.hd)) {
      return false;
    }
    _param = param.tl;
    continue ;
  };
}

function satisfiable(_pss, _qs) {
  while(true) {
    const qs = _qs;
    const pss = _pss;
    if (!pss) {
      return has_instances(qs);
    }
    if (!qs) {
      return false;
    }
    const q = qs.hd;
    const match = q.pat_desc;
    let exit = 0;
    if (typeof match === "number") {
      exit = 2;
    } else {
      switch (match.TAG | 0) {
        case /* Tpat_var */0 :
            exit = 2;
            break;
        case /* Tpat_alias */1 :
            _qs = {
              hd: match._0,
              tl: qs.tl
            };
            continue ;
        case /* Tpat_variant */5 :
            if (is_absent(match._0, match._2)) {
              return false;
            }
            break;
        case /* Tpat_or */8 :
            const qs$1 = qs.tl;
            if (satisfiable(pss, {
                    hd: match._0,
                    tl: qs$1
                  })) {
              return true;
            }
            _qs = {
              hd: match._1,
              tl: qs$1
            };
            continue ;
        default:
          
      }
    }
    if (exit === 2) {
      const qs$2 = qs.tl;
      const q0 = discr_pat(omega, pss);
      const constrs = filter_all(q0, pss);
      if (constrs) {
        if (full_match(false, false, constrs)) {
          return Stdlib__List.exists((function (param) {
                        const p = param[0];
                        if (is_absent_pat(p)) {
                          return false;
                        } else {
                          return satisfiable(param[1], Stdlib.$at(simple_match_args(p, omega), qs$2));
                        }
                      }), constrs);
        }
        _qs = qs$2;
        _pss = filter_extra(pss);
        continue ;
      }
      _qs = qs$2;
      _pss = filter_extra(pss);
      continue ;
    }
    const q0$1 = discr_pat(q, pss);
    _qs = Stdlib.$at(simple_match_args(q0$1, q), qs.tl);
    _pss = filter_one(q0$1, pss);
    continue ;
  };
}

function orify_many(param) {
  if (param) {
    const x = param.hd;
    if (param.tl) {
      let y = Curry._1(orify_many, param.tl);
      return make_pat({
                  TAG: /* Tpat_or */8,
                  _0: x,
                  _1: y,
                  _2: undefined
                }, x.pat_type, x.pat_env);
    } else {
      return x;
    }
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              40024,
              12
            ]
          });
}

function try_many_gadt(f, param) {
  if (!param) {
    return /* Rnone */0;
  }
  const match = param.hd;
  let r1 = Curry._1(f, [
        match[0],
        match[1]
      ]);
  let r2 = try_many_gadt(f, param.tl);
  if (r1) {
    if (r2) {
      return /* Rsome */{
              _0: Stdlib.$at(r1._0, r2._0)
            };
    } else {
      return r1;
    }
  } else {
    return r2;
  }
}

function exhaust(ext, pss, n) {
  if (!pss) {
    return /* Rsome */{
            _0: omegas(n)
          };
  }
  if (!pss.hd) {
    return /* Rnone */0;
  }
  const q0 = discr_pat(omega, pss);
  const constrs = filter_all(q0, pss);
  if (constrs) {
    const try_non_omega = function (param) {
      const p = param[0];
      if (is_absent_pat(p)) {
        return /* Rnone */0;
      }
      const r = exhaust(ext, param[1], (Stdlib__List.length(simple_match_args(p, omega)) + n | 0) - 1 | 0);
      if (r) {
        return /* Rsome */{
                _0: do_set_args(false, p, r._0)
              };
      } else {
        return r;
      }
    };
    if (full_match(true, false, constrs) && !should_extend(ext, constrs)) {
      let _param = constrs;
      while(true) {
        const param = _param;
        if (!param) {
          return /* Rnone */0;
        }
        const match = param.hd;
        const r = Curry._1(try_non_omega, [
              match[0],
              match[1]
            ]);
        if (r) {
          return r;
        }
        _param = param.tl;
        continue ;
      };
    }
    const r$1 = exhaust(ext, filter_extra(pss), n - 1 | 0);
    if (!r$1) {
      return /* Rnone */0;
    }
    try {
      return /* Rsome */{
              _0: {
                hd: build_other(ext, constrs),
                tl: r$1._0
              }
            };
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Empty) {
        return fatal_error("Parmatch.exhaust");
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  } else {
    const r$2 = exhaust(ext, filter_extra(pss), n - 1 | 0);
    if (r$2) {
      return /* Rsome */{
              _0: {
                hd: q0,
                tl: r$2._0
              }
            };
    } else {
      return r$2;
    }
  }
}

function combinations(f, lst, lst$p) {
  const iter2 = function (x, param) {
    if (param) {
      return {
              hd: Curry._2(f, x, param.hd),
              tl: iter2(x, param.tl)
            };
    } else {
      return /* [] */0;
    }
  };
  const iter = function (param) {
    if (param) {
      return Stdlib.$at(iter2(param.hd, lst$p), iter(param.tl));
    } else {
      return /* [] */0;
    }
  };
  return iter(lst);
}

function exhaust_gadt(ext, pss, n) {
  if (!pss) {
    return /* Rsome */{
            _0: {
              hd: omegas(n),
              tl: /* [] */0
            }
          };
  }
  if (!pss.hd) {
    return /* Rnone */0;
  }
  const q0 = discr_pat(omega, pss);
  const constrs = filter_all(q0, pss);
  if (constrs) {
    const try_non_omega = function (param) {
      const p = param[0];
      if (is_absent_pat(p)) {
        return /* Rnone */0;
      }
      const r = exhaust_gadt(ext, param[1], (Stdlib__List.length(simple_match_args(p, omega)) + n | 0) - 1 | 0);
      if (r) {
        return /* Rsome */{
                _0: Stdlib__List.map((function (row) {
                        return do_set_args(false, p, row);
                      }), r._0)
              };
      } else {
        return r;
      }
    };
    const before = try_many_gadt(try_non_omega, constrs);
    if (full_match_gadt(constrs) && !should_extend(ext, constrs)) {
      return before;
    }
    const r = exhaust_gadt(ext, filter_extra(pss), n - 1 | 0);
    if (!r) {
      return before;
    }
    try {
      const missing_trailing = build_other_gadt(ext, constrs);
      const dug = combinations((function (head, tail) {
              return {
                      hd: head,
                      tl: tail
                    };
            }), missing_trailing, r._0);
      if (before) {
        return /* Rsome */{
                _0: Stdlib.$at(before._0, dug)
              };
      } else {
        return /* Rsome */{
                _0: dug
              };
      }
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Empty) {
        return fatal_error("Parmatch.exhaust");
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  } else {
    const r$1 = exhaust_gadt(ext, filter_extra(pss), n - 1 | 0);
    if (r$1) {
      return /* Rsome */{
              _0: Stdlib__List.map((function (row) {
                      return {
                              hd: q0,
                              tl: row
                            };
                    }), r$1._0)
            };
    } else {
      return r$1;
    }
  }
}

function exhaust_gadt$1(ext, pss, n) {
  const ret = exhaust_gadt(ext, pss, n);
  if (!ret) {
    return /* Rnone */0;
  }
  const lst = ret._0;
  if (Caml_obj.caml_equal(lst, /* [] */0)) {
    return /* Rsome */{
            _0: omegas(n)
          };
  }
  const singletons = Stdlib__List.map((function (param) {
          if (param) {
            if (param.tl) {
              throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                        MEL_EXN_ID: "Assert_failure",
                        _1: [
                          "jscomp/test/ocaml_typedtree_test.ml",
                          40200,
                          19
                        ]
                      });
            }
            return param.hd;
          }
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                    MEL_EXN_ID: "Assert_failure",
                    _1: [
                      "jscomp/test/ocaml_typedtree_test.ml",
                      40200,
                      19
                    ]
                  });
        }), lst);
  return /* Rsome */{
          _0: {
            hd: Curry._1(orify_many, singletons),
            tl: /* [] */0
          }
        };
}

function pressure_variants(_tdefs, _pss) {
  while(true) {
    const pss = _pss;
    const tdefs = _tdefs;
    if (!pss) {
      return false;
    }
    if (!pss.hd) {
      return true;
    }
    const q0 = discr_pat(omega, pss);
    const constrs = filter_all(q0, pss);
    if (constrs) {
      const try_non_omega = function (param) {
        if (!param) {
          return true;
        }
        const ok = pressure_variants(tdefs, param.hd[1]);
        if (try_non_omega(param.tl)) {
          return ok;
        } else {
          return false;
        }
      };
      if (full_match(true, tdefs === undefined, constrs)) {
        return try_non_omega(constrs);
      }
      if (tdefs === undefined) {
        _pss = filter_extra(pss);
        _tdefs = undefined;
        continue ;
      }
      const full = full_match(true, true, constrs);
      const ok = full ? try_non_omega(constrs) : try_non_omega(filter_all(q0, mark_partial(pss)));
      if (constrs) {
        const p = constrs.hd[0];
        let tmp = p.pat_desc;
        if (typeof tmp !== "number" && tmp.TAG === /* Tpat_variant */5 && tdefs !== undefined) {
          const row = row_of_pat(p);
          if (row_fixed(row) || pressure_variants(undefined, filter_extra(pss))) {
            
          } else {
            close_variant(Caml_option.valFromOption(tdefs), row);
          }
        }
        
      }
      return ok;
    }
    _pss = filter_extra(pss);
    continue ;
  };
}

function make_row(ps) {
  return {
          no_ors: /* [] */0,
          ors: /* [] */0,
          active: ps
        };
}

function unalias$1(_p) {
  while(true) {
    const p = _p;
    const match = p.pat_desc;
    if (typeof match === "number") {
      return p;
    }
    if (match.TAG !== /* Tpat_alias */1) {
      return p;
    }
    _p = match._0;
    continue ;
  };
}

function is_var_column(rs) {
  return Stdlib__List.for_all((function (r) {
                const match = r.active;
                if (match) {
                  let p = match.hd;
                  const match$1 = unalias$1(p).pat_desc;
                  if (typeof match$1 === "number" || match$1.TAG === /* Tpat_var */0) {
                    return true;
                  } else {
                    return false;
                  }
                }
                throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                          MEL_EXN_ID: "Assert_failure",
                          _1: [
                            "jscomp/test/ocaml_typedtree_test.ml",
                            40309,
                            14
                          ]
                        });
              }), rs);
}

function or_args(_p) {
  while(true) {
    const p = _p;
    const match = p.pat_desc;
    if (typeof match === "number") {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  40316,
                  23
                ]
              });
    }
    switch (match.TAG | 0) {
      case /* Tpat_alias */1 :
          _p = match._0;
          continue ;
      case /* Tpat_or */8 :
          return [
                  match._0,
                  match._1
                ];
      default:
        throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                  MEL_EXN_ID: "Assert_failure",
                  _1: [
                    "jscomp/test/ocaml_typedtree_test.ml",
                    40316,
                    23
                  ]
                });
    }
  };
}

function remove$1(r) {
  const match = r.active;
  if (match) {
    return {
            no_ors: r.no_ors,
            ors: r.ors,
            active: match.tl
          };
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              40321,
              12
            ]
          });
}

function push_no_or(r) {
  const match = r.active;
  if (match) {
    return {
            no_ors: {
              hd: match.hd,
              tl: r.no_ors
            },
            ors: r.ors,
            active: match.tl
          };
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              40328,
              8
            ]
          });
}

function push_or(r) {
  const match = r.active;
  if (match) {
    return {
            no_ors: r.no_ors,
            ors: {
              hd: match.hd,
              tl: r.ors
            },
            active: match.tl
          };
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              40332,
              8
            ]
          });
}

function discr_pat$1(q, rs) {
  return discr_pat(q, Stdlib__List.map((function (r) {
                    return r.active;
                  }), rs));
}

function filter_one$1(q, rs) {
  const filter_rec = function (_rs) {
    while(true) {
      const rs = _rs;
      if (!rs) {
        return /* [] */0;
      }
      const rem = rs.tl;
      const r = rs.hd;
      const match = r.active;
      if (match) {
        const p = match.hd;
        const match$1 = p.pat_desc;
        if (typeof match$1 !== "number") {
          switch (match$1.TAG | 0) {
            case /* Tpat_alias */1 :
                _rs = {
                  hd: {
                    no_ors: r.no_ors,
                    ors: r.ors,
                    active: {
                      hd: match$1._0,
                      tl: match.tl
                    }
                  },
                  tl: rem
                };
                continue ;
            case /* Tpat_or */8 :
                const ps = match.tl;
                _rs = {
                  hd: {
                    no_ors: r.no_ors,
                    ors: r.ors,
                    active: {
                      hd: match$1._0,
                      tl: ps
                    }
                  },
                  tl: {
                    hd: {
                      no_ors: r.no_ors,
                      ors: r.ors,
                      active: {
                        hd: match$1._1,
                        tl: ps
                      }
                    },
                    tl: rem
                  }
                };
                continue ;
            default:
              
          }
        }
        if (simple_match(q, p)) {
          return {
                  hd: {
                    no_ors: r.no_ors,
                    ors: r.ors,
                    active: Stdlib.$at(simple_match_args(q, p), match.tl)
                  },
                  tl: filter_rec(rem)
                };
        }
        _rs = rem;
        continue ;
      }
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  40349,
                  14
                ]
              });
    };
  };
  return filter_rec(rs);
}

function make_vector(r) {
  return r.no_ors;
}

function extract_elements(qs) {
  const do_rec = function (seen, param) {
    if (!param) {
      return /* [] */0;
    }
    const rem = param.tl;
    const q = param.hd;
    return {
            hd: {
              no_ors: Stdlib.$at(Stdlib__List.rev_append(seen, rem), qs.no_ors),
              ors: /* [] */0,
              active: {
                hd: q,
                tl: /* [] */0
              }
            },
            tl: do_rec({
                  hd: q,
                  tl: seen
                }, rem)
          };
  };
  return do_rec(/* [] */0, qs.ors);
}

function extract_columns(pss, qs) {
  if (pss) {
    let rs = Stdlib__List.map(extract_elements, pss);
    if (rs) {
      const i = Stdlib__List.map((function (x) {
              return {
                      hd: x,
                      tl: /* [] */0
                    };
            }), rs.hd);
      return Stdlib__List.fold_left((function (param, param$1) {
                    return Stdlib__List.map2((function (r, x) {
                                  return {
                                          hd: x,
                                          tl: r
                                        };
                                }), param, param$1);
                  }), i, rs.tl);
    }
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                40392,
                8
              ]
            });
  } else {
    return Stdlib__List.map((function (param) {
                  return /* [] */0;
                }), qs.ors);
  }
}

function every_satisfiables(_pss, _qs) {
  while(true) {
    const qs = _qs;
    const pss = _pss;
    const match = qs.active;
    if (match) {
      const q = match.hd;
      const uq = unalias$1(q);
      const match$1 = uq.pat_desc;
      let exit = 0;
      if (typeof match$1 === "number") {
        exit = 2;
      } else {
        switch (match$1.TAG | 0) {
          case /* Tpat_var */0 :
              exit = 2;
              break;
          case /* Tpat_variant */5 :
              if (is_absent(match$1._0, match$1._2)) {
                return /* Unused */1;
              }
              exit = 1;
              break;
          case /* Tpat_or */8 :
              if (match$1._0.pat_loc.loc_ghost && match$1._1.pat_loc.loc_ghost) {
                _qs = push_no_or(qs);
                _pss = Stdlib__List.map(push_no_or, pss);
                continue ;
              }
              _qs = push_or(qs);
              _pss = Stdlib__List.map(push_or, pss);
              continue ;
          default:
            exit = 1;
        }
      }
      switch (exit) {
        case 1 :
            const q0 = discr_pat$1(q, pss);
            _qs = {
              no_ors: qs.no_ors,
              ors: qs.ors,
              active: Stdlib.$at(simple_match_args(q0, q), match.tl)
            };
            _pss = filter_one$1(q0, pss);
            continue ;
        case 2 :
            if (is_var_column(pss)) {
              _qs = remove$1(qs);
              _pss = Stdlib__List.map(remove$1, pss);
              continue ;
            }
            _qs = push_no_or(qs);
            _pss = Stdlib__List.map(push_no_or, pss);
            continue ;
        
      }
    } else {
      const match$2 = qs.ors;
      if (match$2) {
        return Stdlib__List.fold_right2((function (pss, qs, r) {
                      if (typeof r === "number" && r) {
                        return /* Unused */1;
                      }
                      const match = qs.active;
                      if (match) {
                        if (match.tl) {
                          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                                    MEL_EXN_ID: "Assert_failure",
                                    _1: [
                                      "jscomp/test/ocaml_typedtree_test.ml",
                                      40429,
                                      23
                                    ]
                                  });
                        }
                        const match$1 = or_args(match.hd);
                        const r_loc = every_both(pss, qs, match$1[0], match$1[1]);
                        if (typeof r === "number") {
                          if (r) {
                            return /* Unused */1;
                          }
                          
                        } else {
                          if (typeof r_loc !== "number") {
                            return /* Upartial */{
                                    _0: Stdlib.$at(r._0, r_loc._0)
                                  };
                          }
                          if (!r_loc) {
                            return r;
                          }
                          
                        }
                        if (typeof r_loc === "number" && r_loc) {
                          return /* Unused */1;
                        } else {
                          return r_loc;
                        }
                      }
                      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                                MEL_EXN_ID: "Assert_failure",
                                _1: [
                                  "jscomp/test/ocaml_typedtree_test.ml",
                                  40429,
                                  23
                                ]
                              });
                    }), extract_columns(pss, qs), extract_elements(qs), /* Used */0);
      } else if (satisfiable(Stdlib__List.map(make_vector, pss), qs.no_ors)) {
        return /* Used */0;
      } else {
        return /* Unused */1;
      }
    }
  };
}

function every_both(pss, qs, q1, q2) {
  const qs1_no_ors = qs.no_ors;
  const qs1_ors = qs.ors;
  const qs1_active = {
    hd: q1,
    tl: /* [] */0
  };
  const qs1 = {
    no_ors: qs1_no_ors,
    ors: qs1_ors,
    active: qs1_active
  };
  const qs2_no_ors = qs.no_ors;
  const qs2_ors = qs.ors;
  const qs2_active = {
    hd: q2,
    tl: /* [] */0
  };
  const qs2 = {
    no_ors: qs2_no_ors,
    ors: qs2_ors,
    active: qs2_active
  };
  const r1 = every_satisfiables(pss, qs1);
  const r2 = every_satisfiables(compat(q1, q2) ? ({
            hd: qs1,
            tl: pss
          }) : pss, qs2);
  if (typeof r1 === "number") {
    if (r1) {
      if (typeof r2 === "number") {
        if (r2) {
          return /* Unused */1;
        } else {
          return /* Upartial */{
                  _0: {
                    hd: q1,
                    tl: /* [] */0
                  }
                };
        }
      } else {
        return /* Upartial */{
                _0: {
                  hd: q1,
                  tl: r2._0
                }
              };
      }
    } else if (typeof r2 === "number" && r2) {
      return /* Upartial */{
              _0: {
                hd: q2,
                tl: /* [] */0
              }
            };
    } else {
      return r2;
    }
  }
  const u1 = r1._0;
  if (typeof r2 === "number") {
    if (r2) {
      return /* Upartial */{
              _0: Stdlib.$at(u1, {
                    hd: q2,
                    tl: /* [] */0
                  })
            };
    } else {
      return r1;
    }
  } else {
    return /* Upartial */{
            _0: Stdlib.$at(u1, r2._0)
          };
  }
}

function le_pat(_p, _q) {
  while(true) {
    const q = _q;
    const p = _p;
    const match = p.pat_desc;
    const match$1 = q.pat_desc;
    let exit = 0;
    if (typeof match === "number") {
      return true;
    }
    switch (match.TAG | 0) {
      case /* Tpat_var */0 :
          return true;
      case /* Tpat_alias */1 :
          _p = match._0;
          continue ;
      case /* Tpat_constant */2 :
          if (typeof match$1 !== "number") {
            switch (match$1.TAG | 0) {
              case /* Tpat_alias */1 :
                  exit = 2;
                  break;
              case /* Tpat_constant */2 :
                  return const_compare(match._0, match$1._0) === 0;
              default:
                
            }
          }
          break;
      case /* Tpat_tuple */3 :
          if (typeof match$1 !== "number") {
            switch (match$1.TAG | 0) {
              case /* Tpat_alias */1 :
                  exit = 2;
                  break;
              case /* Tpat_tuple */3 :
                  return le_pats(match._0, match$1._0);
              default:
                
            }
          }
          break;
      case /* Tpat_construct */4 :
          if (typeof match$1 !== "number") {
            switch (match$1.TAG | 0) {
              case /* Tpat_alias */1 :
                  exit = 2;
                  break;
              case /* Tpat_construct */4 :
                  if (equal_tag(match._1.cstr_tag, match$1._1.cstr_tag)) {
                    return le_pats(match._2, match$1._2);
                  } else {
                    return false;
                  }
              default:
                
            }
          }
          break;
      case /* Tpat_variant */5 :
          const p1 = match._1;
          const l1 = match._0;
          if (p1 !== undefined) {
            if (typeof match$1 !== "number") {
              switch (match$1.TAG | 0) {
                case /* Tpat_alias */1 :
                    exit = 2;
                    break;
                case /* Tpat_variant */5 :
                    const p2 = match$1._1;
                    if (p2 === undefined) {
                      return false;
                    }
                    if (l1 !== match$1._0) {
                      return false;
                    }
                    _q = p2;
                    _p = p1;
                    continue ;
                default:
                  
              }
            }
            
          } else if (typeof match$1 !== "number") {
            switch (match$1.TAG | 0) {
              case /* Tpat_alias */1 :
                  exit = 2;
                  break;
              case /* Tpat_variant */5 :
                  if (match$1._1 !== undefined) {
                    return false;
                  } else {
                    return l1 === match$1._0;
                  }
              default:
                
            }
          }
          break;
      case /* Tpat_record */6 :
          if (typeof match$1 !== "number") {
            switch (match$1.TAG | 0) {
              case /* Tpat_alias */1 :
                  exit = 2;
                  break;
              case /* Tpat_record */6 :
                  const match$2 = records_args(match._0, match$1._0);
                  return le_pats(match$2[0], match$2[1]);
              default:
                
            }
          }
          break;
      case /* Tpat_array */7 :
          const ps = match._0;
          if (typeof match$1 !== "number") {
            switch (match$1.TAG | 0) {
              case /* Tpat_alias */1 :
                  exit = 2;
                  break;
              case /* Tpat_array */7 :
                  const qs = match$1._0;
                  if (Stdlib__List.length(ps) === Stdlib__List.length(qs)) {
                    return le_pats(ps, qs);
                  } else {
                    return false;
                  }
              default:
                
            }
          }
          break;
      case /* Tpat_or */8 :
          exit = 2;
          break;
      case /* Tpat_lazy */9 :
          if (typeof match$1 !== "number") {
            switch (match$1.TAG | 0) {
              case /* Tpat_alias */1 :
                  exit = 2;
                  break;
              case /* Tpat_lazy */9 :
                  _q = match$1._0;
                  _p = match._0;
                  continue ;
              default:
                
            }
          }
          break;
      
    }
    if (exit === 2 && typeof match$1 !== "number" && match$1.TAG === /* Tpat_alias */1) {
      _q = match$1._0;
      continue ;
    }
    return !satisfiable({
                hd: {
                  hd: p,
                  tl: /* [] */0
                },
                tl: /* [] */0
              }, {
                hd: q,
                tl: /* [] */0
              });
  };
}

function le_pats(_ps, _qs) {
  while(true) {
    const qs = _qs;
    const ps = _ps;
    if (!ps) {
      return true;
    }
    if (!qs) {
      return true;
    }
    if (!le_pat(ps.hd, qs.hd)) {
      return false;
    }
    _qs = qs.tl;
    _ps = ps.tl;
    continue ;
  };
}

function get_mins(le, ps) {
  const select_rec = function (_r, _param) {
    while(true) {
      const param = _param;
      const r = _r;
      if (!param) {
        return r;
      }
      const ps = param.tl;
      const p = param.hd;
      if (Stdlib__List.exists((function (p0) {
                return Curry._2(le, p0, p);
              }), ps)) {
        _param = ps;
        continue ;
      }
      _param = ps;
      _r = {
        hd: p,
        tl: r
      };
      continue ;
    };
  };
  return select_rec(/* [] */0, select_rec(/* [] */0, ps));
}

function pressure_variants$1(tdefs, patl) {
  const pss = Stdlib__List.map((function (p) {
          return {
                  hd: p,
                  tl: {
                    hd: omega,
                    tl: /* [] */0
                  }
                };
        }), patl);
  pressure_variants(Caml_option.some(tdefs), pss);
}

function initial_matrix(_param) {
  while(true) {
    const param = _param;
    if (!param) {
      return /* [] */0;
    }
    const match = param.hd;
    if (match.c_guard === undefined) {
      return {
              hd: {
                hd: match.c_lhs,
                tl: /* [] */0
              },
              tl: initial_matrix(param.tl)
            };
    }
    _param = param.tl;
    continue ;
  };
}

const NoGuard = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Parmatch.NoGuard");

function initial_all(no_guard, param) {
  if (param) {
    const match = param.hd;
    const pat = match.c_lhs;
    return {
            hd: [
              {
                hd: pat,
                tl: /* [] */0
              },
              pat.pat_loc
            ],
            tl: initial_all(no_guard && match.c_guard === undefined, param.tl)
          };
  }
  if (!no_guard) {
    return /* [] */0;
  }
  throw new Caml_js_exceptions.MelangeError(NoGuard, {
            MEL_EXN_ID: NoGuard
          });
}

function do_filter_var(param) {
  if (!param) {
    return /* [] */0;
  }
  const match = param.hd;
  const match$1 = match[0];
  if (match$1) {
    return {
            hd: [
              match$1.tl,
              match[1]
            ],
            tl: do_filter_var(param.tl)
          };
  } else {
    return /* [] */0;
  }
}

function do_filter_one(q, pss) {
  const filter_rec = function (_param) {
    while(true) {
      const param = _param;
      if (!param) {
        return /* [] */0;
      }
      const match = param.hd;
      const match$1 = match[0];
      if (!match$1) {
        return /* [] */0;
      }
      const p = match$1.hd;
      const match$2 = p.pat_desc;
      if (typeof match$2 !== "number") {
        switch (match$2.TAG | 0) {
          case /* Tpat_alias */1 :
              _param = {
                hd: [
                  {
                    hd: match$2._0,
                    tl: match$1.tl
                  },
                  match[1]
                ],
                tl: param.tl
              };
              continue ;
          case /* Tpat_or */8 :
              const loc = match[1];
              const ps = match$1.tl;
              _param = {
                hd: [
                  {
                    hd: match$2._0,
                    tl: ps
                  },
                  loc
                ],
                tl: {
                  hd: [
                    {
                      hd: match$2._1,
                      tl: ps
                    },
                    loc
                  ],
                  tl: param.tl
                }
              };
              continue ;
          default:
            
        }
      }
      const pss = param.tl;
      if (simple_match(q, p)) {
        return {
                hd: [
                  Stdlib.$at(simple_match_args(q, p), match$1.tl),
                  match[1]
                ],
                tl: filter_rec(pss)
              };
      }
      _param = pss;
      continue ;
    };
  };
  return filter_rec(pss);
}

function do_match(_pss, _qs) {
  while(true) {
    const qs = _qs;
    const pss = _pss;
    if (qs) {
      const qs$1 = qs.tl;
      const q = qs.hd;
      const match = q.pat_desc;
      if (typeof match === "number") {
        _qs = qs$1;
        _pss = do_filter_var(pss);
        continue ;
      }
      if (match.TAG === /* Tpat_or */8) {
        const r = do_match(pss, {
              hd: match._0,
              tl: qs$1
            });
        if (r !== undefined) {
          return r;
        }
        _qs = {
          hd: match._1,
          tl: qs$1
        };
        continue ;
      }
      const q0 = normalize_pat(q);
      _qs = Stdlib.$at(simple_match_args(q0, q), qs$1);
      _pss = do_filter_one(q0, pss);
      continue ;
    } else {
      if (!pss) {
        return ;
      }
      const match$1 = pss.hd;
      if (match$1[0]) {
        return ;
      } else {
        return Caml_option.some(match$1[1]);
      }
    }
  };
}

function check_partial_all(v, casel) {
  try {
    const pss = initial_all(true, casel);
    return do_match(pss, {
                hd: v,
                tl: /* [] */0
              });
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === NoGuard) {
      return ;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function get_first(f, _param) {
  while(true) {
    const param = _param;
    if (!param) {
      return ;
    }
    const x = Curry._1(f, param.hd);
    if (x !== undefined) {
      return x;
    }
    _param = param.tl;
    continue ;
  };
}

function select(param) {
  if (!param) {
    return /* [] */0;
  }
  const xs = param.hd;
  if (!param.tl) {
    return Stdlib__List.map((function (y) {
                  return {
                          hd: y,
                          tl: /* [] */0
                        };
                }), xs);
  }
  if (!xs) {
    return /* [] */0;
  }
  const ys = param.tl;
  const x = xs.hd;
  return Stdlib.$at(Stdlib__List.map((function (lst) {
                    return {
                            hd: x,
                            tl: lst
                          };
                  }), select(ys)), select({
                  hd: xs.tl,
                  tl: ys
                }));
}

const name_counter$1 = {
  contents: 0
};

function fresh(name) {
  const current = name_counter$1.contents;
  name_counter$1.contents = name_counter$1.contents + 1 | 0;
  return "#$" + (name + String(current));
}

function conv(typed) {
  const constrs = Stdlib__Hashtbl.create(undefined, 0);
  const labels = Stdlib__Hashtbl.create(undefined, 0);
  const loop = function (_pat) {
    while(true) {
      const pat = _pat;
      const lst = pat.pat_desc;
      if (typeof lst === "number") {
        return {
                hd: mk$1(undefined, undefined, /* Ppat_any */0),
                tl: /* [] */0
              };
      }
      switch (lst.TAG | 0) {
        case /* Tpat_alias */1 :
            _pat = lst._0;
            continue ;
        case /* Tpat_tuple */3 :
            const results = select(Stdlib__List.map(loop, lst._0));
            return Stdlib__List.map((function (lst) {
                          return mk$1(undefined, undefined, {
                                      TAG: /* Ppat_tuple */4,
                                      _0: lst
                                    });
                        }), results);
        case /* Tpat_construct */4 :
            const lst$1 = lst._2;
            const cstr = lst._1;
            const id = fresh(cstr.cstr_name);
            const lid_txt = {
              TAG: /* Lident */0,
              _0: id
            };
            const lid_loc = lst._0.loc;
            const lid = {
              txt: lid_txt,
              loc: lid_loc
            };
            Stdlib__Hashtbl.add(constrs, id, cstr);
            const results$1 = select(Stdlib__List.map(loop, lst$1));
            if (lst$1) {
              return Stdlib__List.map((function (lst) {
                            let arg;
                            if (lst) {
                              arg = lst.tl ? mk$1(undefined, undefined, {
                                      TAG: /* Ppat_tuple */4,
                                      _0: lst
                                    }) : lst.hd;
                            } else {
                              throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                                        MEL_EXN_ID: "Assert_failure",
                                        _1: [
                                          "jscomp/test/ocaml_typedtree_test.ml",
                                          40764,
                                          28
                                        ]
                                      });
                            }
                            return mk$1(undefined, undefined, {
                                        TAG: /* Ppat_construct */5,
                                        _0: lid,
                                        _1: arg
                                      });
                          }), results$1);
            } else {
              return {
                      hd: mk$1(undefined, undefined, {
                            TAG: /* Ppat_construct */5,
                            _0: lid,
                            _1: undefined
                          }),
                      tl: /* [] */0
                    };
            }
        case /* Tpat_variant */5 :
            const p_opt = lst._1;
            const label = lst._0;
            if (p_opt === undefined) {
              return {
                      hd: mk$1(undefined, undefined, {
                            TAG: /* Ppat_variant */6,
                            _0: label,
                            _1: undefined
                          }),
                      tl: /* [] */0
                    };
            }
            const results$2 = loop(p_opt);
            return Stdlib__List.map((function (p) {
                          return mk$1(undefined, undefined, {
                                      TAG: /* Ppat_variant */6,
                                      _0: label,
                                      _1: p
                                    });
                        }), results$2);
        case /* Tpat_record */6 :
            const subpatterns = lst._0;
            const pats = select(Stdlib__List.map((function (param) {
                        return loop(param[2]);
                      }), subpatterns));
            const label_idents = Stdlib__List.map((function (param) {
                    const lbl = param[1];
                    const id = fresh(lbl.lbl_name);
                    Stdlib__Hashtbl.add(labels, id, lbl);
                    return {
                            TAG: /* Lident */0,
                            _0: id
                          };
                  }), subpatterns);
            return Stdlib__List.map((function (lst) {
                          const lst$1 = Stdlib__List.map2((function (lid, pat) {
                                  return [
                                          {
                                            txt: lid,
                                            loc: none
                                          },
                                          pat
                                        ];
                                }), label_idents, lst);
                          return mk$1(undefined, undefined, {
                                      TAG: /* Ppat_record */7,
                                      _0: lst$1,
                                      _1: /* Open */1
                                    });
                        }), pats);
        case /* Tpat_array */7 :
            const results$3 = select(Stdlib__List.map(loop, lst._0));
            return Stdlib__List.map((function (lst) {
                          return mk$1(undefined, undefined, {
                                      TAG: /* Ppat_array */8,
                                      _0: lst
                                    });
                        }), results$3);
        case /* Tpat_or */8 :
            return Stdlib.$at(loop(lst._0), loop(lst._1));
        case /* Tpat_lazy */9 :
            const results$4 = loop(lst._0);
            return Stdlib__List.map((function (p) {
                          return mk$1(undefined, undefined, {
                                      TAG: /* Ppat_lazy */12,
                                      _0: p
                                    });
                        }), results$4);
        default:
          return {
                  hd: mk$1(undefined, undefined, /* Ppat_any */0),
                  tl: /* [] */0
                };
      }
    };
  };
  const ps = loop(typed);
  return [
          ps,
          constrs,
          labels
        ];
}

function do_check_partial(pred, exhaust, loc, casel, pss) {
  if (pss) {
    const match = Curry._3(exhaust, undefined, pss, Stdlib__List.length(pss.hd));
    if (!match) {
      return /* Total */1;
    }
    const match$1 = match._0;
    if (!match$1) {
      return fatal_error("Parmatch.check_partial");
    }
    if (match$1.tl) {
      return fatal_error("Parmatch.check_partial");
    }
    const u = match$1.hd;
    let v;
    if (pred !== undefined) {
      const match$2 = conv(u);
      v = get_first(Curry._2(pred, match$2[1], match$2[2]), match$2[0]);
    } else {
      v = u;
    }
    if (v === undefined) {
      return /* Total */1;
    }
    const match$3 = v.pat_desc;
    let errmsg;
    let exit = 0;
    if (typeof match$3 === "number" || !(match$3.TAG === /* Tpat_construct */4 && match$3._1.cstr_name === "*extension*")) {
      exit = 1;
    } else {
      errmsg = "_\nMatching over values of extensible variant types must include\na wild card pattern in order to be exhaustive.";
    }
    if (exit === 1) {
      try {
        const buf = Stdlib__Buffer.create(16);
        const fmt = Stdlib__Format.formatter_of_buffer(buf);
        top_pretty(fmt, v);
        const match$4 = check_partial_all(v, casel);
        if (match$4 !== undefined) {
          Stdlib__Buffer.add_string(buf, "\n(However, some guarded clause may match this value.)");
        }
        errmsg = Stdlib__Buffer.contents(buf);
      }
      catch (exn){
        errmsg = "";
      }
    }
    prerr_warning(loc, {
          TAG: /* Partial_match */3,
          _0: errmsg
        });
    return /* Partial */0;
  }
  if (casel) {
    prerr_warning(loc, /* All_clauses_guarded */12);
  }
  return /* Partial */0;
}

function do_check_partial_normal(loc, casel, pss) {
  return do_check_partial(undefined, exhaust, loc, casel, pss);
}

function add_path(path, paths) {
  if (!paths) {
    return {
            hd: path,
            tl: /* [] */0
          };
  }
  const x = paths.hd;
  if (same(path, x)) {
    return paths;
  } else {
    return {
            hd: x,
            tl: add_path(path, paths.tl)
          };
  }
}

function extendable_path(path) {
  return !(same(path, path_bool) || same(path, path_list) || same(path, path_unit) || same(path, path_option));
}

function collect_paths_from_pat(_r, _p) {
  while(true) {
    const p = _p;
    const r = _r;
    const p$1 = p.pat_desc;
    if (typeof p$1 === "number") {
      return r;
    }
    switch (p$1.TAG | 0) {
      case /* Tpat_construct */4 :
          switch (p$1._1.cstr_tag.TAG | 0) {
            case /* Cstr_constant */0 :
            case /* Cstr_block */1 :
                break;
            case /* Cstr_extension */2 :
                return Stdlib__List.fold_left(collect_paths_from_pat, r, p$1._2);
            
          }
          const path = get_type_path(p.pat_type, p.pat_env);
          return Stdlib__List.fold_left(collect_paths_from_pat, extendable_path(path) ? add_path(path, r) : r, p$1._2);
      case /* Tpat_variant */5 :
          const p$2 = p$1._1;
          if (p$2 === undefined) {
            return r;
          }
          _p = p$2;
          continue ;
      case /* Tpat_record */6 :
          return Stdlib__List.fold_left((function (r, param) {
                        return collect_paths_from_pat(r, param[2]);
                      }), r, p$1._0);
      case /* Tpat_tuple */3 :
      case /* Tpat_array */7 :
          return Stdlib__List.fold_left(collect_paths_from_pat, r, p$1._0);
      case /* Tpat_or */8 :
          _p = p$1._1;
          _r = collect_paths_from_pat(r, p$1._0);
          continue ;
      case /* Tpat_alias */1 :
      case /* Tpat_lazy */9 :
          _p = p$1._0;
          continue ;
      default:
        return r;
    }
  };
}

function do_check_fragile_param(exhaust, loc, casel, pss) {
  const exts = Stdlib__List.fold_left((function (r, c) {
          return collect_paths_from_pat(r, c.c_lhs);
        }), /* [] */0, casel);
  if (!exts) {
    return ;
  }
  if (!pss) {
    return ;
  }
  const ps = pss.hd;
  Stdlib__List.iter((function (ext) {
          const match = Curry._3(exhaust, ext, pss, Stdlib__List.length(ps));
          if (match) {
            return ;
          } else {
            return prerr_warning(loc, {
                        TAG: /* Fragile_match */1,
                        _0: name(undefined, ext)
                      });
          }
        }), exts);
}

function do_check_fragile_normal(param, param$1, param$2) {
  return do_check_fragile_param(exhaust, param, param$1, param$2);
}

function do_check_fragile_gadt(param, param$1, param$2) {
  return do_check_fragile_param(exhaust_gadt$1, param, param$1, param$2);
}

function check_partial_param(do_check_partial, do_check_fragile, loc, casel) {
  if (!is_active({
          TAG: /* Partial_match */3,
          _0: ""
        })) {
    return /* Partial */0;
  }
  const pss = initial_matrix(casel);
  const pss$1 = get_mins(le_pats, pss);
  const total = Curry._3(do_check_partial, loc, casel, pss$1);
  if (total === /* Total */1 && is_active({
          TAG: /* Fragile_match */1,
          _0: ""
        })) {
    Curry._3(do_check_fragile, loc, casel, pss$1);
  }
  return total;
}

function check_partial(param, param$1) {
  return check_partial_param(do_check_partial_normal, do_check_fragile_normal, param, param$1);
}

const Already_bound = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Typetexp.Already_bound");

const $$Error$6 = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Typetexp.Error");

const Error_forward = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Typetexp.Error_forward");

function string_of_payload(param) {
  switch (param.TAG | 0) {
    case /* PStr */0 :
        const match = param._0;
        if (!match) {
          return ;
        }
        const match$1 = match.hd.pstr_desc;
        if (match$1.TAG !== /* Pstr_eval */0) {
          return ;
        }
        const c = match$1._0.pexp_desc;
        if (c.TAG === /* Pexp_constant */1 && !match.tl) {
          let param$1 = c._0;
          if (param$1.TAG === /* Const_string */2) {
            return param$1._0;
          } else {
            return ;
          }
        } else {
          return ;
        }
    case /* PTyp */1 :
    case /* PPat */2 :
        return ;
    
  }
}

function error_of_extension(ext) {
  const match = ext[0];
  const txt = match.txt;
  let exit = 0;
  switch (txt) {
    case "error" :
    case "ocaml.error" :
        exit = 1;
        break;
    default:
      return Curry._1(errorf(match.loc, undefined, undefined, /* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "Uninterpreted extension '",
                        _1: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "'.",
                            _1: /* End_of_format */0
                          }
                        }
                      },
                      _1: "Uninterpreted extension '%s'."
                    }), txt);
  }
  if (exit === 1) {
    const p = ext[1];
    const loc = match.loc;
    const sub_from = function (inner) {
      if (!inner) {
        return /* [] */0;
      }
      const match = inner.hd.pstr_desc;
      if (match.TAG === /* Pstr_extension */14) {
        return {
                hd: error_of_extension(match._0),
                tl: sub_from(inner.tl)
              };
      } else {
        return {
                hd: Curry._1(errorf(loc, undefined, undefined, /* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "Invalid syntax for sub-error of extension '",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* String_literal */11,
                                _0: "'.",
                                _1: /* End_of_format */0
                              }
                            }
                          },
                          _1: "Invalid syntax for sub-error of extension '%s'."
                        }), txt),
                tl: sub_from(inner.tl)
              };
      }
    };
    let exit$1 = 0;
    switch (p.TAG | 0) {
      case /* PStr */0 :
          const match$1 = p._0;
          if (match$1) {
            const match$2 = match$1.hd.pstr_desc;
            if (match$2.TAG === /* Pstr_eval */0) {
              const match$3 = match$2._0.pexp_desc;
              if (match$3.TAG === /* Pexp_constant */1) {
                const match$4 = match$3._0;
                if (match$4.TAG === /* Const_string */2) {
                  const msg = match$4._0;
                  let exit$2 = 0;
                  const match$5 = match$1.tl;
                  if (match$5) {
                    const match$6 = match$5.hd.pstr_desc;
                    if (match$6.TAG === /* Pstr_eval */0) {
                      const match$7 = match$6._0.pexp_desc;
                      if (match$7.TAG === /* Pexp_constant */1) {
                        const match$8 = match$7._0;
                        if (match$8.TAG === /* Const_string */2) {
                          return error(loc, sub_from(match$5.tl), match$8._0, msg);
                        }
                        exit$2 = 3;
                      } else {
                        exit$2 = 3;
                      }
                    } else {
                      exit$2 = 3;
                    }
                  } else {
                    exit$2 = 3;
                  }
                  if (exit$2 === 3) {
                    return error(loc, sub_from(match$1.tl), undefined, msg);
                  }
                  
                } else {
                  exit$1 = 2;
                }
              } else {
                exit$1 = 2;
              }
            } else {
              exit$1 = 2;
            }
          } else {
            exit$1 = 2;
          }
          break;
      case /* PTyp */1 :
      case /* PPat */2 :
          exit$1 = 2;
          break;
      
    }
    if (exit$1 === 2) {
      return Curry._1(errorf(loc, undefined, undefined, /* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "Invalid syntax for extension '",
                        _1: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "'.",
                            _1: /* End_of_format */0
                          }
                        }
                      },
                      _1: "Invalid syntax for extension '%s'."
                    }), txt);
    }
    
  }
  
}

function check_deprecated(loc, attrs, s) {
  Stdlib__List.iter((function (param) {
          switch (param[0].txt) {
            case "deprecated" :
            case "ocaml.deprecated" :
                break;
            default:
              return ;
          }
          const txt = string_of_payload(param[1]);
          if (txt !== undefined) {
            if (bs_vscode) {
              return prerr_warning(loc, {
                          TAG: /* Deprecated */0,
                          _0: s + (" " + txt)
                        });
            } else {
              return prerr_warning(loc, {
                          TAG: /* Deprecated */0,
                          _0: s + ("\n" + txt)
                        });
            }
          } else {
            return prerr_warning(loc, {
                        TAG: /* Deprecated */0,
                        _0: s
                      });
          }
        }), attrs);
}

const newrecord$1 = Caml_obj.caml_obj_dup(default_mapper);

newrecord$1.attribute = (function (param, a) {
    let exit = 0;
    switch (a[0].txt) {
      case "ocaml.ppwarning" :
      case "ppwarning" :
          exit = 1;
          break;
      default:
        
    }
    if (exit === 1) {
      const match = a[1];
      switch (match.TAG | 0) {
        case /* PStr */0 :
            const match$1 = match._0;
            if (match$1) {
              const match$2 = match$1.hd;
              const match$3 = match$2.pstr_desc;
              if (match$3.TAG === /* Pstr_eval */0) {
                const match$4 = match$3._0.pexp_desc;
                if (match$4.TAG === /* Pexp_constant */1) {
                  const match$5 = match$4._0;
                  if (match$5.TAG === /* Const_string */2) {
                    if (match$1.tl) {
                      
                    } else {
                      prerr_warning(match$2.pstr_loc, {
                            TAG: /* Preprocessor */10,
                            _0: match$5._0
                          });
                    }
                  }
                  
                }
                
              }
              
            }
            break;
        case /* PTyp */1 :
        case /* PPat */2 :
            break;
        
      }
    }
    return a;
  });

const warning_scope = {
  contents: /* [] */0
};

function warning_enter_scope(param) {
  warning_scope.contents = {
    hd: current.contents,
    tl: warning_scope.contents
  };
}

function warning_leave_scope(param) {
  const match = warning_scope.contents;
  if (match) {
    current.contents = match.hd;
    warning_scope.contents = match.tl;
    return ;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              41342,
              10
            ]
          });
}

function warning_attribute(attrs) {
  const $$process = function (loc, txt, errflag, payload) {
    const s = string_of_payload(payload);
    if (s === undefined) {
      return prerr_warning(loc, {
                  TAG: /* Attribute_payload */30,
                  _0: txt,
                  _1: "A single string literal is expected"
                });
    }
    try {
      return parse_options(errflag, s);
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib__Arg.Bad) {
        return prerr_warning(loc, {
                    TAG: /* Attribute_payload */30,
                    _0: txt,
                    _1: "Ill-formed list of warnings"
                  });
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  };
  Stdlib__List.iter((function (param) {
          const match = param[0];
          const txt = match.txt;
          let exit = 0;
          switch (txt) {
            case "ocaml.warnerror" :
            case "warnerror" :
                exit = 2;
                break;
            case "ocaml.warning" :
            case "warning" :
                exit = 1;
                break;
            default:
              return ;
          }
          switch (exit) {
            case 1 :
                return $$process(match.loc, txt, false, param[1]);
            case 2 :
                return $$process(match.loc, txt, true, param[1]);
            
          }
        }), attrs);
}

function narrow_unbound_lid_error(env, loc, lid, make_error) {
  const check_module = function (mlid) {
    try {
      lookup_module(true, mlid, env);
      return ;
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        return narrow_unbound_lid_error(env, loc, mlid, (function (lid) {
                      return {
                              TAG: /* Unbound_module */20,
                              _0: lid
                            };
                    }));
      }
      if (exn.MEL_EXN_ID === Recmodule) {
        throw new Caml_js_exceptions.MelangeError($$Error$6, {
                  MEL_EXN_ID: $$Error$6,
                  _1: loc,
                  _2: env,
                  _3: /* Illegal_reference_to_recursive_module */1
                });
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  };
  switch (lid.TAG | 0) {
    case /* Lident */0 :
        break;
    case /* Ldot */1 :
        const mlid = lid._0;
        check_module(mlid);
        const md = find_module(false, lookup_module(true, mlid, env), env);
        const match = scrape_alias(env, undefined, md.md_type);
        if (match.TAG === /* Mty_functor */2) {
          throw new Caml_js_exceptions.MelangeError($$Error$6, {
                    MEL_EXN_ID: $$Error$6,
                    _1: loc,
                    _2: env,
                    _3: {
                      TAG: /* Access_functor_as_structure */25,
                      _0: mlid
                    }
                  });
        }
        break;
    case /* Lapply */2 :
        check_module(lid._0);
        check_module(lid._1);
        throw new Caml_js_exceptions.MelangeError($$Error$6, {
                  MEL_EXN_ID: $$Error$6,
                  _1: loc,
                  _2: env,
                  _3: {
                    TAG: /* Ill_typed_functor_application */24,
                    _0: lid
                  }
                });
    
  }
  throw new Caml_js_exceptions.MelangeError($$Error$6, {
            MEL_EXN_ID: $$Error$6,
            _1: loc,
            _2: env,
            _3: Curry._1(make_error, lid)
          });
}

function find_component(lookup, make_error, env, loc, lid) {
  try {
    switch (lid.TAG | 0) {
      case /* Ldot */1 :
          const match = lid._0;
          switch (match.TAG | 0) {
            case /* Lident */0 :
                if (match._0 === "*predef*") {
                  return Curry._2(lookup, {
                              TAG: /* Lident */0,
                              _0: lid._1
                            }, initial_safe_string);
                } else {
                  return Curry._2(lookup, lid, env);
                }
            case /* Ldot */1 :
            case /* Lapply */2 :
                return Curry._2(lookup, lid, env);
            
          }
      case /* Lident */0 :
      case /* Lapply */2 :
          return Curry._2(lookup, lid, env);
      
    }
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return narrow_unbound_lid_error(env, loc, lid, make_error);
    }
    if (exn.MEL_EXN_ID === Recmodule) {
      throw new Caml_js_exceptions.MelangeError($$Error$6, {
                MEL_EXN_ID: $$Error$6,
                _1: loc,
                _2: env,
                _3: /* Illegal_reference_to_recursive_module */1
              });
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function find_type(env, loc, lid) {
  const r = find_component(lookup_type$1, (function (lid) {
          return {
                  TAG: /* Unbound_type_constructor */1,
                  _0: lid
                };
        }), env, loc, lid);
  check_deprecated(loc, r[1].type_attributes, name(undefined, r[0]));
  return r;
}

function find_constructor(param, param$1, param$2) {
  return find_component(lookup_constructor, (function (lid) {
                return {
                        TAG: /* Unbound_constructor */18,
                        _0: lid
                      };
              }), param, param$1, param$2);
}

function find_all_constructors(param, param$1, param$2) {
  return find_component(lookup_all_constructors$1, (function (lid) {
                return {
                        TAG: /* Unbound_constructor */18,
                        _0: lid
                      };
              }), param, param$1, param$2);
}

function find_all_labels(param, param$1, param$2) {
  return find_component(lookup_all_labels$1, (function (lid) {
                return {
                        TAG: /* Unbound_label */19,
                        _0: lid
                      };
              }), param, param$1, param$2);
}

function find_class$1(env, loc, lid) {
  const r = find_component(lookup_class$1, (function (lid) {
          return {
                  TAG: /* Unbound_class */21,
                  _0: lid
                };
        }), env, loc, lid);
  check_deprecated(loc, r[1].cty_attributes, name(undefined, r[0]));
  return r;
}

function find_value$1(env, loc, lid) {
  check_value_name(last$1(lid), loc);
  const r = find_component(lookup_value$1, (function (lid) {
          return {
                  TAG: /* Unbound_value */17,
                  _0: lid
                };
        }), env, loc, lid);
  check_deprecated(loc, r[1].val_attributes, name(undefined, r[0]));
  return r;
}

function lookup_module$1(loadOpt, env, loc, lid) {
  const load = loadOpt !== undefined ? loadOpt : false;
  return find_component((function (lid, env) {
                  return [
                          lookup_module(load, lid, env),
                          undefined
                        ];
                }), (function (lid) {
                  return {
                          TAG: /* Unbound_module */20,
                          _0: lid
                        };
                }), env, loc, lid)[0];
}

function find_module$1(env, loc, lid) {
  const path = lookup_module$1(true, env, loc, lid);
  const decl = find_module(false, path, env);
  check_deprecated(loc, decl.md_attributes, name(undefined, path));
  return [
          path,
          decl
        ];
}

function find_modtype$1(env, loc, lid) {
  const r = find_component(lookup_modtype, (function (lid) {
          return {
                  TAG: /* Unbound_modtype */22,
                  _0: lid
                };
        }), env, loc, lid);
  check_deprecated(loc, r[1].mtd_attributes, name(undefined, r[0]));
  return r;
}

function find_class_type(env, loc, lid) {
  const r = find_component(lookup_cltype$1, (function (lid) {
          return {
                  TAG: /* Unbound_cltype */23,
                  _0: lid
                };
        }), env, loc, lid);
  check_deprecated(loc, r[1].clty_attributes, name(undefined, r[0]));
  return r;
}

function unbound_constructor_error(env, lid) {
  return narrow_unbound_lid_error(env, lid.loc, lid.txt, (function (lid) {
                return {
                        TAG: /* Unbound_constructor */18,
                        _0: lid
                      };
              }));
}

function unbound_label_error(env, lid) {
  return narrow_unbound_lid_error(env, lid.loc, lid.txt, (function (lid) {
                return {
                        TAG: /* Unbound_label */19,
                        _0: lid
                      };
              }));
}

const transl_modtype_longident = {
  contents: (function (param) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  41489,
                  45
                ]
              });
    })
};

const transl_modtype = {
  contents: (function (param) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  41490,
                  35
                ]
              });
    })
};

function create_package_mty(fake, loc, env, param) {
  const l = Stdlib__List.sort((function (param, param$1) {
          const s2 = param$1[0];
          const s1 = param[0];
          if (Caml_obj.caml_equal(s1.txt, s2.txt)) {
            throw new Caml_js_exceptions.MelangeError($$Error$6, {
                      MEL_EXN_ID: $$Error$6,
                      _1: loc,
                      _2: env,
                      _3: {
                        TAG: /* Multiple_constraints_on_type */15,
                        _0: s1.txt
                      }
                    });
          }
          return Caml_obj.caml_compare(s1.txt, s2.txt);
        }), param[1]);
  return [
          l,
          Stdlib__List.fold_left((function (mty, param) {
                  const s = param[0];
                  const d_ptype_name = {
                    txt: last$1(s.txt),
                    loc: s.loc
                  };
                  const d_ptype_manifest = fake ? undefined : param[1];
                  const d = {
                    ptype_name: d_ptype_name,
                    ptype_params: /* [] */0,
                    ptype_cstrs: /* [] */0,
                    ptype_kind: /* Ptype_abstract */0,
                    ptype_private: /* Public */1,
                    ptype_manifest: d_ptype_manifest,
                    ptype_attributes: /* [] */0,
                    ptype_loc: loc
                  };
                  return mk$3(loc, undefined, {
                              TAG: /* Pmty_with */3,
                              _0: mty,
                              _1: {
                                hd: {
                                  TAG: /* Pwith_type */0,
                                  _0: {
                                    txt: s.txt,
                                    loc: loc
                                  },
                                  _1: d
                                },
                                tl: /* [] */0
                              }
                            });
                }), mk$3(loc, undefined, {
                    TAG: /* Pmty_ident */0,
                    _0: param[0]
                  }), l)
        ];
}

const type_variables = {
  contents: /* Empty */0
};

const univars = {
  contents: /* [] */0
};

const pre_univars = {
  contents: /* [] */0
};

const used_variables = {
  contents: /* Empty */0
};

function reset_type_variables(param) {
  reset_global_level(undefined);
  type_variables.contents = /* Empty */0;
}

function narrow(param) {
  return [
          increase_global_level(undefined),
          type_variables.contents
        ];
}

function widen(param) {
  global_level.contents = param[0];
  type_variables.contents = param[1];
}

function strict_lowercase(c) {
  if (c === /* '_' */95) {
    return true;
  } else if (c >= /* 'a' */97) {
    return c <= /* 'z' */122;
  } else {
    return false;
  }
}

function validate_name(s) {
  if (s !== undefined && s !== "" && strict_lowercase(Caml_string.get(s, 0))) {
    return s;
  }
  
}

function transl_type_param(env, styp) {
  const loc = styp.ptyp_loc;
  const name = styp.ptyp_desc;
  if (typeof name === "number") {
    const ty = new_global_var(validate_name("_"), undefined);
    return {
            ctyp_desc: /* Ttyp_any */0,
            ctyp_type: ty,
            ctyp_env: env,
            ctyp_loc: loc,
            ctyp_attributes: styp.ptyp_attributes
          };
  }
  if (name.TAG === /* Ptyp_var */0) {
    const name$1 = name._0;
    let ty$1;
    try {
      if (name$1 !== "" && Caml_string.get(name$1, 0) === /* '_' */95) {
        throw new Caml_js_exceptions.MelangeError($$Error$6, {
                  MEL_EXN_ID: $$Error$6,
                  _1: loc,
                  _2: empty,
                  _3: {
                    TAG: /* Invalid_variable_name */13,
                    _0: "'" + name$1
                  }
                });
      }
      find$2(name$1, type_variables.contents);
      throw new Caml_js_exceptions.MelangeError(Already_bound, {
                MEL_EXN_ID: Already_bound
              });
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        const v = new_global_var(validate_name(name$1), undefined);
        type_variables.contents = add$5(name$1, v, type_variables.contents);
        ty$1 = v;
      } else {
        throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
      }
    }
    return {
            ctyp_desc: {
              TAG: /* Ttyp_var */0,
              _0: name$1
            },
            ctyp_type: ty$1,
            ctyp_env: env,
            ctyp_loc: loc,
            ctyp_attributes: styp.ptyp_attributes
          };
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              41575,
              9
            ]
          });
}

function new_pre_univar(name, param) {
  const v = newvar(validate_name(name), undefined);
  pre_univars.contents = {
    hd: v,
    tl: pre_univars.contents
  };
  return v;
}

function swap_list(l) {
  if (!l) {
    return l;
  }
  const match = l.tl;
  if (match) {
    return {
            hd: match.hd,
            tl: {
              hd: l.hd,
              tl: swap_list(match.tl)
            }
          };
  } else {
    return l;
  }
}

function transl_type(env, policy, styp) {
  const loc = styp.ptyp_loc;
  const ctyp = function (ctyp_desc, ctyp_type) {
    return {
            ctyp_desc: ctyp_desc,
            ctyp_type: ctyp_type,
            ctyp_env: env,
            ctyp_loc: loc,
            ctyp_attributes: styp.ptyp_attributes
          };
  };
  const name = styp.ptyp_desc;
  if (typeof name === "number") {
    let ty;
    if (policy === /* Univars */2) {
      ty = new_pre_univar(undefined, undefined);
    } else {
      if (policy === /* Fixed */0) {
        throw new Caml_js_exceptions.MelangeError($$Error$6, {
                  MEL_EXN_ID: $$Error$6,
                  _1: styp.ptyp_loc,
                  _2: env,
                  _3: {
                    TAG: /* Unbound_type_variable */0,
                    _0: "_"
                  }
                });
      }
      ty = newvar(validate_name(undefined), undefined);
    }
    return ctyp(/* Ttyp_any */0, ty);
  }
  switch (name.TAG | 0) {
    case /* Ptyp_var */0 :
        const name$1 = name._0;
        if (name$1 !== "" && Caml_string.get(name$1, 0) === /* '_' */95) {
          throw new Caml_js_exceptions.MelangeError($$Error$6, {
                    MEL_EXN_ID: $$Error$6,
                    _1: styp.ptyp_loc,
                    _2: env,
                    _3: {
                      TAG: /* Invalid_variable_name */13,
                      _0: "'" + name$1
                    }
                  });
        }
        let ty$1;
        try {
          ty$1 = instance(undefined, env, Stdlib__List.assoc(name$1, univars.contents));
        }
        catch (raw_exn){
          const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.MEL_EXN_ID === Stdlib.Not_found) {
            try {
              ty$1 = instance(undefined, env, find$2(name$1, used_variables.contents)[0]);
            }
            catch (raw_exn$1){
              const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
              if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
                const v = policy === /* Univars */2 ? new_pre_univar(name$1, undefined) : newvar(validate_name(name$1), undefined);
                used_variables.contents = add$5(name$1, [
                      v,
                      styp.ptyp_loc
                    ], used_variables.contents);
                ty$1 = v;
              } else {
                throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
              }
            }
          } else {
            throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
          }
        }
        return ctyp({
                    TAG: /* Ttyp_var */0,
                    _0: name$1
                  }, ty$1);
    case /* Ptyp_arrow */1 :
        const l = name._0;
        const cty1 = transl_type(env, policy, name._1);
        const cty2 = transl_type(env, policy, name._2);
        const ty$2 = newty2(current_level.contents, {
              TAG: /* Tarrow */1,
              _0: l,
              _1: cty1.ctyp_type,
              _2: cty2.ctyp_type,
              _3: /* Cok */0
            });
        return ctyp({
                    TAG: /* Ttyp_arrow */1,
                    _0: l,
                    _1: cty1,
                    _2: cty2
                  }, ty$2);
    case /* Ptyp_tuple */2 :
        const stl = name._0;
        if (Stdlib__List.length(stl) < 2) {
          ill_formed_ast(loc, "Tuples must have at least 2 components.");
        }
        const ctys = Stdlib__List.map((function (param) {
                return transl_type(env, policy, param);
              }), stl);
        const desc = {
          TAG: /* Ttuple */2,
          _0: Stdlib__List.map((function (ctyp) {
                  return ctyp.ctyp_type;
                }), ctys)
        };
        const ty$3 = newty2(current_level.contents, desc);
        return ctyp({
                    TAG: /* Ttyp_tuple */2,
                    _0: ctys
                  }, ty$3);
    case /* Ptyp_constr */3 :
        const stl$1 = name._1;
        const lid = name._0;
        const match = find_type(env, styp.ptyp_loc, lid.txt);
        const decl = match[1];
        const path = match[0];
        let stl$2;
        if (stl$1) {
          const t = stl$1.hd;
          stl$2 = typeof t.ptyp_desc === "number" && !(stl$1.tl || decl.type_arity <= 1) ? Stdlib__List.map((function (param) {
                    return t;
                  }), decl.type_params) : stl$1;
        } else {
          stl$2 = stl$1;
        }
        if (Stdlib__List.length(stl$2) !== decl.type_arity) {
          throw new Caml_js_exceptions.MelangeError($$Error$6, {
                    MEL_EXN_ID: $$Error$6,
                    _1: styp.ptyp_loc,
                    _2: env,
                    _3: {
                      TAG: /* Type_arity_mismatch */3,
                      _0: lid.txt,
                      _1: decl.type_arity,
                      _2: Stdlib__List.length(stl$2)
                    }
                  });
        }
        const args = Stdlib__List.map((function (param) {
                return transl_type(env, policy, param);
              }), stl$2);
        const params = instance_list(empty, decl.type_params);
        const ty$4 = decl.type_manifest;
        const unify_param = ty$4 !== undefined && repr(ty$4).level !== 100000000 ? unify$2 : unify_var;
        Stdlib__List.iter2((function (param, ty$p) {
                try {
                  return Curry._3(unify_param, env, ty$p, param[1].ctyp_type);
                }
                catch (raw_trace){
                  const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
                  if (trace.MEL_EXN_ID === Unify) {
                    throw new Caml_js_exceptions.MelangeError($$Error$6, {
                              MEL_EXN_ID: $$Error$6,
                              _1: param[0].ptyp_loc,
                              _2: env,
                              _3: {
                                TAG: /* Type_mismatch */6,
                                _0: swap_list(trace._1)
                              }
                            });
                  }
                  throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
                }
              }), Stdlib__List.combine(stl$2, args), params);
        const constr = newconstr(path, Stdlib__List.map((function (ctyp) {
                    return ctyp.ctyp_type;
                  }), args));
        try {
          enforce_constraints(env, constr);
        }
        catch (raw_trace){
          const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
          if (trace.MEL_EXN_ID === Unify) {
            throw new Caml_js_exceptions.MelangeError($$Error$6, {
                      MEL_EXN_ID: $$Error$6,
                      _1: styp.ptyp_loc,
                      _2: env,
                      _3: {
                        TAG: /* Type_mismatch */6,
                        _0: trace._1
                      }
                    });
          }
          throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
        }
        return ctyp({
                    TAG: /* Ttyp_constr */3,
                    _0: path,
                    _1: lid,
                    _2: args
                  }, constr);
    case /* Ptyp_object */4 :
        const o = name._1;
        const fields = Stdlib__List.map((function (param) {
                return [
                        param[0],
                        param[1],
                        transl_poly_type(env, policy, param[2])
                      ];
              }), name._0);
        const ty$5 = newobj(transl_fields(loc, env, policy, /* [] */0, o, fields));
        return ctyp({
                    TAG: /* Ttyp_object */4,
                    _0: fields,
                    _1: o
                  }, ty$5);
    case /* Ptyp_class */5 :
        const stl$3 = name._1;
        const lid$1 = name._0;
        let match$1;
        try {
          const match$2 = lookup_type$1(lid$1.txt, env);
          const decl$1 = match$2[1];
          const check = function (_decl) {
            while(true) {
              const decl = _decl;
              const ty = decl.type_manifest;
              if (ty !== undefined) {
                const row = repr(ty).desc;
                if (typeof row === "number") {
                  throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                            MEL_EXN_ID: Stdlib.Not_found
                          });
                }
                switch (row.TAG | 0) {
                  case /* Tconstr */3 :
                      _decl = find_type_full(row._0, env)[0];
                      continue ;
                  case /* Tvariant */8 :
                      if (static_row(row._0)) {
                        return ;
                      }
                      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                                MEL_EXN_ID: Stdlib.Not_found
                              });
                  default:
                    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                              MEL_EXN_ID: Stdlib.Not_found
                            });
                }
              } else {
                throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                          MEL_EXN_ID: Stdlib.Not_found
                        });
              }
            };
          };
          check(decl$1);
          prerr_warning(styp.ptyp_loc, {
                TAG: /* Deprecated */0,
                _0: "old syntax for polymorphic variant type"
              });
          match$1 = [
            match$2[0],
            decl$1,
            true
          ];
        }
        catch (raw_exn$2){
          const exn$2 = Caml_js_exceptions.internalToOCamlException(raw_exn$2);
          if (exn$2.MEL_EXN_ID === Stdlib.Not_found) {
            try {
              const s = lid$1.txt;
              let lid2;
              switch (s.TAG | 0) {
                case /* Lident */0 :
                    lid2 = {
                      TAG: /* Lident */0,
                      _0: "#" + s._0
                    };
                    break;
                case /* Ldot */1 :
                    lid2 = {
                      TAG: /* Ldot */1,
                      _0: s._0,
                      _1: "#" + s._1
                    };
                    break;
                case /* Lapply */2 :
                    lid2 = fatal_error("Typetexp.transl_type");
                    break;
                
              }
              const match$3 = lookup_type$1(lid2, env);
              match$1 = [
                match$3[0],
                match$3[1],
                false
              ];
            }
            catch (raw_exn$3){
              const exn$3 = Caml_js_exceptions.internalToOCamlException(raw_exn$3);
              if (exn$3.MEL_EXN_ID === Stdlib.Not_found) {
                find_class$1(env, styp.ptyp_loc, lid$1.txt);
                throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                          MEL_EXN_ID: "Assert_failure",
                          _1: [
                            "jscomp/test/ocaml_typedtree_test.ml",
                            41701,
                            57
                          ]
                        });
              }
              throw new Caml_js_exceptions.MelangeError(exn$3.MEL_EXN_ID, exn$3);
            }
          } else {
            throw new Caml_js_exceptions.MelangeError(exn$2.MEL_EXN_ID, exn$2);
          }
        }
        const decl$2 = match$1[1];
        const path$1 = match$1[0];
        if (Stdlib__List.length(stl$3) !== decl$2.type_arity) {
          throw new Caml_js_exceptions.MelangeError($$Error$6, {
                    MEL_EXN_ID: $$Error$6,
                    _1: styp.ptyp_loc,
                    _2: env,
                    _3: {
                      TAG: /* Type_arity_mismatch */3,
                      _0: lid$1.txt,
                      _1: decl$2.type_arity,
                      _2: Stdlib__List.length(stl$3)
                    }
                  });
        }
        const args$1 = Stdlib__List.map((function (param) {
                return transl_type(env, policy, param);
              }), stl$3);
        const params$1 = instance_list(empty, decl$2.type_params);
        Stdlib__List.iter2((function (param, ty$p) {
                try {
                  return unify_var(env, ty$p, param[1].ctyp_type);
                }
                catch (raw_trace){
                  const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
                  if (trace.MEL_EXN_ID === Unify) {
                    throw new Caml_js_exceptions.MelangeError($$Error$6, {
                              MEL_EXN_ID: $$Error$6,
                              _1: param[0].ptyp_loc,
                              _2: env,
                              _3: {
                                TAG: /* Type_mismatch */6,
                                _0: swap_list(trace._1)
                              }
                            });
                  }
                  throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
                }
              }), Stdlib__List.combine(stl$3, args$1), params$1);
        const ty_args = Stdlib__List.map((function (ctyp) {
                return ctyp.ctyp_type;
              }), args$1);
        let ty$6;
        try {
          ty$6 = expand_head(env, newconstr(path$1, ty_args));
        }
        catch (raw_trace$1){
          const trace$1 = Caml_js_exceptions.internalToOCamlException(raw_trace$1);
          if (trace$1.MEL_EXN_ID === Unify) {
            throw new Caml_js_exceptions.MelangeError($$Error$6, {
                      MEL_EXN_ID: $$Error$6,
                      _1: styp.ptyp_loc,
                      _2: env,
                      _3: {
                        TAG: /* Type_mismatch */6,
                        _0: trace$1._1
                      }
                    });
          }
          throw new Caml_js_exceptions.MelangeError(trace$1.MEL_EXN_ID, trace$1);
        }
        const row = ty$6.desc;
        let ty$7;
        if (typeof row === "number") {
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                    MEL_EXN_ID: "Assert_failure",
                    _1: [
                      "jscomp/test/ocaml_typedtree_test.ml",
                      41749,
                      10
                    ]
                  });
        }
        switch (row.TAG | 0) {
          case /* Tobject */4 :
              const match$4 = flatten_fields(row._0);
              if (policy === /* Univars */2) {
                pre_univars.contents = {
                  hd: match$4[1],
                  tl: pre_univars.contents
                };
              }
              ty$7 = ty$6;
              break;
          case /* Tvariant */8 :
              const row$1 = row_repr_aux(/* [] */0, row._0);
              const fields$1 = Stdlib__List.map((function (param) {
                      const f = param[1];
                      const match = row_field_repr_aux(/* [] */0, f);
                      let tmp;
                      if (typeof match === "number" || match.TAG !== /* Rpresent */0) {
                        tmp = f;
                      } else {
                        const ty = match._0;
                        tmp = ty !== undefined ? ({
                              TAG: /* Reither */1,
                              _0: false,
                              _1: {
                                hd: ty,
                                tl: /* [] */0
                              },
                              _2: false,
                              _3: {
                                contents: undefined
                              }
                            }) : ({
                              TAG: /* Reither */1,
                              _0: true,
                              _1: /* [] */0,
                              _2: false,
                              _3: {
                                contents: undefined
                              }
                            });
                      }
                      return [
                              param[0],
                              tmp
                            ];
                    }), row$1.row_fields);
              const row_row_more = newvar(validate_name(undefined), undefined);
              const row_row_name = [
                path$1,
                ty_args
              ];
              const row$2 = {
                row_fields: fields$1,
                row_more: row_row_more,
                row_bound: undefined,
                row_closed: true,
                row_fixed: false,
                row_name: row_row_name
              };
              const $$static = static_row(row$2);
              const row$3 = $$static ? ({
                    row_fields: fields$1,
                    row_more: newty2(current_level.contents, /* Tnil */0),
                    row_bound: undefined,
                    row_closed: true,
                    row_fixed: false,
                    row_name: row_row_name
                  }) : (
                  policy !== /* Univars */2 ? row$2 : ({
                        row_fields: fields$1,
                        row_more: new_pre_univar(undefined, undefined),
                        row_bound: undefined,
                        row_closed: true,
                        row_fixed: false,
                        row_name: row_row_name
                      })
                );
              ty$7 = newty2(current_level.contents, {
                    TAG: /* Tvariant */8,
                    _0: row$3
                  });
              break;
          default:
            throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                      MEL_EXN_ID: "Assert_failure",
                      _1: [
                        "jscomp/test/ocaml_typedtree_test.ml",
                        41749,
                        10
                      ]
                    });
        }
        return ctyp({
                    TAG: /* Ttyp_class */5,
                    _0: path$1,
                    _1: lid$1,
                    _2: args$1
                  }, ty$7);
    case /* Ptyp_alias */6 :
        const alias = name._1;
        const st = name._0;
        let cty;
        try {
          let t$1;
          try {
            t$1 = Stdlib__List.assoc(alias, univars.contents);
          }
          catch (raw_exn$4){
            const exn$4 = Caml_js_exceptions.internalToOCamlException(raw_exn$4);
            if (exn$4.MEL_EXN_ID === Stdlib.Not_found) {
              t$1 = instance(undefined, env, find$2(alias, used_variables.contents)[0]);
            } else {
              throw new Caml_js_exceptions.MelangeError(exn$4.MEL_EXN_ID, exn$4);
            }
          }
          const ty$8 = transl_type(env, policy, st);
          try {
            unify_var(env, t$1, ty$8.ctyp_type);
          }
          catch (raw_trace$2){
            const trace$2 = Caml_js_exceptions.internalToOCamlException(raw_trace$2);
            if (trace$2.MEL_EXN_ID === Unify) {
              const trace$3 = swap_list(trace$2._1);
              throw new Caml_js_exceptions.MelangeError($$Error$6, {
                        MEL_EXN_ID: $$Error$6,
                        _1: styp.ptyp_loc,
                        _2: env,
                        _3: {
                          TAG: /* Alias_type_mismatch */7,
                          _0: trace$3
                        }
                      });
            }
            throw new Caml_js_exceptions.MelangeError(trace$2.MEL_EXN_ID, trace$2);
          }
          cty = ty$8;
        }
        catch (raw_exn$5){
          const exn$5 = Caml_js_exceptions.internalToOCamlException(raw_exn$5);
          if (exn$5.MEL_EXN_ID === Stdlib.Not_found) {
            if (principal.contents) {
              begin_def(undefined);
            }
            const t$2 = newvar(validate_name(undefined), undefined);
            used_variables.contents = add$5(alias, [
                  t$2,
                  styp.ptyp_loc
                ], used_variables.contents);
            const ty$9 = transl_type(env, policy, st);
            try {
              unify_var(env, t$2, ty$9.ctyp_type);
            }
            catch (raw_trace$3){
              const trace$4 = Caml_js_exceptions.internalToOCamlException(raw_trace$3);
              if (trace$4.MEL_EXN_ID === Unify) {
                const trace$5 = swap_list(trace$4._1);
                throw new Caml_js_exceptions.MelangeError($$Error$6, {
                          MEL_EXN_ID: $$Error$6,
                          _1: styp.ptyp_loc,
                          _2: env,
                          _3: {
                            TAG: /* Alias_type_mismatch */7,
                            _0: trace$5
                          }
                        });
              }
              throw new Caml_js_exceptions.MelangeError(trace$4.MEL_EXN_ID, trace$4);
            }
            if (principal.contents) {
              end_def(undefined);
              generalize_structure$1(current_level.contents, t$2);
            }
            const t$3 = instance(undefined, env, t$2);
            const px = proxy(t$3);
            const match$5 = px.desc;
            if (typeof match$5 !== "number") {
              switch (match$5.TAG | 0) {
                case /* Tvar */0 :
                    if (match$5._0 !== undefined) {
                      
                    } else {
                      log_type(px);
                      px.desc = {
                        TAG: /* Tvar */0,
                        _0: alias
                      };
                    }
                    break;
                case /* Tunivar */9 :
                    if (match$5._0 !== undefined) {
                      
                    } else {
                      log_type(px);
                      px.desc = {
                        TAG: /* Tunivar */9,
                        _0: alias
                      };
                    }
                    break;
                default:
                  
              }
            }
            cty = {
              ctyp_desc: ty$9.ctyp_desc,
              ctyp_type: t$3,
              ctyp_env: ty$9.ctyp_env,
              ctyp_loc: ty$9.ctyp_loc,
              ctyp_attributes: ty$9.ctyp_attributes
            };
          } else {
            throw new Caml_js_exceptions.MelangeError(exn$5.MEL_EXN_ID, exn$5);
          }
        }
        return ctyp({
                    TAG: /* Ttyp_alias */6,
                    _0: cty,
                    _1: alias
                  }, cty.ctyp_type);
    case /* Ptyp_variant */7 :
        const present = name._2;
        const closed = name._1;
        const name$2 = {
          contents: undefined
        };
        const mkfield = function (l, f) {
          const desc = {
            TAG: /* Tvariant */8,
            _0: {
              row_fields: {
                hd: [
                  l,
                  f
                ],
                tl: /* [] */0
              },
              row_more: newvar(validate_name(undefined), undefined),
              row_bound: undefined,
              row_closed: true,
              row_fixed: false,
              row_name: undefined
            }
          };
          return newty2(current_level.contents, desc);
        };
        const hfields = Stdlib__Hashtbl.create(undefined, 17);
        const add_typed_field = function (loc, l, f) {
          const h = hash_variant(l);
          try {
            const match = Stdlib__Hashtbl.find(hfields, h);
            const l$p = match[0];
            if (l !== l$p) {
              throw new Caml_js_exceptions.MelangeError($$Error$6, {
                        MEL_EXN_ID: $$Error$6,
                        _1: styp.ptyp_loc,
                        _2: env,
                        _3: {
                          TAG: /* Variant_tags */12,
                          _0: l,
                          _1: l$p
                        }
                      });
            }
            const ty = mkfield(l, f);
            const ty$p = mkfield(l, match[1]);
            if (equal$5(env, false, {
                    hd: ty,
                    tl: /* [] */0
                  }, {
                    hd: ty$p,
                    tl: /* [] */0
                  })) {
              return ;
            }
            try {
              return unify$2(env, ty, ty$p);
            }
            catch (raw_trace){
              const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
              if (trace.MEL_EXN_ID === Unify) {
                throw new Caml_js_exceptions.MelangeError($$Error$6, {
                          MEL_EXN_ID: $$Error$6,
                          _1: loc,
                          _2: env,
                          _3: {
                            TAG: /* Constructor_mismatch */10,
                            _0: ty,
                            _1: ty$p
                          }
                        });
              }
              throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
            }
          }
          catch (raw_exn){
            const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.MEL_EXN_ID === Stdlib.Not_found) {
              return Stdlib__Hashtbl.add(hfields, h, [
                          l,
                          f
                        ]);
            }
            throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
          }
        };
        const add_field = function (sty) {
          if (sty.TAG === /* Rtag */0) {
            const stl = sty._3;
            const c = sty._2;
            const l = sty._0;
            name$2.contents = undefined;
            const tl = Stdlib__List.map((function (param) {
                    return transl_type(env, policy, param);
                  }), stl);
            let f;
            let exit = 0;
            if (present !== undefined && !Stdlib__List.mem(l, present)) {
              const ty_tl = Stdlib__List.map((function (cty) {
                      return cty.ctyp_type;
                    }), tl);
              f = {
                TAG: /* Reither */1,
                _0: c,
                _1: ty_tl,
                _2: false,
                _3: {
                  contents: undefined
                }
              };
            } else {
              exit = 1;
            }
            if (exit === 1) {
              if (Stdlib__List.length(stl) > 1 || c && Caml_obj.caml_notequal(stl, /* [] */0)) {
                throw new Caml_js_exceptions.MelangeError($$Error$6, {
                          MEL_EXN_ID: $$Error$6,
                          _1: styp.ptyp_loc,
                          _2: env,
                          _3: {
                            TAG: /* Present_has_conjunction */8,
                            _0: l
                          }
                        });
              }
              f = tl ? ({
                    TAG: /* Rpresent */0,
                    _0: tl.hd.ctyp_type
                  }) : ({
                    TAG: /* Rpresent */0,
                    _0: undefined
                  });
            }
            add_typed_field(styp.ptyp_loc, l, f);
            return {
                    TAG: /* Ttag */0,
                    _0: l,
                    _1: sty._1,
                    _2: c,
                    _3: tl
                  };
          }
          const sty$1 = sty._0;
          const cty = transl_type(env, policy, sty$1);
          const ty = cty.ctyp_type;
          const match = repr(cty.ctyp_type);
          const match$1 = match.desc;
          let nm;
          nm = typeof match$1 === "number" || match$1.TAG !== /* Tconstr */3 ? undefined : [
              match$1._0,
              match$1._1
            ];
          try {
            Stdlib__Hashtbl.iter((function (param, param$1) {
                    throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                              MEL_EXN_ID: Stdlib.Exit
                            });
                  }), hfields);
            name$2.contents = nm;
          }
          catch (raw_exn){
            const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.MEL_EXN_ID === Stdlib.Exit) {
              name$2.contents = undefined;
            } else {
              throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
            }
          }
          const match$2 = expand_head(env, cty.ctyp_type);
          let fl;
          let exit$1 = 0;
          const row = match$2.desc;
          if (typeof row === "number") {
            exit$1 = 1;
          } else {
            switch (row.TAG | 0) {
              case /* Tvar */0 :
                  if (nm !== undefined) {
                    throw new Caml_js_exceptions.MelangeError($$Error$6, {
                              MEL_EXN_ID: $$Error$6,
                              _1: sty$1.ptyp_loc,
                              _2: env,
                              _3: {
                                TAG: /* Unbound_type_constructor_2 */2,
                                _0: nm[0]
                              }
                            });
                  }
                  exit$1 = 1;
                  break;
              case /* Tvariant */8 :
                  const row$1 = row._0;
                  if (static_row(row$1)) {
                    fl = row_repr_aux(/* [] */0, row$1).row_fields;
                  } else {
                    exit$1 = 1;
                  }
                  break;
              default:
                exit$1 = 1;
            }
          }
          if (exit$1 === 1) {
            throw new Caml_js_exceptions.MelangeError($$Error$6, {
                      MEL_EXN_ID: $$Error$6,
                      _1: sty$1.ptyp_loc,
                      _2: env,
                      _3: {
                        TAG: /* Not_a_variant */11,
                        _0: ty
                      }
                    });
          }
          Stdlib__List.iter((function (param) {
                  const f = param[1];
                  const l = param[0];
                  let f$1;
                  if (present !== undefined && !Stdlib__List.mem(l, present)) {
                    if (typeof f === "number") {
                      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                                MEL_EXN_ID: "Assert_failure",
                                _1: [
                                  "jscomp/test/ocaml_typedtree_test.ml",
                                  41862,
                                  24
                                ]
                              });
                    }
                    if (f.TAG === /* Rpresent */0) {
                      const ty = f._0;
                      f$1 = ty !== undefined ? ({
                            TAG: /* Reither */1,
                            _0: false,
                            _1: {
                              hd: ty,
                              tl: /* [] */0
                            },
                            _2: false,
                            _3: {
                              contents: undefined
                            }
                          }) : ({
                            TAG: /* Reither */1,
                            _0: true,
                            _1: /* [] */0,
                            _2: false,
                            _3: {
                              contents: undefined
                            }
                          });
                    } else {
                      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                                MEL_EXN_ID: "Assert_failure",
                                _1: [
                                  "jscomp/test/ocaml_typedtree_test.ml",
                                  41862,
                                  24
                                ]
                              });
                    }
                  } else {
                    f$1 = f;
                  }
                  add_typed_field(sty$1.ptyp_loc, l, f$1);
                }), fl);
          return {
                  TAG: /* Tinherit */1,
                  _0: cty
                };
        };
        const tfields = Stdlib__List.map(add_field, name._0);
        const fields$2 = Stdlib__Hashtbl.fold((function (param, p, l) {
                return {
                        hd: p,
                        tl: l
                      };
              }), hfields, /* [] */0);
        if (present !== undefined) {
          Stdlib__List.iter((function (l) {
                  if (Stdlib__List.mem_assoc(l, fields$2)) {
                    return ;
                  }
                  throw new Caml_js_exceptions.MelangeError($$Error$6, {
                            MEL_EXN_ID: $$Error$6,
                            _1: styp.ptyp_loc,
                            _2: env,
                            _3: {
                              TAG: /* Present_has_no_type */9,
                              _0: l
                            }
                          });
                }), present);
        }
        const row_row_fields = Stdlib__List.rev(fields$2);
        const row_row_more$1 = newvar(validate_name(undefined), undefined);
        const row_row_closed = closed === /* Closed */0;
        const row_row_name$1 = name$2.contents;
        const row$4 = {
          row_fields: row_row_fields,
          row_more: row_row_more$1,
          row_bound: undefined,
          row_closed: row_row_closed,
          row_fixed: false,
          row_name: row_row_name$1
        };
        const $$static$1 = static_row(row$4);
        const row$5 = $$static$1 ? ({
              row_fields: row_row_fields,
              row_more: newty2(current_level.contents, /* Tnil */0),
              row_bound: undefined,
              row_closed: row_row_closed,
              row_fixed: false,
              row_name: row_row_name$1
            }) : (
            policy !== /* Univars */2 ? row$4 : ({
                  row_fields: row_row_fields,
                  row_more: new_pre_univar(undefined, undefined),
                  row_bound: undefined,
                  row_closed: row_row_closed,
                  row_fixed: false,
                  row_name: row_row_name$1
                })
          );
        const ty$10 = newty2(current_level.contents, {
              TAG: /* Tvariant */8,
              _0: row$5
            });
        return ctyp({
                    TAG: /* Ttyp_variant */7,
                    _0: tfields,
                    _1: closed,
                    _2: present
                  }, ty$10);
    case /* Ptyp_poly */8 :
        const vars = name._0;
        begin_def(undefined);
        const new_univars = Stdlib__List.map((function (name) {
                return [
                        name,
                        newvar(validate_name(name), undefined)
                      ];
              }), vars);
        const old_univars = univars.contents;
        univars.contents = Stdlib.$at(new_univars, univars.contents);
        const cty$1 = transl_type(env, policy, name._1);
        const ty$11 = cty$1.ctyp_type;
        univars.contents = old_univars;
        end_def(undefined);
        iter_generalize$1({
              contents: /* [] */0
            }, ty$11);
        const ty_list = Stdlib__List.fold_left((function (tyl, param) {
                const v = proxy(param[1]);
                if (!deep_occur(v, ty$11)) {
                  return tyl;
                }
                const name = v.desc;
                if (typeof name !== "number" && name.TAG === /* Tvar */0 && v.level === 100000000) {
                  v.desc = {
                    TAG: /* Tunivar */9,
                    _0: name._0
                  };
                  return {
                          hd: v,
                          tl: tyl
                        };
                }
                throw new Caml_js_exceptions.MelangeError($$Error$6, {
                          MEL_EXN_ID: $$Error$6,
                          _1: styp.ptyp_loc,
                          _2: env,
                          _3: {
                            TAG: /* Cannot_quantify */14,
                            _0: param[0],
                            _1: v
                          }
                        });
              }), /* [] */0, new_univars);
        const ty$p = newty2(100000000, {
              TAG: /* Tpoly */10,
              _0: ty$11,
              _1: Stdlib__List.rev(ty_list)
            });
        unify_var(env, newvar(validate_name(undefined), undefined), ty$p);
        return ctyp({
                    TAG: /* Ttyp_poly */8,
                    _0: vars,
                    _1: cty$1
                  }, ty$p);
    case /* Ptyp_package */9 :
        const match$6 = name._0;
        const p = match$6[0];
        const match$7 = create_package_mty(true, styp.ptyp_loc, env, [
              p,
              match$6[1]
            ]);
        const l$1 = match$7[0];
        const z = narrow(undefined);
        const mty = Curry._2(transl_modtype.contents, env, match$7[1]);
        widen(z);
        const ptys = Stdlib__List.map((function (param) {
                return [
                        param[0],
                        transl_type(env, policy, param[1])
                      ];
              }), l$1);
        const path$2 = Curry._3(transl_modtype_longident.contents, styp.ptyp_loc, env, p.txt);
        const desc_1 = Stdlib__List.map((function (param) {
                return param[0].txt;
              }), l$1);
        const desc_2 = Stdlib__List.map((function (param) {
                return param[1].ctyp_type;
              }), ptys);
        const desc$1 = {
          TAG: /* Tpackage */11,
          _0: path$2,
          _1: desc_1,
          _2: desc_2
        };
        const ty$12 = newty2(current_level.contents, desc$1);
        return ctyp({
                    TAG: /* Ttyp_package */9,
                    _0: {
                      pack_path: path$2,
                      pack_fields: ptys,
                      pack_type: mty.mty_type,
                      pack_txt: p
                    }
                  }, ty$12);
    case /* Ptyp_extension */10 :
        throw new Caml_js_exceptions.MelangeError(Error_forward, {
                  MEL_EXN_ID: Error_forward,
                  _1: error_of_extension(name._0)
                });
    
  }
}

function transl_poly_type(env, policy, t) {
  return transl_type(env, policy, force_poly(t));
}

function transl_fields(loc, env, policy, seen, o, param) {
  if (!param) {
    if (o) {
      if (policy >= 2) {
        return new_pre_univar(undefined, undefined);
      } else {
        return newvar(validate_name(undefined), undefined);
      }
    } else {
      return newty2(current_level.contents, /* Tnil */0);
    }
  }
  const match = param.hd;
  const s = match[0];
  if (Stdlib__List.mem(s, seen)) {
    throw new Caml_js_exceptions.MelangeError($$Error$6, {
              MEL_EXN_ID: $$Error$6,
              _1: loc,
              _2: env,
              _3: {
                TAG: /* Repeated_method_label */16,
                _0: s
              }
            });
  }
  const ty2 = transl_fields(loc, env, policy, {
        hd: s,
        tl: seen
      }, o, param.tl);
  return newty2(current_level.contents, {
              TAG: /* Tfield */5,
              _0: s,
              _1: /* Fpresent */0,
              _2: match[2].ctyp_type,
              _3: ty2
            });
}

function make_fixed_univars(ty) {
  const ty$1 = repr(ty);
  if (ty$1.level < 0) {
    return ;
  }
  mark_type_node(ty$1);
  const row = ty$1.desc;
  if (typeof row === "number") {
    return iter_type_expr(make_fixed_univars, ty$1);
  }
  if (row.TAG !== /* Tvariant */8) {
    return iter_type_expr(make_fixed_univars, ty$1);
  }
  const row$1 = row_repr_aux(/* [] */0, row._0);
  if (is_Tunivar(row_more(row$1))) {
    ty$1.desc = {
      TAG: /* Tvariant */8,
      _0: {
        row_fields: Stdlib__List.map((function (p) {
                const match = row_field_repr_aux(/* [] */0, p[1]);
                if (typeof match === "number" || match.TAG === /* Rpresent */0) {
                  return p;
                } else {
                  return [
                          p[0],
                          {
                            TAG: /* Reither */1,
                            _0: match._0,
                            _1: match._1,
                            _2: true,
                            _3: match._3
                          }
                        ];
                }
              }), row$1.row_fields),
        row_more: row$1.row_more,
        row_bound: row$1.row_bound,
        row_closed: row$1.row_closed,
        row_fixed: true,
        row_name: row$1.row_name
      }
    };
  }
  iter_row(make_fixed_univars, row$1);
}

function globalize_used_variables(env, fixed) {
  const r = {
    contents: /* [] */0
  };
  iter$2((function (name, param) {
          const loc = param[1];
          const ty = param[0];
          const v = new_global_var(validate_name(undefined), undefined);
          const snap = snapshot(undefined);
          let tmp;
          try {
            unify$2(env, v, ty);
            tmp = true;
          }
          catch (exn){
            backtrack(snap);
            tmp = false;
          }
          if (!tmp) {
            return ;
          }
          try {
            r.contents = {
              hd: [
                loc,
                v,
                find$2(name, type_variables.contents)
              ],
              tl: r.contents
            };
            return ;
          }
          catch (raw_exn){
            const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
              if (fixed && is_Tvar(repr(ty))) {
                throw new Caml_js_exceptions.MelangeError($$Error$6, {
                          MEL_EXN_ID: $$Error$6,
                          _1: loc,
                          _2: env,
                          _3: {
                            TAG: /* Unbound_type_variable */0,
                            _0: "'" + name
                          }
                        });
              }
              const v2 = new_global_var(validate_name(undefined), undefined);
              r.contents = {
                hd: [
                  loc,
                  v,
                  v2
                ],
                tl: r.contents
              };
              type_variables.contents = add$5(name, v2, type_variables.contents);
              return ;
            }
            throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
          }
        }), used_variables.contents);
  used_variables.contents = /* Empty */0;
  return function (param) {
    Stdlib__List.iter((function (param) {
            try {
              return unify$2(env, param[1], param[2]);
            }
            catch (raw_trace){
              const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
              if (trace.MEL_EXN_ID === Unify) {
                throw new Caml_js_exceptions.MelangeError($$Error$6, {
                          MEL_EXN_ID: $$Error$6,
                          _1: param[0],
                          _2: env,
                          _3: {
                            TAG: /* Type_mismatch */6,
                            _0: trace._1
                          }
                        });
              }
              throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
            }
          }), r.contents);
  };
}

function transl_simple_type(env, fixed, styp) {
  univars.contents = /* [] */0;
  used_variables.contents = /* Empty */0;
  const typ = transl_type(env, fixed ? /* Fixed */0 : /* Extensible */1, styp);
  globalize_used_variables(env, fixed)(undefined);
  const ty = typ.ctyp_type;
  make_fixed_univars(ty);
  unmark_type(ty);
  return typ;
}

function transl_simple_type_univars(env, styp) {
  univars.contents = /* [] */0;
  used_variables.contents = /* Empty */0;
  pre_univars.contents = /* [] */0;
  begin_def(undefined);
  const typ = transl_type(env, /* Univars */2, styp);
  const new_variables = used_variables.contents;
  used_variables.contents = /* Empty */0;
  iter$2((function (name, p) {
          if (mem$4(name, type_variables.contents)) {
            used_variables.contents = add$5(name, p, used_variables.contents);
            return ;
          }
          
        }), new_variables);
  globalize_used_variables(env, false)(undefined);
  end_def(undefined);
  iter_generalize$1({
        contents: /* [] */0
      }, typ.ctyp_type);
  const univs = Stdlib__List.fold_left((function (acc, v) {
          const v$1 = repr(v);
          const name = v$1.desc;
          if (typeof name === "number" || !(name.TAG === /* Tvar */0 && v$1.level === 100000000)) {
            return acc;
          } else {
            v$1.desc = {
              TAG: /* Tunivar */9,
              _0: name._0
            };
            return {
                    hd: v$1,
                    tl: acc
                  };
          }
        }), /* [] */0, pre_univars.contents);
  const ty = typ.ctyp_type;
  make_fixed_univars(ty);
  unmark_type(ty);
  return {
          ctyp_desc: typ.ctyp_desc,
          ctyp_type: instance(undefined, env, newty2(100000000, {
                    TAG: /* Tpoly */10,
                    _0: typ.ctyp_type,
                    _1: univs
                  })),
          ctyp_env: typ.ctyp_env,
          ctyp_loc: typ.ctyp_loc,
          ctyp_attributes: typ.ctyp_attributes
        };
}

function transl_simple_type_delayed(env, styp) {
  univars.contents = /* [] */0;
  used_variables.contents = /* Empty */0;
  const typ = transl_type(env, /* Extensible */1, styp);
  const ty = typ.ctyp_type;
  make_fixed_univars(ty);
  unmark_type(ty);
  return [
          typ,
          globalize_used_variables(env, false)
        ];
}

function transl_type_scheme(env, styp) {
  reset_type_variables(undefined);
  begin_def(undefined);
  const typ = transl_simple_type(env, false, styp);
  end_def(undefined);
  iter_generalize$1({
        contents: /* [] */0
      }, typ.ctyp_type);
  return typ;
}

function spellcheck(ppf, fold, env, lid) {
  const match = last$1(lid).length;
  const cutoff = match > 4 || match < 1 ? (
      match === 6 || match === 5 ? 2 : 3
    ) : (
      match >= 3 ? 1 : 0
    );
  const compare = function (target, head, acc) {
    const best_dist = acc[1];
    const best_choice = acc[0];
    const dist = edit_distance(target, head, cutoff);
    if (dist === undefined) {
      return [
              best_choice,
              best_dist
            ];
    }
    const choice = dist < best_dist ? ({
          hd: head,
          tl: /* [] */0
        }) : (
        dist === best_dist ? ({
              hd: head,
              tl: best_choice
            }) : best_choice
      );
    return [
            choice,
            dist < best_dist ? dist : best_dist
          ];
  };
  const init = [
    /* [] */0,
    Stdlib.max_int
  ];
  const handle = function (param) {
    const match = Stdlib__List.rev(param[0]);
    if (!match) {
      return ;
    }
    const rev_rest = match.tl;
    Curry._3(Stdlib__Format.fprintf(ppf)(/* Format */{
              _0: {
                TAG: /* Formatting_lit */17,
                _0: /* Force_newline */3,
                _1: {
                  TAG: /* String_literal */11,
                  _0: "Hint: Did you mean ",
                  _1: {
                    TAG: /* String */2,
                    _0: /* No_padding */0,
                    _1: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* Char_literal */12,
                          _0: /* '?' */63,
                          _1: /* End_of_format */0
                        }
                      }
                    }
                  }
                }
              },
              _1: "@\nHint: Did you mean %s%s%s?"
            }), Stdlib__String.concat(", ", Stdlib__List.rev(rev_rest)), Caml_obj.caml_equal(rev_rest, /* [] */0) ? "" : " or ", match.hd);
  };
  Stdlib__Format.fprintf(ppf)(/* Format */{
        _0: {
          TAG: /* Formatting_lit */17,
          _0: /* FFlush */2,
          _1: /* End_of_format */0
        },
        _1: "@?"
      });
  switch (lid.TAG | 0) {
    case /* Lident */0 :
        const s = lid._0;
        return handle(Curry._4(fold, (function (param, param$1) {
                          return compare(s, param, param$1);
                        }), undefined, env, init));
    case /* Ldot */1 :
        const s$1 = lid._1;
        return handle(Curry._4(fold, (function (param, param$1) {
                          return compare(s$1, param, param$1);
                        }), lid._0, env, init));
    case /* Lapply */2 :
        return ;
    
  }
}

function spellcheck_simple(ppf, fold, extr) {
  return function (param, param$1) {
    return spellcheck(ppf, (function (f) {
                  return Curry._1(fold, (function (decl, x) {
                                return Curry._2(f, Curry._1(extr, decl), x);
                              }));
                }), param, param$1);
  };
}

function spellcheck$1(ppf, fold) {
  return function (param, param$1) {
    return spellcheck(ppf, (function (f) {
                  return Curry._1(fold, (function (s, param, param$1, x) {
                                return Curry._2(f, s, x);
                              }));
                }), param, param$1);
  };
}

register_error_of_exn(function (err) {
      if (err.MEL_EXN_ID !== $$Error$6) {
        if (err.MEL_EXN_ID === Error_forward) {
          return err._1;
        } else {
          return ;
        }
      }
      const env = err._2;
      return error_of_printer(err._1, (function (param, param$1) {
                    if (typeof param$1 === "number") {
                      if (param$1 === /* Recursive_type */0) {
                        return Stdlib__Format.fprintf(param)(/* Format */{
                                    _0: {
                                      TAG: /* String_literal */11,
                                      _0: "This type is recursive",
                                      _1: /* End_of_format */0
                                    },
                                    _1: "This type is recursive"
                                  });
                      } else {
                        return Stdlib__Format.fprintf(param)(/* Format */{
                                    _0: {
                                      TAG: /* String_literal */11,
                                      _0: "Illegal recursive module reference",
                                      _1: /* End_of_format */0
                                    },
                                    _1: "Illegal recursive module reference"
                                  });
                      }
                    }
                    switch (param$1.TAG | 0) {
                      case /* Unbound_type_variable */0 :
                          return Curry._1(Stdlib__Format.fprintf(param)(/* Format */{
                                          _0: {
                                            TAG: /* String_literal */11,
                                            _0: "Unbound type parameter ",
                                            _1: {
                                              TAG: /* String */2,
                                              _0: /* No_padding */0,
                                              _1: {
                                                TAG: /* Formatting_lit */17,
                                                _0: /* Flush_newline */4,
                                                _1: /* End_of_format */0
                                              }
                                            }
                                          },
                                          _1: "Unbound type parameter %s@."
                                        }), param$1._0);
                      case /* Unbound_type_constructor */1 :
                          const lid = param$1._0;
                          Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                    _0: {
                                      TAG: /* String_literal */11,
                                      _0: "Unbound type constructor ",
                                      _1: {
                                        TAG: /* Alpha */15,
                                        _0: /* End_of_format */0
                                      }
                                    },
                                    _1: "Unbound type constructor %a"
                                  }), longident, lid);
                          return spellcheck$1(param, fold_types)(env, lid);
                      case /* Unbound_type_constructor_2 */2 :
                          return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                          _0: {
                                            TAG: /* String_literal */11,
                                            _0: "The type constructor",
                                            _1: {
                                              TAG: /* Formatting_lit */17,
                                              _0: {
                                                TAG: /* Break */0,
                                                _0: "@ ",
                                                _1: 1,
                                                _2: 0
                                              },
                                              _1: {
                                                TAG: /* Alpha */15,
                                                _0: {
                                                  TAG: /* Formatting_lit */17,
                                                  _0: {
                                                    TAG: /* Break */0,
                                                    _0: "@ ",
                                                    _1: 1,
                                                    _2: 0
                                                  },
                                                  _1: {
                                                    TAG: /* String_literal */11,
                                                    _0: "is not yet completely defined",
                                                    _1: /* End_of_format */0
                                                  }
                                                }
                                              }
                                            }
                                          },
                                          _1: "The type constructor@ %a@ is not yet completely defined"
                                        }), path, param$1._0);
                      case /* Type_arity_mismatch */3 :
                          return Curry._4(Stdlib__Format.fprintf(param)(/* Format */{
                                          _0: {
                                            TAG: /* Formatting_gen */18,
                                            _0: {
                                              TAG: /* Open_box */1,
                                              _0: /* Format */{
                                                _0: /* End_of_format */0,
                                                _1: ""
                                              }
                                            },
                                            _1: {
                                              TAG: /* String_literal */11,
                                              _0: "The type constructor ",
                                              _1: {
                                                TAG: /* Alpha */15,
                                                _0: {
                                                  TAG: /* Formatting_lit */17,
                                                  _0: {
                                                    TAG: /* Break */0,
                                                    _0: "@ ",
                                                    _1: 1,
                                                    _2: 0
                                                  },
                                                  _1: {
                                                    TAG: /* String_literal */11,
                                                    _0: "expects ",
                                                    _1: {
                                                      TAG: /* Int */4,
                                                      _0: /* Int_i */3,
                                                      _1: /* No_padding */0,
                                                      _2: /* No_precision */0,
                                                      _3: {
                                                        TAG: /* String_literal */11,
                                                        _0: " argument(s),",
                                                        _1: {
                                                          TAG: /* Formatting_lit */17,
                                                          _0: {
                                                            TAG: /* Break */0,
                                                            _0: "@ ",
                                                            _1: 1,
                                                            _2: 0
                                                          },
                                                          _1: {
                                                            TAG: /* String_literal */11,
                                                            _0: "but is here applied to ",
                                                            _1: {
                                                              TAG: /* Int */4,
                                                              _0: /* Int_i */3,
                                                              _1: /* No_padding */0,
                                                              _2: /* No_precision */0,
                                                              _3: {
                                                                TAG: /* String_literal */11,
                                                                _0: " argument(s)",
                                                                _1: {
                                                                  TAG: /* Formatting_lit */17,
                                                                  _0: /* Close_box */0,
                                                                  _1: /* End_of_format */0
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          },
                                          _1: "@[The type constructor %a@ expects %i argument(s),@ but is here applied to %i argument(s)@]"
                                        }), longident, param$1._0, param$1._1, param$1._2);
                      case /* Bound_type_variable */4 :
                          return Curry._1(Stdlib__Format.fprintf(param)(/* Format */{
                                          _0: {
                                            TAG: /* String_literal */11,
                                            _0: "Already bound type parameter '",
                                            _1: {
                                              TAG: /* String */2,
                                              _0: /* No_padding */0,
                                              _1: /* End_of_format */0
                                            }
                                          },
                                          _1: "Already bound type parameter '%s"
                                        }), param$1._0);
                      case /* Unbound_row_variable */5 :
                          return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                          _0: {
                                            TAG: /* String_literal */11,
                                            _0: "Unbound row variable in #",
                                            _1: {
                                              TAG: /* Alpha */15,
                                              _0: /* End_of_format */0
                                            }
                                          },
                                          _1: "Unbound row variable in #%a"
                                        }), longident, param$1._0);
                      case /* Type_mismatch */6 :
                          return report_unification_error(param, empty, undefined, param$1._0, (function (ppf) {
                                        Stdlib__Format.fprintf(ppf)(/* Format */{
                                              _0: {
                                                TAG: /* String_literal */11,
                                                _0: "This type",
                                                _1: /* End_of_format */0
                                              },
                                              _1: "This type"
                                            });
                                      }), (function (ppf) {
                                        Stdlib__Format.fprintf(ppf)(/* Format */{
                                              _0: {
                                                TAG: /* String_literal */11,
                                                _0: "should be an instance of type",
                                                _1: /* End_of_format */0
                                              },
                                              _1: "should be an instance of type"
                                            });
                                      }));
                      case /* Alias_type_mismatch */7 :
                          return report_unification_error(param, empty, undefined, param$1._0, (function (ppf) {
                                        Stdlib__Format.fprintf(ppf)(/* Format */{
                                              _0: {
                                                TAG: /* String_literal */11,
                                                _0: "This alias is bound to type",
                                                _1: /* End_of_format */0
                                              },
                                              _1: "This alias is bound to type"
                                            });
                                      }), (function (ppf) {
                                        Stdlib__Format.fprintf(ppf)(/* Format */{
                                              _0: {
                                                TAG: /* String_literal */11,
                                                _0: "but is used as an instance of type",
                                                _1: /* End_of_format */0
                                              },
                                              _1: "but is used as an instance of type"
                                            });
                                      }));
                      case /* Present_has_conjunction */8 :
                          return Curry._1(Stdlib__Format.fprintf(param)(/* Format */{
                                          _0: {
                                            TAG: /* String_literal */11,
                                            _0: "The present constructor ",
                                            _1: {
                                              TAG: /* String */2,
                                              _0: /* No_padding */0,
                                              _1: {
                                                TAG: /* String_literal */11,
                                                _0: " has a conjunctive type",
                                                _1: /* End_of_format */0
                                              }
                                            }
                                          },
                                          _1: "The present constructor %s has a conjunctive type"
                                        }), param$1._0);
                      case /* Present_has_no_type */9 :
                          return Curry._1(Stdlib__Format.fprintf(param)(/* Format */{
                                          _0: {
                                            TAG: /* String_literal */11,
                                            _0: "The present constructor ",
                                            _1: {
                                              TAG: /* String */2,
                                              _0: /* No_padding */0,
                                              _1: {
                                                TAG: /* String_literal */11,
                                                _0: " has no type",
                                                _1: /* End_of_format */0
                                              }
                                            }
                                          },
                                          _1: "The present constructor %s has no type"
                                        }), param$1._0);
                      case /* Constructor_mismatch */10 :
                          const ty$p = param$1._1;
                          const ty = param$1._0;
                          return wrap_printing_env(env, (function (param$2) {
                                        reset_and_mark_loops_list({
                                              hd: ty,
                                              tl: {
                                                hd: ty$p,
                                                tl: /* [] */0
                                              }
                                            });
                                        Curry._6(Stdlib__Format.fprintf(param)(/* Format */{
                                                  _0: {
                                                    TAG: /* Formatting_gen */18,
                                                    _0: {
                                                      TAG: /* Open_box */1,
                                                      _0: /* Format */{
                                                        _0: {
                                                          TAG: /* String_literal */11,
                                                          _0: "<hov>",
                                                          _1: /* End_of_format */0
                                                        },
                                                        _1: "<hov>"
                                                      }
                                                    },
                                                    _1: {
                                                      TAG: /* String */2,
                                                      _0: /* No_padding */0,
                                                      _1: {
                                                        TAG: /* Char_literal */12,
                                                        _0: /* ' ' */32,
                                                        _1: {
                                                          TAG: /* Alpha */15,
                                                          _0: {
                                                            TAG: /* Formatting_lit */17,
                                                            _0: {
                                                              TAG: /* Break */0,
                                                              _0: "@ ",
                                                              _1: 1,
                                                              _2: 0
                                                            },
                                                            _1: {
                                                              TAG: /* String */2,
                                                              _0: /* No_padding */0,
                                                              _1: {
                                                                TAG: /* Formatting_lit */17,
                                                                _0: {
                                                                  TAG: /* Break */0,
                                                                  _0: "@ ",
                                                                  _1: 1,
                                                                  _2: 0
                                                                },
                                                                _1: {
                                                                  TAG: /* Alpha */15,
                                                                  _0: {
                                                                    TAG: /* Formatting_lit */17,
                                                                    _0: /* Close_box */0,
                                                                    _1: /* End_of_format */0
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  },
                                                  _1: "@[<hov>%s %a@ %s@ %a@]"
                                                }), "This variant type contains a constructor", type_expr$1, ty, "which should be", type_expr$1, ty$p);
                                      }));
                      case /* Not_a_variant */11 :
                          const ty$1 = param$1._0;
                          reset(undefined);
                          mark_loops(ty$1);
                          return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                          _0: {
                                            TAG: /* Formatting_gen */18,
                                            _0: {
                                              TAG: /* Open_box */1,
                                              _0: /* Format */{
                                                _0: /* End_of_format */0,
                                                _1: ""
                                              }
                                            },
                                            _1: {
                                              TAG: /* String_literal */11,
                                              _0: "The type ",
                                              _1: {
                                                TAG: /* Alpha */15,
                                                _0: {
                                                  TAG: /* Formatting_lit */17,
                                                  _0: {
                                                    TAG: /* Break */0,
                                                    _0: "@ ",
                                                    _1: 1,
                                                    _2: 0
                                                  },
                                                  _1: {
                                                    TAG: /* String_literal */11,
                                                    _0: "is not a polymorphic variant type",
                                                    _1: {
                                                      TAG: /* Formatting_lit */17,
                                                      _0: /* Close_box */0,
                                                      _1: /* End_of_format */0
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          },
                                          _1: "@[The type %a@ is not a polymorphic variant type@]"
                                        }), type_expr$1, ty$1);
                      case /* Variant_tags */12 :
                          return Curry._3(Stdlib__Format.fprintf(param)(/* Format */{
                                          _0: {
                                            TAG: /* Formatting_gen */18,
                                            _0: {
                                              TAG: /* Open_box */1,
                                              _0: /* Format */{
                                                _0: /* End_of_format */0,
                                                _1: ""
                                              }
                                            },
                                            _1: {
                                              TAG: /* String_literal */11,
                                              _0: "Variant tags `",
                                              _1: {
                                                TAG: /* String */2,
                                                _0: /* No_padding */0,
                                                _1: {
                                                  TAG: /* Formatting_lit */17,
                                                  _0: {
                                                    TAG: /* Break */0,
                                                    _0: "@ ",
                                                    _1: 1,
                                                    _2: 0
                                                  },
                                                  _1: {
                                                    TAG: /* String_literal */11,
                                                    _0: "and `",
                                                    _1: {
                                                      TAG: /* String */2,
                                                      _0: /* No_padding */0,
                                                      _1: {
                                                        TAG: /* String_literal */11,
                                                        _0: " have the same hash value.",
                                                        _1: {
                                                          TAG: /* Formatting_lit */17,
                                                          _0: {
                                                            TAG: /* Break */0,
                                                            _0: "@ ",
                                                            _1: 1,
                                                            _2: 0
                                                          },
                                                          _1: {
                                                            TAG: /* String */2,
                                                            _0: /* No_padding */0,
                                                            _1: {
                                                              TAG: /* Formatting_lit */17,
                                                              _0: /* Close_box */0,
                                                              _1: /* End_of_format */0
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          },
                                          _1: "@[Variant tags `%s@ and `%s have the same hash value.@ %s@]"
                                        }), param$1._0, param$1._1, "Change one of them.");
                      case /* Invalid_variable_name */13 :
                          return Curry._1(Stdlib__Format.fprintf(param)(/* Format */{
                                          _0: {
                                            TAG: /* String_literal */11,
                                            _0: "The type variable name ",
                                            _1: {
                                              TAG: /* String */2,
                                              _0: /* No_padding */0,
                                              _1: {
                                                TAG: /* String_literal */11,
                                                _0: " is not allowed in programs",
                                                _1: /* End_of_format */0
                                              }
                                            }
                                          },
                                          _1: "The type variable name %s is not allowed in programs"
                                        }), param$1._0);
                      case /* Cannot_quantify */14 :
                          const v = param$1._1;
                          return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                          _0: {
                                            TAG: /* Formatting_gen */18,
                                            _0: {
                                              TAG: /* Open_box */1,
                                              _0: /* Format */{
                                                _0: {
                                                  TAG: /* String_literal */11,
                                                  _0: "<hov>",
                                                  _1: /* End_of_format */0
                                                },
                                                _1: "<hov>"
                                              }
                                            },
                                            _1: {
                                              TAG: /* String_literal */11,
                                              _0: "The universal type variable '",
                                              _1: {
                                                TAG: /* String */2,
                                                _0: /* No_padding */0,
                                                _1: {
                                                  TAG: /* String_literal */11,
                                                  _0: " cannot be generalized:",
                                                  _1: {
                                                    TAG: /* Formatting_lit */17,
                                                    _0: {
                                                      TAG: /* Break */0,
                                                      _0: "@ ",
                                                      _1: 1,
                                                      _2: 0
                                                    },
                                                    _1: {
                                                      TAG: /* String */2,
                                                      _0: /* No_padding */0,
                                                      _1: {
                                                        TAG: /* Char_literal */12,
                                                        _0: /* '.' */46,
                                                        _1: {
                                                          TAG: /* Formatting_lit */17,
                                                          _0: /* Close_box */0,
                                                          _1: /* End_of_format */0
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          },
                                          _1: "@[<hov>The universal type variable '%s cannot be generalized:@ %s.@]"
                                        }), param$1._0, is_Tvar(v) ? "it escapes its scope" : (
                                        is_Tunivar(v) ? "it is already bound to another variable" : "it is not a variable"
                                      ));
                      case /* Multiple_constraints_on_type */15 :
                          return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                          _0: {
                                            TAG: /* String_literal */11,
                                            _0: "Multiple constraints for type ",
                                            _1: {
                                              TAG: /* Alpha */15,
                                              _0: /* End_of_format */0
                                            }
                                          },
                                          _1: "Multiple constraints for type %a"
                                        }), longident, param$1._0);
                      case /* Repeated_method_label */16 :
                          return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                          _0: {
                                            TAG: /* Formatting_gen */18,
                                            _0: {
                                              TAG: /* Open_box */1,
                                              _0: /* Format */{
                                                _0: /* End_of_format */0,
                                                _1: ""
                                              }
                                            },
                                            _1: {
                                              TAG: /* String_literal */11,
                                              _0: "This is the second method `",
                                              _1: {
                                                TAG: /* String */2,
                                                _0: /* No_padding */0,
                                                _1: {
                                                  TAG: /* String_literal */11,
                                                  _0: "' of this object type.",
                                                  _1: {
                                                    TAG: /* Formatting_lit */17,
                                                    _0: {
                                                      TAG: /* Break */0,
                                                      _0: "@ ",
                                                      _1: 1,
                                                      _2: 0
                                                    },
                                                    _1: {
                                                      TAG: /* String */2,
                                                      _0: /* No_padding */0,
                                                      _1: {
                                                        TAG: /* Formatting_lit */17,
                                                        _0: /* Close_box */0,
                                                        _1: /* End_of_format */0
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          },
                                          _1: "@[This is the second method `%s' of this object type.@ %s@]"
                                        }), param$1._0, "Multiple occurences are not allowed.");
                      case /* Unbound_value */17 :
                          const lid$1 = param$1._0;
                          Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                    _0: {
                                      TAG: /* String_literal */11,
                                      _0: "Unbound value ",
                                      _1: {
                                        TAG: /* Alpha */15,
                                        _0: /* End_of_format */0
                                      }
                                    },
                                    _1: "Unbound value %a"
                                  }), longident, lid$1);
                          return spellcheck$1(param, fold_values)(env, lid$1);
                      case /* Unbound_constructor */18 :
                          const lid$2 = param$1._0;
                          Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                    _0: {
                                      TAG: /* String_literal */11,
                                      _0: "Unbound constructor ",
                                      _1: {
                                        TAG: /* Alpha */15,
                                        _0: /* End_of_format */0
                                      }
                                    },
                                    _1: "Unbound constructor %a"
                                  }), longident, lid$2);
                          return spellcheck_simple(param, fold_constructors, (function (d) {
                                          return d.cstr_name;
                                        }))(env, lid$2);
                      case /* Unbound_label */19 :
                          const lid$3 = param$1._0;
                          Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                    _0: {
                                      TAG: /* String_literal */11,
                                      _0: "Unbound record field ",
                                      _1: {
                                        TAG: /* Alpha */15,
                                        _0: /* End_of_format */0
                                      }
                                    },
                                    _1: "Unbound record field %a"
                                  }), longident, lid$3);
                          return spellcheck_simple(param, fold_labels, (function (d) {
                                          return d.lbl_name;
                                        }))(env, lid$3);
                      case /* Unbound_module */20 :
                          const lid$4 = param$1._0;
                          Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                    _0: {
                                      TAG: /* String_literal */11,
                                      _0: "Unbound module ",
                                      _1: {
                                        TAG: /* Alpha */15,
                                        _0: /* End_of_format */0
                                      }
                                    },
                                    _1: "Unbound module %a"
                                  }), longident, lid$4);
                          return spellcheck$1(param, fold_modules)(env, lid$4);
                      case /* Unbound_class */21 :
                          const lid$5 = param$1._0;
                          Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                    _0: {
                                      TAG: /* String_literal */11,
                                      _0: "Unbound class ",
                                      _1: {
                                        TAG: /* Alpha */15,
                                        _0: /* End_of_format */0
                                      }
                                    },
                                    _1: "Unbound class %a"
                                  }), longident, lid$5);
                          return spellcheck$1(param, fold_classs)(env, lid$5);
                      case /* Unbound_modtype */22 :
                          const lid$6 = param$1._0;
                          Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                    _0: {
                                      TAG: /* String_literal */11,
                                      _0: "Unbound module type ",
                                      _1: {
                                        TAG: /* Alpha */15,
                                        _0: /* End_of_format */0
                                      }
                                    },
                                    _1: "Unbound module type %a"
                                  }), longident, lid$6);
                          return spellcheck$1(param, fold_modtypes)(env, lid$6);
                      case /* Unbound_cltype */23 :
                          const lid$7 = param$1._0;
                          Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                    _0: {
                                      TAG: /* String_literal */11,
                                      _0: "Unbound class type ",
                                      _1: {
                                        TAG: /* Alpha */15,
                                        _0: /* End_of_format */0
                                      }
                                    },
                                    _1: "Unbound class type %a"
                                  }), longident, lid$7);
                          return spellcheck$1(param, fold_cltypes)(env, lid$7);
                      case /* Ill_typed_functor_application */24 :
                          return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                          _0: {
                                            TAG: /* String_literal */11,
                                            _0: "Ill-typed functor application ",
                                            _1: {
                                              TAG: /* Alpha */15,
                                              _0: /* End_of_format */0
                                            }
                                          },
                                          _1: "Ill-typed functor application %a"
                                        }), longident, param$1._0);
                      case /* Access_functor_as_structure */25 :
                          return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                          _0: {
                                            TAG: /* String_literal */11,
                                            _0: "The module ",
                                            _1: {
                                              TAG: /* Alpha */15,
                                              _0: {
                                                TAG: /* String_literal */11,
                                                _0: " is a functor, not a structure",
                                                _1: /* End_of_format */0
                                              }
                                            }
                                          },
                                          _1: "The module %a is a functor, not a structure"
                                        }), longident, param$1._0);
                      
                    }
                  }), err._3);
    });

const $$Error$7 = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Typecore.Error");

const Error_forward$1 = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Typecore.Error_forward");

const type_module = {
  contents: (function (env, md) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  42440,
                  22
                ]
              });
    })
};

const type_open = {
  contents: (function (param) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  42446,
                  16
                ]
              });
    })
};

const type_package = {
  contents: (function (param) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  42451,
                  16
                ]
              });
    })
};

const type_object = {
  contents: (function (env, s) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  42455,
                  20
                ]
              });
    })
};

function re(node) {
  add_saved_type({
        TAG: /* Partial_expression */2,
        _0: node
      });
  record$2({
        TAG: /* Ti_expr */1,
        _0: node
      });
  return node;
}

function rp(node) {
  add_saved_type({
        TAG: /* Partial_pattern */3,
        _0: node
      });
  record$2({
        TAG: /* Ti_pat */0,
        _0: node
      });
  return node;
}

function snd3(param) {
  return param[1];
}

function iter_expression(f, e) {
  const expr = function (_e) {
    while(true) {
      const e = _e;
      Curry._1(f, e);
      const pel = e.pexp_desc;
      switch (pel.TAG | 0) {
        case /* Pexp_let */2 :
            expr(pel._2);
            return Stdlib__List.iter(binding, pel._1);
        case /* Pexp_function */3 :
            return Stdlib__List.iter($$case, pel._0);
        case /* Pexp_fun */4 :
            may(expr, pel._1);
            _e = pel._3;
            continue ;
        case /* Pexp_apply */5 :
            expr(pel._0);
            return Stdlib__List.iter((function (param) {
                          expr(param[1]);
                        }), pel._1);
        case /* Pexp_match */6 :
        case /* Pexp_try */7 :
            break;
        case /* Pexp_construct */9 :
        case /* Pexp_variant */10 :
            return may(expr, pel._1);
        case /* Pexp_record */11 :
            may(expr, pel._1);
            return Stdlib__List.iter((function (param) {
                          expr(param[1]);
                        }), pel._0);
        case /* Pexp_setfield */13 :
            expr(pel._0);
            _e = pel._2;
            continue ;
        case /* Pexp_tuple */8 :
        case /* Pexp_array */14 :
            return Stdlib__List.iter(expr, pel._0);
        case /* Pexp_ifthenelse */15 :
            expr(pel._0);
            expr(pel._1);
            return may(expr, pel._2);
        case /* Pexp_sequence */16 :
        case /* Pexp_while */17 :
            expr(pel._0);
            _e = pel._1;
            continue ;
        case /* Pexp_for */18 :
            expr(pel._1);
            expr(pel._2);
            _e = pel._4;
            continue ;
        case /* Pexp_override */24 :
            return Stdlib__List.iter((function (param) {
                          expr(param[1]);
                        }), pel._0);
        case /* Pexp_letmodule */25 :
            expr(pel._2);
            return module_expr(pel._1);
        case /* Pexp_object */29 :
            return Stdlib__List.iter(class_field, pel._0.pcstr_fields);
        case /* Pexp_setinstvar */23 :
        case /* Pexp_newtype */30 :
            _e = pel._1;
            continue ;
        case /* Pexp_pack */31 :
            return module_expr(pel._0);
        case /* Pexp_open */32 :
            _e = pel._2;
            continue ;
        case /* Pexp_ident */0 :
        case /* Pexp_constant */1 :
        case /* Pexp_new */22 :
        case /* Pexp_extension */33 :
            return ;
        default:
          _e = pel._0;
          continue ;
      }
      expr(pel._0);
      return Stdlib__List.iter($$case, pel._1);
    };
  };
  const $$case = function (param) {
    may(expr, param.pc_guard);
    expr(param.pc_rhs);
  };
  const binding = function (x) {
    expr(x.pvb_expr);
  };
  const module_expr = function (_me) {
    while(true) {
      const me = _me;
      const str = me.pmod_desc;
      switch (str.TAG | 0) {
        case /* Pmod_structure */1 :
            return Stdlib__List.iter(structure_item, str._0);
        case /* Pmod_functor */2 :
            _me = str._2;
            continue ;
        case /* Pmod_apply */3 :
            module_expr(str._0);
            _me = str._1;
            continue ;
        case /* Pmod_constraint */4 :
            _me = str._0;
            continue ;
        case /* Pmod_unpack */5 :
            return expr(str._0);
        case /* Pmod_ident */0 :
        case /* Pmod_extension */6 :
            return ;
        
      }
    };
  };
  const structure_item = function (str) {
    const l = str.pstr_desc;
    switch (l.TAG | 0) {
      case /* Pstr_eval */0 :
          return expr(l._0);
      case /* Pstr_value */1 :
          return Stdlib__List.iter(binding, l._1);
      case /* Pstr_module */6 :
          return module_expr(l._0.pmb_expr);
      case /* Pstr_recmodule */7 :
          return Stdlib__List.iter((function (x) {
                        module_expr(x.pmb_expr);
                      }), l._0);
      case /* Pstr_class */10 :
          return Stdlib__List.iter((function (c) {
                        class_expr(c.pci_expr);
                      }), l._0);
      case /* Pstr_include */12 :
          return module_expr(l._0.pincl_mod);
      default:
        return ;
    }
  };
  const class_expr = function (_ce) {
    while(true) {
      const ce = _ce;
      const match = ce.pcl_desc;
      switch (match.TAG | 0) {
        case /* Pcl_structure */1 :
            return Stdlib__List.iter(class_field, match._0.pcstr_fields);
        case /* Pcl_fun */2 :
            may(expr, match._1);
            _ce = match._3;
            continue ;
        case /* Pcl_apply */3 :
            class_expr(match._0);
            return Stdlib__List.iter((function (param) {
                          expr(param[1]);
                        }), match._1);
        case /* Pcl_let */4 :
            Stdlib__List.iter(binding, match._1);
            _ce = match._2;
            continue ;
        case /* Pcl_constraint */5 :
            _ce = match._0;
            continue ;
        case /* Pcl_constr */0 :
        case /* Pcl_extension */6 :
            return ;
        
      }
    };
  };
  const class_field = function (cf) {
    const e = cf.pcf_desc;
    switch (e.TAG | 0) {
      case /* Pcf_inherit */0 :
          return class_expr(e._1);
      case /* Pcf_val */1 :
          const match = e._0[2];
          if (match.TAG === /* Cfk_virtual */0) {
            return ;
          } else {
            return expr(match._1);
          }
      case /* Pcf_method */2 :
          const match$1 = e._0[2];
          if (match$1.TAG === /* Cfk_virtual */0) {
            return ;
          } else {
            return expr(match$1._1);
          }
      case /* Pcf_initializer */4 :
          return expr(e._0);
      case /* Pcf_constraint */3 :
      case /* Pcf_attribute */5 :
      case /* Pcf_extension */6 :
          return ;
      
    }
  };
  expr(e);
}

function all_idents_cases(el) {
  const idents = Stdlib__Hashtbl.create(undefined, 8);
  const f = function (param) {
    const match = param.pexp_desc;
    if (match.TAG !== /* Pexp_ident */0) {
      return ;
    }
    const id = match._0.txt;
    switch (id.TAG | 0) {
      case /* Lident */0 :
          return Stdlib__Hashtbl.replace(idents, id._0, undefined);
      case /* Ldot */1 :
      case /* Lapply */2 :
          return ;
      
    }
  };
  Stdlib__List.iter((function (cp) {
          may((function (param) {
                  return iter_expression(f, param);
                }), cp.pc_guard);
          iter_expression(f, cp.pc_rhs);
        }), el);
  return Stdlib__Hashtbl.fold((function (x, param, rest) {
                return {
                        hd: x,
                        tl: rest
                      };
              }), idents, /* [] */0);
}

function type_constant(param) {
  switch (param.TAG | 0) {
    case /* Const_int */0 :
        return instance_def(type_int);
    case /* Const_char */1 :
        return instance_def(type_char);
    case /* Const_string */2 :
        return instance_def(type_string);
    case /* Const_float */3 :
        return instance_def(type_float);
    case /* Const_int32 */4 :
        return instance_def(type_int32);
    case /* Const_int64 */5 :
        return instance_def(type_int64);
    case /* Const_nativeint */6 :
        return instance_def(type_nativeint);
    
  }
}

function type_option$1(ty) {
  return newty2(current_level.contents, {
              TAG: /* Tconstr */3,
              _0: path_option,
              _1: {
                hd: ty,
                tl: /* [] */0
              },
              _2: {
                contents: /* Mnil */0
              }
            });
}

function mkexp$1(exp_desc, exp_type, exp_loc, exp_env) {
  return {
          exp_desc: exp_desc,
          exp_loc: exp_loc,
          exp_extra: /* [] */0,
          exp_type: exp_type,
          exp_env: exp_env,
          exp_attributes: /* [] */0
        };
}

function option_none(ty, loc) {
  const lid = {
    TAG: /* Lident */0,
    _0: "None"
  };
  const cnone = lookup_constructor(lid, initial_safe_string);
  return mkexp$1({
              TAG: /* Texp_construct */8,
              _0: {
                txt: lid,
                loc: none
              },
              _1: cnone,
              _2: /* [] */0
            }, ty, loc, initial_safe_string);
}

function option_some(texp) {
  const lid = {
    TAG: /* Lident */0,
    _0: "Some"
  };
  const csome = lookup_constructor(lid, initial_safe_string);
  return mkexp$1({
              TAG: /* Texp_construct */8,
              _0: {
                txt: lid,
                loc: none
              },
              _1: csome,
              _2: {
                hd: texp,
                tl: /* [] */0
              }
            }, type_option$1(texp.exp_type), texp.exp_loc, texp.exp_env);
}

function extract_option_type(env, ty) {
  const match = expand_head(env, ty);
  const match$1 = match.desc;
  if (typeof match$1 !== "number" && match$1.TAG === /* Tconstr */3) {
    const match$2 = match$1._1;
    if (match$2 && !match$2.tl && same(match$1._0, path_option)) {
      return match$2.hd;
    }
    
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              42638,
              9
            ]
          });
}

function extract_concrete_record(env, ty) {
  const match = extract_concrete_typedecl(env, ty);
  const match$1 = match[2].type_kind;
  if (typeof match$1 === "number") {
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
  }
  if (match$1.TAG === /* Type_record */0) {
    return [
            match[0],
            match[1],
            match$1._0
          ];
  }
  throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
}

function extract_concrete_variant(env, ty) {
  const match = extract_concrete_typedecl(env, ty);
  const cstrs = match[2].type_kind;
  const p = match[1];
  const p0 = match[0];
  if (typeof cstrs === "number") {
    if (cstrs !== /* Type_abstract */0) {
      return [
              p0,
              p,
              /* [] */0
            ];
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
  } else {
    if (cstrs.TAG !== /* Type_record */0) {
      return [
              p0,
              p,
              cstrs._0
            ];
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
  }
}

function extract_label_names(sexp, env, ty) {
  try {
    const match = extract_concrete_record(env, ty);
    return Stdlib__List.map((function (l) {
                  return l.ld_id;
                }), match[2]);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  42656,
                  4
                ]
              });
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function explicit_arity(param) {
  return Stdlib__List.exists((function (param) {
                switch (param[0].txt) {
                  case "explicit_arity" :
                  case "ocaml.explicit_arity" :
                      return true;
                  default:
                    return false;
                }
              }), param);
}

function unify_pat_types(loc, env, ty, ty$p) {
  try {
    return unify$2(env, ty, ty$p);
  }
  catch (raw_trace){
    const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
    if (trace.MEL_EXN_ID === Unify) {
      throw new Caml_js_exceptions.MelangeError($$Error$7, {
                MEL_EXN_ID: $$Error$7,
                _1: loc,
                _2: env,
                _3: {
                  TAG: /* Pattern_type_clash */3,
                  _0: trace._1
                }
              });
    }
    if (trace.MEL_EXN_ID === Tags) {
      throw new Caml_js_exceptions.MelangeError($$Error$6, {
                MEL_EXN_ID: $$Error$6,
                _1: loc,
                _2: env,
                _3: {
                  TAG: /* Variant_tags */12,
                  _0: trace._1,
                  _1: trace._2
                }
              });
    }
    throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
  }
}

function unify_exp_types(loc, env, ty, expected_ty) {
  try {
    return unify$2(env, ty, expected_ty);
  }
  catch (raw_trace){
    const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
    if (trace.MEL_EXN_ID === Unify) {
      throw new Caml_js_exceptions.MelangeError($$Error$7, {
                MEL_EXN_ID: $$Error$7,
                _1: loc,
                _2: env,
                _3: {
                  TAG: /* Expr_type_clash */7,
                  _0: trace._1
                }
              });
    }
    if (trace.MEL_EXN_ID === Tags) {
      throw new Caml_js_exceptions.MelangeError($$Error$6, {
                MEL_EXN_ID: $$Error$6,
                _1: loc,
                _2: env,
                _3: {
                  TAG: /* Variant_tags */12,
                  _0: trace._1,
                  _1: trace._2
                }
              });
    }
    throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
  }
}

const newtype_level$1 = {
  contents: undefined
};

function get_newtype_level$1(param) {
  const y = newtype_level$1.contents;
  if (y !== undefined) {
    return y;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              42694,
              12
            ]
          });
}

function unify_pat_types_gadt(loc, env, ty, ty$p) {
  const x = newtype_level$1.contents;
  let newtype_level$2;
  if (x !== undefined) {
    newtype_level$2 = x;
  } else {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                42699,
                14
              ]
            });
  }
  try {
    try {
      univar_pairs.contents = /* [] */0;
      newtype_level.contents = newtype_level$2;
      set_mode_pattern(true, true, (function (param) {
              unify$1(env, ty, ty$p);
            }));
      newtype_level.contents = undefined;
      return Curry._1(TypePairs.clear, unify_eq_set);
    }
    catch (raw_e){
      const e = Caml_js_exceptions.internalToOCamlException(raw_e);
      Curry._1(TypePairs.clear, unify_eq_set);
      if (e.MEL_EXN_ID === Unify) {
        throw new Caml_js_exceptions.MelangeError(Unify, {
                  MEL_EXN_ID: Unify,
                  _1: e._1
                });
      }
      newtype_level.contents = undefined;
      throw new Caml_js_exceptions.MelangeError(e.MEL_EXN_ID, e);
    }
  }
  catch (raw_trace){
    const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
    if (trace.MEL_EXN_ID === Unify) {
      throw new Caml_js_exceptions.MelangeError($$Error$7, {
                MEL_EXN_ID: $$Error$7,
                _1: loc,
                _2: env.contents,
                _3: {
                  TAG: /* Pattern_type_clash */3,
                  _0: trace._1
                }
              });
    }
    if (trace.MEL_EXN_ID === Tags) {
      throw new Caml_js_exceptions.MelangeError($$Error$6, {
                MEL_EXN_ID: $$Error$6,
                _1: loc,
                _2: env.contents,
                _3: {
                  TAG: /* Variant_tags */12,
                  _0: trace._1,
                  _1: trace._2
                }
              });
    }
    if (trace.MEL_EXN_ID === Unification_recursive_abbrev) {
      throw new Caml_js_exceptions.MelangeError($$Error$7, {
                MEL_EXN_ID: $$Error$7,
                _1: loc,
                _2: env.contents,
                _3: {
                  TAG: /* Recursive_local_constraint */33,
                  _0: trace._1
                }
              });
    }
    throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
  }
}

function unify_pat(env, pat, expected_ty) {
  unify_pat_types(pat.pat_loc, env, pat.pat_type, expected_ty);
}

function finalize_variant(pat) {
  const match = pat.pat_desc;
  if (typeof match === "number") {
    return ;
  }
  if (match.TAG !== /* Tpat_variant */5) {
    return ;
  }
  const opat = match._1;
  const match$1 = expand_head(pat.pat_env, pat.pat_type);
  const row = match$1.desc;
  let row$1;
  if (typeof row === "number") {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                42725,
                15
              ]
            });
  }
  if (row.TAG === /* Tvariant */8) {
    const row$2 = row._0;
    match._2.contents = row$2;
    row$1 = row_repr_aux(/* [] */0, row$2);
  } else {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                42725,
                15
              ]
            });
  }
  const match$2 = row_field(match._0, row$1);
  if (typeof match$2 === "number") {
    return ;
  }
  if (match$2.TAG === /* Rpresent */0) {
    return ;
  }
  const c = match$2._0;
  if (c) {
    if (!match$2._1 && !row$1.row_closed) {
      return set_row_field(match$2._3, {
                  TAG: /* Rpresent */0,
                  _0: undefined
                });
    }
    
  } else {
    const match$3 = match$2._1;
    if (match$3 && !row$1.row_closed) {
      const ty = match$3.hd;
      set_row_field(match$2._3, {
            TAG: /* Rpresent */0,
            _0: ty
          });
      if (opat !== undefined) {
        const partial_arg = opat.pat_env;
        return Stdlib__List.iter((function (param) {
                      return unify_pat(partial_arg, opat, param);
                    }), {
                    hd: ty,
                    tl: match$3.tl
                  });
      }
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  42733,
                  40
                ]
              });
    }
    
  }
  if (match$2._2 && !row_fixed(row$1)) {
    return set_row_field(match$2._3, {
                TAG: /* Reither */1,
                _0: c,
                _1: /* [] */0,
                _2: false,
                _3: {
                  contents: undefined
                }
              });
  }
  
}

function iter_pattern(f, p) {
  Curry._1(f, p);
  iter_pattern_desc((function (param) {
          return iter_pattern(f, param);
        }), p.pat_desc);
}

function has_variants(p) {
  try {
    iter_pattern((function (param) {
            let tmp = param.pat_desc;
            if (typeof tmp === "number") {
              return ;
            }
            if (tmp.TAG !== /* Tpat_variant */5) {
              return ;
            }
            throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                      MEL_EXN_ID: Stdlib.Exit
                    });
          }), p);
    return false;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Exit) {
      return true;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

const pattern_variables = {
  contents: /* [] */0
};

const pattern_force = {
  contents: /* [] */0
};

const pattern_scope = {
  contents: undefined
};

const allow_modules = {
  contents: false
};

const module_variables = {
  contents: /* [] */0
};

function reset_pattern(scope, allow) {
  pattern_variables.contents = /* [] */0;
  pattern_force.contents = /* [] */0;
  pattern_scope.contents = scope;
  allow_modules.contents = allow;
  module_variables.contents = /* [] */0;
}

function enter_variable(is_moduleOpt, is_as_variableOpt, loc, name, ty) {
  const is_module = is_moduleOpt !== undefined ? is_moduleOpt : false;
  const is_as_variable = is_as_variableOpt !== undefined ? is_as_variableOpt : false;
  if (Stdlib__List.exists((function (param) {
            return param[0].name === name.txt;
          }), pattern_variables.contents)) {
    throw new Caml_js_exceptions.MelangeError($$Error$7, {
              MEL_EXN_ID: $$Error$7,
              _1: loc,
              _2: empty,
              _3: {
                TAG: /* Multiply_bound_variable */5,
                _0: name.txt
              }
            });
  }
  const id = create(name.txt);
  pattern_variables.contents = {
    hd: [
      id,
      ty,
      name,
      loc,
      is_as_variable
    ],
    tl: pattern_variables.contents
  };
  if (is_module) {
    if (!allow_modules.contents) {
      throw new Caml_js_exceptions.MelangeError($$Error$7, {
                MEL_EXN_ID: $$Error$7,
                _1: loc,
                _2: empty,
                _3: /* Modules_not_allowed */2
              });
    }
    module_variables.contents = {
      hd: [
        name,
        loc
      ],
      tl: module_variables.contents
    };
  } else {
    may((function (s) {
            record$2({
                  TAG: /* An_ident */5,
                  _0: name.loc,
                  _1: name.txt,
                  _2: s
                });
          }), pattern_scope.contents);
  }
  return id;
}

function sort_pattern_variables(vs) {
  return Stdlib__List.sort((function (param, param$1) {
                return Caml.caml_string_compare(param[0].name, param$1[0].name);
              }), vs);
}

function enter_orpat_variables(loc, env, p1_vs, p2_vs) {
  const p1_vs$1 = sort_pattern_variables(p1_vs);
  const p2_vs$1 = sort_pattern_variables(p2_vs);
  const unify_vars = function (_p1_vs, _p2_vs) {
    while(true) {
      const p2_vs = _p2_vs;
      const p1_vs = _p1_vs;
      if (p1_vs) {
        const match = p1_vs.hd;
        const x1 = match[0];
        if (p2_vs) {
          const match$1 = p2_vs.hd;
          const x2 = match$1[0];
          const rem1 = p1_vs.tl;
          const rem2 = p2_vs.tl;
          if (equal(x1, x2)) {
            if (x1 === x2) {
              _p2_vs = rem2;
              _p1_vs = rem1;
              continue ;
            }
            try {
              unify$2(env, match[1], match$1[1]);
            }
            catch (raw_trace){
              const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
              if (trace.MEL_EXN_ID === Unify) {
                throw new Caml_js_exceptions.MelangeError($$Error$7, {
                          MEL_EXN_ID: $$Error$7,
                          _1: loc,
                          _2: env,
                          _3: {
                            TAG: /* Or_pattern_type_clash */4,
                            _0: x1,
                            _1: trace._1
                          }
                        });
              }
              throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
            }
            return {
                    hd: [
                      x2,
                      x1
                    ],
                    tl: unify_vars(rem1, rem2)
                  };
          }
          const min_var = x1.name < x2.name ? x1 : x2;
          throw new Caml_js_exceptions.MelangeError($$Error$7, {
                    MEL_EXN_ID: $$Error$7,
                    _1: loc,
                    _2: env,
                    _3: {
                      TAG: /* Orpat_vars */6,
                      _0: min_var
                    }
                  });
        }
        throw new Caml_js_exceptions.MelangeError($$Error$7, {
                  MEL_EXN_ID: $$Error$7,
                  _1: loc,
                  _2: env,
                  _3: {
                    TAG: /* Orpat_vars */6,
                    _0: x1
                  }
                });
      }
      if (!p2_vs) {
        return /* [] */0;
      }
      throw new Caml_js_exceptions.MelangeError($$Error$7, {
                MEL_EXN_ID: $$Error$7,
                _1: loc,
                _2: env,
                _3: {
                  TAG: /* Orpat_vars */6,
                  _0: p2_vs.hd[0]
                }
              });
    };
  };
  return unify_vars(p1_vs$1, p2_vs$1);
}

function build_as_type(env, _p) {
  while(true) {
    const p = _p;
    const pl = p.pat_desc;
    if (typeof pl === "number") {
      return p.pat_type;
    }
    switch (pl.TAG | 0) {
      case /* Tpat_alias */1 :
          _p = pl._0;
          continue ;
      case /* Tpat_tuple */3 :
          const tyl = Stdlib__List.map((function (param) {
                  return build_as_type(env, param);
                }), pl._0);
          return newty2(current_level.contents, {
                      TAG: /* Ttuple */2,
                      _0: tyl
                    });
      case /* Tpat_construct */4 :
          const pl$1 = pl._2;
          const cstr = pl._1;
          const keep = cstr.cstr_private === /* Private */0 || Caml_obj.caml_notequal(cstr.cstr_existentials, /* [] */0);
          if (keep) {
            return p.pat_type;
          }
          const tyl$1 = Stdlib__List.map((function (param) {
                  return build_as_type(env, param);
                }), pl$1);
          const match = instance_constructor(undefined, cstr);
          Stdlib__List.iter2((function (param) {
                  const p = param[0];
                  const partial_arg = {
                    pat_desc: p.pat_desc,
                    pat_loc: p.pat_loc,
                    pat_extra: p.pat_extra,
                    pat_type: param[1],
                    pat_env: p.pat_env,
                    pat_attributes: p.pat_attributes
                  };
                  return function (param) {
                    return unify_pat(env, partial_arg, param);
                  };
                }), Stdlib__List.combine(pl$1, tyl$1), match[0]);
          return match[1];
      case /* Tpat_variant */5 :
          const ty = may_map((function (param) {
                  return build_as_type(env, param);
                }), pl._1);
          const desc = {
            TAG: /* Tvariant */8,
            _0: {
              row_fields: {
                hd: [
                  pl._0,
                  {
                    TAG: /* Rpresent */0,
                    _0: ty
                  }
                ],
                tl: /* [] */0
              },
              row_more: newvar(undefined, undefined),
              row_bound: undefined,
              row_closed: false,
              row_fixed: false,
              row_name: undefined
            }
          };
          return newty2(current_level.contents, desc);
      case /* Tpat_record */6 :
          const lpl = pl._0;
          const lbl = snd3(Stdlib__List.hd(lpl));
          if (lbl.lbl_private === /* Private */0) {
            return p.pat_type;
          }
          const ty$1 = newvar(undefined, undefined);
          const ppl = Stdlib__List.map((function (param) {
                  return [
                          param[1].lbl_pos,
                          param[2]
                        ];
                }), lpl);
          const do_label = function (lbl) {
            const match = instance_label(false, lbl);
            const ty_arg = match[1];
            unify_pat(env, {
                  pat_desc: p.pat_desc,
                  pat_loc: p.pat_loc,
                  pat_extra: p.pat_extra,
                  pat_type: ty$1,
                  pat_env: p.pat_env,
                  pat_attributes: p.pat_attributes
                }, match[2]);
            let refinable = false;
            if (lbl.lbl_mut === /* Immutable */0) {
              let tmp = false;
              if (Stdlib__List.mem_assoc(lbl.lbl_pos, ppl)) {
                const match$1 = repr(lbl.lbl_arg).desc;
                let tmp$1;
                tmp$1 = typeof match$1 === "number" || match$1.TAG !== /* Tpoly */10 ? true : false;
                tmp = tmp$1;
              }
              refinable = tmp;
            }
            if (refinable) {
              const arg = Stdlib__List.assoc(lbl.lbl_pos, ppl);
              return unify_pat(env, {
                          pat_desc: arg.pat_desc,
                          pat_loc: arg.pat_loc,
                          pat_extra: arg.pat_extra,
                          pat_type: build_as_type(env, arg),
                          pat_env: arg.pat_env,
                          pat_attributes: arg.pat_attributes
                        }, ty_arg);
            }
            const match$2 = instance_label(false, lbl);
            unify$2(env, ty_arg, match$2[1]);
            unify_pat(env, p, match$2[2]);
          };
          Stdlib__Array.iter(do_label, lbl.lbl_all);
          return ty$1;
      case /* Tpat_or */8 :
          const row = pl._2;
          const p2 = pl._1;
          if (row !== undefined) {
            const row$1 = row_repr_aux(/* [] */0, row);
            const desc$1 = {
              TAG: /* Tvariant */8,
              _0: {
                row_fields: row$1.row_fields,
                row_more: newvar(undefined, undefined),
                row_bound: row$1.row_bound,
                row_closed: false,
                row_fixed: row$1.row_fixed,
                row_name: row$1.row_name
              }
            };
            return newty2(current_level.contents, desc$1);
          }
          const ty1 = build_as_type(env, pl._0);
          const ty2 = build_as_type(env, p2);
          unify_pat(env, {
                pat_desc: p2.pat_desc,
                pat_loc: p2.pat_loc,
                pat_extra: p2.pat_extra,
                pat_type: ty2,
                pat_env: p2.pat_env,
                pat_attributes: p2.pat_attributes
              }, ty1);
          return ty1;
      default:
        return p.pat_type;
    }
  };
}

function build_or_pat(env, loc, lid) {
  const match = find_type(env, loc, lid);
  const path = match[0];
  const tyl = Stdlib__List.map((function (param) {
          return newvar(undefined, undefined);
        }), match[1].type_params);
  const ty = expand_head(env, newty2(current_level.contents, {
            TAG: /* Tconstr */3,
            _0: path,
            _1: tyl,
            _2: {
              contents: /* Mnil */0
            }
          }));
  const row = ty.desc;
  let row0;
  let exit = 0;
  if (typeof row === "number" || row.TAG !== /* Tvariant */8) {
    exit = 1;
  } else {
    const row$1 = row._0;
    if (static_row(row$1)) {
      row0 = row$1;
    } else {
      exit = 1;
    }
  }
  if (exit === 1) {
    throw new Caml_js_exceptions.MelangeError($$Error$7, {
              MEL_EXN_ID: $$Error$7,
              _1: loc,
              _2: env,
              _3: {
                TAG: /* Not_a_variant_type */30,
                _0: lid
              }
            });
  }
  const match$1 = Stdlib__List.fold_left((function (param, param$1) {
          const l = param$1[0];
          const fields = param[1];
          const pats = param[0];
          const match = row_field_repr_aux(/* [] */0, param$1[1]);
          if (typeof match === "number") {
            return [
                    pats,
                    fields
                  ];
          }
          if (match.TAG !== /* Rpresent */0) {
            return [
                    pats,
                    fields
                  ];
          }
          const ty = match._0;
          if (ty !== undefined) {
            return [
                    {
                      hd: [
                        l,
                        {
                          pat_desc: /* Tpat_any */0,
                          pat_loc: none,
                          pat_extra: /* [] */0,
                          pat_type: ty,
                          pat_env: env,
                          pat_attributes: /* [] */0
                        }
                      ],
                      tl: pats
                    },
                    {
                      hd: [
                        l,
                        {
                          TAG: /* Reither */1,
                          _0: false,
                          _1: {
                            hd: ty,
                            tl: /* [] */0
                          },
                          _2: true,
                          _3: {
                            contents: undefined
                          }
                        }
                      ],
                      tl: fields
                    }
                  ];
          } else {
            return [
                    {
                      hd: [
                        l,
                        undefined
                      ],
                      tl: pats
                    },
                    {
                      hd: [
                        l,
                        {
                          TAG: /* Reither */1,
                          _0: true,
                          _1: /* [] */0,
                          _2: true,
                          _3: {
                            contents: undefined
                          }
                        }
                      ],
                      tl: fields
                    }
                  ];
          }
        }), [
        /* [] */0,
        /* [] */0
      ], row_repr_aux(/* [] */0, row0).row_fields);
  const row_row_fields = Stdlib__List.rev(match$1[1]);
  const row_row_more = newvar(undefined, undefined);
  const row_row_name = [
    path,
    tyl
  ];
  const row$2 = {
    row_fields: row_row_fields,
    row_more: row_row_more,
    row_bound: undefined,
    row_closed: false,
    row_fixed: false,
    row_name: row_row_name
  };
  const ty$1 = newty2(current_level.contents, {
        TAG: /* Tvariant */8,
        _0: row$2
      });
  const gloc_loc_start = loc.loc_start;
  const gloc_loc_end = loc.loc_end;
  const gloc = {
    loc_start: gloc_loc_start,
    loc_end: gloc_loc_end,
    loc_ghost: true
  };
  const row$p = {
    contents: {
      row_fields: row_row_fields,
      row_more: newvar(undefined, undefined),
      row_bound: undefined,
      row_closed: false,
      row_fixed: false,
      row_name: row_row_name
    }
  };
  const pats = Stdlib__List.map((function (param) {
          return {
                  pat_desc: {
                    TAG: /* Tpat_variant */5,
                    _0: param[0],
                    _1: param[1],
                    _2: row$p
                  },
                  pat_loc: gloc,
                  pat_extra: /* [] */0,
                  pat_type: ty$1,
                  pat_env: env,
                  pat_attributes: /* [] */0
                };
        }), match$1[0]);
  if (pats) {
    const r = Stdlib__List.fold_left((function (pat, pat0) {
            return {
                    pat_desc: {
                      TAG: /* Tpat_or */8,
                      _0: pat0,
                      _1: pat,
                      _2: row0
                    },
                    pat_loc: gloc,
                    pat_extra: /* [] */0,
                    pat_type: ty$1,
                    pat_env: env,
                    pat_attributes: /* [] */0
                  };
          }), pats.hd, pats.tl);
    return [
            path,
            rp({
                  pat_desc: r.pat_desc,
                  pat_loc: loc,
                  pat_extra: r.pat_extra,
                  pat_type: r.pat_type,
                  pat_env: r.pat_env,
                  pat_attributes: r.pat_attributes
                }),
            ty$1
          ];
  }
  throw new Caml_js_exceptions.MelangeError($$Error$7, {
            MEL_EXN_ID: $$Error$7,
            _1: loc,
            _2: env,
            _3: {
              TAG: /* Not_a_variant_type */30,
              _0: lid
            }
          });
}

function expand_path(env, _p) {
  while(true) {
    const p = _p;
    let decl;
    try {
      decl = find_type_full(p, env)[0];
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        decl = undefined;
      } else {
        throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
      }
    }
    if (decl !== undefined) {
      const ty = decl.type_manifest;
      if (ty !== undefined) {
        const match = repr(ty);
        const match$1 = match.desc;
        if (typeof match$1 === "number") {
          return p;
        }
        if (match$1.TAG !== /* Tconstr */3) {
          return p;
        }
        _p = match$1._0;
        continue ;
      }
      
    }
    const p$p = normalize_path$1(undefined, env, p);
    if (same(p, p$p)) {
      return p;
    }
    _p = p$p;
    continue ;
  };
}

function compare_type_path(env, tpath1, tpath2) {
  return same(expand_path(env, tpath1), expand_path(env, tpath2));
}

function wrap_disambiguate(kind, ty, f, x) {
  try {
    return Curry._1(f, x);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === $$Error$7) {
      const match = exn._3;
      if (typeof match === "number") {
        throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
      }
      if (match.TAG === /* Wrong_name */13) {
        throw new Caml_js_exceptions.MelangeError($$Error$7, {
                  MEL_EXN_ID: $$Error$7,
                  _1: exn._1,
                  _2: exn._2,
                  _3: {
                    TAG: /* Wrong_name */13,
                    _0: kind,
                    _1: ty,
                    _2: match._2,
                    _3: match._3,
                    _4: match._4
                  }
                });
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    } else {
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  }
}

const type_kind = "record";

function get_type_path$1(env, d) {
  const match = d.lbl_res.desc;
  if (typeof match === "number") {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                42965,
                11
              ]
            });
  }
  if (match.TAG === /* Tconstr */3) {
    return match._0;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              42965,
              11
            ]
          });
}

function lookup_from_type(env, tpath, lid) {
  const descrs = find_type_full(tpath, env)[1][1];
  mark_type_used(env, last(tpath), find_type_full(tpath, env)[0]);
  const s = lid.txt;
  switch (s.TAG | 0) {
    case /* Lident */0 :
        const s$1 = s._0;
        try {
          return Stdlib__List.find((function (nd) {
                        return nd.lbl_name === s$1;
                      }), descrs);
        }
        catch (raw_exn){
          const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.MEL_EXN_ID === Stdlib.Not_found) {
            throw new Caml_js_exceptions.MelangeError($$Error$7, {
                      MEL_EXN_ID: $$Error$7,
                      _1: lid.loc,
                      _2: env,
                      _3: {
                        TAG: /* Wrong_name */13,
                        _0: "",
                        _1: newvar(undefined, undefined),
                        _2: type_kind,
                        _3: tpath,
                        _4: lid.txt
                      }
                    });
          }
          throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
        }
    case /* Ldot */1 :
    case /* Lapply */2 :
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                  MEL_EXN_ID: Stdlib.Not_found
                });
    
  }
}

function unique(eq, _acc, _param) {
  while(true) {
    const param = _param;
    const acc = _acc;
    if (!param) {
      return Stdlib__List.rev(acc);
    }
    const rem = param.tl;
    const x = param.hd;
    if (Stdlib__List.exists(Curry._1(eq, x), acc)) {
      _param = rem;
      continue ;
    }
    _param = rem;
    _acc = {
      hd: x,
      tl: acc
    };
    continue ;
  };
}

function ambiguous_types(env, lbl, others) {
  const tpath = get_type_path$1(env, lbl);
  const others$1 = Stdlib__List.map((function (param) {
          return get_type_path$1(env, param[0]);
        }), others);
  const tpaths = unique((function (param, param$1) {
          return compare_type_path(env, param, param$1);
        }), {
        hd: tpath,
        tl: /* [] */0
      }, others$1);
  if (tpaths && !tpaths.tl) {
    return /* [] */0;
  } else {
    return Stdlib__List.map(string_of_path, tpaths);
  }
}

function disambiguate_by_type(env, tpath, lbls) {
  const check_type = function (param) {
    const lbl_tpath = get_type_path$1(env, param[0]);
    return compare_type_path(env, tpath, lbl_tpath);
  };
  return Stdlib__List.find(check_type, lbls);
}

function disambiguate(warnOpt, check_lkOpt, scope, lid, env, opath, lbls) {
  const warn = warnOpt !== undefined ? warnOpt : prerr_warning;
  const check_lk = check_lkOpt !== undefined ? check_lkOpt : (function (param, param$1) {
        
      });
  const scope$1 = scope !== undefined ? scope : lbls;
  let lbl;
  if (opath !== undefined) {
    const pr = opath[2];
    const tpath = opath[1];
    const warn_pr = function (param) {
      const kind = type_kind === "record" ? "field" : "constructor";
      Curry._2(warn, lid.loc, {
            TAG: /* Not_principal */8,
            _0: "this type-based " + (kind + " disambiguation")
          });
    };
    try {
      const match = disambiguate_by_type(env, tpath, scope$1);
      const lbl$1 = match[0];
      Curry._1(match[1], undefined);
      if (!pr) {
        if (lbls) {
          const lbl_tpath = get_type_path$1(env, lbls.hd[0]);
          if (compare_type_path(env, tpath, lbl_tpath)) {
            const paths = ambiguous_types(env, lbl$1, lbls.tl);
            if (Caml_obj.caml_notequal(paths, /* [] */0)) {
              Curry._2(warn, lid.loc, {
                    TAG: /* Ambiguous_name */24,
                    _0: {
                      hd: last$1(lid.txt),
                      tl: /* [] */0
                    },
                    _1: paths,
                    _2: false
                  });
            }
            
          } else {
            warn_pr(undefined);
          }
        } else {
          warn_pr(undefined);
        }
      }
      lbl = lbl$1;
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        try {
          const lbl$2 = lookup_from_type(env, tpath, lid);
          Curry._2(check_lk, tpath, lbl$2);
          const s = string_of_out_ident(tree_of_path(tpath));
          Curry._2(warn, lid.loc, {
                TAG: /* Name_out_of_scope */23,
                _0: s,
                _1: {
                  hd: last$1(lid.txt),
                  tl: /* [] */0
                },
                _2: false
              });
          if (!pr) {
            warn_pr(undefined);
          }
          lbl = lbl$2;
        }
        catch (raw_exn$1){
          const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
          if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
            if (Caml_obj.caml_equal(lbls, /* [] */0)) {
              lbl = unbound_label_error(env, lid);
            } else {
              const tp_0 = opath[0];
              const tp_1 = expand_path(env, tpath);
              const tp = [
                tp_0,
                tp_1
              ];
              const tpl = Stdlib__List.map((function (param) {
                      const tp0 = get_type_path$1(env, param[0]);
                      const tp = expand_path(env, tp0);
                      return [
                              tp0,
                              tp
                            ];
                    }), lbls);
              throw new Caml_js_exceptions.MelangeError($$Error$7, {
                        MEL_EXN_ID: $$Error$7,
                        _1: lid.loc,
                        _2: env,
                        _3: {
                          TAG: /* Name_type_mismatch */14,
                          _0: type_kind,
                          _1: lid.txt,
                          _2: tp,
                          _3: tpl
                        }
                      });
            }
          } else {
            throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
          }
        }
      } else {
        throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
      }
    }
  } else if (lbls) {
    const match$1 = lbls.hd;
    const lbl$3 = match$1[0];
    Curry._1(match$1[1], undefined);
    const paths$1 = ambiguous_types(env, lbl$3, lbls.tl);
    if (Caml_obj.caml_notequal(paths$1, /* [] */0)) {
      Curry._2(warn, lid.loc, {
            TAG: /* Ambiguous_name */24,
            _0: {
              hd: last$1(lid.txt),
              tl: /* [] */0
            },
            _1: paths$1,
            _2: false
          });
    }
    lbl = lbl$3;
  } else {
    lbl = unbound_label_error(env, lid);
  }
  if (scope$1 && scope$1.hd[0] === lbl) {
    
  } else {
    prerr_warning(lid.loc, {
          TAG: /* Disambiguated_name */25,
          _0: lbl.lbl_name
        });
  }
  return lbl;
}

function disambiguate_label_by_ids(keep, env, closed, ids, labels) {
  const check_ids = function (param) {
    const lbls = Stdlib__Hashtbl.create(undefined, 8);
    Stdlib__Array.iter((function (lbl) {
            Stdlib__Hashtbl.add(lbls, lbl.lbl_name, undefined);
          }), param[0].lbl_all);
    return Stdlib__List.for_all((function (param) {
                  return Stdlib__Hashtbl.mem(lbls, param);
                }), ids);
  };
  const check_closed = function (param) {
    if (closed) {
      return Stdlib__List.length(ids) === param[0].lbl_all.length;
    } else {
      return true;
    }
  };
  const labels$p = Stdlib__List.filter(check_ids, labels);
  if (keep && Caml_obj.caml_equal(labels$p, /* [] */0)) {
    return [
            false,
            labels
          ];
  }
  const labels$p$p = Stdlib__List.filter(check_closed, labels$p);
  if (keep && Caml_obj.caml_equal(labels$p$p, /* [] */0)) {
    return [
            false,
            labels$p
          ];
  } else {
    return [
            true,
            labels$p$p
          ];
  }
}

function disambiguate_lid_a_list(loc, closed, env, opath, lid_a_list) {
  const ids = Stdlib__List.map((function (param) {
          return last$1(param[0].txt);
        }), lid_a_list);
  const w_pr = {
    contents: false
  };
  const w_amb = {
    contents: /* [] */0
  };
  const w_scope = {
    contents: /* [] */0
  };
  const w_scope_ty = {
    contents: ""
  };
  const warn = function (loc, msg) {
    if (typeof msg === "number") {
      return prerr_warning(loc, msg);
    }
    switch (msg.TAG | 0) {
      case /* Not_principal */8 :
          w_pr.contents = true;
          return ;
      case /* Name_out_of_scope */23 :
          const match = msg._1;
          if (match && !match.tl) {
            w_scope.contents = {
              hd: match.hd,
              tl: w_scope.contents
            };
            w_scope_ty.contents = msg._0;
            return ;
          } else {
            return prerr_warning(loc, msg);
          }
      case /* Ambiguous_name */24 :
          const match$1 = msg._0;
          if (match$1 && !match$1.tl) {
            w_amb.contents = {
              hd: [
                match$1.hd,
                msg._1
              ],
              tl: w_amb.contents
            };
            return ;
          } else {
            return prerr_warning(loc, msg);
          }
      default:
        return prerr_warning(loc, msg);
    }
  };
  const process_label = function (lid) {
    const scope = find_all_labels(env, lid.loc, lid.txt);
    if (opath === undefined && Caml_obj.caml_equal(scope, /* [] */0)) {
      unbound_label_error(env, lid);
    }
    let match;
    let exit = 0;
    if (opath !== undefined && opath[2]) {
      match = [
        true,
        scope
      ];
    } else {
      exit = 1;
    }
    if (exit === 1) {
      match = disambiguate_label_by_ids(opath === undefined, env, closed, ids, scope);
    }
    const labels = match[1];
    if (match[0]) {
      return disambiguate(warn, undefined, scope, lid, env, opath, labels);
    } else {
      return Stdlib__List.hd(labels)[0];
    }
  };
  const lbl_a_list = Stdlib__List.map((function (param) {
          const lid = param[0];
          return [
                  lid,
                  process_label(lid),
                  param[1]
                ];
        }), lid_a_list);
  if (w_pr.contents) {
    prerr_warning(loc, {
          TAG: /* Not_principal */8,
          _0: "this type-based record disambiguation"
        });
  } else {
    const amb = Stdlib__List.rev(w_amb.contents);
    if (amb) {
      const paths = Stdlib__List.map((function (param) {
              return get_type_path$1(env, param[1]);
            }), lbl_a_list);
      const path = Stdlib__List.hd(paths);
      if (Stdlib__List.for_all((function (param) {
                return compare_type_path(env, path, param);
              }), Stdlib__List.tl(paths))) {
        prerr_warning(loc, {
              TAG: /* Ambiguous_name */24,
              _0: Stdlib__List.map((function (prim) {
                      return prim[0];
                    }), amb),
              _1: amb.hd[1],
              _2: true
            });
      } else {
        Stdlib__List.iter((function (param) {
                prerr_warning(loc, {
                      TAG: /* Ambiguous_name */24,
                      _0: {
                        hd: param[0],
                        tl: /* [] */0
                      },
                      _1: param[1],
                      _2: false
                    });
              }), amb);
      }
    }
    
  }
  if (Caml_obj.caml_notequal(w_scope.contents, /* [] */0)) {
    prerr_warning(loc, {
          TAG: /* Name_out_of_scope */23,
          _0: w_scope_ty.contents,
          _1: Stdlib__List.rev(w_scope.contents),
          _2: true
        });
  }
  return lbl_a_list;
}

function find_record_qual(_param) {
  while(true) {
    const param = _param;
    if (!param) {
      return ;
    }
    const match = param.hd[0].txt;
    switch (match.TAG | 0) {
      case /* Ldot */1 :
          return match._0;
      case /* Lident */0 :
      case /* Lapply */2 :
          _param = param.tl;
          continue ;
      
    }
  };
}

function type_label_a_list(labels, loc, closed, env, type_lbl_a, opath, lid_a_list) {
  let lbl_a_list;
  let exit = 0;
  if (lid_a_list) {
    const s = lid_a_list.hd[0].txt;
    switch (s.TAG | 0) {
      case /* Lident */0 :
          if (labels !== undefined) {
            const labels$1 = Caml_option.valFromOption(labels);
            if (Stdlib__Hashtbl.mem(labels$1, s._0)) {
              lbl_a_list = Stdlib__List.map((function (param) {
                      const lid = param[0];
                      const s = lid.txt;
                      switch (s.TAG | 0) {
                        case /* Lident */0 :
                            return [
                                    lid,
                                    Stdlib__Hashtbl.find(labels$1, s._0),
                                    param[1]
                                  ];
                        case /* Ldot */1 :
                        case /* Lapply */2 :
                            throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                                      MEL_EXN_ID: "Assert_failure",
                                      _1: [
                                        "jscomp/test/ocaml_typedtree_test.ml",
                                        43182,
                                        17
                                      ]
                                    });
                        
                      }
                    }), lid_a_list);
            } else {
              exit = 1;
            }
          } else {
            exit = 1;
          }
          break;
      case /* Ldot */1 :
      case /* Lapply */2 :
          exit = 1;
          break;
      
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    const modname = find_record_qual(lid_a_list);
    const lid_a_list$1 = modname !== undefined ? Stdlib__List.map((function (lid_a) {
              const lid = lid_a[0];
              const s = lid.txt;
              switch (s.TAG | 0) {
                case /* Lident */0 :
                    return [
                            {
                              txt: {
                                TAG: /* Ldot */1,
                                _0: modname,
                                _1: s._0
                              },
                              loc: lid.loc
                            },
                            lid_a[1]
                          ];
                case /* Ldot */1 :
                case /* Lapply */2 :
                    return lid_a;
                
              }
            }), lid_a_list) : lid_a_list;
    lbl_a_list = disambiguate_lid_a_list(loc, closed, env, opath, lid_a_list$1);
  }
  const lbl_a_list$1 = Stdlib__List.sort((function (param, param$1) {
          return Caml.caml_int_compare(param[1].lbl_pos, param$1[1].lbl_pos);
        }), lbl_a_list);
  return Stdlib__List.map(type_lbl_a, lbl_a_list$1);
}

function check_recordpat_labels(loc, lbl_pat_list, closed) {
  if (!lbl_pat_list) {
    return ;
  }
  const all = lbl_pat_list.hd[1].lbl_all;
  const defined = Caml_array.make(all.length, false);
  const check_defined = function (param) {
    const label = param[1];
    if (Caml_array.get(defined, label.lbl_pos)) {
      throw new Caml_js_exceptions.MelangeError($$Error$7, {
                MEL_EXN_ID: $$Error$7,
                _1: loc,
                _2: empty,
                _3: {
                  TAG: /* Label_multiply_defined */10,
                  _0: label.lbl_name
                }
              });
    }
    Caml_array.set(defined, label.lbl_pos, true);
  };
  Stdlib__List.iter(check_defined, lbl_pat_list);
  if (!(closed === /* Closed */0 && is_active({
            TAG: /* Non_closed_record_pattern */4,
            _0: ""
          }))) {
    return ;
  }
  let $$undefined = /* [] */0;
  for(let i = 0 ,i_finish = all.length; i < i_finish; ++i){
    if (!Caml_array.get(defined, i)) {
      $$undefined = {
        hd: Caml_array.get(all, i).lbl_name,
        tl: $$undefined
      };
    }
    
  }
  if (!Caml_obj.caml_notequal($$undefined, /* [] */0)) {
    return ;
  }
  const u = Stdlib__String.concat(", ", Stdlib__List.rev($$undefined));
  prerr_warning(loc, {
        TAG: /* Non_closed_record_pattern */4,
        _0: u
      });
}

const type_kind$1 = "variant";

function get_type_path$2(env, d) {
  const match = d.cstr_res.desc;
  if (typeof match === "number") {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                42965,
                11
              ]
            });
  }
  if (match.TAG === /* Tconstr */3) {
    return match._0;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              42965,
              11
            ]
          });
}

function lookup_from_type$1(env, tpath, lid) {
  const descrs = find_type_full(tpath, env)[1][0];
  mark_type_used(env, last(tpath), find_type_full(tpath, env)[0]);
  const s = lid.txt;
  switch (s.TAG | 0) {
    case /* Lident */0 :
        const s$1 = s._0;
        try {
          return Stdlib__List.find((function (nd) {
                        return nd.cstr_name === s$1;
                      }), descrs);
        }
        catch (raw_exn){
          const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.MEL_EXN_ID === Stdlib.Not_found) {
            throw new Caml_js_exceptions.MelangeError($$Error$7, {
                      MEL_EXN_ID: $$Error$7,
                      _1: lid.loc,
                      _2: env,
                      _3: {
                        TAG: /* Wrong_name */13,
                        _0: "",
                        _1: newvar(undefined, undefined),
                        _2: type_kind$1,
                        _3: tpath,
                        _4: lid.txt
                      }
                    });
          }
          throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
        }
    case /* Ldot */1 :
    case /* Lapply */2 :
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                  MEL_EXN_ID: Stdlib.Not_found
                });
    
  }
}

function unique$1(eq, _acc, _param) {
  while(true) {
    const param = _param;
    const acc = _acc;
    if (!param) {
      return Stdlib__List.rev(acc);
    }
    const rem = param.tl;
    const x = param.hd;
    if (Stdlib__List.exists(Curry._1(eq, x), acc)) {
      _param = rem;
      continue ;
    }
    _param = rem;
    _acc = {
      hd: x,
      tl: acc
    };
    continue ;
  };
}

function ambiguous_types$1(env, lbl, others) {
  const tpath = get_type_path$2(env, lbl);
  const others$1 = Stdlib__List.map((function (param) {
          return get_type_path$2(env, param[0]);
        }), others);
  const tpaths = unique$1((function (param, param$1) {
          return compare_type_path(env, param, param$1);
        }), {
        hd: tpath,
        tl: /* [] */0
      }, others$1);
  if (tpaths && !tpaths.tl) {
    return /* [] */0;
  } else {
    return Stdlib__List.map(string_of_path, tpaths);
  }
}

function disambiguate_by_type$1(env, tpath, lbls) {
  const check_type = function (param) {
    const lbl_tpath = get_type_path$2(env, param[0]);
    return compare_type_path(env, tpath, lbl_tpath);
  };
  return Stdlib__List.find(check_type, lbls);
}

function disambiguate$1(warnOpt, check_lkOpt, scope, lid, env, opath, lbls) {
  const warn = warnOpt !== undefined ? warnOpt : prerr_warning;
  const check_lk = check_lkOpt !== undefined ? check_lkOpt : (function (param, param$1) {
        
      });
  const scope$1 = scope !== undefined ? scope : lbls;
  let lbl;
  if (opath !== undefined) {
    const pr = opath[2];
    const tpath = opath[1];
    const warn_pr = function (param) {
      const kind = type_kind$1 === "record" ? "field" : "constructor";
      Curry._2(warn, lid.loc, {
            TAG: /* Not_principal */8,
            _0: "this type-based " + (kind + " disambiguation")
          });
    };
    try {
      const match = disambiguate_by_type$1(env, tpath, scope$1);
      const lbl$1 = match[0];
      Curry._1(match[1], undefined);
      if (!pr) {
        if (lbls) {
          const lbl_tpath = get_type_path$2(env, lbls.hd[0]);
          if (compare_type_path(env, tpath, lbl_tpath)) {
            const paths = ambiguous_types$1(env, lbl$1, lbls.tl);
            if (Caml_obj.caml_notequal(paths, /* [] */0)) {
              Curry._2(warn, lid.loc, {
                    TAG: /* Ambiguous_name */24,
                    _0: {
                      hd: last$1(lid.txt),
                      tl: /* [] */0
                    },
                    _1: paths,
                    _2: false
                  });
            }
            
          } else {
            warn_pr(undefined);
          }
        } else {
          warn_pr(undefined);
        }
      }
      lbl = lbl$1;
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        try {
          const lbl$2 = lookup_from_type$1(env, tpath, lid);
          Curry._2(check_lk, tpath, lbl$2);
          const s = string_of_out_ident(tree_of_path(tpath));
          Curry._2(warn, lid.loc, {
                TAG: /* Name_out_of_scope */23,
                _0: s,
                _1: {
                  hd: last$1(lid.txt),
                  tl: /* [] */0
                },
                _2: false
              });
          if (!pr) {
            warn_pr(undefined);
          }
          lbl = lbl$2;
        }
        catch (raw_exn$1){
          const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
          if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
            if (Caml_obj.caml_equal(lbls, /* [] */0)) {
              lbl = unbound_constructor_error(env, lid);
            } else {
              const tp_0 = opath[0];
              const tp_1 = expand_path(env, tpath);
              const tp = [
                tp_0,
                tp_1
              ];
              const tpl = Stdlib__List.map((function (param) {
                      const tp0 = get_type_path$2(env, param[0]);
                      const tp = expand_path(env, tp0);
                      return [
                              tp0,
                              tp
                            ];
                    }), lbls);
              throw new Caml_js_exceptions.MelangeError($$Error$7, {
                        MEL_EXN_ID: $$Error$7,
                        _1: lid.loc,
                        _2: env,
                        _3: {
                          TAG: /* Name_type_mismatch */14,
                          _0: type_kind$1,
                          _1: lid.txt,
                          _2: tp,
                          _3: tpl
                        }
                      });
            }
          } else {
            throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
          }
        }
      } else {
        throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
      }
    }
  } else if (lbls) {
    const match$1 = lbls.hd;
    const lbl$3 = match$1[0];
    Curry._1(match$1[1], undefined);
    const paths$1 = ambiguous_types$1(env, lbl$3, lbls.tl);
    if (Caml_obj.caml_notequal(paths$1, /* [] */0)) {
      Curry._2(warn, lid.loc, {
            TAG: /* Ambiguous_name */24,
            _0: {
              hd: last$1(lid.txt),
              tl: /* [] */0
            },
            _1: paths$1,
            _2: false
          });
    }
    lbl = lbl$3;
  } else {
    lbl = unbound_constructor_error(env, lid);
  }
  if (scope$1 && scope$1.hd[0] === lbl) {
    
  } else {
    prerr_warning(lid.loc, {
          TAG: /* Disambiguated_name */25,
          _0: lbl.cstr_name
        });
  }
  return lbl;
}

function unify_head_only(loc, env, ty, constr) {
  const match = instance_constructor(undefined, constr);
  const ty_res = match[1];
  const match$1 = repr(ty_res).desc;
  if (typeof match$1 === "number") {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                43255,
                9
              ]
            });
  }
  if (match$1.TAG === /* Tconstr */3) {
    ty_res.desc = {
      TAG: /* Tconstr */3,
      _0: match$1._0,
      _1: Stdlib__List.map((function (param) {
              return newvar(undefined, undefined);
            }), match$1._1),
      _2: match$1._2
    };
    enforce_constraints(env, ty_res);
    return unify_pat_types(loc, env, ty_res, ty);
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              43255,
              9
            ]
          });
}

function type_pat(constrs, labels, no_existentials, mode, env, sp, expected_ty) {
  const type_pat$1 = function (modeOpt, envOpt) {
    const mode$1 = modeOpt !== undefined ? modeOpt : mode;
    const env$1 = envOpt !== undefined ? envOpt : env;
    return function (param, param$1) {
      return type_pat(constrs, labels, no_existentials, mode$1, env$1, param, param$1);
    };
  };
  const loc = sp.ppat_loc;
  const name = sp.ppat_desc;
  if (typeof name === "number") {
    return rp({
                pat_desc: /* Tpat_any */0,
                pat_loc: loc,
                pat_extra: /* [] */0,
                pat_type: expected_ty,
                pat_env: env.contents,
                pat_attributes: sp.ppat_attributes
              });
  }
  switch (name.TAG | 0) {
    case /* Ppat_var */0 :
        const name$1 = name._0;
        const id = enter_variable(undefined, undefined, loc, name$1, expected_ty);
        return rp({
                    pat_desc: {
                      TAG: /* Tpat_var */0,
                      _0: id,
                      _1: name$1
                    },
                    pat_loc: loc,
                    pat_extra: /* [] */0,
                    pat_type: expected_ty,
                    pat_env: env.contents,
                    pat_attributes: sp.ppat_attributes
                  });
    case /* Ppat_alias */1 :
        const name$2 = name._1;
        const q = type_pat$1(undefined, undefined)(name._0, expected_ty);
        begin_def(undefined);
        const ty_var = build_as_type(env.contents, q);
        end_def(undefined);
        iter_generalize$1({
              contents: /* [] */0
            }, ty_var);
        const id$1 = enter_variable(undefined, true, loc, name$2, ty_var);
        return rp({
                    pat_desc: {
                      TAG: /* Tpat_alias */1,
                      _0: q,
                      _1: id$1,
                      _2: name$2
                    },
                    pat_loc: loc,
                    pat_extra: /* [] */0,
                    pat_type: q.pat_type,
                    pat_env: env.contents,
                    pat_attributes: sp.ppat_attributes
                  });
    case /* Ppat_constant */2 :
        const cst = name._0;
        unify_pat_types(loc, env.contents, type_constant(cst), expected_ty);
        return rp({
                    pat_desc: {
                      TAG: /* Tpat_constant */2,
                      _0: cst
                    },
                    pat_loc: loc,
                    pat_extra: /* [] */0,
                    pat_type: expected_ty,
                    pat_env: env.contents,
                    pat_attributes: sp.ppat_attributes
                  });
    case /* Ppat_interval */3 :
        const c1 = name._0;
        if (c1.TAG === /* Const_char */1) {
          const c2 = name._1;
          if (c2.TAG === /* Const_char */1) {
            const c2$1 = c2._0;
            const c1$1 = c1._0;
            const gloc_loc_start = loc.loc_start;
            const gloc_loc_end = loc.loc_end;
            const gloc = {
              loc_start: gloc_loc_start,
              loc_end: gloc_loc_end,
              loc_ghost: true
            };
            const loop = function (c1, c2) {
              if (c1 === c2) {
                return constant(gloc, undefined, {
                            TAG: /* Const_char */1,
                            _0: c1
                          });
              } else {
                return or_(gloc, undefined, constant(gloc, undefined, {
                                TAG: /* Const_char */1,
                                _0: c1
                              }), loop(Stdlib__Char.chr(c1 + 1 | 0), c2));
              }
            };
            const p = c1$1 <= c2$1 ? loop(c1$1, c2$1) : loop(c2$1, c1$1);
            const p_ppat_desc = p.ppat_desc;
            const p_ppat_attributes = p.ppat_attributes;
            const p$1 = {
              ppat_desc: p_ppat_desc,
              ppat_loc: loc,
              ppat_attributes: p_ppat_attributes
            };
            return type_pat$1(undefined, undefined)(p$1, expected_ty);
          }
          throw new Caml_js_exceptions.MelangeError($$Error$7, {
                    MEL_EXN_ID: $$Error$7,
                    _1: loc,
                    _2: env.contents,
                    _3: /* Invalid_interval */5
                  });
        }
        throw new Caml_js_exceptions.MelangeError($$Error$7, {
                  MEL_EXN_ID: $$Error$7,
                  _1: loc,
                  _2: env.contents,
                  _3: /* Invalid_interval */5
                });
    case /* Ppat_tuple */4 :
        const spl = name._0;
        if (Stdlib__List.length(spl) < 2) {
          ill_formed_ast(loc, "Tuples must have at least 2 components.");
        }
        const spl_ann = Stdlib__List.map((function (p) {
                return [
                        p,
                        newvar(undefined, undefined)
                      ];
              }), spl);
        const desc = {
          TAG: /* Ttuple */2,
          _0: Stdlib__List.map((function (prim) {
                  return prim[1];
                }), spl_ann)
        };
        const ty = newty2(current_level.contents, desc);
        unify_pat_types(loc, env.contents, ty, expected_ty);
        const pl = Stdlib__List.map((function (param) {
                return type_pat$1(undefined, undefined)(param[0], param[1]);
              }), spl_ann);
        return rp({
                    pat_desc: {
                      TAG: /* Tpat_tuple */3,
                      _0: pl
                    },
                    pat_loc: loc,
                    pat_extra: /* [] */0,
                    pat_type: expected_ty,
                    pat_env: env.contents,
                    pat_attributes: sp.ppat_attributes
                  });
    case /* Ppat_construct */5 :
        const sarg = name._1;
        const lid = name._0;
        let opath;
        try {
          const match = extract_concrete_variant(env.contents, expected_ty);
          opath = [
            match[0],
            match[1],
            true
          ];
        }
        catch (raw_exn){
          const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.MEL_EXN_ID === Stdlib.Not_found) {
            opath = undefined;
          } else {
            throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
          }
        }
        const match$1 = lid.txt;
        let constrs$1;
        let exit = 0;
        switch (match$1.TAG | 0) {
          case /* Lident */0 :
              if (constrs !== undefined) {
                const constrs$2 = Caml_option.valFromOption(constrs);
                const s = match$1._0;
                if (Stdlib__Hashtbl.mem(constrs$2, s)) {
                  constrs$1 = {
                    hd: [
                      Stdlib__Hashtbl.find(constrs$2, s),
                      (function (param) {
                          
                        })
                    ],
                    tl: /* [] */0
                  };
                } else {
                  exit = 1;
                }
              } else {
                exit = 1;
              }
              break;
          case /* Ldot */1 :
          case /* Lapply */2 :
              exit = 1;
              break;
          
        }
        if (exit === 1) {
          constrs$1 = find_all_constructors(env.contents, lid.loc, lid.txt);
        }
        const check_lk = function (tpath, constr) {
          if (!constr.cstr_generalized) {
            return ;
          }
          throw new Caml_js_exceptions.MelangeError($$Error$7, {
                    MEL_EXN_ID: $$Error$7,
                    _1: lid.loc,
                    _2: env.contents,
                    _3: {
                      TAG: /* Unqualified_gadt_pattern */34,
                      _0: tpath,
                      _1: constr.cstr_name
                    }
                  });
        };
        const partial_arg = env.contents;
        const partial_arg$1 = check_lk;
        const constr = wrap_disambiguate("This variant pattern is expected to have", expected_ty, (function (param) {
                return disambiguate$1(undefined, partial_arg$1, undefined, lid, partial_arg, opath, param);
              }), constrs$1);
        mark_constructor(/* Pattern */1, env.contents, last$1(lid.txt), constr);
        check_deprecated(loc, constr.cstr_attributes, constr.cstr_name);
        if (no_existentials && Caml_obj.caml_notequal(constr.cstr_existentials, /* [] */0)) {
          throw new Caml_js_exceptions.MelangeError($$Error$7, {
                    MEL_EXN_ID: $$Error$7,
                    _1: loc,
                    _2: env.contents,
                    _3: /* Unexpected_existential */4
                  });
        }
        if (constr.cstr_generalized) {
          unify_head_only(loc, env.contents, expected_ty, constr);
        }
        let sargs;
        if (sarg !== undefined) {
          const spl$1 = sarg.ppat_desc;
          if (typeof spl$1 === "number") {
            if (constr.cstr_arity !== 1) {
              if (constr.cstr_arity === 0) {
                prerr_warning(sarg.ppat_loc, /* Wildcard_arg_to_constant_constr */13);
              }
              sargs = replicate_list(sarg, constr.cstr_arity);
            } else {
              sargs = {
                hd: sarg,
                tl: /* [] */0
              };
            }
          } else {
            sargs = spl$1.TAG === /* Ppat_tuple */4 && (constr.cstr_arity > 1 || explicit_arity(sp.ppat_attributes)) ? spl$1._0 : ({
                  hd: sarg,
                  tl: /* [] */0
                });
          }
        } else {
          sargs = /* [] */0;
        }
        if (Stdlib__List.length(sargs) !== constr.cstr_arity) {
          throw new Caml_js_exceptions.MelangeError($$Error$7, {
                    MEL_EXN_ID: $$Error$7,
                    _1: loc,
                    _2: env.contents,
                    _3: {
                      TAG: /* Constructor_arity_mismatch */1,
                      _0: lid.txt,
                      _1: constr.cstr_arity,
                      _2: Stdlib__List.length(sargs)
                    }
                  });
        }
        const match$2 = instance_constructor([
              env,
              get_newtype_level$1(undefined)
            ], constr);
        const ty_res = match$2[1];
        if (constr.cstr_generalized && mode === /* Normal */0) {
          unify_pat_types_gadt(loc, env, ty_res, expected_ty);
        } else {
          unify_pat_types(loc, env.contents, ty_res, expected_ty);
        }
        const args = Stdlib__List.map2((function (p, t) {
                return type_pat$1(undefined, undefined)(p, t);
              }), sargs, match$2[0]);
        return rp({
                    pat_desc: {
                      TAG: /* Tpat_construct */4,
                      _0: lid,
                      _1: constr,
                      _2: args
                    },
                    pat_loc: loc,
                    pat_extra: /* [] */0,
                    pat_type: expected_ty,
                    pat_env: env.contents,
                    pat_attributes: sp.ppat_attributes
                  });
    case /* Ppat_variant */6 :
        const sarg$1 = name._1;
        const l = name._0;
        const arg_type = sarg$1 !== undefined ? ({
              hd: newvar(undefined, undefined),
              tl: /* [] */0
            }) : /* [] */0;
        const row_row_fields = {
          hd: [
            l,
            {
              TAG: /* Reither */1,
              _0: sarg$1 === undefined,
              _1: arg_type,
              _2: true,
              _3: {
                contents: undefined
              }
            }
          ],
          tl: /* [] */0
        };
        const row_row_more = newvar(undefined, undefined);
        const row = {
          row_fields: row_row_fields,
          row_more: row_row_more,
          row_bound: undefined,
          row_closed: false,
          row_fixed: false,
          row_name: undefined
        };
        unify_pat_types(loc, env.contents, newty2(current_level.contents, {
                  TAG: /* Tvariant */8,
                  _0: row
                }), expected_ty);
        const arg = sarg$1 !== undefined && arg_type && !arg_type.tl ? type_pat$1(undefined, undefined)(sarg$1, arg_type.hd) : undefined;
        return rp({
                    pat_desc: {
                      TAG: /* Tpat_variant */5,
                      _0: l,
                      _1: arg,
                      _2: {
                        contents: {
                          row_fields: row_row_fields,
                          row_more: newvar(undefined, undefined),
                          row_bound: undefined,
                          row_closed: false,
                          row_fixed: false,
                          row_name: undefined
                        }
                      }
                    },
                    pat_loc: loc,
                    pat_extra: /* [] */0,
                    pat_type: expected_ty,
                    pat_env: env.contents,
                    pat_attributes: sp.ppat_attributes
                  });
    case /* Ppat_record */7 :
        const closed = name._1;
        const lid_sp_list = name._0;
        if (Caml_obj.caml_equal(lid_sp_list, /* [] */0)) {
          ill_formed_ast(loc, "Records cannot be empty.");
        }
        let match$3;
        try {
          const match$4 = extract_concrete_record(env.contents, expected_ty);
          match$3 = [
            [
              match$4[0],
              match$4[1],
              true
            ],
            expected_ty
          ];
        }
        catch (raw_exn$1){
          const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
          if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
            match$3 = [
              undefined,
              newvar(undefined, undefined)
            ];
          } else {
            throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
          }
        }
        const record_ty = match$3[1];
        const opath$1 = match$3[0];
        const type_label_pat = function (param) {
          const label = param[1];
          const label_lid = param[0];
          begin_def(undefined);
          const match = instance_label(false, label);
          const ty_arg = match[1];
          const vars = match[0];
          if (Caml_obj.caml_equal(vars, /* [] */0)) {
            end_def(undefined);
          }
          try {
            unify_pat_types(loc, env.contents, match[2], record_ty);
          }
          catch (raw_trace){
            const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
            if (trace.MEL_EXN_ID === Unify) {
              throw new Caml_js_exceptions.MelangeError($$Error$7, {
                        MEL_EXN_ID: $$Error$7,
                        _1: label_lid.loc,
                        _2: env.contents,
                        _3: {
                          TAG: /* Label_mismatch */2,
                          _0: label_lid.txt,
                          _1: trace._1
                        }
                      });
            }
            throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
          }
          const arg = type_pat$1(undefined, undefined)(param[2], ty_arg);
          if (Caml_obj.caml_notequal(vars, /* [] */0)) {
            end_def(undefined);
            iter_generalize$1({
                  contents: /* [] */0
                }, ty_arg);
            Stdlib__List.iter(generalize, vars);
            const instantiated = function (tv) {
              const tv$1 = expand_head(env.contents, tv);
              if (is_Tvar(tv$1)) {
                return tv$1.level !== 100000000;
              } else {
                return true;
              }
            };
            if (Stdlib__List.exists(instantiated, vars)) {
              throw new Caml_js_exceptions.MelangeError($$Error$7, {
                        MEL_EXN_ID: $$Error$7,
                        _1: label_lid.loc,
                        _2: env.contents,
                        _3: {
                          TAG: /* Polymorphic_label */0,
                          _0: label_lid.txt
                        }
                      });
            }
            
          }
          return [
                  label_lid,
                  label,
                  arg
                ];
        };
        const partial_arg$2 = env.contents;
        const lbl_pat_list = wrap_disambiguate("This record pattern is expected to have", expected_ty, (function (param) {
                return type_label_a_list(labels, loc, false, partial_arg$2, type_label_pat, opath$1, param);
              }), lid_sp_list);
        check_recordpat_labels(loc, lbl_pat_list, closed);
        unify_pat_types(loc, env.contents, record_ty, expected_ty);
        return rp({
                    pat_desc: {
                      TAG: /* Tpat_record */6,
                      _0: lbl_pat_list,
                      _1: closed
                    },
                    pat_loc: loc,
                    pat_extra: /* [] */0,
                    pat_type: expected_ty,
                    pat_env: env.contents,
                    pat_attributes: sp.ppat_attributes
                  });
    case /* Ppat_array */8 :
        const ty_elt = newvar(undefined, undefined);
        unify_pat_types(loc, env.contents, instance_def(type_array(ty_elt)), expected_ty);
        const spl_ann$1 = Stdlib__List.map((function (p) {
                return [
                        p,
                        newvar(undefined, undefined)
                      ];
              }), name._0);
        const pl$1 = Stdlib__List.map((function (param) {
                return type_pat$1(undefined, undefined)(param[0], ty_elt);
              }), spl_ann$1);
        return rp({
                    pat_desc: {
                      TAG: /* Tpat_array */7,
                      _0: pl$1
                    },
                    pat_loc: loc,
                    pat_extra: /* [] */0,
                    pat_type: expected_ty,
                    pat_env: env.contents,
                    pat_attributes: sp.ppat_attributes
                  });
    case /* Ppat_or */9 :
        const initial_pattern_variables = pattern_variables.contents;
        const p1 = type_pat$1(/* Inside_or */1, undefined)(name._0, expected_ty);
        const p1_variables = pattern_variables.contents;
        pattern_variables.contents = initial_pattern_variables;
        const p2 = type_pat$1(/* Inside_or */1, undefined)(name._1, expected_ty);
        const p2_variables = pattern_variables.contents;
        const alpha_env = enter_orpat_variables(loc, env.contents, p1_variables, p2_variables);
        pattern_variables.contents = p1_variables;
        return rp({
                    pat_desc: {
                      TAG: /* Tpat_or */8,
                      _0: p1,
                      _1: alpha_pat(alpha_env, p2),
                      _2: undefined
                    },
                    pat_loc: loc,
                    pat_extra: /* [] */0,
                    pat_type: expected_ty,
                    pat_env: env.contents,
                    pat_attributes: sp.ppat_attributes
                  });
    case /* Ppat_constraint */10 :
        const sp$1 = name._0;
        let exit$1 = 0;
        const name$3 = sp$1.ppat_desc;
        if (typeof name$3 === "number" || name$3.TAG !== /* Ppat_var */0) {
          exit$1 = 1;
        } else {
          const sty = name._1;
          let tmp = sty.ptyp_desc;
          if (typeof tmp === "number" || tmp.TAG !== /* Ptyp_poly */8) {
            exit$1 = 1;
          } else {
            const lloc = sp$1.ppat_loc;
            const name$4 = name$3._0;
            const match$5 = transl_simple_type_delayed(env.contents, sty);
            const cty = match$5[0];
            const ty$1 = cty.ctyp_type;
            unify_pat_types(lloc, env.contents, ty$1, expected_ty);
            pattern_force.contents = {
              hd: match$5[1],
              tl: pattern_force.contents
            };
            const match$6 = ty$1.desc;
            if (typeof match$6 === "number") {
              throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                        MEL_EXN_ID: "Assert_failure",
                        _1: [
                          "jscomp/test/ocaml_typedtree_test.ml",
                          43318,
                          13
                        ]
                      });
            }
            if (match$6.TAG === /* Tpoly */10) {
              begin_def(undefined);
              const match$7 = instance_poly(true, false, match$6._1, match$6._0);
              const ty$p = match$7[1];
              end_def(undefined);
              iter_generalize$1({
                    contents: /* [] */0
                  }, ty$p);
              const id$2 = enter_variable(undefined, undefined, lloc, name$4, ty$p);
              return rp({
                          pat_desc: {
                            TAG: /* Tpat_var */0,
                            _0: id$2,
                            _1: name$4
                          },
                          pat_loc: lloc,
                          pat_extra: {
                            hd: [
                              {
                                TAG: /* Tpat_constraint */0,
                                _0: cty
                              },
                              loc,
                              sp.ppat_attributes
                            ],
                            tl: /* [] */0
                          },
                          pat_type: ty$1,
                          pat_env: env.contents,
                          pat_attributes: /* [] */0
                        });
            }
            throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                      MEL_EXN_ID: "Assert_failure",
                      _1: [
                        "jscomp/test/ocaml_typedtree_test.ml",
                        43318,
                        13
                      ]
                    });
          }
        }
        if (exit$1 === 1) {
          begin_def(undefined);
          const match$8 = transl_simple_type_delayed(env.contents, name._1);
          const cty$1 = match$8[0];
          const ty$2 = cty$1.ctyp_type;
          end_def(undefined);
          generalize_structure$1(current_level.contents, ty$2);
          const ty$3 = instance(undefined, env.contents, ty$2);
          const expected_ty$p = instance(undefined, env.contents, ty$2);
          unify_pat_types(loc, env.contents, ty$3, expected_ty);
          const p$2 = type_pat$1(undefined, undefined)(sp$1, expected_ty$p);
          pattern_force.contents = {
            hd: match$8[1],
            tl: pattern_force.contents
          };
          const extra_0 = {
            TAG: /* Tpat_constraint */0,
            _0: cty$1
          };
          const extra_2 = sp$1.ppat_attributes;
          const extra = [
            extra_0,
            loc,
            extra_2
          ];
          const match$9 = p$2.pat_desc;
          let exit$2 = 0;
          if (typeof match$9 === "number") {
            exit$2 = 2;
          } else {
            if (match$9.TAG === /* Tpat_var */0) {
              return {
                      pat_desc: {
                        TAG: /* Tpat_alias */1,
                        _0: {
                          pat_desc: /* Tpat_any */0,
                          pat_loc: p$2.pat_loc,
                          pat_extra: p$2.pat_extra,
                          pat_type: p$2.pat_type,
                          pat_env: p$2.pat_env,
                          pat_attributes: /* [] */0
                        },
                        _1: match$9._0,
                        _2: match$9._1
                      },
                      pat_loc: p$2.pat_loc,
                      pat_extra: {
                        hd: extra,
                        tl: /* [] */0
                      },
                      pat_type: ty$3,
                      pat_env: p$2.pat_env,
                      pat_attributes: p$2.pat_attributes
                    };
            }
            exit$2 = 2;
          }
          if (exit$2 === 2) {
            return {
                    pat_desc: p$2.pat_desc,
                    pat_loc: p$2.pat_loc,
                    pat_extra: {
                      hd: extra,
                      tl: p$2.pat_extra
                    },
                    pat_type: ty$3,
                    pat_env: p$2.pat_env,
                    pat_attributes: p$2.pat_attributes
                  };
          }
          
        }
        break;
    case /* Ppat_type */11 :
        const lid$1 = name._0;
        const match$10 = build_or_pat(env.contents, loc, lid$1.txt);
        const p$3 = match$10[1];
        unify_pat_types(loc, env.contents, match$10[2], expected_ty);
        return {
                pat_desc: p$3.pat_desc,
                pat_loc: p$3.pat_loc,
                pat_extra: {
                  hd: [
                    {
                      TAG: /* Tpat_type */1,
                      _0: match$10[0],
                      _1: lid$1
                    },
                    loc,
                    sp.ppat_attributes
                  ],
                  tl: p$3.pat_extra
                },
                pat_type: p$3.pat_type,
                pat_env: p$3.pat_env,
                pat_attributes: p$3.pat_attributes
              };
    case /* Ppat_lazy */12 :
        const nv = newvar(undefined, undefined);
        unify_pat_types(loc, env.contents, instance_def(type_lazy_t(nv)), expected_ty);
        const p1$1 = type_pat$1(undefined, undefined)(name._0, nv);
        return rp({
                    pat_desc: {
                      TAG: /* Tpat_lazy */9,
                      _0: p1$1
                    },
                    pat_loc: loc,
                    pat_extra: /* [] */0,
                    pat_type: expected_ty,
                    pat_env: env.contents,
                    pat_attributes: sp.ppat_attributes
                  });
    case /* Ppat_unpack */13 :
        const name$5 = name._0;
        const id$3 = enter_variable(true, undefined, loc, name$5, expected_ty);
        return rp({
                    pat_desc: {
                      TAG: /* Tpat_var */0,
                      _0: id$3,
                      _1: name$5
                    },
                    pat_loc: sp.ppat_loc,
                    pat_extra: {
                      hd: [
                        /* Tpat_unpack */0,
                        loc,
                        sp.ppat_attributes
                      ],
                      tl: /* [] */0
                    },
                    pat_type: expected_ty,
                    pat_env: env.contents,
                    pat_attributes: /* [] */0
                  });
    case /* Ppat_exception */14 :
        throw new Caml_js_exceptions.MelangeError($$Error$7, {
                  MEL_EXN_ID: $$Error$7,
                  _1: loc,
                  _2: env.contents,
                  _3: /* Exception_pattern_below_toplevel */8
                });
    case /* Ppat_extension */15 :
        throw new Caml_js_exceptions.MelangeError(Error_forward$1, {
                  MEL_EXN_ID: Error_forward$1,
                  _1: error_of_extension(name._0)
                });
    
  }
}

function type_pat$1(allow_existentialsOpt, constrs, labels, levOpt, env, sp, expected_ty) {
  const allow_existentials = allow_existentialsOpt !== undefined ? allow_existentialsOpt : false;
  const lev = levOpt !== undefined ? levOpt : current_level.contents;
  newtype_level$1.contents = lev;
  try {
    const r = type_pat(constrs, labels, !allow_existentials, /* Normal */0, env, sp, expected_ty);
    iter_pattern((function (p) {
            p.pat_env = env.contents;
          }), r);
    newtype_level$1.contents = undefined;
    return r;
  }
  catch (e){
    newtype_level$1.contents = undefined;
    throw new Caml_js_exceptions.MelangeError(e.MEL_EXN_ID, e);
  }
}

function partial_pred(lev, env, expected_ty, constrs, labels, p) {
  const snap = snapshot(undefined);
  try {
    reset_pattern(undefined, true);
    const typed_p = type_pat$1(true, Caml_option.some(constrs), Caml_option.some(labels), lev, {
          contents: env
        }, p, expected_ty);
    backtrack(snap);
    return typed_p;
  }
  catch (exn){
    backtrack(snap);
    return ;
  }
}

function check_partial$1(levOpt, env, expected_ty) {
  const lev = levOpt !== undefined ? levOpt : current_level.contents;
  return function (param, param$1) {
    const pred = function (param, param$1, param$2) {
      return partial_pred(lev, env, expected_ty, param, param$1, param$2);
    };
    const first_check = check_partial(param, param$1);
    if (first_check) {
      return check_partial_param((function (param, param$1, param$2) {
                    return do_check_partial(pred, exhaust_gadt$1, param, param$1, param$2);
                  }), do_check_fragile_gadt, param, param$1);
    } else {
      return /* Partial */0;
    }
  };
}

function add_pattern_variables(check, check_as, env) {
  const pv = get_ref(pattern_variables);
  return [
          Stdlib__List.fold_right((function (param, env) {
                  const check$1 = param[4] ? check_as : check;
                  return add_value(check$1, param[0], {
                              val_type: param[1],
                              val_kind: /* Val_reg */0,
                              val_loc: param[3],
                              val_attributes: /* [] */0
                            }, env);
                }), pv, env),
          get_ref(module_variables)
        ];
}

function type_pattern(lev, env, spat, scope, expected_ty) {
  reset_pattern(scope, true);
  const new_env = {
    contents: env
  };
  const pat = type_pat$1(true, undefined, undefined, lev, new_env, spat, expected_ty);
  const match = add_pattern_variables((function (s) {
          return {
                  TAG: /* Unused_var_strict */13,
                  _0: s
                };
        }), (function (s) {
          return {
                  TAG: /* Unused_var */12,
                  _0: s
                };
        }), new_env.contents);
  return [
          pat,
          match[0],
          get_ref(pattern_force),
          match[1]
        ];
}

function type_pattern_list(env, spatl, scope, expected_tys, allow) {
  reset_pattern(scope, allow);
  const new_env = {
    contents: env
  };
  const patl = Stdlib__List.map2((function (param, param$1) {
          return type_pat$1(undefined, undefined, undefined, undefined, new_env, param, param$1);
        }), spatl, expected_tys);
  const match = add_pattern_variables(undefined, undefined, new_env.contents);
  return [
          patl,
          match[0],
          get_ref(pattern_force),
          match[1]
        ];
}

function type_class_arg_pattern(cl_num, val_env, met_env, l, spat) {
  reset_pattern(undefined, false);
  const nv = newvar(undefined, undefined);
  const pat = type_pat$1(undefined, undefined, undefined, undefined, {
        contents: val_env
      }, spat, nv);
  if (has_variants(pat)) {
    pressure_variants$1(val_env, {
          hd: pat,
          tl: /* [] */0
        });
    iter_pattern(finalize_variant, pat);
  }
  Stdlib__List.iter((function (f) {
          Curry._1(f, undefined);
        }), get_ref(pattern_force));
  if (is_optional(l)) {
    unify_pat(val_env, pat, type_option$1(newvar(undefined, undefined)));
  }
  const match = Stdlib__List.fold_right((function (param, param$1) {
          const as_var = param[4];
          const ty = param[1];
          const id = param[0];
          const check = function (s) {
            if (as_var) {
              return {
                      TAG: /* Unused_var */12,
                      _0: s
                    };
            } else {
              return {
                      TAG: /* Unused_var_strict */13,
                      _0: s
                    };
            }
          };
          const id$p = create(id.name);
          return [
                  {
                    hd: [
                      id$p,
                      param[2],
                      id,
                      ty
                    ],
                    tl: param$1[0]
                  },
                  add_value(check, id$p, {
                        val_type: ty,
                        val_kind: {
                          TAG: /* Val_ivar */1,
                          _0: /* Immutable */0,
                          _1: cl_num
                        },
                        val_loc: param[3],
                        val_attributes: /* [] */0
                      }, param$1[1])
                ];
        }), pattern_variables.contents, [
        /* [] */0,
        met_env
      ]);
  const match$1 = add_pattern_variables(undefined, undefined, val_env);
  return [
          pat,
          match[0],
          match$1[0],
          match[1]
        ];
}

function type_self_pattern(cl_num, privty, val_env, met_env, par_env, spat) {
  const spat$1 = mk$1(undefined, undefined, {
        TAG: /* Ppat_alias */1,
        _0: mk$1(undefined, undefined, {
              TAG: /* Ppat_alias */1,
              _0: spat,
              _1: {
                txt: "selfpat-*",
                loc: none
              }
            }),
        _1: {
          txt: "selfpat-" + cl_num,
          loc: none
        }
      });
  reset_pattern(undefined, false);
  const nv = newvar(undefined, undefined);
  const pat = type_pat$1(undefined, undefined, undefined, undefined, {
        contents: val_env
      }, spat$1, nv);
  Stdlib__List.iter((function (f) {
          Curry._1(f, undefined);
        }), get_ref(pattern_force));
  const meths = {
    contents: /* Empty */0
  };
  const vars = {
    contents: Meths.empty
  };
  const pv = pattern_variables.contents;
  pattern_variables.contents = /* [] */0;
  const match = Stdlib__List.fold_right((function (param, param$1) {
          const as_var = param[4];
          const loc = param[3];
          const ty = param[1];
          const id = param[0];
          return [
                  add_value(undefined, id, {
                        val_type: ty,
                        val_kind: /* Val_unbound */1,
                        val_loc: loc,
                        val_attributes: /* [] */0
                      }, param$1[0]),
                  add_value((function (s) {
                          if (as_var) {
                            return {
                                    TAG: /* Unused_var */12,
                                    _0: s
                                  };
                          } else {
                            return {
                                    TAG: /* Unused_var_strict */13,
                                    _0: s
                                  };
                          }
                        }), id, {
                        val_type: ty,
                        val_kind: {
                          TAG: /* Val_self */2,
                          _0: meths,
                          _1: vars,
                          _2: cl_num,
                          _3: privty
                        },
                        val_loc: loc,
                        val_attributes: /* [] */0
                      }, param$1[1]),
                  add_value(undefined, id, {
                        val_type: ty,
                        val_kind: /* Val_unbound */1,
                        val_loc: loc,
                        val_attributes: /* [] */0
                      }, param$1[2])
                ];
        }), pv, [
        val_env,
        met_env,
        par_env
      ]);
  return [
          pat,
          meths,
          vars,
          match[0],
          match[1],
          match[2]
        ];
}

const delayed_checks = {
  contents: /* [] */0
};

function add_delayed_check(f) {
  delayed_checks.contents = {
    hd: [
      f,
      current.contents
    ],
    tl: delayed_checks.contents
  };
}

function force_delayed_checks(param) {
  const snap = snapshot(undefined);
  const w_old = current.contents;
  Stdlib__List.iter((function (param) {
          current.contents = param[1];
          Curry._1(param[0], undefined);
        }), Stdlib__List.rev(delayed_checks.contents));
  current.contents = w_old;
  delayed_checks.contents = /* [] */0;
  backtrack(snap);
}

function final_subexpression(_sexp) {
  while(true) {
    const sexp = _sexp;
    const match = sexp.pexp_desc;
    switch (match.TAG | 0) {
      case /* Pexp_let */2 :
          _sexp = match._2;
          continue ;
      case /* Pexp_match */6 :
          const match$1 = match._1;
          if (!match$1) {
            return sexp;
          }
          _sexp = match$1.hd.pc_rhs;
          continue ;
      case /* Pexp_try */7 :
          _sexp = match._0;
          continue ;
      case /* Pexp_ifthenelse */15 :
      case /* Pexp_sequence */16 :
          _sexp = match._1;
          continue ;
      default:
        return sexp;
    }
  };
}

function is_nonexpansive(_exp) {
  while(true) {
    const exp = _exp;
    const el = exp.exp_desc;
    switch (el.TAG | 0) {
      case /* Texp_let */2 :
          if (!Stdlib__List.for_all((function (vb) {
                    return is_nonexpansive(vb.vb_expr);
                  }), el._1)) {
            return false;
          }
          _exp = el._2;
          continue ;
      case /* Texp_ident */0 :
      case /* Texp_constant */1 :
      case /* Texp_function */3 :
          return true;
      case /* Texp_apply */4 :
          const match = el._1;
          if (match && !(match.hd[1] !== undefined || !is_nonexpansive(el._0))) {
            return Stdlib__List.for_all(is_nonexpansive_opt, Stdlib__List.map(snd3, match.tl));
          } else {
            return false;
          }
      case /* Texp_match */5 :
          if (el._2 || !is_nonexpansive(el._0)) {
            return false;
          } else {
            return Stdlib__List.for_all((function (param) {
                          if (is_nonexpansive_opt(param.c_guard)) {
                            return is_nonexpansive(param.c_rhs);
                          } else {
                            return false;
                          }
                        }), el._1);
          }
      case /* Texp_tuple */7 :
          return Stdlib__List.for_all(is_nonexpansive, el._0);
      case /* Texp_construct */8 :
          return Stdlib__List.for_all(is_nonexpansive, el._2);
      case /* Texp_variant */9 :
          return is_nonexpansive_opt(el._1);
      case /* Texp_record */10 :
          if (Stdlib__List.for_all((function (param) {
                    return param[1].lbl_mut === /* Immutable */0 ? is_nonexpansive(param[2]) : false;
                  }), el._0)) {
            return is_nonexpansive_opt(el._1);
          } else {
            return false;
          }
      case /* Texp_array */13 :
          if (el._0) {
            return false;
          } else {
            return true;
          }
      case /* Texp_ifthenelse */14 :
          if (is_nonexpansive(el._1)) {
            return is_nonexpansive_opt(el._2);
          } else {
            return false;
          }
      case /* Texp_sequence */15 :
          _exp = el._1;
          continue ;
      case /* Texp_new */19 :
          return class_type_arity(el._2.cty_type) > 0;
      case /* Texp_letmodule */23 :
          if (!is_nonexpansive_mod(el._2)) {
            return false;
          }
          _exp = el._3;
          continue ;
      case /* Texp_field */11 :
      case /* Texp_lazy */25 :
          _exp = el._0;
          continue ;
      case /* Texp_object */26 :
          const match$1 = el._0;
          const count = {
            contents: 0
          };
          if (Stdlib__List.for_all((function (field) {
                    const e = field.cf_desc;
                    switch (e.TAG | 0) {
                      case /* Tcf_inherit */0 :
                          return false;
                      case /* Tcf_val */1 :
                          const match = e._3;
                          if (match.TAG === /* Tcfk_virtual */0) {
                            count.contents = count.contents + 1 | 0;
                            return true;
                          }
                          count.contents = count.contents + 1 | 0;
                          return is_nonexpansive(match._1);
                      case /* Tcf_initializer */4 :
                          return is_nonexpansive(e._0);
                      default:
                        return true;
                    }
                  }), match$1.cstr_fields) && Curry._3(Meths.fold, (function (param, param$1, b) {
                    count.contents = count.contents - 1 | 0;
                    return b ? param$1[0] === /* Immutable */0 : false;
                  }), match$1.cstr_type.csig_vars, true)) {
            return count.contents === 0;
          } else {
            return false;
          }
      case /* Texp_pack */27 :
          return is_nonexpansive_mod(el._0);
      default:
        return false;
    }
  };
}

function is_nonexpansive_mod(_mexp) {
  while(true) {
    const mexp = _mexp;
    const str = mexp.mod_desc;
    switch (str.TAG | 0) {
      case /* Tmod_structure */1 :
          return Stdlib__List.for_all((function (item) {
                        const id_mod_list = item.str_desc;
                        switch (id_mod_list.TAG | 0) {
                          case /* Tstr_value */1 :
                              return Stdlib__List.for_all((function (vb) {
                                            return is_nonexpansive(vb.vb_expr);
                                          }), id_mod_list._1);
                          case /* Tstr_typext */4 :
                              return Stdlib__List.for_all((function (param) {
                                            if (param.ext_kind.TAG === /* Text_decl */0) {
                                              return false;
                                            } else {
                                              return true;
                                            }
                                          }), id_mod_list._0.tyext_constructors);
                          case /* Tstr_exception */5 :
                              if (id_mod_list._0.ext_kind.TAG === /* Text_decl */0) {
                                return false;
                              } else {
                                return true;
                              }
                          case /* Tstr_module */6 :
                              return is_nonexpansive_mod(id_mod_list._0.mb_expr);
                          case /* Tstr_recmodule */7 :
                              return Stdlib__List.for_all((function (param) {
                                            return is_nonexpansive_mod(param.mb_expr);
                                          }), id_mod_list._0);
                          case /* Tstr_class */10 :
                              return false;
                          case /* Tstr_include */12 :
                              return is_nonexpansive_mod(id_mod_list._0.incl_mod);
                          case /* Tstr_attribute */13 :
                              return true;
                          default:
                            return true;
                        }
                      }), str._0.str_items);
      case /* Tmod_ident */0 :
      case /* Tmod_functor */2 :
          return true;
      case /* Tmod_apply */3 :
          return false;
      case /* Tmod_constraint */4 :
          _mexp = str._0;
          continue ;
      case /* Tmod_unpack */5 :
          return is_nonexpansive(str._0);
      
    }
  };
}

function is_nonexpansive_opt(e) {
  if (e !== undefined) {
    return is_nonexpansive(e);
  } else {
    return true;
  }
}

function approx_type(env, _sty) {
  while(true) {
    const sty = _sty;
    const args = sty.ptyp_desc;
    if (typeof args === "number") {
      return newvar(undefined, undefined);
    }
    switch (args.TAG | 0) {
      case /* Ptyp_arrow */1 :
          const p = args._0;
          const ty1 = is_optional(p) ? type_option$1(newvar(undefined, undefined)) : newvar(undefined, undefined);
          const desc_2 = approx_type(env, args._2);
          const desc = {
            TAG: /* Tarrow */1,
            _0: p,
            _1: ty1,
            _2: desc_2,
            _3: /* Cok */0
          };
          return newty2(current_level.contents, desc);
      case /* Ptyp_tuple */2 :
          const desc$1 = {
            TAG: /* Ttuple */2,
            _0: Stdlib__List.map((function (param) {
                    return approx_type(env, param);
                  }), args._0)
          };
          return newty2(current_level.contents, desc$1);
      case /* Ptyp_constr */3 :
          const ctl = args._1;
          try {
            const match = lookup_type$1(args._0.txt, env);
            if (Stdlib__List.length(ctl) !== match[1].type_arity) {
              throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                        MEL_EXN_ID: Stdlib.Not_found
                      });
            }
            const tyl = Stdlib__List.map((function (param) {
                    return approx_type(env, param);
                  }), ctl);
            return newconstr(match[0], tyl);
          }
          catch (raw_exn){
            const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.MEL_EXN_ID === Stdlib.Not_found) {
              return newvar(undefined, undefined);
            }
            throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
          }
      case /* Ptyp_poly */8 :
          _sty = args._1;
          continue ;
      default:
        return newvar(undefined, undefined);
    }
  };
}

function type_approx(env, _sexp) {
  while(true) {
    const sexp = _sexp;
    const l = sexp.pexp_desc;
    switch (l.TAG | 0) {
      case /* Pexp_let */2 :
          _sexp = l._2;
          continue ;
      case /* Pexp_function */3 :
          const match = l._0;
          if (!match) {
            return newvar(undefined, undefined);
          }
          const desc_1 = newvar(undefined, undefined);
          const desc_2 = type_approx(env, match.hd.pc_rhs);
          const desc = {
            TAG: /* Tarrow */1,
            _0: "",
            _1: desc_1,
            _2: desc_2,
            _3: /* Cok */0
          };
          return newty2(current_level.contents, desc);
      case /* Pexp_fun */4 :
          const p = l._0;
          if (is_optional(p)) {
            const desc_1$1 = type_option$1(newvar(undefined, undefined));
            const desc_2$1 = type_approx(env, l._3);
            const desc$1 = {
              TAG: /* Tarrow */1,
              _0: p,
              _1: desc_1$1,
              _2: desc_2$1,
              _3: /* Cok */0
            };
            return newty2(current_level.contents, desc$1);
          }
          const desc_1$2 = newvar(undefined, undefined);
          const desc_2$2 = type_approx(env, l._3);
          const desc$2 = {
            TAG: /* Tarrow */1,
            _0: p,
            _1: desc_1$2,
            _2: desc_2$2,
            _3: /* Cok */0
          };
          return newty2(current_level.contents, desc$2);
      case /* Pexp_match */6 :
          const match$1 = l._1;
          if (!match$1) {
            return newvar(undefined, undefined);
          }
          _sexp = match$1.hd.pc_rhs;
          continue ;
      case /* Pexp_try */7 :
          _sexp = l._0;
          continue ;
      case /* Pexp_tuple */8 :
          const desc$3 = {
            TAG: /* Ttuple */2,
            _0: Stdlib__List.map((function (param) {
                    return type_approx(env, param);
                  }), l._0)
          };
          return newty2(current_level.contents, desc$3);
      case /* Pexp_ifthenelse */15 :
      case /* Pexp_sequence */16 :
          _sexp = l._1;
          continue ;
      case /* Pexp_constraint */19 :
          const ty = type_approx(env, l._0);
          const ty1 = approx_type(env, l._1);
          try {
            unify$2(env, ty, ty1);
          }
          catch (raw_trace){
            const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
            if (trace.MEL_EXN_ID === Unify) {
              throw new Caml_js_exceptions.MelangeError($$Error$7, {
                        MEL_EXN_ID: $$Error$7,
                        _1: sexp.pexp_loc,
                        _2: env,
                        _3: {
                          TAG: /* Expr_type_clash */7,
                          _0: trace._1
                        }
                      });
            }
            throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
          }
          return ty1;
      case /* Pexp_coerce */20 :
          const approx_ty_opt = function (sty) {
            if (sty !== undefined) {
              return approx_type(env, sty);
            } else {
              return newvar(undefined, undefined);
            }
          };
          const ty$1 = type_approx(env, l._0);
          const ty1$1 = approx_ty_opt(l._1);
          const ty2 = approx_type(env, l._2);
          try {
            unify$2(env, ty$1, ty1$1);
          }
          catch (raw_trace$1){
            const trace$1 = Caml_js_exceptions.internalToOCamlException(raw_trace$1);
            if (trace$1.MEL_EXN_ID === Unify) {
              throw new Caml_js_exceptions.MelangeError($$Error$7, {
                        MEL_EXN_ID: $$Error$7,
                        _1: sexp.pexp_loc,
                        _2: env,
                        _3: {
                          TAG: /* Expr_type_clash */7,
                          _0: trace$1._1
                        }
                      });
            }
            throw new Caml_js_exceptions.MelangeError(trace$1.MEL_EXN_ID, trace$1);
          }
          return ty2;
      default:
        return newvar(undefined, undefined);
    }
  };
}

function list_labels(env, ty) {
  return wrap_trace_gadt_instances(env, (function (param) {
                let _visited = /* [] */0;
                let _ls = /* [] */0;
                let _ty_fun = param;
                while(true) {
                  const ty_fun = _ty_fun;
                  const ls = _ls;
                  const visited = _visited;
                  const ty = expand_head(env, ty_fun);
                  if (Stdlib__List.memq(ty, visited)) {
                    return [
                            Stdlib__List.rev(ls),
                            false
                          ];
                  }
                  const match = ty.desc;
                  if (typeof match === "number") {
                    return [
                            Stdlib__List.rev(ls),
                            is_Tvar(ty)
                          ];
                  }
                  if (match.TAG !== /* Tarrow */1) {
                    return [
                            Stdlib__List.rev(ls),
                            is_Tvar(ty)
                          ];
                  }
                  _ty_fun = match._2;
                  _ls = {
                    hd: match._0,
                    tl: ls
                  };
                  _visited = {
                    hd: ty,
                    tl: visited
                  };
                  continue ;
                };
              }), ty);
}

function check_univars(env, expans, kind, exp, ty_expected, vars) {
  if (expans && !is_nonexpansive(exp)) {
    generalize_expansive$1(env, exp.exp_type);
  }
  const vars$1 = Stdlib__List.map((function (param) {
          return expand_head(env, param);
        }), vars);
  const vars$2 = Stdlib__List.map((function (param) {
          return expand_head(env, param);
        }), vars$1);
  const vars$p = Stdlib__List.filter((function (t) {
          const t$1 = repr(t);
          iter_generalize$1({
                contents: /* [] */0
              }, t$1);
          const name = t$1.desc;
          if (typeof name === "number" || !(name.TAG === /* Tvar */0 && t$1.level === 100000000)) {
            return false;
          } else {
            log_type(t$1);
            t$1.desc = {
              TAG: /* Tunivar */9,
              _0: name._0
            };
            return true;
          }
        }), vars$2);
  if (Stdlib__List.length(vars$2) === Stdlib__List.length(vars$p)) {
    return ;
  }
  const ty = newty2(100000000, {
        TAG: /* Tpoly */10,
        _0: repr(exp.exp_type),
        _1: vars$p
      });
  const ty_expected$1 = repr(ty_expected);
  throw new Caml_js_exceptions.MelangeError($$Error$7, {
            MEL_EXN_ID: $$Error$7,
            _1: exp.exp_loc,
            _2: env,
            _3: {
              TAG: /* Less_general */31,
              _0: kind,
              _1: {
                hd: [
                  ty,
                  ty
                ],
                tl: {
                  hd: [
                    ty_expected$1,
                    ty_expected$1
                  ],
                  tl: /* [] */0
                }
              }
            }
          });
}

function check_application_result(env, statement, exp) {
  const loc = exp.exp_loc;
  const match = expand_head(env, exp.exp_type).desc;
  if (typeof match !== "number") {
    switch (match.TAG | 0) {
      case /* Tvar */0 :
          return ;
      case /* Tarrow */1 :
          return prerr_warning(exp.exp_loc, /* Partial_application */2);
      case /* Tconstr */3 :
          if (same(match._0, path_unit)) {
            return ;
          }
          break;
      default:
        
    }
  }
  if (statement) {
    return prerr_warning(loc, /* Statement_type */4);
  }
  
}

function generalizable(level, ty) {
  const check = function (ty) {
    const ty$1 = repr(ty);
    if (ty$1.level < 0) {
      return ;
    }
    if (ty$1.level <= level) {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                MEL_EXN_ID: Stdlib.Exit
              });
    }
    mark_type_node(ty$1);
    iter_type_expr(check, ty$1);
  };
  try {
    check(ty);
    unmark_type(ty);
    return true;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Exit) {
      unmark_type(ty);
      return false;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

const self_coercion = {
  contents: /* [] */0
};

function wrap_unpacks(sexp, unpacks) {
  return Stdlib__List.fold_left((function (sexp, param) {
                const name = param[0];
                return Curry._5(Ast_helper_Exp.letmodule, sexp.pexp_loc, undefined, name, unpack$1(param[1], undefined, Curry._3(Ast_helper_Exp.ident, name.loc, undefined, {
                                    txt: {
                                      TAG: /* Lident */0,
                                      _0: name.txt
                                    },
                                    loc: name.loc
                                  })), sexp);
              }), sexp, unpacks);
}

function contains_variant_either(ty) {
  const loop = function (ty) {
    const ty$1 = repr(ty);
    if (ty$1.level < 0) {
      return ;
    }
    mark_type_node(ty$1);
    const row = ty$1.desc;
    if (typeof row === "number") {
      return iter_type_expr(loop, ty$1);
    }
    if (row.TAG !== /* Tvariant */8) {
      return iter_type_expr(loop, ty$1);
    }
    const row$1 = row_repr_aux(/* [] */0, row._0);
    if (!row$1.row_fixed) {
      Stdlib__List.iter((function (param) {
              const match = row_field_repr_aux(/* [] */0, param[1]);
              if (typeof match === "number") {
                return ;
              }
              if (match.TAG === /* Rpresent */0) {
                return ;
              }
              throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                        MEL_EXN_ID: Stdlib.Exit
                      });
            }), row$1.row_fields);
    }
    iter_row(loop, row$1);
  };
  try {
    loop(ty);
    unmark_type(ty);
    return false;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Exit) {
      unmark_type(ty);
      return true;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function iter_ppat(f, p) {
  const pats = p.ppat_desc;
  if (typeof pats === "number") {
    return ;
  }
  switch (pats.TAG | 0) {
    case /* Ppat_construct */5 :
    case /* Ppat_variant */6 :
        return may(f, pats._1);
    case /* Ppat_record */7 :
        return Stdlib__List.iter((function (param) {
                      Curry._1(f, param[1]);
                    }), pats._0);
    case /* Ppat_tuple */4 :
    case /* Ppat_array */8 :
        return Stdlib__List.iter(f, pats._0);
    case /* Ppat_or */9 :
        Curry._1(f, pats._0);
        return Curry._1(f, pats._1);
    case /* Ppat_alias */1 :
    case /* Ppat_constraint */10 :
    case /* Ppat_lazy */12 :
    case /* Ppat_exception */14 :
        return Curry._1(f, pats._0);
    default:
      return ;
  }
}

function contains_polymorphic_variant(p) {
  const loop = function (p) {
    const match = p.ppat_desc;
    if (typeof match === "number") {
      return iter_ppat(loop, p);
    }
    switch (match.TAG | 0) {
      case /* Ppat_variant */6 :
      case /* Ppat_type */11 :
          throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                    MEL_EXN_ID: Stdlib.Exit
                  });
      default:
        return iter_ppat(loop, p);
    }
  };
  try {
    loop(p);
    return false;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Exit) {
      return true;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function contains_gadt(env, p) {
  const loop = function (p) {
    const match = p.ppat_desc;
    if (typeof match === "number") {
      return iter_ppat(loop, p);
    }
    if (match.TAG !== /* Ppat_construct */5) {
      return iter_ppat(loop, p);
    }
    try {
      const cstrs = lookup_all_constructors$1(match._0.txt, env);
      Stdlib__List.iter((function (param) {
              if (!param[0].cstr_generalized) {
                return ;
              }
              throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                        MEL_EXN_ID: Stdlib.Exit
                      });
            }), cstrs);
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID !== Stdlib.Not_found) {
        throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
      }
      
    }
    iter_ppat(loop, p);
  };
  try {
    loop(p);
    return false;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Exit) {
      return true;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function check_absent_variant(env) {
  return function (param) {
    return iter_pattern((function (pat) {
                  const match = pat.pat_desc;
                  if (typeof match === "number") {
                    return ;
                  }
                  if (match.TAG !== /* Tpat_variant */5) {
                    return ;
                  }
                  const arg = match._1;
                  const s = match._0;
                  const row = row_repr_aux(/* [] */0, match._2.contents);
                  if (Stdlib__List.exists((function (param) {
                            if (s === param[0]) {
                              return Caml_obj.caml_notequal(row_field_repr_aux(/* [] */0, param[1]), /* Rabsent */0);
                            } else {
                              return false;
                            }
                          }), row.row_fields) || !row.row_fixed && !static_row(row)) {
                    return ;
                  }
                  const ty_arg = arg !== undefined ? ({
                        hd: type_expr(identity, arg.pat_type),
                        tl: /* [] */0
                      }) : /* [] */0;
                  const row$p_row_fields = {
                    hd: [
                      s,
                      {
                        TAG: /* Reither */1,
                        _0: arg === undefined,
                        _1: ty_arg,
                        _2: true,
                        _3: {
                          contents: undefined
                        }
                      }
                    ],
                    tl: /* [] */0
                  };
                  const row$p_row_more = newvar(undefined, undefined);
                  const row$p = {
                    row_fields: row$p_row_fields,
                    row_more: row$p_row_more,
                    row_bound: undefined,
                    row_closed: false,
                    row_fixed: false,
                    row_name: undefined
                  };
                  unify_pat(env, {
                        pat_desc: pat.pat_desc,
                        pat_loc: pat.pat_loc,
                        pat_extra: pat.pat_extra,
                        pat_type: newty2(current_level.contents, {
                              TAG: /* Tvariant */8,
                              _0: row$p
                            }),
                        pat_env: pat.pat_env,
                        pat_attributes: pat.pat_attributes
                      }, type_expr(identity, pat.pat_type));
                }), param);
  };
}

function duplicate_ident_types(loc, caselist, env) {
  const caselist$1 = Stdlib__List.filter((function (param) {
          return contains_gadt(env, param.pc_lhs);
        }), caselist);
  const idents = all_idents_cases(caselist$1);
  return Stdlib__List.fold_left((function (env, s) {
                try {
                  const match = lookup_value$1({
                        TAG: /* Lident */0,
                        _0: s
                      }, env);
                  const desc = match[1];
                  const path = match[0];
                  switch (path.TAG | 0) {
                    case /* Pident */0 :
                        const desc_val_type = type_expr(identity, desc.val_type);
                        const desc_val_kind = desc.val_kind;
                        const desc_val_loc = desc.val_loc;
                        const desc_val_attributes = desc.val_attributes;
                        const desc$1 = {
                          val_type: desc_val_type,
                          val_kind: desc_val_kind,
                          val_loc: desc_val_loc,
                          val_attributes: desc_val_attributes
                        };
                        return add_value(undefined, path._0, desc$1, env);
                    case /* Pdot */1 :
                    case /* Papply */2 :
                        return env;
                    
                  }
                }
                catch (raw_exn){
                  const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                  if (exn.MEL_EXN_ID === Stdlib.Not_found) {
                    return env;
                  }
                  throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
                }
              }), env, idents);
}

function unify_exp(env, exp, expected_ty) {
  unify_exp_types(exp.exp_loc, env, exp.exp_type, expected_ty);
}

function type_exp(env, sexp) {
  return type_expect(undefined, env, sexp, newvar(undefined, undefined));
}

function type_expect(in_function, env, sexp, ty_expected) {
  const previous_saved_types = saved_types.contents;
  warning_enter_scope(undefined);
  warning_attribute(sexp.pexp_attributes);
  const exp = type_expect_(in_function, env, sexp, ty_expected);
  warning_leave_scope(undefined);
  saved_types.contents = {
    hd: {
      TAG: /* Partial_expression */2,
      _0: exp
    },
    tl: previous_saved_types
  };
  return exp;
}

function type_expect_(in_function, env, sexp, ty_expected) {
  const loc = sexp.pexp_loc;
  const rue = function (exp) {
    unify_exp(env, re(exp), instance(undefined, env, ty_expected));
    return exp;
  };
  const lid = sexp.pexp_desc;
  switch (lid.TAG | 0) {
    case /* Pexp_ident */0 :
        const lid$1 = lid._0;
        const match = find_value$1(env, loc, lid$1.txt);
        const desc = match[1];
        const path = match[0];
        if (annotations.contents) {
          const dloc = desc.val_loc;
          const annot = dloc.loc_ghost ? /* Iref_external */0 : ({
                TAG: /* Iref_internal */0,
                _0: dloc
              });
          const name$1 = name(parenthesized_ident, path);
          record$2({
                TAG: /* An_ident */5,
                _0: loc,
                _1: name$1,
                _2: annot
              });
        }
        const match$1 = desc.val_kind;
        let tmp;
        if (typeof match$1 === "number") {
          if (match$1 === /* Val_unbound */1) {
            throw new Caml_js_exceptions.MelangeError($$Error$7, {
                      MEL_EXN_ID: $$Error$7,
                      _1: loc,
                      _2: env,
                      _3: {
                        TAG: /* Masked_instance_variable */29,
                        _0: lid$1.txt
                      }
                    });
          }
          tmp = {
            TAG: /* Texp_ident */0,
            _0: path,
            _1: lid$1,
            _2: desc
          };
        } else {
          switch (match$1.TAG | 0) {
            case /* Val_ivar */1 :
                const match$2 = lookup_value$1({
                      TAG: /* Lident */0,
                      _0: "self-" + match$1._1
                    }, env);
                const txt = lid$1.txt;
                let tmp$1;
                switch (txt.TAG | 0) {
                  case /* Lident */0 :
                      tmp$1 = {
                        txt: txt._0,
                        loc: lid$1.loc
                      };
                      break;
                  case /* Ldot */1 :
                  case /* Lapply */2 :
                      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                                MEL_EXN_ID: "Assert_failure",
                                _1: [
                                  "jscomp/test/ocaml_typedtree_test.ml",
                                  44136,
                                  38
                                ]
                              });
                  
                }
                tmp = {
                  TAG: /* Texp_instvar */20,
                  _0: match$2[0],
                  _1: path,
                  _2: tmp$1
                };
                break;
            case /* Val_self */2 :
                const match$3 = lookup_value$1({
                      TAG: /* Lident */0,
                      _0: "self-" + match$1._2
                    }, env);
                tmp = {
                  TAG: /* Texp_ident */0,
                  _0: match$3[0],
                  _1: lid$1,
                  _2: desc
                };
                break;
            default:
              tmp = {
                TAG: /* Texp_ident */0,
                _0: path,
                _1: lid$1,
                _2: desc
              };
          }
        }
        return rue({
                    exp_desc: tmp,
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: instance(undefined, env, desc.val_type),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_constant */1 :
        const cst = lid._0;
        if (cst.TAG !== /* Const_string */2) {
          return rue({
                      exp_desc: {
                        TAG: /* Texp_constant */1,
                        _0: cst
                      },
                      exp_loc: loc,
                      exp_extra: /* [] */0,
                      exp_type: type_constant(cst),
                      exp_env: env,
                      exp_attributes: sexp.pexp_attributes
                    });
        }
        const ty_exp = expand_head(env, ty_expected);
        const fmt6_path_0 = {
          TAG: /* Pident */0,
          _0: {
            stamp: 0,
            name: "CamlinternalFormatBasics",
            flags: 1
          }
        };
        const fmt6_path = {
          TAG: /* Pdot */1,
          _0: fmt6_path_0,
          _1: "format6",
          _2: 0
        };
        const match$4 = ty_exp.desc;
        let is_format;
        if (typeof match$4 === "number" || !(match$4.TAG === /* Tconstr */3 && same(match$4._0, fmt6_path))) {
          is_format = false;
        } else {
          if (principal.contents && ty_exp.level !== 100000000) {
            prerr_warning(loc, {
                  TAG: /* Not_principal */8,
                  _0: "this coercion to format6"
                });
          }
          is_format = true;
        }
        if (!is_format) {
          return rue({
                      exp_desc: {
                        TAG: /* Texp_constant */1,
                        _0: cst
                      },
                      exp_loc: loc,
                      exp_extra: /* [] */0,
                      exp_type: instance_def(type_string),
                      exp_env: env,
                      exp_attributes: sexp.pexp_attributes
                    });
        }
        const init = type_format(loc, cst._0, env);
        const format_parsetree_pexp_desc = init.pexp_desc;
        const format_parsetree_pexp_loc = sexp.pexp_loc;
        const format_parsetree_pexp_attributes = init.pexp_attributes;
        const format_parsetree = {
          pexp_desc: format_parsetree_pexp_desc,
          pexp_loc: format_parsetree_pexp_loc,
          pexp_attributes: format_parsetree_pexp_attributes
        };
        return type_expect(in_function, env, format_parsetree, ty_expected);
    case /* Pexp_let */2 :
        const rec_flag = lid._0;
        let exit = 0;
        if (rec_flag) {
          exit = 1;
        } else {
          const match$5 = lid._1;
          if (match$5) {
            const match$6 = match$5.hd;
            if (match$6.pvb_attributes || match$5.tl) {
              exit = 1;
            } else {
              const spat = match$6.pvb_pat;
              if (contains_gadt(env, spat)) {
                return type_expect(in_function, env, {
                            pexp_desc: {
                              TAG: /* Pexp_match */6,
                              _0: match$6.pvb_expr,
                              _1: {
                                hd: Curry._3(Ast_helper_Exp.$$case, spat, undefined, lid._2),
                                tl: /* [] */0
                              }
                            },
                            pexp_loc: sexp.pexp_loc,
                            pexp_attributes: sexp.pexp_attributes
                          }, ty_expected);
              }
              exit = 1;
            }
          } else {
            exit = 1;
          }
        }
        if (exit === 1) {
          const sbody = lid._2;
          const match$7 = sexp.pexp_attributes;
          let scp;
          let exit$1 = 0;
          if (match$7 && match$7.hd[0].txt === "#default" && !match$7.tl) {
            scp = undefined;
          } else {
            exit$1 = 2;
          }
          if (exit$1 === 2) {
            scp = rec_flag ? ({
                  TAG: /* Idef */1,
                  _0: loc
                }) : ({
                  TAG: /* Idef */1,
                  _0: sbody.pexp_loc
                });
          }
          const match$8 = type_let(undefined, undefined, env, rec_flag, lid._1, scp, true);
          const body = type_expect(undefined, match$8[1], wrap_unpacks(sbody, match$8[2]), ty_expected);
          return re({
                      exp_desc: {
                        TAG: /* Texp_let */2,
                        _0: rec_flag,
                        _1: match$8[0],
                        _2: body
                      },
                      exp_loc: loc,
                      exp_extra: /* [] */0,
                      exp_type: body.exp_type,
                      exp_env: env,
                      exp_attributes: sexp.pexp_attributes
                    });
        }
        break;
    case /* Pexp_function */3 :
        return type_function(in_function, loc, sexp.pexp_attributes, env, ty_expected, "", lid._0);
    case /* Pexp_fun */4 :
        const $$default = lid._1;
        const l = lid._0;
        if ($$default !== undefined) {
          if (!is_optional(l)) {
            throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                      MEL_EXN_ID: "Assert_failure",
                      _1: [
                        "jscomp/test/ocaml_typedtree_test.ml",
                        44215,
                        6
                      ]
                    });
          }
          const default_loc = $$default.pexp_loc;
          const scases_0 = Curry._3(Ast_helper_Exp.$$case, construct(default_loc, undefined, {
                    txt: {
                      TAG: /* Ldot */1,
                      _0: {
                        TAG: /* Lident */0,
                        _0: "*predef*"
                      },
                      _1: "Some"
                    },
                    loc: none
                  }, $$var$1(default_loc, undefined, {
                        txt: "*sth*",
                        loc: none
                      })), undefined, Curry._3(Ast_helper_Exp.ident, default_loc, undefined, {
                    txt: {
                      TAG: /* Lident */0,
                      _0: "*sth*"
                    },
                    loc: none
                  }));
          const scases_1 = {
            hd: Curry._3(Ast_helper_Exp.$$case, construct(default_loc, undefined, {
                      txt: {
                        TAG: /* Ldot */1,
                        _0: {
                          TAG: /* Lident */0,
                          _0: "*predef*"
                        },
                        _1: "None"
                      },
                      loc: none
                    }, undefined), undefined, $$default),
            tl: /* [] */0
          };
          const scases = {
            hd: scases_0,
            tl: scases_1
          };
          const smatch = Curry._4(Ast_helper_Exp.match_, loc, undefined, Curry._3(Ast_helper_Exp.ident, loc, undefined, {
                    txt: {
                      TAG: /* Lident */0,
                      _0: "*opt*"
                    },
                    loc: none
                  }), scases);
          const sfun = Curry._6(Ast_helper_Exp.fun_, loc, undefined, l, undefined, $$var$1(loc, undefined, {
                    txt: "*opt*",
                    loc: none
                  }), Curry._5(Ast_helper_Exp.let_, loc, {
                    hd: [
                      {
                        txt: "#default",
                        loc: none
                      },
                      {
                        TAG: /* PStr */0,
                        _0: /* [] */0
                      }
                    ],
                    tl: /* [] */0
                  }, /* Nonrecursive */0, {
                    hd: mk$17(undefined, undefined, undefined, undefined, lid._2, smatch),
                    tl: /* [] */0
                  }, lid._3));
          return type_expect(in_function, env, sfun, ty_expected);
        }
        const sexp$1 = lid._3;
        return type_function(in_function, loc, sexp$1.pexp_attributes, env, ty_expected, l, {
                    hd: {
                      pc_lhs: lid._2,
                      pc_guard: undefined,
                      pc_rhs: sexp$1
                    },
                    tl: /* [] */0
                  });
    case /* Pexp_apply */5 :
        const sargs = lid._1;
        if (Caml_obj.caml_equal(sargs, /* [] */0)) {
          ill_formed_ast(loc, "Function application with no argument.");
        }
        begin_def(undefined);
        if (principal.contents) {
          begin_def(undefined);
        }
        const funct = type_exp(env, lid._0);
        if (principal.contents) {
          end_def(undefined);
          generalize_structure$1(current_level.contents, funct.exp_type);
        }
        const ty = instance(undefined, env, funct.exp_type);
        end_def(undefined);
        wrap_trace_gadt_instances(env, (function (param) {
                let _seen = /* [] */0;
                let _ty_fun = param;
                while(true) {
                  const ty_fun = _ty_fun;
                  const seen = _seen;
                  const ty = expand_head(env, ty_fun);
                  if (Stdlib__List.memq(ty, seen)) {
                    return ;
                  }
                  const match = ty.desc;
                  if (typeof match === "number") {
                    return ;
                  }
                  if (match.TAG !== /* Tarrow */1) {
                    return ;
                  }
                  try {
                    unify_var(env, newvar(undefined, undefined), match._1);
                  }
                  catch (raw_exn){
                    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    if (exn.MEL_EXN_ID === Unify) {
                      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                                MEL_EXN_ID: "Assert_failure",
                                _1: [
                                  "jscomp/test/ocaml_typedtree_test.ml",
                                  44266,
                                  65
                                ]
                              });
                    }
                    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
                  }
                  _ty_fun = match._2;
                  _seen = {
                    hd: ty,
                    tl: seen
                  };
                  continue ;
                };
              }), ty);
        begin_def(undefined);
        const match$9 = type_application(env, funct, sargs);
        end_def(undefined);
        unify_var(env, newvar(undefined, undefined), funct.exp_type);
        return rue({
                    exp_desc: {
                      TAG: /* Texp_apply */4,
                      _0: funct,
                      _1: match$9[0]
                    },
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: match$9[1],
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_match */6 :
        begin_def(undefined);
        const arg = type_exp(env, lid._0);
        end_def(undefined);
        if (is_nonexpansive(arg)) {
          iter_generalize$1({
                contents: /* [] */0
              }, arg.exp_type);
        } else {
          generalize_expansive$1(env, arg.exp_type);
        }
        const split_cases = function (_vc, _ec, _param) {
          while(true) {
            const param = _param;
            const ec = _ec;
            const vc = _vc;
            if (!param) {
              return [
                      Stdlib__List.rev(vc),
                      Stdlib__List.rev(ec)
                    ];
            }
            const c = param.hd;
            const p = c.pc_lhs.ppat_desc;
            if (typeof p !== "number" && p.TAG === /* Ppat_exception */14) {
              _param = param.tl;
              _ec = {
                hd: {
                  pc_lhs: p._0,
                  pc_guard: c.pc_guard,
                  pc_rhs: c.pc_rhs
                },
                tl: ec
              };
              continue ;
            }
            _param = param.tl;
            _vc = {
              hd: c,
              tl: vc
            };
            continue ;
          };
        };
        const match$10 = split_cases(/* [] */0, /* [] */0, lid._1);
        const exn_caselist = match$10[1];
        const val_caselist = match$10[0];
        if (Caml_obj.caml_equal(val_caselist, /* [] */0) && Caml_obj.caml_notequal(exn_caselist, /* [] */0)) {
          throw new Caml_js_exceptions.MelangeError($$Error$7, {
                    MEL_EXN_ID: $$Error$7,
                    _1: loc,
                    _2: env,
                    _3: /* No_value_clauses */7
                  });
        }
        const match$11 = type_cases(undefined, env, arg.exp_type, ty_expected, true, loc, val_caselist);
        const match$12 = type_cases(undefined, env, type_exn, ty_expected, false, loc, exn_caselist);
        return re({
                    exp_desc: {
                      TAG: /* Texp_match */5,
                      _0: arg,
                      _1: match$11[0],
                      _2: match$12[0],
                      _3: match$11[1]
                    },
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: instance(undefined, env, ty_expected),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_try */7 :
        const body$1 = type_expect(undefined, env, lid._0, ty_expected);
        const match$13 = type_cases(undefined, env, type_exn, ty_expected, false, loc, lid._1);
        return re({
                    exp_desc: {
                      TAG: /* Texp_try */6,
                      _0: body$1,
                      _1: match$13[0]
                    },
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: body$1.exp_type,
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_tuple */8 :
        const sexpl = lid._0;
        if (Stdlib__List.length(sexpl) < 2) {
          ill_formed_ast(loc, "Tuples must have at least 2 components.");
        }
        const subtypes = Stdlib__List.map((function (param) {
                return newty2(100000000, {
                            TAG: /* Tvar */0,
                            _0: undefined
                          });
              }), sexpl);
        const to_unify = newty2(100000000, {
              TAG: /* Ttuple */2,
              _0: subtypes
            });
        unify_exp_types(loc, env, to_unify, ty_expected);
        const expl = Stdlib__List.map2((function (body, ty) {
                return type_expect(undefined, env, body, ty);
              }), sexpl, subtypes);
        const desc$1 = {
          TAG: /* Ttuple */2,
          _0: Stdlib__List.map((function (e) {
                  return e.exp_type;
                }), expl)
        };
        return re({
                    exp_desc: {
                      TAG: /* Texp_tuple */7,
                      _0: expl
                    },
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: newty2(current_level.contents, desc$1),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_construct */9 :
        let lid$2 = lid._0;
        let sarg = lid._1;
        let attrs = sexp.pexp_attributes;
        let opath;
        try {
          const match$14 = extract_concrete_variant(env, ty_expected);
          opath = [
            match$14[0],
            match$14[1],
            ty_expected.level === 100000000 || !principal.contents
          ];
        }
        catch (raw_exn){
          const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.MEL_EXN_ID === Stdlib.Not_found) {
            opath = undefined;
          } else {
            throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
          }
        }
        const constrs = find_all_constructors(env, lid$2.loc, lid$2.txt);
        const constr = wrap_disambiguate("This variant expression is expected to have", ty_expected, (function (param) {
                return disambiguate$1(undefined, undefined, undefined, lid$2, env, opath, param);
              }), constrs);
        mark_constructor(/* Positive */0, env, last$1(lid$2.txt), constr);
        check_deprecated(loc, constr.cstr_attributes, constr.cstr_name);
        let sargs$1;
        if (sarg !== undefined) {
          const sel = sarg.pexp_desc;
          sargs$1 = sel.TAG === /* Pexp_tuple */8 && (constr.cstr_arity > 1 || explicit_arity(attrs)) ? sel._0 : ({
                hd: sarg,
                tl: /* [] */0
              });
        } else {
          sargs$1 = /* [] */0;
        }
        if (Stdlib__List.length(sargs$1) !== constr.cstr_arity) {
          throw new Caml_js_exceptions.MelangeError($$Error$7, {
                    MEL_EXN_ID: $$Error$7,
                    _1: loc,
                    _2: env,
                    _3: {
                      TAG: /* Constructor_arity_mismatch */1,
                      _0: lid$2.txt,
                      _1: constr.cstr_arity,
                      _2: Stdlib__List.length(sargs$1)
                    }
                  });
        }
        const separate = principal.contents || env.local_constraints;
        if (separate) {
          begin_def(undefined);
          begin_def(undefined);
        }
        const match$15 = instance_constructor(undefined, constr);
        const ty_res = match$15[1];
        const ty_args = match$15[0];
        const texp = re({
              exp_desc: {
                TAG: /* Texp_construct */8,
                _0: lid$2,
                _1: constr,
                _2: /* [] */0
              },
              exp_loc: loc,
              exp_extra: /* [] */0,
              exp_type: ty_res,
              exp_env: env,
              exp_attributes: attrs
            });
        if (separate) {
          end_def(undefined);
          generalize_structure$1(current_level.contents, ty_res);
          unify_exp(env, {
                exp_desc: texp.exp_desc,
                exp_loc: texp.exp_loc,
                exp_extra: texp.exp_extra,
                exp_type: instance_def(ty_res),
                exp_env: texp.exp_env,
                exp_attributes: texp.exp_attributes
              }, instance(undefined, env, ty_expected));
          end_def(undefined);
          Stdlib__List.iter(generalize_structure$2, ty_args);
          generalize_structure$1(current_level.contents, ty_res);
        }
        const match$16 = instance_list(env, {
              hd: ty_res,
              tl: ty_args
            });
        let match$17;
        if (match$16) {
          match$17 = [
            match$16.tl,
            match$16.hd
          ];
        } else {
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                    MEL_EXN_ID: "Assert_failure",
                    _1: [
                      "jscomp/test/ocaml_typedtree_test.ml",
                      45498,
                      11
                    ]
                  });
        }
        const ty_res$1 = match$17[1];
        const texp_exp_desc = texp.exp_desc;
        const texp_exp_loc = texp.exp_loc;
        const texp_exp_extra = texp.exp_extra;
        const texp_exp_env = texp.exp_env;
        const texp_exp_attributes = texp.exp_attributes;
        const texp$1 = {
          exp_desc: texp_exp_desc,
          exp_loc: texp_exp_loc,
          exp_extra: texp_exp_extra,
          exp_type: ty_res$1,
          exp_env: texp_exp_env,
          exp_attributes: texp_exp_attributes
        };
        if (!separate) {
          unify_exp(env, texp$1, instance(undefined, env, ty_expected));
        }
        const args = Stdlib__List.map2((function (e, param) {
                return type_argument(env, e, param[0], param[1]);
              }), sargs$1, Stdlib__List.combine(ty_args, match$17[0]));
        if (constr.cstr_private === /* Private */0) {
          throw new Caml_js_exceptions.MelangeError($$Error$7, {
                    MEL_EXN_ID: $$Error$7,
                    _1: loc,
                    _2: env,
                    _3: {
                      TAG: /* Private_type */19,
                      _0: ty_res$1
                    }
                  });
        }
        return {
                exp_desc: {
                  TAG: /* Texp_construct */8,
                  _0: lid$2,
                  _1: constr,
                  _2: args
                },
                exp_loc: texp_exp_loc,
                exp_extra: texp_exp_extra,
                exp_type: ty_res$1,
                exp_env: texp_exp_env,
                exp_attributes: texp_exp_attributes
              };
    case /* Pexp_variant */10 :
        const sarg$1 = lid._1;
        const l$1 = lid._0;
        const ty_expected0 = instance(undefined, env, ty_expected);
        try {
          const match$18 = expand_head(env, ty_expected);
          const match$19 = expand_head(env, ty_expected0);
          if (sarg$1 !== undefined) {
            const row = match$18.desc;
            if (typeof row === "number") {
              throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                        MEL_EXN_ID: Stdlib.Not_found
                      });
            }
            if (row.TAG === /* Tvariant */8) {
              const row0 = match$19.desc;
              if (typeof row0 === "number") {
                throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                          MEL_EXN_ID: Stdlib.Not_found
                        });
              }
              if (row0.TAG === /* Tvariant */8) {
                const row$1 = row_repr_aux(/* [] */0, row._0);
                const match$20 = row_field_repr_aux(/* [] */0, Stdlib__List.assoc(l$1, row$1.row_fields));
                const match$21 = row_field_repr_aux(/* [] */0, Stdlib__List.assoc(l$1, row0._0.row_fields));
                if (typeof match$20 === "number") {
                  throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                            MEL_EXN_ID: Stdlib.Not_found
                          });
                }
                if (match$20.TAG === /* Rpresent */0) {
                  const ty$1 = match$20._0;
                  if (ty$1 !== undefined) {
                    if (typeof match$21 === "number") {
                      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                                MEL_EXN_ID: Stdlib.Not_found
                              });
                    }
                    if (match$21.TAG === /* Rpresent */0) {
                      const ty0 = match$21._0;
                      if (ty0 !== undefined) {
                        const arg$1 = type_argument(env, sarg$1, ty$1, ty0);
                        return re({
                                    exp_desc: {
                                      TAG: /* Texp_variant */9,
                                      _0: l$1,
                                      _1: arg$1
                                    },
                                    exp_loc: loc,
                                    exp_extra: /* [] */0,
                                    exp_type: ty_expected0,
                                    exp_env: env,
                                    exp_attributes: sexp.pexp_attributes
                                  });
                      }
                      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                                MEL_EXN_ID: Stdlib.Not_found
                              });
                    }
                    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                              MEL_EXN_ID: Stdlib.Not_found
                            });
                  } else {
                    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                              MEL_EXN_ID: Stdlib.Not_found
                            });
                  }
                } else {
                  throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                            MEL_EXN_ID: Stdlib.Not_found
                          });
                }
              } else {
                throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                          MEL_EXN_ID: Stdlib.Not_found
                        });
              }
            } else {
              throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                        MEL_EXN_ID: Stdlib.Not_found
                      });
            }
          } else {
            throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                      MEL_EXN_ID: Stdlib.Not_found
                    });
          }
        }
        catch (raw_exn$1){
          const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
          if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
            const arg$2 = may_map((function (param) {
                    return type_exp(env, param);
                  }), sarg$1);
            const arg_type = may_map((function (arg) {
                    return arg.exp_type;
                  }), arg$2);
            const desc$2 = {
              TAG: /* Tvariant */8,
              _0: {
                row_fields: {
                  hd: [
                    l$1,
                    {
                      TAG: /* Rpresent */0,
                      _0: arg_type
                    }
                  ],
                  tl: /* [] */0
                },
                row_more: newvar(undefined, undefined),
                row_bound: undefined,
                row_closed: false,
                row_fixed: false,
                row_name: undefined
              }
            };
            return rue({
                        exp_desc: {
                          TAG: /* Texp_variant */9,
                          _0: l$1,
                          _1: arg$2
                        },
                        exp_loc: loc,
                        exp_extra: /* [] */0,
                        exp_type: newty2(current_level.contents, desc$2),
                        exp_env: env,
                        exp_attributes: sexp.pexp_attributes
                      });
          }
          throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
        }
    case /* Pexp_record */11 :
        const opt_sexp = lid._1;
        const lid_sexp_list = lid._0;
        if (Caml_obj.caml_equal(lid_sexp_list, /* [] */0)) {
          ill_formed_ast(loc, "Records cannot be empty.");
        }
        let opt_exp;
        if (opt_sexp !== undefined) {
          if (principal.contents) {
            begin_def(undefined);
          }
          const exp = type_exp(env, opt_sexp);
          if (principal.contents) {
            end_def(undefined);
            generalize_structure$1(current_level.contents, exp.exp_type);
          }
          opt_exp = exp;
        } else {
          opt_exp = undefined;
        }
        const get_path = function (ty) {
          try {
            const match = extract_concrete_record(env, ty);
            return [
                    match[0],
                    match[1],
                    ty.level === 100000000 || !principal.contents
                  ];
          }
          catch (raw_exn){
            const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.MEL_EXN_ID === Stdlib.Not_found) {
              return ;
            }
            throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
          }
        };
        const op = get_path(ty_expected);
        let match$22;
        if (op !== undefined) {
          match$22 = [
            ty_expected,
            op
          ];
        } else if (opt_exp !== undefined) {
          const op$1 = get_path(opt_exp.exp_type);
          if (op$1 !== undefined) {
            const p$p = op$1[1];
            const decl = find_type_full(p$p, env)[0];
            begin_def(undefined);
            const ty$2 = newconstr(p$p, instance_list(env, decl.type_params));
            end_def(undefined);
            generalize_structure$1(current_level.contents, ty$2);
            match$22 = [
              ty$2,
              op$1
            ];
          } else {
            match$22 = [
              newvar(undefined, undefined),
              undefined
            ];
          }
        } else {
          match$22 = [
            newvar(undefined, undefined),
            undefined
          ];
        }
        const opath$1 = match$22[1];
        const ty_record = match$22[0];
        const closed = opt_sexp === undefined;
        const lbl_exp_list = wrap_disambiguate("This record expression is expected to have", ty_record, (function (param) {
                return type_label_a_list(undefined, loc, closed, env, (function (param) {
                              return type_label_exp(true, env, loc, ty_record, param);
                            }), opath$1, param);
              }), lid_sexp_list);
        unify_exp_types(loc, env, ty_record, instance(undefined, env, ty_expected));
        const check_duplicates = function (_param) {
          while(true) {
            const param = _param;
            if (!param) {
              return ;
            }
            const match = param.tl;
            if (match) {
              const lbl1 = param.hd[1];
              if (lbl1.lbl_pos === match.hd[1].lbl_pos) {
                throw new Caml_js_exceptions.MelangeError($$Error$7, {
                          MEL_EXN_ID: $$Error$7,
                          _1: loc,
                          _2: env,
                          _3: {
                            TAG: /* Label_multiply_defined */10,
                            _0: lbl1.lbl_name
                          }
                        });
              }
              _param = param.tl;
              continue ;
            }
            _param = param.tl;
            continue ;
          };
        };
        check_duplicates(lbl_exp_list);
        let opt_exp$1;
        if (opt_exp !== undefined) {
          if (lbl_exp_list) {
            const ty_exp$1 = instance(undefined, env, opt_exp.exp_type);
            const unify_kept = function (lbl) {
              if (!Stdlib__List.for_all((function (param) {
                        return param[1].lbl_pos !== lbl.lbl_pos;
                      }), lbl_exp_list)) {
                return ;
              }
              const match = instance_label(false, lbl);
              const match$1 = instance_label(false, lbl);
              unify$2(env, match[1], match$1[1]);
              unify$2(env, instance(undefined, env, ty_expected), match$1[2]);
              unify_exp_types(opt_exp.exp_loc, env, ty_exp$1, match[2]);
            };
            Stdlib__Array.iter(unify_kept, lbl_exp_list.hd[1].lbl_all);
            opt_exp$1 = {
              exp_desc: opt_exp.exp_desc,
              exp_loc: opt_exp.exp_loc,
              exp_extra: opt_exp.exp_extra,
              exp_type: ty_exp$1,
              exp_env: opt_exp.exp_env,
              exp_attributes: opt_exp.exp_attributes
            };
          } else {
            throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                      MEL_EXN_ID: "Assert_failure",
                      _1: [
                        "jscomp/test/ocaml_typedtree_test.ml",
                        44455,
                        15
                      ]
                    });
          }
        } else {
          opt_exp$1 = undefined;
        }
        let num_fields;
        if (lbl_exp_list) {
          num_fields = lbl_exp_list.hd[1].lbl_all.length;
        } else {
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                    MEL_EXN_ID: "Assert_failure",
                    _1: [
                      "jscomp/test/ocaml_typedtree_test.ml",
                      44458,
                      38
                    ]
                  });
        }
        if (opt_sexp === undefined && Stdlib__List.length(lid_sexp_list) !== num_fields) {
          const present_indices = Stdlib__List.map((function (param) {
                  return param[1].lbl_pos;
                }), lbl_exp_list);
          const label_names = extract_label_names(sexp, env, ty_expected);
          const missing_labels = function (_n, _param) {
            while(true) {
              const param = _param;
              const n = _n;
              if (!param) {
                return /* [] */0;
              }
              const rem = param.tl;
              if (!Stdlib__List.mem(n, present_indices)) {
                return {
                        hd: param.hd,
                        tl: missing_labels(n + 1 | 0, rem)
                      };
              }
              _param = rem;
              _n = n + 1 | 0;
              continue ;
            };
          };
          const missing = missing_labels(0, label_names);
          throw new Caml_js_exceptions.MelangeError($$Error$7, {
                    MEL_EXN_ID: $$Error$7,
                    _1: loc,
                    _2: env,
                    _3: {
                      TAG: /* Label_missing */11,
                      _0: missing
                    }
                  });
        }
        if (opt_sexp !== undefined && Stdlib__List.length(lid_sexp_list) === num_fields) {
          prerr_warning(loc, /* Useless_record_with */11);
        }
        return re({
                    exp_desc: {
                      TAG: /* Texp_record */10,
                      _0: lbl_exp_list,
                      _1: opt_exp$1
                    },
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: instance(undefined, env, ty_expected),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_field */12 :
        const lid$3 = lid._1;
        const match$23 = type_label_access(env, loc, lid._0, lid$3);
        const label = match$23[1];
        const record$3 = match$23[0];
        const match$24 = instance_label(false, label);
        unify_exp(env, record$3, match$24[2]);
        return rue({
                    exp_desc: {
                      TAG: /* Texp_field */11,
                      _0: record$3,
                      _1: lid$3,
                      _2: label
                    },
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: match$24[1],
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_setfield */13 :
        const lid$4 = lid._1;
        const match$25 = type_label_access(env, loc, lid._0, lid$4);
        const record$4 = match$25[0];
        const ty_record$1 = match$25[2] === undefined ? newvar(undefined, undefined) : record$4.exp_type;
        const match$26 = type_label_exp(false, env, loc, ty_record$1, [
              lid$4,
              match$25[1],
              lid._2
            ]);
        const label$1 = match$26[1];
        unify_exp(env, record$4, ty_record$1);
        if (label$1.lbl_mut === /* Immutable */0) {
          throw new Caml_js_exceptions.MelangeError($$Error$7, {
                    MEL_EXN_ID: $$Error$7,
                    _1: loc,
                    _2: env,
                    _3: {
                      TAG: /* Label_not_mutable */12,
                      _0: lid$4.txt
                    }
                  });
        }
        return rue({
                    exp_desc: {
                      TAG: /* Texp_setfield */12,
                      _0: record$4,
                      _1: match$26[0],
                      _2: label$1,
                      _3: match$26[2]
                    },
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: instance_def(type_unit),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_array */14 :
        const ty$3 = newty2(100000000, {
              TAG: /* Tvar */0,
              _0: undefined
            });
        const to_unify$1 = type_array(ty$3);
        unify_exp_types(loc, env, to_unify$1, ty_expected);
        const argl = Stdlib__List.map((function (sarg) {
                return type_expect(undefined, env, sarg, ty$3);
              }), lid._0);
        return re({
                    exp_desc: {
                      TAG: /* Texp_array */13,
                      _0: argl
                    },
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: instance(undefined, env, ty_expected),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_ifthenelse */15 :
        const sifnot = lid._2;
        const sifso = lid._1;
        const cond = type_expect(undefined, env, lid._0, type_bool);
        if (sifnot !== undefined) {
          const ifso = type_expect(undefined, env, sifso, ty_expected);
          const ifnot = type_expect(undefined, env, sifnot, ty_expected);
          unify_exp(env, ifnot, ifso.exp_type);
          return re({
                      exp_desc: {
                        TAG: /* Texp_ifthenelse */14,
                        _0: cond,
                        _1: ifso,
                        _2: ifnot
                      },
                      exp_loc: loc,
                      exp_extra: /* [] */0,
                      exp_type: ifso.exp_type,
                      exp_env: env,
                      exp_attributes: sexp.pexp_attributes
                    });
        }
        const ifso$1 = type_expect(undefined, env, sifso, type_unit);
        return rue({
                    exp_desc: {
                      TAG: /* Texp_ifthenelse */14,
                      _0: cond,
                      _1: ifso$1,
                      _2: undefined
                    },
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: ifso$1.exp_type,
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_sequence */16 :
        const exp1 = type_statement(env, lid._0);
        const exp2 = type_expect(undefined, env, lid._1, ty_expected);
        return re({
                    exp_desc: {
                      TAG: /* Texp_sequence */15,
                      _0: exp1,
                      _1: exp2
                    },
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: exp2.exp_type,
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_while */17 :
        const cond$1 = type_expect(undefined, env, lid._0, type_bool);
        const body$2 = type_statement(env, lid._1);
        return rue({
                    exp_desc: {
                      TAG: /* Texp_while */16,
                      _0: cond$1,
                      _1: body$2
                    },
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: instance_def(type_unit),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_for */18 :
        const param = lid._0;
        const low = type_expect(undefined, env, lid._1, type_int);
        const high = type_expect(undefined, env, lid._2, type_int);
        const match$27 = param.ppat_desc;
        let match$28;
        if (typeof match$27 === "number") {
          match$28 = [
            create("_for"),
            env
          ];
        } else if (match$27.TAG === /* Ppat_var */0) {
          match$28 = enter_value((function (s) {
                    return {
                            TAG: /* Unused_for_index */19,
                            _0: s
                          };
                  }))(match$27._0.txt, {
                val_type: instance_def(type_int),
                val_kind: /* Val_reg */0,
                val_loc: loc,
                val_attributes: /* [] */0
              }, env);
        } else {
          throw new Caml_js_exceptions.MelangeError($$Error$7, {
                    MEL_EXN_ID: $$Error$7,
                    _1: param.ppat_loc,
                    _2: env,
                    _3: /* Invalid_for_loop_index */6
                  });
        }
        const body$3 = type_statement(match$28[1], lid._4);
        return rue({
                    exp_desc: {
                      TAG: /* Texp_for */17,
                      _0: match$28[0],
                      _1: param,
                      _2: low,
                      _3: high,
                      _4: lid._3,
                      _5: body$3
                    },
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: instance_def(type_unit),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_constraint */19 :
        begin_def(undefined);
        const cty = transl_simple_type(env, false, lid._1);
        const ty$4 = cty.ctyp_type;
        end_def(undefined);
        generalize_structure$1(current_level.contents, ty$4);
        const arg$3 = type_argument(env, lid._0, ty$4, instance(undefined, env, ty$4));
        const ty$p = instance(undefined, env, ty$4);
        return rue({
                    exp_desc: arg$3.exp_desc,
                    exp_loc: arg$3.exp_loc,
                    exp_extra: {
                      hd: [
                        {
                          TAG: /* Texp_constraint */0,
                          _0: cty
                        },
                        loc,
                        sexp.pexp_attributes
                      ],
                      tl: arg$3.exp_extra
                    },
                    exp_type: ty$p,
                    exp_env: env,
                    exp_attributes: arg$3.exp_attributes
                  });
    case /* Pexp_coerce */20 :
        const sty$p = lid._2;
        const sty = lid._1;
        const sarg$2 = lid._0;
        let match$29;
        if (sty !== undefined) {
          begin_def(undefined);
          const match$30 = transl_simple_type_delayed(env, sty);
          const cty$1 = match$30[0];
          const match$31 = transl_simple_type_delayed(env, sty$p);
          const cty$p = match$31[0];
          const ty$5 = cty$1.ctyp_type;
          const ty$p$1 = cty$p.ctyp_type;
          try {
            const force$p$p = subtype(env, ty$5, ty$p$1);
            Curry._1(match$30[1], undefined);
            Curry._1(match$31[1], undefined);
            Curry._1(force$p$p, undefined);
          }
          catch (raw_exn$2){
            const exn$2 = Caml_js_exceptions.internalToOCamlException(raw_exn$2);
            if (exn$2.MEL_EXN_ID === Subtype) {
              throw new Caml_js_exceptions.MelangeError($$Error$7, {
                        MEL_EXN_ID: $$Error$7,
                        _1: loc,
                        _2: env,
                        _3: {
                          TAG: /* Not_subtype */23,
                          _0: exn$2._1,
                          _1: exn$2._2
                        }
                      });
            }
            throw new Caml_js_exceptions.MelangeError(exn$2.MEL_EXN_ID, exn$2);
          }
          end_def(undefined);
          generalize_structure$1(current_level.contents, ty$5);
          generalize_structure$1(current_level.contents, ty$p$1);
          match$29 = [
            type_argument(env, sarg$2, ty$5, instance(undefined, env, ty$5)),
            instance(undefined, env, ty$p$1),
            cty$1,
            cty$p
          ];
        } else {
          const match$32 = transl_simple_type_delayed(env, sty$p);
          const force = match$32[1];
          const cty$p$1 = match$32[0];
          const ty$p$2 = cty$p$1.ctyp_type;
          begin_def(undefined);
          const arg$4 = type_exp(env, sarg$2);
          end_def(undefined);
          const tv = newvar(undefined, undefined);
          const gen = generalizable(tv.level, arg$4.exp_type);
          unify_var(env, tv, arg$4.exp_type);
          const match$33 = arg$4.exp_desc;
          const match$34 = self_coercion.contents;
          const match$35 = repr(ty$p$2).desc;
          let exit$2 = 0;
          if (match$33.TAG === /* Texp_ident */0) {
            let tmp$2 = match$33._2.val_kind;
            if (typeof tmp$2 === "number" || !(tmp$2.TAG === /* Val_self */2 && match$34 && !(typeof match$35 === "number" || match$35.TAG !== /* Tconstr */3))) {
              exit$2 = 1;
            } else {
              const match$36 = match$34.hd;
              const r = match$36[1];
              if (same(match$36[0], match$35._0)) {
                r.contents = {
                  hd: loc,
                  tl: r.contents
                };
                Curry._1(force, undefined);
              } else {
                exit$2 = 1;
              }
            }
          } else {
            exit$2 = 1;
          }
          if (exit$2 === 1) {
            if (Caml_obj.caml_equal(free_variables$1(Caml_option.some(env), arg$4.exp_type), /* [] */0) && Caml_obj.caml_equal(free_variables$1(Caml_option.some(env), ty$p$2), /* [] */0)) {
              let tmp$3 = false;
              if (!gen) {
                const snap = snapshot(undefined);
                const match$37 = enlarge_type(env, ty$p$2);
                let tmp$4;
                try {
                  Curry._1(force, undefined);
                  unify$2(env, arg$4.exp_type, match$37[0]);
                  tmp$4 = true;
                }
                catch (raw_exn$3){
                  const exn$3 = Caml_js_exceptions.internalToOCamlException(raw_exn$3);
                  if (exn$3.MEL_EXN_ID === Unify) {
                    backtrack(snap);
                    tmp$4 = false;
                  } else {
                    throw new Caml_js_exceptions.MelangeError(exn$3.MEL_EXN_ID, exn$3);
                  }
                }
                tmp$3 = tmp$4;
              }
              if (!tmp$3) {
                try {
                  const force$p = subtype(env, arg$4.exp_type, ty$p$2);
                  Curry._1(force, undefined);
                  Curry._1(force$p, undefined);
                  if (!gen) {
                    prerr_warning(loc, {
                          TAG: /* Not_principal */8,
                          _0: "this ground coercion"
                        });
                  }
                  
                }
                catch (raw_exn$4){
                  const exn$4 = Caml_js_exceptions.internalToOCamlException(raw_exn$4);
                  if (exn$4.MEL_EXN_ID === Subtype) {
                    throw new Caml_js_exceptions.MelangeError($$Error$7, {
                              MEL_EXN_ID: $$Error$7,
                              _1: loc,
                              _2: env,
                              _3: {
                                TAG: /* Not_subtype */23,
                                _0: exn$4._1,
                                _1: exn$4._2
                              }
                            });
                  }
                  throw new Caml_js_exceptions.MelangeError(exn$4.MEL_EXN_ID, exn$4);
                }
              }
              
            } else {
              const match$38 = enlarge_type(env, ty$p$2);
              Curry._1(force, undefined);
              try {
                unify$2(env, arg$4.exp_type, match$38[0]);
              }
              catch (raw_trace){
                const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
                if (trace.MEL_EXN_ID === Unify) {
                  throw new Caml_js_exceptions.MelangeError($$Error$7, {
                            MEL_EXN_ID: $$Error$7,
                            _1: sarg$2.pexp_loc,
                            _2: env,
                            _3: {
                              TAG: /* Coercion_failure */25,
                              _0: ty$p$2,
                              _1: full_expand(env, ty$p$2),
                              _2: trace._1,
                              _3: match$38[1]
                            }
                          });
                }
                throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
              }
            }
          }
          match$29 = [
            arg$4,
            ty$p$2,
            undefined,
            cty$p$1
          ];
        }
        const arg$5 = match$29[0];
        return rue({
                    exp_desc: arg$5.exp_desc,
                    exp_loc: arg$5.exp_loc,
                    exp_extra: {
                      hd: [
                        {
                          TAG: /* Texp_coerce */1,
                          _0: match$29[2],
                          _1: match$29[3]
                        },
                        loc,
                        sexp.pexp_attributes
                      ],
                      tl: arg$5.exp_extra
                    },
                    exp_type: match$29[1],
                    exp_env: env,
                    exp_attributes: arg$5.exp_attributes
                  });
    case /* Pexp_send */21 :
        const met = lid._1;
        const e = lid._0;
        if (principal.contents) {
          begin_def(undefined);
        }
        const obj = type_exp(env, e);
        try {
          const match$39 = obj.exp_desc;
          let match$40;
          let exit$3 = 0;
          if (match$39.TAG === /* Texp_ident */0) {
            const match$41 = match$39._2.val_kind;
            const lid$5 = match$39._1;
            if (typeof match$41 === "number") {
              exit$3 = 1;
            } else {
              switch (match$41.TAG | 0) {
                case /* Val_self */2 :
                    const match$42 = filter_self_method(env, met, /* Private */0, match$41._0, match$41._3);
                    const typ = match$42[1];
                    if (is_Tvar(repr(typ))) {
                      prerr_warning(loc, {
                            TAG: /* Undeclared_virtual_method */7,
                            _0: met
                          });
                    }
                    match$40 = [
                      {
                        TAG: /* Tmeth_val */1,
                        _0: match$42[0]
                      },
                      undefined,
                      typ
                    ];
                    break;
                case /* Val_anc */3 :
                    const cl_num = match$41._1;
                    let method_id;
                    try {
                      method_id = Stdlib__List.assoc(met, match$41._0);
                    }
                    catch (raw_exn$5){
                      const exn$5 = Caml_js_exceptions.internalToOCamlException(raw_exn$5);
                      if (exn$5.MEL_EXN_ID === Stdlib.Not_found) {
                        throw new Caml_js_exceptions.MelangeError($$Error$7, {
                                  MEL_EXN_ID: $$Error$7,
                                  _1: e.pexp_loc,
                                  _2: env,
                                  _3: {
                                    TAG: /* Undefined_inherited_method */17,
                                    _0: met
                                  }
                                });
                      }
                      throw new Caml_js_exceptions.MelangeError(exn$5.MEL_EXN_ID, exn$5);
                    }
                    const match$43 = lookup_value$1({
                          TAG: /* Lident */0,
                          _0: "selfpat-" + cl_num
                        }, env);
                    const match$44 = lookup_value$1({
                          TAG: /* Lident */0,
                          _0: "self-" + cl_num
                        }, env);
                    const desc$3 = match$43[1];
                    const match$45 = desc$3.val_kind;
                    if (typeof match$45 === "number") {
                      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                                MEL_EXN_ID: "Assert_failure",
                                _1: [
                                  "jscomp/test/ocaml_typedtree_test.ml",
                                  44747,
                                  18
                                ]
                              });
                    }
                    if (match$45.TAG === /* Val_self */2) {
                      const match$46 = filter_self_method(env, met, /* Private */0, match$45._0, match$45._3);
                      const typ$1 = match$46[1];
                      const method_type = newvar(undefined, undefined);
                      const match$47 = filter_arrow(env, method_type, "");
                      unify$2(env, match$47[0], desc$3.val_type);
                      unify$2(env, match$47[1], instance(undefined, env, typ$1));
                      const exp_0 = {
                        exp_desc: {
                          TAG: /* Texp_ident */0,
                          _0: {
                            TAG: /* Pident */0,
                            _0: method_id
                          },
                          _1: lid$5,
                          _2: {
                            val_type: method_type,
                            val_kind: /* Val_reg */0,
                            val_loc: none,
                            val_attributes: /* [] */0
                          }
                        },
                        exp_loc: loc,
                        exp_extra: /* [] */0,
                        exp_type: method_type,
                        exp_env: env,
                        exp_attributes: /* [] */0
                      };
                      const exp_1 = {
                        hd: [
                          "",
                          {
                            exp_desc: {
                              TAG: /* Texp_ident */0,
                              _0: match$44[0],
                              _1: lid$5,
                              _2: desc$3
                            },
                            exp_loc: obj.exp_loc,
                            exp_extra: /* [] */0,
                            exp_type: desc$3.val_type,
                            exp_env: env,
                            exp_attributes: /* [] */0
                          },
                          /* Required */0
                        ],
                        tl: /* [] */0
                      };
                      const exp$1 = {
                        TAG: /* Texp_apply */4,
                        _0: exp_0,
                        _1: exp_1
                      };
                      match$40 = [
                        {
                          TAG: /* Tmeth_name */0,
                          _0: met
                        },
                        re({
                              exp_desc: exp$1,
                              exp_loc: loc,
                              exp_extra: /* [] */0,
                              exp_type: typ$1,
                              exp_env: env,
                              exp_attributes: /* [] */0
                            }),
                        typ$1
                      ];
                    } else {
                      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                                MEL_EXN_ID: "Assert_failure",
                                _1: [
                                  "jscomp/test/ocaml_typedtree_test.ml",
                                  44747,
                                  18
                                ]
                              });
                    }
                    break;
                default:
                  exit$3 = 1;
              }
            }
          } else {
            exit$3 = 1;
          }
          if (exit$3 === 1) {
            match$40 = [
              {
                TAG: /* Tmeth_name */0,
                _0: met
              },
              undefined,
              filter_method(env, met, /* Public */1, obj.exp_type)
            ];
          }
          const typ$2 = match$40[2];
          if (principal.contents) {
            end_def(undefined);
            generalize_structure$1(current_level.contents, typ$2);
          }
          const ty$6 = repr(typ$2);
          const match$48 = ty$6.desc;
          let typ$3;
          if (typeof match$48 === "number") {
            throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                      MEL_EXN_ID: "Assert_failure",
                      _1: [
                        "jscomp/test/ocaml_typedtree_test.ml",
                        44773,
                        14
                      ]
                    });
          }
          switch (match$48.TAG | 0) {
            case /* Tvar */0 :
                const ty$p$3 = newvar(undefined, undefined);
                unify$2(env, instance_def(ty$6), newty2(current_level.contents, {
                          TAG: /* Tpoly */10,
                          _0: ty$p$3,
                          _1: /* [] */0
                        }));
                typ$3 = ty$p$3;
                break;
            case /* Tpoly */10 :
                const ty$7 = match$48._0;
                if (match$48._1) {
                  const l$2 = ty$6.level;
                  if (principal.contents && l$2 !== 100000000) {
                    prerr_warning(loc, {
                          TAG: /* Not_principal */8,
                          _0: "this use of a polymorphic method"
                        });
                  }
                  typ$3 = instance_poly(undefined, false, match$48._1, ty$7)[1];
                } else {
                  typ$3 = instance(undefined, env, ty$7);
                }
                break;
            default:
              throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                        MEL_EXN_ID: "Assert_failure",
                        _1: [
                          "jscomp/test/ocaml_typedtree_test.ml",
                          44773,
                          14
                        ]
                      });
          }
          return rue({
                      exp_desc: {
                        TAG: /* Texp_send */18,
                        _0: obj,
                        _1: match$40[0],
                        _2: match$40[1]
                      },
                      exp_loc: loc,
                      exp_extra: /* [] */0,
                      exp_type: typ$3,
                      exp_env: env,
                      exp_attributes: sexp.pexp_attributes
                    });
        }
        catch (raw_exn$6){
          const exn$6 = Caml_js_exceptions.internalToOCamlException(raw_exn$6);
          if (exn$6.MEL_EXN_ID === Unify) {
            throw new Caml_js_exceptions.MelangeError($$Error$7, {
                      MEL_EXN_ID: $$Error$7,
                      _1: e.pexp_loc,
                      _2: env,
                      _3: {
                        TAG: /* Undefined_method */16,
                        _0: obj.exp_type,
                        _1: met
                      }
                    });
          }
          throw new Caml_js_exceptions.MelangeError(exn$6.MEL_EXN_ID, exn$6);
        }
        break;
    case /* Pexp_new */22 :
        const cl = lid._0;
        const match$49 = find_class$1(env, loc, cl.txt);
        const cl_decl = match$49[1];
        const ty$8 = cl_decl.cty_new;
        if (ty$8 !== undefined) {
          return rue({
                      exp_desc: {
                        TAG: /* Texp_new */19,
                        _0: match$49[0],
                        _1: cl,
                        _2: cl_decl
                      },
                      exp_loc: loc,
                      exp_extra: /* [] */0,
                      exp_type: instance_def(ty$8),
                      exp_env: env,
                      exp_attributes: sexp.pexp_attributes
                    });
        }
        throw new Caml_js_exceptions.MelangeError($$Error$7, {
                  MEL_EXN_ID: $$Error$7,
                  _1: loc,
                  _2: env,
                  _3: {
                    TAG: /* Virtual_class */18,
                    _0: cl.txt
                  }
                });
    case /* Pexp_setinstvar */23 :
        const lab = lid._0;
        try {
          const match$50 = lookup_value$1({
                TAG: /* Lident */0,
                _0: lab.txt
              }, env);
          const desc$4 = match$50[1];
          const match$51 = desc$4.val_kind;
          let exit$4 = 0;
          if (typeof match$51 === "number") {
            exit$4 = 1;
          } else {
            if (match$51.TAG === /* Val_ivar */1) {
              if (match$51._0) {
                const newval = type_expect(undefined, env, lid._1, instance(undefined, env, desc$4.val_type));
                const match$52 = lookup_value$1({
                      TAG: /* Lident */0,
                      _0: "self-" + match$51._1
                    }, env);
                return rue({
                            exp_desc: {
                              TAG: /* Texp_setinstvar */21,
                              _0: match$52[0],
                              _1: match$50[0],
                              _2: lab,
                              _3: newval
                            },
                            exp_loc: loc,
                            exp_extra: /* [] */0,
                            exp_type: instance_def(type_unit),
                            exp_env: env,
                            exp_attributes: sexp.pexp_attributes
                          });
              }
              throw new Caml_js_exceptions.MelangeError($$Error$7, {
                        MEL_EXN_ID: $$Error$7,
                        _1: loc,
                        _2: env,
                        _3: {
                          TAG: /* Instance_variable_not_mutable */22,
                          _0: true,
                          _1: lab.txt
                        }
                      });
            }
            exit$4 = 1;
          }
          if (exit$4 === 1) {
            throw new Caml_js_exceptions.MelangeError($$Error$7, {
                      MEL_EXN_ID: $$Error$7,
                      _1: loc,
                      _2: env,
                      _3: {
                        TAG: /* Instance_variable_not_mutable */22,
                        _0: false,
                        _1: lab.txt
                      }
                    });
          }
          
        }
        catch (raw_exn$7){
          const exn$7 = Caml_js_exceptions.internalToOCamlException(raw_exn$7);
          if (exn$7.MEL_EXN_ID === Stdlib.Not_found) {
            throw new Caml_js_exceptions.MelangeError($$Error$7, {
                      MEL_EXN_ID: $$Error$7,
                      _1: loc,
                      _2: env,
                      _3: {
                        TAG: /* Unbound_instance_variable */21,
                        _0: lab.txt
                      }
                    });
          }
          throw new Caml_js_exceptions.MelangeError(exn$7.MEL_EXN_ID, exn$7);
        }
        break;
    case /* Pexp_override */24 :
        const lst = lid._0;
        Stdlib__List.fold_right((function (param, l) {
                const lab = param[0];
                if (Stdlib__List.exists((function (l) {
                          return l.txt === lab.txt;
                        }), l)) {
                  throw new Caml_js_exceptions.MelangeError($$Error$7, {
                            MEL_EXN_ID: $$Error$7,
                            _1: loc,
                            _2: env,
                            _3: {
                              TAG: /* Value_multiply_overridden */24,
                              _0: lab.txt
                            }
                          });
                }
                return {
                        hd: lab,
                        tl: l
                      };
              }), lst, /* [] */0);
        let match$53;
        try {
          match$53 = [
            lookup_value$1({
                  TAG: /* Lident */0,
                  _0: "selfpat-*"
                }, env),
            lookup_value$1({
                  TAG: /* Lident */0,
                  _0: "self-*"
                }, env)
          ];
        }
        catch (raw_exn$8){
          const exn$8 = Caml_js_exceptions.internalToOCamlException(raw_exn$8);
          if (exn$8.MEL_EXN_ID === Stdlib.Not_found) {
            throw new Caml_js_exceptions.MelangeError($$Error$7, {
                      MEL_EXN_ID: $$Error$7,
                      _1: loc,
                      _2: env,
                      _3: /* Outside_class */0
                    });
          }
          throw new Caml_js_exceptions.MelangeError(exn$8.MEL_EXN_ID, exn$8);
        }
        const match$54 = match$53[0][1];
        const match$55 = match$54.val_kind;
        if (typeof match$55 === "number") {
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                    MEL_EXN_ID: "Assert_failure",
                    _1: [
                      "jscomp/test/ocaml_typedtree_test.ml",
                      44857,
                      10
                    ]
                  });
        }
        if (match$55.TAG === /* Val_self */2) {
          const vars = match$55._1;
          const type_override = function (param) {
            const lab = param[0];
            try {
              const match = Curry._2(Meths.find, lab.txt, vars.contents);
              return [
                      {
                        TAG: /* Pident */0,
                        _0: match[0]
                      },
                      lab,
                      type_expect(undefined, env, param[1], instance(undefined, env, match[3]))
                    ];
            }
            catch (raw_exn){
              const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn.MEL_EXN_ID === Stdlib.Not_found) {
                throw new Caml_js_exceptions.MelangeError($$Error$7, {
                          MEL_EXN_ID: $$Error$7,
                          _1: loc,
                          _2: env,
                          _3: {
                            TAG: /* Unbound_instance_variable */21,
                            _0: lab.txt
                          }
                        });
              }
              throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
            }
          };
          const modifs = Stdlib__List.map(type_override, lst);
          return rue({
                      exp_desc: {
                        TAG: /* Texp_override */22,
                        _0: match$53[1][0],
                        _1: modifs
                      },
                      exp_loc: loc,
                      exp_extra: /* [] */0,
                      exp_type: match$54.val_type,
                      exp_env: env,
                      exp_attributes: sexp.pexp_attributes
                    });
        }
        throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                  MEL_EXN_ID: "Assert_failure",
                  _1: [
                    "jscomp/test/ocaml_typedtree_test.ml",
                    44857,
                    10
                  ]
                });
    case /* Pexp_letmodule */25 :
        const name$2 = lid._0;
        const ty$9 = newvar(undefined, undefined);
        begin_def(undefined);
        set_current_time(ty$9.level);
        const context = narrow(undefined);
        const modl = Curry._2(type_module.contents, env, lid._1);
        const match$56 = enter_module(undefined, name$2.txt, modl.mod_type, env);
        const new_env = match$56[1];
        init_def(currentstamp.contents);
        widen(context);
        const body$4 = type_expect(undefined, new_env, lid._2, ty_expected);
        end_def(undefined);
        try {
          unify_var(new_env, ty$9, body$4.exp_type);
        }
        catch (raw_exn$9){
          const exn$9 = Caml_js_exceptions.internalToOCamlException(raw_exn$9);
          if (exn$9.MEL_EXN_ID === Unify) {
            throw new Caml_js_exceptions.MelangeError($$Error$7, {
                      MEL_EXN_ID: $$Error$7,
                      _1: loc,
                      _2: env,
                      _3: {
                        TAG: /* Scoping_let_module */28,
                        _0: name$2.txt,
                        _1: body$4.exp_type
                      }
                    });
          }
          throw new Caml_js_exceptions.MelangeError(exn$9.MEL_EXN_ID, exn$9);
        }
        return re({
                    exp_desc: {
                      TAG: /* Texp_letmodule */23,
                      _0: match$56[0],
                      _1: name$2,
                      _2: modl,
                      _3: body$4
                    },
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: ty$9,
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_assert */26 :
        const cond$2 = type_expect(undefined, env, lid._0, type_bool);
        const match$57 = cond$2.exp_desc;
        let exp_type;
        exp_type = match$57.TAG === /* Texp_construct */8 && match$57._1.cstr_name === "false" ? instance(undefined, env, ty_expected) : instance_def(type_unit);
        return rue({
                    exp_desc: {
                      TAG: /* Texp_assert */24,
                      _0: cond$2
                    },
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: exp_type,
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_lazy */27 :
        const ty$10 = newty2(100000000, {
              TAG: /* Tvar */0,
              _0: undefined
            });
        const to_unify$2 = type_lazy_t(ty$10);
        unify_exp_types(loc, env, to_unify$2, ty_expected);
        const arg$6 = type_expect(undefined, env, lid._0, ty$10);
        return re({
                    exp_desc: {
                      TAG: /* Texp_lazy */25,
                      _0: arg$6
                    },
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: instance(undefined, env, ty_expected),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_poly */28 :
        const sty$1 = lid._1;
        const sbody$1 = lid._0;
        if (principal.contents) {
          begin_def(undefined);
        }
        let match$58;
        if (sty$1 !== undefined) {
          const sty$2 = force_poly(sty$1);
          const cty$2 = transl_simple_type(env, false, sty$2);
          match$58 = [
            repr(cty$2.ctyp_type),
            cty$2
          ];
        } else {
          match$58 = [
            repr(ty_expected),
            undefined
          ];
        }
        const ty$11 = match$58[0];
        if (principal.contents) {
          end_def(undefined);
          generalize_structure$1(current_level.contents, ty$11);
        }
        if (sty$1 !== undefined) {
          unify_exp_types(loc, env, instance(undefined, env, ty$11), instance(undefined, env, ty_expected));
        }
        const match$59 = expand_head(env, ty$11).desc;
        let exp$2;
        if (typeof match$59 === "number") {
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                    MEL_EXN_ID: "Assert_failure",
                    _1: [
                      "jscomp/test/ocaml_typedtree_test.ml",
                      44963,
                      15
                    ]
                  });
        }
        switch (match$59.TAG | 0) {
          case /* Tvar */0 :
              const exp$3 = type_exp(env, sbody$1);
              const exp_exp_desc = exp$3.exp_desc;
              const exp_exp_loc = exp$3.exp_loc;
              const exp_exp_extra = exp$3.exp_extra;
              const exp_exp_type = newty2(current_level.contents, {
                    TAG: /* Tpoly */10,
                    _0: exp$3.exp_type,
                    _1: /* [] */0
                  });
              const exp_exp_env = exp$3.exp_env;
              const exp_exp_attributes = exp$3.exp_attributes;
              const exp$4 = {
                exp_desc: exp_exp_desc,
                exp_loc: exp_exp_loc,
                exp_extra: exp_exp_extra,
                exp_type: exp_exp_type,
                exp_env: exp_exp_env,
                exp_attributes: exp_exp_attributes
              };
              unify_exp(env, exp$4, ty$11);
              exp$2 = exp$4;
              break;
          case /* Tpoly */10 :
              const ty$p$4 = match$59._0;
              if (match$59._1) {
                begin_def(undefined);
                if (principal.contents) {
                  begin_def(undefined);
                }
                const match$60 = instance_poly(undefined, true, match$59._1, ty$p$4);
                const ty$p$p = match$60[1];
                if (principal.contents) {
                  end_def(undefined);
                  generalize_structure$1(current_level.contents, ty$p$p);
                }
                const exp$5 = type_expect(undefined, env, sbody$1, ty$p$p);
                end_def(undefined);
                check_univars(env, false, "method", exp$5, ty_expected, match$60[0]);
                exp$2 = {
                  exp_desc: exp$5.exp_desc,
                  exp_loc: exp$5.exp_loc,
                  exp_extra: exp$5.exp_extra,
                  exp_type: instance(undefined, env, ty$11),
                  exp_env: exp$5.exp_env,
                  exp_attributes: exp$5.exp_attributes
                };
              } else {
                const exp$6 = type_expect(undefined, env, sbody$1, ty$p$4);
                exp$2 = {
                  exp_desc: exp$6.exp_desc,
                  exp_loc: exp$6.exp_loc,
                  exp_extra: exp$6.exp_extra,
                  exp_type: instance(undefined, env, ty$11),
                  exp_env: exp$6.exp_env,
                  exp_attributes: exp$6.exp_attributes
                };
              }
              break;
          default:
            throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                      MEL_EXN_ID: "Assert_failure",
                      _1: [
                        "jscomp/test/ocaml_typedtree_test.ml",
                        44963,
                        15
                      ]
                    });
        }
        return re({
                    exp_desc: exp$2.exp_desc,
                    exp_loc: exp$2.exp_loc,
                    exp_extra: {
                      hd: [
                        {
                          TAG: /* Texp_poly */3,
                          _0: match$58[1]
                        },
                        loc,
                        sexp.pexp_attributes
                      ],
                      tl: exp$2.exp_extra
                    },
                    exp_type: exp$2.exp_type,
                    exp_env: exp$2.exp_env,
                    exp_attributes: exp$2.exp_attributes
                  });
    case /* Pexp_object */29 :
        const match$61 = Curry._3(type_object.contents, env, loc, lid._0);
        return rue({
                    exp_desc: {
                      TAG: /* Texp_object */26,
                      _0: match$61[0],
                      _1: match$61[2]
                    },
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: match$61[1].csig_self,
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_newtype */30 :
        const name$3 = lid._0;
        const ty$12 = newvar(undefined, undefined);
        begin_def(undefined);
        const level = current_level.contents;
        const decl_type_newtype_level = [
          level,
          level
        ];
        const decl$1 = {
          type_params: /* [] */0,
          type_arity: 0,
          type_kind: /* Type_abstract */0,
          type_private: /* Public */1,
          type_manifest: undefined,
          type_variance: /* [] */0,
          type_newtype_level: decl_type_newtype_level,
          type_loc: loc,
          type_attributes: /* [] */0
        };
        set_current_time(ty$12.level);
        const match$62 = enter_type(name$3, decl$1, env);
        const id = match$62[0];
        init_def(currentstamp.contents);
        const body$5 = type_exp(match$62[1], lid._1);
        const seen = Stdlib__Hashtbl.create(undefined, 8);
        const replace = function (t) {
          if (Stdlib__Hashtbl.mem(seen, t.id)) {
            return ;
          }
          Stdlib__Hashtbl.add(seen, t.id, undefined);
          const match = t.desc;
          if (typeof match === "number") {
            return iter_type_expr(replace, t);
          }
          if (match.TAG !== /* Tconstr */3) {
            return iter_type_expr(replace, t);
          }
          const id$p = match._0;
          switch (id$p.TAG | 0) {
            case /* Pident */0 :
                if (id === id$p._0) {
                  return link_type(t, ty$12);
                } else {
                  return iter_type_expr(replace, t);
                }
            case /* Pdot */1 :
            case /* Papply */2 :
                return iter_type_expr(replace, t);
            
          }
        };
        const ety = type_expr(identity, body$5.exp_type);
        replace(ety);
        end_def(undefined);
        return rue({
                    exp_desc: body$5.exp_desc,
                    exp_loc: loc,
                    exp_extra: {
                      hd: [
                        {
                          TAG: /* Texp_newtype */4,
                          _0: name$3
                        },
                        loc,
                        sexp.pexp_attributes
                      ],
                      tl: body$5.exp_extra
                    },
                    exp_type: ety,
                    exp_env: body$5.exp_env,
                    exp_attributes: body$5.exp_attributes
                  });
    case /* Pexp_pack */31 :
        const match$63 = expand_head(env, instance(undefined, env, ty_expected));
        const match$64 = match$63.desc;
        let match$65;
        if (typeof match$64 === "number") {
          throw new Caml_js_exceptions.MelangeError($$Error$7, {
                    MEL_EXN_ID: $$Error$7,
                    _1: loc,
                    _2: env,
                    _3: {
                      TAG: /* Not_a_packed_module */32,
                      _0: ty_expected
                    }
                  });
        }
        switch (match$64.TAG | 0) {
          case /* Tvar */0 :
              throw new Caml_js_exceptions.MelangeError($$Error$7, {
                        MEL_EXN_ID: $$Error$7,
                        _1: loc,
                        _2: env,
                        _3: /* Cannot_infer_signature */3
                      });
          case /* Tpackage */11 :
              if (principal.contents && expand_head(env, ty_expected).level < 100000000) {
                prerr_warning(loc, {
                      TAG: /* Not_principal */8,
                      _0: "this module packing"
                    });
              }
              match$65 = [
                match$64._0,
                match$64._1,
                match$64._2
              ];
              break;
          default:
            throw new Caml_js_exceptions.MelangeError($$Error$7, {
                      MEL_EXN_ID: $$Error$7,
                      _1: loc,
                      _2: env,
                      _3: {
                        TAG: /* Not_a_packed_module */32,
                        _0: ty_expected
                      }
                    });
        }
        const nl = match$65[1];
        const p = match$65[0];
        const match$66 = Curry._5(type_package.contents, env, lid._0, p, nl, match$65[2]);
        return rue({
                    exp_desc: {
                      TAG: /* Texp_pack */27,
                      _0: match$66[0]
                    },
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: newty2(current_level.contents, {
                          TAG: /* Tpackage */11,
                          _0: p,
                          _1: nl,
                          _2: match$66[1]
                        }),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_open */32 :
        const lid$6 = lid._1;
        const ovf = lid._0;
        const match$67 = Curry._4(type_open.contents, ovf, env, sexp.pexp_loc, lid$6);
        const newenv = match$67[1];
        const exp$7 = type_expect(undefined, newenv, lid._2, ty_expected);
        return {
                exp_desc: exp$7.exp_desc,
                exp_loc: exp$7.exp_loc,
                exp_extra: {
                  hd: [
                    {
                      TAG: /* Texp_open */2,
                      _0: ovf,
                      _1: match$67[0],
                      _2: lid$6,
                      _3: newenv
                    },
                    loc,
                    sexp.pexp_attributes
                  ],
                  tl: exp$7.exp_extra
                },
                exp_type: exp$7.exp_type,
                exp_env: exp$7.exp_env,
                exp_attributes: exp$7.exp_attributes
              };
    case /* Pexp_extension */33 :
        throw new Caml_js_exceptions.MelangeError(Error_forward$1, {
                  MEL_EXN_ID: Error_forward$1,
                  _1: error_of_extension(lid._0)
                });
    
  }
}

function type_function(in_function, loc, attrs, env, ty_expected, l, caselist) {
  const match = in_function !== undefined ? in_function : [
      loc,
      instance(undefined, env, ty_expected)
    ];
  const ty_fun = match[1];
  const loc_fun = match[0];
  const separate = principal.contents || env.local_constraints;
  if (separate) {
    begin_def(undefined);
  }
  let match$1;
  try {
    match$1 = filter_arrow(env, instance(undefined, env, ty_expected), l);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Unify) {
      const ty = expand_head(env, ty_expected);
      let exit = 0;
      const match$2 = ty.desc;
      if (typeof match$2 === "number") {
        exit = 1;
      } else {
        if (match$2.TAG === /* Tarrow */1) {
          throw new Caml_js_exceptions.MelangeError($$Error$7, {
                    MEL_EXN_ID: $$Error$7,
                    _1: loc,
                    _2: env,
                    _3: {
                      TAG: /* Abstract_wrong_label */27,
                      _0: l,
                      _1: ty
                    }
                  });
        }
        exit = 1;
      }
      if (exit === 1) {
        throw new Caml_js_exceptions.MelangeError($$Error$7, {
                  MEL_EXN_ID: $$Error$7,
                  _1: loc_fun,
                  _2: env,
                  _3: {
                    TAG: /* Too_many_arguments */26,
                    _0: in_function !== undefined,
                    _1: ty_fun
                  }
                });
      }
      
    } else {
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  }
  const ty_res = match$1[1];
  const ty_arg = match$1[0];
  let ty_arg$1;
  if (is_optional(l)) {
    const tv = newvar(undefined, undefined);
    try {
      unify$2(env, ty_arg, type_option$1(tv));
    }
    catch (raw_exn$1){
      const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
      if (exn$1.MEL_EXN_ID === Unify) {
        throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                  MEL_EXN_ID: "Assert_failure",
                  _1: [
                    "jscomp/test/ocaml_typedtree_test.ml",
                    45069,
                    24
                  ]
                });
      }
      throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
    }
    ty_arg$1 = type_option$1(tv);
  } else {
    ty_arg$1 = ty_arg;
  }
  if (separate) {
    end_def(undefined);
    generalize_structure$1(current_level.contents, ty_arg$1);
    generalize_structure$1(current_level.contents, ty_res);
  }
  const match$3 = type_cases([
        loc_fun,
        ty_fun
      ], env, ty_arg$1, ty_res, true, loc, caselist);
  const cases = match$3[0];
  const not_function = function (ty) {
    const match = list_labels(env, ty);
    if (Caml_obj.caml_equal(match[0], /* [] */0)) {
      return !match[1];
    } else {
      return false;
    }
  };
  if (is_optional(l) && not_function(ty_res)) {
    prerr_warning(Stdlib__List.hd(cases).c_lhs.pat_loc, /* Unerasable_optional_argument */8);
  }
  return re({
              exp_desc: {
                TAG: /* Texp_function */3,
                _0: l,
                _1: cases,
                _2: match$3[1]
              },
              exp_loc: loc,
              exp_extra: /* [] */0,
              exp_type: instance(undefined, env, newty2(100000000, {
                        TAG: /* Tarrow */1,
                        _0: l,
                        _1: ty_arg$1,
                        _2: ty_res,
                        _3: /* Cok */0
                      })),
              exp_env: env,
              exp_attributes: attrs
            });
}

function type_label_access(env, loc, srecord, lid) {
  if (principal.contents) {
    begin_def(undefined);
  }
  const record = type_exp(env, srecord);
  if (principal.contents) {
    end_def(undefined);
    generalize_structure$1(current_level.contents, record.exp_type);
  }
  const ty_exp = record.exp_type;
  let opath;
  try {
    const match = extract_concrete_record(env, ty_exp);
    opath = [
      match[0],
      match[1],
      ty_exp.level === 100000000 || !principal.contents
    ];
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      opath = undefined;
    } else {
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  }
  const labels = find_all_labels(env, lid.loc, lid.txt);
  const label = wrap_disambiguate("This expression has", ty_exp, (function (param) {
          return disambiguate(undefined, undefined, undefined, lid, env, opath, param);
        }), labels);
  return [
          record,
          label,
          opath
        ];
}

function type_format(loc, str, env) {
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              45122,
              1
            ]
          });
}

function type_label_exp(create, env, loc, ty_expected, param) {
  const sarg = param[2];
  const label = param[1];
  const lid = param[0];
  begin_def(undefined);
  const separate = principal.contents || env.local_constraints;
  if (separate) {
    begin_def(undefined);
    begin_def(undefined);
  }
  const match = instance_label(true, label);
  const ty_res = match[2];
  const ty_arg = match[1];
  const vars = match[0];
  if (separate) {
    end_def(undefined);
    generalize_structure$1(current_level.contents, ty_arg);
    generalize_structure$1(current_level.contents, ty_res);
  }
  try {
    unify$2(env, instance_def(ty_res), instance(undefined, env, ty_expected));
  }
  catch (raw_trace){
    const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
    if (trace.MEL_EXN_ID === Unify) {
      throw new Caml_js_exceptions.MelangeError($$Error$7, {
                MEL_EXN_ID: $$Error$7,
                _1: lid.loc,
                _2: env,
                _3: {
                  TAG: /* Label_mismatch */2,
                  _0: lid.txt,
                  _1: trace._1
                }
              });
    }
    throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
  }
  const ty_arg$1 = instance_def(ty_arg);
  if (separate) {
    end_def(undefined);
    generalize_structure$1(current_level.contents, ty_arg$1);
  }
  if (label.lbl_private === /* Private */0) {
    if (create) {
      throw new Caml_js_exceptions.MelangeError($$Error$7, {
                MEL_EXN_ID: $$Error$7,
                _1: loc,
                _2: env,
                _3: {
                  TAG: /* Private_type */19,
                  _0: ty_expected
                }
              });
    }
    throw new Caml_js_exceptions.MelangeError($$Error$7, {
              MEL_EXN_ID: $$Error$7,
              _1: lid.loc,
              _2: env,
              _3: {
                TAG: /* Private_label */20,
                _0: lid.txt,
                _1: ty_expected
              }
            });
  }
  const snap = Caml_obj.caml_equal(vars, /* [] */0) ? undefined : Caml_option.some(snapshot(undefined));
  const arg = type_argument(env, sarg, ty_arg$1, instance(undefined, env, ty_arg$1));
  end_def(undefined);
  let arg$1;
  try {
    check_univars(env, Caml_obj.caml_notequal(vars, /* [] */0), "field value", arg, label.lbl_arg, vars);
    arg$1 = arg;
  }
  catch (exn){
    if (is_nonexpansive(arg)) {
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
    try {
      may(backtrack, snap);
      begin_def(undefined);
      const arg$2 = type_exp(env, sarg);
      end_def(undefined);
      generalize_expansive$1(env, arg$2.exp_type);
      unify_exp(env, arg$2, ty_arg$1);
      check_univars(env, false, "field value", arg$2, label.lbl_arg, vars);
      arg$1 = arg$2;
    }
    catch (raw_e){
      const e = Caml_js_exceptions.internalToOCamlException(raw_e);
      if (e.MEL_EXN_ID === $$Error$7) {
        let tmp = e._3;
        if (typeof tmp === "number") {
          throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
        }
        if (tmp.TAG === /* Less_general */31) {
          throw new Caml_js_exceptions.MelangeError(e.MEL_EXN_ID, e);
        }
        throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
      } else {
        throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
      }
    }
  }
  return [
          lid,
          label,
          {
            exp_desc: arg$1.exp_desc,
            exp_loc: arg$1.exp_loc,
            exp_extra: arg$1.exp_extra,
            exp_type: instance(undefined, env, arg$1.exp_type),
            exp_env: arg$1.exp_env,
            exp_attributes: arg$1.exp_attributes
          }
        ];
}

function type_argument(env, sarg, ty_expected$p, ty_expected) {
  const no_labels = function (ty) {
    const match = list_labels(env, ty);
    if (match[1]) {
      return false;
    } else {
      return Stdlib__List.for_all((function (param) {
                    return "" === param;
                  }), match[0]);
    }
  };
  const is_inferred = function (_sexp) {
    while(true) {
      const sexp = _sexp;
      const match = sexp.pexp_desc;
      switch (match.TAG | 0) {
        case /* Pexp_ifthenelse */15 :
            const e2 = match._2;
            if (e2 === undefined) {
              return false;
            }
            if (!is_inferred(match._1)) {
              return false;
            }
            _sexp = e2;
            continue ;
        case /* Pexp_sequence */16 :
            _sexp = match._1;
            continue ;
        case /* Pexp_ident */0 :
        case /* Pexp_apply */5 :
        case /* Pexp_field */12 :
        case /* Pexp_constraint */19 :
        case /* Pexp_coerce */20 :
        case /* Pexp_send */21 :
        case /* Pexp_new */22 :
            return true;
        case /* Pexp_open */32 :
            _sexp = match._2;
            continue ;
        default:
          return false;
      }
    };
  };
  const match = expand_head(env, ty_expected$p);
  const match$1 = match.desc;
  if (typeof match$1 !== "number" && match$1.TAG === /* Tarrow */1 && match$1._0 === "") {
    const ty_res = match$1._2;
    const lv = match.level;
    if (is_inferred(sarg)) {
      if (principal.contents) {
        begin_def(undefined);
      }
      const texp = type_exp(env, sarg);
      if (principal.contents) {
        end_def(undefined);
        generalize_structure$1(current_level.contents, texp.exp_type);
      }
      const make_args = function (_args, _ty_fun) {
        while(true) {
          const ty_fun = _ty_fun;
          const args = _args;
          const match = expand_head(env, ty_fun).desc;
          if (typeof match !== "number") {
            switch (match.TAG | 0) {
              case /* Tvar */0 :
                  return [
                          Stdlib__List.rev(args),
                          ty_fun,
                          false
                        ];
              case /* Tarrow */1 :
                  const l = match._0;
                  if (is_optional(l)) {
                    const ty = option_none(instance(undefined, env, match._1), sarg.pexp_loc);
                    _ty_fun = match._2;
                    _args = {
                      hd: [
                        l,
                        ty,
                        /* Optional */1
                      ],
                      tl: args
                    };
                    continue ;
                  }
                  if (l === "" || classic.contents) {
                    return [
                            Stdlib__List.rev(args),
                            ty_fun,
                            no_labels(match._2)
                          ];
                  }
                  break;
              default:
                
            }
          }
          return [
                  /* [] */0,
                  texp.exp_type,
                  false
                ];
        };
      };
      const match$2 = make_args(/* [] */0, texp.exp_type);
      const ty_fun$p = match$2[1];
      const args = match$2[0];
      const warn = principal.contents && (lv !== 100000000 || repr(ty_fun$p).level !== 100000000);
      const texp_exp_desc = texp.exp_desc;
      const texp_exp_loc = texp.exp_loc;
      const texp_exp_extra = texp.exp_extra;
      const texp_exp_type = instance(undefined, env, texp.exp_type);
      const texp_exp_env = texp.exp_env;
      const texp_exp_attributes = texp.exp_attributes;
      const texp$1 = {
        exp_desc: texp_exp_desc,
        exp_loc: texp_exp_loc,
        exp_extra: texp_exp_extra,
        exp_type: texp_exp_type,
        exp_env: texp_exp_env,
        exp_attributes: texp_exp_attributes
      };
      const ty_fun = instance(undefined, env, ty_fun$p);
      if (match$2[2] || no_labels(ty_res)) {
        unify_exp(env, {
              exp_desc: texp_exp_desc,
              exp_loc: texp_exp_loc,
              exp_extra: texp_exp_extra,
              exp_type: ty_fun,
              exp_env: texp_exp_env,
              exp_attributes: texp_exp_attributes
            }, ty_expected);
        if (Caml_obj.caml_equal(args, /* [] */0)) {
          return texp$1;
        }
        const var_pair = function (name, ty) {
          const id = create(name);
          return [
                  {
                    pat_desc: {
                      TAG: /* Tpat_var */0,
                      _0: id,
                      _1: {
                        txt: name,
                        loc: none
                      }
                    },
                    pat_loc: none,
                    pat_extra: /* [] */0,
                    pat_type: ty,
                    pat_env: env,
                    pat_attributes: /* [] */0
                  },
                  {
                    exp_desc: {
                      TAG: /* Texp_ident */0,
                      _0: {
                        TAG: /* Pident */0,
                        _0: id
                      },
                      _1: {
                        txt: {
                          TAG: /* Lident */0,
                          _0: name
                        },
                        loc: none
                      },
                      _2: {
                        val_type: ty,
                        val_kind: /* Val_reg */0,
                        val_loc: none,
                        val_attributes: /* [] */0
                      }
                    },
                    exp_loc: none,
                    exp_extra: /* [] */0,
                    exp_type: ty,
                    exp_env: env,
                    exp_attributes: /* [] */0
                  }
                ];
        };
        const match$3 = var_pair("eta", match$1._1);
        const eta_var = match$3[1];
        const eta_pat = match$3[0];
        const func = function (texp) {
          const e_exp_desc = {
            TAG: /* Texp_apply */4,
            _0: texp,
            _1: Stdlib.$at(args, {
                  hd: [
                    "",
                    eta_var,
                    /* Required */0
                  ],
                  tl: /* [] */0
                })
          };
          const e_exp_loc = texp.exp_loc;
          const e_exp_extra = texp.exp_extra;
          const e_exp_env = texp.exp_env;
          const e_exp_attributes = texp.exp_attributes;
          const e = {
            exp_desc: e_exp_desc,
            exp_loc: e_exp_loc,
            exp_extra: e_exp_extra,
            exp_type: ty_res,
            exp_env: e_exp_env,
            exp_attributes: e_exp_attributes
          };
          return {
                  exp_desc: {
                    TAG: /* Texp_function */3,
                    _0: "",
                    _1: {
                      hd: {
                        c_lhs: eta_pat,
                        c_guard: undefined,
                        c_rhs: e
                      },
                      tl: /* [] */0
                    },
                    _2: /* Total */1
                  },
                  exp_loc: texp.exp_loc,
                  exp_extra: texp.exp_extra,
                  exp_type: ty_fun,
                  exp_env: texp.exp_env,
                  exp_attributes: texp.exp_attributes
                };
        };
        prerr_warning(texp_exp_loc, {
              TAG: /* Eliminated_optional_arguments */31,
              _0: Stdlib__List.map((function (param) {
                      return param[0];
                    }), args)
            });
        if (warn) {
          prerr_warning(texp_exp_loc, {
                TAG: /* Without_principality */9,
                _0: "eliminated optional argument"
              });
        }
        if (is_nonexpansive(texp$1)) {
          return func(texp$1);
        }
        const match$4 = var_pair("arg", texp_exp_type);
        return re({
                    exp_desc: {
                      TAG: /* Texp_let */2,
                      _0: /* Nonrecursive */0,
                      _1: {
                        hd: {
                          vb_pat: match$4[0],
                          vb_expr: texp$1,
                          vb_attributes: /* [] */0,
                          vb_loc: none
                        },
                        tl: /* [] */0
                      },
                      _2: func(match$4[1])
                    },
                    exp_loc: texp_exp_loc,
                    exp_extra: texp_exp_extra,
                    exp_type: ty_fun,
                    exp_env: texp_exp_env,
                    exp_attributes: texp_exp_attributes
                  });
      }
      unify_exp(env, texp$1, ty_expected);
      return texp$1;
    }
    
  }
  const texp$2 = type_expect(undefined, env, sarg, ty_expected$p);
  unify_exp(env, texp$2, ty_expected);
  return texp$2;
}

function type_application(env, funct, sargs) {
  const result_type = function (omitted, ty_fun) {
    return Stdlib__List.fold_left((function (ty_fun, param) {
                  return newty2(param[2], {
                              TAG: /* Tarrow */1,
                              _0: param[0],
                              _1: param[1],
                              _2: ty_fun,
                              _3: /* Cok */0
                            });
                }), ty_fun, omitted);
  };
  const has_label = function (l, ty_fun) {
    const match = list_labels(env, ty_fun);
    if (match[1]) {
      return true;
    } else {
      return Stdlib__List.mem(l, match[0]);
    }
  };
  const ignored = {
    contents: /* [] */0
  };
  let ignore_labels = true;
  if (!classic.contents) {
    const match = list_labels(env, funct.exp_type);
    let tmp = false;
    if (!match[1]) {
      const labels = Stdlib__List.filter((function (l) {
              return !is_optional(l);
            }), match[0]);
      tmp = Stdlib__List.length(labels) === Stdlib__List.length(sargs) && Stdlib__List.for_all((function (param) {
              return param[0] === "";
            }), sargs) && Stdlib__List.exists((function (l) {
              return l !== "";
            }), labels) && (prerr_warning(funct.exp_loc, /* Labels_omitted */3), true);
    }
    ignore_labels = tmp;
  }
  const warned = {
    contents: false
  };
  const type_args = function (_args, _omitted, _ty_fun, _ty_fun0, _ty_old, _sargs, _more_sargs) {
    while(true) {
      const more_sargs = _more_sargs;
      const sargs = _sargs;
      const ty_old = _ty_old;
      const ty_fun0 = _ty_fun0;
      const ty_fun = _ty_fun;
      const omitted = _omitted;
      const args = _args;
      const match = expand_head(env, ty_fun);
      const match$1 = expand_head(env, ty_fun0);
      let exit = 0;
      const match$2 = match.desc;
      if (typeof match$2 === "number" || match$2.TAG !== /* Tarrow */1) {
        exit = 1;
      } else {
        const ty_fun$1 = match$2._2;
        const ty = match$2._1;
        const l = match$2._0;
        const lv = match.level;
        const match$3 = match$1.desc;
        if (typeof match$3 === "number" || match$3.TAG !== /* Tarrow */1) {
          exit = 1;
        } else {
          const ty0 = match$3._1;
          if ((Caml_obj.caml_notequal(sargs, /* [] */0) || Caml_obj.caml_notequal(more_sargs, /* [] */0)) && Caml_obj.caml_equal(commu_repr(match$2._3), /* Cok */0)) {
            const may_warn = function (loc, w) {
              if (!warned.contents && principal.contents && lv !== 100000000) {
                warned.contents = true;
                return prerr_warning(loc, w);
              }
              
            };
            const name = label_name(l);
            const optional = is_optional(l) ? /* Optional */1 : /* Required */0;
            let match$4;
            if (ignore_labels && !is_optional(l)) {
              if (sargs) {
                const match$5 = sargs.hd;
                throw new Caml_js_exceptions.MelangeError($$Error$7, {
                          MEL_EXN_ID: $$Error$7,
                          _1: match$5[1].pexp_loc,
                          _2: env,
                          _3: {
                            TAG: /* Apply_wrong_label */9,
                            _0: match$5[0],
                            _1: ty_old
                          }
                        });
              }
              if (more_sargs) {
                const match$6 = more_sargs.hd;
                const sarg0 = match$6[1];
                const l$p = match$6[0];
                if (l !== l$p && l$p !== "") {
                  throw new Caml_js_exceptions.MelangeError($$Error$7, {
                            MEL_EXN_ID: $$Error$7,
                            _1: sarg0.pexp_loc,
                            _2: env,
                            _3: {
                              TAG: /* Apply_wrong_label */9,
                              _0: l$p,
                              _1: match
                            }
                          });
                }
                match$4 = [
                  /* [] */0,
                  more_sargs.tl,
                  (function (param) {
                      return type_argument(env, sarg0, ty, ty0);
                    })
                ];
              } else {
                throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                          MEL_EXN_ID: "Assert_failure",
                          _1: [
                            "jscomp/test/ocaml_typedtree_test.ml",
                            45373,
                            16
                          ]
                        });
              }
            } else {
              try {
                let match$7;
                try {
                  const match$8 = extract_label_aux(/* [] */0, name, sargs);
                  const sargs1 = match$8[2];
                  const sarg0$1 = match$8[1];
                  if (Caml_obj.caml_notequal(sargs1, /* [] */0)) {
                    may_warn(sarg0$1.pexp_loc, {
                          TAG: /* Not_principal */8,
                          _0: "commuting this argument"
                        });
                  }
                  match$7 = [
                    match$8[0],
                    sarg0$1,
                    Stdlib.$at(sargs1, match$8[3]),
                    more_sargs
                  ];
                }
                catch (raw_exn){
                  const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                  if (exn.MEL_EXN_ID === Stdlib.Not_found) {
                    const match$9 = extract_label_aux(/* [] */0, name, more_sargs);
                    const sargs1$1 = match$9[2];
                    const sarg0$2 = match$9[1];
                    if (Caml_obj.caml_notequal(sargs1$1, /* [] */0) || Caml_obj.caml_notequal(sargs, /* [] */0)) {
                      may_warn(sarg0$2.pexp_loc, {
                            TAG: /* Not_principal */8,
                            _0: "commuting this argument"
                          });
                    }
                    match$7 = [
                      match$9[0],
                      sarg0$2,
                      Stdlib.$at(sargs, sargs1$1),
                      match$9[3]
                    ];
                  } else {
                    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
                  }
                }
                const sarg0$3 = match$7[1];
                const l$p$1 = match$7[0];
                if (optional === /* Required */0 && is_optional(l$p$1)) {
                  prerr_warning(sarg0$3.pexp_loc, {
                        TAG: /* Nonoptional_label */26,
                        _0: l
                      });
                }
                match$4 = [
                  match$7[2],
                  match$7[3],
                  optional === /* Required */0 || is_optional(l$p$1) ? (function (param) {
                        return type_argument(env, sarg0$3, ty, ty0);
                      }) : (may_warn(sarg0$3.pexp_loc, {
                            TAG: /* Not_principal */8,
                            _0: "using an optional argument here"
                          }), (function (param) {
                          return option_some(type_argument(env, sarg0$3, extract_option_type(env, ty), extract_option_type(env, ty0)));
                        }))
                ];
              }
              catch (raw_exn$1){
                const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
                if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
                  match$4 = [
                    sargs,
                    more_sargs,
                    optional === /* Optional */1 && (Stdlib__List.mem_assoc("", sargs) || Stdlib__List.mem_assoc("", more_sargs)) ? (may_warn(funct.exp_loc, {
                              TAG: /* Without_principality */9,
                              _0: "eliminated optional argument"
                            }), ignored.contents = {
                          hd: [
                            l,
                            ty,
                            lv
                          ],
                          tl: ignored.contents
                        }, (function (param) {
                            return option_none(instance(undefined, env, ty), none);
                          })) : (may_warn(funct.exp_loc, {
                              TAG: /* Without_principality */9,
                              _0: "commuted an argument"
                            }), undefined)
                  ];
                } else {
                  throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
                }
              }
            }
            const arg = match$4[2];
            const sargs$1 = match$4[0];
            const omitted$1 = arg === undefined ? ({
                  hd: [
                    l,
                    ty,
                    lv
                  ],
                  tl: omitted
                }) : omitted;
            const ty_old$1 = Caml_obj.caml_equal(sargs$1, /* [] */0) ? ty_fun$1 : ty_old;
            _more_sargs = match$4[1];
            _sargs = sargs$1;
            _ty_old = ty_old$1;
            _ty_fun0 = match$3._2;
            _ty_fun = ty_fun$1;
            _omitted = omitted$1;
            _args = {
              hd: [
                l,
                arg,
                optional
              ],
              tl: args
            };
            continue ;
          }
          exit = 1;
        }
      }
      if (exit === 1) {
        let exit$1 = 0;
        if (sargs) {
          if (ignore_labels) {
            const match$10 = sargs.hd;
            throw new Caml_js_exceptions.MelangeError($$Error$7, {
                      MEL_EXN_ID: $$Error$7,
                      _1: match$10[1].pexp_loc,
                      _2: env,
                      _3: {
                        TAG: /* Apply_wrong_label */9,
                        _0: match$10[0],
                        _1: ty_old
                      }
                    });
          }
          exit$1 = 2;
        } else {
          exit$1 = 2;
        }
        if (exit$1 === 2) {
          let _args$1 = args;
          let _ty_fun$1 = ty_fun0;
          let _param = Stdlib.$at(sargs, more_sargs);
          while(true) {
            const param = _param;
            const ty_fun$2 = _ty_fun$1;
            const args$1 = _args$1;
            if (!param) {
              return [
                      Stdlib__List.map((function (param) {
                              const f = param[1];
                              const l = param[0];
                              if (f !== undefined) {
                                return [
                                        l,
                                        Curry._1(f, undefined),
                                        param[2]
                                      ];
                              } else {
                                return [
                                        l,
                                        undefined,
                                        param[2]
                                      ];
                              }
                            }), Stdlib__List.rev(args$1)),
                      instance(undefined, env, result_type(omitted, ty_fun$2))
                    ];
            }
            const match$11 = param.hd;
            const sarg1 = match$11[1];
            const l1 = match$11[0];
            const ty_fun$3 = expand_head(env, ty_fun$2);
            const td = ty_fun$3.desc;
            let match$12;
            let exit$2 = 0;
            if (typeof td === "number") {
              exit$2 = 1;
            } else {
              switch (td.TAG | 0) {
                case /* Tvar */0 :
                    const t1 = newvar(undefined, undefined);
                    const t2 = newvar(undefined, undefined);
                    const not_identity = function (param) {
                      if (param.TAG !== /* Texp_ident */0) {
                        return true;
                      }
                      const match = param._2.val_kind;
                      if (typeof match === "number" || !(match.TAG === /* Val_prim */0 && match._0.prim_name === "%identity")) {
                        return true;
                      } else {
                        return false;
                      }
                    };
                    if (ty_fun$3.level >= t1.level && not_identity(funct.exp_desc)) {
                      prerr_warning(sarg1.pexp_loc, /* Unused_argument */9);
                    }
                    unify$2(env, ty_fun$3, newty2(current_level.contents, {
                              TAG: /* Tarrow */1,
                              _0: l1,
                              _1: t1,
                              _2: t2,
                              _3: /* Clink */{
                                _0: {
                                  contents: /* Cunknown */1
                                }
                              }
                            }));
                    match$12 = [
                      t1,
                      t2
                    ];
                    break;
                case /* Tarrow */1 :
                    const l$1 = td._0;
                    if (l$1 === l1 || classic.contents && l1 === "" && !is_optional(l$1)) {
                      match$12 = [
                        td._1,
                        td._2
                      ];
                    } else {
                      exit$2 = 1;
                    }
                    break;
                default:
                  exit$2 = 1;
              }
            }
            if (exit$2 === 1) {
              let ty_fun$4;
              ty_fun$4 = typeof td === "number" || td.TAG !== /* Tarrow */1 ? ty_fun$3 : newty2(current_level.contents, td);
              const ty_res = result_type(Stdlib.$at(omitted, ignored.contents), ty_fun$4);
              const match$13 = ty_res.desc;
              let exit$3 = 0;
              if (typeof match$13 === "number") {
                exit$3 = 2;
              } else {
                if (match$13.TAG === /* Tarrow */1) {
                  if (classic.contents || !has_label(l1, ty_fun$4)) {
                    throw new Caml_js_exceptions.MelangeError($$Error$7, {
                              MEL_EXN_ID: $$Error$7,
                              _1: sarg1.pexp_loc,
                              _2: env,
                              _3: {
                                TAG: /* Apply_wrong_label */9,
                                _0: l1,
                                _1: ty_res
                              }
                            });
                  }
                  throw new Caml_js_exceptions.MelangeError($$Error$7, {
                            MEL_EXN_ID: $$Error$7,
                            _1: funct.exp_loc,
                            _2: env,
                            _3: /* Incoherent_label_order */1
                          });
                }
                exit$3 = 2;
              }
              if (exit$3 === 2) {
                throw new Caml_js_exceptions.MelangeError($$Error$7, {
                          MEL_EXN_ID: $$Error$7,
                          _1: funct.exp_loc,
                          _2: env,
                          _3: {
                            TAG: /* Apply_non_function */8,
                            _0: expand_head(env, funct.exp_type)
                          }
                        });
              }
              
            }
            const ty1 = match$12[0];
            const optional$1 = is_optional(l1) ? /* Optional */1 : /* Required */0;
            const arg1 = function (param) {
              const arg1$1 = type_expect(undefined, env, sarg1, ty1);
              if (optional$1 === /* Optional */1) {
                unify_exp(env, arg1$1, type_option$1(newvar(undefined, undefined)));
              }
              return arg1$1;
            };
            _param = param.tl;
            _ty_fun$1 = match$12[1];
            _args$1 = {
              hd: [
                l1,
                arg1,
                optional$1
              ],
              tl: args$1
            };
            continue ;
          };
        }
        
      }
      
    };
  };
  const match$1 = funct.exp_desc;
  if (match$1.TAG === /* Texp_ident */0) {
    const match$2 = match$1._2.val_kind;
    if (typeof match$2 !== "number" && match$2.TAG === /* Val_prim */0 && match$2._0.prim_name === "%ignore" && sargs) {
      const match$3 = sargs.hd;
      if (match$3[0] === "" && !sargs.tl) {
        const match$4 = filter_arrow(env, instance(undefined, env, funct.exp_type), "");
        const exp = type_expect(undefined, env, match$3[1], match$4[0]);
        const match$5 = expand_head(env, exp.exp_type).desc;
        if (typeof match$5 !== "number") {
          switch (match$5.TAG | 0) {
            case /* Tvar */0 :
                add_delayed_check(function (param) {
                      check_application_result(env, false, exp);
                    });
                break;
            case /* Tarrow */1 :
                prerr_warning(exp.exp_loc, /* Partial_application */2);
                break;
            default:
              
          }
        }
        return [
                {
                  hd: [
                    "",
                    exp,
                    /* Required */0
                  ],
                  tl: /* [] */0
                },
                match$4[1]
              ];
      }
      
    }
    
  }
  const ty = funct.exp_type;
  if (ignore_labels) {
    return type_args(/* [] */0, /* [] */0, ty, instance(undefined, env, ty), ty, /* [] */0, sargs);
  } else {
    return type_args(/* [] */0, /* [] */0, ty, instance(undefined, env, ty), ty, sargs, /* [] */0);
  }
}

function type_statement(env, sexp) {
  const loc = final_subexpression(sexp).pexp_loc;
  begin_def(undefined);
  const exp = type_exp(env, sexp);
  end_def(undefined);
  if (strict_sequence.contents) {
    const expected_ty = instance_def(type_unit);
    unify_exp(env, exp, expected_ty);
    return exp;
  }
  const ty = expand_head(env, exp.exp_type);
  const tv = newvar(undefined, undefined);
  const match = ty.desc;
  if (typeof match === "number") {
    prerr_warning(loc, /* Statement_type */4);
  } else {
    switch (match.TAG | 0) {
      case /* Tvar */0 :
          if (ty.level > tv.level) {
            prerr_warning(loc, /* Nonreturning_statement */10);
          } else {
            add_delayed_check(function (param) {
                  check_application_result(env, true, exp);
                });
          }
          break;
      case /* Tarrow */1 :
          prerr_warning(loc, /* Partial_application */2);
          break;
      case /* Tconstr */3 :
          if (same(match._0, path_unit)) {
            
          } else {
            prerr_warning(loc, /* Statement_type */4);
          }
          break;
      default:
        prerr_warning(loc, /* Statement_type */4);
    }
  }
  unify_var(env, tv, ty);
  return exp;
}

function type_cases(in_function, env, ty_arg, ty_res, partial_flag, loc, caselist) {
  const patterns = Stdlib__List.map((function (param) {
          return param.pc_lhs;
        }), caselist);
  const erase_either = Stdlib__List.exists(contains_polymorphic_variant, patterns) && contains_variant_either(ty_arg);
  const has_gadts = Stdlib__List.exists((function (param) {
          return contains_gadt(env, param);
        }), patterns);
  const ty_arg$1 = (has_gadts || erase_either) && !principal.contents ? type_expr(identity, ty_arg) : ty_arg;
  const match = has_gadts && !principal.contents ? [
      type_expr(identity, ty_res),
      duplicate_ident_types(loc, caselist, env)
    ] : [
      ty_res,
      env
    ];
  const env$1 = match[1];
  const ty_res$1 = match[0];
  let match$1;
  if (has_gadts) {
    begin_def(undefined);
    set_current_time(current_level.contents);
    const lev = currentstamp.contents;
    init_def(lev + 1000 | 0);
    match$1 = [
      lev,
      add_gadt_instance_level(lev, env$1)
    ];
  } else {
    match$1 = [
      current_level.contents,
      env$1
    ];
  }
  const env$2 = match$1[1];
  const lev$1 = match$1[0];
  begin_def(undefined);
  const ty_arg$p = newvar(undefined, undefined);
  const pattern_force = {
    contents: /* [] */0
  };
  const pat_env_list = Stdlib__List.map((function (param) {
          const pc_rhs = param.pc_rhs;
          const pc_guard = param.pc_guard;
          let loc;
          if (pc_guard !== undefined) {
            const init = pc_rhs.pexp_loc;
            loc = {
              loc_start: pc_guard.pexp_loc.loc_start,
              loc_end: init.loc_end,
              loc_ghost: init.loc_ghost
            };
          } else {
            loc = pc_rhs.pexp_loc;
          }
          if (principal.contents) {
            begin_def(undefined);
          }
          const scope = {
            TAG: /* Idef */1,
            _0: loc
          };
          const partial = principal.contents || erase_either ? false : undefined;
          const ty_arg$2 = instance(partial, env$2, ty_arg$1);
          const match = type_pattern(lev$1, env$2, param.pc_lhs, scope, ty_arg$2);
          const pat = match[0];
          pattern_force.contents = Stdlib.$at(match[2], pattern_force.contents);
          const pat$1 = principal.contents ? (end_def(undefined), iter_pattern((function (param) {
                      generalize_structure$1(current_level.contents, param.pat_type);
                    }), pat), {
                pat_desc: pat.pat_desc,
                pat_loc: pat.pat_loc,
                pat_extra: pat.pat_extra,
                pat_type: instance(undefined, env$2, pat.pat_type),
                pat_env: pat.pat_env,
                pat_attributes: pat.pat_attributes
              }) : pat;
          return [
                  pat$1,
                  [
                    match[1],
                    match[3]
                  ]
                ];
        }), caselist);
  const patl = Stdlib__List.map((function (prim) {
          return prim[0];
        }), pat_env_list);
  Stdlib__List.iter((function (pat) {
          unify_pat(env$2, pat, ty_arg$p);
        }), patl);
  if (Stdlib__List.exists(has_variants, patl)) {
    pressure_variants$1(env$2, patl);
    Stdlib__List.iter((function (param) {
            return iter_pattern(finalize_variant, param);
          }), patl);
  }
  Stdlib__List.iter((function (f) {
          Curry._1(f, undefined);
        }), pattern_force.contents);
  Stdlib__List.iter((function (param) {
          return iter_pattern((function (param) {
                        unify_var(env$2, param.pat_type, newvar(undefined, undefined));
                      }), param);
        }), patl);
  Stdlib__List.iter((function (pat) {
          unify_pat(env$2, pat, instance(undefined, env$2, ty_arg$1));
        }), patl);
  end_def(undefined);
  Stdlib__List.iter((function (param) {
          return iter_pattern((function (param) {
                        iter_generalize$1({
                              contents: /* [] */0
                            }, param.pat_type);
                      }), param);
        }), patl);
  const in_function$1 = Stdlib__List.length(caselist) === 1 ? in_function : undefined;
  const cases = Stdlib__List.map2((function (param, param$1) {
          const pc_guard = param$1.pc_guard;
          const match = param[1];
          const unpacks = match[1];
          const ext_env = match[0];
          const sexp = wrap_unpacks(param$1.pc_rhs, unpacks);
          let ty_res$p;
          if (principal.contents) {
            begin_def(undefined);
            const ty = instance(true, env$2, ty_res$1);
            end_def(undefined);
            generalize_structure$1(current_level.contents, ty);
            ty_res$p = ty;
          } else {
            ty_res$p = contains_gadt(env$2, param$1.pc_lhs) ? type_expr(identity, ty_res$1) : ty_res$1;
          }
          const guard = pc_guard !== undefined ? type_expect(undefined, ext_env, wrap_unpacks(pc_guard, unpacks), type_bool) : undefined;
          const exp = type_expect(in_function$1, ext_env, sexp, ty_res$p);
          return {
                  c_lhs: param[0],
                  c_guard: guard,
                  c_rhs: {
                    exp_desc: exp.exp_desc,
                    exp_loc: exp.exp_loc,
                    exp_extra: exp.exp_extra,
                    exp_type: instance(undefined, env$2, ty_res$p),
                    exp_env: exp.exp_env,
                    exp_attributes: exp.exp_attributes
                  }
                };
        }), pat_env_list, caselist);
  if (principal.contents || has_gadts) {
    const ty_res$p = instance(undefined, env$2, ty_res$1);
    Stdlib__List.iter((function (c) {
            unify_exp(env$2, c.c_rhs, ty_res$p);
          }), cases);
  }
  const partial = partial_flag ? check_partial$1(lev$1, env$2, ty_arg$1)(loc, cases) : /* Partial */0;
  add_delayed_check(function (param) {
        Stdlib__List.iter((function (param) {
                check_absent_variant(param[1][0])(param[0]);
              }), pat_env_list);
        if (!is_active(/* Unused_match */5)) {
          return ;
        }
        let _pref = /* [] */0;
        let _param = cases;
        while(true) {
          const param$1 = _param;
          const pref = _pref;
          if (!param$1) {
            return ;
          }
          const rem = param$1.tl;
          const match = param$1.hd;
          const q = match.c_lhs;
          const qs = {
            hd: q,
            tl: /* [] */0
          };
          try {
            const pss = get_mins(le_pats, Stdlib__List.filter((function (param) {
                        return compats(qs, param);
                      }), pref));
            const r = every_satisfiables(Stdlib__List.map(make_row, pss), {
                  no_ors: /* [] */0,
                  ors: /* [] */0,
                  active: qs
                });
            if (typeof r === "number") {
              if (r) {
                prerr_warning(q.pat_loc, /* Unused_match */5);
              }
              
            } else {
              Stdlib__List.iter((function (p) {
                      prerr_warning(p.pat_loc, /* Unused_pat */6);
                    }), r._0);
            }
          }
          catch (raw_exn){
            const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            let exit = 0;
            if (exn.MEL_EXN_ID === Empty || exn.MEL_EXN_ID === Stdlib.Not_found || exn.MEL_EXN_ID === NoGuard) {
              exit = 1;
            } else {
              throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
            }
            if (exit === 1) {
              throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                        MEL_EXN_ID: "Assert_failure",
                        _1: [
                          "jscomp/test/ocaml_typedtree_test.ml",
                          40982,
                          48
                        ]
                      });
            }
            
          }
          if (match.c_guard !== undefined) {
            _param = rem;
            continue ;
          }
          _param = rem;
          _pref = {
            hd: {
              hd: q,
              tl: /* [] */0
            },
            tl: pref
          };
          continue ;
        };
      });
  if (has_gadts) {
    end_def(undefined);
    unify_exp_types(loc, env$2, instance(undefined, env$2, ty_res$1), newvar(undefined, undefined));
  }
  return [
          cases,
          partial
        ];
}

function type_let(checkOpt, check_strictOpt, env, rec_flag, spat_sexp_list, scope, allow) {
  const check = checkOpt !== undefined ? checkOpt : (function (s) {
        return {
                TAG: /* Unused_var */12,
                _0: s
              };
      });
  const check_strict = check_strictOpt !== undefined ? check_strictOpt : (function (s) {
        return {
                TAG: /* Unused_var_strict */13,
                _0: s
              };
      });
  begin_def(undefined);
  if (principal.contents) {
    begin_def(undefined);
  }
  let is_fake_let;
  if (spat_sexp_list) {
    const match = spat_sexp_list.hd.pvb_expr.pexp_desc;
    if (match.TAG === /* Pexp_match */6) {
      const match$1 = match._0.pexp_desc;
      if (match$1.TAG === /* Pexp_ident */0) {
        const match$2 = match$1._0.txt;
        switch (match$2.TAG | 0) {
          case /* Lident */0 :
              is_fake_let = match$2._0 === "*opt*" && !spat_sexp_list.tl ? true : false;
              break;
          case /* Ldot */1 :
          case /* Lapply */2 :
              is_fake_let = false;
              break;
          
        }
      } else {
        is_fake_let = false;
      }
    } else {
      is_fake_let = false;
    }
  } else {
    is_fake_let = false;
  }
  const check$1 = is_fake_let ? check_strict : check;
  const spatl = Stdlib__List.map((function (param) {
          const spat = param.pvb_pat;
          const match = spat.ppat_desc;
          const match$1 = param.pvb_expr.pexp_desc;
          let sty;
          if (typeof match === "number") {
            return spat;
          }
          if (match.TAG === /* Ppat_constraint */10) {
            return spat;
          }
          switch (match$1.TAG | 0) {
            case /* Pexp_constraint */19 :
                sty = match$1._1;
                break;
            case /* Pexp_coerce */20 :
                sty = match$1._2;
                break;
            default:
              return spat;
          }
          if (!principal.contents) {
            return spat;
          }
          const init = spat.ppat_loc;
          return constraint_({
                      loc_start: init.loc_start,
                      loc_end: init.loc_end,
                      loc_ghost: true
                    }, undefined, spat, sty);
        }), spat_sexp_list);
  const nvs = Stdlib__List.map((function (param) {
          return newvar(undefined, undefined);
        }), spatl);
  const match$3 = type_pattern_list(env, spatl, scope, nvs, allow);
  const unpacks = match$3[3];
  const new_env = match$3[1];
  const pat_list = match$3[0];
  const is_recursive = rec_flag === /* Recursive */1;
  if (is_recursive) {
    Stdlib__List.iter2((function (pat, binding) {
            const match = pat.pat_type.desc;
            let pat$1;
            pat$1 = typeof match === "number" || match.TAG !== /* Tpoly */10 ? pat : ({
                  pat_desc: pat.pat_desc,
                  pat_loc: pat.pat_loc,
                  pat_extra: pat.pat_extra,
                  pat_type: instance_poly(true, false, match._1, match._0)[1],
                  pat_env: pat.pat_env,
                  pat_attributes: pat.pat_attributes
                });
            unify_pat(env, pat$1, type_approx(env, binding.pvb_expr));
          }), pat_list, spat_sexp_list);
  }
  Stdlib__List.iter((function (pat) {
          if (has_variants(pat)) {
            pressure_variants$1(env, {
                  hd: pat,
                  tl: /* [] */0
                });
            return iter_pattern(finalize_variant, pat);
          }
          
        }), pat_list);
  const pat_list$1 = principal.contents ? (end_def(undefined), Stdlib__List.map((function (pat) {
              iter_pattern((function (pat) {
                      generalize_structure$1(current_level.contents, pat.pat_type);
                    }), pat);
              return {
                      pat_desc: pat.pat_desc,
                      pat_loc: pat.pat_loc,
                      pat_extra: pat.pat_extra,
                      pat_type: instance(undefined, env, pat.pat_type),
                      pat_env: pat.pat_env,
                      pat_attributes: pat.pat_attributes
                    };
            }), pat_list)) : pat_list;
  Stdlib__List.iter((function (f) {
          Curry._1(f, undefined);
        }), match$3[2]);
  const exp_env = is_recursive ? new_env : env;
  const current_slot = {
    contents: undefined
  };
  const rec_needed = {
    contents: false
  };
  const warn_unused = is_active(Curry._1(check$1, "")) || is_active(Curry._1(check_strict, "")) || is_recursive && is_active(/* Unused_rec_flag */15);
  const pat_slot_list = Stdlib__List.map((function (pat) {
          if (!warn_unused) {
            return [
                    pat,
                    undefined
                  ];
          }
          const some_used = {
            contents: false
          };
          const slot = {
            contents: /* [] */0
          };
          Stdlib__List.iter((function (param) {
                  const id = param[0];
                  const vd = find_value({
                        TAG: /* Pident */0,
                        _0: id
                      }, new_env);
                  const name = id.name;
                  const used = {
                    contents: false
                  };
                  if (!(name === "" || Caml_string.get(name, 0) === /* '_' */95 || Caml_string.get(name, 0) === /* '#' */35)) {
                    add_delayed_check(function (param) {
                          if (!used.contents) {
                            return prerr_warning(vd.val_loc, Curry._1(some_used.contents ? check_strict : check$1, name));
                          }
                          
                        });
                  }
                  const callback = function (param) {
                    const slot$1 = current_slot.contents;
                    if (slot$1 !== undefined) {
                      slot$1.contents = {
                        hd: [
                          name,
                          vd
                        ],
                        tl: slot$1.contents
                      };
                      rec_needed.contents = true;
                    } else {
                      Stdlib__List.iter((function (param) {
                              mark_value_used(env, param[0], param[1]);
                            }), get_ref(slot));
                      used.contents = true;
                      some_used.contents = true;
                    }
                  };
                  const key_1 = vd.val_loc;
                  const key = [
                    name,
                    key_1
                  ];
                  try {
                    const old = Stdlib__Hashtbl.find(value_declarations, key);
                    return Stdlib__Hashtbl.replace(value_declarations, key, (function (param) {
                                  Curry._1(old, undefined);
                                  Curry._1(callback, undefined);
                                }));
                  }
                  catch (raw_exn){
                    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
                      return Stdlib__Hashtbl.add(value_declarations, key, callback);
                    }
                    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
                  }
                }), pat_bound_idents(pat));
          return [
                  pat,
                  slot
                ];
        }), pat_list$1);
  const exp_list = Stdlib__List.map2((function (param, param$1) {
          const pat = param$1[0];
          const sexp = param.pvb_expr;
          const sexp$1 = rec_flag === /* Recursive */1 ? wrap_unpacks(sexp, unpacks) : sexp;
          if (is_recursive) {
            current_slot.contents = param$1[1];
          }
          const match = pat.pat_type.desc;
          if (typeof match === "number") {
            return type_expect(undefined, exp_env, sexp$1, pat.pat_type);
          }
          if (match.TAG !== /* Tpoly */10) {
            return type_expect(undefined, exp_env, sexp$1, pat.pat_type);
          }
          begin_def(undefined);
          if (principal.contents) {
            begin_def(undefined);
          }
          const match$1 = instance_poly(true, true, match._1, match._0);
          const ty$p = match$1[1];
          if (principal.contents) {
            end_def(undefined);
            generalize_structure$1(current_level.contents, ty$p);
          }
          const exp = type_expect(undefined, exp_env, sexp$1, ty$p);
          end_def(undefined);
          check_univars(env, true, "definition", exp, pat.pat_type, match$1[0]);
          return {
                  exp_desc: exp.exp_desc,
                  exp_loc: exp.exp_loc,
                  exp_extra: exp.exp_extra,
                  exp_type: instance(undefined, env, exp.exp_type),
                  exp_env: exp.exp_env,
                  exp_attributes: exp.exp_attributes
                };
        }), spat_sexp_list, pat_slot_list);
  current_slot.contents = undefined;
  if (is_recursive && !rec_needed.contents && is_active(/* Unused_rec_flag */15)) {
    prerr_warning(Stdlib__List.hd(spat_sexp_list).pvb_pat.ppat_loc, /* Unused_rec_flag */15);
  }
  Stdlib__List.iter2((function (pat, exp) {
          check_partial$1(undefined, env, pat.pat_type)(pat.pat_loc, {
                hd: {
                  c_lhs: pat,
                  c_guard: undefined,
                  c_rhs: exp
                },
                tl: /* [] */0
              });
        }), pat_list$1, exp_list);
  end_def(undefined);
  Stdlib__List.iter2((function (pat, exp) {
          if (!is_nonexpansive(exp)) {
            return iter_pattern((function (pat) {
                          generalize_expansive$1(env, pat.pat_type);
                        }), pat);
          }
          
        }), pat_list$1, exp_list);
  Stdlib__List.iter((function (pat) {
          iter_pattern((function (pat) {
                  iter_generalize$1({
                        contents: /* [] */0
                      }, pat.pat_type);
                }), pat);
        }), pat_list$1);
  const l = Stdlib__List.combine(pat_list$1, exp_list);
  const l$1 = Stdlib__List.map2((function (param, pvb) {
          return {
                  vb_pat: param[0],
                  vb_expr: param[1],
                  vb_attributes: pvb.pvb_attributes,
                  vb_loc: pvb.pvb_loc
                };
        }), l, spat_sexp_list);
  return [
          l$1,
          new_env,
          unpacks
        ];
}

function type_binding(env, rec_flag, spat_sexp_list, scope) {
  reset_type_variables(undefined);
  const match = type_let((function (s) {
          return {
                  TAG: /* Unused_value_declaration */16,
                  _0: s
                };
        }), (function (s) {
          return {
                  TAG: /* Unused_value_declaration */16,
                  _0: s
                };
        }), env, rec_flag, spat_sexp_list, scope, false);
  return [
          match[0],
          match[1]
        ];
}

function type_let$1(env, rec_flag, spat_sexp_list, scope) {
  const match = type_let(undefined, undefined, env, rec_flag, spat_sexp_list, scope, false);
  return [
          match[0],
          match[1]
        ];
}

function type_expression(env, sexp) {
  reset_type_variables(undefined);
  begin_def(undefined);
  const exp = type_exp(env, sexp);
  end_def(undefined);
  if (is_nonexpansive(exp)) {
    iter_generalize$1({
          contents: /* [] */0
        }, exp.exp_type);
  } else {
    generalize_expansive$1(env, exp.exp_type);
  }
  const lid = sexp.pexp_desc;
  if (lid.TAG !== /* Pexp_ident */0) {
    return exp;
  }
  const match = lookup_value$1(lid._0.txt, env);
  return {
          exp_desc: exp.exp_desc,
          exp_loc: exp.exp_loc,
          exp_extra: exp.exp_extra,
          exp_type: match[1].val_type,
          exp_env: exp.exp_env,
          exp_attributes: exp.exp_attributes
        };
}

register_error_of_exn(function (err) {
      if (err.MEL_EXN_ID !== $$Error$7) {
        if (err.MEL_EXN_ID === Error_forward$1) {
          return err._1;
        } else {
          return ;
        }
      }
      const env = err._2;
      return error_of_printer(err._1, (function (param, param$1) {
                    return wrap_printing_env(env, (function (param$2) {
                                  if (typeof param$1 === "number") {
                                    switch (param$1) {
                                      case /* Outside_class */0 :
                                          return Stdlib__Format.fprintf(param)(/* Format */{
                                                      _0: {
                                                        TAG: /* String_literal */11,
                                                        _0: "This object duplication occurs outside a method definition",
                                                        _1: /* End_of_format */0
                                                      },
                                                      _1: "This object duplication occurs outside a method definition"
                                                    });
                                      case /* Incoherent_label_order */1 :
                                          Stdlib__Format.fprintf(param)(/* Format */{
                                                _0: {
                                                  TAG: /* String_literal */11,
                                                  _0: "This function is applied to arguments",
                                                  _1: {
                                                    TAG: /* Formatting_lit */17,
                                                    _0: {
                                                      TAG: /* Break */0,
                                                      _0: "@ ",
                                                      _1: 1,
                                                      _2: 0
                                                    },
                                                    _1: /* End_of_format */0
                                                  }
                                                },
                                                _1: "This function is applied to arguments@ "
                                              });
                                          Stdlib__Format.fprintf(param)(/* Format */{
                                                _0: {
                                                  TAG: /* String_literal */11,
                                                  _0: "in an order different from other calls.",
                                                  _1: {
                                                    TAG: /* Formatting_lit */17,
                                                    _0: {
                                                      TAG: /* Break */0,
                                                      _0: "@ ",
                                                      _1: 1,
                                                      _2: 0
                                                    },
                                                    _1: /* End_of_format */0
                                                  }
                                                },
                                                _1: "in an order different from other calls.@ "
                                              });
                                          return Stdlib__Format.fprintf(param)(/* Format */{
                                                      _0: {
                                                        TAG: /* String_literal */11,
                                                        _0: "This is only allowed when the real type is known.",
                                                        _1: /* End_of_format */0
                                                      },
                                                      _1: "This is only allowed when the real type is known."
                                                    });
                                      case /* Modules_not_allowed */2 :
                                          return Stdlib__Format.fprintf(param)(/* Format */{
                                                      _0: {
                                                        TAG: /* String_literal */11,
                                                        _0: "Modules are not allowed in this pattern.",
                                                        _1: /* End_of_format */0
                                                      },
                                                      _1: "Modules are not allowed in this pattern."
                                                    });
                                      case /* Cannot_infer_signature */3 :
                                          return Stdlib__Format.fprintf(param)(/* Format */{
                                                      _0: {
                                                        TAG: /* String_literal */11,
                                                        _0: "The signature for this packaged module couldn't be inferred.",
                                                        _1: /* End_of_format */0
                                                      },
                                                      _1: "The signature for this packaged module couldn't be inferred."
                                                    });
                                      case /* Unexpected_existential */4 :
                                          return Stdlib__Format.fprintf(param)(/* Format */{
                                                      _0: {
                                                        TAG: /* String_literal */11,
                                                        _0: "Unexpected existential",
                                                        _1: /* End_of_format */0
                                                      },
                                                      _1: "Unexpected existential"
                                                    });
                                      case /* Invalid_interval */5 :
                                          return Stdlib__Format.fprintf(param)(/* Format */{
                                                      _0: {
                                                        TAG: /* Formatting_gen */18,
                                                        _0: {
                                                          TAG: /* Open_box */1,
                                                          _0: /* Format */{
                                                            _0: /* End_of_format */0,
                                                            _1: ""
                                                          }
                                                        },
                                                        _1: {
                                                          TAG: /* String_literal */11,
                                                          _0: "Only character intervals are supported in patterns.",
                                                          _1: {
                                                            TAG: /* Formatting_lit */17,
                                                            _0: /* Close_box */0,
                                                            _1: /* End_of_format */0
                                                          }
                                                        }
                                                      },
                                                      _1: "@[Only character intervals are supported in patterns.@]"
                                                    });
                                      case /* Invalid_for_loop_index */6 :
                                          return Stdlib__Format.fprintf(param)(/* Format */{
                                                      _0: {
                                                        TAG: /* Formatting_gen */18,
                                                        _0: {
                                                          TAG: /* Open_box */1,
                                                          _0: /* Format */{
                                                            _0: /* End_of_format */0,
                                                            _1: ""
                                                          }
                                                        },
                                                        _1: {
                                                          TAG: /* String_literal */11,
                                                          _0: "Invalid for-loop index: only variables and _ are allowed.",
                                                          _1: {
                                                            TAG: /* Formatting_lit */17,
                                                            _0: /* Close_box */0,
                                                            _1: /* End_of_format */0
                                                          }
                                                        }
                                                      },
                                                      _1: "@[Invalid for-loop index: only variables and _ are allowed.@]"
                                                    });
                                      case /* No_value_clauses */7 :
                                          return Stdlib__Format.fprintf(param)(/* Format */{
                                                      _0: {
                                                        TAG: /* String_literal */11,
                                                        _0: "None of the patterns in this 'match' expression match values.",
                                                        _1: /* End_of_format */0
                                                      },
                                                      _1: "None of the patterns in this 'match' expression match values."
                                                    });
                                      case /* Exception_pattern_below_toplevel */8 :
                                          return Stdlib__Format.fprintf(param)(/* Format */{
                                                      _0: {
                                                        TAG: /* Formatting_gen */18,
                                                        _0: {
                                                          TAG: /* Open_box */1,
                                                          _0: /* Format */{
                                                            _0: /* End_of_format */0,
                                                            _1: ""
                                                          }
                                                        },
                                                        _1: {
                                                          TAG: /* String_literal */11,
                                                          _0: "Exception patterns must be at the top level of a match case.",
                                                          _1: {
                                                            TAG: /* Formatting_lit */17,
                                                            _0: /* Close_box */0,
                                                            _1: /* End_of_format */0
                                                          }
                                                        }
                                                      },
                                                      _1: "@[Exception patterns must be at the top level of a match case.@]"
                                                    });
                                      
                                    }
                                  } else {
                                    switch (param$1.TAG | 0) {
                                      case /* Polymorphic_label */0 :
                                          return Curry._3(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* Formatting_gen */18,
                                                            _0: {
                                                              TAG: /* Open_box */1,
                                                              _0: /* Format */{
                                                                _0: /* End_of_format */0,
                                                                _1: ""
                                                              }
                                                            },
                                                            _1: {
                                                              TAG: /* String_literal */11,
                                                              _0: "The record field ",
                                                              _1: {
                                                                TAG: /* Alpha */15,
                                                                _0: {
                                                                  TAG: /* String_literal */11,
                                                                  _0: " is polymorphic.",
                                                                  _1: {
                                                                    TAG: /* Formatting_lit */17,
                                                                    _0: {
                                                                      TAG: /* Break */0,
                                                                      _0: "@ ",
                                                                      _1: 1,
                                                                      _2: 0
                                                                    },
                                                                    _1: {
                                                                      TAG: /* String */2,
                                                                      _0: /* No_padding */0,
                                                                      _1: {
                                                                        TAG: /* Formatting_lit */17,
                                                                        _0: /* Close_box */0,
                                                                        _1: /* End_of_format */0
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          },
                                                          _1: "@[The record field %a is polymorphic.@ %s@]"
                                                        }), longident, param$1._0, "You cannot instantiate it in a pattern.");
                                      case /* Constructor_arity_mismatch */1 :
                                          return Curry._4(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* Formatting_gen */18,
                                                            _0: {
                                                              TAG: /* Open_box */1,
                                                              _0: /* Format */{
                                                                _0: /* End_of_format */0,
                                                                _1: ""
                                                              }
                                                            },
                                                            _1: {
                                                              TAG: /* String_literal */11,
                                                              _0: "The constructor ",
                                                              _1: {
                                                                TAG: /* Alpha */15,
                                                                _0: {
                                                                  TAG: /* Formatting_lit */17,
                                                                  _0: {
                                                                    TAG: /* Break */0,
                                                                    _0: "@ ",
                                                                    _1: 1,
                                                                    _2: 0
                                                                  },
                                                                  _1: {
                                                                    TAG: /* String_literal */11,
                                                                    _0: "expects ",
                                                                    _1: {
                                                                      TAG: /* Int */4,
                                                                      _0: /* Int_i */3,
                                                                      _1: /* No_padding */0,
                                                                      _2: /* No_precision */0,
                                                                      _3: {
                                                                        TAG: /* String_literal */11,
                                                                        _0: " argument(s),",
                                                                        _1: {
                                                                          TAG: /* Formatting_lit */17,
                                                                          _0: {
                                                                            TAG: /* Break */0,
                                                                            _0: "@ ",
                                                                            _1: 1,
                                                                            _2: 0
                                                                          },
                                                                          _1: {
                                                                            TAG: /* String_literal */11,
                                                                            _0: "but is applied here to ",
                                                                            _1: {
                                                                              TAG: /* Int */4,
                                                                              _0: /* Int_i */3,
                                                                              _1: /* No_padding */0,
                                                                              _2: /* No_precision */0,
                                                                              _3: {
                                                                                TAG: /* String_literal */11,
                                                                                _0: " argument(s)",
                                                                                _1: {
                                                                                  TAG: /* Formatting_lit */17,
                                                                                  _0: /* Close_box */0,
                                                                                  _1: /* End_of_format */0
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          },
                                                          _1: "@[The constructor %a@ expects %i argument(s),@ but is applied here to %i argument(s)@]"
                                                        }), longident, param$1._0, param$1._1, param$1._2);
                                      case /* Label_mismatch */2 :
                                          const lid = param$1._0;
                                          return report_unification_error(param, env, undefined, param$1._1, (function (ppf) {
                                                        Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                                                                  _0: {
                                                                    TAG: /* String_literal */11,
                                                                    _0: "The record field ",
                                                                    _1: {
                                                                      TAG: /* Alpha */15,
                                                                      _0: {
                                                                        TAG: /* Formatting_lit */17,
                                                                        _0: {
                                                                          TAG: /* Break */0,
                                                                          _0: "@ ",
                                                                          _1: 1,
                                                                          _2: 0
                                                                        },
                                                                        _1: {
                                                                          TAG: /* String_literal */11,
                                                                          _0: "belongs to the type",
                                                                          _1: /* End_of_format */0
                                                                        }
                                                                      }
                                                                    }
                                                                  },
                                                                  _1: "The record field %a@ belongs to the type"
                                                                }), longident, lid);
                                                      }), (function (ppf) {
                                                        Stdlib__Format.fprintf(ppf)(/* Format */{
                                                              _0: {
                                                                TAG: /* String_literal */11,
                                                                _0: "but is mixed here with fields of type",
                                                                _1: /* End_of_format */0
                                                              },
                                                              _1: "but is mixed here with fields of type"
                                                            });
                                                      }));
                                      case /* Pattern_type_clash */3 :
                                          return report_unification_error(param, env, undefined, param$1._0, (function (ppf) {
                                                        Stdlib__Format.fprintf(ppf)(/* Format */{
                                                              _0: {
                                                                TAG: /* String_literal */11,
                                                                _0: "This pattern matches values of type",
                                                                _1: /* End_of_format */0
                                                              },
                                                              _1: "This pattern matches values of type"
                                                            });
                                                      }), (function (ppf) {
                                                        Stdlib__Format.fprintf(ppf)(/* Format */{
                                                              _0: {
                                                                TAG: /* String_literal */11,
                                                                _0: "but a pattern was expected which matches values of type",
                                                                _1: /* End_of_format */0
                                                              },
                                                              _1: "but a pattern was expected which matches values of type"
                                                            });
                                                      }));
                                      case /* Or_pattern_type_clash */4 :
                                          const id = param$1._0;
                                          return report_unification_error(param, env, undefined, param$1._1, (function (ppf) {
                                                        Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                                                                  _0: {
                                                                    TAG: /* String_literal */11,
                                                                    _0: "The variable ",
                                                                    _1: {
                                                                      TAG: /* String */2,
                                                                      _0: /* No_padding */0,
                                                                      _1: {
                                                                        TAG: /* String_literal */11,
                                                                        _0: " on the left-hand side of this or-pattern has type",
                                                                        _1: /* End_of_format */0
                                                                      }
                                                                    }
                                                                  },
                                                                  _1: "The variable %s on the left-hand side of this or-pattern has type"
                                                                }), id.name);
                                                      }), (function (ppf) {
                                                        Stdlib__Format.fprintf(ppf)(/* Format */{
                                                              _0: {
                                                                TAG: /* String_literal */11,
                                                                _0: "but on the right-hand side it has type",
                                                                _1: /* End_of_format */0
                                                              },
                                                              _1: "but on the right-hand side it has type"
                                                            });
                                                      }));
                                      case /* Multiply_bound_variable */5 :
                                          return Curry._1(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* String_literal */11,
                                                            _0: "Variable ",
                                                            _1: {
                                                              TAG: /* String */2,
                                                              _0: /* No_padding */0,
                                                              _1: {
                                                                TAG: /* String_literal */11,
                                                                _0: " is bound several times in this matching",
                                                                _1: /* End_of_format */0
                                                              }
                                                            }
                                                          },
                                                          _1: "Variable %s is bound several times in this matching"
                                                        }), param$1._0);
                                      case /* Orpat_vars */6 :
                                          return Curry._1(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* String_literal */11,
                                                            _0: "Variable ",
                                                            _1: {
                                                              TAG: /* String */2,
                                                              _0: /* No_padding */0,
                                                              _1: {
                                                                TAG: /* String_literal */11,
                                                                _0: " must occur on both sides of this | pattern",
                                                                _1: /* End_of_format */0
                                                              }
                                                            }
                                                          },
                                                          _1: "Variable %s must occur on both sides of this | pattern"
                                                        }), param$1._0.name);
                                      case /* Expr_type_clash */7 :
                                          return report_unification_error(param, env, undefined, param$1._0, (function (ppf) {
                                                        Stdlib__Format.fprintf(ppf)(/* Format */{
                                                              _0: {
                                                                TAG: /* String_literal */11,
                                                                _0: "This expression has type",
                                                                _1: /* End_of_format */0
                                                              },
                                                              _1: "This expression has type"
                                                            });
                                                      }), (function (ppf) {
                                                        Stdlib__Format.fprintf(ppf)(/* Format */{
                                                              _0: {
                                                                TAG: /* String_literal */11,
                                                                _0: "but an expression was expected of type",
                                                                _1: /* End_of_format */0
                                                              },
                                                              _1: "but an expression was expected of type"
                                                            });
                                                      }));
                                      case /* Apply_non_function */8 :
                                          const typ = param$1._0;
                                          reset(undefined);
                                          mark_loops(typ);
                                          const match = repr(typ).desc;
                                          if (typeof match !== "number" && match.TAG === /* Tarrow */1) {
                                            Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                      _0: {
                                                        TAG: /* Formatting_gen */18,
                                                        _0: {
                                                          TAG: /* Open_box */1,
                                                          _0: /* Format */{
                                                            _0: {
                                                              TAG: /* String_literal */11,
                                                              _0: "<v>",
                                                              _1: /* End_of_format */0
                                                            },
                                                            _1: "<v>"
                                                          }
                                                        },
                                                        _1: {
                                                          TAG: /* Formatting_gen */18,
                                                          _0: {
                                                            TAG: /* Open_box */1,
                                                            _0: /* Format */{
                                                              _0: {
                                                                TAG: /* String_literal */11,
                                                                _0: "<2>",
                                                                _1: /* End_of_format */0
                                                              },
                                                              _1: "<2>"
                                                            }
                                                          },
                                                          _1: {
                                                            TAG: /* String_literal */11,
                                                            _0: "This function has type",
                                                            _1: {
                                                              TAG: /* Formatting_lit */17,
                                                              _0: {
                                                                TAG: /* Break */0,
                                                                _0: "@ ",
                                                                _1: 1,
                                                                _2: 0
                                                              },
                                                              _1: {
                                                                TAG: /* Alpha */15,
                                                                _0: {
                                                                  TAG: /* Formatting_lit */17,
                                                                  _0: /* Close_box */0,
                                                                  _1: /* End_of_format */0
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      },
                                                      _1: "@[<v>@[<2>This function has type@ %a@]"
                                                    }), type_expr$1, typ);
                                            return Curry._1(Stdlib__Format.fprintf(param)(/* Format */{
                                                            _0: {
                                                              TAG: /* Formatting_lit */17,
                                                              _0: {
                                                                TAG: /* Break */0,
                                                                _0: "@ ",
                                                                _1: 1,
                                                                _2: 0
                                                              },
                                                              _1: {
                                                                TAG: /* Formatting_gen */18,
                                                                _0: {
                                                                  TAG: /* Open_box */1,
                                                                  _0: /* Format */{
                                                                    _0: /* End_of_format */0,
                                                                    _1: ""
                                                                  }
                                                                },
                                                                _1: {
                                                                  TAG: /* String_literal */11,
                                                                  _0: "It is applied to too many arguments;",
                                                                  _1: {
                                                                    TAG: /* Formatting_lit */17,
                                                                    _0: {
                                                                      TAG: /* Break */0,
                                                                      _0: "@ ",
                                                                      _1: 1,
                                                                      _2: 0
                                                                    },
                                                                    _1: {
                                                                      TAG: /* String */2,
                                                                      _0: /* No_padding */0,
                                                                      _1: {
                                                                        TAG: /* Formatting_lit */17,
                                                                        _0: /* Close_box */0,
                                                                        _1: {
                                                                          TAG: /* Formatting_lit */17,
                                                                          _0: /* Close_box */0,
                                                                          _1: /* End_of_format */0
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            },
                                                            _1: "@ @[It is applied to too many arguments;@ %s@]@]"
                                                          }), "maybe you forgot a `;'.");
                                          }
                                          return Curry._3(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* Formatting_gen */18,
                                                            _0: {
                                                              TAG: /* Open_box */1,
                                                              _0: /* Format */{
                                                                _0: {
                                                                  TAG: /* String_literal */11,
                                                                  _0: "<v>",
                                                                  _1: /* End_of_format */0
                                                                },
                                                                _1: "<v>"
                                                              }
                                                            },
                                                            _1: {
                                                              TAG: /* Formatting_gen */18,
                                                              _0: {
                                                                TAG: /* Open_box */1,
                                                                _0: /* Format */{
                                                                  _0: {
                                                                    TAG: /* String_literal */11,
                                                                    _0: "<2>",
                                                                    _1: /* End_of_format */0
                                                                  },
                                                                  _1: "<2>"
                                                                }
                                                              },
                                                              _1: {
                                                                TAG: /* String_literal */11,
                                                                _0: "This expression has type",
                                                                _1: {
                                                                  TAG: /* Formatting_lit */17,
                                                                  _0: {
                                                                    TAG: /* Break */0,
                                                                    _0: "@ ",
                                                                    _1: 1,
                                                                    _2: 0
                                                                  },
                                                                  _1: {
                                                                    TAG: /* Alpha */15,
                                                                    _0: {
                                                                      TAG: /* Formatting_lit */17,
                                                                      _0: /* Close_box */0,
                                                                      _1: {
                                                                        TAG: /* Formatting_lit */17,
                                                                        _0: {
                                                                          TAG: /* Break */0,
                                                                          _0: "@ ",
                                                                          _1: 1,
                                                                          _2: 0
                                                                        },
                                                                        _1: {
                                                                          TAG: /* String */2,
                                                                          _0: /* No_padding */0,
                                                                          _1: {
                                                                            TAG: /* Formatting_lit */17,
                                                                            _0: /* Close_box */0,
                                                                            _1: /* End_of_format */0
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          },
                                                          _1: "@[<v>@[<2>This expression has type@ %a@]@ %s@]"
                                                        }), type_expr$1, typ, "This is not a function; it cannot be applied.");
                                      case /* Apply_wrong_label */9 :
                                          const ty = param$1._1;
                                          const print_label = function (ppf, l) {
                                            if (l === "") {
                                              return Stdlib__Format.fprintf(ppf)(/* Format */{
                                                          _0: {
                                                            TAG: /* String_literal */11,
                                                            _0: "without label",
                                                            _1: /* End_of_format */0
                                                          },
                                                          _1: "without label"
                                                        });
                                            } else {
                                              return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                                                              _0: {
                                                                TAG: /* String_literal */11,
                                                                _0: "with label ",
                                                                _1: {
                                                                  TAG: /* String */2,
                                                                  _0: /* No_padding */0,
                                                                  _1: /* End_of_format */0
                                                                }
                                                              },
                                                              _1: "with label %s"
                                                            }), prefixed_label_name(l));
                                            }
                                          };
                                          reset(undefined);
                                          mark_loops(ty);
                                          return Curry._4(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* Formatting_gen */18,
                                                            _0: {
                                                              TAG: /* Open_box */1,
                                                              _0: /* Format */{
                                                                _0: {
                                                                  TAG: /* String_literal */11,
                                                                  _0: "<v>",
                                                                  _1: /* End_of_format */0
                                                                },
                                                                _1: "<v>"
                                                              }
                                                            },
                                                            _1: {
                                                              TAG: /* Formatting_gen */18,
                                                              _0: {
                                                                TAG: /* Open_box */1,
                                                                _0: /* Format */{
                                                                  _0: {
                                                                    TAG: /* String_literal */11,
                                                                    _0: "<2>",
                                                                    _1: /* End_of_format */0
                                                                  },
                                                                  _1: "<2>"
                                                                }
                                                              },
                                                              _1: {
                                                                TAG: /* String_literal */11,
                                                                _0: "The function applied to this argument has type",
                                                                _1: {
                                                                  TAG: /* Formatting_lit */17,
                                                                  _0: {
                                                                    TAG: /* Break */0,
                                                                    _0: "@ ",
                                                                    _1: 1,
                                                                    _2: 0
                                                                  },
                                                                  _1: {
                                                                    TAG: /* Alpha */15,
                                                                    _0: {
                                                                      TAG: /* Formatting_lit */17,
                                                                      _0: /* Close_box */0,
                                                                      _1: {
                                                                        TAG: /* Formatting_lit */17,
                                                                        _0: /* Flush_newline */4,
                                                                        _1: {
                                                                          TAG: /* String_literal */11,
                                                                          _0: "This argument cannot be applied ",
                                                                          _1: {
                                                                            TAG: /* Alpha */15,
                                                                            _0: {
                                                                              TAG: /* Formatting_lit */17,
                                                                              _0: /* Close_box */0,
                                                                              _1: /* End_of_format */0
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          },
                                                          _1: "@[<v>@[<2>The function applied to this argument has type@ %a@]@.This argument cannot be applied %a@]"
                                                        }), type_expr$1, ty, print_label, param$1._0);
                                      case /* Label_multiply_defined */10 :
                                          return Curry._1(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* String_literal */11,
                                                            _0: "The record field label ",
                                                            _1: {
                                                              TAG: /* String */2,
                                                              _0: /* No_padding */0,
                                                              _1: {
                                                                TAG: /* String_literal */11,
                                                                _0: " is defined several times",
                                                                _1: /* End_of_format */0
                                                              }
                                                            }
                                                          },
                                                          _1: "The record field label %s is defined several times"
                                                        }), param$1._0);
                                      case /* Label_missing */11 :
                                          const print_labels = function (ppf) {
                                            return function (param) {
                                              return Stdlib__List.iter((function (lbl) {
                                                            Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                                                                      _0: {
                                                                        TAG: /* Formatting_lit */17,
                                                                        _0: {
                                                                          TAG: /* Break */0,
                                                                          _0: "@ ",
                                                                          _1: 1,
                                                                          _2: 0
                                                                        },
                                                                        _1: {
                                                                          TAG: /* String */2,
                                                                          _0: /* No_padding */0,
                                                                          _1: /* End_of_format */0
                                                                        }
                                                                      },
                                                                      _1: "@ %s"
                                                                    }), lbl.name);
                                                          }), param);
                                            };
                                          };
                                          return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* Formatting_gen */18,
                                                            _0: {
                                                              TAG: /* Open_box */1,
                                                              _0: /* Format */{
                                                                _0: {
                                                                  TAG: /* String_literal */11,
                                                                  _0: "<hov>",
                                                                  _1: /* End_of_format */0
                                                                },
                                                                _1: "<hov>"
                                                              }
                                                            },
                                                            _1: {
                                                              TAG: /* String_literal */11,
                                                              _0: "Some record fields are undefined:",
                                                              _1: {
                                                                TAG: /* Alpha */15,
                                                                _0: {
                                                                  TAG: /* Formatting_lit */17,
                                                                  _0: /* Close_box */0,
                                                                  _1: /* End_of_format */0
                                                                }
                                                              }
                                                            }
                                                          },
                                                          _1: "@[<hov>Some record fields are undefined:%a@]"
                                                        }), print_labels, param$1._0);
                                      case /* Label_not_mutable */12 :
                                          return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* String_literal */11,
                                                            _0: "The record field ",
                                                            _1: {
                                                              TAG: /* Alpha */15,
                                                              _0: {
                                                                TAG: /* String_literal */11,
                                                                _0: " is not mutable",
                                                                _1: /* End_of_format */0
                                                              }
                                                            }
                                                          },
                                                          _1: "The record field %a is not mutable"
                                                        }), longident, param$1._0);
                                      case /* Wrong_name */13 :
                                          const lid$1 = param$1._4;
                                          const p = param$1._3;
                                          const kind = param$1._2;
                                          const ty$1 = param$1._1;
                                          reset(undefined);
                                          mark_loops(ty$1);
                                          Curry._3(Stdlib__Format.fprintf(param)(/* Format */{
                                                    _0: {
                                                      TAG: /* Formatting_gen */18,
                                                      _0: {
                                                        TAG: /* Open_box */1,
                                                        _0: /* Format */{
                                                          _0: /* End_of_format */0,
                                                          _1: ""
                                                        }
                                                      },
                                                      _1: {
                                                        TAG: /* Formatting_gen */18,
                                                        _0: {
                                                          TAG: /* Open_box */1,
                                                          _0: /* Format */{
                                                            _0: {
                                                              TAG: /* String_literal */11,
                                                              _0: "<2>",
                                                              _1: /* End_of_format */0
                                                            },
                                                            _1: "<2>"
                                                          }
                                                        },
                                                        _1: {
                                                          TAG: /* String */2,
                                                          _0: /* No_padding */0,
                                                          _1: {
                                                            TAG: /* String_literal */11,
                                                            _0: " type",
                                                            _1: {
                                                              TAG: /* Formatting_lit */17,
                                                              _0: {
                                                                TAG: /* Break */0,
                                                                _0: "@ ",
                                                                _1: 1,
                                                                _2: 0
                                                              },
                                                              _1: {
                                                                TAG: /* Alpha */15,
                                                                _0: {
                                                                  TAG: /* Formatting_lit */17,
                                                                  _0: /* Close_box */0,
                                                                  _1: {
                                                                    TAG: /* Formatting_lit */17,
                                                                    _0: {
                                                                      TAG: /* Break */0,
                                                                      _0: "@ ",
                                                                      _1: 1,
                                                                      _2: 0
                                                                    },
                                                                    _1: /* End_of_format */0
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    },
                                                    _1: "@[@[<2>%s type@ %a@]@ "
                                                  }), param$1._0, type_expr$1, ty$1);
                                          Curry._5(Stdlib__Format.fprintf(param)(/* Format */{
                                                    _0: {
                                                      TAG: /* String_literal */11,
                                                      _0: "The ",
                                                      _1: {
                                                        TAG: /* String */2,
                                                        _0: /* No_padding */0,
                                                        _1: {
                                                          TAG: /* Char_literal */12,
                                                          _0: /* ' ' */32,
                                                          _1: {
                                                            TAG: /* Alpha */15,
                                                            _0: {
                                                              TAG: /* String_literal */11,
                                                              _0: " does not belong to type ",
                                                              _1: {
                                                                TAG: /* Alpha */15,
                                                                _0: {
                                                                  TAG: /* Formatting_lit */17,
                                                                  _0: /* Close_box */0,
                                                                  _1: /* End_of_format */0
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    },
                                                    _1: "The %s %a does not belong to type %a@]"
                                                  }), kind === "record" ? "field" : "constructor", longident, lid$1, path, p);
                                          if (kind === "record") {
                                            return spellcheck_simple(param, fold_labels, (function (d) {
                                                            if (compare_type_path(env, p, get_type_path$1(env, d))) {
                                                              return d.lbl_name;
                                                            } else {
                                                              return "";
                                                            }
                                                          }))(env, lid$1);
                                          } else {
                                            return spellcheck_simple(param, fold_constructors, (function (d) {
                                                            if (compare_type_path(env, p, get_type_path$2(env, d))) {
                                                              return d.cstr_name;
                                                            } else {
                                                              return "";
                                                            }
                                                          }))(env, lid$1);
                                          }
                                      case /* Name_type_mismatch */14 :
                                          const lid$2 = param$1._1;
                                          const kind$1 = param$1._0;
                                          const name = kind$1 === "record" ? "field" : "constructor";
                                          let param$3 = param$1._2;
                                          let tpl = param$1._3;
                                          const txt1 = function (ppf) {
                                            Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                                                      _0: {
                                                        TAG: /* String_literal */11,
                                                        _0: "The ",
                                                        _1: {
                                                          TAG: /* String */2,
                                                          _0: /* No_padding */0,
                                                          _1: {
                                                            TAG: /* Char_literal */12,
                                                            _0: /* ' ' */32,
                                                            _1: {
                                                              TAG: /* Alpha */15,
                                                              _0: {
                                                                TAG: /* Formatting_lit */17,
                                                                _0: {
                                                                  TAG: /* Break */0,
                                                                  _0: "@ ",
                                                                  _1: 1,
                                                                  _2: 0
                                                                },
                                                                _1: {
                                                                  TAG: /* String_literal */11,
                                                                  _0: "belongs to the ",
                                                                  _1: {
                                                                    TAG: /* String */2,
                                                                    _0: /* No_padding */0,
                                                                    _1: {
                                                                      TAG: /* String_literal */11,
                                                                      _0: " type",
                                                                      _1: /* End_of_format */0
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      },
                                                      _1: "The %s %a@ belongs to the %s type"
                                                    }), name, longident, lid$2, kind$1);
                                          };
                                          const txt2 = function (ppf) {
                                            Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                                                      _0: {
                                                        TAG: /* String_literal */11,
                                                        _0: "The ",
                                                        _1: {
                                                          TAG: /* String */2,
                                                          _0: /* No_padding */0,
                                                          _1: {
                                                            TAG: /* Char_literal */12,
                                                            _0: /* ' ' */32,
                                                            _1: {
                                                              TAG: /* Alpha */15,
                                                              _0: {
                                                                TAG: /* Formatting_lit */17,
                                                                _0: {
                                                                  TAG: /* Break */0,
                                                                  _0: "@ ",
                                                                  _1: 1,
                                                                  _2: 0
                                                                },
                                                                _1: {
                                                                  TAG: /* String_literal */11,
                                                                  _0: "belongs to one of the following ",
                                                                  _1: {
                                                                    TAG: /* String */2,
                                                                    _0: /* No_padding */0,
                                                                    _1: {
                                                                      TAG: /* String_literal */11,
                                                                      _0: " types:",
                                                                      _1: /* End_of_format */0
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      },
                                                      _1: "The %s %a@ belongs to one of the following %s types:"
                                                    }), name, longident, lid$2, kind$1);
                                          };
                                          const txt3 = function (ppf) {
                                            Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                                                      _0: {
                                                        TAG: /* String_literal */11,
                                                        _0: "but a ",
                                                        _1: {
                                                          TAG: /* String */2,
                                                          _0: /* No_padding */0,
                                                          _1: {
                                                            TAG: /* String_literal */11,
                                                            _0: " was expected belonging to the ",
                                                            _1: {
                                                              TAG: /* String */2,
                                                              _0: /* No_padding */0,
                                                              _1: {
                                                                TAG: /* String_literal */11,
                                                                _0: " type",
                                                                _1: /* End_of_format */0
                                                              }
                                                            }
                                                          }
                                                        }
                                                      },
                                                      _1: "but a %s was expected belonging to the %s type"
                                                    }), name, kind$1);
                                          };
                                          const tp0$p = param$3[1];
                                          const tp0 = param$3[0];
                                          return wrap_printing_env(env, (function (param$4) {
                                                        reset(undefined);
                                                        Stdlib__List.iter((function (param) {
                                                                path_same_name(tp0, param[0]);
                                                                path_same_name(tp0$p, param[1]);
                                                              }), tpl);
                                                        if (tpl) {
                                                          if (tpl.tl) {
                                                            return Curry._6(Stdlib__Format.fprintf(param)(/* Format */{
                                                                            _0: {
                                                                              TAG: /* Formatting_gen */18,
                                                                              _0: {
                                                                                TAG: /* Open_box */1,
                                                                                _0: /* Format */{
                                                                                  _0: /* End_of_format */0,
                                                                                  _1: ""
                                                                                }
                                                                              },
                                                                              _1: {
                                                                                TAG: /* Theta */16,
                                                                                _0: {
                                                                                  TAG: /* Formatting_lit */17,
                                                                                  _0: {
                                                                                    TAG: /* Break */0,
                                                                                    _0: "@;<1 2>",
                                                                                    _1: 1,
                                                                                    _2: 2
                                                                                  },
                                                                                  _1: {
                                                                                    TAG: /* Formatting_gen */18,
                                                                                    _0: {
                                                                                      TAG: /* Open_box */1,
                                                                                      _0: /* Format */{
                                                                                        _0: {
                                                                                          TAG: /* String_literal */11,
                                                                                          _0: "<hv>",
                                                                                          _1: /* End_of_format */0
                                                                                        },
                                                                                        _1: "<hv>"
                                                                                      }
                                                                                    },
                                                                                    _1: {
                                                                                      TAG: /* Alpha */15,
                                                                                      _0: {
                                                                                        TAG: /* Formatting_lit */17,
                                                                                        _0: /* Close_box */0,
                                                                                        _1: {
                                                                                          TAG: /* Formatting_lit */17,
                                                                                          _0: {
                                                                                            TAG: /* Break */0,
                                                                                            _0: "@ ",
                                                                                            _1: 1,
                                                                                            _2: 0
                                                                                          },
                                                                                          _1: {
                                                                                            TAG: /* Theta */16,
                                                                                            _0: {
                                                                                              TAG: /* Formatting_lit */17,
                                                                                              _0: {
                                                                                                TAG: /* Break */0,
                                                                                                _0: "@;<1 2>",
                                                                                                _1: 1,
                                                                                                _2: 2
                                                                                              },
                                                                                              _1: {
                                                                                                TAG: /* Alpha */15,
                                                                                                _0: {
                                                                                                  TAG: /* Formatting_lit */17,
                                                                                                  _0: /* Close_box */0,
                                                                                                  _1: /* End_of_format */0
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            },
                                                                            _1: "@[%t@;<1 2>@[<hv>%a@]@ %t@;<1 2>%a@]"
                                                                          }), txt2, type_path_list, tpl, txt3, (function (param, param$1) {
                                                                          return type_path_expansion(tp0, param, param$1);
                                                                        }), tp0$p);
                                                          }
                                                          const match = tpl.hd;
                                                          const tp = match[0];
                                                          return Curry._6(Stdlib__Format.fprintf(param)(/* Format */{
                                                                          _0: {
                                                                            TAG: /* Formatting_gen */18,
                                                                            _0: {
                                                                              TAG: /* Open_box */1,
                                                                              _0: /* Format */{
                                                                                _0: /* End_of_format */0,
                                                                                _1: ""
                                                                              }
                                                                            },
                                                                            _1: {
                                                                              TAG: /* Theta */16,
                                                                              _0: {
                                                                                TAG: /* Formatting_lit */17,
                                                                                _0: {
                                                                                  TAG: /* Break */0,
                                                                                  _0: "@;<1 2>",
                                                                                  _1: 1,
                                                                                  _2: 2
                                                                                },
                                                                                _1: {
                                                                                  TAG: /* Alpha */15,
                                                                                  _0: {
                                                                                    TAG: /* Formatting_lit */17,
                                                                                    _0: {
                                                                                      TAG: /* Break */0,
                                                                                      _0: "@ ",
                                                                                      _1: 1,
                                                                                      _2: 0
                                                                                    },
                                                                                    _1: {
                                                                                      TAG: /* Theta */16,
                                                                                      _0: {
                                                                                        TAG: /* Formatting_lit */17,
                                                                                        _0: {
                                                                                          TAG: /* Break */0,
                                                                                          _0: "@;<1 2>",
                                                                                          _1: 1,
                                                                                          _2: 2
                                                                                        },
                                                                                        _1: {
                                                                                          TAG: /* Alpha */15,
                                                                                          _0: {
                                                                                            TAG: /* Formatting_lit */17,
                                                                                            _0: /* Close_box */0,
                                                                                            _1: /* End_of_format */0
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          },
                                                                          _1: "@[%t@;<1 2>%a@ %t@;<1 2>%a@]"
                                                                        }), txt1, (function (param, param$1) {
                                                                        return type_path_expansion(tp, param, param$1);
                                                                      }), match[1], txt3, (function (param, param$1) {
                                                                        return type_path_expansion(tp0, param, param$1);
                                                                      }), tp0$p);
                                                        }
                                                        throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                                                                  MEL_EXN_ID: "Assert_failure",
                                                                  _1: [
                                                                    "jscomp/test/ocaml_typedtree_test.ml",
                                                                    37069,
                                                                    12
                                                                  ]
                                                                });
                                                      }));
                                      case /* Invalid_format */15 :
                                          return Curry._1(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* String */2,
                                                            _0: /* No_padding */0,
                                                            _1: /* End_of_format */0
                                                          },
                                                          _1: "%s"
                                                        }), param$1._0);
                                      case /* Undefined_method */16 :
                                          const ty$2 = param$1._0;
                                          reset(undefined);
                                          mark_loops(ty$2);
                                          return Curry._3(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* Formatting_gen */18,
                                                            _0: {
                                                              TAG: /* Open_box */1,
                                                              _0: /* Format */{
                                                                _0: {
                                                                  TAG: /* String_literal */11,
                                                                  _0: "<v>",
                                                                  _1: /* End_of_format */0
                                                                },
                                                                _1: "<v>"
                                                              }
                                                            },
                                                            _1: {
                                                              TAG: /* Formatting_gen */18,
                                                              _0: {
                                                                TAG: /* Open_box */1,
                                                                _0: /* Format */{
                                                                  _0: /* End_of_format */0,
                                                                  _1: ""
                                                                }
                                                              },
                                                              _1: {
                                                                TAG: /* String_literal */11,
                                                                _0: "This expression has type",
                                                                _1: {
                                                                  TAG: /* Formatting_lit */17,
                                                                  _0: {
                                                                    TAG: /* Break */0,
                                                                    _0: "@;<1 2>",
                                                                    _1: 1,
                                                                    _2: 2
                                                                  },
                                                                  _1: {
                                                                    TAG: /* Alpha */15,
                                                                    _0: {
                                                                      TAG: /* Formatting_lit */17,
                                                                      _0: /* Close_box */0,
                                                                      _1: {
                                                                        TAG: /* Formatting_lit */17,
                                                                        _0: {
                                                                          TAG: /* Break */0,
                                                                          _0: "@,",
                                                                          _1: 0,
                                                                          _2: 0
                                                                        },
                                                                        _1: {
                                                                          TAG: /* String_literal */11,
                                                                          _0: "It has no method ",
                                                                          _1: {
                                                                            TAG: /* String */2,
                                                                            _0: /* No_padding */0,
                                                                            _1: {
                                                                              TAG: /* Formatting_lit */17,
                                                                              _0: /* Close_box */0,
                                                                              _1: /* End_of_format */0
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          },
                                                          _1: "@[<v>@[This expression has type@;<1 2>%a@]@,It has no method %s@]"
                                                        }), type_expr$1, ty$2, param$1._1);
                                      case /* Undefined_inherited_method */17 :
                                          return Curry._1(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* String_literal */11,
                                                            _0: "This expression has no method ",
                                                            _1: {
                                                              TAG: /* String */2,
                                                              _0: /* No_padding */0,
                                                              _1: /* End_of_format */0
                                                            }
                                                          },
                                                          _1: "This expression has no method %s"
                                                        }), param$1._0);
                                      case /* Virtual_class */18 :
                                          return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* String_literal */11,
                                                            _0: "Cannot instantiate the virtual class ",
                                                            _1: {
                                                              TAG: /* Alpha */15,
                                                              _0: /* End_of_format */0
                                                            }
                                                          },
                                                          _1: "Cannot instantiate the virtual class %a"
                                                        }), longident, param$1._0);
                                      case /* Private_type */19 :
                                          return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* String_literal */11,
                                                            _0: "Cannot create values of the private type ",
                                                            _1: {
                                                              TAG: /* Alpha */15,
                                                              _0: /* End_of_format */0
                                                            }
                                                          },
                                                          _1: "Cannot create values of the private type %a"
                                                        }), type_expr$1, param$1._0);
                                      case /* Private_label */20 :
                                          return Curry._4(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* String_literal */11,
                                                            _0: "Cannot assign field ",
                                                            _1: {
                                                              TAG: /* Alpha */15,
                                                              _0: {
                                                                TAG: /* String_literal */11,
                                                                _0: " of the private type ",
                                                                _1: {
                                                                  TAG: /* Alpha */15,
                                                                  _0: /* End_of_format */0
                                                                }
                                                              }
                                                            }
                                                          },
                                                          _1: "Cannot assign field %a of the private type %a"
                                                        }), longident, param$1._0, type_expr$1, param$1._1);
                                      case /* Unbound_instance_variable */21 :
                                          return Curry._1(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* String_literal */11,
                                                            _0: "Unbound instance variable ",
                                                            _1: {
                                                              TAG: /* String */2,
                                                              _0: /* No_padding */0,
                                                              _1: /* End_of_format */0
                                                            }
                                                          },
                                                          _1: "Unbound instance variable %s"
                                                        }), param$1._0);
                                      case /* Instance_variable_not_mutable */22 :
                                          const v = param$1._1;
                                          if (param$1._0) {
                                            return Curry._1(Stdlib__Format.fprintf(param)(/* Format */{
                                                            _0: {
                                                              TAG: /* String_literal */11,
                                                              _0: "The instance variable ",
                                                              _1: {
                                                                TAG: /* String */2,
                                                                _0: /* No_padding */0,
                                                                _1: {
                                                                  TAG: /* String_literal */11,
                                                                  _0: " is not mutable",
                                                                  _1: /* End_of_format */0
                                                                }
                                                              }
                                                            },
                                                            _1: "The instance variable %s is not mutable"
                                                          }), v);
                                          } else {
                                            return Curry._1(Stdlib__Format.fprintf(param)(/* Format */{
                                                            _0: {
                                                              TAG: /* String_literal */11,
                                                              _0: "The value ",
                                                              _1: {
                                                                TAG: /* String */2,
                                                                _0: /* No_padding */0,
                                                                _1: {
                                                                  TAG: /* String_literal */11,
                                                                  _0: " is not an instance variable",
                                                                  _1: /* End_of_format */0
                                                                }
                                                              }
                                                            },
                                                            _1: "The value %s is not an instance variable"
                                                          }), v);
                                          }
                                      case /* Not_subtype */23 :
                                          let tr1 = param$1._0;
                                          let txt1$1 = "is not a subtype of";
                                          let tr2 = param$1._1;
                                          return wrap_printing_env(env, (function (param$4) {
                                                        reset(undefined);
                                                        const tr1$1 = Stdlib__List.map(prepare_expansion, tr1);
                                                        const tr2$1 = Stdlib__List.map(prepare_expansion, tr2);
                                                        const partial_arg = Caml_obj.caml_equal(tr2$1, /* [] */0);
                                                        Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                                  _0: {
                                                                    TAG: /* Formatting_gen */18,
                                                                    _0: {
                                                                      TAG: /* Open_box */1,
                                                                      _0: /* Format */{
                                                                        _0: {
                                                                          TAG: /* String_literal */11,
                                                                          _0: "<v>",
                                                                          _1: /* End_of_format */0
                                                                        },
                                                                        _1: "<v>"
                                                                      }
                                                                    },
                                                                    _1: {
                                                                      TAG: /* Alpha */15,
                                                                      _0: /* End_of_format */0
                                                                    }
                                                                  },
                                                                  _1: "@[<v>%a"
                                                                }), (function (param, param$1) {
                                                                return trace$1(true, partial_arg, txt1$1, param, param$1);
                                                              }), tr1$1);
                                                        if (Caml_obj.caml_equal(tr2$1, /* [] */0)) {
                                                          return Stdlib__Format.fprintf(param)(/* Format */{
                                                                      _0: {
                                                                        TAG: /* Formatting_lit */17,
                                                                        _0: /* Close_box */0,
                                                                        _1: /* End_of_format */0
                                                                      },
                                                                      _1: "@]"
                                                                    });
                                                        }
                                                        const mis = mismatch(true, tr2$1);
                                                        const partial_arg$1 = mis === undefined;
                                                        Curry._3(Stdlib__Format.fprintf(param)(/* Format */{
                                                                  _0: {
                                                                    TAG: /* Alpha */15,
                                                                    _0: {
                                                                      TAG: /* Theta */16,
                                                                      _0: {
                                                                        TAG: /* Formatting_lit */17,
                                                                        _0: /* Close_box */0,
                                                                        _1: /* End_of_format */0
                                                                      }
                                                                    }
                                                                  },
                                                                  _1: "%a%t@]"
                                                                }), (function (param, param$1) {
                                                                return trace$1(false, partial_arg$1, "is not compatible with type", param, param$1);
                                                              }), tr2$1, (function (param) {
                                                                return explanation(true, mis, param);
                                                              }));
                                                      }));
                                      case /* Value_multiply_overridden */24 :
                                          return Curry._1(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* String_literal */11,
                                                            _0: "The instance variable ",
                                                            _1: {
                                                              TAG: /* String */2,
                                                              _0: /* No_padding */0,
                                                              _1: {
                                                                TAG: /* String_literal */11,
                                                                _0: " is overridden several times",
                                                                _1: /* End_of_format */0
                                                              }
                                                            }
                                                          },
                                                          _1: "The instance variable %s is overridden several times"
                                                        }), param$1._0);
                                      case /* Coercion_failure */25 :
                                          const ty$p = param$1._1;
                                          const ty$3 = param$1._0;
                                          report_unification_error(param, env, undefined, param$1._2, (function (ppf) {
                                                  const match = prepare_expansion([
                                                        ty$3,
                                                        ty$p
                                                      ]);
                                                  const ty$4 = match[0];
                                                  Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                                                            _0: {
                                                              TAG: /* String_literal */11,
                                                              _0: "This expression cannot be coerced to type",
                                                              _1: {
                                                                TAG: /* Formatting_lit */17,
                                                                _0: {
                                                                  TAG: /* Break */0,
                                                                  _0: "@;<1 2>",
                                                                  _1: 1,
                                                                  _2: 2
                                                                },
                                                                _1: {
                                                                  TAG: /* Alpha */15,
                                                                  _0: {
                                                                    TAG: /* Char_literal */12,
                                                                    _0: /* ';' */59,
                                                                    _1: {
                                                                      TAG: /* Formatting_lit */17,
                                                                      _0: {
                                                                        TAG: /* Break */0,
                                                                        _0: "@ ",
                                                                        _1: 1,
                                                                        _2: 0
                                                                      },
                                                                      _1: {
                                                                        TAG: /* String_literal */11,
                                                                        _0: "it has type",
                                                                        _1: /* End_of_format */0
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            },
                                                            _1: "This expression cannot be coerced to type@;<1 2>%a;@ it has type"
                                                          }), (function (param, param$1) {
                                                          return type_expansion(ty$4, param, param$1);
                                                        }), match[1]);
                                                }), (function (ppf) {
                                                  Stdlib__Format.fprintf(ppf)(/* Format */{
                                                        _0: {
                                                          TAG: /* String_literal */11,
                                                          _0: "but is here used with type",
                                                          _1: /* End_of_format */0
                                                        },
                                                        _1: "but is here used with type"
                                                      });
                                                }));
                                          if (param$1._3) {
                                            return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                            _0: {
                                                              TAG: /* Char_literal */12,
                                                              _0: /* '.' */46,
                                                              _1: {
                                                                TAG: /* Formatting_lit */17,
                                                                _0: /* Flush_newline */4,
                                                                _1: {
                                                                  TAG: /* Formatting_gen */18,
                                                                  _0: {
                                                                    TAG: /* Open_box */1,
                                                                    _0: /* Format */{
                                                                      _0: {
                                                                        TAG: /* String_literal */11,
                                                                        _0: "<hov>",
                                                                        _1: /* End_of_format */0
                                                                      },
                                                                      _1: "<hov>"
                                                                    }
                                                                  },
                                                                  _1: {
                                                                    TAG: /* String */2,
                                                                    _0: /* No_padding */0,
                                                                    _1: {
                                                                      TAG: /* Formatting_lit */17,
                                                                      _0: {
                                                                        TAG: /* Break */0,
                                                                        _0: "@ ",
                                                                        _1: 1,
                                                                        _2: 0
                                                                      },
                                                                      _1: {
                                                                        TAG: /* String */2,
                                                                        _0: /* No_padding */0,
                                                                        _1: {
                                                                          TAG: /* Formatting_lit */17,
                                                                          _0: /* Close_box */0,
                                                                          _1: /* End_of_format */0
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            },
                                                            _1: ".@.@[<hov>%s@ %s@]"
                                                          }), "This simple coercion was not fully general.", "Consider using a double coercion.");
                                          } else {
                                            return ;
                                          }
                                      case /* Too_many_arguments */26 :
                                          const ty$4 = param$1._1;
                                          reset(undefined);
                                          mark_loops(ty$4);
                                          if (param$1._0) {
                                            Stdlib__Format.fprintf(param)(/* Format */{
                                                  _0: {
                                                    TAG: /* String_literal */11,
                                                    _0: "This function expects too many arguments,",
                                                    _1: {
                                                      TAG: /* Formatting_lit */17,
                                                      _0: {
                                                        TAG: /* Break */0,
                                                        _0: "@ ",
                                                        _1: 1,
                                                        _2: 0
                                                      },
                                                      _1: /* End_of_format */0
                                                    }
                                                  },
                                                  _1: "This function expects too many arguments,@ "
                                                });
                                            return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                            _0: {
                                                              TAG: /* String_literal */11,
                                                              _0: "it should have type",
                                                              _1: {
                                                                TAG: /* Formatting_lit */17,
                                                                _0: {
                                                                  TAG: /* Break */0,
                                                                  _0: "@ ",
                                                                  _1: 1,
                                                                  _2: 0
                                                                },
                                                                _1: {
                                                                  TAG: /* Alpha */15,
                                                                  _0: /* End_of_format */0
                                                                }
                                                              }
                                                            },
                                                            _1: "it should have type@ %a"
                                                          }), type_expr$1, ty$4);
                                          } else {
                                            Stdlib__Format.fprintf(param)(/* Format */{
                                                  _0: {
                                                    TAG: /* String_literal */11,
                                                    _0: "This expression should not be a function,",
                                                    _1: {
                                                      TAG: /* Formatting_lit */17,
                                                      _0: {
                                                        TAG: /* Break */0,
                                                        _0: "@ ",
                                                        _1: 1,
                                                        _2: 0
                                                      },
                                                      _1: /* End_of_format */0
                                                    }
                                                  },
                                                  _1: "This expression should not be a function,@ "
                                                });
                                            return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                            _0: {
                                                              TAG: /* String_literal */11,
                                                              _0: "the expected type is",
                                                              _1: {
                                                                TAG: /* Formatting_lit */17,
                                                                _0: {
                                                                  TAG: /* Break */0,
                                                                  _0: "@ ",
                                                                  _1: 1,
                                                                  _2: 0
                                                                },
                                                                _1: {
                                                                  TAG: /* Alpha */15,
                                                                  _0: /* End_of_format */0
                                                                }
                                                              }
                                                            },
                                                            _1: "the expected type is@ %a"
                                                          }), type_expr$1, ty$4);
                                          }
                                      case /* Abstract_wrong_label */27 :
                                          const ty$5 = param$1._1;
                                          const label_mark = function (l) {
                                            if (l === "") {
                                              return "but its first argument is not labelled";
                                            } else {
                                              return Curry._1(Stdlib__Format.sprintf(/* Format */{
                                                              _0: {
                                                                TAG: /* String_literal */11,
                                                                _0: "but its first argument is labelled ",
                                                                _1: {
                                                                  TAG: /* String */2,
                                                                  _0: /* No_padding */0,
                                                                  _1: /* End_of_format */0
                                                                }
                                                              },
                                                              _1: "but its first argument is labelled %s"
                                                            }), prefixed_label_name(l));
                                            }
                                          };
                                          reset(undefined);
                                          mark_loops(ty$5);
                                          return Curry._3(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* Formatting_gen */18,
                                                            _0: {
                                                              TAG: /* Open_box */1,
                                                              _0: /* Format */{
                                                                _0: {
                                                                  TAG: /* String_literal */11,
                                                                  _0: "<v>",
                                                                  _1: /* End_of_format */0
                                                                },
                                                                _1: "<v>"
                                                              }
                                                            },
                                                            _1: {
                                                              TAG: /* Formatting_gen */18,
                                                              _0: {
                                                                TAG: /* Open_box */1,
                                                                _0: /* Format */{
                                                                  _0: {
                                                                    TAG: /* String_literal */11,
                                                                    _0: "<2>",
                                                                    _1: /* End_of_format */0
                                                                  },
                                                                  _1: "<2>"
                                                                }
                                                              },
                                                              _1: {
                                                                TAG: /* String_literal */11,
                                                                _0: "This function should have type",
                                                                _1: {
                                                                  TAG: /* Formatting_lit */17,
                                                                  _0: {
                                                                    TAG: /* Break */0,
                                                                    _0: "@ ",
                                                                    _1: 1,
                                                                    _2: 0
                                                                  },
                                                                  _1: {
                                                                    TAG: /* Alpha */15,
                                                                    _0: {
                                                                      TAG: /* Formatting_lit */17,
                                                                      _0: /* Close_box */0,
                                                                      _1: {
                                                                        TAG: /* Formatting_lit */17,
                                                                        _0: {
                                                                          TAG: /* Break */0,
                                                                          _0: "@,",
                                                                          _1: 0,
                                                                          _2: 0
                                                                        },
                                                                        _1: {
                                                                          TAG: /* String */2,
                                                                          _0: /* No_padding */0,
                                                                          _1: {
                                                                            TAG: /* Formatting_lit */17,
                                                                            _0: /* Close_box */0,
                                                                            _1: /* End_of_format */0
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          },
                                                          _1: "@[<v>@[<2>This function should have type@ %a@]@,%s@]"
                                                        }), type_expr$1, ty$5, label_mark(param$1._0));
                                      case /* Scoping_let_module */28 :
                                          const ty$6 = param$1._1;
                                          reset(undefined);
                                          mark_loops(ty$6);
                                          Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                    _0: {
                                                      TAG: /* String_literal */11,
                                                      _0: "This `let module' expression has type",
                                                      _1: {
                                                        TAG: /* Formatting_lit */17,
                                                        _0: {
                                                          TAG: /* Break */0,
                                                          _0: "@ ",
                                                          _1: 1,
                                                          _2: 0
                                                        },
                                                        _1: {
                                                          TAG: /* Alpha */15,
                                                          _0: {
                                                            TAG: /* Formatting_lit */17,
                                                            _0: {
                                                              TAG: /* Break */0,
                                                              _0: "@ ",
                                                              _1: 1,
                                                              _2: 0
                                                            },
                                                            _1: /* End_of_format */0
                                                          }
                                                        }
                                                      }
                                                    },
                                                    _1: "This `let module' expression has type@ %a@ "
                                                  }), type_expr$1, ty$6);
                                          return Curry._1(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* String_literal */11,
                                                            _0: "In this type, the locally bound module name ",
                                                            _1: {
                                                              TAG: /* String */2,
                                                              _0: /* No_padding */0,
                                                              _1: {
                                                                TAG: /* String_literal */11,
                                                                _0: " escapes its scope",
                                                                _1: /* End_of_format */0
                                                              }
                                                            }
                                                          },
                                                          _1: "In this type, the locally bound module name %s escapes its scope"
                                                        }), param$1._0);
                                      case /* Masked_instance_variable */29 :
                                          return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* String_literal */11,
                                                            _0: "The instance variable ",
                                                            _1: {
                                                              TAG: /* Alpha */15,
                                                              _0: {
                                                                TAG: /* Formatting_lit */17,
                                                                _0: {
                                                                  TAG: /* Break */0,
                                                                  _0: "@ ",
                                                                  _1: 1,
                                                                  _2: 0
                                                                },
                                                                _1: {
                                                                  TAG: /* String_literal */11,
                                                                  _0: "cannot be accessed from the definition of another instance variable",
                                                                  _1: /* End_of_format */0
                                                                }
                                                              }
                                                            }
                                                          },
                                                          _1: "The instance variable %a@ cannot be accessed from the definition of another instance variable"
                                                        }), longident, param$1._0);
                                      case /* Not_a_variant_type */30 :
                                          return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* String_literal */11,
                                                            _0: "The type ",
                                                            _1: {
                                                              TAG: /* Alpha */15,
                                                              _0: {
                                                                TAG: /* Formatting_lit */17,
                                                                _0: {
                                                                  TAG: /* Break */0,
                                                                  _0: "@ ",
                                                                  _1: 1,
                                                                  _2: 0
                                                                },
                                                                _1: {
                                                                  TAG: /* String_literal */11,
                                                                  _0: "is not a variant type",
                                                                  _1: /* End_of_format */0
                                                                }
                                                              }
                                                            }
                                                          },
                                                          _1: "The type %a@ is not a variant type"
                                                        }), longident, param$1._0);
                                      case /* Less_general */31 :
                                          const kind$2 = param$1._0;
                                          return report_unification_error(param, env, undefined, param$1._1, (function (ppf) {
                                                        Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                                                                  _0: {
                                                                    TAG: /* String_literal */11,
                                                                    _0: "This ",
                                                                    _1: {
                                                                      TAG: /* String */2,
                                                                      _0: /* No_padding */0,
                                                                      _1: {
                                                                        TAG: /* String_literal */11,
                                                                        _0: " has type",
                                                                        _1: /* End_of_format */0
                                                                      }
                                                                    }
                                                                  },
                                                                  _1: "This %s has type"
                                                                }), kind$2);
                                                      }), (function (ppf) {
                                                        Stdlib__Format.fprintf(ppf)(/* Format */{
                                                              _0: {
                                                                TAG: /* String_literal */11,
                                                                _0: "which is less general than",
                                                                _1: /* End_of_format */0
                                                              },
                                                              _1: "which is less general than"
                                                            });
                                                      }));
                                      case /* Not_a_packed_module */32 :
                                          return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* String_literal */11,
                                                            _0: "This expression is packed module, but the expected type is",
                                                            _1: {
                                                              TAG: /* Formatting_lit */17,
                                                              _0: {
                                                                TAG: /* Break */0,
                                                                _0: "@ ",
                                                                _1: 1,
                                                                _2: 0
                                                              },
                                                              _1: {
                                                                TAG: /* Alpha */15,
                                                                _0: /* End_of_format */0
                                                              }
                                                            }
                                                          },
                                                          _1: "This expression is packed module, but the expected type is@ %a"
                                                        }), type_expr$1, param$1._0);
                                      case /* Recursive_local_constraint */33 :
                                          return report_unification_error(param, env, undefined, param$1._0, (function (ppf) {
                                                        Stdlib__Format.fprintf(ppf)(/* Format */{
                                                              _0: {
                                                                TAG: /* String_literal */11,
                                                                _0: "Recursive local constraint when unifying",
                                                                _1: /* End_of_format */0
                                                              },
                                                              _1: "Recursive local constraint when unifying"
                                                            });
                                                      }), (function (ppf) {
                                                        Stdlib__Format.fprintf(ppf)(/* Format */{
                                                              _0: {
                                                                TAG: /* String_literal */11,
                                                                _0: "with",
                                                                _1: /* End_of_format */0
                                                              },
                                                              _1: "with"
                                                            });
                                                      }));
                                      case /* Unqualified_gadt_pattern */34 :
                                          return Curry._4(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* Formatting_gen */18,
                                                            _0: {
                                                              TAG: /* Open_box */1,
                                                              _0: /* Format */{
                                                                _0: /* End_of_format */0,
                                                                _1: ""
                                                              }
                                                            },
                                                            _1: {
                                                              TAG: /* String_literal */11,
                                                              _0: "The GADT constructor ",
                                                              _1: {
                                                                TAG: /* String */2,
                                                                _0: /* No_padding */0,
                                                                _1: {
                                                                  TAG: /* String_literal */11,
                                                                  _0: " of type ",
                                                                  _1: {
                                                                    TAG: /* Alpha */15,
                                                                    _0: {
                                                                      TAG: /* Formatting_lit */17,
                                                                      _0: {
                                                                        TAG: /* Break */0,
                                                                        _0: "@ ",
                                                                        _1: 1,
                                                                        _2: 0
                                                                      },
                                                                      _1: {
                                                                        TAG: /* String */2,
                                                                        _0: /* No_padding */0,
                                                                        _1: {
                                                                          TAG: /* Char_literal */12,
                                                                          _0: /* '.' */46,
                                                                          _1: {
                                                                            TAG: /* Formatting_lit */17,
                                                                            _0: /* Close_box */0,
                                                                            _1: /* End_of_format */0
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          },
                                                          _1: "@[The GADT constructor %s of type %a@ %s.@]"
                                                        }), param$1._1, path, param$1._0, "must be qualified in this pattern");
                                      
                                    }
                                  }
                                }));
                  }), err._3);
    });

add_delayed_check_forward.contents = add_delayed_check;

const $$Error$8 = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Typedecl.Error");

function enter_type$1(env, sdecl, id) {
  const match = sdecl.ptype_manifest;
  const decl_type_params = Stdlib__List.map((function (param) {
          return newty2(100000000, {
                      TAG: /* Tvar */0,
                      _0: undefined
                    });
        }), sdecl.ptype_params);
  const decl_type_arity = Stdlib__List.length(sdecl.ptype_params);
  const decl_type_private = sdecl.ptype_private;
  const decl_type_manifest = match !== undefined ? newvar(undefined, undefined) : undefined;
  const decl_type_variance = Stdlib__List.map((function (param) {
          return Types_Variance.full;
        }), sdecl.ptype_params);
  const decl_type_loc = sdecl.ptype_loc;
  const decl_type_attributes = sdecl.ptype_attributes;
  const decl = {
    type_params: decl_type_params,
    type_arity: decl_type_arity,
    type_kind: /* Type_abstract */0,
    type_private: decl_type_private,
    type_manifest: decl_type_manifest,
    type_variance: decl_type_variance,
    type_newtype_level: undefined,
    type_loc: decl_type_loc,
    type_attributes: decl_type_attributes
  };
  return add_type$1(true, id, decl, env);
}

function is_fixed_type(sd) {
  const sty = sd.ptype_manifest;
  if (sty !== undefined && Caml_obj.caml_equal(sd.ptype_kind, /* Ptype_abstract */0) && sd.ptype_private === /* Private */0) {
    let _sty = sty;
    while(true) {
      const sty$1 = _sty;
      const match = sty$1.ptyp_desc;
      if (typeof match === "number") {
        return false;
      }
      switch (match.TAG | 0) {
        case /* Ptyp_object */4 :
            if (match._1) {
              return true;
            } else {
              return false;
            }
        case /* Ptyp_class */5 :
            return true;
        case /* Ptyp_alias */6 :
            _sty = match._0;
            continue ;
        case /* Ptyp_variant */7 :
            if (match._1) {
              return true;
            } else {
              return match._2 !== undefined;
            }
        default:
          return false;
      }
    };
  } else {
    return false;
  }
}

function set_fixed_row(env, loc, p, decl) {
  const t = decl.type_manifest;
  let tm;
  if (t !== undefined) {
    tm = expand_head(env, t);
  } else {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                46327,
                14
              ]
            });
  }
  const row = tm.desc;
  let rv;
  if (typeof row === "number") {
    throw new Caml_js_exceptions.MelangeError($$Error$8, {
              MEL_EXN_ID: $$Error$8,
              _1: loc,
              _2: {
                TAG: /* Bad_fixed_type */18,
                _0: "is not an object or variant"
              }
            });
  }
  switch (row.TAG | 0) {
    case /* Tobject */4 :
        rv = flatten_fields(row._0)[1];
        break;
    case /* Tvariant */8 :
        const row$1 = row_repr_aux(/* [] */0, row._0);
        tm.desc = {
          TAG: /* Tvariant */8,
          _0: {
            row_fields: row$1.row_fields,
            row_more: row$1.row_more,
            row_bound: row$1.row_bound,
            row_closed: row$1.row_closed,
            row_fixed: true,
            row_name: row$1.row_name
          }
        };
        rv = static_row(row$1) ? newty2(100000000, /* Tnil */0) : row$1.row_more;
        break;
    default:
      throw new Caml_js_exceptions.MelangeError($$Error$8, {
                MEL_EXN_ID: $$Error$8,
                _1: loc,
                _2: {
                  TAG: /* Bad_fixed_type */18,
                  _0: "is not an object or variant"
                }
              });
  }
  if (!is_Tvar(rv)) {
    throw new Caml_js_exceptions.MelangeError($$Error$8, {
              MEL_EXN_ID: $$Error$8,
              _1: loc,
              _2: {
                TAG: /* Bad_fixed_type */18,
                _0: "has no row variable"
              }
            });
  }
  rv.desc = {
    TAG: /* Tconstr */3,
    _0: p,
    _1: decl.type_params,
    _2: {
      contents: /* Mnil */0
    }
  };
}

const compare$7 = Caml.caml_string_compare;

const funarg$5 = {
  compare: compare$7
};

function height$10(param) {
  if (param) {
    return param.h;
  } else {
    return 0;
  }
}

function create$11(l, v, r) {
  const hl = l ? l.h : 0;
  const hr = r ? r.h : 0;
  return /* Node */{
          l: l,
          v: v,
          r: r,
          h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        };
}

function bal$10(l, v, r) {
  const hl = l ? l.h : 0;
  const hr = r ? r.h : 0;
  if (hl > (hr + 2 | 0)) {
    if (l) {
      const lr = l.r;
      const lv = l.v;
      const ll = l.l;
      if (height$10(ll) >= height$10(lr)) {
        return create$11(ll, lv, create$11(lr, v, r));
      }
      if (lr) {
        return create$11(create$11(ll, lv, lr.l), lr.v, create$11(lr.r, v, r));
      }
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
                MEL_EXN_ID: "Invalid_argument",
                _1: "Set.bal"
              });
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Set.bal"
            });
  }
  if (hr <= (hl + 2 | 0)) {
    return /* Node */{
            l: l,
            v: v,
            r: r,
            h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          };
  }
  if (r) {
    const rr = r.r;
    const rv = r.v;
    const rl = r.l;
    if (height$10(rr) >= height$10(rl)) {
      return create$11(create$11(l, v, rl), rv, rr);
    }
    if (rl) {
      return create$11(create$11(l, v, rl.l), rl.v, create$11(rl.r, rv, rr));
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Set.bal"
            });
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Set.bal"
          });
}

function add$12(x, t) {
  if (!t) {
    return /* Node */{
            l: /* Empty */0,
            v: x,
            r: /* Empty */0,
            h: 1
          };
  }
  const r = t.r;
  const v = t.v;
  const l = t.l;
  const c = Curry._2(funarg$5.compare, x, v);
  if (c === 0) {
    return t;
  }
  if (c < 0) {
    const ll = add$12(x, l);
    if (l === ll) {
      return t;
    } else {
      return bal$10(ll, v, r);
    }
  }
  const rr = add$12(x, r);
  if (r === rr) {
    return t;
  } else {
    return bal$10(l, v, rr);
  }
}

function mem$6(x, _param) {
  while(true) {
    const param = _param;
    if (!param) {
      return false;
    }
    const c = Curry._2(funarg$5.compare, x, param.v);
    if (c === 0) {
      return true;
    }
    _param = c < 0 ? param.l : param.r;
    continue ;
  };
}

function make_params(env, params) {
  const make_param = function (param) {
    const sty = param[0];
    try {
      return [
              transl_type_param(env, sty),
              param[1]
            ];
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Already_bound) {
        throw new Caml_js_exceptions.MelangeError($$Error$8, {
                  MEL_EXN_ID: $$Error$8,
                  _1: sty.ptyp_loc,
                  _2: /* Repeated_parameter */0
                });
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  };
  return Stdlib__List.map(make_param, params);
}

function make_constructor(env, type_path, type_params, sargs, sret_type) {
  if (sret_type !== undefined) {
    const z = narrow(undefined);
    reset_type_variables(undefined);
    const targs = Stdlib__List.map((function (param) {
            return transl_simple_type(env, false, param);
          }), sargs);
    const args = Stdlib__List.map((function (cty) {
            return cty.ctyp_type;
          }), targs);
    const tret_type = transl_simple_type(env, false, sret_type);
    const ret_type = tret_type.ctyp_type;
    const match = repr(ret_type).desc;
    let exit = 0;
    if (typeof match === "number" || !(match.TAG === /* Tconstr */3 && same(type_path, match._0))) {
      exit = 1;
    }
    if (exit === 1) {
      throw new Caml_js_exceptions.MelangeError($$Error$8, {
                MEL_EXN_ID: $$Error$8,
                _1: sret_type.ptyp_loc,
                _2: {
                  TAG: /* Constraint_failed */5,
                  _0: ret_type,
                  _1: newconstr(type_path, type_params)
                }
              });
    }
    widen(z);
    return [
            targs,
            tret_type,
            args,
            ret_type
          ];
  }
  const targs$1 = Stdlib__List.map((function (param) {
          return transl_simple_type(env, true, param);
        }), sargs);
  const args$1 = Stdlib__List.map((function (cty) {
          return cty.ctyp_type;
        }), targs$1);
  return [
          targs$1,
          undefined,
          args$1,
          undefined
        ];
}

function generalize_decl(decl) {
  Stdlib__List.iter(generalize, decl.type_params);
  const v = decl.type_kind;
  if (typeof v === "number") {
    v === /* Type_abstract */0;
  } else if (v.TAG === /* Type_record */0) {
    Stdlib__List.iter((function (l) {
            iter_generalize$1({
                  contents: /* [] */0
                }, l.ld_type);
          }), v._0);
  } else {
    Stdlib__List.iter((function (c) {
            Stdlib__List.iter(generalize, c.cd_args);
            may(generalize, c.cd_res);
          }), v._0);
  }
  const ty = decl.type_manifest;
  if (ty !== undefined) {
    return iter_generalize$1({
                contents: /* [] */0
              }, ty);
  }
  
}

function check_constraints_rec(env, loc, visited, _ty) {
  while(true) {
    const ty = _ty;
    const ty$1 = repr(ty);
    if (Curry._2(mem$3, ty$1, visited.contents)) {
      return ;
    }
    visited.contents = Curry._2(add$3, ty$1, visited.contents);
    const match = ty$1.desc;
    if (typeof match === "number") {
      return iter_type_expr((function (param) {
                    return check_constraints_rec(env, loc, visited, param);
                  }), ty$1);
    }
    switch (match.TAG | 0) {
      case /* Tconstr */3 :
          const args = match._1;
          const path = match._0;
          const args$p = Stdlib__List.map((function (param) {
                  return newvar(undefined, undefined);
                }), args);
          const ty$p = newconstr(path, args$p);
          try {
            enforce_constraints(env, ty$p);
          }
          catch (raw_exn){
            const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.MEL_EXN_ID === Unify) {
              throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                        MEL_EXN_ID: "Assert_failure",
                        _1: [
                          "jscomp/test/ocaml_typedtree_test.ml",
                          46574,
                          28
                        ]
                      });
            }
            if (exn.MEL_EXN_ID === Stdlib.Not_found) {
              throw new Caml_js_exceptions.MelangeError($$Error$8, {
                        MEL_EXN_ID: $$Error$8,
                        _1: loc,
                        _2: {
                          TAG: /* Unavailable_type_constructor */17,
                          _0: path
                        }
                      });
            }
            throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
          }
          if (!matches(env, ty$1, ty$p)) {
            throw new Caml_js_exceptions.MelangeError($$Error$8, {
                      MEL_EXN_ID: $$Error$8,
                      _1: loc,
                      _2: {
                        TAG: /* Constraint_failed */5,
                        _0: ty$1,
                        _1: ty$p
                      }
                    });
          }
          return Stdlib__List.iter((function (param) {
                        return check_constraints_rec(env, loc, visited, param);
                      }), args);
      case /* Tpoly */10 :
          const match$1 = instance_poly(undefined, false, match._1, match._0);
          _ty = match$1[1];
          continue ;
      default:
        return iter_type_expr((function (param) {
                      return check_constraints_rec(env, loc, visited, param);
                    }), ty$1);
    }
  };
}

const funarg$6 = {
  compare: Stdlib__String.compare
};

function height$11(param) {
  if (param) {
    return param.h;
  } else {
    return 0;
  }
}

function create$12(l, x, d, r) {
  const hl = height$11(l);
  const hr = height$11(r);
  return /* Node */{
          l: l,
          v: x,
          d: d,
          r: r,
          h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        };
}

function bal$11(l, x, d, r) {
  const hl = l ? l.h : 0;
  const hr = r ? r.h : 0;
  if (hl > (hr + 2 | 0)) {
    if (l) {
      const lr = l.r;
      const ld = l.d;
      const lv = l.v;
      const ll = l.l;
      if (height$11(ll) >= height$11(lr)) {
        return create$12(ll, lv, ld, create$12(lr, x, d, r));
      }
      if (lr) {
        return create$12(create$12(ll, lv, ld, lr.l), lr.v, lr.d, create$12(lr.r, x, d, r));
      }
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
                MEL_EXN_ID: "Invalid_argument",
                _1: "Map.bal"
              });
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Map.bal"
            });
  }
  if (hr <= (hl + 2 | 0)) {
    return /* Node */{
            l: l,
            v: x,
            d: d,
            r: r,
            h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          };
  }
  if (r) {
    const rr = r.r;
    const rd = r.d;
    const rv = r.v;
    const rl = r.l;
    if (height$11(rr) >= height$11(rl)) {
      return create$12(create$12(l, x, d, rl), rv, rd, rr);
    }
    if (rl) {
      return create$12(create$12(l, x, d, rl.l), rl.v, rl.d, create$12(rl.r, rv, rd, rr));
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Map.bal"
            });
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Map.bal"
          });
}

function add$13(x, data, m) {
  if (!m) {
    return /* Node */{
            l: /* Empty */0,
            v: x,
            d: data,
            r: /* Empty */0,
            h: 1
          };
  }
  const r = m.r;
  const d = m.d;
  const v = m.v;
  const l = m.l;
  const c = Curry._2(funarg$6.compare, x, v);
  if (c === 0) {
    if (d === data) {
      return m;
    } else {
      return /* Node */{
              l: l,
              v: x,
              d: data,
              r: r,
              h: m.h
            };
    }
  }
  if (c < 0) {
    const ll = add$13(x, data, l);
    if (l === ll) {
      return m;
    } else {
      return bal$11(ll, v, d, r);
    }
  }
  const rr = add$13(x, data, r);
  if (r === rr) {
    return m;
  } else {
    return bal$11(l, v, d, rr);
  }
}

function find$6(x, _param) {
  while(true) {
    const param = _param;
    if (param) {
      const c = Curry._2(funarg$6.compare, x, param.v);
      if (c === 0) {
        return param.d;
      }
      _param = c < 0 ? param.l : param.r;
      continue ;
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
  };
}

function check_coherence(env, loc, id, decl) {
  const match = decl.type_kind;
  if (typeof match === "number" && !match) {
    return ;
  }
  const ty = decl.type_manifest;
  if (ty === undefined) {
    return ;
  }
  const match$1 = repr(ty).desc;
  if (typeof match$1 === "number") {
    throw new Caml_js_exceptions.MelangeError($$Error$8, {
              MEL_EXN_ID: $$Error$8,
              _1: loc,
              _2: {
                TAG: /* Definition_mismatch */4,
                _0: ty,
                _1: /* [] */0
              }
            });
  }
  if (match$1.TAG === /* Tconstr */3) {
    const args = match$1._1;
    const path = match$1._0;
    try {
      const decl$p = find_type_full(path, env)[0];
      const err = Stdlib__List.length(args) !== Stdlib__List.length(decl.type_params) ? ({
            hd: /* Arity */0,
            tl: /* [] */0
          }) : (
          equal$5(env, false, args, decl.type_params) ? type_declarations$1(true, env, last(path), decl$p, id, type_declaration(add_type(id, path, identity), decl)) : ({
                hd: /* Constraint */3,
                tl: /* [] */0
              })
        );
      if (!Caml_obj.caml_notequal(err, /* [] */0)) {
        return ;
      }
      throw new Caml_js_exceptions.MelangeError($$Error$8, {
                MEL_EXN_ID: $$Error$8,
                _1: loc,
                _2: {
                  TAG: /* Definition_mismatch */4,
                  _0: ty,
                  _1: err
                }
              });
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        throw new Caml_js_exceptions.MelangeError($$Error$8, {
                  MEL_EXN_ID: $$Error$8,
                  _1: loc,
                  _2: {
                    TAG: /* Unavailable_type_constructor */17,
                    _0: path
                  }
                });
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  } else {
    throw new Caml_js_exceptions.MelangeError($$Error$8, {
              MEL_EXN_ID: $$Error$8,
              _1: loc,
              _2: {
                TAG: /* Definition_mismatch */4,
                _0: ty,
                _1: /* [] */0
              }
            });
  }
}

function check_well_founded(env, loc, path, to_check, ty) {
  const visited = {
    contents: /* Empty */0
  };
  const check = function (ty0, exp_nodes, ty) {
    const ty$1 = repr(ty);
    if (Curry._2(mem$3, ty$1, exp_nodes)) {
      const match = ty0.desc;
      let tmp;
      tmp = typeof match === "number" || match.TAG !== /* Tconstr */3 ? false : same(match._0, path);
      if (tmp) {
        throw new Caml_js_exceptions.MelangeError($$Error$8, {
                  MEL_EXN_ID: $$Error$8,
                  _1: loc,
                  _2: {
                    TAG: /* Recursive_abbrev */2,
                    _0: name(undefined, path)
                  }
                });
      }
      throw new Caml_js_exceptions.MelangeError($$Error$8, {
                MEL_EXN_ID: $$Error$8,
                _1: loc,
                _2: {
                  TAG: /* Cycle_in_def */3,
                  _0: name(undefined, path),
                  _1: ty0
                }
              });
    }
    let match$1;
    try {
      const prev = Curry._2(find$1, ty$1, visited.contents);
      match$1 = Curry._2(subset$1, exp_nodes, prev) ? [
          true,
          exp_nodes
        ] : [
          false,
          Curry._2(union$3, exp_nodes, prev)
        ];
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        match$1 = [
          false,
          exp_nodes
        ];
      } else {
        throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
      }
    }
    const exp_nodes$1 = match$1[1];
    const snap = snapshot(undefined);
    if (match$1[0]) {
      return ;
    }
    try {
      visited.contents = Curry._3(add$4, ty$1, exp_nodes$1, visited.contents);
      const match$2 = ty$1.desc;
      if (typeof match$2 === "number") {
        throw new Caml_js_exceptions.MelangeError(Cannot_expand, {
                  MEL_EXN_ID: Cannot_expand
                });
      }
      if (match$2.TAG === /* Tconstr */3) {
        if (!Curry._1(is_empty$2, exp_nodes$1) || Curry._1(to_check, match$2._0)) {
          const ty$p = try_expand_once_opt(env, ty$1);
          const ty0$1 = Curry._1(is_empty$2, exp_nodes$1) ? ty$1 : ty0;
          return check(ty0$1, Curry._2(add$3, ty$1, exp_nodes$1), ty$p);
        }
        throw new Caml_js_exceptions.MelangeError(Cannot_expand, {
                  MEL_EXN_ID: Cannot_expand
                });
      }
      throw new Caml_js_exceptions.MelangeError(Cannot_expand, {
                MEL_EXN_ID: Cannot_expand
              });
    }
    catch (raw_exn$1){
      const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
      if (exn$1.MEL_EXN_ID === Cannot_expand) {
        let tmp$1 = true;
        if (!(recursive_types.contents && is_contractive(env, ty$1))) {
          const match$3 = ty$1.desc;
          let tmp$2;
          if (typeof match$3 === "number") {
            tmp$2 = false;
          } else {
            switch (match$3.TAG | 0) {
              case /* Tobject */4 :
              case /* Tvariant */8 :
                  tmp$2 = true;
                  break;
              default:
                tmp$2 = false;
            }
          }
          tmp$1 = tmp$2;
        }
        const nodes = tmp$1 ? /* Empty */0 : exp_nodes$1;
        return iter_type_expr((function (param) {
                      return check(ty0, nodes, param);
                    }), ty$1);
      }
      if (exn$1.MEL_EXN_ID === Unify) {
        return backtrack(snap);
      }
      throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
    }
  };
  wrap_trace_gadt_instances(env, (function (param) {
          return check(ty, /* Empty */0, param);
        }), ty);
}

function check_well_founded_decl(env, loc, path, decl, to_check) {
  const it_it_type_expr = function (param) {
    return function (param) {
      return check_well_founded(env, loc, path, to_check, param);
    };
  };
  const it = {
    it_signature: it_signature,
    it_signature_item: it_signature_item,
    it_value_description: it_value_description,
    it_type_declaration: it_type_declaration,
    it_extension_constructor: it_extension_constructor,
    it_module_declaration: it_module_declaration,
    it_modtype_declaration: it_modtype_declaration,
    it_class_declaration: it_class_declaration,
    it_class_type_declaration: it_class_type_declaration,
    it_module_type: it_module_type,
    it_class_type: it_class_type,
    it_type_kind: it_type_kind,
    it_do_type_expr: it_do_type_expr,
    it_type_expr: it_it_type_expr,
    it_path: it_path
  };
  it_type_declaration(it, instance_declaration(decl));
}

function check_recursion(env, loc, path, decl, to_check) {
  if (Caml_obj.caml_equal(decl.type_params, /* [] */0)) {
    return ;
  }
  const visited = {
    contents: /* [] */0
  };
  const check_regular = function (cpath, args, prev_exp, _ty) {
    while(true) {
      const ty = _ty;
      const ty$1 = repr(ty);
      if (Stdlib__List.memq(ty$1, visited.contents)) {
        return ;
      }
      visited.contents = {
        hd: ty$1,
        tl: visited.contents
      };
      const match = ty$1.desc;
      if (typeof match === "number") {
        return iter_type_expr((function (param) {
                      return check_regular(cpath, args, prev_exp, param);
                    }), ty$1);
      }
      switch (match.TAG | 0) {
        case /* Tconstr */3 :
            const args$p = match._1;
            const path$p = match._0;
            if (same(path, path$p)) {
              if (!equal$5(env, false, args, args$p)) {
                throw new Caml_js_exceptions.MelangeError($$Error$8, {
                          MEL_EXN_ID: $$Error$8,
                          _1: loc,
                          _2: {
                            TAG: /* Parameters_differ */8,
                            _0: cpath,
                            _1: ty$1,
                            _2: newconstr(path, args)
                          }
                        });
              }
              
            } else if (Curry._1(to_check, path$p) && !Stdlib__List.mem(path$p, prev_exp)) {
              try {
                const match$1 = find_type_expansion(path$p, env);
                const params0 = match$1[0];
                const match$2 = instance_parameterized_type(undefined, params0, match$1[1]);
                try {
                  Stdlib__List.iter2((function (param, param$1) {
                          return unify$2(env, param, param$1);
                        }), match$2[0], args$p);
                }
                catch (raw_exn){
                  const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                  if (exn.MEL_EXN_ID === Unify) {
                    throw new Caml_js_exceptions.MelangeError($$Error$8, {
                              MEL_EXN_ID: $$Error$8,
                              _1: loc,
                              _2: {
                                TAG: /* Constraint_failed */5,
                                _0: ty$1,
                                _1: newconstr(path$p, params0)
                              }
                            });
                  }
                  throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
                }
                check_regular(path$p, args, {
                      hd: path$p,
                      tl: prev_exp
                    }, match$2[1]);
              }
              catch (raw_exn$1){
                const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
                if (exn$1.MEL_EXN_ID !== Stdlib.Not_found) {
                  throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
                }
                
              }
            }
            return Stdlib__List.iter((function (param) {
                          return check_regular(cpath, args, prev_exp, param);
                        }), args$p);
        case /* Tpoly */10 :
            const match$3 = instance_poly(true, false, match._1, match._0);
            _ty = match$3[1];
            continue ;
        default:
          return iter_type_expr((function (param) {
                        return check_regular(cpath, args, prev_exp, param);
                      }), ty$1);
      }
    };
  };
  may((function (body) {
          const match = instance_parameterized_type(true, decl.type_params, body);
          check_regular(path, match[0], /* [] */0, match[1]);
        }), decl.type_manifest);
}

function get_variance(ty, visited) {
  try {
    return Curry._2(find$1, ty, visited.contents);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return Types_Variance.$$null;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function compute_variance(env, visited, vari, ty) {
  const compute_variance_rec = function (_vari, _ty) {
    while(true) {
      const ty = _ty;
      const vari = _vari;
      const ty$1 = repr(ty);
      const vari$p = get_variance(ty$1, visited);
      if (Curry._2(Types_Variance.subset, vari, vari$p)) {
        return ;
      }
      const vari$1 = Curry._2(Types_Variance.union, vari, vari$p);
      visited.contents = Curry._3(add$4, ty$1, vari$1, visited.contents);
      const compute_same = function (param) {
        return compute_variance_rec(vari$1, param);
      };
      const tl = ty$1.desc;
      if (typeof tl === "number") {
        return ;
      }
      switch (tl.TAG | 0) {
        case /* Tarrow */1 :
            const v = Curry._1(Types_Variance.conjugate, vari$1);
            const v1 = Curry._2(Types_Variance.mem, /* May_pos */0, v) || Curry._2(Types_Variance.mem, /* May_neg */1, v) ? Curry._3(Types_Variance.set, /* May_weak */2, true, v) : v;
            compute_variance_rec(v1, tl._1);
            _ty = tl._2;
            _vari = vari$1;
            continue ;
        case /* Ttuple */2 :
            return Stdlib__List.iter(compute_same, tl._0);
        case /* Tconstr */3 :
            const tl$1 = tl._1;
            if (Caml_obj.caml_equal(tl$1, /* [] */0)) {
              return ;
            }
            try {
              const decl = find_type_full(tl._0, env)[0];
              return Stdlib__List.iter2((function (ty, v) {
                            const strict = Curry._2(Types_Variance.mem, /* Inv */6, vari$1) && Curry._2(Types_Variance.mem, /* Inj */3, v) || (Curry._2(Types_Variance.mem, /* Pos */4, vari$1) || Curry._2(Types_Variance.mem, /* Neg */5, vari$1)) && Curry._2(Types_Variance.mem, /* Inv */6, v);
                            if (strict) {
                              return compute_variance_rec(Types_Variance.full, ty);
                            }
                            const p1 = Curry._2(Types_Variance.inter, v, vari$1);
                            const n1 = Curry._2(Types_Variance.inter, v, Curry._1(Types_Variance.conjugate, vari$1));
                            const v1 = Curry._2(Types_Variance.union, Curry._2(Types_Variance.inter, Types_Variance.covariant, Curry._2(Types_Variance.union, p1, Curry._1(Types_Variance.conjugate, p1))), Curry._2(Types_Variance.inter, Curry._1(Types_Variance.conjugate, Types_Variance.covariant), Curry._2(Types_Variance.union, n1, Curry._1(Types_Variance.conjugate, n1))));
                            const weak = Curry._2(Types_Variance.mem, /* May_weak */2, vari$1) && (Curry._2(Types_Variance.mem, /* May_pos */0, v) || Curry._2(Types_Variance.mem, /* May_neg */1, v)) || (Curry._2(Types_Variance.mem, /* May_pos */0, vari$1) || Curry._2(Types_Variance.mem, /* May_neg */1, vari$1)) && Curry._2(Types_Variance.mem, /* May_weak */2, v);
                            const v2 = Curry._3(Types_Variance.set, /* May_weak */2, weak, v1);
                            compute_variance_rec(v2, ty);
                          }), tl$1, decl.type_variance);
            }
            catch (raw_exn){
              const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn.MEL_EXN_ID === Stdlib.Not_found) {
                return Stdlib__List.iter((function (param) {
                              return compute_variance_rec(Types_Variance.may_inv, param);
                            }), tl$1);
              }
              throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
            }
        case /* Tfield */5 :
            compute_variance_rec(vari$1, tl._2);
            _ty = tl._3;
            _vari = vari$1;
            continue ;
        case /* Tvariant */8 :
            const row = row_repr_aux(/* [] */0, tl._0);
            Stdlib__List.iter((function (param) {
                    const match = row_field_repr_aux(/* [] */0, param[1]);
                    if (typeof match === "number") {
                      return ;
                    }
                    if (match.TAG === /* Rpresent */0) {
                      const ty = match._0;
                      if (ty !== undefined) {
                        return compute_variance_rec(vari$1, ty);
                      } else {
                        return ;
                      }
                    }
                    const upper = Stdlib__List.fold_left((function (s, f) {
                            return Curry._3(Types_Variance.set, f, true, s);
                          }), Types_Variance.$$null, {
                          hd: /* May_pos */0,
                          tl: {
                            hd: /* May_neg */1,
                            tl: {
                              hd: /* May_weak */2,
                              tl: /* [] */0
                            }
                          }
                        });
                    const v = Curry._2(Types_Variance.inter, vari$1, upper);
                    Stdlib__List.iter((function (param) {
                            return compute_variance_rec(v, param);
                          }), match._1);
                  }), row.row_fields);
            _ty = row.row_more;
            _vari = vari$1;
            continue ;
        case /* Tobject */4 :
        case /* Tsubst */7 :
        case /* Tpoly */10 :
            _ty = tl._0;
            _vari = vari$1;
            continue ;
        case /* Tpackage */11 :
            const v$1 = Curry._2(Types_Variance.mem, /* Pos */4, vari$1) || Curry._2(Types_Variance.mem, /* Neg */5, vari$1) ? Types_Variance.full : Types_Variance.may_inv;
            return Stdlib__List.iter((function (param) {
                          return compute_variance_rec(v$1, param);
                        }), tl._2);
        default:
          return ;
      }
    };
  };
  compute_variance_rec(vari, ty);
}

function make(p, n, i) {
  return Curry._3(Types_Variance.set, /* May_pos */0, p, Curry._3(Types_Variance.set, /* May_neg */1, n, Curry._3(Types_Variance.set, /* May_weak */2, n, Curry._3(Types_Variance.set, /* Inj */3, i, Types_Variance.$$null))));
}

function compute_variance_type(env, check, param, decl, tyl) {
  const loc = param[1];
  const required = Stdlib__List.map((function (param) {
          const i = param[2];
          const n = param[1];
          const c = param[0];
          if (c || n) {
            return [
                    c,
                    n,
                    i
                  ];
          } else {
            return [
                    true,
                    true,
                    i
                  ];
          }
        }), param[0]);
  const params = Stdlib__List.map(repr, decl.type_params);
  const tvl = {
    contents: /* Empty */0
  };
  Stdlib__List.iter((function (param) {
          compute_variance(env, tvl, param[0] ? Types_Variance.full : Types_Variance.covariant, param[1]);
        }), tyl);
  if (check) {
    const pos = {
      contents: 0
    };
    Stdlib__List.iter2((function (ty, param) {
            const i = param[2];
            const n = param[1];
            const c = param[0];
            pos.contents = pos.contents + 1 | 0;
            const $$var = get_variance(ty, tvl);
            const match = Curry._1(Types_Variance.get_upper, $$var);
            const cn = match[1];
            const co = match[0];
            const ij = Curry._2(Types_Variance.mem, /* Inj */3, $$var);
            if (!(is_Tvar(ty) && (co && !c || cn && !n || !ij && i))) {
              return ;
            }
            throw new Caml_js_exceptions.MelangeError($$Error$8, {
                      MEL_EXN_ID: $$Error$8,
                      _1: loc,
                      _2: {
                        TAG: /* Bad_variance */16,
                        _0: pos.contents,
                        _1: [
                          co,
                          cn,
                          ij
                        ],
                        _2: [
                          c,
                          n,
                          i
                        ]
                      }
                    });
          }), params, required);
    const args = newty2(100000000, {
          TAG: /* Ttuple */2,
          _0: params
        });
    const fvl = free_variables$1(undefined, args);
    const fvl$1 = Stdlib__List.filter((function (v) {
            return !Stdlib__List.memq(v, params);
          }), fvl);
    if (!Caml_obj.caml_equal(fvl$1, /* [] */0)) {
      const tvl2 = {
        contents: /* Empty */0
      };
      Stdlib__List.iter2((function (ty, param) {
              if (is_Tvar(ty)) {
                return ;
              }
              const v = param[0] ? (
                  param[1] ? Types_Variance.full : Types_Variance.covariant
                ) : Curry._1(Types_Variance.conjugate, Types_Variance.covariant);
              compute_variance(env, tvl2, v, ty);
            }), params, required);
      const visited = {
        contents: /* Empty */0
      };
      const check$1 = function (ty) {
        const ty$1 = repr(ty);
        if (Curry._2(mem$3, ty$1, visited.contents)) {
          return ;
        }
        const visited$p = Curry._2(add$3, ty$1, visited.contents);
        visited.contents = visited$p;
        const v1 = get_variance(ty$1, tvl);
        const snap = snapshot(undefined);
        const v2 = Curry._3(fold$3, (function (t, vt, v) {
                if (equal$5(env, false, {
                        hd: ty$1,
                        tl: /* [] */0
                      }, {
                        hd: t,
                        tl: /* [] */0
                      })) {
                  return Curry._2(Types_Variance.union, vt, v);
                } else {
                  return v;
                }
              }), tvl2.contents, Types_Variance.$$null);
        backtrack(snap);
        const match = Curry._1(Types_Variance.get_upper, v1);
        const n1 = match[1];
        const c1 = match[0];
        const match$1 = Curry._1(Types_Variance.get_lower, v2);
        const n2 = match$1[1];
        const c2 = match$1[0];
        if (!(c1 && !c2 || n1 && !n2)) {
          return ;
        }
        if (!Stdlib__List.memq(ty$1, fvl$1)) {
          return iter_type_expr(check$1, ty$1);
        }
        const code = match$1[3] ? (
            c2 || n2 ? -1 : -3
          ) : -2;
        throw new Caml_js_exceptions.MelangeError($$Error$8, {
                  MEL_EXN_ID: $$Error$8,
                  _1: loc,
                  _2: {
                    TAG: /* Bad_variance */16,
                    _0: code,
                    _1: [
                      c1,
                      n1,
                      false
                    ],
                    _2: [
                      c2,
                      n2,
                      false
                    ]
                  }
                });
      };
      Stdlib__List.iter((function (param) {
              check$1(param[1]);
            }), tyl);
    }
    
  }
  return Stdlib__List.map2((function (ty, param) {
                const v = get_variance(ty, tvl);
                const tr = decl.type_private;
                const concr = Caml_obj.caml_notequal(decl.type_kind, /* Type_abstract */0);
                const match = tr === /* Private */0 || !is_Tvar(ty) ? [
                    param[0],
                    param[1]
                  ] : [
                    false,
                    false
                  ];
                const n = match[1];
                const p = match[0];
                const i = concr || param[2] && tr === /* Private */0;
                const v$1 = Curry._2(Types_Variance.union, v, make(p, n, i));
                const v$2 = concr ? (
                    Curry._2(Types_Variance.mem, /* Pos */4, v$1) && Curry._2(Types_Variance.mem, /* Neg */5, v$1) ? Types_Variance.full : (
                        is_Tvar(ty) ? v$1 : Curry._2(Types_Variance.union, v$1, p ? (
                                  n ? Types_Variance.full : Types_Variance.covariant
                                ) : Curry._1(Types_Variance.conjugate, Types_Variance.covariant))
                      )
                  ) : v$1;
                if (Caml_obj.caml_equal(decl.type_kind, /* Type_abstract */0) && tr === /* Public */1) {
                  return v$2;
                } else {
                  return Curry._3(Types_Variance.set, /* May_weak */2, Curry._2(Types_Variance.mem, /* May_neg */1, v$2), v$2);
                }
              }), params, required);
}

function add_false(param) {
  return Stdlib__List.map((function (ty) {
                return [
                        false,
                        ty
                      ];
              }), param);
}

function constrained(env, vars, ty) {
  const match = ty.desc;
  if (typeof match === "number" || match.TAG !== /* Tvar */0) {
    return true;
  } else {
    return Stdlib__List.exists((function (tl) {
                  return Stdlib__List.memq(ty, tl);
                }), vars);
  }
}

function compute_variance_gadt(env, check, rloc, decl, param) {
  const ret_type_opt = param[1];
  const tl = param[0];
  const loc = rloc[1];
  if (ret_type_opt === undefined) {
    return compute_variance_type(env, check, rloc, {
                type_params: decl.type_params,
                type_arity: decl.type_arity,
                type_kind: decl.type_kind,
                type_private: /* Private */0,
                type_manifest: decl.type_manifest,
                type_variance: decl.type_variance,
                type_newtype_level: decl.type_newtype_level,
                type_loc: decl.type_loc,
                type_attributes: decl.type_attributes
              }, add_false(tl));
  }
  const match = repr(ret_type_opt);
  const match$1 = match.desc;
  if (typeof match$1 === "number") {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/ocaml_typedtree_test.ml",
                47023,
                13
              ]
            });
  }
  if (match$1.TAG === /* Tconstr */3) {
    const tyl = Stdlib__List.map(repr, match$1._1);
    const fvl = Stdlib__List.map((function (param) {
            return free_variables$1(undefined, param);
          }), tyl);
    Stdlib__List.fold_left2((function (param, ty, param$1) {
            const fv2 = param[1];
            if (fv2) {
              const fv2$1 = fv2.tl;
              const fv1 = param[0];
              if ((param$1[0] || param$1[1]) && constrained(env, Stdlib.$at(fv1, fv2$1), ty)) {
                throw new Caml_js_exceptions.MelangeError($$Error$8, {
                          MEL_EXN_ID: $$Error$8,
                          _1: loc,
                          _2: /* Varying_anonymous */4
                        });
              }
              return [
                      {
                        hd: fv2.hd,
                        tl: fv1
                      },
                      fv2$1
                    ];
            }
            throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                      MEL_EXN_ID: "Assert_failure",
                      _1: [
                        "jscomp/test/ocaml_typedtree_test.ml",
                        47012,
                        37
                      ]
                    });
          }), [
          /* [] */0,
          fvl
        ], tyl, rloc[0]);
    return compute_variance_type(env, check, rloc, {
                type_params: tyl,
                type_arity: decl.type_arity,
                type_kind: decl.type_kind,
                type_private: /* Private */0,
                type_manifest: decl.type_manifest,
                type_variance: decl.type_variance,
                type_newtype_level: decl.type_newtype_level,
                type_loc: decl.type_loc,
                type_attributes: decl.type_attributes
              }, add_false(tl));
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              47023,
              13
            ]
          });
}

function compute_variance_extension(env, check, decl, ext, rloc) {
  return compute_variance_gadt(env, check, rloc, {
              type_params: ext.ext_type_params,
              type_arity: decl.type_arity,
              type_kind: decl.type_kind,
              type_private: decl.type_private,
              type_manifest: decl.type_manifest,
              type_variance: decl.type_variance,
              type_newtype_level: decl.type_newtype_level,
              type_loc: decl.type_loc,
              type_attributes: decl.type_attributes
            }, [
              ext.ext_args,
              ext.ext_ret_type
            ]);
}

function compute_variance_decl(env, check, decl, rloc) {
  if ((Caml_obj.caml_equal(decl.type_kind, /* Type_abstract */0) || Caml_obj.caml_equal(decl.type_kind, /* Type_open */1)) && decl.type_manifest === undefined) {
    return Stdlib__List.map((function (param) {
                  return make(!param[1], !param[0], Caml_obj.caml_notequal(decl.type_kind, /* Type_abstract */0) || param[2]);
                }), rloc[0]);
  }
  const ty = decl.type_manifest;
  const mn = ty !== undefined ? ({
        hd: [
          false,
          ty
        ],
        tl: /* [] */0
      }) : /* [] */0;
  const tll = decl.type_kind;
  if (typeof tll === "number") {
    return compute_variance_type(env, check, rloc, decl, mn);
  }
  if (tll.TAG === /* Type_record */0) {
    return compute_variance_type(env, check, rloc, decl, Stdlib.$at(mn, Stdlib__List.map((function (param) {
                          return [
                                  param.ld_mutable === /* Mutable */1,
                                  param.ld_type
                                ];
                        }), tll._0)));
  }
  const tll$1 = tll._0;
  if (Stdlib__List.for_all((function (c) {
            return c.cd_res === undefined;
          }), tll$1)) {
    return compute_variance_type(env, check, rloc, decl, Stdlib.$at(mn, add_false(Stdlib__List.flatten(Stdlib__List.map((function (c) {
                                  return c.cd_args;
                                }), tll$1)))));
  }
  const mn$1 = Stdlib__List.map((function (param) {
          return [
                  {
                    hd: param[1],
                    tl: /* [] */0
                  },
                  undefined
                ];
        }), mn);
  const tll$2 = Stdlib.$at(mn$1, Stdlib__List.map((function (c) {
              return [
                      c.cd_args,
                      c.cd_res
                    ];
            }), tll$1));
  const match = Stdlib__List.map((function (param) {
          return compute_variance_gadt(env, check, rloc, decl, param);
        }), tll$2);
  if (match) {
    const varl = Stdlib__List.fold_left((function (param, param$1) {
            return Stdlib__List.map2(Types_Variance.union, param, param$1);
          }), match.hd, match.tl);
    return Stdlib__List.map((function (v) {
                  if (Curry._2(Types_Variance.mem, /* Pos */4, v) && Curry._2(Types_Variance.mem, /* Neg */5, v)) {
                    return Types_Variance.full;
                  } else {
                    return v;
                  }
                }), varl);
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/ocaml_typedtree_test.ml",
              47062,
              15
            ]
          });
}

function is_sharp(id) {
  const s = id.name;
  if (s.length !== 0) {
    return Caml_string.get(s, 0) === /* '#' */35;
  } else {
    return false;
  }
}

function compute_variance_fixpoint(env, decls, required, _variances) {
  while(true) {
    const variances = _variances;
    const new_decls = Stdlib__List.map2((function (param, variance) {
            const decl = param[1];
            return [
                    param[0],
                    {
                      type_params: decl.type_params,
                      type_arity: decl.type_arity,
                      type_kind: decl.type_kind,
                      type_private: decl.type_private,
                      type_manifest: decl.type_manifest,
                      type_variance: variance,
                      type_newtype_level: decl.type_newtype_level,
                      type_loc: decl.type_loc,
                      type_attributes: decl.type_attributes
                    }
                  ];
          }), decls, variances);
    const new_env = Stdlib__List.fold_right((function (param, env) {
            return add_type$1(true, param[0], param[1], env);
          }), new_decls, env);
    const new_variances = Stdlib__List.map2((function (param) {
            const decl = param[1];
            return function (param) {
              return compute_variance_decl(new_env, false, decl, param);
            };
          }), new_decls, required);
    const new_variances$1 = Stdlib__List.map2((function (param, param$1) {
            return Stdlib__List.map2(Types_Variance.union, param, param$1);
          }), new_variances, variances);
    if (Caml_obj.caml_notequal(new_variances$1, variances)) {
      _variances = new_variances$1;
      continue ;
    }
    Stdlib__List.iter2((function (param, req) {
            if (!is_sharp(param[0])) {
              compute_variance_decl(new_env, true, param[1], req);
              return ;
            }
            
          }), new_decls, required);
    return [
            new_decls,
            new_env
          ];
  };
}

function init_variance(param) {
  return Stdlib__List.map((function (param) {
                return Types_Variance.$$null;
              }), param[1].type_params);
}

function add_injectivity(param) {
  return Stdlib__List.map((function (param) {
                switch (param) {
                  case /* Covariant */0 :
                      return [
                              true,
                              false,
                              false
                            ];
                  case /* Contravariant */1 :
                      return [
                              false,
                              true,
                              false
                            ];
                  case /* Invariant */2 :
                      return [
                              false,
                              false,
                              false
                            ];
                  
                }
              }), param);
}

function compute_variance_decls(env, cldecls) {
  const match = Stdlib__List.fold_right((function (param, param$1) {
          const ci = param[5];
          const variance = Stdlib__List.map((function (prim) {
                  return prim[1];
                }), ci.ci_params);
          return [
                  {
                    hd: [
                      param[0],
                      param[1]
                    ],
                    tl: param$1[0]
                  },
                  {
                    hd: [
                      add_injectivity(variance),
                      ci.ci_loc
                    ],
                    tl: param$1[1]
                  }
                ];
        }), cldecls, [
        /* [] */0,
        /* [] */0
      ]);
  const decls = match[0];
  const variances = Stdlib__List.map(init_variance, decls);
  const match$1 = compute_variance_fixpoint(env, decls, match[1], variances);
  return Stdlib__List.map2((function (param, param$1) {
                const cltydef = param$1[4];
                const clty = param$1[3];
                const cl_abbr = param$1[2];
                const decl = param[1];
                const variance = decl.type_variance;
                return [
                        decl,
                        {
                          type_params: cl_abbr.type_params,
                          type_arity: cl_abbr.type_arity,
                          type_kind: cl_abbr.type_kind,
                          type_private: cl_abbr.type_private,
                          type_manifest: cl_abbr.type_manifest,
                          type_variance: variance,
                          type_newtype_level: cl_abbr.type_newtype_level,
                          type_loc: cl_abbr.type_loc,
                          type_attributes: cl_abbr.type_attributes
                        },
                        {
                          cty_params: clty.cty_params,
                          cty_type: clty.cty_type,
                          cty_path: clty.cty_path,
                          cty_new: clty.cty_new,
                          cty_variance: variance,
                          cty_loc: clty.cty_loc,
                          cty_attributes: clty.cty_attributes
                        },
                        {
                          clty_params: cltydef.clty_params,
                          clty_type: cltydef.clty_type,
                          clty_path: cltydef.clty_path,
                          clty_variance: variance,
                          clty_loc: cltydef.clty_loc,
                          clty_attributes: cltydef.clty_attributes
                        }
                      ];
              }), match$1[0], cldecls);
}

function check_duplicates(sdecl_list) {
  const labels = Stdlib__Hashtbl.create(undefined, 7);
  const constrs = Stdlib__Hashtbl.create(undefined, 7);
  Stdlib__List.iter((function (sdecl) {
          const cl = sdecl.ptype_kind;
          if (typeof cl === "number") {
            return ;
          } else if (cl.TAG === /* Ptype_variant */0) {
            return Stdlib__List.iter((function (pcd) {
                          try {
                            const name$p = Stdlib__Hashtbl.find(constrs, pcd.pcd_name.txt);
                            return prerr_warning(pcd.pcd_loc, {
                                        TAG: /* Duplicate_definitions */14,
                                        _0: "constructor",
                                        _1: pcd.pcd_name.txt,
                                        _2: name$p,
                                        _3: sdecl.ptype_name.txt
                                      });
                          }
                          catch (raw_exn){
                            const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                            if (exn.MEL_EXN_ID === Stdlib.Not_found) {
                              return Stdlib__Hashtbl.add(constrs, pcd.pcd_name.txt, sdecl.ptype_name.txt);
                            }
                            throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
                          }
                        }), cl._0);
          } else {
            return Stdlib__List.iter((function (param) {
                          const cname = param.pld_name;
                          try {
                            const name$p = Stdlib__Hashtbl.find(labels, cname.txt);
                            return prerr_warning(param.pld_loc, {
                                        TAG: /* Duplicate_definitions */14,
                                        _0: "label",
                                        _1: cname.txt,
                                        _2: name$p,
                                        _3: sdecl.ptype_name.txt
                                      });
                          }
                          catch (raw_exn){
                            const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                            if (exn.MEL_EXN_ID === Stdlib.Not_found) {
                              return Stdlib__Hashtbl.add(labels, cname.txt, sdecl.ptype_name.txt);
                            }
                            throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
                          }
                        }), cl._0);
          }
        }), sdecl_list);
}

function name_recursion(sdecl, id, decl) {
  const match = decl.type_kind;
  if (typeof match !== "number") {
    return decl;
  }
  if (match) {
    return decl;
  }
  if (decl.type_private) {
    return decl;
  }
  const ty = decl.type_manifest;
  if (ty === undefined) {
    return decl;
  }
  if (!is_fixed_type(sdecl)) {
    return decl;
  }
  const ty$1 = repr(ty);
  const ty$p = newty2(ty$1.level, ty$1.desc);
  if (!deep_occur(ty$1, ty$p)) {
    return decl;
  }
  const td_0 = {
    TAG: /* Pident */0,
    _0: id
  };
  const td_1 = decl.type_params;
  const td_2 = {
    contents: /* Mnil */0
  };
  const td = {
    TAG: /* Tconstr */3,
    _0: td_0,
    _1: td_1,
    _2: td_2
  };
  link_type(ty$1, newty2(ty$1.level, td));
  return {
          type_params: decl.type_params,
          type_arity: decl.type_arity,
          type_kind: decl.type_kind,
          type_private: decl.type_private,
          type_manifest: ty$p,
          type_variance: decl.type_variance,
          type_newtype_level: decl.type_newtype_level,
          type_loc: decl.type_loc,
          type_attributes: decl.type_attributes
        };
}

function transl_type_decl(env, rec_flag, sdecl_list) {
  const fixed_types = Stdlib__List.filter(is_fixed_type, sdecl_list);
  const sdecl_list$1 = Stdlib.$at(Stdlib__List.map((function (sdecl) {
              const ptype_name_txt = sdecl.ptype_name.txt + "#row";
              const ptype_name_loc = sdecl.ptype_name.loc;
              const ptype_name = {
                txt: ptype_name_txt,
                loc: ptype_name_loc
              };
              return {
                      ptype_name: ptype_name,
                      ptype_params: sdecl.ptype_params,
                      ptype_cstrs: sdecl.ptype_cstrs,
                      ptype_kind: /* Ptype_abstract */0,
                      ptype_private: sdecl.ptype_private,
                      ptype_manifest: undefined,
                      ptype_attributes: sdecl.ptype_attributes,
                      ptype_loc: sdecl.ptype_loc
                    };
            }), fixed_types), sdecl_list);
  const id_list = Stdlib__List.map((function (sdecl) {
          return create(sdecl.ptype_name.txt);
        }), sdecl_list$1);
  init_def(currentstamp.contents);
  begin_def(undefined);
  const temp_env = rec_flag ? Stdlib__List.fold_left2(enter_type$1, env, sdecl_list$1, id_list) : env;
  const current_slot = {
    contents: undefined
  };
  const warn_unused = is_active({
        TAG: /* Unused_type_declaration */18,
        _0: ""
      });
  const id_slots = function (id) {
    if (!rec_flag) {
      return [
              id,
              undefined
            ];
    }
    if (!warn_unused) {
      return [
              id,
              undefined
            ];
    }
    const slot = {
      contents: /* [] */0
    };
    const td = find_type_full({
            TAG: /* Pident */0,
            _0: id
          }, temp_env)[0];
    const name = id.name;
    set_type_used_callback(name, td, (function (old_callback) {
            const slot$1 = current_slot.contents;
            if (slot$1 !== undefined) {
              slot$1.contents = {
                hd: [
                  name,
                  td
                ],
                tl: slot$1.contents
              };
              return ;
            } else {
              Stdlib__List.iter((function (param) {
                      mark_type_used(env, param[0], param[1]);
                    }), get_ref(slot));
              return Curry._1(old_callback, undefined);
            }
          }));
    return [
            id,
            slot
          ];
  };
  const transl_declaration = function (name_sdecl, param) {
    current_slot.contents = param[1];
    let id = param[0];
    reset_type_variables(undefined);
    begin_def(undefined);
    const tparams = make_params(temp_env, name_sdecl.ptype_params);
    const params = Stdlib__List.map((function (param) {
            return param[0].ctyp_type;
          }), tparams);
    const cstrs = Stdlib__List.map((function (param) {
            return [
                    transl_simple_type(temp_env, false, param[0]),
                    transl_simple_type(temp_env, false, param[1]),
                    param[2]
                  ];
          }), name_sdecl.ptype_cstrs);
    const scstrs = name_sdecl.ptype_kind;
    let match;
    if (typeof scstrs === "number") {
      match = scstrs === /* Ptype_abstract */0 ? [
          /* Ttype_abstract */0,
          /* Type_abstract */0
        ] : [
          /* Ttype_open */1,
          /* Type_open */1
        ];
    } else if (scstrs.TAG === /* Ptype_variant */0) {
      const scstrs$1 = scstrs._0;
      if (Caml_obj.caml_equal(scstrs$1, /* [] */0)) {
        ill_formed_ast(name_sdecl.ptype_loc, "Variant types cannot be empty.");
      }
      const all_constrs = {
        contents: /* Empty */0
      };
      Stdlib__List.iter((function (param) {
              const name = param.pcd_name.txt;
              if (Curry._2(mem$6, name, all_constrs.contents)) {
                throw new Caml_js_exceptions.MelangeError($$Error$8, {
                          MEL_EXN_ID: $$Error$8,
                          _1: name_sdecl.ptype_loc,
                          _2: {
                            TAG: /* Duplicate_constructor */0,
                            _0: name
                          }
                        });
              }
              all_constrs.contents = Curry._2(add$12, name, all_constrs.contents);
            }), scstrs$1);
      if (Stdlib__List.length(Stdlib__List.filter((function (cd) {
                    return Caml_obj.caml_notequal(cd.pcd_args, /* [] */0);
                  }), scstrs$1)) > 246) {
        throw new Caml_js_exceptions.MelangeError($$Error$8, {
                  MEL_EXN_ID: $$Error$8,
                  _1: name_sdecl.ptype_loc,
                  _2: /* Too_many_constructors */1
                });
      }
      const make_cstr = function (scstr) {
        const name = create(scstr.pcd_name.txt);
        const match = make_constructor(temp_env, {
              TAG: /* Pident */0,
              _0: id
            }, params, scstr.pcd_args, scstr.pcd_res);
        const tcstr_cd_name = scstr.pcd_name;
        const tcstr_cd_args = match[0];
        const tcstr_cd_res = match[1];
        const tcstr_cd_loc = scstr.pcd_loc;
        const tcstr_cd_attributes = scstr.pcd_attributes;
        const tcstr = {
          cd_id: name,
          cd_name: tcstr_cd_name,
          cd_args: tcstr_cd_args,
          cd_res: tcstr_cd_res,
          cd_loc: tcstr_cd_loc,
          cd_attributes: tcstr_cd_attributes
        };
        const cstr_cd_args = match[2];
        const cstr_cd_res = match[3];
        const cstr_cd_loc = scstr.pcd_loc;
        const cstr_cd_attributes = scstr.pcd_attributes;
        const cstr = {
          cd_id: name,
          cd_args: cstr_cd_args,
          cd_res: cstr_cd_res,
          cd_loc: cstr_cd_loc,
          cd_attributes: cstr_cd_attributes
        };
        return [
                tcstr,
                cstr
              ];
      };
      const match$1 = Stdlib__List.split(Stdlib__List.map(make_cstr, scstrs$1));
      match = [
        {
          TAG: /* Ttype_variant */0,
          _0: match$1[0]
        },
        {
          TAG: /* Type_variant */1,
          _0: match$1[1]
        }
      ];
    } else {
      const lbls = scstrs._0;
      if (Caml_obj.caml_equal(lbls, /* [] */0)) {
        ill_formed_ast(name_sdecl.ptype_loc, "Records cannot be empty.");
      }
      const all_labels = {
        contents: /* Empty */0
      };
      Stdlib__List.iter((function (param) {
              const name = param.pld_name.txt;
              if (Curry._2(mem$6, name, all_labels.contents)) {
                throw new Caml_js_exceptions.MelangeError($$Error$8, {
                          MEL_EXN_ID: $$Error$8,
                          _1: name_sdecl.ptype_loc,
                          _2: {
                            TAG: /* Duplicate_label */1,
                            _0: name
                          }
                        });
              }
              all_labels.contents = Curry._2(add$12, name, all_labels.contents);
            }), lbls);
      const lbls$1 = Stdlib__List.map((function (param) {
              const name = param.pld_name;
              const arg = force_poly(param.pld_type);
              const cty = transl_simple_type(temp_env, true, arg);
              return {
                      ld_id: create(name.txt),
                      ld_name: name,
                      ld_mutable: param.pld_mutable,
                      ld_type: cty,
                      ld_loc: param.pld_loc,
                      ld_attributes: param.pld_attributes
                    };
            }), lbls);
      const lbls$p = Stdlib__List.map((function (ld) {
              const ty = ld.ld_type.ctyp_type;
              const match = ty.desc;
              let ty$1;
              ty$1 = typeof match === "number" || !(match.TAG === /* Tpoly */10 && !match._1) ? ty : match._0;
              return {
                      ld_id: ld.ld_id,
                      ld_mutable: ld.ld_mutable,
                      ld_type: ty$1,
                      ld_loc: ld.ld_loc,
                      ld_attributes: ld.ld_attributes
                    };
            }), lbls$1);
      const rep = Stdlib__List.for_all((function (l) {
              let ty = l.ld_type;
              const match = repr(expand_head_opt(temp_env, ty));
              const match$1 = match.desc;
              if (typeof match$1 === "number" || match$1.TAG !== /* Tconstr */3) {
                return false;
              } else {
                return same(match$1._0, path_float);
              }
            }), lbls$p) ? /* Record_float */1 : /* Record_regular */0;
      match = [
        {
          TAG: /* Ttype_record */1,
          _0: lbls$1
        },
        {
          TAG: /* Type_record */0,
          _0: lbls$p,
          _1: rep
        }
      ];
    }
    const sty = name_sdecl.ptype_manifest;
    let match$2;
    if (sty !== undefined) {
      const no_row = !is_fixed_type(name_sdecl);
      const cty = transl_simple_type(temp_env, no_row, sty);
      match$2 = [
        cty,
        cty.ctyp_type
      ];
    } else {
      match$2 = [
        undefined,
        undefined
      ];
    }
    const man = match$2[1];
    const decl_type_arity = Stdlib__List.length(params);
    const decl_type_kind = match[1];
    const decl_type_private = name_sdecl.ptype_private;
    const decl_type_variance = Stdlib__List.map((function (param) {
            return Types_Variance.full;
          }), params);
    const decl_type_loc = name_sdecl.ptype_loc;
    const decl_type_attributes = name_sdecl.ptype_attributes;
    const decl = {
      type_params: params,
      type_arity: decl_type_arity,
      type_kind: decl_type_kind,
      type_private: decl_type_private,
      type_manifest: man,
      type_variance: decl_type_variance,
      type_newtype_level: undefined,
      type_loc: decl_type_loc,
      type_attributes: decl_type_attributes
    };
    Stdlib__List.iter((function (param) {
            const ty = param[0].ctyp_type;
            const ty$p = param[1].ctyp_type;
            try {
              return unify$2(temp_env, ty, ty$p);
            }
            catch (raw_tr){
              const tr = Caml_js_exceptions.internalToOCamlException(raw_tr);
              if (tr.MEL_EXN_ID === Unify) {
                throw new Caml_js_exceptions.MelangeError($$Error$8, {
                          MEL_EXN_ID: $$Error$8,
                          _1: param[2],
                          _2: {
                            TAG: /* Inconsistent_constraint */6,
                            _0: temp_env,
                            _1: tr._1
                          }
                        });
              }
              throw new Caml_js_exceptions.MelangeError(tr.MEL_EXN_ID, tr);
            }
          }), cstrs);
    end_def(undefined);
    if (is_fixed_type(name_sdecl)) {
      let match$3;
      try {
        match$3 = lookup_type$1({
              TAG: /* Lident */0,
              _0: id.name + "#row"
            }, temp_env);
      }
      catch (raw_exn){
        const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.MEL_EXN_ID === Stdlib.Not_found) {
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                    MEL_EXN_ID: "Assert_failure",
                    _1: [
                      "jscomp/test/ocaml_typedtree_test.ml",
                      46515,
                      26
                    ]
                  });
        }
        throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
      }
      set_fixed_row(temp_env, name_sdecl.ptype_loc, match$3[0], decl);
    }
    if (man !== undefined && cyclic_abbrev(temp_env, id, man)) {
      throw new Caml_js_exceptions.MelangeError($$Error$8, {
                MEL_EXN_ID: $$Error$8,
                _1: name_sdecl.ptype_loc,
                _2: {
                  TAG: /* Recursive_abbrev */2,
                  _0: name_sdecl.ptype_name.txt
                }
              });
    }
    return {
            typ_id: id,
            typ_name: name_sdecl.ptype_name,
            typ_params: tparams,
            typ_type: decl,
            typ_cstrs: cstrs,
            typ_kind: match[0],
            typ_private: name_sdecl.ptype_private,
            typ_manifest: match$2[0],
            typ_loc: name_sdecl.ptype_loc,
            typ_attributes: name_sdecl.ptype_attributes
          };
  };
  const tdecls = Stdlib__List.map2(transl_declaration, sdecl_list$1, Stdlib__List.map(id_slots, id_list));
  const decls = Stdlib__List.map((function (tdecl) {
          return [
                  tdecl.typ_id,
                  tdecl.typ_type
                ];
        }), tdecls);
  current_slot.contents = undefined;
  check_duplicates(sdecl_list$1);
  const newenv = Stdlib__List.fold_right((function (param, env) {
          return add_type$1(true, param[0], param[1], env);
        }), decls, env);
  if (rec_flag) {
    Stdlib__List.iter2((function (id, sdecl) {
            let loc = sdecl.ptype_loc;
            const path = {
              TAG: /* Pident */0,
              _0: id
            };
            const decl = find_type_full(path, temp_env)[0];
            const ty = decl.type_manifest;
            if (ty === undefined) {
              return ;
            }
            const params = Stdlib__List.map((function (param) {
                    return newvar(undefined, undefined);
                  }), decl.type_params);
            try {
              return unify$2(newenv, newconstr(path, params), ty);
            }
            catch (raw_trace){
              const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
              if (trace.MEL_EXN_ID === Unify) {
                throw new Caml_js_exceptions.MelangeError($$Error$8, {
                          MEL_EXN_ID: $$Error$8,
                          _1: loc,
                          _2: {
                            TAG: /* Type_clash */7,
                            _0: newenv,
                            _1: trace._1
                          }
                        });
              }
              throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
            }
          }), id_list, sdecl_list$1);
  }
  end_def(undefined);
  Stdlib__List.iter((function (param) {
          generalize_decl(param[1]);
        }), decls);
  const id_loc_list = Stdlib__List.map2((function (id, sdecl) {
          return [
                  id,
                  sdecl.ptype_loc
                ];
        }), id_list, sdecl_list$1);
  Stdlib__List.iter((function (param) {
          const id = param[0];
          let loc = Stdlib__List.assoc(id, id_loc_list);
          let path = {
            TAG: /* Pident */0,
            _0: id
          };
          let decl = param[1];
          if (decl.type_manifest === undefined) {
            return ;
          }
          const args = Stdlib__List.map((function (param) {
                  return newvar(undefined, undefined);
                }), decl.type_params);
          check_well_founded(newenv, loc, path, (function (param) {
                  return same(path, param);
                }), newconstr(path, args));
        }), decls);
  const to_check = function (id) {
    switch (id.TAG | 0) {
      case /* Pident */0 :
          return Stdlib__List.mem_assoc(id._0, id_loc_list);
      case /* Pdot */1 :
      case /* Papply */2 :
          return false;
      
    }
  };
  Stdlib__List.iter((function (param) {
          const id = param[0];
          check_well_founded_decl(newenv, Stdlib__List.assoc(id, id_loc_list), {
                TAG: /* Pident */0,
                _0: id
              }, param[1], to_check);
        }), decls);
  Stdlib__List.iter((function (param) {
          const decl = param.typ_type;
          const id = param.typ_id;
          return check_recursion(newenv, Stdlib__List.assoc(id, id_loc_list), {
                      TAG: /* Pident */0,
                      _0: id
                    }, decl, to_check);
        }), tdecls);
  Stdlib__List.iter2((function (sdecl, tdecl) {
          const decl = tdecl.typ_type;
          const ty = closed_type_decl(decl);
          if (ty === undefined) {
            return ;
          }
          throw new Caml_js_exceptions.MelangeError($$Error$8, {
                    MEL_EXN_ID: $$Error$8,
                    _1: sdecl.ptype_loc,
                    _2: {
                      TAG: /* Unbound_type_var */9,
                      _0: ty,
                      _1: decl
                    }
                  });
        }), sdecl_list$1, tdecls);
  Stdlib__List.iter2((function (param, param$1) {
          const decl = param$1[1];
          const visited = {
            contents: /* Empty */0
          };
          const l = decl.type_kind;
          if (typeof l === "number") {
            l === /* Type_abstract */0;
          } else if (l.TAG === /* Type_record */0) {
            const find_pl = function (pl) {
              if (typeof pl === "number") {
                throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                          MEL_EXN_ID: "Assert_failure",
                          _1: [
                            "jscomp/test/ocaml_typedtree_test.ml",
                            46623,
                            59
                          ]
                        });
              }
              if (pl.TAG === /* Ptype_record */1) {
                return pl._0;
              }
              throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                        MEL_EXN_ID: "Assert_failure",
                        _1: [
                          "jscomp/test/ocaml_typedtree_test.ml",
                          46623,
                          59
                        ]
                      });
            };
            const pl = find_pl(param.ptype_kind);
            const get_loc = function (name, _param) {
              while(true) {
                const param = _param;
                if (param) {
                  const pld = param.hd;
                  if (name === pld.pld_name.txt) {
                    return pld.pld_type.ptyp_loc;
                  }
                  _param = param.tl;
                  continue ;
                }
                throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                          MEL_EXN_ID: "Assert_failure",
                          _1: [
                            "jscomp/test/ocaml_typedtree_test.ml",
                            46627,
                            16
                          ]
                        });
              };
            };
            Stdlib__List.iter((function (param) {
                    check_constraints_rec(newenv, get_loc(param.ld_id.name, pl), visited, param.ld_type);
                  }), l._0);
          } else {
            const find_pl$1 = function (pl) {
              if (typeof pl === "number") {
                throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                          MEL_EXN_ID: "Assert_failure",
                          _1: [
                            "jscomp/test/ocaml_typedtree_test.ml",
                            46596,
                            58
                          ]
                        });
              }
              if (pl.TAG === /* Ptype_variant */0) {
                return pl._0;
              }
              throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                        MEL_EXN_ID: "Assert_failure",
                        _1: [
                          "jscomp/test/ocaml_typedtree_test.ml",
                          46596,
                          58
                        ]
                      });
            };
            const pl$1 = find_pl$1(param.ptype_kind);
            const foldf = function (acc, x) {
              return Curry._3(add$13, x.pcd_name.txt, x, acc);
            };
            const pl_index = Stdlib__List.fold_left(foldf, /* Empty */0, pl$1);
            Stdlib__List.iter((function (param) {
                    const ret_type = param.cd_res;
                    let match;
                    try {
                      match = Curry._2(find$6, param.cd_id.name, pl_index);
                    }
                    catch (raw_exn){
                      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
                        throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                                  MEL_EXN_ID: "Assert_failure",
                                  _1: [
                                    "jscomp/test/ocaml_typedtree_test.ml",
                                    46609,
                                    30
                                  ]
                                });
                      }
                      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
                    }
                    const sret_type = match.pcd_res;
                    Stdlib__List.iter2((function (sty, ty) {
                            check_constraints_rec(newenv, sty.ptyp_loc, visited, ty);
                          }), match.pcd_args, param.cd_args);
                    if (sret_type !== undefined && ret_type !== undefined) {
                      return check_constraints_rec(newenv, sret_type.ptyp_loc, visited, ret_type);
                    }
                    
                  }), l._0);
          }
          const ty = decl.type_manifest;
          if (ty === undefined) {
            return ;
          }
          const sty = param.ptype_manifest;
          let sty$1;
          if (sty !== undefined) {
            sty$1 = sty;
          } else {
            throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                      MEL_EXN_ID: "Assert_failure",
                      _1: [
                        "jscomp/test/ocaml_typedtree_test.ml",
                        46642,
                        63
                      ]
                    });
          }
          return check_constraints_rec(newenv, sty$1.ptyp_loc, visited, ty);
        }), sdecl_list$1, decls);
  const decls$1 = Stdlib__List.map2((function (sdecl, param) {
          const id = param[0];
          return [
                  id,
                  name_recursion(sdecl, id, param[1])
                ];
        }), sdecl_list$1, decls);
  const required = Stdlib__List.map((function (sdecl) {
          return [
                  add_injectivity(Stdlib__List.map((function (prim) {
                              return prim[1];
                            }), sdecl.ptype_params)),
                  sdecl.ptype_loc
                ];
        }), sdecl_list$1);
  const match = compute_variance_fixpoint(env, decls$1, required, Stdlib__List.map(init_variance, decls$1));
  const final_env = match[1];
  const final_decls = match[0];
  Stdlib__List.iter2((function (param, param$1) {
          return check_coherence(final_env, param.ptype_loc, param$1[0], param$1[1]);
        }), sdecl_list$1, final_decls);
  const final_decls$1 = Stdlib__List.map2((function (tdecl, param) {
          return {
                  typ_id: tdecl.typ_id,
                  typ_name: tdecl.typ_name,
                  typ_params: tdecl.typ_params,
                  typ_type: param[1],
                  typ_cstrs: tdecl.typ_cstrs,
                  typ_kind: tdecl.typ_kind,
                  typ_private: tdecl.typ_private,
                  typ_manifest: tdecl.typ_manifest,
                  typ_loc: tdecl.typ_loc,
                  typ_attributes: tdecl.typ_attributes
                };
        }), tdecls, final_decls);
  return [
          final_decls$1,
          final_env
        ];
}

function transl_extension_constructor(env, check_open, type_path, type_params, typext_params, priv, sext) {
  const id = create(sext.pext_name.txt);
  const lid = sext.pext_kind;
  let match;
  if (lid.TAG === /* Pext_decl */0) {
    const match$1 = make_constructor(env, type_path, typext_params, lid._0, lid._1);
    match = [
      match$1[2],
      match$1[3],
      {
        TAG: /* Text_decl */0,
        _0: match$1[0],
        _1: match$1[1]
      }
    ];
  } else {
    const lid$1 = lid._0;
    const cdescr = find_constructor(env, sext.pext_loc, lid$1.txt);
    const usage = cdescr.cstr_private === /* Private */0 || priv === /* Public */1 ? /* Positive */0 : /* Privatize */2;
    mark_constructor(usage, env, last$1(lid$1.txt), cdescr);
    const match$2 = instance_constructor(undefined, cdescr);
    const args = match$2[0];
    let match$3;
    if (cdescr.cstr_generalized) {
      const params = instance_list(env, type_params);
      const res = newconstr(type_path, params);
      const ret_type = newconstr(type_path, params);
      match$3 = [
        res,
        ret_type
      ];
    } else {
      match$3 = [
        newconstr(type_path, typext_params),
        undefined
      ];
    }
    try {
      unify$2(env, match$2[1], match$3[0]);
    }
    catch (raw_trace){
      const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
      if (trace.MEL_EXN_ID === Unify) {
        throw new Caml_js_exceptions.MelangeError($$Error$8, {
                  MEL_EXN_ID: $$Error$8,
                  _1: lid$1.loc,
                  _2: {
                    TAG: /* Rebind_wrong_type */13,
                    _0: lid$1.txt,
                    _1: env,
                    _2: trace._1
                  }
                });
      }
      throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
    }
    if (!cdescr.cstr_generalized) {
      const vars = free_variables$1(undefined, newty2(100000000, {
                TAG: /* Ttuple */2,
                _0: args
              }));
      Stdlib__List.iter((function (ty) {
              const match = ty.desc;
              if (typeof match === "number") {
                return ;
              }
              if (match.TAG !== /* Tvar */0) {
                return ;
              }
              const match$1 = match._0;
              if (match$1 !== undefined && match$1 === "_" && Stdlib__List.memq(ty, vars)) {
                ty.desc = {
                  TAG: /* Tvar */0,
                  _0: undefined
                };
                return ;
              }
              
            }), typext_params);
    }
    const match$4 = cdescr.cstr_res.desc;
    let match$5;
    if (typeof match$4 === "number") {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  47376,
                  17
                ]
              });
    }
    if (match$4.TAG === /* Tconstr */3) {
      const p = match$4._0;
      const decl = find_type_full(p, env)[0];
      match$5 = [
        p,
        decl.type_params
      ];
    } else {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  47376,
                  17
                ]
              });
    }
    const cstr_type_params = match$5[1];
    const cstr_type_path = match$5[0];
    const cstr_types_0 = newty2(100000000, {
          TAG: /* Tconstr */3,
          _0: cstr_type_path,
          _1: cstr_type_params,
          _2: {
            contents: /* Mnil */0
          }
        });
    const cstr_types = {
      hd: cstr_types_0,
      tl: cstr_type_params
    };
    const ext_types_0 = newty2(100000000, {
          TAG: /* Tconstr */3,
          _0: type_path,
          _1: type_params,
          _2: {
            contents: /* Mnil */0
          }
        });
    const ext_types = {
      hd: ext_types_0,
      tl: type_params
    };
    if (!equal$5(env, true, cstr_types, ext_types)) {
      throw new Caml_js_exceptions.MelangeError($$Error$8, {
                MEL_EXN_ID: $$Error$8,
                _1: lid$1.loc,
                _2: {
                  TAG: /* Rebind_mismatch */14,
                  _0: lid$1.txt,
                  _1: cstr_type_path,
                  _2: type_path
                }
              });
    }
    const match$6 = cdescr.cstr_private;
    if (!match$6 && priv) {
      throw new Caml_js_exceptions.MelangeError($$Error$8, {
                MEL_EXN_ID: $$Error$8,
                _1: lid$1.loc,
                _2: {
                  TAG: /* Rebind_private */15,
                  _0: lid$1.txt
                }
              });
    }
    const match$7 = cdescr.cstr_tag;
    let path;
    switch (match$7.TAG | 0) {
      case /* Cstr_constant */0 :
      case /* Cstr_block */1 :
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                    MEL_EXN_ID: "Assert_failure",
                    _1: [
                      "jscomp/test/ocaml_typedtree_test.ml",
                      47401,
                      17
                    ]
                  });
      case /* Cstr_extension */2 :
          path = match$7._0;
          break;
      
    }
    match = [
      args,
      match$3[1],
      {
        TAG: /* Text_rebind */1,
        _0: path,
        _1: lid$1
      }
    ];
  }
  const ext_ext_args = match[0];
  const ext_ext_ret_type = match[1];
  const ext_ext_loc = sext.pext_loc;
  const ext_ext_attributes = sext.pext_attributes;
  const ext = {
    ext_type_path: type_path,
    ext_type_params: typext_params,
    ext_args: ext_ext_args,
    ext_ret_type: ext_ext_ret_type,
    ext_private: priv,
    ext_loc: ext_ext_loc,
    ext_attributes: ext_ext_attributes
  };
  return {
          ext_id: id,
          ext_name: sext.pext_name,
          ext_type: ext,
          ext_kind: match[2],
          ext_loc: sext.pext_loc,
          ext_attributes: sext.pext_attributes
        };
}

function transl_type_extension(check_open, env, loc, styext) {
  reset_type_variables(undefined);
  begin_def(undefined);
  const match = find_type(env, loc, styext.ptyext_path.txt);
  const type_decl = match[1];
  const type_path = match[0];
  const match$1 = type_decl.type_kind;
  if (typeof match$1 === "number") {
    if (!match$1 && check_open) {
      try {
        const match$2 = Stdlib__List.find((function (param) {
                if (param.pext_kind.TAG === /* Pext_decl */0) {
                  return true;
                } else {
                  return false;
                }
              }), styext.ptyext_constructors);
        throw new Caml_js_exceptions.MelangeError($$Error$8, {
                  MEL_EXN_ID: $$Error$8,
                  _1: match$2.pext_loc,
                  _2: {
                    TAG: /* Not_open_type */10,
                    _0: type_path
                  }
                });
      }
      catch (raw_exn){
        const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.MEL_EXN_ID !== Stdlib.Not_found) {
          throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
        }
        
      }
    }
    
  } else {
    throw new Caml_js_exceptions.MelangeError($$Error$8, {
              MEL_EXN_ID: $$Error$8,
              _1: loc,
              _2: {
                TAG: /* Not_extensible_type */11,
                _0: type_path
              }
            });
  }
  const type_variance = Stdlib__List.map((function (v) {
          const match = Curry._1(Types_Variance.get_upper, v);
          return [
                  !match[1],
                  !match[0],
                  false
                ];
        }), type_decl.type_variance);
  const err = type_decl.type_arity !== Stdlib__List.length(styext.ptyext_params) ? ({
        hd: /* Arity */0,
        tl: /* [] */0
      }) : (
      Stdlib__List.for_all2((function (param, param$1) {
              if (!param$1[0] || param[0]) {
                if (param$1[1]) {
                  return param[1];
                } else {
                  return true;
                }
              } else {
                return false;
              }
            }), type_variance, add_injectivity(Stdlib__List.map((function (prim) {
                      return prim[1];
                    }), styext.ptyext_params))) ? /* [] */0 : ({
            hd: /* Variance */5,
            tl: /* [] */0
          })
    );
  if (Caml_obj.caml_notequal(err, /* [] */0)) {
    throw new Caml_js_exceptions.MelangeError($$Error$8, {
              MEL_EXN_ID: $$Error$8,
              _1: loc,
              _2: {
                TAG: /* Extension_mismatch */12,
                _0: type_path,
                _1: err
              }
            });
  }
  const ttype_params = make_params(env, styext.ptyext_params);
  const type_params = Stdlib__List.map((function (param) {
          return param[0].ctyp_type;
        }), ttype_params);
  Stdlib__List.iter2((function (param, param$1) {
          return unify_var(env, param, param$1);
        }), instance_list(env, type_decl.type_params), type_params);
  const partial_arg = styext.ptyext_private;
  const partial_arg$1 = type_decl.type_params;
  const constructors = Stdlib__List.map((function (param) {
          return transl_extension_constructor(env, check_open, type_path, partial_arg$1, type_params, partial_arg, param);
        }), styext.ptyext_constructors);
  end_def(undefined);
  Stdlib__List.iter(generalize, type_params);
  Stdlib__List.iter((function (ext) {
          Stdlib__List.iter(generalize, ext.ext_type.ext_args);
          may(generalize, ext.ext_type.ext_ret_type);
        }), constructors);
  Stdlib__List.iter((function (ext) {
          const ty = closed_extension_constructor(ext.ext_type);
          if (ty === undefined) {
            return ;
          }
          throw new Caml_js_exceptions.MelangeError($$Error$8, {
                    MEL_EXN_ID: $$Error$8,
                    _1: ext.ext_loc,
                    _2: {
                      TAG: /* Unbound_type_var_ext */19,
                      _0: ty,
                      _1: ext.ext_type
                    }
                  });
        }), constructors);
  Stdlib__List.iter((function (ext) {
          compute_variance_extension(env, true, type_decl, ext.ext_type, [
                type_variance,
                loc
              ]);
        }), constructors);
  const newenv = Stdlib__List.fold_left((function (env, ext) {
          return add_extension(true, ext.ext_id, ext.ext_type, env);
        }), env, constructors);
  const tyext_tyext_txt = styext.ptyext_path;
  const tyext_tyext_private = styext.ptyext_private;
  const tyext_tyext_attributes = styext.ptyext_attributes;
  const tyext = {
    tyext_path: type_path,
    tyext_txt: tyext_tyext_txt,
    tyext_params: ttype_params,
    tyext_constructors: constructors,
    tyext_private: tyext_tyext_private,
    tyext_attributes: tyext_tyext_attributes
  };
  return [
          tyext,
          newenv
        ];
}

function transl_exception(env, sext) {
  reset_type_variables(undefined);
  begin_def(undefined);
  const ext = transl_extension_constructor(env, false, path_exn, /* [] */0, /* [] */0, /* Public */1, sext);
  end_def(undefined);
  Stdlib__List.iter(generalize, ext.ext_type.ext_args);
  may(generalize, ext.ext_type.ext_ret_type);
  const ty = closed_extension_constructor(ext.ext_type);
  if (ty !== undefined) {
    throw new Caml_js_exceptions.MelangeError($$Error$8, {
              MEL_EXN_ID: $$Error$8,
              _1: ext.ext_loc,
              _2: {
                TAG: /* Unbound_type_var_ext */19,
                _0: ty,
                _1: ext.ext_type
              }
            });
  }
  const newenv = add_extension(true, ext.ext_id, ext.ext_type, env);
  return [
          ext,
          newenv
        ];
}

function customize_arity(arity, pval_attributes) {
  const cur_arity = {
    contents: arity
  };
  Stdlib__List.iter((function (x) {
          if (x[0].txt !== "internal.arity") {
            return ;
          }
          const match = x[1];
          switch (match.TAG | 0) {
            case /* PStr */0 :
                const match$1 = match._0;
                if (!match$1) {
                  return ;
                }
                const match$2 = match$1.hd.pstr_desc;
                if (match$2.TAG !== /* Pstr_eval */0) {
                  return ;
                }
                const match$3 = match$2._0.pexp_desc;
                if (match$3.TAG !== /* Pexp_constant */1) {
                  return ;
                }
                const i = match$3._0;
                if (i.TAG !== /* Const_int */0) {
                  return ;
                }
                if (match$1.tl) {
                  return ;
                }
                const i$1 = i._0;
                if (i$1 < cur_arity.contents) {
                  cur_arity.contents = i$1;
                  return ;
                } else {
                  return ;
                }
            case /* PTyp */1 :
            case /* PPat */2 :
                return ;
            
          }
        }), pval_attributes);
  return cur_arity.contents;
}

function transl_value_decl(env, loc, valdecl) {
  const cty = transl_type_scheme(env, valdecl.pval_type);
  const ty = cty.ctyp_type;
  const decl = valdecl.pval_prim;
  let v;
  if (decl) {
    const arity$1 = customize_arity(arity(ty), valdecl.pval_attributes);
    const prim = parse_declaration(arity$1, decl);
    const prim_native_name = prim.prim_native_name;
    if (arity$1 === 0 && !(prim_native_name.length > 3 && prim_native_name[0] === "B" && prim_native_name[1] === "S" && prim_native_name[2] === ":") && (prim.prim_name.length === 0 || Caml_string.get(prim.prim_name, 0) !== /* '%' */37 && Caml_string.get(prim.prim_name, 0) !== /* '#' */35)) {
      throw new Caml_js_exceptions.MelangeError($$Error$8, {
                MEL_EXN_ID: $$Error$8,
                _1: valdecl.pval_type.ptyp_loc,
                _2: /* Null_arity_external */2
              });
    }
    if (native_code.contents && prim.prim_arity > 5 && prim_native_name === "") {
      throw new Caml_js_exceptions.MelangeError($$Error$8, {
                MEL_EXN_ID: $$Error$8,
                _1: valdecl.pval_type.ptyp_loc,
                _2: /* Missing_native_external */3
              });
    }
    v = {
      val_type: ty,
      val_kind: {
        TAG: /* Val_prim */0,
        _0: prim
      },
      val_loc: loc,
      val_attributes: valdecl.pval_attributes
    };
  } else {
    v = {
      val_type: ty,
      val_kind: /* Val_reg */0,
      val_loc: loc,
      val_attributes: valdecl.pval_attributes
    };
  }
  const match = enter_value((function (s) {
            return {
                    TAG: /* Unused_value_declaration */16,
                    _0: s
                  };
          }))(valdecl.pval_name.txt, v, env);
  const desc_val_id = match[0];
  const desc_val_name = valdecl.pval_name;
  const desc_val_prim = valdecl.pval_prim;
  const desc_val_loc = valdecl.pval_loc;
  const desc_val_attributes = valdecl.pval_attributes;
  const desc = {
    val_id: desc_val_id,
    val_name: desc_val_name,
    val_desc: cty,
    val_val: v,
    val_prim: desc_val_prim,
    val_loc: desc_val_loc,
    val_attributes: desc_val_attributes
  };
  return [
          desc,
          match[1]
        ];
}

function transl_with_constraint(env, id, row_path, orig_decl, sdecl) {
  mark_type_used(env, id.name, orig_decl);
  reset_type_variables(undefined);
  begin_def(undefined);
  const tparams = make_params(env, sdecl.ptype_params);
  const params = Stdlib__List.map((function (param) {
          return param[0].ctyp_type;
        }), tparams);
  const orig_decl$1 = instance_declaration(orig_decl);
  const arity_ok = Stdlib__List.length(params) === orig_decl$1.type_arity;
  if (arity_ok) {
    Stdlib__List.iter2((function (param, param$1) {
            return unify_var(env, param, param$1);
          }), params, orig_decl$1.type_params);
  }
  const constraints = Stdlib__List.map((function (param) {
          const loc = param[2];
          try {
            const cty = transl_simple_type(env, false, param[0]);
            const cty$p = transl_simple_type(env, false, param[1]);
            const ty = cty.ctyp_type;
            const ty$p = cty$p.ctyp_type;
            unify$2(env, ty, ty$p);
            return [
                    cty,
                    cty$p,
                    loc
                  ];
          }
          catch (raw_tr){
            const tr = Caml_js_exceptions.internalToOCamlException(raw_tr);
            if (tr.MEL_EXN_ID === Unify) {
              throw new Caml_js_exceptions.MelangeError($$Error$8, {
                        MEL_EXN_ID: $$Error$8,
                        _1: loc,
                        _2: {
                          TAG: /* Inconsistent_constraint */6,
                          _0: env,
                          _1: tr._1
                        }
                      });
            }
            throw new Caml_js_exceptions.MelangeError(tr.MEL_EXN_ID, tr);
          }
        }), sdecl.ptype_cstrs);
  const no_row = !is_fixed_type(sdecl);
  const sty = sdecl.ptype_manifest;
  let match;
  if (sty !== undefined) {
    const cty = transl_simple_type(env, no_row, sty);
    match = [
      cty,
      cty.ctyp_type
    ];
  } else {
    match = [
      undefined,
      undefined
    ];
  }
  const man = match[1];
  const priv = sdecl.ptype_private === /* Private */0 ? /* Private */0 : (
      arity_ok && Caml_obj.caml_notequal(orig_decl$1.type_kind, /* Type_abstract */0) ? orig_decl$1.type_private : sdecl.ptype_private
    );
  if (arity_ok && Caml_obj.caml_notequal(orig_decl$1.type_kind, /* Type_abstract */0) && sdecl.ptype_private === /* Private */0) {
    prerr_warning(sdecl.ptype_loc, {
          TAG: /* Deprecated */0,
          _0: "spurious use of private"
        });
  }
  const decl_type_arity = Stdlib__List.length(params);
  const decl_type_kind = arity_ok && man !== undefined ? orig_decl$1.type_kind : /* Type_abstract */0;
  const decl_type_loc = sdecl.ptype_loc;
  const decl_type_attributes = sdecl.ptype_attributes;
  const decl = {
    type_params: params,
    type_arity: decl_type_arity,
    type_kind: decl_type_kind,
    type_private: priv,
    type_manifest: man,
    type_variance: /* [] */0,
    type_newtype_level: undefined,
    type_loc: decl_type_loc,
    type_attributes: decl_type_attributes
  };
  if (row_path !== undefined) {
    set_fixed_row(env, sdecl.ptype_loc, row_path, decl);
  }
  const ty = closed_type_decl(decl);
  if (ty !== undefined) {
    throw new Caml_js_exceptions.MelangeError($$Error$8, {
              MEL_EXN_ID: $$Error$8,
              _1: sdecl.ptype_loc,
              _2: {
                TAG: /* Unbound_type_var */9,
                _0: ty,
                _1: decl
              }
            });
  }
  const decl$1 = name_recursion(sdecl, id, decl);
  const decl_type_params = decl$1.type_params;
  const decl_type_arity$1 = decl$1.type_arity;
  const decl_type_kind$1 = decl$1.type_kind;
  const decl_type_private = decl$1.type_private;
  const decl_type_manifest = decl$1.type_manifest;
  const decl_type_variance = compute_variance_decl(env, false, decl$1, [
        add_injectivity(Stdlib__List.map((function (prim) {
                    return prim[1];
                  }), sdecl.ptype_params)),
        sdecl.ptype_loc
      ]);
  const decl_type_newtype_level = decl$1.type_newtype_level;
  const decl_type_loc$1 = decl$1.type_loc;
  const decl_type_attributes$1 = decl$1.type_attributes;
  const decl$2 = {
    type_params: decl_type_params,
    type_arity: decl_type_arity$1,
    type_kind: decl_type_kind$1,
    type_private: decl_type_private,
    type_manifest: decl_type_manifest,
    type_variance: decl_type_variance,
    type_newtype_level: decl_type_newtype_level,
    type_loc: decl_type_loc$1,
    type_attributes: decl_type_attributes$1
  };
  end_def(undefined);
  generalize_decl(decl$2);
  return {
          typ_id: id,
          typ_name: sdecl.ptype_name,
          typ_params: tparams,
          typ_type: decl$2,
          typ_cstrs: constraints,
          typ_kind: /* Ttype_abstract */0,
          typ_private: sdecl.ptype_private,
          typ_manifest: match[0],
          typ_loc: sdecl.ptype_loc,
          typ_attributes: sdecl.ptype_attributes
        };
}

function abstract_type_decl(arity) {
  const make_params = function (n) {
    if (n <= 0) {
      return /* [] */0;
    } else {
      return {
              hd: newvar(undefined, undefined),
              tl: make_params(n - 1 | 0)
            };
    }
  };
  begin_def(undefined);
  const decl_type_params = make_params(arity);
  const decl_type_variance = replicate_list(Types_Variance.full, arity);
  const decl = {
    type_params: decl_type_params,
    type_arity: arity,
    type_kind: /* Type_abstract */0,
    type_private: /* Public */1,
    type_manifest: undefined,
    type_variance: decl_type_variance,
    type_newtype_level: undefined,
    type_loc: none,
    type_attributes: /* [] */0
  };
  end_def(undefined);
  generalize_decl(decl);
  return decl;
}

function approx_type_decl(env, sdecl_list) {
  return Stdlib__List.map((function (sdecl) {
                return [
                        create(sdecl.ptype_name.txt),
                        abstract_type_decl(Stdlib__List.length(sdecl.ptype_params))
                      ];
              }), sdecl_list);
}

function explain_unbound(ppf, tv, tl, typ, kwd, lab) {
  try {
    const ti = Stdlib__List.find((function (ti) {
            return deep_occur(tv, Curry._1(typ, ti));
          }), tl);
    const ty0 = newty2(100000000, {
          TAG: /* Tobject */4,
          _0: tv,
          _1: {
            contents: undefined
          }
        });
    reset_and_mark_loops_list({
          hd: Curry._1(typ, ti),
          tl: {
            hd: ty0,
            tl: /* [] */0
          }
        });
    return Curry._6(Stdlib__Format.fprintf(ppf)(/* Format */{
                    _0: {
                      TAG: /* Char_literal */12,
                      _0: /* '.' */46,
                      _1: {
                        TAG: /* Formatting_lit */17,
                        _0: /* Flush_newline */4,
                        _1: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<hov2>",
                                _1: /* End_of_format */0
                              },
                              _1: "<hov2>"
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "In ",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@ ",
                                  _1: 1,
                                  _2: 0
                                },
                                _1: {
                                  TAG: /* String */2,
                                  _0: /* No_padding */0,
                                  _1: {
                                    TAG: /* Alpha */15,
                                    _0: {
                                      TAG: /* Formatting_lit */17,
                                      _0: {
                                        TAG: /* Break */0,
                                        _0: "@;<1 -2>",
                                        _1: 1,
                                        _2: -2
                                      },
                                      _1: {
                                        TAG: /* String_literal */11,
                                        _0: "the variable ",
                                        _1: {
                                          TAG: /* Alpha */15,
                                          _0: {
                                            TAG: /* String_literal */11,
                                            _0: " is unbound",
                                            _1: {
                                              TAG: /* Formatting_lit */17,
                                              _0: /* Close_box */0,
                                              _1: /* End_of_format */0
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    _1: ".@.@[<hov2>In %s@ %s%a@;<1 -2>the variable %a is unbound@]"
                  }), kwd, Curry._1(lab, ti), type_expr$1, Curry._1(typ, ti), type_expr$1, tv);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return ;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function report_error$5(ppf, s) {
  if (typeof s === "number") {
    switch (s) {
      case /* Repeated_parameter */0 :
          return Stdlib__Format.fprintf(ppf)(/* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "A type parameter occurs several times",
                        _1: /* End_of_format */0
                      },
                      _1: "A type parameter occurs several times"
                    });
      case /* Too_many_constructors */1 :
          return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* Formatting_gen */18,
                            _0: {
                              TAG: /* Open_box */1,
                              _0: /* Format */{
                                _0: /* End_of_format */0,
                                _1: ""
                              }
                            },
                            _1: {
                              TAG: /* String_literal */11,
                              _0: "Too many non-constant constructors",
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@ ",
                                  _1: 1,
                                  _2: 0
                                },
                                _1: {
                                  TAG: /* String_literal */11,
                                  _0: "-- maximum is ",
                                  _1: {
                                    TAG: /* Int */4,
                                    _0: /* Int_i */3,
                                    _1: /* No_padding */0,
                                    _2: /* No_precision */0,
                                    _3: {
                                      TAG: /* Char_literal */12,
                                      _0: /* ' ' */32,
                                      _1: {
                                        TAG: /* String */2,
                                        _0: /* No_padding */0,
                                        _1: {
                                          TAG: /* Formatting_lit */17,
                                          _0: /* Close_box */0,
                                          _1: /* End_of_format */0
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          },
                          _1: "@[Too many non-constant constructors@ -- maximum is %i %s@]"
                        }), 246, "non-constant constructors");
      case /* Null_arity_external */2 :
          return Stdlib__Format.fprintf(ppf)(/* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "External identifiers must be functions",
                        _1: /* End_of_format */0
                      },
                      _1: "External identifiers must be functions"
                    });
      case /* Missing_native_external */3 :
          return Stdlib__Format.fprintf(ppf)(/* Format */{
                      _0: {
                        TAG: /* Formatting_gen */18,
                        _0: {
                          TAG: /* Open_box */1,
                          _0: /* Format */{
                            _0: {
                              TAG: /* String_literal */11,
                              _0: "<hv>",
                              _1: /* End_of_format */0
                            },
                            _1: "<hv>"
                          }
                        },
                        _1: {
                          TAG: /* String_literal */11,
                          _0: "An external function with more than 5 arguments requires a second stub function",
                          _1: {
                            TAG: /* Formatting_lit */17,
                            _0: {
                              TAG: /* Break */0,
                              _0: "@ ",
                              _1: 1,
                              _2: 0
                            },
                            _1: {
                              TAG: /* String_literal */11,
                              _0: "for native-code compilation",
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: /* Close_box */0,
                                _1: /* End_of_format */0
                              }
                            }
                          }
                        }
                      },
                      _1: "@[<hv>An external function with more than 5 arguments requires a second stub function@ for native-code compilation@]"
                    });
      case /* Varying_anonymous */4 :
          return Curry._3(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* Formatting_gen */18,
                            _0: {
                              TAG: /* Open_box */1,
                              _0: /* Format */{
                                _0: /* End_of_format */0,
                                _1: ""
                              }
                            },
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@ ",
                                  _1: 1,
                                  _2: 0
                                },
                                _1: {
                                  TAG: /* String */2,
                                  _0: /* No_padding */0,
                                  _1: {
                                    TAG: /* Formatting_lit */17,
                                    _0: {
                                      TAG: /* Break */0,
                                      _0: "@ ",
                                      _1: 1,
                                      _2: 0
                                    },
                                    _1: {
                                      TAG: /* String */2,
                                      _0: /* No_padding */0,
                                      _1: {
                                        TAG: /* Formatting_lit */17,
                                        _0: /* Close_box */0,
                                        _1: /* End_of_format */0
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          },
                          _1: "@[%s@ %s@ %s@]"
                        }), "In this GADT definition,", "the variance of some parameter", "cannot be checked");
      
    }
  } else {
    switch (s.TAG | 0) {
      case /* Duplicate_constructor */0 :
          return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "Two constructors are named ",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: /* End_of_format */0
                            }
                          },
                          _1: "Two constructors are named %s"
                        }), s._0);
      case /* Duplicate_label */1 :
          return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "Two labels are named ",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: /* End_of_format */0
                            }
                          },
                          _1: "Two labels are named %s"
                        }), s._0);
      case /* Recursive_abbrev */2 :
          return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "The type abbreviation ",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* String_literal */11,
                                _0: " is cyclic",
                                _1: /* End_of_format */0
                              }
                            }
                          },
                          _1: "The type abbreviation %s is cyclic"
                        }), s._0);
      case /* Cycle_in_def */3 :
          const ty = s._1;
          reset(undefined);
          mark_loops(ty);
          return Curry._3(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* Formatting_gen */18,
                            _0: {
                              TAG: /* Open_box */1,
                              _0: /* Format */{
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: "<v>",
                                  _1: /* End_of_format */0
                                },
                                _1: "<v>"
                              }
                            },
                            _1: {
                              TAG: /* String_literal */11,
                              _0: "The definition of ",
                              _1: {
                                TAG: /* String */2,
                                _0: /* No_padding */0,
                                _1: {
                                  TAG: /* String_literal */11,
                                  _0: " contains a cycle:",
                                  _1: {
                                    TAG: /* Formatting_lit */17,
                                    _0: {
                                      TAG: /* Break */0,
                                      _0: "@ ",
                                      _1: 1,
                                      _2: 0
                                    },
                                    _1: {
                                      TAG: /* Alpha */15,
                                      _0: {
                                        TAG: /* Formatting_lit */17,
                                        _0: /* Close_box */0,
                                        _1: /* End_of_format */0
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          },
                          _1: "@[<v>The definition of %s contains a cycle:@ %a@]"
                        }), s._0, type_expr$1, ty);
      case /* Definition_mismatch */4 :
          const ty$1 = s._0;
          reset(undefined);
          mark_loops(ty$1);
          return Curry._6(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* Formatting_gen */18,
                            _0: {
                              TAG: /* Open_box */1,
                              _0: /* Format */{
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: "<v>",
                                  _1: /* End_of_format */0
                                },
                                _1: "<v>"
                              }
                            },
                            _1: {
                              TAG: /* Formatting_gen */18,
                              _0: {
                                TAG: /* Open_box */1,
                                _0: /* Format */{
                                  _0: {
                                    TAG: /* String_literal */11,
                                    _0: "<hov>",
                                    _1: /* End_of_format */0
                                  },
                                  _1: "<hov>"
                                }
                              },
                              _1: {
                                TAG: /* String */2,
                                _0: /* No_padding */0,
                                _1: {
                                  TAG: /* Formatting_lit */17,
                                  _0: {
                                    TAG: /* Break */0,
                                    _0: "@ ",
                                    _1: 1,
                                    _2: 0
                                  },
                                  _1: {
                                    TAG: /* String */2,
                                    _0: /* No_padding */0,
                                    _1: {
                                      TAG: /* Formatting_lit */17,
                                      _0: {
                                        TAG: /* Break */0,
                                        _0: "@;<1 2>",
                                        _1: 1,
                                        _2: 2
                                      },
                                      _1: {
                                        TAG: /* Alpha */15,
                                        _0: {
                                          TAG: /* Formatting_lit */17,
                                          _0: /* Close_box */0,
                                          _1: {
                                            TAG: /* Alpha */15,
                                            _0: {
                                              TAG: /* Formatting_lit */17,
                                              _0: /* Close_box */0,
                                              _1: /* End_of_format */0
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          },
                          _1: "@[<v>@[<hov>%s@ %s@;<1 2>%a@]%a@]"
                        }), "This variant or record definition", "does not match that of type", type_expr$1, ty$1, (function (param) {
                        return report_type_mismatch("the original", "this", "definition", param);
                      }), s._1);
      case /* Constraint_failed */5 :
          const ty$p = s._1;
          const ty$2 = s._0;
          reset(undefined);
          mark_loops(ty$2);
          mark_loops(ty$p);
          return Curry._5(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* Formatting_gen */18,
                            _0: {
                              TAG: /* Open_box */1,
                              _0: /* Format */{
                                _0: /* End_of_format */0,
                                _1: ""
                              }
                            },
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@ ",
                                  _1: 1,
                                  _2: 0
                                },
                                _1: {
                                  TAG: /* Formatting_gen */18,
                                  _0: {
                                    TAG: /* Open_box */1,
                                    _0: /* Format */{
                                      _0: {
                                        TAG: /* String_literal */11,
                                        _0: "<hv>",
                                        _1: /* End_of_format */0
                                      },
                                      _1: "<hv>"
                                    }
                                  },
                                  _1: {
                                    TAG: /* String_literal */11,
                                    _0: "Type",
                                    _1: {
                                      TAG: /* Formatting_lit */17,
                                      _0: {
                                        TAG: /* Break */0,
                                        _0: "@ ",
                                        _1: 1,
                                        _2: 0
                                      },
                                      _1: {
                                        TAG: /* Alpha */15,
                                        _0: {
                                          TAG: /* Formatting_lit */17,
                                          _0: {
                                            TAG: /* Break */0,
                                            _0: "@ ",
                                            _1: 1,
                                            _2: 0
                                          },
                                          _1: {
                                            TAG: /* String_literal */11,
                                            _0: "should be an instance of",
                                            _1: {
                                              TAG: /* Formatting_lit */17,
                                              _0: {
                                                TAG: /* Break */0,
                                                _0: "@ ",
                                                _1: 1,
                                                _2: 0
                                              },
                                              _1: {
                                                TAG: /* Alpha */15,
                                                _0: {
                                                  TAG: /* Formatting_lit */17,
                                                  _0: /* Close_box */0,
                                                  _1: {
                                                    TAG: /* Formatting_lit */17,
                                                    _0: /* Close_box */0,
                                                    _1: /* End_of_format */0
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          },
                          _1: "@[%s@ @[<hv>Type@ %a@ should be an instance of@ %a@]@]"
                        }), "Constraints are not satisfied in this type.", type_expr$1, ty$2, type_expr$1, ty$p);
      case /* Inconsistent_constraint */6 :
          Stdlib__Format.fprintf(ppf)(/* Format */{
                _0: {
                  TAG: /* String_literal */11,
                  _0: "The type constraints are not consistent.",
                  _1: {
                    TAG: /* Formatting_lit */17,
                    _0: /* Flush_newline */4,
                    _1: /* End_of_format */0
                  }
                },
                _1: "The type constraints are not consistent.@."
              });
          return report_unification_error(ppf, s._0, undefined, s._1, (function (ppf) {
                        Stdlib__Format.fprintf(ppf)(/* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "Type",
                                _1: /* End_of_format */0
                              },
                              _1: "Type"
                            });
                      }), (function (ppf) {
                        Stdlib__Format.fprintf(ppf)(/* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "is not compatible with type",
                                _1: /* End_of_format */0
                              },
                              _1: "is not compatible with type"
                            });
                      }));
      case /* Type_clash */7 :
          return report_unification_error(ppf, s._0, undefined, s._1, (function (ppf) {
                        Stdlib__Format.fprintf(ppf)(/* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "This type constructor expands to type",
                                _1: /* End_of_format */0
                              },
                              _1: "This type constructor expands to type"
                            });
                      }), (function (ppf) {
                        Stdlib__Format.fprintf(ppf)(/* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "but is used here with type",
                                _1: /* End_of_format */0
                              },
                              _1: "but is used here with type"
                            });
                      }));
      case /* Parameters_differ */8 :
          const ty$p$1 = s._2;
          const ty$3 = s._1;
          reset(undefined);
          mark_loops(ty$3);
          mark_loops(ty$p$1);
          return Curry._5(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* Formatting_gen */18,
                            _0: {
                              TAG: /* Open_box */1,
                              _0: /* Format */{
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: "<hv>",
                                  _1: /* End_of_format */0
                                },
                                _1: "<hv>"
                              }
                            },
                            _1: {
                              TAG: /* String_literal */11,
                              _0: "In the definition of ",
                              _1: {
                                TAG: /* String */2,
                                _0: /* No_padding */0,
                                _1: {
                                  TAG: /* String_literal */11,
                                  _0: ", type",
                                  _1: {
                                    TAG: /* Formatting_lit */17,
                                    _0: {
                                      TAG: /* Break */0,
                                      _0: "@ ",
                                      _1: 1,
                                      _2: 0
                                    },
                                    _1: {
                                      TAG: /* Alpha */15,
                                      _0: {
                                        TAG: /* Formatting_lit */17,
                                        _0: {
                                          TAG: /* Break */0,
                                          _0: "@ ",
                                          _1: 1,
                                          _2: 0
                                        },
                                        _1: {
                                          TAG: /* String_literal */11,
                                          _0: "should be",
                                          _1: {
                                            TAG: /* Formatting_lit */17,
                                            _0: {
                                              TAG: /* Break */0,
                                              _0: "@ ",
                                              _1: 1,
                                              _2: 0
                                            },
                                            _1: {
                                              TAG: /* Alpha */15,
                                              _0: {
                                                TAG: /* Formatting_lit */17,
                                                _0: /* Close_box */0,
                                                _1: /* End_of_format */0
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          },
                          _1: "@[<hv>In the definition of %s, type@ %a@ should be@ %a@]"
                        }), name(undefined, s._0), type_expr$1, ty$3, type_expr$1, ty$p$1);
      case /* Unbound_type_var */9 :
          const decl = s._1;
          Stdlib__Format.fprintf(ppf)(/* Format */{
                _0: {
                  TAG: /* String_literal */11,
                  _0: "A type variable is unbound in this type declaration",
                  _1: /* End_of_format */0
                },
                _1: "A type variable is unbound in this type declaration"
              });
          const ty$4 = repr(s._0);
          const match = decl.type_kind;
          const match$1 = decl.type_manifest;
          if (typeof match === "number") {
            if (match === /* Type_abstract */0 && match$1 !== undefined) {
              const trivial = function (ty$5) {
                explain_unbound(ppf, ty$4, {
                      hd: ty$5,
                      tl: /* [] */0
                    }, (function (t) {
                        return t;
                      }), "type", (function (param) {
                        return "";
                      }));
              };
              const row = repr(match$1).desc;
              if (typeof row === "number") {
                return trivial(match$1);
              }
              switch (row.TAG | 0) {
                case /* Tobject */4 :
                    const match$2 = flatten_fields(row._0);
                    if (match$2[1] === ty$4) {
                      return trivial(match$1);
                    } else {
                      return explain_unbound(ppf, ty$4, match$2[0], (function (param) {
                                    return param[2];
                                  }), "method", (function (param) {
                                    return param[0] + ": ";
                                  }));
                    }
                case /* Tvariant */8 :
                    const row$1 = row_repr_aux(/* [] */0, row._0);
                    if (row$1.row_more === ty$4) {
                      return trivial(match$1);
                    } else {
                      return explain_unbound(ppf, ty$4, row$1.row_fields, (function (param) {
                                    const match = row_field_repr_aux(/* [] */0, param[1]);
                                    if (typeof match === "number") {
                                      return newty2(100000000, {
                                                  TAG: /* Ttuple */2,
                                                  _0: /* [] */0
                                                });
                                    }
                                    if (match.TAG === /* Rpresent */0) {
                                      const t = match._0;
                                      if (t !== undefined) {
                                        return t;
                                      } else {
                                        return newty2(100000000, {
                                                    TAG: /* Ttuple */2,
                                                    _0: /* [] */0
                                                  });
                                      }
                                    }
                                    const match$1 = match._1;
                                    if (match$1 && !match$1.tl) {
                                      return match$1.hd;
                                    } else {
                                      return newty2(100000000, {
                                                  TAG: /* Ttuple */2,
                                                  _0: match._1
                                                });
                                    }
                                  }), "case", (function (param) {
                                    return "`" + (param[0] + " of ");
                                  }));
                    }
                default:
                  return trivial(match$1);
              }
            } else {
              return ;
            }
          } else if (match.TAG === /* Type_record */0) {
            return explain_unbound(ppf, ty$4, match._0, (function (l) {
                          return l.ld_type;
                        }), "field", (function (l) {
                          return l.ld_id.name + ": ";
                        }));
          } else {
            return explain_unbound(ppf, ty$4, match._0, (function (c) {
                          return newty2(100000000, {
                                      TAG: /* Ttuple */2,
                                      _0: c.cd_args
                                    });
                        }), "case", (function (c) {
                          return c.cd_id.name + " of ";
                        }));
          }
      case /* Not_open_type */10 :
          return Curry._3(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* Formatting_gen */18,
                            _0: {
                              TAG: /* Open_box */1,
                              _0: /* Format */{
                                _0: /* End_of_format */0,
                                _1: ""
                              }
                            },
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@ ",
                                  _1: 1,
                                  _2: 0
                                },
                                _1: {
                                  TAG: /* Alpha */15,
                                  _0: {
                                    TAG: /* Formatting_lit */17,
                                    _0: /* Close_box */0,
                                    _1: /* End_of_format */0
                                  }
                                }
                              }
                            }
                          },
                          _1: "@[%s@ %a@]"
                        }), "Cannot extend type definition", path, s._0);
      case /* Not_extensible_type */11 :
          return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* Formatting_gen */18,
                            _0: {
                              TAG: /* Open_box */1,
                              _0: /* Format */{
                                _0: /* End_of_format */0,
                                _1: ""
                              }
                            },
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@ ",
                                  _1: 1,
                                  _2: 0
                                },
                                _1: {
                                  TAG: /* Alpha */15,
                                  _0: {
                                    TAG: /* Formatting_lit */17,
                                    _0: {
                                      TAG: /* Break */0,
                                      _0: "@ ",
                                      _1: 1,
                                      _2: 0
                                    },
                                    _1: {
                                      TAG: /* String */2,
                                      _0: /* No_padding */0,
                                      _1: {
                                        TAG: /* Formatting_lit */17,
                                        _0: /* Close_box */0,
                                        _1: /* End_of_format */0
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          },
                          _1: "@[%s@ %a@ %s@]"
                        }), "Type", path, s._0, "is not extensible");
      case /* Extension_mismatch */12 :
          return Curry._5(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* Formatting_gen */18,
                            _0: {
                              TAG: /* Open_box */1,
                              _0: /* Format */{
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: "<v>",
                                  _1: /* End_of_format */0
                                },
                                _1: "<v>"
                              }
                            },
                            _1: {
                              TAG: /* Formatting_gen */18,
                              _0: {
                                TAG: /* Open_box */1,
                                _0: /* Format */{
                                  _0: {
                                    TAG: /* String_literal */11,
                                    _0: "<hov>",
                                    _1: /* End_of_format */0
                                  },
                                  _1: "<hov>"
                                }
                              },
                              _1: {
                                TAG: /* String */2,
                                _0: /* No_padding */0,
                                _1: {
                                  TAG: /* Formatting_lit */17,
                                  _0: {
                                    TAG: /* Break */0,
                                    _0: "@ ",
                                    _1: 1,
                                    _2: 0
                                  },
                                  _1: {
                                    TAG: /* String */2,
                                    _0: /* No_padding */0,
                                    _1: {
                                      TAG: /* Formatting_lit */17,
                                      _0: {
                                        TAG: /* Break */0,
                                        _0: "@;<1 2>",
                                        _1: 1,
                                        _2: 2
                                      },
                                      _1: {
                                        TAG: /* String */2,
                                        _0: /* No_padding */0,
                                        _1: {
                                          TAG: /* Formatting_lit */17,
                                          _0: /* Close_box */0,
                                          _1: {
                                            TAG: /* Alpha */15,
                                            _0: {
                                              TAG: /* Formatting_lit */17,
                                              _0: /* Close_box */0,
                                              _1: /* End_of_format */0
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          },
                          _1: "@[<v>@[<hov>%s@ %s@;<1 2>%s@]%a@]"
                        }), "This extension", "does not match the definition of type", name(undefined, s._0), (function (param) {
                        return report_type_mismatch("the type", "this extension", "definition", param);
                      }), s._1);
      case /* Rebind_wrong_type */13 :
          const lid = s._0;
          return report_unification_error(ppf, s._1, undefined, s._2, (function (ppf) {
                        Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                                  _0: {
                                    TAG: /* String_literal */11,
                                    _0: "The constructor ",
                                    _1: {
                                      TAG: /* Alpha */15,
                                      _0: {
                                        TAG: /* Formatting_lit */17,
                                        _0: {
                                          TAG: /* Break */0,
                                          _0: "@ ",
                                          _1: 1,
                                          _2: 0
                                        },
                                        _1: {
                                          TAG: /* String_literal */11,
                                          _0: "has type",
                                          _1: /* End_of_format */0
                                        }
                                      }
                                    }
                                  },
                                  _1: "The constructor %a@ has type"
                                }), longident, lid);
                      }), (function (ppf) {
                        Stdlib__Format.fprintf(ppf)(/* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "but was expected to be of type",
                                _1: /* End_of_format */0
                              },
                              _1: "but was expected to be of type"
                            });
                      }));
      case /* Rebind_mismatch */14 :
          return Curry._8(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* Formatting_gen */18,
                            _0: {
                              TAG: /* Open_box */1,
                              _0: /* Format */{
                                _0: /* End_of_format */0,
                                _1: ""
                              }
                            },
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@ ",
                                  _1: 1,
                                  _2: 0
                                },
                                _1: {
                                  TAG: /* Alpha */15,
                                  _0: {
                                    TAG: /* Formatting_lit */17,
                                    _0: {
                                      TAG: /* Break */0,
                                      _0: "@ ",
                                      _1: 1,
                                      _2: 0
                                    },
                                    _1: {
                                      TAG: /* String */2,
                                      _0: /* No_padding */0,
                                      _1: {
                                        TAG: /* Formatting_lit */17,
                                        _0: {
                                          TAG: /* Break */0,
                                          _0: "@ ",
                                          _1: 1,
                                          _2: 0
                                        },
                                        _1: {
                                          TAG: /* String */2,
                                          _0: /* No_padding */0,
                                          _1: {
                                            TAG: /* Formatting_lit */17,
                                            _0: {
                                              TAG: /* Break */0,
                                              _0: "@ ",
                                              _1: 1,
                                              _2: 0
                                            },
                                            _1: {
                                              TAG: /* String */2,
                                              _0: /* No_padding */0,
                                              _1: {
                                                TAG: /* Formatting_lit */17,
                                                _0: {
                                                  TAG: /* Break */0,
                                                  _0: "@ ",
                                                  _1: 1,
                                                  _2: 0
                                                },
                                                _1: {
                                                  TAG: /* String */2,
                                                  _0: /* No_padding */0,
                                                  _1: {
                                                    TAG: /* Formatting_lit */17,
                                                    _0: {
                                                      TAG: /* Break */0,
                                                      _0: "@ ",
                                                      _1: 1,
                                                      _2: 0
                                                    },
                                                    _1: {
                                                      TAG: /* String */2,
                                                      _0: /* No_padding */0,
                                                      _1: {
                                                        TAG: /* Formatting_lit */17,
                                                        _0: /* Close_box */0,
                                                        _1: /* End_of_format */0
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          },
                          _1: "@[%s@ %a@ %s@ %s@ %s@ %s@ %s@]"
                        }), "The constructor", longident, s._0, "extends type", name(undefined, s._1), "whose declaration does not match", "the declaration of type", name(undefined, s._2));
      case /* Rebind_private */15 :
          return Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* Formatting_gen */18,
                            _0: {
                              TAG: /* Open_box */1,
                              _0: /* Format */{
                                _0: /* End_of_format */0,
                                _1: ""
                              }
                            },
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@ ",
                                  _1: 1,
                                  _2: 0
                                },
                                _1: {
                                  TAG: /* Alpha */15,
                                  _0: {
                                    TAG: /* Formatting_lit */17,
                                    _0: {
                                      TAG: /* Break */0,
                                      _0: "@ ",
                                      _1: 1,
                                      _2: 0
                                    },
                                    _1: {
                                      TAG: /* String */2,
                                      _0: /* No_padding */0,
                                      _1: {
                                        TAG: /* Formatting_lit */17,
                                        _0: /* Close_box */0,
                                        _1: /* End_of_format */0
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          },
                          _1: "@[%s@ %a@ %s@]"
                        }), "The constructor", longident, s._0, "is private");
      case /* Bad_variance */16 :
          const n = s._0;
          const variance = function (param) {
            const n = param[1];
            const inj = param[2] ? "injective " : "";
            if (param[0]) {
              if (n) {
                return inj + "invariant";
              } else {
                return inj + "covariant";
              }
            } else if (n) {
              return inj + "contravariant";
            } else if (inj === "") {
              return "unrestricted";
            } else {
              return inj;
            }
          };
          const suffix = function (n) {
            const teen = (n % 100 / 10 | 0) === 1;
            const match = n % 10;
            switch (match) {
              case 1 :
                  if (teen) {
                    return "th";
                  } else {
                    return "st";
                  }
              case 2 :
                  if (teen) {
                    return "th";
                  } else {
                    return "nd";
                  }
              case 3 :
                  if (teen) {
                    return "th";
                  } else {
                    return "rd";
                  }
              default:
                return "th";
            }
          };
          if (n === -1) {
            Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                      _0: {
                        TAG: /* Formatting_gen */18,
                        _0: {
                          TAG: /* Open_box */1,
                          _0: /* Format */{
                            _0: /* End_of_format */0,
                            _1: ""
                          }
                        },
                        _1: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* Formatting_lit */17,
                            _0: {
                              TAG: /* Break */0,
                              _0: "@ ",
                              _1: 1,
                              _2: 0
                            },
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@ ",
                                  _1: 1,
                                  _2: 0
                                },
                                _1: {
                                  TAG: /* String_literal */11,
                                  _0: "It",
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          }
                        }
                      },
                      _1: "@[%s@ %s@ It"
                    }), "In this definition, a type variable has a variance that", "is not reflected by its occurrence in type parameters.");
          } else if (n === -2) {
            Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                      _0: {
                        TAG: /* Formatting_gen */18,
                        _0: {
                          TAG: /* Open_box */1,
                          _0: /* Format */{
                            _0: /* End_of_format */0,
                            _1: ""
                          }
                        },
                        _1: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* Formatting_lit */17,
                            _0: {
                              TAG: /* Break */0,
                              _0: "@ ",
                              _1: 1,
                              _2: 0
                            },
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: /* Close_box */0,
                                _1: /* End_of_format */0
                              }
                            }
                          }
                        }
                      },
                      _1: "@[%s@ %s@]"
                    }), "In this definition, a type variable cannot be deduced", "from the type parameters.");
          } else if (n === -3) {
            Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                      _0: {
                        TAG: /* Formatting_gen */18,
                        _0: {
                          TAG: /* Open_box */1,
                          _0: /* Format */{
                            _0: /* End_of_format */0,
                            _1: ""
                          }
                        },
                        _1: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* Formatting_lit */17,
                            _0: {
                              TAG: /* Break */0,
                              _0: "@ ",
                              _1: 1,
                              _2: 0
                            },
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@ ",
                                  _1: 1,
                                  _2: 0
                                },
                                _1: {
                                  TAG: /* String_literal */11,
                                  _0: "It",
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          }
                        }
                      },
                      _1: "@[%s@ %s@ It"
                    }), "In this definition, a type variable has a variance that", "cannot be deduced from the type parameters.");
          } else {
            Curry._4(Stdlib__Format.fprintf(ppf)(/* Format */{
                      _0: {
                        TAG: /* Formatting_gen */18,
                        _0: {
                          TAG: /* Open_box */1,
                          _0: /* Format */{
                            _0: /* End_of_format */0,
                            _1: ""
                          }
                        },
                        _1: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* Formatting_lit */17,
                            _0: {
                              TAG: /* Break */0,
                              _0: "@ ",
                              _1: 1,
                              _2: 0
                            },
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@ ",
                                  _1: 1,
                                  _2: 0
                                },
                                _1: {
                                  TAG: /* String_literal */11,
                                  _0: "The ",
                                  _1: {
                                    TAG: /* Int */4,
                                    _0: /* Int_d */0,
                                    _1: /* No_padding */0,
                                    _2: /* No_precision */0,
                                    _3: {
                                      TAG: /* String */2,
                                      _0: /* No_padding */0,
                                      _1: {
                                        TAG: /* String_literal */11,
                                        _0: " type parameter",
                                        _1: /* End_of_format */0
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      },
                      _1: "@[%s@ %s@ The %d%s type parameter"
                    }), "In this definition, expected parameter", "variances are not satisfied.", n, suffix(n));
          }
          if (n !== -2) {
            return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                            _0: {
                              TAG: /* String_literal */11,
                              _0: " was expected to be ",
                              _1: {
                                TAG: /* String */2,
                                _0: /* No_padding */0,
                                _1: {
                                  TAG: /* Char_literal */12,
                                  _0: /* ',' */44,
                                  _1: {
                                    TAG: /* Formatting_lit */17,
                                    _0: {
                                      TAG: /* Break */0,
                                      _0: "@ ",
                                      _1: 1,
                                      _2: 0
                                    },
                                    _1: {
                                      TAG: /* String_literal */11,
                                      _0: "but it is ",
                                      _1: {
                                        TAG: /* String */2,
                                        _0: /* No_padding */0,
                                        _1: {
                                          TAG: /* Char_literal */12,
                                          _0: /* '.' */46,
                                          _1: {
                                            TAG: /* Formatting_lit */17,
                                            _0: /* Close_box */0,
                                            _1: /* End_of_format */0
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            },
                            _1: " was expected to be %s,@ but it is %s.@]"
                          }), variance(s._2), variance(s._1));
          } else {
            return ;
          }
      case /* Unavailable_type_constructor */17 :
          return Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "The definition of type ",
                            _1: {
                              TAG: /* Alpha */15,
                              _0: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@ ",
                                  _1: 1,
                                  _2: 0
                                },
                                _1: {
                                  TAG: /* String_literal */11,
                                  _0: "is unavailable",
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          },
                          _1: "The definition of type %a@ is unavailable"
                        }), path, s._0);
      case /* Bad_fixed_type */18 :
          return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "This fixed type ",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: /* End_of_format */0
                            }
                          },
                          _1: "This fixed type %s"
                        }), s._0);
      case /* Unbound_type_var_ext */19 :
          Stdlib__Format.fprintf(ppf)(/* Format */{
                _0: {
                  TAG: /* String_literal */11,
                  _0: "A type variable is unbound in this extension constructor",
                  _1: /* End_of_format */0
                },
                _1: "A type variable is unbound in this extension constructor"
              });
          return explain_unbound(ppf, s._0, s._1.ext_args, (function (c) {
                        return c;
                      }), "type", (function (param) {
                        return "";
                      }));
      
    }
  }
}

register_error_of_exn(function (param) {
      if (param.MEL_EXN_ID === $$Error$8) {
        return error_of_printer(param._1, report_error$5, param._2);
      }
      
    });

const $$Error$9 = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Typeclass.Error");

const Error_forward$2 = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Typeclass.Error_forward");

function ctyp(desc, typ, env, loc) {
  return {
          ctyp_desc: desc,
          ctyp_type: typ,
          ctyp_env: env,
          ctyp_loc: loc,
          ctyp_attributes: /* [] */0
        };
}

const unbound_class = {
  TAG: /* Pident */0,
  _0: create("")
};

function scrape_class_type(_cty) {
  while(true) {
    const cty = _cty;
    switch (cty.TAG | 0) {
      case /* Cty_constr */0 :
          _cty = cty._2;
          continue ;
      case /* Cty_signature */1 :
      case /* Cty_arrow */2 :
          return cty;
      
    }
  };
}

function generalize_class_type(gen, _param) {
  while(true) {
    const param = _param;
    switch (param.TAG | 0) {
      case /* Cty_constr */0 :
          Stdlib__List.iter(gen, param._1);
          _param = param._2;
          continue ;
      case /* Cty_signature */1 :
          const match = param._0;
          Curry._1(gen, match.csig_self);
          Curry._2(Meths.iter, (function (param, param$1) {
                  Curry._1(gen, param$1[2]);
                }), match.csig_vars);
          return Stdlib__List.iter((function (param) {
                        Stdlib__List.iter(gen, param[1]);
                      }), match.csig_inher);
      case /* Cty_arrow */2 :
          Curry._1(gen, param._1);
          _param = param._2;
          continue ;
      
    }
  };
}

function virtual_methods(sign) {
  const match = flatten_fields(object_fields(sign.csig_self));
  return Stdlib__List.fold_left((function (virt, param) {
                const lab = param[0];
                if (lab === dummy_method || Curry._2(mem$2, lab, sign.csig_concr)) {
                  return virt;
                } else {
                  return {
                          hd: lab,
                          tl: virt
                        };
                }
              }), /* [] */0, match[0]);
}

function constructor_type(constr, _cty) {
  while(true) {
    const cty = _cty;
    switch (cty.TAG | 0) {
      case /* Cty_constr */0 :
          _cty = cty._2;
          continue ;
      case /* Cty_signature */1 :
          return constr;
      case /* Cty_arrow */2 :
          const desc_0 = cty._0;
          const desc_1 = cty._1;
          const desc_2 = constructor_type(constr, cty._2);
          const desc = {
            TAG: /* Tarrow */1,
            _0: desc_0,
            _1: desc_1,
            _2: desc_2,
            _3: /* Cok */0
          };
          return newty2(current_level.contents, desc);
      
    }
  };
}

function class_body(_cty) {
  while(true) {
    const cty = _cty;
    switch (cty.TAG | 0) {
      case /* Cty_constr */0 :
      case /* Cty_signature */1 :
          return cty;
      case /* Cty_arrow */2 :
          _cty = cty._2;
          continue ;
      
    }
  };
}

function extract_constraints(cty) {
  const sign = signature_of_class_type(cty);
  const match = flatten_fields(object_fields(sign.csig_self));
  return [
          Curry._3(Meths.fold, (function (lab, param, vars) {
                  return {
                          hd: lab,
                          tl: vars
                        };
                }), sign.csig_vars, /* [] */0),
          Stdlib__List.fold_left((function (meths, param) {
                  const lab = param[0];
                  if (lab === dummy_method) {
                    return meths;
                  } else {
                    return {
                            hd: lab,
                            tl: meths
                          };
                  }
                }), /* [] */0, match[0]),
          sign.csig_concr
        ];
}

function abbreviate_class_type(path, params, cty) {
  switch (cty.TAG | 0) {
    case /* Cty_constr */0 :
    case /* Cty_signature */1 :
        return {
                TAG: /* Cty_constr */0,
                _0: path,
                _1: params,
                _2: cty
              };
    case /* Cty_arrow */2 :
        return {
                TAG: /* Cty_arrow */2,
                _0: cty._0,
                _1: cty._1,
                _2: abbreviate_class_type(path, params, cty._2)
              };
    
  }
}

function closed_class$1(cty) {
  if (Stdlib__List.for_all(closed_schema, cty.cty_params)) {
    let _sign = cty.cty_type;
    while(true) {
      const sign = _sign;
      switch (sign.TAG | 0) {
        case /* Cty_constr */0 :
            return Stdlib__List.for_all(closed_schema, sign._1);
        case /* Cty_signature */1 :
            const sign$1 = sign._0;
            if (closed_schema(sign$1.csig_self)) {
              return Curry._3(Meths.fold, (function (param, param$1, cc) {
                            if (closed_schema(param$1[2])) {
                              return cc;
                            } else {
                              return false;
                            }
                          }), sign$1.csig_vars, true);
            } else {
              return false;
            }
        case /* Cty_arrow */2 :
            if (!closed_schema(sign._1)) {
              return false;
            }
            _sign = sign._2;
            continue ;
        
      }
    };
  } else {
    return false;
  }
}

function limited_generalize$1(rv, _sign) {
  while(true) {
    const sign = _sign;
    switch (sign.TAG | 0) {
      case /* Cty_constr */0 :
          Stdlib__List.iter((function (param) {
                  return limited_generalize(rv, param);
                }), sign._1);
          _sign = sign._2;
          continue ;
      case /* Cty_signature */1 :
          const sign$1 = sign._0;
          limited_generalize(rv, sign$1.csig_self);
          Curry._2(Meths.iter, (function (param, param$1) {
                  limited_generalize(rv, param$1[2]);
                }), sign$1.csig_vars);
          return Stdlib__List.iter((function (param) {
                        Stdlib__List.iter((function (param) {
                                return limited_generalize(rv, param);
                              }), param[1]);
                      }), sign$1.csig_inher);
      case /* Cty_arrow */2 :
          limited_generalize(rv, sign._1);
          _sign = sign._2;
          continue ;
      
    }
  };
}

function rc(node) {
  add_saved_type({
        TAG: /* Partial_class_expr */4,
        _0: node
      });
  record$2({
        TAG: /* Ti_class */2,
        _0: node
      });
  return node;
}

function enter_met_env(check, loc, lab, kind, ty, val_env, met_env, par_env) {
  const match = enter_value(undefined)(lab, {
        val_type: ty,
        val_kind: /* Val_unbound */1,
        val_loc: loc,
        val_attributes: /* [] */0
      }, val_env);
  const id = match[0];
  return [
          id,
          match[1],
          add_value(check, id, {
                val_type: ty,
                val_kind: kind,
                val_loc: loc,
                val_attributes: /* [] */0
              }, met_env),
          add_value(undefined, id, {
                val_type: ty,
                val_kind: /* Val_unbound */1,
                val_loc: loc,
                val_attributes: /* [] */0
              }, par_env)
        ];
}

function enter_val(cl_num, vars, inh, lab, mut, virt, ty, val_env, met_env, par_env, loc) {
  let match;
  try {
    const match$1 = Curry._2(Meths.find, lab, vars.contents);
    const virt$p = match$1[2];
    if (match$1[1] !== mut) {
      throw new Caml_js_exceptions.MelangeError($$Error$9, {
                MEL_EXN_ID: $$Error$9,
                _1: loc,
                _2: val_env,
                _3: {
                  TAG: /* Mutability_mismatch */22,
                  _0: lab,
                  _1: mut
                }
              });
    }
    unify$2(val_env, instance(undefined, val_env, ty), instance(undefined, val_env, match$1[3]));
    match = [
      !inh ? match$1[0] : undefined,
      virt$p === /* Concrete */1 ? virt$p : virt
    ];
  }
  catch (raw_tr){
    const tr = Caml_js_exceptions.internalToOCamlException(raw_tr);
    if (tr.MEL_EXN_ID === Unify) {
      throw new Caml_js_exceptions.MelangeError($$Error$9, {
                MEL_EXN_ID: $$Error$9,
                _1: loc,
                _2: val_env,
                _3: {
                  TAG: /* Field_type_mismatch */1,
                  _0: "instance variable",
                  _1: lab,
                  _2: tr._1
                }
              });
    }
    if (tr.MEL_EXN_ID === Stdlib.Not_found) {
      match = [
        undefined,
        virt
      ];
    } else {
      throw new Caml_js_exceptions.MelangeError(tr.MEL_EXN_ID, tr);
    }
  }
  const id = match[0];
  const result = id !== undefined ? [
      id,
      val_env,
      met_env,
      par_env
    ] : enter_met_env(undefined, none, lab, {
          TAG: /* Val_ivar */1,
          _0: mut,
          _1: cl_num
        }, ty, val_env, met_env, par_env);
  vars.contents = Curry._3(Meths.add, lab, [
        result[0],
        mut,
        match[1],
        ty
      ], vars.contents);
  return result;
}

function concr_vals(vars) {
  return Curry._3(Meths.fold, (function (id, param, s) {
                if (param[1] === /* Virtual */0) {
                  return s;
                } else {
                  return Curry._2(add$2, id, s);
                }
              }), vars, /* Empty */0);
}

function inheritance(self_type, env, ovf, concr_meths, warn_vals, loc, parent) {
  const cl_sig = scrape_class_type(parent);
  switch (cl_sig.TAG | 0) {
    case /* Cty_signature */1 :
        const cl_sig$1 = cl_sig._0;
        try {
          unify$2(env, self_type, cl_sig$1.csig_self);
        }
        catch (raw_trace){
          const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
          if (trace.MEL_EXN_ID === Unify) {
            const trace$1 = trace._1;
            let exit = 0;
            if (trace$1) {
              const match = trace$1.tl;
              if (match) {
                const match$1 = match.tl;
                if (match$1) {
                  const match$2 = match$1.tl;
                  if (match$2) {
                    const match$3 = match$2.hd[0].desc;
                    if (typeof match$3 === "number") {
                      exit = 1;
                    } else {
                      if (match$3.TAG === /* Tfield */5) {
                        throw new Caml_js_exceptions.MelangeError($$Error$9, {
                                  MEL_EXN_ID: $$Error$9,
                                  _1: loc,
                                  _2: env,
                                  _3: {
                                    TAG: /* Field_type_mismatch */1,
                                    _0: "method",
                                    _1: match$3._0,
                                    _2: match$2.tl
                                  }
                                });
                      }
                      exit = 1;
                    }
                  } else {
                    exit = 1;
                  }
                } else {
                  exit = 1;
                }
              } else {
                exit = 1;
              }
            } else {
              exit = 1;
            }
            if (exit === 1) {
              throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                        MEL_EXN_ID: "Assert_failure",
                        _1: [
                          "jscomp/test/ocaml_typedtree_test.ml",
                          48280,
                          12
                        ]
                      });
            }
            
          } else {
            throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
          }
        }
        const over_meths = Curry._2(inter$1, cl_sig$1.csig_concr, concr_meths);
        const concr_vals$1 = concr_vals(cl_sig$1.csig_vars);
        const over_vals = Curry._2(inter$1, concr_vals$1, warn_vals);
        if (ovf !== undefined) {
          if (ovf) {
            let cname;
            switch (parent.TAG | 0) {
              case /* Cty_constr */0 :
                  cname = name(undefined, parent._0);
                  break;
              case /* Cty_signature */1 :
              case /* Cty_arrow */2 :
                  cname = "inherited";
                  break;
              
            }
            if (!Curry._1(is_empty$1, over_meths)) {
              prerr_warning(loc, {
                    TAG: /* Method_override */2,
                    _0: {
                      hd: cname,
                      tl: Curry._1(elements, over_meths)
                    }
                  });
            }
            if (!Curry._1(is_empty$1, over_vals)) {
              prerr_warning(loc, {
                    TAG: /* Instance_variable_override */5,
                    _0: {
                      hd: cname,
                      tl: Curry._1(elements, over_vals)
                    }
                  });
            }
            
          } else if (Curry._1(is_empty$1, over_meths) && Curry._1(is_empty$1, over_vals)) {
            throw new Caml_js_exceptions.MelangeError($$Error$9, {
                      MEL_EXN_ID: $$Error$9,
                      _1: loc,
                      _2: env,
                      _3: {
                        TAG: /* No_overriding */23,
                        _0: "",
                        _1: ""
                      }
                    });
          }
          
        }
        const concr_meths$1 = Curry._2(union$2, cl_sig$1.csig_concr, concr_meths);
        const warn_vals$1 = Curry._2(union$2, concr_vals$1, warn_vals);
        return [
                cl_sig$1,
                concr_meths$1,
                warn_vals$1
              ];
    case /* Cty_constr */0 :
    case /* Cty_arrow */2 :
        throw new Caml_js_exceptions.MelangeError($$Error$9, {
                  MEL_EXN_ID: $$Error$9,
                  _1: loc,
                  _2: env,
                  _3: {
                    TAG: /* Structure_expected */2,
                    _0: parent
                  }
                });
    
  }
}

function virtual_method(val_env, meths, self_type, lab, priv, sty, loc) {
  const match = filter_self_method(val_env, lab, priv, meths, self_type);
  const sty$1 = force_poly(sty);
  const cty = transl_simple_type(val_env, false, sty$1);
  const ty = cty.ctyp_type;
  try {
    unify$2(val_env, ty, match[1]);
  }
  catch (raw_trace){
    const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
    if (trace.MEL_EXN_ID === Unify) {
      throw new Caml_js_exceptions.MelangeError($$Error$9, {
                MEL_EXN_ID: $$Error$9,
                _1: loc,
                _2: val_env,
                _3: {
                  TAG: /* Field_type_mismatch */1,
                  _0: "method",
                  _1: lab,
                  _2: trace._1
                }
              });
    }
    throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
  }
  return cty;
}

const delayed_meth_specs = {
  contents: /* [] */0
};

function declare_method(val_env, meths, self_type, lab, priv, sty, loc) {
  const match = filter_self_method(val_env, lab, priv, meths, self_type);
  const ty$p = match[1];
  const unif = function (ty) {
    try {
      return unify$2(val_env, ty, ty$p);
    }
    catch (raw_trace){
      const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
      if (trace.MEL_EXN_ID === Unify) {
        throw new Caml_js_exceptions.MelangeError($$Error$9, {
                  MEL_EXN_ID: $$Error$9,
                  _1: loc,
                  _2: val_env,
                  _3: {
                    TAG: /* Field_type_mismatch */1,
                    _0: "method",
                    _1: lab,
                    _2: trace._1
                  }
                });
      }
      throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
    }
  };
  const sty$1 = force_poly(sty);
  const match$1 = sty$1.ptyp_desc;
  if (typeof match$1 !== "number" && match$1.TAG === /* Ptyp_poly */8 && !match$1._0 && priv) {
    const sty$p = match$1._1;
    const returned_cty = ctyp(/* Ttyp_any */0, newty2(current_level.contents, /* Tnil */0), val_env, loc);
    delayed_meth_specs.contents = {
      hd: {
        LAZY_DONE: false,
        VAL: (function () {
            const cty = transl_simple_type_univars(val_env, sty$p);
            const ty = cty.ctyp_type;
            unif(ty);
            returned_cty.ctyp_desc = {
              TAG: /* Ttyp_poly */8,
              _0: /* [] */0,
              _1: cty
            };
            returned_cty.ctyp_type = ty;
          })
      },
      tl: delayed_meth_specs.contents
    };
    return returned_cty;
  }
  const cty = transl_simple_type(val_env, false, sty$1);
  const ty = cty.ctyp_type;
  unif(ty);
  return cty;
}

function type_constraint(val_env, sty, sty$p, loc) {
  const cty = transl_simple_type(val_env, false, sty);
  const ty = cty.ctyp_type;
  const cty$p = transl_simple_type(val_env, false, sty$p);
  const ty$p = cty$p.ctyp_type;
  try {
    unify$2(val_env, ty, ty$p);
  }
  catch (raw_trace){
    const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
    if (trace.MEL_EXN_ID === Unify) {
      throw new Caml_js_exceptions.MelangeError($$Error$9, {
                MEL_EXN_ID: $$Error$9,
                _1: loc,
                _2: val_env,
                _3: {
                  TAG: /* Unconsistent_constraint */0,
                  _0: trace._1
                }
              });
    }
    throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
  }
  return [
          cty,
          cty$p
        ];
}

function make_method(loc, cl_num, expr) {
  return Curry._6(Ast_helper_Exp.fun_, expr.pexp_loc, undefined, "", undefined, alias$1(loc, undefined, $$var$1(loc, undefined, {
                      txt: "self-*",
                      loc: loc
                    }), {
                  txt: "self-" + cl_num,
                  loc: loc
                }), expr);
}

function add_val(env, loc, lab, param, val_sig) {
  const virt = param[1];
  let virt$1;
  try {
    const match = Curry._2(Meths.find, lab, val_sig);
    const virt$p = match[1];
    virt$1 = virt$p === /* Concrete */1 ? virt$p : virt;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      virt$1 = virt;
    } else {
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  }
  return Curry._3(Meths.add, lab, [
              param[0],
              virt$1,
              param[2]
            ], val_sig);
}

function class_signature$1(env, param) {
  const sty = param.pcsig_self;
  const meths = {
    contents: /* Empty */0
  };
  const self_cty = transl_simple_type(env, false, sty);
  const self_cty$1 = {
    ctyp_desc: self_cty.ctyp_desc,
    ctyp_type: expand_head(env, self_cty.ctyp_type),
    ctyp_env: self_cty.ctyp_env,
    ctyp_loc: self_cty.ctyp_loc,
    ctyp_attributes: self_cty.ctyp_attributes
  };
  const self_type = self_cty$1.ctyp_type;
  const dummy_obj = newvar(undefined, undefined);
  unify$2(env, filter_method(env, dummy_method, /* Private */0, dummy_obj), newty2(current_level.contents, {
            TAG: /* Ttuple */2,
            _0: /* [] */0
          }));
  try {
    unify$2(env, self_type, dummy_obj);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Unify) {
      throw new Caml_js_exceptions.MelangeError($$Error$9, {
                MEL_EXN_ID: $$Error$9,
                _1: sty.ptyp_loc,
                _2: env,
                _3: {
                  TAG: /* Pattern_type_clash */5,
                  _0: self_type
                }
              });
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
  warning_enter_scope(undefined);
  const match = Stdlib__List.fold_left((function (param, param$1) {
          const inher = param[3];
          const concr_meths = param[2];
          const val_sig = param[1];
          const fields = param[0];
          const loc = param$1.pctf_loc;
          const mkctf = function (desc) {
            return {
                    ctf_desc: desc,
                    ctf_loc: loc,
                    ctf_attributes: param$1.pctf_attributes
                  };
          };
          const sparent = param$1.pctf_desc;
          switch (sparent.TAG | 0) {
            case /* Pctf_inherit */0 :
                const sparent$1 = sparent._0;
                const parent = class_type$3(env, sparent$1);
                const match = parent.cltyp_type;
                let inher$1;
                switch (match.TAG | 0) {
                  case /* Cty_constr */0 :
                      inher$1 = {
                        hd: [
                          match._0,
                          match._1
                        ],
                        tl: inher
                      };
                      break;
                  case /* Cty_signature */1 :
                  case /* Cty_arrow */2 :
                      inher$1 = inher;
                      break;
                  
                }
                const match$1 = inheritance(self_type, env, undefined, concr_meths, /* Empty */0, sparent$1.pcty_loc, parent.cltyp_type);
                const partial_arg = sparent$1.pcty_loc;
                const val_sig$1 = Curry._3(Meths.fold, (function (param, param$1, param$2) {
                        return add_val(env, partial_arg, param, param$1, param$2);
                      }), match$1[0].csig_vars, val_sig);
                return [
                        {
                          hd: mkctf({
                                TAG: /* Tctf_inherit */0,
                                _0: parent
                              }),
                          tl: fields
                        },
                        val_sig$1,
                        match$1[1],
                        inher$1
                      ];
            case /* Pctf_val */1 :
                const match$2 = sparent._0;
                const virt = match$2[2];
                const mut = match$2[1];
                const lab = match$2[0];
                const cty = transl_simple_type(env, false, match$2[3]);
                const ty = cty.ctyp_type;
                return [
                        {
                          hd: mkctf({
                                TAG: /* Tctf_val */1,
                                _0: [
                                  lab,
                                  mut,
                                  virt,
                                  cty
                                ]
                              }),
                          tl: fields
                        },
                        add_val(env, param$1.pctf_loc, lab, [
                              mut,
                              virt,
                              ty
                            ], val_sig),
                        concr_meths,
                        inher
                      ];
            case /* Pctf_method */2 :
                const match$3 = sparent._0;
                const virt$1 = match$3[2];
                const priv = match$3[1];
                const lab$1 = match$3[0];
                const cty$1 = declare_method(env, meths, self_type, lab$1, priv, match$3[3], param$1.pctf_loc);
                const concr_meths$1 = virt$1 ? Curry._2(add$2, lab$1, concr_meths) : concr_meths;
                return [
                        {
                          hd: mkctf({
                                TAG: /* Tctf_method */2,
                                _0: [
                                  lab$1,
                                  priv,
                                  virt$1,
                                  cty$1
                                ]
                              }),
                          tl: fields
                        },
                        val_sig,
                        concr_meths$1,
                        inher
                      ];
            case /* Pctf_constraint */3 :
                const match$4 = sparent._0;
                const match$5 = type_constraint(env, match$4[0], match$4[1], param$1.pctf_loc);
                return [
                        {
                          hd: mkctf({
                                TAG: /* Tctf_constraint */3,
                                _0: [
                                  match$5[0],
                                  match$5[1]
                                ]
                              }),
                          tl: fields
                        },
                        val_sig,
                        concr_meths,
                        inher
                      ];
            case /* Pctf_attribute */4 :
                const x = sparent._0;
                warning_attribute({
                      hd: x,
                      tl: /* [] */0
                    });
                return [
                        {
                          hd: mkctf({
                                TAG: /* Tctf_attribute */4,
                                _0: x
                              }),
                          tl: fields
                        },
                        val_sig,
                        concr_meths,
                        inher
                      ];
            case /* Pctf_extension */5 :
                throw new Caml_js_exceptions.MelangeError(Error_forward$2, {
                          MEL_EXN_ID: Error_forward$2,
                          _1: error_of_extension(sparent._0)
                        });
            
          }
        }), [
        /* [] */0,
        Meths.empty,
        /* Empty */0,
        /* [] */0
      ], param.pcsig_fields);
  warning_leave_scope(undefined);
  const cty_csig_vars = match[1];
  const cty_csig_concr = match[2];
  const cty_csig_inher = match[3];
  const cty = {
    csig_self: self_type,
    csig_vars: cty_csig_vars,
    csig_concr: cty_csig_concr,
    csig_inher: cty_csig_inher
  };
  return {
          csig_self: self_cty$1,
          csig_fields: Stdlib__List.rev(match[0]),
          csig_type: cty
        };
}

function class_type$3(env, scty) {
  const cltyp = function (desc, typ) {
    return {
            cltyp_desc: desc,
            cltyp_type: typ,
            cltyp_env: env,
            cltyp_loc: scty.pcty_loc,
            cltyp_attributes: scty.pcty_attributes
          };
  };
  const pcsig = scty.pcty_desc;
  switch (pcsig.TAG | 0) {
    case /* Pcty_constr */0 :
        const styl = pcsig._1;
        const lid = pcsig._0;
        const match = find_class_type(env, scty.pcty_loc, lid.txt);
        const decl = match[1];
        const path = match[0];
        if (same(decl.clty_path, unbound_class)) {
          throw new Caml_js_exceptions.MelangeError($$Error$9, {
                    MEL_EXN_ID: $$Error$9,
                    _1: scty.pcty_loc,
                    _2: env,
                    _3: {
                      TAG: /* Unbound_class_type_2 */7,
                      _0: lid.txt
                    }
                  });
        }
        const match$1 = instance_class(decl.clty_params, decl.clty_type);
        const params = match$1[0];
        if (Stdlib__List.length(params) !== Stdlib__List.length(styl)) {
          throw new Caml_js_exceptions.MelangeError($$Error$9, {
                    MEL_EXN_ID: $$Error$9,
                    _1: scty.pcty_loc,
                    _2: env,
                    _3: {
                      TAG: /* Parameter_arity_mismatch */11,
                      _0: lid.txt,
                      _1: Stdlib__List.length(params),
                      _2: Stdlib__List.length(styl)
                    }
                  });
        }
        const ctys = Stdlib__List.map2((function (sty, ty) {
                const cty$p = transl_simple_type(env, false, sty);
                const ty$p = cty$p.ctyp_type;
                try {
                  unify$2(env, ty$p, ty);
                }
                catch (raw_trace){
                  const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
                  if (trace.MEL_EXN_ID === Unify) {
                    throw new Caml_js_exceptions.MelangeError($$Error$9, {
                              MEL_EXN_ID: $$Error$9,
                              _1: sty.ptyp_loc,
                              _2: env,
                              _3: {
                                TAG: /* Parameter_mismatch */12,
                                _0: trace._1
                              }
                            });
                  }
                  throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
                }
                return cty$p;
              }), styl, params);
        const typ_2 = match$1[1];
        const typ = {
          TAG: /* Cty_constr */0,
          _0: path,
          _1: params,
          _2: typ_2
        };
        return cltyp({
                    TAG: /* Tcty_constr */0,
                    _0: path,
                    _1: lid,
                    _2: ctys
                  }, typ);
    case /* Pcty_signature */1 :
        const clsig = class_signature$1(env, pcsig._0);
        const typ$1 = {
          TAG: /* Cty_signature */1,
          _0: clsig.csig_type
        };
        return cltyp({
                    TAG: /* Tcty_signature */1,
                    _0: clsig
                  }, typ$1);
    case /* Pcty_arrow */2 :
        const l = pcsig._0;
        const cty = transl_simple_type(env, false, pcsig._1);
        const ty = cty.ctyp_type;
        const clty = class_type$3(env, pcsig._2);
        const typ_2$1 = clty.cltyp_type;
        const typ$2 = {
          TAG: /* Cty_arrow */2,
          _0: l,
          _1: ty,
          _2: typ_2$1
        };
        return cltyp({
                    TAG: /* Tcty_arrow */2,
                    _0: l,
                    _1: cty,
                    _2: clty
                  }, typ$2);
    case /* Pcty_extension */3 :
        throw new Caml_js_exceptions.MelangeError(Error_forward$2, {
                  MEL_EXN_ID: Error_forward$2,
                  _1: error_of_extension(pcsig._0)
                });
    
  }
}

function class_type$4(env, scty) {
  delayed_meth_specs.contents = /* [] */0;
  const cty = class_type$3(env, scty);
  Stdlib__List.iter(CamlinternalLazy.force, Stdlib__List.rev(delayed_meth_specs.contents));
  delayed_meth_specs.contents = /* [] */0;
  return cty;
}

function class_structure(cl_num, $$final, val_env, met_env, loc, param) {
  const spat = param.pcstr_self;
  const init = spat.ppat_loc;
  const self_loc_loc_start = init.loc_start;
  const self_loc_loc_end = init.loc_end;
  const self_loc = {
    loc_start: self_loc_loc_start,
    loc_end: self_loc_loc_end,
    loc_ghost: true
  };
  const self_type = newvar(undefined, undefined);
  unify$2(val_env, filter_method(val_env, dummy_method, /* Private */0, self_type), newty2(current_level.contents, {
            TAG: /* Ttuple */2,
            _0: /* [] */0
          }));
  const private_self = $$final ? newvar(undefined, undefined) : self_type;
  const match = type_self_pattern(cl_num, private_self, val_env, met_env, met_env, spat);
  const val_env$1 = match[3];
  const vars = match[2];
  const meths = match[1];
  const pat = match[0];
  const public_self = pat.pat_type;
  let ty;
  if ($$final) {
    const desc_0 = newvar(undefined, undefined);
    const desc_1 = {
      contents: undefined
    };
    const desc = {
      TAG: /* Tobject */4,
      _0: desc_0,
      _1: desc_1
    };
    ty = newty2(current_level.contents, desc);
  } else {
    ty = self_type;
  }
  try {
    unify$2(val_env$1, public_self, ty);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Unify) {
      throw new Caml_js_exceptions.MelangeError($$Error$9, {
                MEL_EXN_ID: $$Error$9,
                _1: spat.ppat_loc,
                _2: val_env$1,
                _3: {
                  TAG: /* Pattern_type_clash */5,
                  _0: public_self
                }
              });
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
  const get_methods = function (ty) {
    return flatten_fields(object_fields(expand_head(val_env$1, ty)))[0];
  };
  if ($$final) {
    Stdlib__List.iter((function (param) {
            const k = Caml_obj.caml_equal(field_kind_repr(param[1]), /* Fpresent */0) ? /* Public */1 : /* Private */0;
            try {
              return unify$2(val_env$1, param[2], filter_method(val_env$1, param[0], k, self_type));
            }
            catch (exn){
              throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                        MEL_EXN_ID: "Assert_failure",
                        _1: [
                          "jscomp/test/ocaml_typedtree_test.ml",
                          48779,
                          18
                        ]
                      });
            }
          }), get_methods(public_self));
  }
  warning_enter_scope(undefined);
  const match$1 = Stdlib__List.fold_left((function (param, param$1) {
          const local_vals = param[8];
          const local_meths = param[7];
          const inher = param[6];
          const warn_vals = param[5];
          const concr_meths = param[4];
          const fields = param[3];
          const par_env = param[2];
          const met_env = param[1];
          const val_env = param[0];
          const loc = param$1.pcf_loc;
          const mkcf = function (desc) {
            return {
                    cf_desc: desc,
                    cf_loc: loc,
                    cf_attributes: param$1.pcf_attributes
                  };
          };
          const expr = param$1.pcf_desc;
          switch (expr.TAG | 0) {
            case /* Pcf_inherit */0 :
                const $$super = expr._2;
                const sparent = expr._1;
                const ovf = expr._0;
                const parent = class_expr(cl_num, val_env, par_env, sparent);
                const match = parent.cl_type;
                let inher$1;
                switch (match.TAG | 0) {
                  case /* Cty_constr */0 :
                      inher$1 = {
                        hd: [
                          match._0,
                          match._1
                        ],
                        tl: inher
                      };
                      break;
                  case /* Cty_signature */1 :
                  case /* Cty_arrow */2 :
                      inher$1 = inher;
                      break;
                  
                }
                const match$1 = inheritance(self_type, val_env, ovf, concr_meths, warn_vals, sparent.pcl_loc, parent.cl_type);
                const cl_sig = match$1[0];
                const match$2 = Curry._3(Meths.fold, (function (lab, info, param) {
                        const match = enter_val(cl_num, vars, true, lab, info[0], info[1], info[2], param[0], param[1], param[2], sparent.pcl_loc);
                        return [
                                match[1],
                                match[2],
                                match[3],
                                {
                                  hd: [
                                    lab,
                                    match[0]
                                  ],
                                  tl: param[3]
                                }
                              ];
                      }), cl_sig.csig_vars, [
                      val_env,
                      met_env,
                      par_env,
                      /* [] */0
                    ]);
                const inh_vars = match$2[3];
                const par_env$1 = match$2[2];
                const met_env$1 = match$2[1];
                const val_env$1 = match$2[0];
                const inh_meths = Curry._3(fold$1, (function (lab, rem) {
                        return {
                                hd: [
                                  lab,
                                  create(lab)
                                ],
                                tl: rem
                              };
                      }), cl_sig.csig_concr, /* [] */0);
                let match$3;
                if ($$super !== undefined) {
                  const match$4 = enter_met_env((function (s) {
                          return {
                                  TAG: /* Unused_ancestor */20,
                                  _0: s
                                };
                        }), sparent.pcl_loc, $$super, {
                        TAG: /* Val_anc */3,
                        _0: inh_meths,
                        _1: cl_num
                      }, self_type, val_env$1, met_env$1, par_env$1);
                  match$3 = [
                    match$4[1],
                    match$4[2],
                    match$4[3]
                  ];
                } else {
                  match$3 = [
                    val_env$1,
                    met_env$1,
                    par_env$1
                  ];
                }
                return [
                        match$3[0],
                        match$3[1],
                        match$3[2],
                        {
                          hd: {
                            LAZY_DONE: false,
                            VAL: (function () {
                                return mkcf({
                                            TAG: /* Tcf_inherit */0,
                                            _0: ovf,
                                            _1: parent,
                                            _2: $$super,
                                            _3: inh_vars,
                                            _4: inh_meths
                                          });
                              })
                          },
                          tl: fields
                        },
                        match$1[1],
                        match$1[2],
                        inher$1,
                        local_meths,
                        local_vals
                      ];
            case /* Pcf_val */1 :
                const match$5 = expr._0;
                const styp = match$5[2];
                const mut = match$5[1];
                const lab = match$5[0];
                if (styp.TAG === /* Cfk_virtual */0) {
                  if (principal.contents) {
                    begin_def(undefined);
                  }
                  const cty = transl_simple_type(val_env, false, styp._0);
                  const ty = cty.ctyp_type;
                  if (principal.contents) {
                    end_def(undefined);
                    generalize_structure$1(current_level.contents, ty);
                  }
                  const match$6 = enter_val(cl_num, vars, false, lab.txt, mut, /* Virtual */0, ty, val_env, met_env, par_env, loc);
                  const met_env$p = match$6[2];
                  const id = match$6[0];
                  return [
                          match$6[1],
                          met_env$p,
                          match$6[3],
                          {
                            hd: {
                              LAZY_DONE: false,
                              VAL: (function () {
                                  return mkcf({
                                              TAG: /* Tcf_val */1,
                                              _0: lab,
                                              _1: mut,
                                              _2: id,
                                              _3: {
                                                TAG: /* Tcfk_virtual */0,
                                                _0: cty
                                              },
                                              _4: met_env === met_env$p
                                            });
                                })
                            },
                            tl: fields
                          },
                          concr_meths,
                          warn_vals,
                          inher,
                          local_meths,
                          local_vals
                        ];
                }
                const ovf$1 = styp._0;
                if (Curry._2(mem$2, lab.txt, local_vals)) {
                  throw new Caml_js_exceptions.MelangeError($$Error$9, {
                            MEL_EXN_ID: $$Error$9,
                            _1: loc,
                            _2: val_env,
                            _3: {
                              TAG: /* Duplicate */24,
                              _0: "instance variable",
                              _1: lab.txt
                            }
                          });
                }
                if (Curry._2(mem$2, lab.txt, warn_vals)) {
                  if (ovf$1 === /* Fresh */1) {
                    prerr_warning(lab.loc, {
                          TAG: /* Instance_variable_override */5,
                          _0: {
                            hd: lab.txt,
                            tl: /* [] */0
                          }
                        });
                  }
                  
                } else if (ovf$1 === /* Override */0) {
                  throw new Caml_js_exceptions.MelangeError($$Error$9, {
                            MEL_EXN_ID: $$Error$9,
                            _1: loc,
                            _2: val_env,
                            _3: {
                              TAG: /* No_overriding */23,
                              _0: "instance variable",
                              _1: lab.txt
                            }
                          });
                }
                if (principal.contents) {
                  begin_def(undefined);
                }
                let exp;
                try {
                  exp = type_exp(val_env, styp._1);
                }
                catch (raw_exn){
                  const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                  if (exn.MEL_EXN_ID === Unify) {
                    const match$7 = exn._1;
                    if (match$7) {
                      if (match$7.tl) {
                        throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
                      }
                      throw new Caml_js_exceptions.MelangeError($$Error$9, {
                                MEL_EXN_ID: $$Error$9,
                                _1: loc,
                                _2: val_env,
                                _3: {
                                  TAG: /* Make_nongen_seltype */17,
                                  _0: match$7.hd[0]
                                }
                              });
                    }
                    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
                  }
                  throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
                }
                if (principal.contents) {
                  end_def(undefined);
                  generalize_structure$1(current_level.contents, exp.exp_type);
                }
                const match$8 = enter_val(cl_num, vars, false, lab.txt, mut, /* Concrete */1, exp.exp_type, val_env, met_env, par_env, loc);
                const met_env$p$1 = match$8[2];
                const id$1 = match$8[0];
                return [
                        match$8[1],
                        met_env$p$1,
                        match$8[3],
                        {
                          hd: {
                            LAZY_DONE: false,
                            VAL: (function () {
                                return mkcf({
                                            TAG: /* Tcf_val */1,
                                            _0: lab,
                                            _1: mut,
                                            _2: id$1,
                                            _3: {
                                              TAG: /* Tcfk_concrete */1,
                                              _0: ovf$1,
                                              _1: exp
                                            },
                                            _4: met_env === met_env$p$1
                                          });
                              })
                          },
                          tl: fields
                        },
                        concr_meths,
                        Curry._2(add$2, lab.txt, warn_vals),
                        inher,
                        local_meths,
                        Curry._2(add$2, lab.txt, local_vals)
                      ];
            case /* Pcf_method */2 :
                const match$9 = expr._0;
                const sty = match$9[2];
                const priv = match$9[1];
                const lab$1 = match$9[0];
                if (sty.TAG === /* Cfk_virtual */0) {
                  const cty$1 = virtual_method(val_env, meths, self_type, lab$1.txt, priv, sty._0, loc);
                  return [
                          val_env,
                          met_env,
                          par_env,
                          {
                            hd: {
                              LAZY_DONE: false,
                              VAL: (function () {
                                  return mkcf({
                                              TAG: /* Tcf_method */2,
                                              _0: lab$1,
                                              _1: priv,
                                              _2: {
                                                TAG: /* Tcfk_virtual */0,
                                                _0: cty$1
                                              }
                                            });
                                })
                            },
                            tl: fields
                          },
                          concr_meths,
                          warn_vals,
                          inher,
                          local_meths,
                          local_vals
                        ];
                }
                const expr$1 = sty._1;
                const ovf$2 = sty._0;
                const match$10 = expr$1.pexp_desc;
                let expr$2;
                expr$2 = match$10.TAG === /* Pexp_poly */28 ? expr$1 : Curry._4(Ast_helper_Exp.poly, expr$1.pexp_loc, undefined, expr$1, undefined);
                if (Curry._2(mem$2, lab$1.txt, local_meths)) {
                  throw new Caml_js_exceptions.MelangeError($$Error$9, {
                            MEL_EXN_ID: $$Error$9,
                            _1: loc,
                            _2: val_env,
                            _3: {
                              TAG: /* Duplicate */24,
                              _0: "method",
                              _1: lab$1.txt
                            }
                          });
                }
                if (Curry._2(mem$2, lab$1.txt, concr_meths)) {
                  if (ovf$2 === /* Fresh */1) {
                    prerr_warning(loc, {
                          TAG: /* Method_override */2,
                          _0: {
                            hd: lab$1.txt,
                            tl: /* [] */0
                          }
                        });
                  }
                  
                } else if (ovf$2 === /* Override */0) {
                  throw new Caml_js_exceptions.MelangeError($$Error$9, {
                            MEL_EXN_ID: $$Error$9,
                            _1: loc,
                            _2: val_env,
                            _3: {
                              TAG: /* No_overriding */23,
                              _0: "method",
                              _1: lab$1.txt
                            }
                          });
                }
                const match$11 = filter_self_method(val_env, lab$1.txt, priv, meths, self_type);
                const ty$1 = match$11[1];
                try {
                  const match$12 = expr$2.pexp_desc;
                  if (match$12.TAG === /* Pexp_poly */28) {
                    const sty$1 = match$12._1;
                    const sbody = match$12._0;
                    if (sty$1 !== undefined) {
                      const sty$2 = force_poly(sty$1);
                      const cty$p = transl_simple_type(val_env, false, sty$2);
                      const ty$p = cty$p.ctyp_type;
                      unify$2(val_env, ty$p, ty$1);
                    }
                    const match$13 = repr(ty$1).desc;
                    if (typeof match$13 === "number") {
                      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                                MEL_EXN_ID: "Assert_failure",
                                _1: [
                                  "jscomp/test/ocaml_typedtree_test.ml",
                                  48681,
                                  17
                                ]
                              });
                    }
                    switch (match$13.TAG | 0) {
                      case /* Tvar */0 :
                          const ty$p$1 = newvar(undefined, undefined);
                          unify$2(val_env, newty2(current_level.contents, {
                                    TAG: /* Tpoly */10,
                                    _0: ty$p$1,
                                    _1: /* [] */0
                                  }), ty$1);
                          unify$2(val_env, type_approx(val_env, sbody), ty$p$1);
                          break;
                      case /* Tpoly */10 :
                          const match$14 = instance_poly(undefined, false, match$13._1, match$13._0);
                          const ty2 = type_approx(val_env, sbody);
                          unify$2(val_env, ty2, match$14[1]);
                          break;
                      default:
                        throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                                  MEL_EXN_ID: "Assert_failure",
                                  _1: [
                                    "jscomp/test/ocaml_typedtree_test.ml",
                                    48681,
                                    17
                                  ]
                                });
                    }
                  } else {
                    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                              MEL_EXN_ID: "Assert_failure",
                              _1: [
                                "jscomp/test/ocaml_typedtree_test.ml",
                                48683,
                                13
                              ]
                            });
                  }
                }
                catch (raw_trace){
                  const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
                  if (trace.MEL_EXN_ID === Unify) {
                    throw new Caml_js_exceptions.MelangeError($$Error$9, {
                              MEL_EXN_ID: $$Error$9,
                              _1: loc,
                              _2: val_env,
                              _3: {
                                TAG: /* Field_type_mismatch */1,
                                _0: "method",
                                _1: lab$1.txt,
                                _2: trace._1
                              }
                            });
                  }
                  throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
                }
                const meth_expr = make_method(self_loc, cl_num, expr$2);
                const vars_local = vars.contents;
                const field = {
                  LAZY_DONE: false,
                  VAL: (function () {
                      const meth_type = newty2(100000000, {
                            TAG: /* Tarrow */1,
                            _0: "",
                            _1: self_type,
                            _2: ty$1,
                            _3: /* Cok */0
                          });
                      raise_nongen_level(undefined);
                      vars.contents = vars_local;
                      const texp = type_expect(undefined, met_env, meth_expr, meth_type);
                      end_def(undefined);
                      return mkcf({
                                  TAG: /* Tcf_method */2,
                                  _0: lab$1,
                                  _1: priv,
                                  _2: {
                                    TAG: /* Tcfk_concrete */1,
                                    _0: ovf$2,
                                    _1: texp
                                  }
                                });
                    })
                };
                return [
                        val_env,
                        met_env,
                        par_env,
                        {
                          hd: field,
                          tl: fields
                        },
                        Curry._2(add$2, lab$1.txt, concr_meths),
                        warn_vals,
                        inher,
                        Curry._2(add$2, lab$1.txt, local_meths),
                        local_vals
                      ];
            case /* Pcf_constraint */3 :
                const match$15 = expr._0;
                const match$16 = type_constraint(val_env, match$15[0], match$15[1], loc);
                const cty$p$1 = match$16[1];
                const cty$2 = match$16[0];
                return [
                        val_env,
                        met_env,
                        par_env,
                        {
                          hd: {
                            LAZY_DONE: false,
                            VAL: (function () {
                                return mkcf({
                                            TAG: /* Tcf_constraint */3,
                                            _0: cty$2,
                                            _1: cty$p$1
                                          });
                              })
                          },
                          tl: fields
                        },
                        concr_meths,
                        warn_vals,
                        inher,
                        local_meths,
                        local_vals
                      ];
            case /* Pcf_initializer */4 :
                const expr$3 = make_method(self_loc, cl_num, expr._0);
                const vars_local$1 = vars.contents;
                const field$1 = {
                  LAZY_DONE: false,
                  VAL: (function () {
                      raise_nongen_level(undefined);
                      const desc_2 = instance_def(type_unit);
                      const desc = {
                        TAG: /* Tarrow */1,
                        _0: "",
                        _1: self_type,
                        _2: desc_2,
                        _3: /* Cok */0
                      };
                      const meth_type = newty2(current_level.contents, desc);
                      vars.contents = vars_local$1;
                      const texp = type_expect(undefined, met_env, expr$3, meth_type);
                      end_def(undefined);
                      return mkcf({
                                  TAG: /* Tcf_initializer */4,
                                  _0: texp
                                });
                    })
                };
                return [
                        val_env,
                        met_env,
                        par_env,
                        {
                          hd: field$1,
                          tl: fields
                        },
                        concr_meths,
                        warn_vals,
                        inher,
                        local_meths,
                        local_vals
                      ];
            case /* Pcf_attribute */5 :
                const x = expr._0;
                warning_attribute({
                      hd: x,
                      tl: /* [] */0
                    });
                return [
                        val_env,
                        met_env,
                        par_env,
                        {
                          hd: {
                            LAZY_DONE: false,
                            VAL: (function () {
                                return mkcf({
                                            TAG: /* Tcf_attribute */5,
                                            _0: x
                                          });
                              })
                          },
                          tl: fields
                        },
                        concr_meths,
                        warn_vals,
                        inher,
                        local_meths,
                        local_vals
                      ];
            case /* Pcf_extension */6 :
                throw new Caml_js_exceptions.MelangeError(Error_forward$2, {
                          MEL_EXN_ID: Error_forward$2,
                          _1: error_of_extension(expr._0)
                        });
            
          }
        }), [
        val_env$1,
        match[4],
        match[5],
        /* [] */0,
        /* Empty */0,
        /* Empty */0,
        /* [] */0,
        /* Empty */0,
        /* Empty */0
      ], param.pcstr_fields);
  const inher = match$1[6];
  const concr_meths = match$1[4];
  warning_leave_scope(undefined);
  unify$2(val_env$1, self_type, newvar(undefined, undefined));
  const sign_csig_vars = Curry._2(Meths.map, (function (param) {
          return [
                  param[1],
                  param[2],
                  param[3]
                ];
        }), vars.contents);
  const sign = {
    csig_self: public_self,
    csig_vars: sign_csig_vars,
    csig_concr: concr_meths,
    csig_inher: inher
  };
  const methods = get_methods(self_type);
  const priv_meths = Stdlib__List.filter((function (param) {
          return Caml_obj.caml_notequal(field_kind_repr(param[1]), /* Fpresent */0);
        }), methods);
  if ($$final) {
    close_object(self_type);
    const mets = virtual_methods({
          csig_self: self_type,
          csig_vars: sign_csig_vars,
          csig_concr: concr_meths,
          csig_inher: inher
        });
    const vals = Curry._3(Meths.fold, (function (name, param, l) {
            if (param[1] === /* Virtual */0) {
              return {
                      hd: name,
                      tl: l
                    };
            } else {
              return l;
            }
          }), sign_csig_vars, /* [] */0);
    if (Caml_obj.caml_notequal(mets, /* [] */0) || Caml_obj.caml_notequal(vals, /* [] */0)) {
      throw new Caml_js_exceptions.MelangeError($$Error$9, {
                MEL_EXN_ID: $$Error$9,
                _1: loc,
                _2: val_env$1,
                _3: {
                  TAG: /* Virtual_class */10,
                  _0: true,
                  _1: $$final,
                  _2: mets,
                  _3: vals
                }
              });
    }
    const self_methods = Stdlib__List.fold_right((function (param, rem) {
            const kind = param[1];
            const lab = param[0];
            if (lab === dummy_method) {
              const r = field_kind_repr(kind);
              if (typeof r === "number") {
                return rem;
              } else {
                set_kind(r._0, /* Fabsent */1);
                return rem;
              }
            }
            const desc_1 = copy_kind(kind);
            const desc_2 = param[2];
            const desc = {
              TAG: /* Tfield */5,
              _0: lab,
              _1: desc_1,
              _2: desc_2,
              _3: rem
            };
            return newty2(current_level.contents, desc);
          }), methods, newty2(current_level.contents, /* Tnil */0));
    try {
      unify$2(val_env$1, private_self, newty2(current_level.contents, {
                TAG: /* Tobject */4,
                _0: self_methods,
                _1: {
                  contents: undefined
                }
              }));
      unify$2(val_env$1, public_self, self_type);
    }
    catch (raw_trace){
      const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
      if (trace.MEL_EXN_ID === Unify) {
        throw new Caml_js_exceptions.MelangeError($$Error$9, {
                  MEL_EXN_ID: $$Error$9,
                  _1: loc,
                  _2: val_env$1,
                  _3: {
                    TAG: /* Final_self_clash */21,
                    _0: trace._1
                  }
                });
      }
      throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
    }
  }
  if (principal.contents) {
    Stdlib__List.iter((function (param) {
            generalize_spine(param[2]);
          }), methods);
  }
  const fields = Stdlib__List.map(CamlinternalLazy.force, Stdlib__List.rev(match$1[3]));
  if (principal.contents) {
    Stdlib__List.iter((function (param) {
            unify$2(val_env$1, param[2], newvar(undefined, undefined));
          }), methods);
  }
  const meths$1 = Curry._2(map, (function (param) {
          return param[0];
        }), meths.contents);
  const pub_meths$p = Stdlib__List.filter((function (param) {
          return Caml_obj.caml_equal(field_kind_repr(param[1]), /* Fpresent */0);
        }), get_methods(public_self));
  const names = function (param) {
    return Stdlib__List.map((function (param) {
                  return param[0];
                }), param);
  };
  const l1 = names(priv_meths);
  const l2 = names(pub_meths$p);
  const added = Stdlib__List.filter((function (x) {
          return Stdlib__List.mem(x, l1);
        }), l2);
  if (Caml_obj.caml_notequal(added, /* [] */0)) {
    prerr_warning(loc, {
          TAG: /* Implicit_public_methods */6,
          _0: added
        });
  }
  const sign$1 = $$final ? sign : ({
        csig_self: expand_head(val_env$1, public_self),
        csig_vars: sign_csig_vars,
        csig_concr: concr_meths,
        csig_inher: inher
      });
  return [
          {
            cstr_self: pat,
            cstr_fields: fields,
            cstr_type: sign$1,
            cstr_meths: meths$1
          },
          sign$1
        ];
}

function class_expr(cl_num, val_env, met_env, _scl) {
  while(true) {
    const scl = _scl;
    const cl_str = scl.pcl_desc;
    switch (cl_str.TAG | 0) {
      case /* Pcl_constr */0 :
          const lid = cl_str._0;
          const match = find_class$1(val_env, scl.pcl_loc, lid.txt);
          const decl = match[1];
          const path = match[0];
          if (same(decl.cty_path, unbound_class)) {
            throw new Caml_js_exceptions.MelangeError($$Error$9, {
                      MEL_EXN_ID: $$Error$9,
                      _1: scl.pcl_loc,
                      _2: val_env,
                      _3: {
                        TAG: /* Unbound_class_2 */6,
                        _0: lid.txt
                      }
                    });
          }
          const tyl = Stdlib__List.map((function (sty) {
                  return transl_simple_type(val_env, false, sty);
                }), cl_str._1);
          const match$1 = instance_class(decl.cty_params, decl.cty_type);
          const clty = match$1[1];
          const params = match$1[0];
          const clty$p = abbreviate_class_type(path, params, clty);
          if (Stdlib__List.length(params) !== Stdlib__List.length(tyl)) {
            throw new Caml_js_exceptions.MelangeError($$Error$9, {
                      MEL_EXN_ID: $$Error$9,
                      _1: scl.pcl_loc,
                      _2: val_env,
                      _3: {
                        TAG: /* Parameter_arity_mismatch */11,
                        _0: lid.txt,
                        _1: Stdlib__List.length(params),
                        _2: Stdlib__List.length(tyl)
                      }
                    });
          }
          Stdlib__List.iter2((function (cty$p, ty) {
                  const ty$p = cty$p.ctyp_type;
                  try {
                    return unify$2(val_env, ty$p, ty);
                  }
                  catch (raw_trace){
                    const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
                    if (trace.MEL_EXN_ID === Unify) {
                      throw new Caml_js_exceptions.MelangeError($$Error$9, {
                                MEL_EXN_ID: $$Error$9,
                                _1: cty$p.ctyp_loc,
                                _2: val_env,
                                _3: {
                                  TAG: /* Parameter_mismatch */12,
                                  _0: trace._1
                                }
                              });
                    }
                    throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
                  }
                }), tyl, params);
          const cl = rc({
                cl_desc: {
                  TAG: /* Tcl_ident */0,
                  _0: path,
                  _1: lid,
                  _2: tyl
                },
                cl_loc: scl.pcl_loc,
                cl_type: clty$p,
                cl_env: val_env,
                cl_attributes: scl.pcl_attributes
              });
          const match$2 = extract_constraints(clty);
          return rc({
                      cl_desc: {
                        TAG: /* Tcl_constraint */5,
                        _0: cl,
                        _1: undefined,
                        _2: match$2[0],
                        _3: match$2[1],
                        _4: match$2[2]
                      },
                      cl_loc: scl.pcl_loc,
                      cl_type: clty$p,
                      cl_env: val_env,
                      cl_attributes: /* [] */0
                    });
      case /* Pcl_structure */1 :
          const match$3 = class_structure(cl_num, false, val_env, met_env, scl.pcl_loc, cl_str._0);
          return rc({
                      cl_desc: {
                        TAG: /* Tcl_structure */1,
                        _0: match$3[0]
                      },
                      cl_loc: scl.pcl_loc,
                      cl_type: {
                        TAG: /* Cty_signature */1,
                        _0: match$3[1]
                      },
                      cl_env: val_env,
                      cl_attributes: scl.pcl_attributes
                    });
      case /* Pcl_fun */2 :
          const $$default = cl_str._1;
          const l = cl_str._0;
          if ($$default !== undefined) {
            const loc = $$default.pexp_loc;
            const scases_0 = Curry._3(Ast_helper_Exp.$$case, construct(loc, undefined, {
                      txt: {
                        TAG: /* Ldot */1,
                        _0: {
                          TAG: /* Lident */0,
                          _0: "*predef*"
                        },
                        _1: "Some"
                      },
                      loc: none
                    }, $$var$1(loc, undefined, {
                          txt: "*sth*",
                          loc: none
                        })), undefined, Curry._3(Ast_helper_Exp.ident, loc, undefined, {
                      txt: {
                        TAG: /* Lident */0,
                        _0: "*sth*"
                      },
                      loc: none
                    }));
            const scases_1 = {
              hd: Curry._3(Ast_helper_Exp.$$case, construct(loc, undefined, {
                        txt: {
                          TAG: /* Ldot */1,
                          _0: {
                            TAG: /* Lident */0,
                            _0: "*predef*"
                          },
                          _1: "None"
                        },
                        loc: none
                      }, undefined), undefined, $$default),
              tl: /* [] */0
            };
            const scases = {
              hd: scases_0,
              tl: scases_1
            };
            const smatch = Curry._4(Ast_helper_Exp.match_, loc, undefined, Curry._3(Ast_helper_Exp.ident, loc, undefined, {
                      txt: {
                        TAG: /* Lident */0,
                        _0: "*opt*"
                      },
                      loc: none
                    }), scases);
            const sfun = fun_$1(scl.pcl_loc, undefined, l, undefined, $$var$1(loc, undefined, {
                      txt: "*opt*",
                      loc: none
                    }), let_$1(scl.pcl_loc, undefined, /* Nonrecursive */0, {
                      hd: mk$17(undefined, undefined, undefined, undefined, cl_str._2, smatch),
                      tl: /* [] */0
                    }, cl_str._3));
            _scl = sfun;
            continue ;
          }
          if (principal.contents) {
            begin_def(undefined);
          }
          const match$4 = type_class_arg_pattern(cl_num, val_env, met_env, l, cl_str._2);
          const val_env$p = match$4[2];
          const pat = match$4[0];
          if (principal.contents) {
            end_def(undefined);
            iter_pattern((function (param) {
                    generalize_structure$1(current_level.contents, param.pat_type);
                  }), pat);
          }
          const pv = Stdlib__List.map((function (param) {
                  const id = param[0];
                  const path = {
                    TAG: /* Pident */0,
                    _0: param[2]
                  };
                  const vd = find_value(path, val_env$p);
                  return [
                          id,
                          param[1],
                          {
                            exp_desc: {
                              TAG: /* Texp_ident */0,
                              _0: path,
                              _1: {
                                txt: {
                                  TAG: /* Lident */0,
                                  _0: id.name
                                },
                                loc: none
                              },
                              _2: vd
                            },
                            exp_loc: none,
                            exp_extra: /* [] */0,
                            exp_type: instance(undefined, val_env$p, vd.val_type),
                            exp_env: val_env$p,
                            exp_attributes: /* [] */0
                          }
                        ];
                }), match$4[1]);
          const not_function = function (param) {
            switch (param.TAG | 0) {
              case /* Cty_constr */0 :
              case /* Cty_signature */1 :
                  return true;
              case /* Cty_arrow */2 :
                  return false;
              
            }
          };
          const partial = check_partial$1(undefined, val_env, pat.pat_type)(pat.pat_loc, {
                hd: {
                  c_lhs: pat,
                  c_guard: undefined,
                  c_rhs: {
                    exp_desc: {
                      TAG: /* Texp_constant */1,
                      _0: {
                        TAG: /* Const_int */0,
                        _0: 1
                      }
                    },
                    exp_loc: none,
                    exp_extra: /* [] */0,
                    exp_type: none$2,
                    exp_env: empty,
                    exp_attributes: /* [] */0
                  }
                },
                tl: /* [] */0
              });
          raise_nongen_level(undefined);
          const cl$1 = class_expr(cl_num, val_env$p, match$4[3], cl_str._3);
          end_def(undefined);
          if (is_optional(l) && not_function(cl$1.cl_type)) {
            prerr_warning(pat.pat_loc, /* Unerasable_optional_argument */8);
          }
          return rc({
                      cl_desc: {
                        TAG: /* Tcl_fun */2,
                        _0: l,
                        _1: pat,
                        _2: pv,
                        _3: cl$1,
                        _4: partial
                      },
                      cl_loc: scl.pcl_loc,
                      cl_type: {
                        TAG: /* Cty_arrow */2,
                        _0: l,
                        _1: instance_def(pat.pat_type),
                        _2: cl$1.cl_type
                      },
                      cl_env: val_env,
                      cl_attributes: scl.pcl_attributes
                    });
      case /* Pcl_apply */3 :
          const sargs = cl_str._1;
          if (Caml_obj.caml_equal(sargs, /* [] */0)) {
            ill_formed_ast(scl.pcl_loc, "Function application with no argument.");
          }
          if (principal.contents) {
            begin_def(undefined);
          }
          const cl$2 = class_expr(cl_num, val_env, met_env, cl_str._0);
          if (principal.contents) {
            end_def(undefined);
            generalize_class_type(generalize_structure$2, cl$2.cl_type);
          }
          const nonopt_labels = function (_ls, _ty_fun) {
            while(true) {
              const ty_fun = _ty_fun;
              const ls = _ls;
              switch (ty_fun.TAG | 0) {
                case /* Cty_constr */0 :
                case /* Cty_signature */1 :
                    return ls;
                case /* Cty_arrow */2 :
                    const ty_res = ty_fun._2;
                    const l = ty_fun._0;
                    if (is_optional(l)) {
                      _ty_fun = ty_res;
                      continue ;
                    }
                    _ty_fun = ty_res;
                    _ls = {
                      hd: l,
                      tl: ls
                    };
                    continue ;
                
              }
            };
          };
          let ignore_labels = true;
          if (!classic.contents) {
            const labels = nonopt_labels(/* [] */0, cl$2.cl_type);
            ignore_labels = Stdlib__List.length(labels) === Stdlib__List.length(sargs) && Stdlib__List.for_all((function (param) {
                    return param[0] === "";
                  }), sargs) && Stdlib__List.exists((function (l) {
                    return l !== "";
                  }), labels) && (prerr_warning(cl$2.cl_loc, /* Labels_omitted */3), true);
          }
          const type_args = function (_args, _omitted, _ty_fun, _ty_fun0, _sargs, _more_sargs) {
            while(true) {
              const more_sargs = _more_sargs;
              const sargs = _sargs;
              const ty_fun0 = _ty_fun0;
              const ty_fun = _ty_fun;
              const omitted = _omitted;
              const args = _args;
              switch (ty_fun.TAG | 0) {
                case /* Cty_constr */0 :
                case /* Cty_signature */1 :
                    break;
                case /* Cty_arrow */2 :
                    const ty = ty_fun._1;
                    const l = ty_fun._0;
                    switch (ty_fun0.TAG | 0) {
                      case /* Cty_constr */0 :
                      case /* Cty_signature */1 :
                          break;
                      case /* Cty_arrow */2 :
                          if (Caml_obj.caml_notequal(sargs, /* [] */0) || Caml_obj.caml_notequal(more_sargs, /* [] */0)) {
                            const ty0 = ty_fun0._1;
                            const name = label_name(l);
                            const optional = is_optional(l) ? /* Optional */1 : /* Required */0;
                            let match;
                            if (ignore_labels && !is_optional(l)) {
                              if (sargs) {
                                const match$1 = sargs.hd;
                                throw new Caml_js_exceptions.MelangeError($$Error$9, {
                                          MEL_EXN_ID: $$Error$9,
                                          _1: match$1[1].pexp_loc,
                                          _2: val_env,
                                          _3: {
                                            TAG: /* Apply_wrong_label */4,
                                            _0: match$1[0]
                                          }
                                        });
                              }
                              if (more_sargs) {
                                const match$2 = more_sargs.hd;
                                const sarg0 = match$2[1];
                                const l$p = match$2[0];
                                if (l !== l$p && l$p !== "") {
                                  throw new Caml_js_exceptions.MelangeError($$Error$9, {
                                            MEL_EXN_ID: $$Error$9,
                                            _1: sarg0.pexp_loc,
                                            _2: val_env,
                                            _3: {
                                              TAG: /* Apply_wrong_label */4,
                                              _0: l$p
                                            }
                                          });
                                }
                                match = [
                                  /* [] */0,
                                  more_sargs.tl,
                                  type_argument(val_env, sarg0, ty, ty0)
                                ];
                              } else {
                                throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                                          MEL_EXN_ID: "Assert_failure",
                                          _1: [
                                            "jscomp/test/ocaml_typedtree_test.ml",
                                            49036,
                                            20
                                          ]
                                        });
                              }
                            } else {
                              try {
                                let match$3;
                                try {
                                  const match$4 = extract_label_aux(/* [] */0, name, sargs);
                                  match$3 = [
                                    match$4[0],
                                    match$4[1],
                                    Stdlib.$at(match$4[2], match$4[3]),
                                    more_sargs
                                  ];
                                }
                                catch (raw_exn){
                                  const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                                  if (exn.MEL_EXN_ID === Stdlib.Not_found) {
                                    const match$5 = extract_label_aux(/* [] */0, name, more_sargs);
                                    match$3 = [
                                      match$5[0],
                                      match$5[1],
                                      Stdlib.$at(sargs, match$5[2]),
                                      match$5[3]
                                    ];
                                  } else {
                                    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
                                  }
                                }
                                const sarg0$1 = match$3[1];
                                const l$p$1 = match$3[0];
                                if (optional === /* Required */0 && is_optional(l$p$1)) {
                                  prerr_warning(sarg0$1.pexp_loc, {
                                        TAG: /* Nonoptional_label */26,
                                        _0: l
                                      });
                                }
                                let tmp;
                                if (optional === /* Required */0 || is_optional(l$p$1)) {
                                  tmp = type_argument(val_env, sarg0$1, ty, ty0);
                                } else {
                                  const ty$p = extract_option_type(val_env, ty);
                                  const ty0$p = extract_option_type(val_env, ty0);
                                  const arg = type_argument(val_env, sarg0$1, ty$p, ty0$p);
                                  tmp = option_some(arg);
                                }
                                match = [
                                  match$3[2],
                                  match$3[3],
                                  tmp
                                ];
                              }
                              catch (raw_exn$1){
                                const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
                                if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
                                  match = [
                                    sargs,
                                    more_sargs,
                                    is_optional(l) && (Stdlib__List.mem_assoc("", sargs) || Stdlib__List.mem_assoc("", more_sargs)) ? option_none(ty0, none) : undefined
                                  ];
                                } else {
                                  throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
                                }
                              }
                            }
                            const arg$1 = match[2];
                            const omitted$1 = arg$1 === undefined ? ({
                                  hd: [
                                    l,
                                    ty0
                                  ],
                                  tl: omitted
                                }) : omitted;
                            _more_sargs = match[1];
                            _sargs = match[0];
                            _ty_fun0 = ty_fun0._2;
                            _ty_fun = ty_fun._2;
                            _omitted = omitted$1;
                            _args = {
                              hd: [
                                l,
                                arg$1,
                                optional
                              ],
                              tl: args
                            };
                            continue ;
                          }
                          break;
                      
                    }
                    break;
                
              }
              const match$6 = Stdlib.$at(sargs, more_sargs);
              if (!match$6) {
                return [
                        Stdlib__List.rev(args),
                        Stdlib__List.fold_left((function (ty_fun, param) {
                                return {
                                        TAG: /* Cty_arrow */2,
                                        _0: param[0],
                                        _1: param[1],
                                        _2: ty_fun
                                      };
                              }), ty_fun0, omitted)
                      ];
              }
              if (Caml_obj.caml_notequal(omitted, /* [] */0)) {
                const match$7 = match$6.hd;
                throw new Caml_js_exceptions.MelangeError($$Error$9, {
                          MEL_EXN_ID: $$Error$9,
                          _1: match$7[1].pexp_loc,
                          _2: val_env,
                          _3: {
                            TAG: /* Apply_wrong_label */4,
                            _0: match$7[0]
                          }
                        });
              }
              throw new Caml_js_exceptions.MelangeError($$Error$9, {
                        MEL_EXN_ID: $$Error$9,
                        _1: cl$2.cl_loc,
                        _2: val_env,
                        _3: {
                          TAG: /* Cannot_apply */3,
                          _0: cl$2.cl_type
                        }
                      });
            };
          };
          const match$5 = instance_class(/* [] */0, cl$2.cl_type);
          const ty_fun0 = match$5[1];
          const match$6 = ignore_labels ? type_args(/* [] */0, /* [] */0, cl$2.cl_type, ty_fun0, /* [] */0, sargs) : type_args(/* [] */0, /* [] */0, cl$2.cl_type, ty_fun0, sargs, /* [] */0);
          return rc({
                      cl_desc: {
                        TAG: /* Tcl_apply */3,
                        _0: cl$2,
                        _1: match$6[0]
                      },
                      cl_loc: scl.pcl_loc,
                      cl_type: match$6[1],
                      cl_env: val_env,
                      cl_attributes: scl.pcl_attributes
                    });
      case /* Pcl_let */4 :
          const rec_flag = cl_str._0;
          let match$7;
          try {
            match$7 = type_let$1(val_env, rec_flag, cl_str._1, undefined);
          }
          catch (raw_exn){
            const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.MEL_EXN_ID === Unify) {
              const match$8 = exn._1;
              if (match$8) {
                if (match$8.tl) {
                  throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
                }
                throw new Caml_js_exceptions.MelangeError($$Error$9, {
                          MEL_EXN_ID: $$Error$9,
                          _1: scl.pcl_loc,
                          _2: val_env,
                          _3: {
                            TAG: /* Make_nongen_seltype */17,
                            _0: match$8.hd[0]
                          }
                        });
              }
              throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
            }
            throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
          }
          const val_env$1 = match$7[1];
          const defs = match$7[0];
          const match$9 = Stdlib__List.fold_right((function (param, param$1) {
                  const id = param[0];
                  const path = {
                    TAG: /* Pident */0,
                    _0: id
                  };
                  const vd = find_value(path, val_env$1);
                  begin_def(undefined);
                  const expr_exp_desc = {
                    TAG: /* Texp_ident */0,
                    _0: path,
                    _1: {
                      txt: {
                        TAG: /* Lident */0,
                        _0: id.name
                      },
                      loc: none
                    },
                    _2: vd
                  };
                  const expr_exp_type = instance(undefined, val_env$1, vd.val_type);
                  const expr = {
                    exp_desc: expr_exp_desc,
                    exp_loc: none,
                    exp_extra: /* [] */0,
                    exp_type: expr_exp_type,
                    exp_env: val_env$1,
                    exp_attributes: /* [] */0
                  };
                  end_def(undefined);
                  iter_generalize$1({
                        contents: /* [] */0
                      }, expr_exp_type);
                  const desc_val_type = expr_exp_type;
                  const desc_val_kind = {
                    TAG: /* Val_ivar */1,
                    _0: /* Immutable */0,
                    _1: cl_num
                  };
                  const desc_val_loc = vd.val_loc;
                  const desc = {
                    val_type: desc_val_type,
                    val_kind: desc_val_kind,
                    val_loc: desc_val_loc,
                    val_attributes: /* [] */0
                  };
                  const id$p = create(id.name);
                  return [
                          {
                            hd: [
                              id$p,
                              param[1],
                              expr
                            ],
                            tl: param$1[0]
                          },
                          add_value(undefined, id$p, desc, param$1[1])
                        ];
                }), Stdlib__List.rev(rev_let_bound_idents_with_loc(defs)), [
                /* [] */0,
                met_env
              ]);
          const cl$3 = class_expr(cl_num, val_env$1, match$9[1], cl_str._2);
          return rc({
                      cl_desc: {
                        TAG: /* Tcl_let */4,
                        _0: rec_flag,
                        _1: defs,
                        _2: match$9[0],
                        _3: cl$3
                      },
                      cl_loc: scl.pcl_loc,
                      cl_type: cl$3.cl_type,
                      cl_env: val_env$1,
                      cl_attributes: scl.pcl_attributes
                    });
      case /* Pcl_constraint */5 :
          begin_class_def(undefined);
          const context = narrow(undefined);
          const cl$4 = class_expr(cl_num, val_env, met_env, cl_str._0);
          widen(context);
          const context$1 = narrow(undefined);
          const clty$1 = class_type$4(val_env, cl_str._1);
          widen(context$1);
          end_def(undefined);
          limited_generalize$1(row_variable(repr(signature_of_class_type(cl$4.cl_type).csig_self)), cl$4.cl_type);
          limited_generalize$1(row_variable(repr(signature_of_class_type(clty$1.cltyp_type).csig_self)), clty$1.cltyp_type);
          const error = class_types(val_env, cl$4.cl_type, clty$1.cltyp_type);
          if (error) {
            throw new Caml_js_exceptions.MelangeError($$Error$9, {
                      MEL_EXN_ID: $$Error$9,
                      _1: cl$4.cl_loc,
                      _2: val_env,
                      _3: {
                        TAG: /* Class_match_failure */14,
                        _0: error
                      }
                    });
          }
          const match$10 = extract_constraints(clty$1.cltyp_type);
          return rc({
                      cl_desc: {
                        TAG: /* Tcl_constraint */5,
                        _0: cl$4,
                        _1: clty$1,
                        _2: match$10[0],
                        _3: match$10[1],
                        _4: match$10[2]
                      },
                      cl_loc: scl.pcl_loc,
                      cl_type: instance_class(/* [] */0, clty$1.cltyp_type)[1],
                      cl_env: val_env,
                      cl_attributes: scl.pcl_attributes
                    });
      case /* Pcl_extension */6 :
          throw new Caml_js_exceptions.MelangeError(Error_forward$2, {
                    MEL_EXN_ID: Error_forward$2,
                    _1: error_of_extension(cl_str._0)
                  });
      
    }
  };
}

const var_option = type_option(newty2(100000000, {
          TAG: /* Tvar */0,
          _0: undefined
        }));

function approx_declaration(_cl) {
  while(true) {
    const cl = _cl;
    const match = cl.pcl_desc;
    switch (match.TAG | 0) {
      case /* Pcl_fun */2 :
          const l = match._0;
          const arg = is_optional(l) ? instance_def(var_option) : newvar(undefined, undefined);
          const desc_2 = approx_declaration(match._3);
          const desc = {
            TAG: /* Tarrow */1,
            _0: l,
            _1: arg,
            _2: desc_2,
            _3: /* Cok */0
          };
          return newty2(current_level.contents, desc);
      case /* Pcl_let */4 :
          _cl = match._2;
          continue ;
      case /* Pcl_constraint */5 :
          _cl = match._0;
          continue ;
      default:
        return newvar(undefined, undefined);
    }
  };
}

function approx_description(ct) {
  const match = ct.pcty_desc;
  if (match.TAG !== /* Pcty_arrow */2) {
    return newvar(undefined, undefined);
  }
  const l = match._0;
  const arg = is_optional(l) ? instance_def(var_option) : newvar(undefined, undefined);
  const desc_2 = approx_description(match._2);
  const desc = {
    TAG: /* Tarrow */1,
    _0: l,
    _1: arg,
    _2: desc_2,
    _3: /* Cok */0
  };
  return newty2(current_level.contents, desc);
}

function temp_abbrev(loc, env, id, arity) {
  let params = /* [] */0;
  for(let _i = 1; _i <= arity; ++_i){
    params = {
      hd: newvar(undefined, undefined),
      tl: params
    };
  }
  const ty = newobj(newvar(undefined, undefined));
  const env$1 = add_type$1(true, id, {
        type_params: params,
        type_arity: arity,
        type_kind: /* Type_abstract */0,
        type_private: /* Public */1,
        type_manifest: ty,
        type_variance: replicate_list(Types_Variance.full, arity),
        type_newtype_level: undefined,
        type_loc: loc,
        type_attributes: /* [] */0
      }, env);
  return [
          params,
          ty,
          env$1
        ];
}

function extract_type_decls(param, decls) {
  return {
          hd: [
            param[5],
            param[6],
            param[8],
            param[2],
            param[4],
            param[13]
          ],
          tl: decls
        };
}

function merge_type_decls(param, param$1) {
  return [
          param[0],
          param[1],
          param$1[2],
          param[3],
          param$1[3],
          param[5],
          param$1[0],
          param[7],
          param$1[1],
          param[9],
          param[10],
          param[11],
          param[12],
          param[13]
        ];
}

function type_classes(define_class, approx, kind, env, cls) {
  const cls$1 = Stdlib__List.map((function (cl) {
          return [
                  cl,
                  create(cl.pci_name.txt),
                  create(cl.pci_name.txt),
                  create(cl.pci_name.txt),
                  create("#" + cl.pci_name.txt)
                ];
        }), cls);
  init_def(currentstamp.contents);
  begin_class_def(undefined);
  const match = Stdlib__List.fold_left((function (param, param$1) {
          const cl_id = param$1[4];
          const obj_id = param$1[3];
          const ty_id = param$1[2];
          const id = param$1[1];
          const cl = param$1[0];
          const arity = Stdlib__List.length(cl.pci_params);
          const match = temp_abbrev(cl.pci_loc, param[1], obj_id, arity);
          const match$1 = temp_abbrev(cl.pci_loc, match[2], cl_id, arity);
          const env = match$1[2];
          const constr_type = Curry._1(approx, cl.pci_expr);
          if (principal.contents) {
            generalize_spine(constr_type);
          }
          const dummy_cty = {
            TAG: /* Cty_signature */1,
            _0: {
              csig_self: newvar(undefined, undefined),
              csig_vars: Meths.empty,
              csig_concr: /* Empty */0,
              csig_inher: /* [] */0
            }
          };
          const match$2 = cl.pci_virt;
          const dummy_class = {
            cty_params: /* [] */0,
            cty_type: dummy_cty,
            cty_path: unbound_class,
            cty_new: match$2 ? constr_type : undefined,
            cty_variance: /* [] */0,
            cty_loc: none,
            cty_attributes: /* [] */0
          };
          const env$1 = add_cltype(ty_id, {
                clty_params: /* [] */0,
                clty_type: dummy_cty,
                clty_path: unbound_class,
                clty_variance: /* [] */0,
                clty_loc: none,
                clty_attributes: /* [] */0
              }, define_class ? add_class(id, dummy_class, env) : env);
          return [
                  {
                    hd: [
                      cl,
                      id,
                      ty_id,
                      obj_id,
                      match[0],
                      match[1],
                      cl_id,
                      match$1[0],
                      match$1[1],
                      constr_type,
                      dummy_class
                    ],
                    tl: param[0]
                  },
                  env$1
                ];
        }), [
        /* [] */0,
        env
      ], cls$1);
  const match$1 = Stdlib__List.fold_right((function (param, param$1) {
          const env = param$1[1];
          const constr_type = param[9];
          const cl_ty = param[8];
          const cl_params = param[7];
          const cl_id = param[6];
          const obj_ty = param[5];
          const obj_params = param[4];
          const obj_id = param[3];
          const ty_id = param[2];
          const id = param[1];
          const cl = param[0];
          reset_type_variables(undefined);
          begin_class_def(undefined);
          const make_param = function (param) {
            const sty = param[0];
            try {
              return [
                      transl_type_param(env, sty),
                      param[1]
                    ];
            }
            catch (raw_exn){
              const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn.MEL_EXN_ID === Already_bound) {
                throw new Caml_js_exceptions.MelangeError($$Error$9, {
                          MEL_EXN_ID: $$Error$9,
                          _1: sty.ptyp_loc,
                          _2: env,
                          _3: /* Repeated_parameter */0
                        });
              }
              throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
            }
          };
          const ci_params = Stdlib__List.map(make_param, cl.pci_params);
          const params = Stdlib__List.map((function (param) {
                  return param[0].ctyp_type;
                }), ci_params);
          const coercion_locs = {
            contents: /* [] */0
          };
          let match;
          try {
            self_coercion.contents = {
              hd: [
                {
                  TAG: /* Pident */0,
                  _0: obj_id
                },
                coercion_locs
              ],
              tl: self_coercion.contents
            };
            const res = Curry._2(kind, env, cl.pci_expr);
            self_coercion.contents = Stdlib__List.tl(self_coercion.contents);
            match = res;
          }
          catch (exn){
            self_coercion.contents = /* [] */0;
            throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
          }
          const typ = match[1];
          end_def(undefined);
          const sty = repr(signature_of_class_type(typ).csig_self);
          const match$1 = flatten_fields(object_fields(sty));
          Stdlib__List.iter((function (param) {
                  if (param[0] === dummy_method) {
                    return iter_generalize$1({
                                contents: /* [] */0
                              }, param[2]);
                  }
                  
                }), match$1[0]);
          const rv = row_variable(sty);
          Stdlib__List.iter((function (param) {
                  return limited_generalize(rv, param);
                }), params);
          limited_generalize$1(rv, typ);
          const match$2 = instance_class(params, typ);
          const obj_type = match$2[1];
          const obj_params$p = match$2[0];
          const constr = newconstr({
                TAG: /* Pident */0,
                _0: obj_id
              }, obj_params);
          const ty = repr(signature_of_class_type(obj_type).csig_self);
          hide_private_methods(ty);
          close_object(ty);
          try {
            Stdlib__List.iter2((function (param, param$1) {
                    return unify$2(env, param, param$1);
                  }), obj_params, obj_params$p);
          }
          catch (raw_exn){
            const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn$1.MEL_EXN_ID === Unify) {
              throw new Caml_js_exceptions.MelangeError($$Error$9, {
                        MEL_EXN_ID: $$Error$9,
                        _1: cl.pci_loc,
                        _2: env,
                        _3: {
                          TAG: /* Bad_parameters */13,
                          _0: obj_id,
                          _1: constr,
                          _2: newconstr({
                                TAG: /* Pident */0,
                                _0: obj_id
                              }, obj_params$p)
                        }
                      });
            }
            throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
          }
          try {
            unify$2(env, ty, constr);
          }
          catch (raw_exn$1){
            const exn$2 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
            if (exn$2.MEL_EXN_ID === Unify) {
              throw new Caml_js_exceptions.MelangeError($$Error$9, {
                        MEL_EXN_ID: $$Error$9,
                        _1: cl.pci_loc,
                        _2: env,
                        _3: {
                          TAG: /* Abbrev_type_clash */8,
                          _0: constr,
                          _1: ty,
                          _2: expand_head(env, constr)
                        }
                      });
            }
            throw new Caml_js_exceptions.MelangeError(exn$2.MEL_EXN_ID, exn$2);
          }
          const match$3 = instance_class(params, typ);
          const cl_params$p = match$3[0];
          const ty$1 = repr(signature_of_class_type(match$3[1]).csig_self);
          hide_private_methods(ty$1);
          set_object_name(obj_id, row_variable(ty$1), cl_params, ty$1);
          try {
            Stdlib__List.iter2((function (param, param$1) {
                    return unify$2(env, param, param$1);
                  }), cl_params, cl_params$p);
          }
          catch (raw_exn$2){
            const exn$3 = Caml_js_exceptions.internalToOCamlException(raw_exn$2);
            if (exn$3.MEL_EXN_ID === Unify) {
              throw new Caml_js_exceptions.MelangeError($$Error$9, {
                        MEL_EXN_ID: $$Error$9,
                        _1: cl.pci_loc,
                        _2: env,
                        _3: {
                          TAG: /* Bad_parameters */13,
                          _0: cl_id,
                          _1: newconstr({
                                TAG: /* Pident */0,
                                _0: cl_id
                              }, cl_params),
                          _2: newconstr({
                                TAG: /* Pident */0,
                                _0: cl_id
                              }, cl_params$p)
                        }
                      });
            }
            throw new Caml_js_exceptions.MelangeError(exn$3.MEL_EXN_ID, exn$3);
          }
          try {
            unify$2(env, ty$1, cl_ty);
          }
          catch (raw_exn$3){
            const exn$4 = Caml_js_exceptions.internalToOCamlException(raw_exn$3);
            if (exn$4.MEL_EXN_ID === Unify) {
              const constr$1 = newconstr({
                    TAG: /* Pident */0,
                    _0: cl_id
                  }, params);
              throw new Caml_js_exceptions.MelangeError($$Error$9, {
                        MEL_EXN_ID: $$Error$9,
                        _1: cl.pci_loc,
                        _2: env,
                        _3: {
                          TAG: /* Abbrev_type_clash */8,
                          _0: constr$1,
                          _1: ty$1,
                          _2: cl_ty
                        }
                      });
            }
            throw new Caml_js_exceptions.MelangeError(exn$4.MEL_EXN_ID, exn$4);
          }
          try {
            unify$2(env, constructor_type(constr, obj_type), instance(undefined, env, constr_type));
          }
          catch (raw_trace){
            const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
            if (trace.MEL_EXN_ID === Unify) {
              throw new Caml_js_exceptions.MelangeError($$Error$9, {
                        MEL_EXN_ID: $$Error$9,
                        _1: cl.pci_loc,
                        _2: env,
                        _3: {
                          TAG: /* Constructor_type_mismatch */9,
                          _0: cl.pci_name.txt,
                          _1: trace._1
                        }
                      });
            }
            throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
          }
          const cty_variance = Stdlib__List.map((function (param) {
                  return Types_Variance.full;
                }), params);
          const cltydef_clty_type = class_body(typ);
          const cltydef_clty_path = {
            TAG: /* Pident */0,
            _0: obj_id
          };
          const cltydef_clty_loc = cl.pci_loc;
          const cltydef_clty_attributes = cl.pci_attributes;
          const cltydef = {
            clty_params: params,
            clty_type: cltydef_clty_type,
            clty_path: cltydef_clty_path,
            clty_variance: cty_variance,
            clty_loc: cltydef_clty_loc,
            clty_attributes: cltydef_clty_attributes
          };
          const match$4 = cl.pci_virt;
          const clty = {
            cty_params: params,
            cty_type: typ,
            cty_path: {
              TAG: /* Pident */0,
              _0: obj_id
            },
            cty_new: match$4 ? constr_type : undefined,
            cty_variance: cty_variance,
            cty_loc: cl.pci_loc,
            cty_attributes: cl.pci_attributes
          };
          param[10].cty_type = typ;
          const env$1 = add_cltype(ty_id, cltydef, define_class ? add_class(id, clty, env) : env);
          if (cl.pci_virt === /* Concrete */1) {
            const sign = signature_of_class_type(typ);
            const mets = virtual_methods(sign);
            const vals = Curry._3(Meths.fold, (function (name, param, l) {
                    if (param[1] === /* Virtual */0) {
                      return {
                              hd: name,
                              tl: l
                            };
                    } else {
                      return l;
                    }
                  }), sign.csig_vars, /* [] */0);
            if (Caml_obj.caml_notequal(mets, /* [] */0) || Caml_obj.caml_notequal(vals, /* [] */0)) {
              throw new Caml_js_exceptions.MelangeError($$Error$9, {
                        MEL_EXN_ID: $$Error$9,
                        _1: cl.pci_loc,
                        _2: env$1,
                        _3: {
                          TAG: /* Virtual_class */10,
                          _0: define_class,
                          _1: false,
                          _2: mets,
                          _3: vals
                        }
                      });
            }
            
          }
          const arity = class_type_arity(typ);
          const match$5 = flatten_fields(object_fields(expand_head(env$1, obj_ty)));
          const pub_meths = Stdlib__List.map((function (param) {
                  return param[0];
                }), match$5[0]);
          const match$6 = instance_class(params, typ);
          const typ$p = match$6[1];
          const params$p = match$6[0];
          const cltydef_clty_type$1 = class_body(typ$p);
          const cltydef_clty_path$1 = {
            TAG: /* Pident */0,
            _0: obj_id
          };
          const cltydef_clty_loc$1 = cl.pci_loc;
          const cltydef_clty_attributes$1 = cl.pci_attributes;
          const cltydef$1 = {
            clty_params: params$p,
            clty_type: cltydef_clty_type$1,
            clty_path: cltydef_clty_path$1,
            clty_variance: cty_variance,
            clty_loc: cltydef_clty_loc$1,
            clty_attributes: cltydef_clty_attributes$1
          };
          const match$7 = cl.pci_virt;
          const clty$1 = {
            cty_params: params$p,
            cty_type: typ$p,
            cty_path: {
              TAG: /* Pident */0,
              _0: obj_id
            },
            cty_new: match$7 ? instance(undefined, env$1, constr_type) : undefined,
            cty_variance: cty_variance,
            cty_loc: cl.pci_loc,
            cty_attributes: cl.pci_attributes
          };
          const obj_abbr_type_arity = Stdlib__List.length(obj_params);
          const obj_abbr_type_manifest = obj_ty;
          const obj_abbr_type_variance = Stdlib__List.map((function (param) {
                  return Types_Variance.full;
                }), obj_params);
          const obj_abbr_type_loc = cl.pci_loc;
          const obj_abbr = {
            type_params: obj_params,
            type_arity: obj_abbr_type_arity,
            type_kind: /* Type_abstract */0,
            type_private: /* Public */1,
            type_manifest: obj_abbr_type_manifest,
            type_variance: obj_abbr_type_variance,
            type_newtype_level: undefined,
            type_loc: obj_abbr_type_loc,
            type_attributes: /* [] */0
          };
          const match$8 = instance_parameterized_type(undefined, params, repr(signature_of_class_type(typ).csig_self));
          const cl_ty$1 = match$8[1];
          const cl_params$1 = match$8[0];
          hide_private_methods(cl_ty$1);
          set_object_name(obj_id, row_variable(cl_ty$1), cl_params$1, cl_ty$1);
          const cl_abbr_type_arity = Stdlib__List.length(cl_params$1);
          const cl_abbr_type_manifest = cl_ty$1;
          const cl_abbr_type_variance = Stdlib__List.map((function (param) {
                  return Types_Variance.full;
                }), cl_params$1);
          const cl_abbr_type_loc = cl.pci_loc;
          const cl_abbr = {
            type_params: cl_params$1,
            type_arity: cl_abbr_type_arity,
            type_kind: /* Type_abstract */0,
            type_private: /* Public */1,
            type_manifest: cl_abbr_type_manifest,
            type_variance: cl_abbr_type_variance,
            type_newtype_level: undefined,
            type_loc: cl_abbr_type_loc,
            type_attributes: /* [] */0
          };
          return [
                  {
                    hd: [
                      cl,
                      id,
                      clty$1,
                      ty_id,
                      cltydef$1,
                      obj_id,
                      obj_abbr,
                      cl_id,
                      cl_abbr,
                      ci_params,
                      arity,
                      pub_meths,
                      Stdlib__List.rev(coercion_locs.contents),
                      match[0]
                    ],
                    tl: param$1[0]
                  },
                  env$1
                ];
        }), match[0], [
        /* [] */0,
        match[1]
      ]);
  const env$1 = match$1[1];
  end_def(undefined);
  const res = Stdlib__List.rev_map((function (param) {
          const expr = param[13];
          const cl_abbr = param[8];
          const cl_id = param[7];
          const obj_abbr = param[6];
          const obj_id = param[5];
          const cltydef = param[4];
          const ty_id = param[3];
          const clty = param[2];
          const id = param[1];
          const cl = param[0];
          try {
            collapse_conj_params(env$1, clty.cty_params);
          }
          catch (raw_trace){
            const trace = Caml_js_exceptions.internalToOCamlException(raw_trace);
            if (trace.MEL_EXN_ID === Unify) {
              throw new Caml_js_exceptions.MelangeError($$Error$9, {
                        MEL_EXN_ID: $$Error$9,
                        _1: cl.pci_loc,
                        _2: env$1,
                        _3: {
                          TAG: /* Non_collapsable_conjunction */20,
                          _0: id,
                          _1: clty,
                          _2: trace._1
                        }
                      });
            }
            throw new Caml_js_exceptions.MelangeError(trace.MEL_EXN_ID, trace);
          }
          Stdlib__List.iter(generalize, clty.cty_params);
          generalize_class_type(generalize, clty.cty_type);
          may(generalize, clty.cty_new);
          Stdlib__List.iter(generalize, obj_abbr.type_params);
          may(generalize, obj_abbr.type_manifest);
          Stdlib__List.iter(generalize, cl_abbr.type_params);
          may(generalize, cl_abbr.type_manifest);
          if (!closed_class$1(clty)) {
            throw new Caml_js_exceptions.MelangeError($$Error$9, {
                      MEL_EXN_ID: $$Error$9,
                      _1: cl.pci_loc,
                      _2: env$1,
                      _3: {
                        TAG: /* Non_generalizable_class */18,
                        _0: id,
                        _1: clty
                      }
                    });
          }
          const reason = closed_class(clty.cty_params, signature_of_class_type(clty.cty_type));
          if (reason !== undefined) {
            const printer = define_class ? (function (ppf) {
                  class_declaration$1(id, ppf, clty);
                }) : (function (ppf) {
                  cltype_declaration$1(id, ppf, cltydef);
                });
            throw new Caml_js_exceptions.MelangeError($$Error$9, {
                      MEL_EXN_ID: $$Error$9,
                      _1: cl.pci_loc,
                      _2: env$1,
                      _3: {
                        TAG: /* Unbound_type_var */16,
                        _0: printer,
                        _1: reason
                      }
                    });
          }
          return [
                  id,
                  cl.pci_name,
                  clty,
                  ty_id,
                  cltydef,
                  obj_id,
                  obj_abbr,
                  cl_id,
                  cl_abbr,
                  param[10],
                  param[11],
                  param[12],
                  expr,
                  {
                    ci_virt: cl.pci_virt,
                    ci_params: param[9],
                    ci_id_name: cl.pci_name,
                    ci_id_class: id,
                    ci_id_class_type: ty_id,
                    ci_id_object: obj_id,
                    ci_id_typesharp: cl_id,
                    ci_expr: expr,
                    ci_decl: clty,
                    ci_type_decl: cltydef,
                    ci_loc: cl.pci_loc,
                    ci_attributes: cl.pci_attributes
                  }
                ];
        }), match$1[0]);
  const decls = Stdlib__List.fold_right(extract_type_decls, res, /* [] */0);
  const decls$1 = compute_variance_decls(env$1, decls);
  const res$1 = Stdlib__List.map2(merge_type_decls, res, decls$1);
  const env$2 = Stdlib__List.fold_left((function (param, param$1) {
          return add_type$1(true, param$1[5], type_declaration(identity, param$1[6]), add_type$1(true, param$1[7], type_declaration(identity, param$1[8]), add_cltype(param$1[3], cltype_declaration(identity, param$1[4]), define_class ? add_class(param$1[0], class_declaration(identity, param$1[2]), param) : param)));
        }), env$1, res$1);
  const res$2 = Stdlib__List.map((function (param) {
          const coercion_locs = param[11];
          const cl_abbr = param[8];
          const obj_abbr = param[6];
          if (coercion_locs) {
            const loc = coercion_locs.hd;
            const match = cl_abbr.type_manifest;
            const match$1 = obj_abbr.type_manifest;
            let match$2;
            if (match !== undefined) {
              if (match$1 !== undefined) {
                const match$3 = instance_parameterized_type(undefined, cl_abbr.type_params, match);
                const match$4 = instance_parameterized_type(undefined, obj_abbr.type_params, match$1);
                Stdlib__List.iter2((function (param, param$1) {
                        return unify$2(env$2, param, param$1);
                      }), match$3[0], match$4[0]);
                match$2 = [
                  match$3[1],
                  match$4[1]
                ];
              } else {
                throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                          MEL_EXN_ID: "Assert_failure",
                          _1: [
                            "jscomp/test/ocaml_typedtree_test.ml",
                            49581,
                            15
                          ]
                        });
              }
            } else {
              throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                        MEL_EXN_ID: "Assert_failure",
                        _1: [
                          "jscomp/test/ocaml_typedtree_test.ml",
                          49581,
                          15
                        ]
                      });
            }
            const obj_ty = match$2[1];
            const cl_ty = match$2[0];
            try {
              subtype(env$2, cl_ty, obj_ty)(undefined);
            }
            catch (raw_exn){
              const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn.MEL_EXN_ID === Subtype) {
                throw new Caml_js_exceptions.MelangeError($$Error$7, {
                          MEL_EXN_ID: $$Error$7,
                          _1: loc,
                          _2: env$2,
                          _3: {
                            TAG: /* Not_subtype */23,
                            _0: exn._1,
                            _1: exn._2
                          }
                        });
              }
              throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
            }
            if (!opened_object(cl_ty)) {
              throw new Caml_js_exceptions.MelangeError($$Error$9, {
                        MEL_EXN_ID: $$Error$9,
                        _1: loc,
                        _2: env$2,
                        _3: {
                          TAG: /* Cannot_coerce_self */19,
                          _0: obj_ty
                        }
                      });
            }
            
          }
          return [
                  param[0],
                  param[1],
                  param[2],
                  param[3],
                  param[4],
                  param[5],
                  obj_abbr,
                  param[7],
                  cl_abbr,
                  param[9],
                  param[10],
                  param[13]
                ];
        }), res$1);
  return [
          res$2,
          env$2
        ];
}

const class_num = {
  contents: 0
};

function class_declaration$2(env, sexpr) {
  class_num.contents = class_num.contents + 1 | 0;
  const expr = class_expr(String(class_num.contents), env, env, sexpr);
  return [
          expr,
          expr.cl_type
        ];
}

function class_description(env, sexpr) {
  const expr = class_type$4(env, sexpr);
  return [
          expr,
          expr.cltyp_type
        ];
}

function class_declarations$2(env, cls) {
  return type_classes(true, approx_declaration, class_declaration$2, env, cls);
}

function class_descriptions(env, cls) {
  return type_classes(true, approx_description, class_description, env, cls);
}

function class_type_declarations$2(env, cls) {
  const match = type_classes(false, approx_description, class_description, env, cls);
  return [
          Stdlib__List.map((function (param) {
                  return [
                          param[3],
                          param[1],
                          param[4],
                          param[5],
                          param[6],
                          param[7],
                          param[8],
                          param[11]
                        ];
                }), match[0]),
          match[1]
        ];
}

function unify_parents_struct(env, ty, st) {
  Stdlib__List.iter((function (param) {
          const match = param.cf_desc;
          if (match.TAG === /* Tcf_inherit */0) {
            let _cl = match._1;
            while(true) {
              const cl = _cl;
              const st = cl.cl_desc;
              switch (st.TAG | 0) {
                case /* Tcl_ident */0 :
                    try {
                      const decl = find_class(st._0, env);
                      const match$1 = find_cltype_for_path(env, decl.cty_path);
                      return unify$2(env, ty, instance(undefined, env, match$1[1]));
                    }
                    catch (raw_exn){
                      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
                        return ;
                      }
                      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                                MEL_EXN_ID: "Assert_failure",
                                _1: [
                                  "jscomp/test/ocaml_typedtree_test.ml",
                                  49658,
                                  15
                                ]
                              });
                    }
                case /* Tcl_structure */1 :
                    return unify_parents_struct(env, ty, st._0);
                case /* Tcl_fun */2 :
                case /* Tcl_let */4 :
                    _cl = st._3;
                    continue ;
                case /* Tcl_apply */3 :
                case /* Tcl_constraint */5 :
                    _cl = st._0;
                    continue ;
                
              }
            };
          }
          
        }), st.cstr_fields);
}

function type_object$1(env, loc, s) {
  class_num.contents = class_num.contents + 1 | 0;
  const match = class_structure(String(class_num.contents), true, env, env, loc, s);
  const sign = match[1];
  const desc = match[0];
  const sty = expand_head(env, sign.csig_self);
  hide_private_methods(sty);
  const match$1 = flatten_fields(object_fields(sty));
  const meths = Stdlib__List.map((function (param) {
          return param[0];
        }), match$1[0]);
  unify_parents_struct(env, sign.csig_self, desc);
  return [
          desc,
          sign,
          meths
        ];
}

type_object.contents = type_object$1;

function approx_class(sdecl) {
  const self$p = mk(undefined, undefined, /* Ptyp_any */0);
  const clty$p = signature$1(sdecl.pci_expr.pcty_loc, undefined, {
        pcsig_self: self$p,
        pcsig_fields: /* [] */0
      });
  return {
          pci_virt: sdecl.pci_virt,
          pci_params: sdecl.pci_params,
          pci_name: sdecl.pci_name,
          pci_expr: clty$p,
          pci_loc: sdecl.pci_loc,
          pci_attributes: sdecl.pci_attributes
        };
}

function approx_class_declarations(env, sdecls) {
  return class_type_declarations$2(env, Stdlib__List.map(approx_class, sdecls))[0];
}

register_error_of_exn(function (err) {
      if (err.MEL_EXN_ID !== $$Error$9) {
        if (err.MEL_EXN_ID === Error_forward$2) {
          return err._1;
        } else {
          return ;
        }
      }
      const env = err._2;
      return error_of_printer(err._1, (function (param, param$1) {
                    return wrap_printing_env(env, (function (param$2) {
                                  if (typeof param$1 === "number") {
                                    return Stdlib__Format.fprintf(param)(/* Format */{
                                                _0: {
                                                  TAG: /* String_literal */11,
                                                  _0: "A type parameter occurs several times",
                                                  _1: /* End_of_format */0
                                                },
                                                _1: "A type parameter occurs several times"
                                              });
                                  }
                                  switch (param$1.TAG | 0) {
                                    case /* Unconsistent_constraint */0 :
                                        Stdlib__Format.fprintf(param)(/* Format */{
                                              _0: {
                                                TAG: /* String_literal */11,
                                                _0: "The class constraints are not consistent.",
                                                _1: {
                                                  TAG: /* Formatting_lit */17,
                                                  _0: /* Flush_newline */4,
                                                  _1: /* End_of_format */0
                                                }
                                              },
                                              _1: "The class constraints are not consistent.@."
                                            });
                                        return report_unification_error(param, env, undefined, param$1._0, (function (ppf) {
                                                      Stdlib__Format.fprintf(ppf)(/* Format */{
                                                            _0: {
                                                              TAG: /* String_literal */11,
                                                              _0: "Type",
                                                              _1: /* End_of_format */0
                                                            },
                                                            _1: "Type"
                                                          });
                                                    }), (function (ppf) {
                                                      Stdlib__Format.fprintf(ppf)(/* Format */{
                                                            _0: {
                                                              TAG: /* String_literal */11,
                                                              _0: "is not compatible with type",
                                                              _1: /* End_of_format */0
                                                            },
                                                            _1: "is not compatible with type"
                                                          });
                                                    }));
                                    case /* Field_type_mismatch */1 :
                                        const m = param$1._1;
                                        const k = param$1._0;
                                        return report_unification_error(param, env, undefined, param$1._2, (function (ppf) {
                                                      Curry._2(Stdlib__Format.fprintf(ppf)(/* Format */{
                                                                _0: {
                                                                  TAG: /* String_literal */11,
                                                                  _0: "The ",
                                                                  _1: {
                                                                    TAG: /* String */2,
                                                                    _0: /* No_padding */0,
                                                                    _1: {
                                                                      TAG: /* Char_literal */12,
                                                                      _0: /* ' ' */32,
                                                                      _1: {
                                                                        TAG: /* String */2,
                                                                        _0: /* No_padding */0,
                                                                        _1: {
                                                                          TAG: /* Formatting_lit */17,
                                                                          _0: {
                                                                            TAG: /* Break */0,
                                                                            _0: "@ ",
                                                                            _1: 1,
                                                                            _2: 0
                                                                          },
                                                                          _1: {
                                                                            TAG: /* String_literal */11,
                                                                            _0: "has type",
                                                                            _1: /* End_of_format */0
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                },
                                                                _1: "The %s %s@ has type"
                                                              }), k, m);
                                                    }), (function (ppf) {
                                                      Stdlib__Format.fprintf(ppf)(/* Format */{
                                                            _0: {
                                                              TAG: /* String_literal */11,
                                                              _0: "but is expected to have type",
                                                              _1: /* End_of_format */0
                                                            },
                                                            _1: "but is expected to have type"
                                                          });
                                                    }));
                                    case /* Structure_expected */2 :
                                        return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                        _0: {
                                                          TAG: /* Formatting_gen */18,
                                                          _0: {
                                                            TAG: /* Open_box */1,
                                                            _0: /* Format */{
                                                              _0: /* End_of_format */0,
                                                              _1: ""
                                                            }
                                                          },
                                                          _1: {
                                                            TAG: /* String_literal */11,
                                                            _0: "This class expression is not a class structure; it has type",
                                                            _1: {
                                                              TAG: /* Formatting_lit */17,
                                                              _0: {
                                                                TAG: /* Break */0,
                                                                _0: "@ ",
                                                                _1: 1,
                                                                _2: 0
                                                              },
                                                              _1: {
                                                                TAG: /* Alpha */15,
                                                                _0: {
                                                                  TAG: /* Formatting_lit */17,
                                                                  _0: /* Close_box */0,
                                                                  _1: /* End_of_format */0
                                                                }
                                                              }
                                                            }
                                                          }
                                                        },
                                                        _1: "@[This class expression is not a class structure; it has type@ %a@]"
                                                      }), class_type$2, param$1._0);
                                    case /* Cannot_apply */3 :
                                        return Stdlib__Format.fprintf(param)(/* Format */{
                                                    _0: {
                                                      TAG: /* String_literal */11,
                                                      _0: "This class expression is not a class function, it cannot be applied",
                                                      _1: /* End_of_format */0
                                                    },
                                                    _1: "This class expression is not a class function, it cannot be applied"
                                                  });
                                    case /* Apply_wrong_label */4 :
                                        const mark_label = function (l) {
                                          if (l === "") {
                                            return "out label";
                                          } else {
                                            return Curry._1(Stdlib__Format.sprintf(/* Format */{
                                                            _0: {
                                                              TAG: /* String_literal */11,
                                                              _0: " label ~",
                                                              _1: {
                                                                TAG: /* String */2,
                                                                _0: /* No_padding */0,
                                                                _1: /* End_of_format */0
                                                              }
                                                            },
                                                            _1: " label ~%s"
                                                          }), l);
                                          }
                                        };
                                        return Curry._1(Stdlib__Format.fprintf(param)(/* Format */{
                                                        _0: {
                                                          TAG: /* String_literal */11,
                                                          _0: "This argument cannot be applied with",
                                                          _1: {
                                                            TAG: /* String */2,
                                                            _0: /* No_padding */0,
                                                            _1: /* End_of_format */0
                                                          }
                                                        },
                                                        _1: "This argument cannot be applied with%s"
                                                      }), mark_label(param$1._0));
                                    case /* Pattern_type_clash */5 :
                                        const ty = param$1._0;
                                        reset(undefined);
                                        mark_loops(ty);
                                        return Curry._3(Stdlib__Format.fprintf(param)(/* Format */{
                                                        _0: {
                                                          TAG: /* Formatting_gen */18,
                                                          _0: {
                                                            TAG: /* Open_box */1,
                                                            _0: /* Format */{
                                                              _0: /* End_of_format */0,
                                                              _1: ""
                                                            }
                                                          },
                                                          _1: {
                                                            TAG: /* String */2,
                                                            _0: /* No_padding */0,
                                                            _1: {
                                                              TAG: /* Formatting_lit */17,
                                                              _0: {
                                                                TAG: /* Break */0,
                                                                _0: "@ ",
                                                                _1: 1,
                                                                _2: 0
                                                              },
                                                              _1: {
                                                                TAG: /* Alpha */15,
                                                                _0: {
                                                                  TAG: /* Formatting_lit */17,
                                                                  _0: /* Close_box */0,
                                                                  _1: /* End_of_format */0
                                                                }
                                                              }
                                                            }
                                                          }
                                                        },
                                                        _1: "@[%s@ %a@]"
                                                      }), "This pattern cannot match self: it only matches values of type", type_expr$1, ty);
                                    case /* Unbound_class_2 */6 :
                                        return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                        _0: {
                                                          TAG: /* Formatting_gen */18,
                                                          _0: {
                                                            TAG: /* Open_box */1,
                                                            _0: /* Format */{
                                                              _0: /* End_of_format */0,
                                                              _1: ""
                                                            }
                                                          },
                                                          _1: {
                                                            TAG: /* String_literal */11,
                                                            _0: "The class",
                                                            _1: {
                                                              TAG: /* Formatting_lit */17,
                                                              _0: {
                                                                TAG: /* Break */0,
                                                                _0: "@ ",
                                                                _1: 1,
                                                                _2: 0
                                                              },
                                                              _1: {
                                                                TAG: /* Alpha */15,
                                                                _0: {
                                                                  TAG: /* Formatting_lit */17,
                                                                  _0: {
                                                                    TAG: /* Break */0,
                                                                    _0: "@ ",
                                                                    _1: 1,
                                                                    _2: 0
                                                                  },
                                                                  _1: {
                                                                    TAG: /* String_literal */11,
                                                                    _0: "is not yet completely defined",
                                                                    _1: {
                                                                      TAG: /* Formatting_lit */17,
                                                                      _0: /* Close_box */0,
                                                                      _1: /* End_of_format */0
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        },
                                                        _1: "@[The class@ %a@ is not yet completely defined@]"
                                                      }), longident, param$1._0);
                                    case /* Unbound_class_type_2 */7 :
                                        return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                        _0: {
                                                          TAG: /* Formatting_gen */18,
                                                          _0: {
                                                            TAG: /* Open_box */1,
                                                            _0: /* Format */{
                                                              _0: /* End_of_format */0,
                                                              _1: ""
                                                            }
                                                          },
                                                          _1: {
                                                            TAG: /* String_literal */11,
                                                            _0: "The class type",
                                                            _1: {
                                                              TAG: /* Formatting_lit */17,
                                                              _0: {
                                                                TAG: /* Break */0,
                                                                _0: "@ ",
                                                                _1: 1,
                                                                _2: 0
                                                              },
                                                              _1: {
                                                                TAG: /* Alpha */15,
                                                                _0: {
                                                                  TAG: /* Formatting_lit */17,
                                                                  _0: {
                                                                    TAG: /* Break */0,
                                                                    _0: "@ ",
                                                                    _1: 1,
                                                                    _2: 0
                                                                  },
                                                                  _1: {
                                                                    TAG: /* String_literal */11,
                                                                    _0: "is not yet completely defined",
                                                                    _1: {
                                                                      TAG: /* Formatting_lit */17,
                                                                      _0: /* Close_box */0,
                                                                      _1: /* End_of_format */0
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        },
                                                        _1: "@[The class type@ %a@ is not yet completely defined@]"
                                                      }), longident, param$1._0);
                                    case /* Abbrev_type_clash */8 :
                                        const expected = param$1._2;
                                        const actual = param$1._1;
                                        const abbrev = param$1._0;
                                        reset_and_mark_loops_list({
                                              hd: abbrev,
                                              tl: {
                                                hd: actual,
                                                tl: {
                                                  hd: expected,
                                                  tl: /* [] */0
                                                }
                                              }
                                            });
                                        return Curry._6(Stdlib__Format.fprintf(param)(/* Format */{
                                                        _0: {
                                                          TAG: /* Formatting_gen */18,
                                                          _0: {
                                                            TAG: /* Open_box */1,
                                                            _0: /* Format */{
                                                              _0: /* End_of_format */0,
                                                              _1: ""
                                                            }
                                                          },
                                                          _1: {
                                                            TAG: /* String_literal */11,
                                                            _0: "The abbreviation",
                                                            _1: {
                                                              TAG: /* Formatting_lit */17,
                                                              _0: {
                                                                TAG: /* Break */0,
                                                                _0: "@ ",
                                                                _1: 1,
                                                                _2: 0
                                                              },
                                                              _1: {
                                                                TAG: /* Alpha */15,
                                                                _0: {
                                                                  TAG: /* Formatting_lit */17,
                                                                  _0: {
                                                                    TAG: /* Break */0,
                                                                    _0: "@ ",
                                                                    _1: 1,
                                                                    _2: 0
                                                                  },
                                                                  _1: {
                                                                    TAG: /* String_literal */11,
                                                                    _0: "expands to type",
                                                                    _1: {
                                                                      TAG: /* Formatting_lit */17,
                                                                      _0: {
                                                                        TAG: /* Break */0,
                                                                        _0: "@ ",
                                                                        _1: 1,
                                                                        _2: 0
                                                                      },
                                                                      _1: {
                                                                        TAG: /* Alpha */15,
                                                                        _0: {
                                                                          TAG: /* Formatting_lit */17,
                                                                          _0: {
                                                                            TAG: /* Break */0,
                                                                            _0: "@ ",
                                                                            _1: 1,
                                                                            _2: 0
                                                                          },
                                                                          _1: {
                                                                            TAG: /* String_literal */11,
                                                                            _0: "but is used with type",
                                                                            _1: {
                                                                              TAG: /* Formatting_lit */17,
                                                                              _0: {
                                                                                TAG: /* Break */0,
                                                                                _0: "@ ",
                                                                                _1: 1,
                                                                                _2: 0
                                                                              },
                                                                              _1: {
                                                                                TAG: /* Alpha */15,
                                                                                _0: {
                                                                                  TAG: /* Formatting_lit */17,
                                                                                  _0: /* Close_box */0,
                                                                                  _1: /* End_of_format */0
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        },
                                                        _1: "@[The abbreviation@ %a@ expands to type@ %a@ but is used with type@ %a@]"
                                                      }), type_expr$1, abbrev, type_expr$1, actual, type_expr$1, expected);
                                    case /* Constructor_type_mismatch */9 :
                                        const c = param$1._0;
                                        return report_unification_error(param, env, undefined, param$1._1, (function (ppf) {
                                                      Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                                                                _0: {
                                                                  TAG: /* String_literal */11,
                                                                  _0: "The expression \"new ",
                                                                  _1: {
                                                                    TAG: /* String */2,
                                                                    _0: /* No_padding */0,
                                                                    _1: {
                                                                      TAG: /* String_literal */11,
                                                                      _0: "\" has type",
                                                                      _1: /* End_of_format */0
                                                                    }
                                                                  }
                                                                },
                                                                _1: "The expression \"new %s\" has type"
                                                              }), c);
                                                    }), (function (ppf) {
                                                      Stdlib__Format.fprintf(ppf)(/* Format */{
                                                            _0: {
                                                              TAG: /* String_literal */11,
                                                              _0: "but is used with type",
                                                              _1: /* End_of_format */0
                                                            },
                                                            _1: "but is used with type"
                                                          });
                                                    }));
                                    case /* Virtual_class */10 :
                                        const vals = param$1._3;
                                        const mets = param$1._2;
                                        const imm = param$1._1;
                                        const cl = param$1._0;
                                        const print_mets = function (ppf, mets) {
                                          Stdlib__List.iter((function (met) {
                                                  Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                                                            _0: {
                                                              TAG: /* Formatting_lit */17,
                                                              _0: {
                                                                TAG: /* Break */0,
                                                                _0: "@ ",
                                                                _1: 1,
                                                                _2: 0
                                                              },
                                                              _1: {
                                                                TAG: /* String */2,
                                                                _0: /* No_padding */0,
                                                                _1: /* End_of_format */0
                                                              }
                                                            },
                                                            _1: "@ %s"
                                                          }), met);
                                                }), mets);
                                        };
                                        const missings = mets ? (
                                            vals ? "methods and variables" : "methods"
                                          ) : "variables";
                                        const print_msg = function (ppf) {
                                          if (imm) {
                                            return Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
                                                            _0: {
                                                              TAG: /* String_literal */11,
                                                              _0: "This object has virtual ",
                                                              _1: {
                                                                TAG: /* String */2,
                                                                _0: /* No_padding */0,
                                                                _1: /* End_of_format */0
                                                              }
                                                            },
                                                            _1: "This object has virtual %s"
                                                          }), missings);
                                          } else if (cl) {
                                            return Stdlib__Format.fprintf(ppf)(/* Format */{
                                                        _0: {
                                                          TAG: /* String_literal */11,
                                                          _0: "This class should be virtual",
                                                          _1: /* End_of_format */0
                                                        },
                                                        _1: "This class should be virtual"
                                                      });
                                          } else {
                                            return Stdlib__Format.fprintf(ppf)(/* Format */{
                                                        _0: {
                                                          TAG: /* String_literal */11,
                                                          _0: "This class type should be virtual",
                                                          _1: /* End_of_format */0
                                                        },
                                                        _1: "This class type should be virtual"
                                                      });
                                          }
                                        };
                                        return Curry._4(Stdlib__Format.fprintf(param)(/* Format */{
                                                        _0: {
                                                          TAG: /* Formatting_gen */18,
                                                          _0: {
                                                            TAG: /* Open_box */1,
                                                            _0: /* Format */{
                                                              _0: /* End_of_format */0,
                                                              _1: ""
                                                            }
                                                          },
                                                          _1: {
                                                            TAG: /* Theta */16,
                                                            _0: {
                                                              TAG: /* Char_literal */12,
                                                              _0: /* '.' */46,
                                                              _1: {
                                                                TAG: /* Formatting_lit */17,
                                                                _0: {
                                                                  TAG: /* Break */0,
                                                                  _0: "@ ",
                                                                  _1: 1,
                                                                  _2: 0
                                                                },
                                                                _1: {
                                                                  TAG: /* Formatting_gen */18,
                                                                  _0: {
                                                                    TAG: /* Open_box */1,
                                                                    _0: /* Format */{
                                                                      _0: {
                                                                        TAG: /* String_literal */11,
                                                                        _0: "<2>",
                                                                        _1: /* End_of_format */0
                                                                      },
                                                                      _1: "<2>"
                                                                    }
                                                                  },
                                                                  _1: {
                                                                    TAG: /* String_literal */11,
                                                                    _0: "The following ",
                                                                    _1: {
                                                                      TAG: /* String */2,
                                                                      _0: /* No_padding */0,
                                                                      _1: {
                                                                        TAG: /* String_literal */11,
                                                                        _0: " are undefined :",
                                                                        _1: {
                                                                          TAG: /* Alpha */15,
                                                                          _0: {
                                                                            TAG: /* Formatting_lit */17,
                                                                            _0: /* Close_box */0,
                                                                            _1: {
                                                                              TAG: /* Formatting_lit */17,
                                                                              _0: /* Close_box */0,
                                                                              _1: /* End_of_format */0
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        },
                                                        _1: "@[%t.@ @[<2>The following %s are undefined :%a@]@]"
                                                      }), print_msg, missings, print_mets, Stdlib.$at(mets, vals));
                                    case /* Parameter_arity_mismatch */11 :
                                        return Curry._4(Stdlib__Format.fprintf(param)(/* Format */{
                                                        _0: {
                                                          TAG: /* Formatting_gen */18,
                                                          _0: {
                                                            TAG: /* Open_box */1,
                                                            _0: /* Format */{
                                                              _0: /* End_of_format */0,
                                                              _1: ""
                                                            }
                                                          },
                                                          _1: {
                                                            TAG: /* String_literal */11,
                                                            _0: "The class constructor ",
                                                            _1: {
                                                              TAG: /* Alpha */15,
                                                              _0: {
                                                                TAG: /* Formatting_lit */17,
                                                                _0: {
                                                                  TAG: /* Break */0,
                                                                  _0: "@ ",
                                                                  _1: 1,
                                                                  _2: 0
                                                                },
                                                                _1: {
                                                                  TAG: /* String_literal */11,
                                                                  _0: "expects ",
                                                                  _1: {
                                                                    TAG: /* Int */4,
                                                                    _0: /* Int_i */3,
                                                                    _1: /* No_padding */0,
                                                                    _2: /* No_precision */0,
                                                                    _3: {
                                                                      TAG: /* String_literal */11,
                                                                      _0: " type argument(s),",
                                                                      _1: {
                                                                        TAG: /* Formatting_lit */17,
                                                                        _0: {
                                                                          TAG: /* Break */0,
                                                                          _0: "@ ",
                                                                          _1: 1,
                                                                          _2: 0
                                                                        },
                                                                        _1: {
                                                                          TAG: /* String_literal */11,
                                                                          _0: "but is here applied to ",
                                                                          _1: {
                                                                            TAG: /* Int */4,
                                                                            _0: /* Int_i */3,
                                                                            _1: /* No_padding */0,
                                                                            _2: /* No_precision */0,
                                                                            _3: {
                                                                              TAG: /* String_literal */11,
                                                                              _0: " type argument(s)",
                                                                              _1: {
                                                                                TAG: /* Formatting_lit */17,
                                                                                _0: /* Close_box */0,
                                                                                _1: /* End_of_format */0
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        },
                                                        _1: "@[The class constructor %a@ expects %i type argument(s),@ but is here applied to %i type argument(s)@]"
                                                      }), longident, param$1._0, param$1._1, param$1._2);
                                    case /* Parameter_mismatch */12 :
                                        return report_unification_error(param, env, undefined, param$1._0, (function (ppf) {
                                                      Stdlib__Format.fprintf(ppf)(/* Format */{
                                                            _0: {
                                                              TAG: /* String_literal */11,
                                                              _0: "The type parameter",
                                                              _1: /* End_of_format */0
                                                            },
                                                            _1: "The type parameter"
                                                          });
                                                    }), (function (ppf) {
                                                      Stdlib__Format.fprintf(ppf)(/* Format */{
                                                            _0: {
                                                              TAG: /* String_literal */11,
                                                              _0: "does not meet its constraint: it should be",
                                                              _1: /* End_of_format */0
                                                            },
                                                            _1: "does not meet its constraint: it should be"
                                                          });
                                                    }));
                                    case /* Bad_parameters */13 :
                                        const cstrs = param$1._2;
                                        const params = param$1._1;
                                        reset_and_mark_loops_list({
                                              hd: params,
                                              tl: {
                                                hd: cstrs,
                                                tl: /* [] */0
                                              }
                                            });
                                        return Curry._6(Stdlib__Format.fprintf(param)(/* Format */{
                                                        _0: {
                                                          TAG: /* Formatting_gen */18,
                                                          _0: {
                                                            TAG: /* Open_box */1,
                                                            _0: /* Format */{
                                                              _0: /* End_of_format */0,
                                                              _1: ""
                                                            }
                                                          },
                                                          _1: {
                                                            TAG: /* String_literal */11,
                                                            _0: "The abbreviation ",
                                                            _1: {
                                                              TAG: /* Alpha */15,
                                                              _0: {
                                                                TAG: /* Formatting_lit */17,
                                                                _0: {
                                                                  TAG: /* Break */0,
                                                                  _0: "@ ",
                                                                  _1: 1,
                                                                  _2: 0
                                                                },
                                                                _1: {
                                                                  TAG: /* String_literal */11,
                                                                  _0: "is used with parameters",
                                                                  _1: {
                                                                    TAG: /* Formatting_lit */17,
                                                                    _0: {
                                                                      TAG: /* Break */0,
                                                                      _0: "@ ",
                                                                      _1: 1,
                                                                      _2: 0
                                                                    },
                                                                    _1: {
                                                                      TAG: /* Alpha */15,
                                                                      _0: {
                                                                        TAG: /* Formatting_lit */17,
                                                                        _0: {
                                                                          TAG: /* Break */0,
                                                                          _0: "@ ",
                                                                          _1: 1,
                                                                          _2: 0
                                                                        },
                                                                        _1: {
                                                                          TAG: /* String_literal */11,
                                                                          _0: "wich are incompatible with constraints",
                                                                          _1: {
                                                                            TAG: /* Formatting_lit */17,
                                                                            _0: {
                                                                              TAG: /* Break */0,
                                                                              _0: "@ ",
                                                                              _1: 1,
                                                                              _2: 0
                                                                            },
                                                                            _1: {
                                                                              TAG: /* Alpha */15,
                                                                              _0: {
                                                                                TAG: /* Formatting_lit */17,
                                                                                _0: /* Close_box */0,
                                                                                _1: /* End_of_format */0
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        },
                                                        _1: "@[The abbreviation %a@ is used with parameters@ %a@ wich are incompatible with constraints@ %a@]"
                                                      }), ident$3, param$1._0, type_expr$1, params, type_expr$1, cstrs);
                                    case /* Class_match_failure */14 :
                                        return report_error$3(param, param$1._0);
                                    case /* Unbound_val */15 :
                                        return Curry._1(Stdlib__Format.fprintf(param)(/* Format */{
                                                        _0: {
                                                          TAG: /* String_literal */11,
                                                          _0: "Unbound instance variable ",
                                                          _1: {
                                                            TAG: /* String */2,
                                                            _0: /* No_padding */0,
                                                            _1: /* End_of_format */0
                                                          }
                                                        },
                                                        _1: "Unbound instance variable %s"
                                                      }), param$1._0);
                                    case /* Unbound_type_var */16 :
                                        const print_common = function (ppf, kind, ty0, real, lab, ty) {
                                          const ty1 = real ? ty0 : newty2(100000000, {
                                                  TAG: /* Tobject */4,
                                                  _0: ty0,
                                                  _1: {
                                                    contents: undefined
                                                  }
                                                });
                                          mark_loops(ty1);
                                          Curry._6(Stdlib__Format.fprintf(ppf)(/* Format */{
                                                    _0: {
                                                      TAG: /* String_literal */11,
                                                      _0: "The ",
                                                      _1: {
                                                        TAG: /* String */2,
                                                        _0: /* No_padding */0,
                                                        _1: {
                                                          TAG: /* Char_literal */12,
                                                          _0: /* ' ' */32,
                                                          _1: {
                                                            TAG: /* String */2,
                                                            _0: /* No_padding */0,
                                                            _1: {
                                                              TAG: /* Formatting_lit */17,
                                                              _0: {
                                                                TAG: /* Break */0,
                                                                _0: "@ ",
                                                                _1: 1,
                                                                _2: 0
                                                              },
                                                              _1: {
                                                                TAG: /* String_literal */11,
                                                                _0: "has type",
                                                                _1: {
                                                                  TAG: /* Formatting_lit */17,
                                                                  _0: {
                                                                    TAG: /* Break */0,
                                                                    _0: "@;<1 2>",
                                                                    _1: 1,
                                                                    _2: 2
                                                                  },
                                                                  _1: {
                                                                    TAG: /* Alpha */15,
                                                                    _0: {
                                                                      TAG: /* Formatting_lit */17,
                                                                      _0: {
                                                                        TAG: /* Break */0,
                                                                        _0: "@ ",
                                                                        _1: 1,
                                                                        _2: 0
                                                                      },
                                                                      _1: {
                                                                        TAG: /* String_literal */11,
                                                                        _0: "where",
                                                                        _1: {
                                                                          TAG: /* Formatting_lit */17,
                                                                          _0: {
                                                                            TAG: /* Break */0,
                                                                            _0: "@ ",
                                                                            _1: 1,
                                                                            _2: 0
                                                                          },
                                                                          _1: {
                                                                            TAG: /* Alpha */15,
                                                                            _0: {
                                                                              TAG: /* Formatting_lit */17,
                                                                              _0: {
                                                                                TAG: /* Break */0,
                                                                                _0: "@ ",
                                                                                _1: 1,
                                                                                _2: 0
                                                                              },
                                                                              _1: {
                                                                                TAG: /* String_literal */11,
                                                                                _0: "is unbound",
                                                                                _1: /* End_of_format */0
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    },
                                                    _1: "The %s %s@ has type@;<1 2>%a@ where@ %a@ is unbound"
                                                  }), kind, lab, type_expr$1, ty, type_expr$1, ty0);
                                        };
                                        const print_reason = function (ppf, param) {
                                          if (param.TAG === /* CC_Method */0) {
                                            return print_common(ppf, "method", param._0, param._1, param._2, param._3);
                                          } else {
                                            return print_common(ppf, "instance variable", param._0, param._1, param._2, param._3);
                                          }
                                        };
                                        reset(undefined);
                                        return Curry._3(Stdlib__Format.fprintf(param)(/* Format */{
                                                        _0: {
                                                          TAG: /* Formatting_gen */18,
                                                          _0: {
                                                            TAG: /* Open_box */1,
                                                            _0: /* Format */{
                                                              _0: {
                                                                TAG: /* String_literal */11,
                                                                _0: "<v>",
                                                                _1: /* End_of_format */0
                                                              },
                                                              _1: "<v>"
                                                            }
                                                          },
                                                          _1: {
                                                            TAG: /* Formatting_gen */18,
                                                            _0: {
                                                              TAG: /* Open_box */1,
                                                              _0: /* Format */{
                                                                _0: /* End_of_format */0,
                                                                _1: ""
                                                              }
                                                            },
                                                            _1: {
                                                              TAG: /* String_literal */11,
                                                              _0: "Some type variables are unbound in this type:",
                                                              _1: {
                                                                TAG: /* Formatting_lit */17,
                                                                _0: {
                                                                  TAG: /* Break */0,
                                                                  _0: "@;<1 2>",
                                                                  _1: 1,
                                                                  _2: 2
                                                                },
                                                                _1: {
                                                                  TAG: /* Theta */16,
                                                                  _0: {
                                                                    TAG: /* Formatting_lit */17,
                                                                    _0: /* Close_box */0,
                                                                    _1: {
                                                                      TAG: /* Formatting_lit */17,
                                                                      _0: {
                                                                        TAG: /* Break */0,
                                                                        _0: "@ ",
                                                                        _1: 1,
                                                                        _2: 0
                                                                      },
                                                                      _1: {
                                                                        TAG: /* Formatting_gen */18,
                                                                        _0: {
                                                                          TAG: /* Open_box */1,
                                                                          _0: /* Format */{
                                                                            _0: /* End_of_format */0,
                                                                            _1: ""
                                                                          }
                                                                        },
                                                                        _1: {
                                                                          TAG: /* Alpha */15,
                                                                          _0: {
                                                                            TAG: /* Formatting_lit */17,
                                                                            _0: /* Close_box */0,
                                                                            _1: {
                                                                              TAG: /* Formatting_lit */17,
                                                                              _0: /* Close_box */0,
                                                                              _1: /* End_of_format */0
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        },
                                                        _1: "@[<v>@[Some type variables are unbound in this type:@;<1 2>%t@]@ @[%a@]@]"
                                                      }), param$1._0, print_reason, param$1._1);
                                    case /* Make_nongen_seltype */17 :
                                        return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                        _0: {
                                                          TAG: /* Formatting_gen */18,
                                                          _0: {
                                                            TAG: /* Open_box */1,
                                                            _0: /* Format */{
                                                              _0: {
                                                                TAG: /* String_literal */11,
                                                                _0: "<v>",
                                                                _1: /* End_of_format */0
                                                              },
                                                              _1: "<v>"
                                                            }
                                                          },
                                                          _1: {
                                                            TAG: /* Formatting_gen */18,
                                                            _0: {
                                                              TAG: /* Open_box */1,
                                                              _0: /* Format */{
                                                                _0: /* End_of_format */0,
                                                                _1: ""
                                                              }
                                                            },
                                                            _1: {
                                                              TAG: /* String_literal */11,
                                                              _0: "Self type should not occur in the non-generic type",
                                                              _1: {
                                                                TAG: /* Formatting_lit */17,
                                                                _0: {
                                                                  TAG: /* Break */0,
                                                                  _0: "@;<1 2>",
                                                                  _1: 1,
                                                                  _2: 2
                                                                },
                                                                _1: {
                                                                  TAG: /* Alpha */15,
                                                                  _0: {
                                                                    TAG: /* Formatting_lit */17,
                                                                    _0: /* Close_box */0,
                                                                    _1: {
                                                                      TAG: /* Formatting_lit */17,
                                                                      _0: {
                                                                        TAG: /* Break */0,
                                                                        _0: "@,",
                                                                        _1: 0,
                                                                        _2: 0
                                                                      },
                                                                      _1: {
                                                                        TAG: /* String_literal */11,
                                                                        _0: "It would escape the scope of its class",
                                                                        _1: {
                                                                          TAG: /* Formatting_lit */17,
                                                                          _0: /* Close_box */0,
                                                                          _1: /* End_of_format */0
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        },
                                                        _1: "@[<v>@[Self type should not occur in the non-generic type@;<1 2>%a@]@,It would escape the scope of its class@]"
                                                      }), type_scheme, param$1._0);
                                    case /* Non_generalizable_class */18 :
                                        const id = param$1._0;
                                        return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                        _0: {
                                                          TAG: /* Formatting_gen */18,
                                                          _0: {
                                                            TAG: /* Open_box */1,
                                                            _0: /* Format */{
                                                              _0: /* End_of_format */0,
                                                              _1: ""
                                                            }
                                                          },
                                                          _1: {
                                                            TAG: /* String_literal */11,
                                                            _0: "The type of this class,",
                                                            _1: {
                                                              TAG: /* Formatting_lit */17,
                                                              _0: {
                                                                TAG: /* Break */0,
                                                                _0: "@ ",
                                                                _1: 1,
                                                                _2: 0
                                                              },
                                                              _1: {
                                                                TAG: /* Alpha */15,
                                                                _0: {
                                                                  TAG: /* Char_literal */12,
                                                                  _0: /* ',' */44,
                                                                  _1: {
                                                                    TAG: /* Formatting_lit */17,
                                                                    _0: {
                                                                      TAG: /* Break */0,
                                                                      _0: "@ ",
                                                                      _1: 1,
                                                                      _2: 0
                                                                    },
                                                                    _1: {
                                                                      TAG: /* String_literal */11,
                                                                      _0: "contains type variables that cannot be generalized",
                                                                      _1: {
                                                                        TAG: /* Formatting_lit */17,
                                                                        _0: /* Close_box */0,
                                                                        _1: /* End_of_format */0
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        },
                                                        _1: "@[The type of this class,@ %a,@ contains type variables that cannot be generalized@]"
                                                      }), (function (param, param$1) {
                                                      return class_declaration$1(id, param, param$1);
                                                    }), param$1._1);
                                    case /* Cannot_coerce_self */19 :
                                        return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                        _0: {
                                                          TAG: /* Formatting_gen */18,
                                                          _0: {
                                                            TAG: /* Open_box */1,
                                                            _0: /* Format */{
                                                              _0: /* End_of_format */0,
                                                              _1: ""
                                                            }
                                                          },
                                                          _1: {
                                                            TAG: /* String_literal */11,
                                                            _0: "The type of self cannot be coerced to",
                                                            _1: {
                                                              TAG: /* Formatting_lit */17,
                                                              _0: {
                                                                TAG: /* Break */0,
                                                                _0: "@ ",
                                                                _1: 1,
                                                                _2: 0
                                                              },
                                                              _1: {
                                                                TAG: /* String_literal */11,
                                                                _0: "the type of the current class:",
                                                                _1: {
                                                                  TAG: /* Formatting_lit */17,
                                                                  _0: {
                                                                    TAG: /* Break */0,
                                                                    _0: "@ ",
                                                                    _1: 1,
                                                                    _2: 0
                                                                  },
                                                                  _1: {
                                                                    TAG: /* Alpha */15,
                                                                    _0: {
                                                                      TAG: /* Char_literal */12,
                                                                      _0: /* '.' */46,
                                                                      _1: {
                                                                        TAG: /* Formatting_lit */17,
                                                                        _0: /* Flush_newline */4,
                                                                        _1: {
                                                                          TAG: /* String_literal */11,
                                                                          _0: "Some occurrences are contravariant",
                                                                          _1: {
                                                                            TAG: /* Formatting_lit */17,
                                                                            _0: /* Close_box */0,
                                                                            _1: /* End_of_format */0
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        },
                                                        _1: "@[The type of self cannot be coerced to@ the type of the current class:@ %a.@.Some occurrences are contravariant@]"
                                                      }), type_scheme, param$1._0);
                                    case /* Non_collapsable_conjunction */20 :
                                        const id$1 = param$1._0;
                                        Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                  _0: {
                                                    TAG: /* Formatting_gen */18,
                                                    _0: {
                                                      TAG: /* Open_box */1,
                                                      _0: /* Format */{
                                                        _0: /* End_of_format */0,
                                                        _1: ""
                                                      }
                                                    },
                                                    _1: {
                                                      TAG: /* String_literal */11,
                                                      _0: "The type of this class,",
                                                      _1: {
                                                        TAG: /* Formatting_lit */17,
                                                        _0: {
                                                          TAG: /* Break */0,
                                                          _0: "@ ",
                                                          _1: 1,
                                                          _2: 0
                                                        },
                                                        _1: {
                                                          TAG: /* Alpha */15,
                                                          _0: {
                                                            TAG: /* Char_literal */12,
                                                            _0: /* ',' */44,
                                                            _1: {
                                                              TAG: /* Formatting_lit */17,
                                                              _0: {
                                                                TAG: /* Break */0,
                                                                _0: "@ ",
                                                                _1: 1,
                                                                _2: 0
                                                              },
                                                              _1: {
                                                                TAG: /* String_literal */11,
                                                                _0: "contains non-collapsible conjunctive types in constraints",
                                                                _1: {
                                                                  TAG: /* Formatting_lit */17,
                                                                  _0: /* Close_box */0,
                                                                  _1: /* End_of_format */0
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  },
                                                  _1: "@[The type of this class,@ %a,@ contains non-collapsible conjunctive types in constraints@]"
                                                }), (function (param, param$1) {
                                                return class_declaration$1(id$1, param, param$1);
                                              }), param$1._1);
                                        return report_unification_error(param, env, undefined, param$1._2, (function (ppf) {
                                                      Stdlib__Format.fprintf(ppf)(/* Format */{
                                                            _0: {
                                                              TAG: /* String_literal */11,
                                                              _0: "Type",
                                                              _1: /* End_of_format */0
                                                            },
                                                            _1: "Type"
                                                          });
                                                    }), (function (ppf) {
                                                      Stdlib__Format.fprintf(ppf)(/* Format */{
                                                            _0: {
                                                              TAG: /* String_literal */11,
                                                              _0: "is not compatible with type",
                                                              _1: /* End_of_format */0
                                                            },
                                                            _1: "is not compatible with type"
                                                          });
                                                    }));
                                    case /* Final_self_clash */21 :
                                        return report_unification_error(param, env, undefined, param$1._0, (function (ppf) {
                                                      Stdlib__Format.fprintf(ppf)(/* Format */{
                                                            _0: {
                                                              TAG: /* String_literal */11,
                                                              _0: "This object is expected to have type",
                                                              _1: /* End_of_format */0
                                                            },
                                                            _1: "This object is expected to have type"
                                                          });
                                                    }), (function (ppf) {
                                                      Stdlib__Format.fprintf(ppf)(/* Format */{
                                                            _0: {
                                                              TAG: /* String_literal */11,
                                                              _0: "but actually has type",
                                                              _1: /* End_of_format */0
                                                            },
                                                            _1: "but actually has type"
                                                          });
                                                    }));
                                    case /* Mutability_mismatch */22 :
                                        const match = param$1._1 === /* Immutable */0 ? [
                                            "mutable",
                                            "immutable"
                                          ] : [
                                            "immutable",
                                            "mutable"
                                          ];
                                        return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                        _0: {
                                                          TAG: /* Formatting_gen */18,
                                                          _0: {
                                                            TAG: /* Open_box */1,
                                                            _0: /* Format */{
                                                              _0: /* End_of_format */0,
                                                              _1: ""
                                                            }
                                                          },
                                                          _1: {
                                                            TAG: /* String_literal */11,
                                                            _0: "The instance variable is ",
                                                            _1: {
                                                              TAG: /* String */2,
                                                              _0: /* No_padding */0,
                                                              _1: {
                                                                TAG: /* Char_literal */12,
                                                                _0: /* ';' */59,
                                                                _1: {
                                                                  TAG: /* Formatting_lit */17,
                                                                  _0: {
                                                                    TAG: /* Break */0,
                                                                    _0: "@ ",
                                                                    _1: 1,
                                                                    _2: 0
                                                                  },
                                                                  _1: {
                                                                    TAG: /* String_literal */11,
                                                                    _0: "it cannot be redefined as ",
                                                                    _1: {
                                                                      TAG: /* String */2,
                                                                      _0: /* No_padding */0,
                                                                      _1: {
                                                                        TAG: /* Formatting_lit */17,
                                                                        _0: /* Close_box */0,
                                                                        _1: /* End_of_format */0
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        },
                                                        _1: "@[The instance variable is %s;@ it cannot be redefined as %s@]"
                                                      }), match[0], match[1]);
                                    case /* No_overriding */23 :
                                        if (param$1._1 === "") {
                                          return Curry._1(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* Formatting_gen */18,
                                                            _0: {
                                                              TAG: /* Open_box */1,
                                                              _0: /* Format */{
                                                                _0: /* End_of_format */0,
                                                                _1: ""
                                                              }
                                                            },
                                                            _1: {
                                                              TAG: /* String_literal */11,
                                                              _0: "This inheritance does not override any method",
                                                              _1: {
                                                                TAG: /* Formatting_lit */17,
                                                                _0: {
                                                                  TAG: /* Break */0,
                                                                  _0: "@ ",
                                                                  _1: 1,
                                                                  _2: 0
                                                                },
                                                                _1: {
                                                                  TAG: /* String */2,
                                                                  _0: /* No_padding */0,
                                                                  _1: {
                                                                    TAG: /* Formatting_lit */17,
                                                                    _0: /* Close_box */0,
                                                                    _1: /* End_of_format */0
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          },
                                                          _1: "@[This inheritance does not override any method@ %s@]"
                                                        }), "instance variable");
                                        } else {
                                          return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* Formatting_gen */18,
                                                            _0: {
                                                              TAG: /* Open_box */1,
                                                              _0: /* Format */{
                                                                _0: /* End_of_format */0,
                                                                _1: ""
                                                              }
                                                            },
                                                            _1: {
                                                              TAG: /* String_literal */11,
                                                              _0: "The ",
                                                              _1: {
                                                                TAG: /* String */2,
                                                                _0: /* No_padding */0,
                                                                _1: {
                                                                  TAG: /* String_literal */11,
                                                                  _0: " `",
                                                                  _1: {
                                                                    TAG: /* String */2,
                                                                    _0: /* No_padding */0,
                                                                    _1: {
                                                                      TAG: /* Char_literal */12,
                                                                      _0: /* '\'' */39,
                                                                      _1: {
                                                                        TAG: /* Formatting_lit */17,
                                                                        _0: {
                                                                          TAG: /* Break */0,
                                                                          _0: "@ ",
                                                                          _1: 1,
                                                                          _2: 0
                                                                        },
                                                                        _1: {
                                                                          TAG: /* String_literal */11,
                                                                          _0: "has no previous definition",
                                                                          _1: {
                                                                            TAG: /* Formatting_lit */17,
                                                                            _0: /* Close_box */0,
                                                                            _1: /* End_of_format */0
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          },
                                                          _1: "@[The %s `%s'@ has no previous definition@]"
                                                        }), param$1._0, param$1._1);
                                        }
                                    case /* Duplicate */24 :
                                        return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                        _0: {
                                                          TAG: /* Formatting_gen */18,
                                                          _0: {
                                                            TAG: /* Open_box */1,
                                                            _0: /* Format */{
                                                              _0: /* End_of_format */0,
                                                              _1: ""
                                                            }
                                                          },
                                                          _1: {
                                                            TAG: /* String_literal */11,
                                                            _0: "The ",
                                                            _1: {
                                                              TAG: /* String */2,
                                                              _0: /* No_padding */0,
                                                              _1: {
                                                                TAG: /* String_literal */11,
                                                                _0: " `",
                                                                _1: {
                                                                  TAG: /* String */2,
                                                                  _0: /* No_padding */0,
                                                                  _1: {
                                                                    TAG: /* Char_literal */12,
                                                                    _0: /* '\'' */39,
                                                                    _1: {
                                                                      TAG: /* Formatting_lit */17,
                                                                      _0: {
                                                                        TAG: /* Break */0,
                                                                        _0: "@ ",
                                                                        _1: 1,
                                                                        _2: 0
                                                                      },
                                                                      _1: {
                                                                        TAG: /* String_literal */11,
                                                                        _0: "has multiple definitions in this object",
                                                                        _1: {
                                                                          TAG: /* Formatting_lit */17,
                                                                          _0: /* Close_box */0,
                                                                          _1: /* End_of_format */0
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        },
                                                        _1: "@[The %s `%s'@ has multiple definitions in this object@]"
                                                      }), param$1._0, param$1._1);
                                    
                                  }
                                }));
                  }), err._3);
    });

const $$Error$10 = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Typemod.Error");

const Error_forward$3 = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Typemod.Error_forward");

function fst3(param) {
  return param[0];
}

function path_concat(head, p) {
  switch (p.TAG | 0) {
    case /* Pident */0 :
        return {
                TAG: /* Pdot */1,
                _0: {
                  TAG: /* Pident */0,
                  _0: head
                },
                _1: p._0.name,
                _2: 0
              };
    case /* Pdot */1 :
        return {
                TAG: /* Pdot */1,
                _0: path_concat(head, p._0),
                _1: p._1,
                _2: p._2
              };
    case /* Papply */2 :
        throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                  MEL_EXN_ID: "Assert_failure",
                  _1: [
                    "jscomp/test/ocaml_typedtree_test.ml",
                    50016,
                    16
                  ]
                });
    
  }
}

function extract_sig(env, loc, mty) {
  const sg = scrape_alias(env, undefined, mty);
  if (sg.TAG === /* Mty_signature */1) {
    return sg._0;
  }
  throw new Caml_js_exceptions.MelangeError($$Error$10, {
            MEL_EXN_ID: $$Error$10,
            _1: loc,
            _2: env,
            _3: /* Signature_expected */0
          });
}

function extract_sig_open(env, loc, mty) {
  const sg = scrape_alias(env, undefined, mty);
  if (sg.TAG === /* Mty_signature */1) {
    return sg._0;
  }
  throw new Caml_js_exceptions.MelangeError($$Error$10, {
            MEL_EXN_ID: $$Error$10,
            _1: loc,
            _2: env,
            _3: {
              TAG: /* Structure_expected */3,
              _0: mty
            }
          });
}

function type_open_(toplevel, ovf, env, loc, lid) {
  const match = find_module$1(env, lid.loc, lid.txt);
  const path = match[0];
  const sg = extract_sig_open(env, lid.loc, match[1].md_type);
  return [
          path,
          open_signature$1(loc, toplevel, ovf, path, sg, env)
        ];
}

function type_open$1(toplevel, env, sod) {
  const match = type_open_(toplevel, sod.popen_override, env, sod.popen_loc, sod.popen_lid);
  const path = match[0];
  const od_open_txt = sod.popen_lid;
  const od_open_override = sod.popen_override;
  const od_open_loc = sod.popen_loc;
  const od_open_attributes = sod.popen_attributes;
  const od = {
    open_path: path,
    open_txt: od_open_txt,
    open_override: od_open_override,
    open_loc: od_open_loc,
    open_attributes: od_open_attributes
  };
  return [
          path,
          match[1],
          od
        ];
}

const type_module_type_of_fwd = {
  contents: (function (env, m) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/ocaml_typedtree_test.ml",
                  50061,
                  22
                ]
              });
    })
};

function add_rec_types(_env, _param) {
  while(true) {
    const param = _param;
    const env = _env;
    if (!param) {
      return env;
    }
    const match = param.hd;
    if (match.TAG !== /* Sig_type */1) {
      return env;
    }
    if (match._2 < 2) {
      return env;
    }
    _param = param.tl;
    _env = add_type$1(true, match._0, match._1, env);
    continue ;
  };
}

function check_type_decl(env, loc, id, row_id, newdecl, decl, rs, rem) {
  const env$1 = add_type$1(true, id, newdecl, env);
  const env$2 = row_id !== undefined ? add_type$1(true, row_id, newdecl, env$1) : env$1;
  const env$3 = rs === /* Trec_not */0 ? env$2 : add_rec_types(env$2, rem);
  type_declarations$3(env$3, id, newdecl, decl);
  check_coherence(env$3, loc, id, newdecl);
}

function update_rec_next(rs, rem) {
  if (rs >= 2) {
    return rem;
  }
  if (!rem) {
    return rem;
  }
  const match = rem.hd;
  switch (match.TAG | 0) {
    case /* Sig_type */1 :
        if (match._2 >= 2) {
          return {
                  hd: {
                    TAG: /* Sig_type */1,
                    _0: match._0,
                    _1: match._1,
                    _2: rs
                  },
                  tl: rem.tl
                };
        } else {
          return rem;
        }
    case /* Sig_module */3 :
        if (match._2 >= 2) {
          return {
                  hd: {
                    TAG: /* Sig_module */3,
                    _0: match._0,
                    _1: match._1,
                    _2: rs
                  },
                  tl: rem.tl
                };
        } else {
          return rem;
        }
    default:
      return rem;
  }
}

function merge_constraint(initial_env, loc, sg, constr) {
  let lid;
  switch (constr.TAG | 0) {
    case /* Pwith_type */0 :
    case /* Pwith_module */1 :
        lid = constr._0;
        break;
    case /* Pwith_typesubst */2 :
        const s = constr._0.ptype_name;
        lid = {
          txt: {
            TAG: /* Lident */0,
            _0: s.txt
          },
          loc: s.loc
        };
        break;
    case /* Pwith_modsubst */3 :
        const s$1 = constr._0;
        lid = {
          txt: {
            TAG: /* Lident */0,
            _0: s$1.txt
          },
          loc: s$1.loc
        };
        break;
    
  }
  const real_id = {
    contents: undefined
  };
  const merge = function (env, _sg, namelist, _row_id) {
    while(true) {
      const row_id = _row_id;
      const sg = _sg;
      if (sg) {
        const item = sg.hd;
        switch (item.TAG | 0) {
          case /* Sig_type */1 :
              if (namelist && !namelist.tl) {
                const s = namelist.hd;
                const rem = sg.tl;
                const rs = item._2;
                const decl = item._1;
                const id = item._0;
                let exit = 0;
                switch (constr.TAG | 0) {
                  case /* Pwith_type */0 :
                      const sdecl = constr._1;
                      let exit$1 = 0;
                      const match = sdecl.ptype_kind;
                      if (typeof match === "number" && !match) {
                        if (id.name === s && is_fixed_type(sdecl)) {
                          const decl_row_type_params = Stdlib__List.map((function (param) {
                                  return newty2(100000000, {
                                              TAG: /* Tvar */0,
                                              _0: undefined
                                            });
                                }), sdecl.ptype_params);
                          const decl_row_type_arity = Stdlib__List.length(sdecl.ptype_params);
                          const decl_row_type_variance = Stdlib__List.map((function (param) {
                                  let match;
                                  switch (param[1]) {
                                    case /* Covariant */0 :
                                        match = [
                                          true,
                                          false
                                        ];
                                        break;
                                    case /* Contravariant */1 :
                                        match = [
                                          false,
                                          true
                                        ];
                                        break;
                                    case /* Invariant */2 :
                                        match = [
                                          false,
                                          false
                                        ];
                                        break;
                                    
                                  }
                                  let p = !match[1];
                                  let n = !match[0];
                                  let i = false;
                                  return Curry._3(Types_Variance.set, /* May_pos */0, p, Curry._3(Types_Variance.set, /* May_neg */1, n, Curry._3(Types_Variance.set, /* May_weak */2, n, Curry._3(Types_Variance.set, /* Inj */3, i, Types_Variance.$$null))));
                                }), sdecl.ptype_params);
                          const decl_row_type_loc = sdecl.ptype_loc;
                          const decl_row = {
                            type_params: decl_row_type_params,
                            type_arity: decl_row_type_arity,
                            type_kind: /* Type_abstract */0,
                            type_private: /* Private */0,
                            type_manifest: undefined,
                            type_variance: decl_row_type_variance,
                            type_newtype_level: undefined,
                            type_loc: decl_row_type_loc,
                            type_attributes: /* [] */0
                          };
                          const id_row = create(s + "#row");
                          const initial_env$1 = add_type$1(true, id_row, decl_row, initial_env);
                          const tdecl = transl_with_constraint(initial_env$1, id, {
                                TAG: /* Pident */0,
                                _0: id_row
                              }, decl, sdecl);
                          const newdecl = tdecl.typ_type;
                          check_type_decl(env, sdecl.ptype_loc, id, row_id, newdecl, decl, rs, rem);
                          const decl_row_type_params$1 = newdecl.type_params;
                          const decl_row_type_arity$1 = decl_row_type_arity;
                          const decl_row_type_variance$1 = decl_row_type_variance;
                          const decl_row_type_loc$1 = decl_row_type_loc;
                          const decl_row$1 = {
                            type_params: decl_row_type_params$1,
                            type_arity: decl_row_type_arity$1,
                            type_kind: /* Type_abstract */0,
                            type_private: /* Private */0,
                            type_manifest: undefined,
                            type_variance: decl_row_type_variance$1,
                            type_newtype_level: undefined,
                            type_loc: decl_row_type_loc$1,
                            type_attributes: /* [] */0
                          };
                          const rs$p = rs === /* Trec_first */1 ? /* Trec_not */0 : rs;
                          return [
                                  [
                                    {
                                      TAG: /* Pident */0,
                                      _0: id
                                    },
                                    lid,
                                    {
                                      TAG: /* Twith_type */0,
                                      _0: tdecl
                                    }
                                  ],
                                  {
                                    hd: {
                                      TAG: /* Sig_type */1,
                                      _0: id_row,
                                      _1: decl_row$1,
                                      _2: rs$p
                                    },
                                    tl: {
                                      hd: {
                                        TAG: /* Sig_type */1,
                                        _0: id,
                                        _1: newdecl,
                                        _2: rs
                                      },
                                      tl: rem
                                    }
                                  }
                                ];
                        }
                        exit$1 = 3;
                      } else {
                        exit$1 = 3;
                      }
                      if (exit$1 === 3) {
                        if (id.name === s) {
                          const tdecl$1 = transl_with_constraint(initial_env, id, undefined, decl, sdecl);
                          const newdecl$1 = tdecl$1.typ_type;
                          check_type_decl(env, sdecl.ptype_loc, id, row_id, newdecl$1, decl, rs, rem);
                          return [
                                  [
                                    {
                                      TAG: /* Pident */0,
                                      _0: id
                                    },
                                    lid,
                                    {
                                      TAG: /* Twith_type */0,
                                      _0: tdecl$1
                                    }
                                  ],
                                  {
                                    hd: {
                                      TAG: /* Sig_type */1,
                                      _0: id,
                                      _1: newdecl$1,
                                      _2: rs
                                    },
                                    tl: rem
                                  }
                                ];
                        }
                        exit = 2;
                      }
                      break;
                  case /* Pwith_typesubst */2 :
                      exit = 2;
                      break;
                  case /* Pwith_module */1 :
                  case /* Pwith_modsubst */3 :
                      break;
                  
                }
                if (exit === 2) {
                  if (id.name === s + "#row") {
                    _row_id = id;
                    _sg = rem;
                    continue ;
                  }
                  if (constr.TAG !== /* Pwith_type */0) {
                    const sdecl$1 = constr._0;
                    if (id.name === s) {
                      const tdecl$2 = transl_with_constraint(initial_env, id, undefined, decl, sdecl$1);
                      const newdecl$2 = tdecl$2.typ_type;
                      check_type_decl(env, sdecl$1.ptype_loc, id, row_id, newdecl$2, decl, rs, rem);
                      real_id.contents = id;
                      return [
                              [
                                {
                                  TAG: /* Pident */0,
                                  _0: id
                                },
                                lid,
                                {
                                  TAG: /* Twith_typesubst */2,
                                  _0: tdecl$2
                                }
                              ],
                              update_rec_next(rs, rem)
                            ];
                    }
                    
                  }
                  
                }
                
              }
              break;
          case /* Sig_module */3 :
              if (namelist) {
                const s$1 = namelist.hd;
                const rem$1 = sg.tl;
                const rs$1 = item._2;
                const md = item._1;
                const id$1 = item._0;
                let exit$2 = 0;
                if (namelist.tl) {
                  exit$2 = 2;
                } else {
                  switch (constr.TAG | 0) {
                    case /* Pwith_module */1 :
                        const lid$p = constr._1;
                        if (id$1.name === s$1) {
                          const match$1 = find_module$1(initial_env, loc, lid$p.txt);
                          const md$p = match$1[1];
                          const path = match$1[0];
                          const md$p$p_md_type = remove_aliases$1(env, md$p.md_type);
                          const md$p$p_md_attributes = md$p.md_attributes;
                          const md$p$p_md_loc = md$p.md_loc;
                          const md$p$p = {
                            md_type: md$p$p_md_type,
                            md_attributes: md$p$p_md_attributes,
                            md_loc: md$p$p_md_loc
                          };
                          const newmd = strengthen_decl(env, md$p$p, path);
                          modtypes$1(env, newmd.md_type, md.md_type);
                          return [
                                  [
                                    {
                                      TAG: /* Pident */0,
                                      _0: id$1
                                    },
                                    lid,
                                    {
                                      TAG: /* Twith_module */1,
                                      _0: path,
                                      _1: lid$p
                                    }
                                  ],
                                  {
                                    hd: {
                                      TAG: /* Sig_module */3,
                                      _0: id$1,
                                      _1: newmd,
                                      _2: rs$1
                                    },
                                    tl: rem$1
                                  }
                                ];
                        }
                        exit$2 = 2;
                        break;
                    case /* Pwith_type */0 :
                    case /* Pwith_typesubst */2 :
                        exit$2 = 2;
                        break;
                    case /* Pwith_modsubst */3 :
                        const lid$p$1 = constr._1;
                        if (id$1.name === s$1) {
                          const match$2 = find_module$1(initial_env, loc, lid$p$1.txt);
                          const path$1 = match$2[0];
                          const newmd$1 = strengthen_decl(env, match$2[1], path$1);
                          modtypes$1(env, newmd$1.md_type, md.md_type);
                          real_id.contents = id$1;
                          return [
                                  [
                                    {
                                      TAG: /* Pident */0,
                                      _0: id$1
                                    },
                                    lid,
                                    {
                                      TAG: /* Twith_modsubst */3,
                                      _0: path$1,
                                      _1: lid$p$1
                                    }
                                  ],
                                  update_rec_next(rs$1, rem$1)
                                ];
                        }
                        exit$2 = 2;
                        break;
                    
                  }
                }
                if (exit$2 === 2 && id$1.name === s$1) {
                  const match$3 = merge(env, extract_sig(env, loc, md.md_type), namelist.tl, undefined);
                  const match$4 = match$3[0];
                  return [
                          [
                            path_concat(id$1, match$4[0]),
                            lid,
                            match$4[2]
                          ],
                          {
                            hd: {
                              TAG: /* Sig_module */3,
                              _0: id$1,
                              _1: {
                                md_type: {
                                  TAG: /* Mty_signature */1,
                                  _0: match$3[1]
                                },
                                md_attributes: md.md_attributes,
                                md_loc: md.md_loc
                              },
                              _2: rs$1
                            },
                            tl: rem$1
                          }
                        ];
                }
                
              }
              break;
          default:
            
        }
        const match$5 = merge(add_item(item, env), sg.tl, namelist, row_id);
        return [
                match$5[0],
                {
                  hd: item,
                  tl: match$5[1]
                }
              ];
      }
      throw new Caml_js_exceptions.MelangeError($$Error$10, {
                MEL_EXN_ID: $$Error$10,
                _1: loc,
                _2: env,
                _3: {
                  TAG: /* With_no_component */4,
                  _0: lid.txt
                }
              });
    };
  };
  try {
    const names = flat(/* [] */0, lid.txt);
    const match = merge(initial_env, sg, names, undefined);
    const sg$1 = match[1];
    let sg$2;
    if (names && !names.tl) {
      switch (constr.TAG | 0) {
        case /* Pwith_type */0 :
        case /* Pwith_module */1 :
            sg$2 = sg$1;
            break;
        case /* Pwith_typesubst */2 :
            const sdecl = constr._0;
            const id = real_id.contents;
            let id$1;
            if (id !== undefined) {
              id$1 = id;
            } else {
              throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                        MEL_EXN_ID: "Assert_failure",
                        _1: [
                          "jscomp/test/ocaml_typedtree_test.ml",
                          50208,
                          38
                        ]
                      });
            }
            let lid$1;
            try {
              const match$1 = sdecl.ptype_manifest;
              if (match$1 !== undefined) {
                const match$2 = match$1.ptyp_desc;
                if (typeof match$2 === "number") {
                  throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                            MEL_EXN_ID: Stdlib.Exit
                          });
                }
                if (match$2.TAG === /* Ptyp_constr */3) {
                  const stl = match$2._1;
                  if (Stdlib__List.length(stl) === Stdlib__List.length(sdecl.ptype_params)) {
                    Stdlib__List.iter2((function (x, param) {
                            const sx = x.ptyp_desc;
                            if (typeof sx === "number") {
                              throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                        MEL_EXN_ID: Stdlib.Exit
                                      });
                            }
                            if (sx.TAG === /* Ptyp_var */0) {
                              const sy = param[0].ptyp_desc;
                              if (typeof sy === "number") {
                                throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                          MEL_EXN_ID: Stdlib.Exit
                                        });
                              }
                              if (sy.TAG === /* Ptyp_var */0) {
                                if (sx._0 === sy._0) {
                                  return ;
                                }
                                throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                          MEL_EXN_ID: Stdlib.Exit
                                        });
                              }
                              throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                        MEL_EXN_ID: Stdlib.Exit
                                      });
                            } else {
                              throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                                        MEL_EXN_ID: Stdlib.Exit
                                      });
                            }
                          }), stl, sdecl.ptype_params);
                    lid$1 = match$2._0;
                  } else {
                    throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                              MEL_EXN_ID: Stdlib.Exit
                            });
                  }
                } else {
                  throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                            MEL_EXN_ID: Stdlib.Exit
                          });
                }
              } else {
                throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                          MEL_EXN_ID: Stdlib.Exit
                        });
              }
            }
            catch (raw_exn){
              const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn.MEL_EXN_ID === Stdlib.Exit) {
                throw new Caml_js_exceptions.MelangeError($$Error$10, {
                          MEL_EXN_ID: $$Error$10,
                          _1: sdecl.ptype_loc,
                          _2: initial_env,
                          _3: /* With_need_typeconstr */2
                        });
              }
              throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
            }
            let match$3;
            try {
              match$3 = lookup_type$1(lid$1.txt, initial_env);
            }
            catch (raw_exn$1){
              const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
              if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
                throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                          MEL_EXN_ID: "Assert_failure",
                          _1: [
                            "jscomp/test/ocaml_typedtree_test.ml",
                            50225,
                            68
                          ]
                        });
              }
              throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
            }
            const sub = add_type(id$1, match$3[0], identity);
            sg$2 = signature$2(sub, sg$1);
            break;
        case /* Pwith_modsubst */3 :
            const id$2 = real_id.contents;
            let id$3;
            if (id$2 !== undefined) {
              id$3 = id$2;
            } else {
              throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                        MEL_EXN_ID: "Assert_failure",
                        _1: [
                          "jscomp/test/ocaml_typedtree_test.ml",
                          50231,
                          38
                        ]
                      });
            }
            const path = lookup_module$1(undefined, initial_env, loc, constr._1.txt);
            const sub$1 = add_module(id$3, path, identity);
            sg$2 = signature$2(sub$1, sg$1);
            break;
        
      }
    } else {
      sg$2 = sg$1;
    }
    return [
            match[0],
            sg$2
          ];
  }
  catch (raw_explanation){
    const explanation = Caml_js_exceptions.internalToOCamlException(raw_explanation);
    if (explanation.MEL_EXN_ID === $$Error$5) {
      throw new Caml_js_exceptions.MelangeError($$Error$10, {
                MEL_EXN_ID: $$Error$10,
                _1: loc,
                _2: initial_env,
                _3: {
                  TAG: /* With_mismatch */5,
                  _0: lid.txt,
                  _1: explanation._1
                }
              });
    }
    throw new Caml_js_exceptions.MelangeError(explanation.MEL_EXN_ID, explanation);
  }
}

function map_rec(fn, decls, rem) {
  if (decls) {
    return {
            hd: Curry._2(fn, /* Trec_first */1, decls.hd),
            tl: map_end(Curry._1(fn, /* Trec_next */2), decls.tl, rem)
          };
  } else {
    return rem;
  }
}

function map_rec_type(rec_flag, fn, decls, rem) {
  if (!decls) {
    return rem;
  }
  const first = rec_flag ? /* Trec_first */1 : /* Trec_not */0;
  return {
          hd: Curry._2(fn, first, decls.hd),
          tl: map_end(Curry._1(fn, /* Trec_next */2), decls.tl, rem)
        };
}

function map_rec_type_with_row_types(rec_flag, fn, decls, rem) {
  if (!decls) {
    return rem;
  }
  const d1 = decls.hd;
  if (is_row_name(d1.typ_id.name)) {
    return {
            hd: Curry._2(fn, /* Trec_not */0, d1),
            tl: map_rec_type_with_row_types(rec_flag, fn, decls.tl, rem)
          };
  } else {
    return map_rec_type(rec_flag, fn, decls, rem);
  }
}

function rec_flag_of_ptype_declarations(tds) {
  const is_nonrec = Stdlib__List.exists((function (td) {
          return Stdlib__List.exists((function (param) {
                        return param[0].txt === "nonrec";
                      }), td.ptype_attributes);
        }), tds);
  if (is_nonrec) {
    return /* Nonrecursive */0;
  } else {
    return /* Recursive */1;
  }
}

function map_ext(fn, exts, rem) {
  if (exts) {
    return {
            hd: Curry._2(fn, /* Text_first */0, exts.hd),
            tl: map_end(Curry._1(fn, /* Text_next */1), exts.tl, rem)
          };
  } else {
    return rem;
  }
}

function approx_modtype(env, _smty) {
  while(true) {
    const smty = _smty;
    const lid = smty.pmty_desc;
    switch (lid.TAG | 0) {
      case /* Pmty_ident */0 :
          const match = find_modtype$1(env, smty.pmty_loc, lid._0.txt);
          return {
                  TAG: /* Mty_ident */0,
                  _0: match[0]
                };
      case /* Pmty_signature */1 :
          return {
                  TAG: /* Mty_signature */1,
                  _0: approx_sig(env, lid._0)
                };
      case /* Pmty_functor */2 :
          const arg = may_map((function (param) {
                  return approx_modtype(env, param);
                }), lid._1);
          const match$1 = enter_module(true, lid._0.txt, arg !== undefined ? arg : ({
                    TAG: /* Mty_signature */1,
                    _0: /* [] */0
                  }), env);
          const res = approx_modtype(match$1[1], lid._2);
          return {
                  TAG: /* Mty_functor */2,
                  _0: match$1[0],
                  _1: arg,
                  _2: res
                };
      case /* Pmty_with */3 :
          _smty = lid._0;
          continue ;
      case /* Pmty_typeof */4 :
          return Curry._2(type_module_type_of_fwd.contents, env, lid._0)[1];
      case /* Pmty_extension */5 :
          throw new Caml_js_exceptions.MelangeError(Error_forward$3, {
                    MEL_EXN_ID: Error_forward$3,
                    _1: error_of_extension(lid._0)
                  });
      case /* Pmty_alias */6 :
          const path = lookup_module$1(undefined, env, smty.pmty_loc, lid._0.txt);
          return {
                  TAG: /* Mty_alias */3,
                  _0: path
                };
      
    }
  };
}

function approx_module_declaration(env, pmd) {
  return {
          md_type: approx_modtype(env, pmd.pmd_type),
          md_attributes: pmd.pmd_attributes,
          md_loc: pmd.pmd_loc
        };
}

function approx_sig(_env, _ssg) {
  while(true) {
    const ssg = _ssg;
    const env = _env;
    if (!ssg) {
      return /* [] */0;
    }
    const srem = ssg.tl;
    const sdecls = ssg.hd.psig_desc;
    switch (sdecls.TAG | 0) {
      case /* Psig_type */1 :
          const sdecls$1 = sdecls._0;
          const rec_flag = rec_flag_of_ptype_declarations(sdecls$1);
          const decls = approx_type_decl(env, sdecls$1);
          const rem = approx_sig(env, srem);
          return map_rec_type(rec_flag, (function (rs, param) {
                        return {
                                TAG: /* Sig_type */1,
                                _0: param[0],
                                _1: param[1],
                                _2: rs
                              };
                      }), decls, rem);
      case /* Psig_module */4 :
          const pmd = sdecls._0;
          const md = approx_module_declaration(env, pmd);
          const match = enter_module_declaration(undefined, pmd.pmd_name.txt, md, env);
          return {
                  hd: {
                    TAG: /* Sig_module */3,
                    _0: match[0],
                    _1: md,
                    _2: /* Trec_not */0
                  },
                  tl: approx_sig(match[1], srem)
                };
      case /* Psig_recmodule */5 :
          const decls$1 = Stdlib__List.map((function (pmd) {
                  return [
                          create(pmd.pmd_name.txt),
                          approx_module_declaration(env, pmd)
                        ];
                }), sdecls._0);
          const newenv = Stdlib__List.fold_left((function (env, param) {
                  return add_module_declaration(undefined, param[0], param[1], env);
                }), env, decls$1);
          return map_rec((function (rs, param) {
                        return {
                                TAG: /* Sig_module */3,
                                _0: param[0],
                                _1: param[1],
                                _2: rs
                              };
                      }), decls$1, approx_sig(newenv, srem));
      case /* Psig_modtype */6 :
          const d = sdecls._0;
          const info = approx_modtype_info(env, d);
          const match$1 = enter_modtype(d.pmtd_name.txt, info, env);
          return {
                  hd: {
                    TAG: /* Sig_modtype */4,
                    _0: match$1[0],
                    _1: info
                  },
                  tl: approx_sig(match$1[1], srem)
                };
      case /* Psig_open */7 :
          const match$2 = type_open$1(undefined, env, sdecls._0);
          _ssg = srem;
          _env = match$2[1];
          continue ;
      case /* Psig_include */8 :
          const smty = sdecls._0.pincl_mod;
          const mty = approx_modtype(env, smty);
          const sg = signature$2(identity, extract_sig(env, smty.pmty_loc, mty));
          const newenv$1 = add_signature(sg, env);
          return Stdlib.$at(sg, approx_sig(newenv$1, srem));
      case /* Psig_class */9 :
      case /* Psig_class_type */10 :
          break;
      default:
        _ssg = srem;
        continue ;
    }
    const decls$2 = approx_class_declarations(env, sdecls._0);
    const rem$1 = approx_sig(env, srem);
    return Stdlib__List.flatten(map_rec((function (rs, param) {
                      return {
                              hd: {
                                TAG: /* Sig_class_type */6,
                                _0: param[0],
                                _1: param[2],
                                _2: rs
                              },
                              tl: {
                                hd: {
                                  TAG: /* Sig_type */1,
                                  _0: param[3],
                                  _1: param[4],
                                  _2: rs
                                },
                                tl: {
                                  hd: {
                                    TAG: /* Sig_type */1,
                                    _0: param[5],
                                    _1: param[6],
                                    _2: rs
                                  },
                                  tl: /* [] */0
                                }
                              }
                            };
                    }), decls$2, {
                    hd: rem$1,
                    tl: /* [] */0
                  }));
  };
}

function approx_modtype_info(env, sinfo) {
  return {
          mtd_type: may_map((function (param) {
                  return approx_modtype(env, param);
                }), sinfo.pmtd_type),
          mtd_attributes: sinfo.pmtd_attributes,
          mtd_loc: sinfo.pmtd_loc
        };
}

function check_recmod_typedecls(env, sdecls, decls) {
  const recmod_ids = Stdlib__List.map(fst3, decls);
  Stdlib__List.iter2((function (pmd, param) {
          const mty = param[2].mty_type;
          Stdlib__List.iter((function (path) {
                  let loc = pmd.pmd_type.pmty_loc;
                  let decl = find_type_full(path, env)[0];
                  const to_check = function (path) {
                    return Stdlib__List.exists((function (id) {
                                  return isfree(id, path);
                                }), recmod_ids);
                  };
                  check_well_founded_decl(env, loc, path, decl, to_check);
                  check_recursion(env, loc, path, decl, to_check);
                }), type_paths(env, {
                    TAG: /* Pident */0,
                    _0: param[0]
                  }, mty));
        }), sdecls, decls);
}

const compare$8 = Caml.caml_string_compare;

const funarg$7 = {
  compare: compare$8
};

function height$12(param) {
  if (param) {
    return param.h;
  } else {
    return 0;
  }
}

function create$13(l, v, r) {
  const hl = l ? l.h : 0;
  const hr = r ? r.h : 0;
  return /* Node */{
          l: l,
          v: v,
          r: r,
          h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        };
}

function bal$12(l, v, r) {
  const hl = l ? l.h : 0;
  const hr = r ? r.h : 0;
  if (hl > (hr + 2 | 0)) {
    if (l) {
      const lr = l.r;
      const lv = l.v;
      const ll = l.l;
      if (height$12(ll) >= height$12(lr)) {
        return create$13(ll, lv, create$13(lr, v, r));
      }
      if (lr) {
        return create$13(create$13(ll, lv, lr.l), lr.v, create$13(lr.r, v, r));
      }
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
                MEL_EXN_ID: "Invalid_argument",
                _1: "Set.bal"
              });
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Set.bal"
            });
  }
  if (hr <= (hl + 2 | 0)) {
    return /* Node */{
            l: l,
            v: v,
            r: r,
            h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          };
  }
  if (r) {
    const rr = r.r;
    const rv = r.v;
    const rl = r.l;
    if (height$12(rr) >= height$12(rl)) {
      return create$13(create$13(l, v, rl), rv, rr);
    }
    if (rl) {
      return create$13(create$13(l, v, rl.l), rl.v, create$13(rl.r, rv, rr));
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Set.bal"
            });
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Set.bal"
          });
}

function add$14(x, t) {
  if (!t) {
    return /* Node */{
            l: /* Empty */0,
            v: x,
            r: /* Empty */0,
            h: 1
          };
  }
  const r = t.r;
  const v = t.v;
  const l = t.l;
  const c = Curry._2(funarg$7.compare, x, v);
  if (c === 0) {
    return t;
  }
  if (c < 0) {
    const ll = add$14(x, l);
    if (l === ll) {
      return t;
    } else {
      return bal$12(ll, v, r);
    }
  }
  const rr = add$14(x, r);
  if (r === rr) {
    return t;
  } else {
    return bal$12(l, v, rr);
  }
}

function mem$7(x, _param) {
  while(true) {
    const param = _param;
    if (!param) {
      return false;
    }
    const c = Curry._2(funarg$7.compare, x, param.v);
    if (c === 0) {
      return true;
    }
    _param = c < 0 ? param.l : param.r;
    continue ;
  };
}

function check(cl, loc, set_ref, name) {
  if (Curry._2(mem$7, name, set_ref.contents)) {
    throw new Caml_js_exceptions.MelangeError($$Error$10, {
              MEL_EXN_ID: $$Error$10,
              _1: loc,
              _2: empty,
              _3: {
                TAG: /* Repeated_name */6,
                _0: cl,
                _1: name
              }
            });
  }
  set_ref.contents = Curry._2(add$14, name, set_ref.contents);
}

function check_name(cl, set_ref, name) {
  check(cl, name.loc, set_ref, name.txt);
}

function check_sig_item(type_names, module_names, modtype_names, loc, param) {
  switch (param.TAG | 0) {
    case /* Sig_type */1 :
        return check("type", loc, type_names, param._0.name);
    case /* Sig_module */3 :
        return check("module", loc, module_names, param._0.name);
    case /* Sig_modtype */4 :
        return check("module type", loc, modtype_names, param._0.name);
    default:
      return ;
  }
}

function remove_duplicates(val_ids, ext_ids, _param) {
  while(true) {
    const param = _param;
    if (!param) {
      return /* [] */0;
    }
    const f = param.hd;
    switch (f.TAG | 0) {
      case /* Sig_value */0 :
          const id = f._0;
          if (Stdlib__List.exists((function (param) {
                    return equal(id, param);
                  }), val_ids)) {
            _param = param.tl;
            continue ;
          }
          break;
      case /* Sig_typext */2 :
          const id$1 = f._0;
          let exit = 0;
          if (f._2) {
            exit = 2;
          } else {
            const match = param.tl;
            if (match) {
              const match$1 = match.hd;
              if (match$1.TAG === /* Sig_typext */2 && match$1._2 === 1) {
                if (Stdlib__List.exists((function (param) {
                          return equal(id$1, param);
                        }), ext_ids)) {
                  _param = {
                    hd: {
                      TAG: /* Sig_typext */2,
                      _0: match$1._0,
                      _1: match$1._1,
                      _2: /* Text_first */0
                    },
                    tl: match.tl
                  };
                  continue ;
                }
                exit = 2;
              } else {
                exit = 2;
              }
            } else {
              exit = 2;
            }
          }
          if (exit === 2 && Stdlib__List.exists((function (param) {
                    return equal(id$1, param);
                  }), ext_ids)) {
            _param = param.tl;
            continue ;
          }
          break;
      default:
        
    }
    return {
            hd: f,
            tl: remove_duplicates(val_ids, ext_ids, param.tl)
          };
  };
}

function get_values(_param) {
  while(true) {
    const param = _param;
    if (!param) {
      return /* [] */0;
    }
    const f = param.hd;
    if (f.TAG === /* Sig_value */0) {
      return {
              hd: f._0,
              tl: get_values(param.tl)
            };
    }
    _param = param.tl;
    continue ;
  };
}

function get_extension_constructors(_param) {
  while(true) {
    const param = _param;
    if (!param) {
      return /* [] */0;
    }
    const f = param.hd;
    if (f.TAG === /* Sig_typext */2) {
      return {
              hd: f._0,
              tl: get_extension_constructors(param.tl)
            };
    }
    _param = param.tl;
    continue ;
  };
}

function transl_modtype_longident$1(loc, env, lid) {
  return find_modtype$1(env, loc, lid)[0];
}

function transl_module_alias(loc, env, lid) {
  return lookup_module$1(undefined, env, loc, lid);
}

function mkmty$1(desc, typ, env, loc, attrs) {
  const mty = {
    mty_desc: desc,
    mty_type: typ,
    mty_env: env,
    mty_loc: loc,
    mty_attributes: attrs
  };
  add_saved_type({
        TAG: /* Partial_module_type */7,
        _0: mty
      });
  return mty;
}

function mksig$1(desc, env, loc) {
  const sg = {
    sig_desc: desc,
    sig_env: env,
    sig_loc: loc
  };
  add_saved_type({
        TAG: /* Partial_signature_item */6,
        _0: sg
      });
  return sg;
}

function transl_modtype$1(env, smty) {
  const loc = smty.pmty_loc;
  const lid = smty.pmty_desc;
  switch (lid.TAG | 0) {
    case /* Pmty_ident */0 :
        const lid$1 = lid._0;
        const path = transl_modtype_longident$1(loc, env, lid$1.txt);
        return mkmty$1({
                    TAG: /* Tmty_ident */0,
                    _0: path,
                    _1: lid$1
                  }, {
                    TAG: /* Mty_ident */0,
                    _0: path
                  }, env, loc, smty.pmty_attributes);
    case /* Pmty_signature */1 :
        const sg = transl_signature(env, lid._0);
        return mkmty$1({
                    TAG: /* Tmty_signature */1,
                    _0: sg
                  }, {
                    TAG: /* Mty_signature */1,
                    _0: sg.sig_type
                  }, env, loc, smty.pmty_attributes);
    case /* Pmty_functor */2 :
        const param = lid._0;
        const arg = may_map((function (param) {
                return transl_modtype$1(env, param);
              }), lid._1);
        const ty_arg = may_map((function (m) {
                return m.mty_type;
              }), arg);
        const match = enter_module(true, param.txt, ty_arg !== undefined ? ty_arg : ({
                  TAG: /* Mty_signature */1,
                  _0: /* [] */0
                }), env);
        const id = match[0];
        init_def(currentstamp.contents);
        const res = transl_modtype$1(match[1], lid._2);
        return mkmty$1({
                    TAG: /* Tmty_functor */2,
                    _0: id,
                    _1: param,
                    _2: arg,
                    _3: res
                  }, {
                    TAG: /* Mty_functor */2,
                    _0: id,
                    _1: ty_arg,
                    _2: res.mty_type
                  }, env, loc, smty.pmty_attributes);
    case /* Pmty_with */3 :
        const sbody = lid._0;
        const body = transl_modtype$1(env, sbody);
        const init_sg = extract_sig(env, sbody.pmty_loc, body.mty_type);
        const match$1 = Stdlib__List.fold_left((function (param, sdecl) {
                const match = merge_constraint(env, smty.pmty_loc, param[1], sdecl);
                return [
                        {
                          hd: match[0],
                          tl: param[0]
                        },
                        match[1]
                      ];
              }), [
              /* [] */0,
              init_sg
            ], lid._1);
        return mkmty$1({
                    TAG: /* Tmty_with */3,
                    _0: body,
                    _1: Stdlib__List.rev(match$1[0])
                  }, modtype(identity, {
                        TAG: /* Mty_signature */1,
                        _0: match$1[1]
                      }), env, loc, smty.pmty_attributes);
    case /* Pmty_typeof */4 :
        const match$2 = Curry._2(type_module_type_of_fwd.contents, env, lid._0);
        return mkmty$1({
                    TAG: /* Tmty_typeof */4,
                    _0: match$2[0]
                  }, match$2[1], env, loc, smty.pmty_attributes);
    case /* Pmty_extension */5 :
        throw new Caml_js_exceptions.MelangeError(Error_forward$3, {
                  MEL_EXN_ID: Error_forward$3,
                  _1: error_of_extension(lid._0)
                });
    case /* Pmty_alias */6 :
        const lid$2 = lid._0;
        const path$1 = transl_module_alias(loc, env, lid$2.txt);
        return mkmty$1({
                    TAG: /* Tmty_alias */5,
                    _0: path$1,
                    _1: lid$2
                  }, {
                    TAG: /* Mty_alias */3,
                    _0: path$1
                  }, env, loc, smty.pmty_attributes);
    
  }
}

function transl_signature(env, sg) {
  const type_names = {
    contents: /* Empty */0
  };
  const module_names = {
    contents: /* Empty */0
  };
  const modtype_names = {
    contents: /* Empty */0
  };
  const transl_sig = function (env, sg) {
    init_def(currentstamp.contents);
    if (!sg) {
      return [
              /* [] */0,
              /* [] */0,
              env
            ];
    }
    const srem = sg.tl;
    const item = sg.hd;
    const loc = item.psig_loc;
    const sdesc = item.psig_desc;
    switch (sdesc.TAG | 0) {
      case /* Psig_value */0 :
          const match = transl_value_decl(env, item.psig_loc, sdesc._0);
          const tdesc = match[0];
          const match$1 = transl_sig(match[1], srem);
          const rem = match$1[1];
          const partial_arg = tdesc.val_id;
          return [
                  {
                    hd: mksig$1({
                          TAG: /* Tsig_value */0,
                          _0: tdesc
                        }, env, loc),
                    tl: match$1[0]
                  },
                  Stdlib__List.exists((function (param) {
                          return equal(partial_arg, param);
                        }), get_values(rem)) ? rem : ({
                        hd: {
                          TAG: /* Sig_value */0,
                          _0: tdesc.val_id,
                          _1: tdesc.val_val
                        },
                        tl: rem
                      }),
                  match$1[2]
                ];
      case /* Psig_type */1 :
          const sdecls = sdesc._0;
          const rec_flag = rec_flag_of_ptype_declarations(sdecls);
          Stdlib__List.iter((function (decl) {
                  check_name("type", type_names, decl.ptype_name);
                }), sdecls);
          const match$2 = transl_type_decl(env, rec_flag, sdecls);
          const decls = match$2[0];
          const match$3 = transl_sig(match$2[1], srem);
          return [
                  {
                    hd: mksig$1({
                          TAG: /* Tsig_type */1,
                          _0: decls
                        }, env, loc),
                    tl: match$3[0]
                  },
                  map_rec_type_with_row_types(rec_flag, (function (rs, td) {
                          return {
                                  TAG: /* Sig_type */1,
                                  _0: td.typ_id,
                                  _1: td.typ_type,
                                  _2: rs
                                };
                        }), decls, match$3[1]),
                  match$3[2]
                ];
      case /* Psig_typext */2 :
          const match$4 = transl_type_extension(false, env, item.psig_loc, sdesc._0);
          const tyext = match$4[0];
          const match$5 = transl_sig(match$4[1], srem);
          const rem$1 = match$5[1];
          const constructors = Stdlib__List.filter((function (ext) {
                  const partial_arg = ext.ext_id;
                  return !Stdlib__List.exists((function (param) {
                                return equal(partial_arg, param);
                              }), get_extension_constructors(rem$1));
                }), tyext.tyext_constructors);
          return [
                  {
                    hd: mksig$1({
                          TAG: /* Tsig_typext */2,
                          _0: tyext
                        }, env, loc),
                    tl: match$5[0]
                  },
                  map_ext((function (es, ext) {
                          return {
                                  TAG: /* Sig_typext */2,
                                  _0: ext.ext_id,
                                  _1: ext.ext_type,
                                  _2: es
                                };
                        }), constructors, rem$1),
                  match$5[2]
                ];
      case /* Psig_exception */3 :
          const match$6 = transl_exception(env, sdesc._0);
          const ext = match$6[0];
          const match$7 = transl_sig(match$6[1], srem);
          const rem$2 = match$7[1];
          const partial_arg$1 = ext.ext_id;
          const shadowed = Stdlib__List.exists((function (param) {
                  return equal(partial_arg$1, param);
                }), get_extension_constructors(rem$2));
          return [
                  {
                    hd: mksig$1({
                          TAG: /* Tsig_exception */3,
                          _0: ext
                        }, env, loc),
                    tl: match$7[0]
                  },
                  shadowed ? rem$2 : ({
                        hd: {
                          TAG: /* Sig_typext */2,
                          _0: ext.ext_id,
                          _1: ext.ext_type,
                          _2: /* Text_exception */2
                        },
                        tl: rem$2
                      }),
                  match$7[2]
                ];
      case /* Psig_module */4 :
          const pmd = sdesc._0;
          check_name("module", module_names, pmd.pmd_name);
          const tmty = transl_modtype$1(env, pmd.pmd_type);
          const md_md_type = tmty.mty_type;
          const md_md_attributes = pmd.pmd_attributes;
          const md_md_loc = pmd.pmd_loc;
          const md = {
            md_type: md_md_type,
            md_attributes: md_md_attributes,
            md_loc: md_md_loc
          };
          const match$8 = enter_module_declaration(undefined, pmd.pmd_name.txt, md, env);
          const id = match$8[0];
          const match$9 = transl_sig(match$8[1], srem);
          return [
                  {
                    hd: mksig$1({
                          TAG: /* Tsig_module */4,
                          _0: {
                            md_id: id,
                            md_name: pmd.pmd_name,
                            md_type: tmty,
                            md_attributes: pmd.pmd_attributes,
                            md_loc: pmd.pmd_loc
                          }
                        }, env, loc),
                    tl: match$9[0]
                  },
                  {
                    hd: {
                      TAG: /* Sig_module */3,
                      _0: id,
                      _1: md,
                      _2: /* Trec_not */0
                    },
                    tl: match$9[1]
                  },
                  match$9[2]
                ];
      case /* Psig_recmodule */5 :
          const sdecls$1 = sdesc._0;
          Stdlib__List.iter((function (pmd) {
                  check_name("module", module_names, pmd.pmd_name);
                }), sdecls$1);
          const match$10 = transl_recmodule_modtypes(item.psig_loc, env, sdecls$1);
          const decls$1 = match$10[0];
          const match$11 = transl_sig(match$10[1], srem);
          return [
                  {
                    hd: mksig$1({
                          TAG: /* Tsig_recmodule */5,
                          _0: decls$1
                        }, env, loc),
                    tl: match$11[0]
                  },
                  map_rec((function (rs, md) {
                          const d_md_type = md.md_type.mty_type;
                          const d_md_attributes = md.md_attributes;
                          const d_md_loc = md.md_loc;
                          const d = {
                            md_type: d_md_type,
                            md_attributes: d_md_attributes,
                            md_loc: d_md_loc
                          };
                          return {
                                  TAG: /* Sig_module */3,
                                  _0: md.md_id,
                                  _1: d,
                                  _2: rs
                                };
                        }), decls$1, match$11[1]),
                  match$11[2]
                ];
      case /* Psig_modtype */6 :
          const match$12 = transl_modtype_decl(modtype_names, env, item.psig_loc, sdesc._0);
          const match$13 = transl_sig(match$12[0], srem);
          return [
                  {
                    hd: mksig$1({
                          TAG: /* Tsig_modtype */6,
                          _0: match$12[1]
                        }, env, loc),
                    tl: match$13[0]
                  },
                  {
                    hd: match$12[2],
                    tl: match$13[1]
                  },
                  match$13[2]
                ];
      case /* Psig_open */7 :
          const match$14 = type_open$1(undefined, env, sdesc._0);
          const match$15 = transl_sig(match$14[1], srem);
          return [
                  {
                    hd: mksig$1({
                          TAG: /* Tsig_open */7,
                          _0: match$14[2]
                        }, env, loc),
                    tl: match$15[0]
                  },
                  match$15[1],
                  match$15[2]
                ];
      case /* Psig_include */8 :
          const sincl = sdesc._0;
          const smty = sincl.pincl_mod;
          const tmty$1 = transl_modtype$1(env, smty);
          const mty = tmty$1.mty_type;
          const sg$1 = signature$2(identity, extract_sig(env, smty.pmty_loc, mty));
          const partial_arg$2 = item.psig_loc;
          Stdlib__List.iter((function (param) {
                  return check_sig_item(type_names, module_names, modtype_names, partial_arg$2, param);
                }), sg$1);
          const newenv = add_signature(sg$1, env);
          const incl_incl_loc = sincl.pincl_loc;
          const incl_incl_attributes = sincl.pincl_attributes;
          const incl = {
            incl_mod: tmty$1,
            incl_type: sg$1,
            incl_loc: incl_incl_loc,
            incl_attributes: incl_incl_attributes
          };
          const match$16 = transl_sig(newenv, srem);
          const rem$3 = match$16[1];
          return [
                  {
                    hd: mksig$1({
                          TAG: /* Tsig_include */8,
                          _0: incl
                        }, env, loc),
                    tl: match$16[0]
                  },
                  Stdlib.$at(remove_duplicates(get_values(rem$3), get_extension_constructors(rem$3), sg$1), rem$3),
                  match$16[2]
                ];
      case /* Psig_class */9 :
          const cl = sdesc._0;
          Stdlib__List.iter((function (param) {
                  check_name("type", type_names, param.pci_name);
                }), cl);
          const match$17 = class_descriptions(env, cl);
          const classes = match$17[0];
          const match$18 = transl_sig(match$17[1], srem);
          return [
                  {
                    hd: mksig$1({
                          TAG: /* Tsig_class */9,
                          _0: Stdlib__List.map2((function (pcl, tcl) {
                                  return tcl[11];
                                }), cl, classes)
                        }, env, loc),
                    tl: match$18[0]
                  },
                  Stdlib__List.flatten(map_rec((function (rs, param) {
                              return {
                                      hd: {
                                        TAG: /* Sig_class */5,
                                        _0: param[0],
                                        _1: param[2],
                                        _2: rs
                                      },
                                      tl: {
                                        hd: {
                                          TAG: /* Sig_class_type */6,
                                          _0: param[3],
                                          _1: param[4],
                                          _2: rs
                                        },
                                        tl: {
                                          hd: {
                                            TAG: /* Sig_type */1,
                                            _0: param[5],
                                            _1: param[6],
                                            _2: rs
                                          },
                                          tl: {
                                            hd: {
                                              TAG: /* Sig_type */1,
                                              _0: param[7],
                                              _1: param[8],
                                              _2: rs
                                            },
                                            tl: /* [] */0
                                          }
                                        }
                                      }
                                    };
                            }), classes, {
                            hd: match$18[1],
                            tl: /* [] */0
                          })),
                  match$18[2]
                ];
      case /* Psig_class_type */10 :
          const cl$1 = sdesc._0;
          Stdlib__List.iter((function (param) {
                  check_name("type", type_names, param.pci_name);
                }), cl$1);
          const match$19 = class_type_declarations$2(env, cl$1);
          const classes$1 = match$19[0];
          const match$20 = transl_sig(match$19[1], srem);
          return [
                  {
                    hd: mksig$1({
                          TAG: /* Tsig_class_type */10,
                          _0: Stdlib__List.map2((function (pcl, tcl) {
                                  return tcl[7];
                                }), cl$1, classes$1)
                        }, env, loc),
                    tl: match$20[0]
                  },
                  Stdlib__List.flatten(map_rec((function (rs, param) {
                              return {
                                      hd: {
                                        TAG: /* Sig_class_type */6,
                                        _0: param[0],
                                        _1: param[2],
                                        _2: rs
                                      },
                                      tl: {
                                        hd: {
                                          TAG: /* Sig_type */1,
                                          _0: param[3],
                                          _1: param[4],
                                          _2: rs
                                        },
                                        tl: {
                                          hd: {
                                            TAG: /* Sig_type */1,
                                            _0: param[5],
                                            _1: param[6],
                                            _2: rs
                                          },
                                          tl: /* [] */0
                                        }
                                      }
                                    };
                            }), classes$1, {
                            hd: match$20[1],
                            tl: /* [] */0
                          })),
                  match$20[2]
                ];
      case /* Psig_attribute */11 :
          const x = sdesc._0;
          warning_attribute({
                hd: x,
                tl: /* [] */0
              });
          const match$21 = transl_sig(env, srem);
          return [
                  {
                    hd: mksig$1({
                          TAG: /* Tsig_attribute */11,
                          _0: x
                        }, env, loc),
                    tl: match$21[0]
                  },
                  match$21[1],
                  match$21[2]
                ];
      case /* Psig_extension */12 :
          throw new Caml_js_exceptions.MelangeError(Error_forward$3, {
                    MEL_EXN_ID: Error_forward$3,
                    _1: error_of_extension(sdesc._0)
                  });
      
    }
  };
  const previous_saved_types = saved_types.contents;
  warning_enter_scope(undefined);
  const match = transl_sig(in_signature(env), sg);
  const sg_sig_items = match[0];
  const sg_sig_type = match[1];
  const sg_sig_final_env = match[2];
  const sg$1 = {
    sig_items: sg_sig_items,
    sig_type: sg_sig_type,
    sig_final_env: sg_sig_final_env
  };
  warning_leave_scope(undefined);
  saved_types.contents = {
    hd: {
      TAG: /* Partial_signature */5,
      _0: sg$1
    },
    tl: previous_saved_types
  };
  return sg$1;
}

function transl_modtype_decl(modtype_names, env, loc, param) {
  const pmtd_loc = param.pmtd_loc;
  const pmtd_attributes = param.pmtd_attributes;
  const pmtd_name = param.pmtd_name;
  check_name("module type", modtype_names, pmtd_name);
  const tmty = may_map((function (param) {
          return transl_modtype$1(env, param);
        }), param.pmtd_type);
  const decl_mtd_type = may_map((function (t) {
          return t.mty_type;
        }), tmty);
  const decl = {
    mtd_type: decl_mtd_type,
    mtd_attributes: pmtd_attributes,
    mtd_loc: pmtd_loc
  };
  const match = enter_modtype(pmtd_name.txt, decl, env);
  const id = match[0];
  const mtd = {
    mtd_id: id,
    mtd_name: pmtd_name,
    mtd_type: tmty,
    mtd_attributes: pmtd_attributes,
    mtd_loc: pmtd_loc
  };
  return [
          match[1],
          mtd,
          {
            TAG: /* Sig_modtype */4,
            _0: id,
            _1: decl
          }
        ];
}

function transl_recmodule_modtypes(loc, env, sdecls) {
  const make_env = function (curr) {
    return Stdlib__List.fold_left((function (env, param) {
                  return add_module$1(true, param[0], param[2], env);
                }), env, curr);
  };
  const make_env2 = function (curr) {
    return Stdlib__List.fold_left((function (env, param) {
                  return add_module$1(true, param[0], param[2].mty_type, env);
                }), env, curr);
  };
  const transition = function (env_c, curr) {
    return Stdlib__List.map2((function (pmd, param) {
                  return [
                          param[0],
                          param[1],
                          transl_modtype$1(env_c, pmd.pmd_type)
                        ];
                }), sdecls, curr);
  };
  const ids = Stdlib__List.map((function (x) {
          return create(x.pmd_name.txt);
        }), sdecls);
  const approx_env = Stdlib__List.fold_left((function (env, id) {
          const dummy = {
            TAG: /* Mty_ident */0,
            _0: {
              TAG: /* Pident */0,
              _0: create("#recmod#")
            }
          };
          return add_module$1(true, id, dummy, env);
        }), env, ids);
  const init = Stdlib__List.map2((function (id, pmd) {
          return [
                  id,
                  pmd.pmd_name,
                  approx_modtype(approx_env, pmd.pmd_type)
                ];
        }), ids, sdecls);
  const env0 = make_env(init);
  const dcl1 = transition(env0, init);
  const env1 = make_env2(dcl1);
  check_recmod_typedecls(env1, sdecls, dcl1);
  const dcl2 = transition(env1, dcl1);
  const env2 = make_env2(dcl2);
  check_recmod_typedecls(env2, sdecls, dcl2);
  const dcl2$1 = Stdlib__List.map2((function (pmd, param) {
          return {
                  md_id: param[0],
                  md_name: param[1],
                  md_type: param[2],
                  md_attributes: pmd.pmd_attributes,
                  md_loc: pmd.pmd_loc
                };
        }), sdecls, dcl2);
  return [
          dcl2$1,
          env2
        ];
}

function simplify_signature(sg) {
  const aux = function (param) {
    if (!param) {
      return [
              /* [] */0,
              /* Empty */0,
              /* Empty */0
            ];
    }
    const component = param.hd;
    switch (component.TAG | 0) {
      case /* Sig_value */0 :
          const k = aux(param.tl);
          const val_names = k[1];
          const name = component._0.name;
          if (Curry._2(mem$7, name, val_names)) {
            return k;
          } else {
            return [
                    {
                      hd: component,
                      tl: k[0]
                    },
                    Curry._2(add$14, name, val_names),
                    k[2]
                  ];
          }
      case /* Sig_typext */2 :
          const k$1 = aux(param.tl);
          const ext_names = k$1[2];
          const val_names$1 = k$1[1];
          const sg = k$1[0];
          const name$1 = component._0.name;
          if (!Curry._2(mem$7, name$1, ext_names)) {
            return [
                    {
                      hd: component,
                      tl: sg
                    },
                    val_names$1,
                    Curry._2(add$14, name$1, ext_names)
                  ];
          }
          if (component._2) {
            return k$1;
          }
          if (!sg) {
            return k$1;
          }
          const match = sg.hd;
          if (match.TAG === /* Sig_typext */2 && match._2 === 1) {
            return [
                    {
                      hd: {
                        TAG: /* Sig_typext */2,
                        _0: match._0,
                        _1: match._1,
                        _2: /* Text_first */0
                      },
                      tl: sg.tl
                    },
                    val_names$1,
                    ext_names
                  ];
          } else {
            return k$1;
          }
      default:
        const match$1 = aux(param.tl);
        return [
                {
                  hd: component,
                  tl: match$1[0]
                },
                match$1[1],
                match$1[2]
              ];
    }
  };
  return aux(sg)[0];
}

const Not_a_path = /* @__PURE__ */Caml_exceptions.create("Ocaml_typedtree_test.Typemod.Not_a_path");

function path_of_module(_mexp) {
  while(true) {
    const mexp = _mexp;
    const match = mexp.mod_desc;
    switch (match.TAG | 0) {
      case /* Tmod_ident */0 :
          return match._0;
      case /* Tmod_apply */3 :
          if (applicative_functors.contents) {
            return {
                    TAG: /* Papply */2,
                    _0: path_of_module(match._0),
                    _1: path_of_module(match._1)
                  };
          }
          throw new Caml_js_exceptions.MelangeError(Not_a_path, {
                    MEL_EXN_ID: Not_a_path
                  });
      case /* Tmod_constraint */4 :
          _mexp = match._0;
          continue ;
      default:
        throw new Caml_js_exceptions.MelangeError(Not_a_path, {
                  MEL_EXN_ID: Not_a_path
                });
    }
  };
}

function path_of_module$1(mexp) {
  try {
    return path_of_module(mexp);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Not_a_path) {
      return ;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function closed_modtype(_p) {
  while(true) {
    const p = _p;
    switch (p.TAG | 0) {
      case /* Mty_signature */1 :
          return Stdlib__List.for_all(closed_signature_item, p._0);
      case /* Mty_functor */2 :
          _p = p._2;
          continue ;
      case /* Mty_ident */0 :
      case /* Mty_alias */3 :
          return true;
      
    }
  };
}

function closed_signature_item(param) {
  switch (param.TAG | 0) {
    case /* Sig_value */0 :
        return closed_schema(param._1.val_type);
    case /* Sig_module */3 :
        return closed_modtype(param._1.md_type);
    default:
      return true;
  }
}

function anchor_submodule(name, anchor) {
  if (anchor !== undefined) {
    return {
            TAG: /* Pdot */1,
            _0: anchor,
            _1: name,
            _2: -1
          };
  }
  
}

function enrich_type_decls(anchor, decls, oldenv, newenv) {
  if (anchor !== undefined) {
    return Stdlib__List.fold_left((function (e, info) {
                  const id = info.typ_id;
                  const info$p = enrich_typedecl(oldenv, {
                        TAG: /* Pdot */1,
                        _0: anchor,
                        _1: id.name,
                        _2: -1
                      }, info.typ_type);
                  return add_type$1(true, id, info$p, e);
                }), oldenv, decls);
  } else {
    return newenv;
  }
}

function enrich_module_type(anchor, name, mty, env) {
  if (anchor !== undefined) {
    return enrich_modtype(env, {
                TAG: /* Pdot */1,
                _0: anchor,
                _1: name,
                _2: -1
              }, mty);
  } else {
    return mty;
  }
}

function check_recmodule_inclusion(env, bindings) {
  const subst_and_strengthen = function (env, s, id, mty) {
    return strengthen$1(env, modtype(s, mty), module_path(s, {
                    TAG: /* Pident */0,
                    _0: id
                  }));
  };
  let _first_time = true;
  let _n = Stdlib__List.length(bindings);
  let _env = env;
  let _s = identity;
  while(true) {
    const s = _s;
    const env$1 = _env;
    const n = _n;
    const first_time = _first_time;
    if (n > 0) {
      const bindings1 = Stdlib__List.map((function (param) {
              const id = param[0];
              return [
                      id,
                      rename(id),
                      param[4]
                    ];
            }), bindings);
      const env$p = Stdlib__List.fold_left((function (env, param) {
              const mty_actual = param[2];
              const mty_actual$p = first_time ? mty_actual : subst_and_strengthen(env, s, param[0], mty_actual);
              return add_module$1(false, param[1], mty_actual$p, env);
            }), env$1, bindings1);
      const s$p = Stdlib__List.fold_left((function (s, param) {
              return add_module(param[0], {
                          TAG: /* Pident */0,
                          _0: param[1]
                        }, s);
            }), identity, bindings1);
      _s = s$p;
      _env = env$p;
      _n = n - 1 | 0;
      _first_time = false;
      continue ;
    }
    const check_inclusion = function (param) {
      const modl = param[3];
      const mty_decl = param[2];
      const id = param[0];
      const mty_decl$p = modtype(s, mty_decl.mty_type);
      const mty_actual$p = subst_and_strengthen(env$1, s, id, param[4]);
      let coercion;
      try {
        coercion = modtypes$1(env$1, mty_actual$p, mty_decl$p);
      }
      catch (raw_msg){
        const msg = Caml_js_exceptions.internalToOCamlException(raw_msg);
        if (msg.MEL_EXN_ID === $$Error$5) {
          throw new Caml_js_exceptions.MelangeError($$Error$10, {
                    MEL_EXN_ID: $$Error$10,
                    _1: modl.mod_loc,
                    _2: env$1,
                    _3: {
                      TAG: /* Not_included */1,
                      _0: msg._1
                    }
                  });
        }
        throw new Caml_js_exceptions.MelangeError(msg.MEL_EXN_ID, msg);
      }
      const modl$p_mod_desc = {
        TAG: /* Tmod_constraint */4,
        _0: modl,
        _1: mty_decl.mty_type,
        _2: /* Tmodtype_explicit */{
          _0: mty_decl
        },
        _3: coercion
      };
      const modl$p_mod_loc = modl.mod_loc;
      const modl$p_mod_type = mty_decl.mty_type;
      const modl$p = {
        mod_desc: modl$p_mod_desc,
        mod_loc: modl$p_mod_loc,
        mod_type: modl$p_mod_type,
        mod_env: env$1,
        mod_attributes: /* [] */0
      };
      return {
              mb_id: id,
              mb_name: param[1],
              mb_expr: modl$p,
              mb_attributes: param[5],
              mb_loc: param[6]
            };
    };
    return Stdlib__List.map(check_inclusion, bindings);
  };
}

function package_constraints(env, loc, mty, constrs) {
  if (Caml_obj.caml_equal(constrs, /* [] */0)) {
    return mty;
  }
  const sg = extract_sig(env, loc, mty);
  const sg$p = Stdlib__List.map((function (item) {
          switch (item.TAG | 0) {
            case /* Sig_type */1 :
                const td = item._1;
                if (td.type_params) {
                  return item;
                }
                const id = item._0;
                if (!Stdlib__List.mem_assoc({
                        hd: id.name,
                        tl: /* [] */0
                      }, constrs)) {
                  return item;
                }
                const ty = Stdlib__List.assoc({
                      hd: id.name,
                      tl: /* [] */0
                    }, constrs);
                return {
                        TAG: /* Sig_type */1,
                        _0: id,
                        _1: {
                          type_params: td.type_params,
                          type_arity: td.type_arity,
                          type_kind: td.type_kind,
                          type_private: td.type_private,
                          type_manifest: ty,
                          type_variance: td.type_variance,
                          type_newtype_level: td.type_newtype_level,
                          type_loc: td.type_loc,
                          type_attributes: td.type_attributes
                        },
                        _2: item._2
                      };
            case /* Sig_module */3 :
                const md = item._1;
                const id$1 = item._0;
                const aux = function (_param) {
                  while(true) {
                    const param = _param;
                    if (!param) {
                      return /* [] */0;
                    }
                    const match = param.hd;
                    const match$1 = match[0];
                    if (match$1) {
                      const l = match$1.tl;
                      if (l) {
                        if (match$1.hd === id$1.name) {
                          return {
                                  hd: [
                                    l,
                                    match[1]
                                  ],
                                  tl: aux(param.tl)
                                };
                        }
                        _param = param.tl;
                        continue ;
                      }
                      _param = param.tl;
                      continue ;
                    }
                    _param = param.tl;
                    continue ;
                  };
                };
                const md_md_type = package_constraints(env, loc, md.md_type, aux(constrs));
                const md_md_attributes = md.md_attributes;
                const md_md_loc = md.md_loc;
                const md$1 = {
                  md_type: md_md_type,
                  md_attributes: md_md_attributes,
                  md_loc: md_md_loc
                };
                return {
                        TAG: /* Sig_module */3,
                        _0: id$1,
                        _1: md$1,
                        _2: item._2
                      };
            default:
              return item;
          }
        }), sg);
  return {
          TAG: /* Mty_signature */1,
          _0: sg$p
        };
}

function modtype_of_package(env, loc, p, nl, tl) {
  try {
    const mty = find_modtype(p, env).mtd_type;
    let exit = 0;
    if (mty !== undefined) {
      if (Caml_obj.caml_notequal(nl, /* [] */0)) {
        return package_constraints(env, loc, mty, Stdlib__List.combine(Stdlib__List.map(flatten, nl), tl));
      }
      exit = 1;
    } else {
      exit = 1;
    }
    if (exit === 1) {
      if (Caml_obj.caml_equal(nl, /* [] */0)) {
        return {
                TAG: /* Mty_ident */0,
                _0: p
              };
      }
      throw new Caml_js_exceptions.MelangeError($$Error$10, {
                MEL_EXN_ID: $$Error$10,
                _1: loc,
                _2: env,
                _3: /* Signature_expected */0
              });
    }
    
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      const error = {
        TAG: /* Unbound_modtype */22,
        _0: lid_of_path(undefined, p)
      };
      throw new Caml_js_exceptions.MelangeError($$Error$6, {
                MEL_EXN_ID: $$Error$6,
                _1: loc,
                _2: env,
                _3: error
              });
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function package_subtype$1(env, p1, nl1, tl1, p2, nl2, tl2) {
  const mkmty = function (p, nl, tl) {
    const ntl = Stdlib__List.filter((function (param) {
            return Caml_obj.caml_equal(free_variables$1(undefined, param[1]), /* [] */0);
          }), Stdlib__List.combine(nl, tl));
    const match = Stdlib__List.split(ntl);
    return modtype_of_package(env, none, p, match[0], match[1]);
  };
  const mty1 = mkmty(p1, nl1, tl1);
  const mty2 = mkmty(p2, nl2, tl2);
  try {
    return Caml_obj.caml_equal(modtypes$1(env, mty1, mty2), /* Tcoerce_none */0);
  }
  catch (raw_msg){
    const msg = Caml_js_exceptions.internalToOCamlException(raw_msg);
    if (msg.MEL_EXN_ID === $$Error$5) {
      return false;
    }
    throw new Caml_js_exceptions.MelangeError(msg.MEL_EXN_ID, msg);
  }
}

package_subtype.contents = package_subtype$1;

function wrap_constraint(env, arg, mty, explicit) {
  let coercion;
  try {
    coercion = modtypes$1(env, arg.mod_type, mty);
  }
  catch (raw_msg){
    const msg = Caml_js_exceptions.internalToOCamlException(raw_msg);
    if (msg.MEL_EXN_ID === $$Error$5) {
      throw new Caml_js_exceptions.MelangeError($$Error$10, {
                MEL_EXN_ID: $$Error$10,
                _1: arg.mod_loc,
                _2: env,
                _3: {
                  TAG: /* Not_included */1,
                  _0: msg._1
                }
              });
    }
    throw new Caml_js_exceptions.MelangeError(msg.MEL_EXN_ID, msg);
  }
  return {
          mod_desc: {
            TAG: /* Tmod_constraint */4,
            _0: arg,
            _1: mty,
            _2: explicit,
            _3: coercion
          },
          mod_loc: arg.mod_loc,
          mod_type: mty,
          mod_env: env,
          mod_attributes: /* [] */0
        };
}

function type_module$1(aliasOpt, sttn, funct_body, anchor, env, smod) {
  const alias = aliasOpt !== undefined ? aliasOpt : false;
  const lid = smod.pmod_desc;
  switch (lid.TAG | 0) {
    case /* Pmod_ident */0 :
        const lid$1 = lid._0;
        const path = lookup_module$1(!alias, env, smod.pmod_loc, lid$1.txt);
        const md_mod_desc = {
          TAG: /* Tmod_ident */0,
          _0: path,
          _1: lid$1
        };
        const md_mod_loc = smod.pmod_loc;
        const md_mod_type = {
          TAG: /* Mty_alias */3,
          _0: path
        };
        const md_mod_attributes = smod.pmod_attributes;
        const md = {
          mod_desc: md_mod_desc,
          mod_loc: md_mod_loc,
          mod_type: md_mod_type,
          mod_env: env,
          mod_attributes: md_mod_attributes
        };
        let node;
        if (alias && !is_functor_arg(path, env)) {
          add_required_global(head(path));
          node = md;
        } else {
          const p1 = find_module(false, path, env).md_type;
          let exit = 0;
          if (p1.TAG === /* Mty_alias */3 && !alias) {
            const p1$1 = normalize_path$1(smod.pmod_loc, env, p1._0);
            const mty = expand_module_alias(env, /* [] */0, p1$1);
            node = {
              mod_desc: {
                TAG: /* Tmod_constraint */4,
                _0: md,
                _1: mty,
                _2: /* Tmodtype_implicit */0,
                _3: {
                  TAG: /* Tcoerce_alias */3,
                  _0: p1$1,
                  _1: /* Tcoerce_none */0
                }
              },
              mod_loc: md_mod_loc,
              mod_type: sttn ? strengthen$1(env, mty, p1$1) : mty,
              mod_env: env,
              mod_attributes: md_mod_attributes
            };
          } else {
            exit = 1;
          }
          if (exit === 1) {
            const mty$1 = sttn ? strengthen$1(env, p1, path) : p1;
            node = {
              mod_desc: md_mod_desc,
              mod_loc: md_mod_loc,
              mod_type: mty$1,
              mod_env: env,
              mod_attributes: md_mod_attributes
            };
          }
          
        }
        record$2({
              TAG: /* Ti_mod */3,
              _0: node
            });
        return node;
    case /* Pmod_structure */1 :
        const match = type_structure(undefined, funct_body, anchor, env, lid._0, smod.pmod_loc);
        const sg = match[1];
        const node_mod_desc = {
          TAG: /* Tmod_structure */1,
          _0: match[0]
        };
        const node_mod_loc = smod.pmod_loc;
        const node_mod_type = {
          TAG: /* Mty_signature */1,
          _0: sg
        };
        const node_mod_attributes = smod.pmod_attributes;
        const node$1 = {
          mod_desc: node_mod_desc,
          mod_loc: node_mod_loc,
          mod_type: node_mod_type,
          mod_env: env,
          mod_attributes: node_mod_attributes
        };
        record$2({
              TAG: /* Ti_mod */3,
              _0: node$1
            });
        const sg$p = simplify_signature(sg);
        if (Stdlib__List.length(sg$p) === Stdlib__List.length(sg)) {
          return node$1;
        } else {
          return wrap_constraint(implicit_coercion(env), node$1, {
                      TAG: /* Mty_signature */1,
                      _0: sg$p
                    }, /* Tmodtype_implicit */0);
        }
    case /* Pmod_functor */2 :
        const name = lid._0;
        const mty$2 = may_map((function (param) {
                return transl_modtype$1(env, param);
              }), lid._1);
        const ty_arg = may_map((function (m) {
                return m.mty_type;
              }), mty$2);
        const match$1 = ty_arg !== undefined ? [
            enter_module(true, name.txt, ty_arg, env),
            true
          ] : [
            [
              create("*"),
              env
            ],
            false
          ];
        const match$2 = match$1[0];
        const id = match$2[0];
        const body = type_module$1(undefined, sttn, match$1[1], undefined, match$2[1], lid._2);
        const node_mod_desc$1 = {
          TAG: /* Tmod_functor */2,
          _0: id,
          _1: name,
          _2: mty$2,
          _3: body
        };
        const node_mod_loc$1 = smod.pmod_loc;
        const node_mod_type$1 = {
          TAG: /* Mty_functor */2,
          _0: id,
          _1: ty_arg,
          _2: body.mod_type
        };
        const node_mod_attributes$1 = smod.pmod_attributes;
        const node$2 = {
          mod_desc: node_mod_desc$1,
          mod_loc: node_mod_loc$1,
          mod_type: node_mod_type$1,
          mod_env: env,
          mod_attributes: node_mod_attributes$1
        };
        record$2({
              TAG: /* Ti_mod */3,
              _0: node$2
            });
        return node$2;
    case /* Pmod_apply */3 :
        const sarg = lid._1;
        const sfunct = lid._0;
        const arg = type_module$1(undefined, true, funct_body, undefined, env, sarg);
        const path$1 = path_of_module$1(arg);
        const funct = type_module$1(undefined, sttn && path$1 !== undefined, funct_body, undefined, env, sfunct);
        const mty_functor = scrape_alias(env, undefined, funct.mod_type);
        if (mty_functor.TAG === /* Mty_functor */2) {
          const mty_res = mty_functor._2;
          const mty_param = mty_functor._1;
          const param = mty_functor._0;
          const generative = mty_param === undefined;
          const mty_param$1 = mty_param !== undefined ? mty_param : ({
                TAG: /* Mty_signature */1,
                _0: /* [] */0
              });
          if (generative) {
            if (Caml_obj.caml_notequal(sarg.pmod_desc, {
                    TAG: /* Pmod_structure */1,
                    _0: /* [] */0
                  })) {
              throw new Caml_js_exceptions.MelangeError($$Error$10, {
                        MEL_EXN_ID: $$Error$10,
                        _1: sfunct.pmod_loc,
                        _2: env,
                        _3: /* Apply_generative */4
                      });
            }
            if (funct_body && contains_type$1(env, funct.mod_type)) {
              throw new Caml_js_exceptions.MelangeError($$Error$10, {
                        MEL_EXN_ID: $$Error$10,
                        _1: smod.pmod_loc,
                        _2: env,
                        _3: /* Not_allowed_in_functor_body */1
                      });
            }
            
          }
          let coercion;
          try {
            coercion = modtypes$1(env, arg.mod_type, mty_param$1);
          }
          catch (raw_msg){
            const msg = Caml_js_exceptions.internalToOCamlException(raw_msg);
            if (msg.MEL_EXN_ID === $$Error$5) {
              throw new Caml_js_exceptions.MelangeError($$Error$10, {
                        MEL_EXN_ID: $$Error$10,
                        _1: sarg.pmod_loc,
                        _2: env,
                        _3: {
                          TAG: /* Not_included */1,
                          _0: msg._1
                        }
                      });
            }
            throw new Caml_js_exceptions.MelangeError(msg.MEL_EXN_ID, msg);
          }
          let mty_appl;
          if (path$1 !== undefined) {
            mty_appl = modtype(add_module(param, path$1, identity), mty_res);
          } else if (generative) {
            mty_appl = mty_res;
          } else {
            try {
              mty_appl = nondep_supertype(add_module$1(true, param, arg.mod_type, env), param, mty_res);
            }
            catch (raw_exn){
              const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn.MEL_EXN_ID === Stdlib.Not_found) {
                throw new Caml_js_exceptions.MelangeError($$Error$10, {
                          MEL_EXN_ID: $$Error$10,
                          _1: smod.pmod_loc,
                          _2: env,
                          _3: {
                            TAG: /* Cannot_eliminate_dependency */2,
                            _0: mty_functor
                          }
                        });
              }
              throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
            }
          }
          const node_mod_desc$2 = {
            TAG: /* Tmod_apply */3,
            _0: funct,
            _1: arg,
            _2: coercion
          };
          const node_mod_loc$2 = smod.pmod_loc;
          const node_mod_attributes$2 = smod.pmod_attributes;
          const node$3 = {
            mod_desc: node_mod_desc$2,
            mod_loc: node_mod_loc$2,
            mod_type: mty_appl,
            mod_env: env,
            mod_attributes: node_mod_attributes$2
          };
          record$2({
                TAG: /* Ti_mod */3,
                _0: node$3
              });
          return node$3;
        }
        throw new Caml_js_exceptions.MelangeError($$Error$10, {
                  MEL_EXN_ID: $$Error$10,
                  _1: sfunct.pmod_loc,
                  _2: env,
                  _3: {
                    TAG: /* Cannot_apply */0,
                    _0: funct.mod_type
                  }
                });
    case /* Pmod_constraint */4 :
        const arg$1 = type_module$1(alias, true, funct_body, anchor, env, lid._0);
        const mty$3 = transl_modtype$1(env, lid._1);
        const init = wrap_constraint(env, arg$1, mty$3.mty_type, /* Tmodtype_explicit */{
              _0: mty$3
            });
        const node_mod_desc$3 = init.mod_desc;
        const node_mod_loc$3 = smod.pmod_loc;
        const node_mod_type$2 = init.mod_type;
        const node_mod_env = init.mod_env;
        const node_mod_attributes$3 = smod.pmod_attributes;
        const node$4 = {
          mod_desc: node_mod_desc$3,
          mod_loc: node_mod_loc$3,
          mod_type: node_mod_type$2,
          mod_env: node_mod_env,
          mod_attributes: node_mod_attributes$3
        };
        record$2({
              TAG: /* Ti_mod */3,
              _0: node$4
            });
        return node$4;
    case /* Pmod_unpack */5 :
        if (principal.contents) {
          begin_def(undefined);
        }
        const exp = type_exp(env, lid._0);
        if (principal.contents) {
          end_def(undefined);
          generalize_structure$1(current_level.contents, exp.exp_type);
        }
        const match$3 = expand_head(env, exp.exp_type);
        let mty$4;
        let exit$1 = 0;
        const match$4 = match$3.desc;
        if (typeof match$4 === "number") {
          exit$1 = 1;
        } else {
          switch (match$4.TAG | 0) {
            case /* Tvar */0 :
                throw new Caml_js_exceptions.MelangeError($$Error$7, {
                          MEL_EXN_ID: $$Error$7,
                          _1: smod.pmod_loc,
                          _2: env,
                          _3: /* Cannot_infer_signature */3
                        });
            case /* Tpackage */11 :
                const tl = match$4._2;
                if (Stdlib__List.exists((function (t) {
                          return Caml_obj.caml_notequal(free_variables$1(undefined, t), /* [] */0);
                        }), tl)) {
                  throw new Caml_js_exceptions.MelangeError($$Error$10, {
                            MEL_EXN_ID: $$Error$10,
                            _1: smod.pmod_loc,
                            _2: env,
                            _3: {
                              TAG: /* Incomplete_packed_module */13,
                              _0: exp.exp_type
                            }
                          });
                }
                if (principal.contents && !generalizable(99999999, exp.exp_type)) {
                  prerr_warning(smod.pmod_loc, {
                        TAG: /* Not_principal */8,
                        _0: "this module unpacking"
                      });
                }
                mty$4 = modtype_of_package(env, smod.pmod_loc, match$4._0, match$4._1, tl);
                break;
            default:
              exit$1 = 1;
          }
        }
        if (exit$1 === 1) {
          throw new Caml_js_exceptions.MelangeError($$Error$10, {
                    MEL_EXN_ID: $$Error$10,
                    _1: smod.pmod_loc,
                    _2: env,
                    _3: {
                      TAG: /* Not_a_packed_module */12,
                      _0: exp.exp_type
                    }
                  });
        }
        if (funct_body && contains_type$1(env, mty$4)) {
          throw new Caml_js_exceptions.MelangeError($$Error$10, {
                    MEL_EXN_ID: $$Error$10,
                    _1: smod.pmod_loc,
                    _2: env,
                    _3: /* Not_allowed_in_functor_body */1
                  });
        }
        const node_mod_desc$4 = {
          TAG: /* Tmod_unpack */5,
          _0: exp,
          _1: mty$4
        };
        const node_mod_loc$4 = smod.pmod_loc;
        const node_mod_attributes$4 = smod.pmod_attributes;
        const node$5 = {
          mod_desc: node_mod_desc$4,
          mod_loc: node_mod_loc$4,
          mod_type: mty$4,
          mod_env: env,
          mod_attributes: node_mod_attributes$4
        };
        record$2({
              TAG: /* Ti_mod */3,
              _0: node$5
            });
        return node$5;
    case /* Pmod_extension */6 :
        throw new Caml_js_exceptions.MelangeError(Error_forward$3, {
                  MEL_EXN_ID: Error_forward$3,
                  _1: error_of_extension(lid._0)
                });
    
  }
}

function type_structure(toplevelOpt, funct_body, anchor, env, sstr, scope) {
  const toplevel = toplevelOpt !== undefined ? toplevelOpt : false;
  const type_names = {
    contents: /* Empty */0
  };
  const module_names = {
    contents: /* Empty */0
  };
  const modtype_names = {
    contents: /* Empty */0
  };
  const type_str_item = function (env, srem, param) {
    const loc = param.pstr_loc;
    const desc = param.pstr_desc;
    switch (desc.TAG | 0) {
      case /* Pstr_eval */0 :
          const expr = type_expression(env, desc._0);
          return [
                  {
                    TAG: /* Tstr_eval */0,
                    _0: expr,
                    _1: desc._1
                  },
                  /* [] */0,
                  env
                ];
      case /* Pstr_value */1 :
          const rec_flag = desc._0;
          let scope$1;
          if (rec_flag) {
            scope$1 = {
              TAG: /* Idef */1,
              _0: {
                loc_start: loc.loc_start,
                loc_end: scope.loc_end,
                loc_ghost: scope.loc_ghost
              }
            };
          } else {
            const start = srem ? srem.hd.pstr_loc.loc_start : loc.loc_end;
            scope$1 = {
              TAG: /* Idef */1,
              _0: {
                loc_start: start,
                loc_end: scope.loc_end,
                loc_ghost: scope.loc_ghost
              }
            };
          }
          const match = type_binding(env, rec_flag, desc._1, scope$1);
          const newenv = match[1];
          const defs = match[0];
          return [
                  {
                    TAG: /* Tstr_value */1,
                    _0: rec_flag,
                    _1: defs
                  },
                  Stdlib__List.map((function (id) {
                          return {
                                  TAG: /* Sig_value */0,
                                  _0: id,
                                  _1: find_value({
                                        TAG: /* Pident */0,
                                        _0: id
                                      }, newenv)
                                };
                        }), let_bound_idents(defs)),
                  newenv
                ];
      case /* Pstr_primitive */2 :
          const match$1 = transl_value_decl(env, loc, desc._0);
          const desc$1 = match$1[0];
          return [
                  {
                    TAG: /* Tstr_primitive */2,
                    _0: desc$1
                  },
                  {
                    hd: {
                      TAG: /* Sig_value */0,
                      _0: desc$1.val_id,
                      _1: desc$1.val_val
                    },
                    tl: /* [] */0
                  },
                  match$1[1]
                ];
      case /* Pstr_type */3 :
          const sdecls = desc._0;
          const rec_flag$1 = rec_flag_of_ptype_declarations(sdecls);
          Stdlib__List.iter((function (decl) {
                  check_name("type", type_names, decl.ptype_name);
                }), sdecls);
          const match$2 = transl_type_decl(env, rec_flag$1, sdecls);
          const decls = match$2[0];
          return [
                  {
                    TAG: /* Tstr_type */3,
                    _0: decls
                  },
                  map_rec_type_with_row_types(rec_flag$1, (function (rs, info) {
                          return {
                                  TAG: /* Sig_type */1,
                                  _0: info.typ_id,
                                  _1: info.typ_type,
                                  _2: rs
                                };
                        }), decls, /* [] */0),
                  enrich_type_decls(anchor, decls, env, match$2[1])
                ];
      case /* Pstr_typext */4 :
          const match$3 = transl_type_extension(true, env, loc, desc._0);
          const tyext = match$3[0];
          return [
                  {
                    TAG: /* Tstr_typext */4,
                    _0: tyext
                  },
                  map_ext((function (es, ext) {
                          return {
                                  TAG: /* Sig_typext */2,
                                  _0: ext.ext_id,
                                  _1: ext.ext_type,
                                  _2: es
                                };
                        }), tyext.tyext_constructors, /* [] */0),
                  match$3[1]
                ];
      case /* Pstr_exception */5 :
          const match$4 = transl_exception(env, desc._0);
          const ext = match$4[0];
          return [
                  {
                    TAG: /* Tstr_exception */5,
                    _0: ext
                  },
                  {
                    hd: {
                      TAG: /* Sig_typext */2,
                      _0: ext.ext_id,
                      _1: ext.ext_type,
                      _2: /* Text_exception */2
                    },
                    tl: /* [] */0
                  },
                  match$4[1]
                ];
      case /* Pstr_module */6 :
          const match$5 = desc._0;
          const pmb_loc = match$5.pmb_loc;
          const attrs = match$5.pmb_attributes;
          const name = match$5.pmb_name;
          check_name("module", module_names, name);
          const modl = type_module$1(true, true, funct_body, anchor_submodule(name.txt, anchor), env, match$5.pmb_expr);
          const md_md_type = enrich_module_type(anchor, name.txt, modl.mod_type, env);
          const md = {
            md_type: md_md_type,
            md_attributes: attrs,
            md_loc: pmb_loc
          };
          const match$6 = enter_module_declaration(undefined, name.txt, md, env);
          const id = match$6[0];
          return [
                  {
                    TAG: /* Tstr_module */6,
                    _0: {
                      mb_id: id,
                      mb_name: name,
                      mb_expr: modl,
                      mb_attributes: attrs,
                      mb_loc: pmb_loc
                    }
                  },
                  {
                    hd: {
                      TAG: /* Sig_module */3,
                      _0: id,
                      _1: {
                        md_type: modl.mod_type,
                        md_attributes: attrs,
                        md_loc: pmb_loc
                      },
                      _2: /* Trec_not */0
                    },
                    tl: /* [] */0
                  },
                  match$6[1]
                ];
      case /* Pstr_recmodule */7 :
          const sbind = Stdlib__List.map((function (mb) {
                  const match = mb.pmb_expr.pmod_desc;
                  if (match.TAG === /* Pmod_constraint */4) {
                    return [
                            mb.pmb_name,
                            match._1,
                            match._0,
                            mb.pmb_attributes,
                            mb.pmb_loc
                          ];
                  }
                  throw new Caml_js_exceptions.MelangeError($$Error$10, {
                            MEL_EXN_ID: $$Error$10,
                            _1: mb.pmb_expr.pmod_loc,
                            _2: env,
                            _3: /* Recursive_module_require_explicit_type */3
                          });
                }), desc._0);
          Stdlib__List.iter((function (param) {
                  check_name("module", module_names, param[0]);
                }), sbind);
          const match$7 = transl_recmodule_modtypes(loc, env, Stdlib__List.map((function (param) {
                      return {
                              pmd_name: param[0],
                              pmd_type: param[1],
                              pmd_attributes: param[3],
                              pmd_loc: param[4]
                            };
                    }), sbind));
          const newenv$1 = match$7[1];
          const decls$1 = match$7[0];
          const bindings1 = Stdlib__List.map2((function (param, param$1) {
                  const id = param.md_id;
                  const modl = type_module$1(undefined, true, funct_body, {
                        TAG: /* Pident */0,
                        _0: id
                      }, newenv$1, param$1[2]);
                  const mty$p = enrich_module_type(anchor, id.name, modl.mod_type, newenv$1);
                  return [
                          id,
                          param$1[0],
                          param.md_type,
                          modl,
                          mty$p,
                          param$1[3],
                          param$1[4]
                        ];
                }), decls$1, sbind);
          const newenv$2 = Stdlib__List.fold_left((function (env, md) {
                  const mdecl_md_type = md.md_type.mty_type;
                  const mdecl_md_attributes = md.md_attributes;
                  const mdecl_md_loc = md.md_loc;
                  const mdecl = {
                    md_type: mdecl_md_type,
                    md_attributes: mdecl_md_attributes,
                    md_loc: mdecl_md_loc
                  };
                  return add_module_declaration(undefined, md.md_id, mdecl, env);
                }), env, decls$1);
          const bindings2 = check_recmodule_inclusion(newenv$2, bindings1);
          return [
                  {
                    TAG: /* Tstr_recmodule */7,
                    _0: bindings2
                  },
                  map_rec((function (rs, mb) {
                          return {
                                  TAG: /* Sig_module */3,
                                  _0: mb.mb_id,
                                  _1: {
                                    md_type: mb.mb_expr.mod_type,
                                    md_attributes: mb.mb_attributes,
                                    md_loc: mb.mb_loc
                                  },
                                  _2: rs
                                };
                        }), bindings2, /* [] */0),
                  newenv$2
                ];
      case /* Pstr_modtype */8 :
          const match$8 = transl_modtype_decl(modtype_names, env, loc, desc._0);
          return [
                  {
                    TAG: /* Tstr_modtype */8,
                    _0: match$8[1]
                  },
                  {
                    hd: match$8[2],
                    tl: /* [] */0
                  },
                  match$8[0]
                ];
      case /* Pstr_open */9 :
          const match$9 = type_open$1(toplevel, env, desc._0);
          return [
                  {
                    TAG: /* Tstr_open */9,
                    _0: match$9[2]
                  },
                  /* [] */0,
                  match$9[1]
                ];
      case /* Pstr_class */10 :
          const cl = desc._0;
          Stdlib__List.iter((function (param) {
                  check_name("type", type_names, param.pci_name);
                }), cl);
          const match$10 = class_declarations$2(env, cl);
          const classes = match$10[0];
          return [
                  {
                    TAG: /* Tstr_class */10,
                    _0: Stdlib__List.map((function (param) {
                            const vf = param[2].cty_new === undefined ? /* Virtual */0 : /* Concrete */1;
                            return [
                                    param[11],
                                    param[10],
                                    vf
                                  ];
                          }), classes)
                  },
                  Stdlib__List.flatten(map_rec((function (rs, param) {
                              return {
                                      hd: {
                                        TAG: /* Sig_class */5,
                                        _0: param[0],
                                        _1: param[2],
                                        _2: rs
                                      },
                                      tl: {
                                        hd: {
                                          TAG: /* Sig_class_type */6,
                                          _0: param[3],
                                          _1: param[4],
                                          _2: rs
                                        },
                                        tl: {
                                          hd: {
                                            TAG: /* Sig_type */1,
                                            _0: param[5],
                                            _1: param[6],
                                            _2: rs
                                          },
                                          tl: {
                                            hd: {
                                              TAG: /* Sig_type */1,
                                              _0: param[7],
                                              _1: param[8],
                                              _2: rs
                                            },
                                            tl: /* [] */0
                                          }
                                        }
                                      }
                                    };
                            }), classes, /* [] */0)),
                  match$10[1]
                ];
      case /* Pstr_class_type */11 :
          const cl$1 = desc._0;
          Stdlib__List.iter((function (param) {
                  check_name("type", type_names, param.pci_name);
                }), cl$1);
          const match$11 = class_type_declarations$2(env, cl$1);
          const classes$1 = match$11[0];
          return [
                  {
                    TAG: /* Tstr_class_type */11,
                    _0: Stdlib__List.map((function (param) {
                            return [
                                    param[0],
                                    param[1],
                                    param[7]
                                  ];
                          }), classes$1)
                  },
                  Stdlib__List.flatten(map_rec((function (rs, param) {
                              return {
                                      hd: {
                                        TAG: /* Sig_class_type */6,
                                        _0: param[0],
                                        _1: param[2],
                                        _2: rs
                                      },
                                      tl: {
                                        hd: {
                                          TAG: /* Sig_type */1,
                                          _0: param[3],
                                          _1: param[4],
                                          _2: rs
                                        },
                                        tl: {
                                          hd: {
                                            TAG: /* Sig_type */1,
                                            _0: param[5],
                                            _1: param[6],
                                            _2: rs
                                          },
                                          tl: /* [] */0
                                        }
                                      }
                                    };
                            }), classes$1, /* [] */0)),
                  match$11[1]
                ];
      case /* Pstr_include */12 :
          const sincl = desc._0;
          const smodl = sincl.pincl_mod;
          const modl$1 = type_module$1(undefined, true, funct_body, undefined, env, smodl);
          const sg = signature$2(identity, extract_sig_open(env, smodl.pmod_loc, modl$1.mod_type));
          const match$12 = modl$1.mod_desc;
          let sg$1;
          if (match$12.TAG === /* Tmod_ident */0) {
            const p = match$12._0;
            if (is_functor_arg(p, env)) {
              sg$1 = sg;
            } else {
              add_required_global(head(p));
              const pos = {
                contents: 0
              };
              sg$1 = Stdlib__List.map((function (it) {
                      switch (it.TAG | 0) {
                        case /* Sig_value */0 :
                            const match = it._1.val_kind;
                            if (typeof match === "number" && !match) {
                              pos.contents = pos.contents + 1 | 0;
                              return it;
                            } else {
                              return it;
                            }
                        case /* Sig_module */3 :
                            const md = it._1;
                            const id = it._0;
                            const n = pos.contents;
                            pos.contents = pos.contents + 1 | 0;
                            return {
                                    TAG: /* Sig_module */3,
                                    _0: id,
                                    _1: {
                                      md_type: {
                                        TAG: /* Mty_alias */3,
                                        _0: {
                                          TAG: /* Pdot */1,
                                          _0: p,
                                          _1: id.name,
                                          _2: n
                                        }
                                      },
                                      md_attributes: md.md_attributes,
                                      md_loc: md.md_loc
                                    },
                                    _2: it._2
                                  };
                        case /* Sig_typext */2 :
                        case /* Sig_class */5 :
                            pos.contents = pos.contents + 1 | 0;
                            return it;
                        default:
                          return it;
                      }
                    }), sg);
            }
          } else {
            sg$1 = sg;
          }
          Stdlib__List.iter((function (param) {
                  return check_sig_item(type_names, module_names, modtype_names, loc, param);
                }), sg$1);
          const new_env = add_signature(sg$1, env);
          const incl_incl_loc = sincl.pincl_loc;
          const incl_incl_attributes = sincl.pincl_attributes;
          const incl = {
            incl_mod: modl$1,
            incl_type: sg$1,
            incl_loc: incl_incl_loc,
            incl_attributes: incl_incl_attributes
          };
          return [
                  {
                    TAG: /* Tstr_include */12,
                    _0: incl
                  },
                  sg$1,
                  new_env
                ];
      case /* Pstr_attribute */13 :
          const x = desc._0;
          warning_attribute({
                hd: x,
                tl: /* [] */0
              });
          return [
                  {
                    TAG: /* Tstr_attribute */13,
                    _0: x
                  },
                  /* [] */0,
                  env
                ];
      case /* Pstr_extension */14 :
          throw new Caml_js_exceptions.MelangeError(Error_forward$3, {
                    MEL_EXN_ID: Error_forward$3,
                    _1: error_of_extension(desc._0)
                  });
      
    }
  };
  const type_struct = function (env, sstr) {
    init_def(currentstamp.contents);
    if (!sstr) {
      return [
              /* [] */0,
              /* [] */0,
              env
            ];
    }
    const srem = sstr.tl;
    const pstr = sstr.hd;
    const previous_saved_types = saved_types.contents;
    const match = type_str_item(env, srem, pstr);
    const str_str_desc = match[0];
    const str_str_loc = pstr.pstr_loc;
    const str = {
      str_desc: str_str_desc,
      str_loc: str_str_loc,
      str_env: env
    };
    saved_types.contents = {
      hd: {
        TAG: /* Partial_structure_item */1,
        _0: str
      },
      tl: previous_saved_types
    };
    const match$1 = type_struct(match[2], srem);
    return [
            {
              hd: str,
              tl: match$1[0]
            },
            Stdlib.$at(match[1], match$1[1]),
            match$1[2]
          ];
  };
  if (annotations.contents) {
    Stdlib__List.iter((function (param) {
            let loc = param.pstr_loc;
            if (annotations.contents) {
              phrases.contents = {
                hd: loc,
                tl: phrases.contents
              };
              return ;
            }
            
          }), sstr);
  }
  const previous_saved_types = saved_types.contents;
  warning_enter_scope(undefined);
  const match = type_struct(env, sstr);
  const final_env = match[2];
  const sg = match[1];
  const str_str_items = match[0];
  const str = {
    str_items: str_str_items,
    str_type: sg,
    str_final_env: final_env
  };
  warning_leave_scope(undefined);
  saved_types.contents = {
    hd: {
      TAG: /* Partial_structure */0,
      _0: str
    },
    tl: previous_saved_types
  };
  return [
          str,
          sg,
          final_env
        ];
}

function type_module$2(param, param$1) {
  return type_module$1(undefined, true, false, undefined, param, param$1);
}

function type_structure$1(param, param$1, param$2) {
  return type_structure(undefined, false, undefined, param, param$1, param$2);
}

function normalize_signature(env) {
  return function (param) {
    return Stdlib__List.iter((function (param) {
                  switch (param.TAG | 0) {
                    case /* Sig_value */0 :
                        return normalize_type(env, param._1.val_type);
                    case /* Sig_module */3 :
                        let _p = param._1.md_type;
                        while(true) {
                          const p = _p;
                          switch (p.TAG | 0) {
                            case /* Mty_signature */1 :
                                return normalize_signature(env)(p._0);
                            case /* Mty_functor */2 :
                                _p = p._2;
                                continue ;
                            case /* Mty_ident */0 :
                            case /* Mty_alias */3 :
                                return ;
                            
                          }
                        };
                    default:
                      return ;
                  }
                }), param);
  };
}

function type_module_type_of(env, smod) {
  const lid = smod.pmod_desc;
  let tmty;
  if (lid.TAG === /* Pmod_ident */0) {
    const lid$1 = lid._0;
    const match = find_module$1(env, smod.pmod_loc, lid$1.txt);
    const node_mod_desc = {
      TAG: /* Tmod_ident */0,
      _0: match[0],
      _1: lid$1
    };
    const node_mod_loc = smod.pmod_loc;
    const node_mod_type = match[1].md_type;
    const node_mod_attributes = smod.pmod_attributes;
    const node = {
      mod_desc: node_mod_desc,
      mod_loc: node_mod_loc,
      mod_type: node_mod_type,
      mod_env: env,
      mod_attributes: node_mod_attributes
    };
    record$2({
          TAG: /* Ti_mod */3,
          _0: node
        });
    tmty = node;
  } else {
    tmty = type_module$2(env, smod);
  }
  const mty = tmty.mod_type;
  const mty$1 = remove_aliases$1(env, mty);
  if (!closed_modtype(mty$1)) {
    throw new Caml_js_exceptions.MelangeError($$Error$10, {
              MEL_EXN_ID: $$Error$10,
              _1: smod.pmod_loc,
              _2: env,
              _3: {
                TAG: /* Non_generalizable_module */9,
                _0: mty$1
              }
            });
  }
  return [
          tmty,
          mty$1
        ];
}

function type_package$1(env, m, p, nl, tl) {
  const lv = current_level.contents;
  begin_def(undefined);
  set_current_time(lv);
  const context = narrow(undefined);
  const modl = type_module$2(env, m);
  init_def(currentstamp.contents);
  widen(context);
  const match = modl.mod_desc;
  let match$1;
  if (match.TAG === /* Tmod_ident */0) {
    match$1 = [
      match._0,
      env
    ];
  } else {
    const match$2 = enter_module(true, "%M", modl.mod_type, env);
    match$1 = [
      {
        TAG: /* Pident */0,
        _0: match$2[0]
      },
      match$2[1]
    ];
  }
  const env$1 = match$1[1];
  const mp = match$1[0];
  const mkpath = function (mp, name) {
    switch (name.TAG | 0) {
      case /* Lident */0 :
          return {
                  TAG: /* Pdot */1,
                  _0: mp,
                  _1: name._0,
                  _2: -1
                };
      case /* Ldot */1 :
          return {
                  TAG: /* Pdot */1,
                  _0: mkpath(mp, name._0),
                  _1: name._1,
                  _2: -1
                };
      case /* Lapply */2 :
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                    MEL_EXN_ID: "Assert_failure",
                    _1: [
                      "jscomp/test/ocaml_typedtree_test.ml",
                      51527,
                      11
                    ]
                  });
      
    }
  };
  const tl$p = Stdlib__List.map((function (name) {
          return newty2(100000000, {
                      TAG: /* Tconstr */3,
                      _0: mkpath(mp, name),
                      _1: /* [] */0,
                      _2: {
                        contents: /* Mnil */0
                      }
                    });
        }), nl);
  end_def(undefined);
  if (Caml_obj.caml_equal(nl, /* [] */0)) {
    return [
            wrap_constraint(env$1, modl, {
                  TAG: /* Mty_ident */0,
                  _0: p
                }, /* Tmodtype_implicit */0),
            /* [] */0
          ];
  }
  const mty = modtype_of_package(env$1, modl.mod_loc, p, nl, tl$p);
  Stdlib__List.iter2((function (n, ty) {
          try {
            return unify$2(env$1, ty, newvar(undefined, undefined));
          }
          catch (raw_exn){
            const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.MEL_EXN_ID === Unify) {
              throw new Caml_js_exceptions.MelangeError($$Error$10, {
                        MEL_EXN_ID: $$Error$10,
                        _1: m.pmod_loc,
                        _2: env$1,
                        _3: {
                          TAG: /* Scoping_pack */14,
                          _0: n,
                          _1: ty
                        }
                      });
            }
            throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
          }
        }), nl, tl$p);
  return [
          wrap_constraint(env$1, modl, mty, /* Tmodtype_implicit */0),
          tl$p
        ];
}

type_module.contents = type_module$2;

transl_modtype_longident.contents = transl_modtype_longident$1;

transl_modtype.contents = transl_modtype$1;

type_open.contents = (function (param, param$1, param$2, param$3) {
    return type_open_(undefined, param, param$1, param$2, param$3);
  });

type_package.contents = type_package$1;

type_module_type_of_fwd.contents = type_module_type_of;

function type_implementation_more(sourcefile, outputprefix, modulename, initial_env, ast) {
  clear(undefined);
  try {
    delayed_checks.contents = /* [] */0;
    required_globals.contents = /* [] */0;
    Curry._2(newrecord$1.structure, newrecord$1, ast);
    const match = type_structure$1(initial_env, ast, in_file(sourcefile));
    const finalenv = match[2];
    const sg = match[1];
    const str = match[0];
    const simple_sg = simplify_signature(sg);
    if (print_types.contents) {
      wrap_printing_env(initial_env, (function (param) {
              Curry._2(Stdlib__Format.fprintf(Stdlib__Format.std_formatter)(/* Format */{
                        _0: {
                          TAG: /* Alpha */15,
                          _0: {
                            TAG: /* Formatting_lit */17,
                            _0: /* Flush_newline */4,
                            _1: /* End_of_format */0
                          }
                        },
                        _1: "%a@."
                      }), signature$3, simple_sg);
            }));
      return [
              str,
              /* Tcoerce_none */0,
              finalenv,
              simple_sg
            ];
    }
    const sourceintf = chop_extension_if_any(sourcefile) + interface_suffix.contents;
    const mli_status = assume_no_mli.contents;
    if (mli_status === /* Mli_na */0 && Caml_external_polyfill.resolve("caml_sys_file_exists")(sourceintf) || mli_status === /* Mli_exists */1) {
      let intf_file;
      try {
        intf_file = find_in_path_uncap(load_path.contents, modulename + ".cmi");
      }
      catch (raw_exn){
        const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.MEL_EXN_ID === Stdlib.Not_found) {
          throw new Caml_js_exceptions.MelangeError($$Error$10, {
                    MEL_EXN_ID: $$Error$10,
                    _1: in_file(sourcefile),
                    _2: empty,
                    _3: {
                      TAG: /* Interface_not_compiled */11,
                      _0: sourceintf
                    }
                  });
        }
        throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
      }
      const dclsig = read_signature(modulename, intf_file);
      const coercion = compunit(initial_env, sourcefile, sg, intf_file, dclsig);
      force_delayed_checks(undefined);
      save_cmt(outputprefix + ".cmt", modulename, {
            TAG: /* Implementation */1,
            _0: str
          }, sourcefile, initial_env, undefined);
      return [
              str,
              coercion,
              finalenv,
              dclsig
            ];
    }
    Stdlib__List.iter((function (param) {
            const match = param.str_desc;
            switch (match.TAG | 0) {
              case /* Tstr_value */1 :
                  return Stdlib__List.iter((function (param) {
                                const exp = param.vb_expr;
                                if (closed_schema(exp.exp_type)) {
                                  return ;
                                }
                                throw new Caml_js_exceptions.MelangeError($$Error$10, {
                                          MEL_EXN_ID: $$Error$10,
                                          _1: exp.exp_loc,
                                          _2: finalenv,
                                          _3: {
                                            TAG: /* Non_generalizable */7,
                                            _0: exp.exp_type
                                          }
                                        });
                              }), match._1);
              case /* Tstr_module */6 :
                  const md = match._0.mb_expr;
                  if (closed_modtype(md.mod_type)) {
                    return ;
                  }
                  throw new Caml_js_exceptions.MelangeError($$Error$10, {
                            MEL_EXN_ID: $$Error$10,
                            _1: md.mod_loc,
                            _2: finalenv,
                            _3: {
                              TAG: /* Non_generalizable_module */9,
                              _0: md.mod_type
                            }
                          });
              default:
                return ;
            }
          }), str.str_items);
    normalize_signature(finalenv)(simple_sg);
    const coercion$1 = compunit(initial_env, sourcefile, sg, "(inferred signature)", simple_sg);
    force_delayed_checks(undefined);
    if (!dont_write_files.contents) {
      const sg$1 = save_signature(simple_sg, modulename, outputprefix + ".cmi");
      save_cmt(outputprefix + ".cmt", modulename, {
            TAG: /* Implementation */1,
            _0: str
          }, sourcefile, initial_env, sg$1);
    }
    return [
            str,
            coercion$1,
            finalenv,
            simple_sg
          ];
  }
  catch (e){
    save_cmt(outputprefix + ".cmt", modulename, {
          TAG: /* Partial_implementation */3,
          _0: Stdlib__Array.of_list(saved_types.contents)
        }, sourcefile, initial_env, undefined);
    throw new Caml_js_exceptions.MelangeError(e.MEL_EXN_ID, e);
  }
}

function type_implementation(sourcefile, outputprefix, modulename, initial_env, ast) {
  const match = type_implementation_more(sourcefile, outputprefix, modulename, initial_env, ast);
  return [
          match[0],
          match[1]
        ];
}

register_error_of_exn(function (err) {
      if (err.MEL_EXN_ID !== $$Error$10) {
        if (err.MEL_EXN_ID === Error_forward$3) {
          return err._1;
        } else {
          return ;
        }
      }
      const env = err._2;
      return error_of_printer(err._1, (function (param, param$1) {
                    return wrap_printing_env(env, (function (param$2) {
                                  if (typeof param$1 === "number") {
                                    switch (param$1) {
                                      case /* Signature_expected */0 :
                                          return Stdlib__Format.fprintf(param)(/* Format */{
                                                      _0: {
                                                        TAG: /* String_literal */11,
                                                        _0: "This module type is not a signature",
                                                        _1: /* End_of_format */0
                                                      },
                                                      _1: "This module type is not a signature"
                                                    });
                                      case /* Not_allowed_in_functor_body */1 :
                                          return Curry._1(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* Formatting_gen */18,
                                                            _0: {
                                                              TAG: /* Open_box */1,
                                                              _0: /* Format */{
                                                                _0: /* End_of_format */0,
                                                                _1: ""
                                                              }
                                                            },
                                                            _1: {
                                                              TAG: /* String_literal */11,
                                                              _0: "This expression creates fresh types.",
                                                              _1: {
                                                                TAG: /* Formatting_lit */17,
                                                                _0: {
                                                                  TAG: /* Break */0,
                                                                  _0: "@ ",
                                                                  _1: 1,
                                                                  _2: 0
                                                                },
                                                                _1: {
                                                                  TAG: /* String */2,
                                                                  _0: /* No_padding */0,
                                                                  _1: {
                                                                    TAG: /* Formatting_lit */17,
                                                                    _0: /* Close_box */0,
                                                                    _1: /* End_of_format */0
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          },
                                                          _1: "@[This expression creates fresh types.@ %s@]"
                                                        }), "It is not allowed inside applicative functors.");
                                      case /* With_need_typeconstr */2 :
                                          return Stdlib__Format.fprintf(param)(/* Format */{
                                                      _0: {
                                                        TAG: /* String_literal */11,
                                                        _0: "Only type constructors with identical parameters can be substituted.",
                                                        _1: /* End_of_format */0
                                                      },
                                                      _1: "Only type constructors with identical parameters can be substituted."
                                                    });
                                      case /* Recursive_module_require_explicit_type */3 :
                                          return Stdlib__Format.fprintf(param)(/* Format */{
                                                      _0: {
                                                        TAG: /* String_literal */11,
                                                        _0: "Recursive modules require an explicit module type.",
                                                        _1: /* End_of_format */0
                                                      },
                                                      _1: "Recursive modules require an explicit module type."
                                                    });
                                      case /* Apply_generative */4 :
                                          return Stdlib__Format.fprintf(param)(/* Format */{
                                                      _0: {
                                                        TAG: /* String_literal */11,
                                                        _0: "This is a generative functor. It can only be applied to ()",
                                                        _1: /* End_of_format */0
                                                      },
                                                      _1: "This is a generative functor. It can only be applied to ()"
                                                    });
                                      
                                    }
                                  } else {
                                    switch (param$1.TAG | 0) {
                                      case /* Cannot_apply */0 :
                                          return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* Formatting_gen */18,
                                                            _0: {
                                                              TAG: /* Open_box */1,
                                                              _0: /* Format */{
                                                                _0: /* End_of_format */0,
                                                                _1: ""
                                                              }
                                                            },
                                                            _1: {
                                                              TAG: /* String_literal */11,
                                                              _0: "This module is not a functor; it has type",
                                                              _1: {
                                                                TAG: /* Formatting_lit */17,
                                                                _0: {
                                                                  TAG: /* Break */0,
                                                                  _0: "@ ",
                                                                  _1: 1,
                                                                  _2: 0
                                                                },
                                                                _1: {
                                                                  TAG: /* Alpha */15,
                                                                  _0: {
                                                                    TAG: /* Formatting_lit */17,
                                                                    _0: /* Close_box */0,
                                                                    _1: /* End_of_format */0
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          },
                                                          _1: "@[This module is not a functor; it has type@ %a@]"
                                                        }), modtype$1, param$1._0);
                                      case /* Not_included */1 :
                                          return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* Formatting_gen */18,
                                                            _0: {
                                                              TAG: /* Open_box */1,
                                                              _0: /* Format */{
                                                                _0: {
                                                                  TAG: /* String_literal */11,
                                                                  _0: "<v>",
                                                                  _1: /* End_of_format */0
                                                                },
                                                                _1: "<v>"
                                                              }
                                                            },
                                                            _1: {
                                                              TAG: /* String_literal */11,
                                                              _0: "Signature mismatch:",
                                                              _1: {
                                                                TAG: /* Formatting_lit */17,
                                                                _0: {
                                                                  TAG: /* Break */0,
                                                                  _0: "@ ",
                                                                  _1: 1,
                                                                  _2: 0
                                                                },
                                                                _1: {
                                                                  TAG: /* Alpha */15,
                                                                  _0: {
                                                                    TAG: /* Formatting_lit */17,
                                                                    _0: /* Close_box */0,
                                                                    _1: /* End_of_format */0
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          },
                                                          _1: "@[<v>Signature mismatch:@ %a@]"
                                                        }), report_error$4, param$1._0);
                                      case /* Cannot_eliminate_dependency */2 :
                                          return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* Formatting_gen */18,
                                                            _0: {
                                                              TAG: /* Open_box */1,
                                                              _0: /* Format */{
                                                                _0: /* End_of_format */0,
                                                                _1: ""
                                                              }
                                                            },
                                                            _1: {
                                                              TAG: /* String_literal */11,
                                                              _0: "This functor has type",
                                                              _1: {
                                                                TAG: /* Formatting_lit */17,
                                                                _0: {
                                                                  TAG: /* Break */0,
                                                                  _0: "@ ",
                                                                  _1: 1,
                                                                  _2: 0
                                                                },
                                                                _1: {
                                                                  TAG: /* Alpha */15,
                                                                  _0: {
                                                                    TAG: /* Formatting_lit */17,
                                                                    _0: {
                                                                      TAG: /* Break */0,
                                                                      _0: "@ ",
                                                                      _1: 1,
                                                                      _2: 0
                                                                    },
                                                                    _1: {
                                                                      TAG: /* String_literal */11,
                                                                      _0: "The parameter cannot be eliminated in the result type.",
                                                                      _1: {
                                                                        TAG: /* Formatting_lit */17,
                                                                        _0: {
                                                                          TAG: /* Break */0,
                                                                          _0: "@ ",
                                                                          _1: 1,
                                                                          _2: 0
                                                                        },
                                                                        _1: {
                                                                          TAG: /* String_literal */11,
                                                                          _0: " Please bind the argument to a module identifier.",
                                                                          _1: {
                                                                            TAG: /* Formatting_lit */17,
                                                                            _0: /* Close_box */0,
                                                                            _1: /* End_of_format */0
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          },
                                                          _1: "@[This functor has type@ %a@ The parameter cannot be eliminated in the result type.@  Please bind the argument to a module identifier.@]"
                                                        }), modtype$1, param$1._0);
                                      case /* Structure_expected */3 :
                                          return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* Formatting_gen */18,
                                                            _0: {
                                                              TAG: /* Open_box */1,
                                                              _0: /* Format */{
                                                                _0: /* End_of_format */0,
                                                                _1: ""
                                                              }
                                                            },
                                                            _1: {
                                                              TAG: /* String_literal */11,
                                                              _0: "This module is not a structure; it has type",
                                                              _1: {
                                                                TAG: /* Formatting_lit */17,
                                                                _0: {
                                                                  TAG: /* Break */0,
                                                                  _0: "@ ",
                                                                  _1: 1,
                                                                  _2: 0
                                                                },
                                                                _1: {
                                                                  TAG: /* Alpha */15,
                                                                  _0: /* End_of_format */0
                                                                }
                                                              }
                                                            }
                                                          },
                                                          _1: "@[This module is not a structure; it has type@ %a"
                                                        }), modtype$1, param$1._0);
                                      case /* With_no_component */4 :
                                          return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* Formatting_gen */18,
                                                            _0: {
                                                              TAG: /* Open_box */1,
                                                              _0: /* Format */{
                                                                _0: /* End_of_format */0,
                                                                _1: ""
                                                              }
                                                            },
                                                            _1: {
                                                              TAG: /* String_literal */11,
                                                              _0: "The signature constrained by `with' has no component named ",
                                                              _1: {
                                                                TAG: /* Alpha */15,
                                                                _0: {
                                                                  TAG: /* Formatting_lit */17,
                                                                  _0: /* Close_box */0,
                                                                  _1: /* End_of_format */0
                                                                }
                                                              }
                                                            }
                                                          },
                                                          _1: "@[The signature constrained by `with' has no component named %a@]"
                                                        }), longident, param$1._0);
                                      case /* With_mismatch */5 :
                                          return Curry._4(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* Formatting_gen */18,
                                                            _0: {
                                                              TAG: /* Open_box */1,
                                                              _0: /* Format */{
                                                                _0: {
                                                                  TAG: /* String_literal */11,
                                                                  _0: "<v>",
                                                                  _1: /* End_of_format */0
                                                                },
                                                                _1: "<v>"
                                                              }
                                                            },
                                                            _1: {
                                                              TAG: /* Formatting_gen */18,
                                                              _0: {
                                                                TAG: /* Open_box */1,
                                                                _0: /* Format */{
                                                                  _0: /* End_of_format */0,
                                                                  _1: ""
                                                                }
                                                              },
                                                              _1: {
                                                                TAG: /* String_literal */11,
                                                                _0: "In this `with' constraint, the new definition of ",
                                                                _1: {
                                                                  TAG: /* Alpha */15,
                                                                  _0: {
                                                                    TAG: /* Formatting_lit */17,
                                                                    _0: {
                                                                      TAG: /* Break */0,
                                                                      _0: "@ ",
                                                                      _1: 1,
                                                                      _2: 0
                                                                    },
                                                                    _1: {
                                                                      TAG: /* String_literal */11,
                                                                      _0: "does not match its original definition",
                                                                      _1: {
                                                                        TAG: /* Formatting_lit */17,
                                                                        _0: {
                                                                          TAG: /* Break */0,
                                                                          _0: "@ ",
                                                                          _1: 1,
                                                                          _2: 0
                                                                        },
                                                                        _1: {
                                                                          TAG: /* String_literal */11,
                                                                          _0: "in the constrained signature:",
                                                                          _1: {
                                                                            TAG: /* Formatting_lit */17,
                                                                            _0: /* Close_box */0,
                                                                            _1: {
                                                                              TAG: /* Formatting_lit */17,
                                                                              _0: {
                                                                                TAG: /* Break */0,
                                                                                _0: "@ ",
                                                                                _1: 1,
                                                                                _2: 0
                                                                              },
                                                                              _1: {
                                                                                TAG: /* Alpha */15,
                                                                                _0: {
                                                                                  TAG: /* Formatting_lit */17,
                                                                                  _0: /* Close_box */0,
                                                                                  _1: /* End_of_format */0
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          },
                                                          _1: "@[<v>@[In this `with' constraint, the new definition of %a@ does not match its original definition@ in the constrained signature:@]@ %a@]"
                                                        }), longident, param$1._0, report_error$4, param$1._1);
                                      case /* Repeated_name */6 :
                                          return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* Formatting_gen */18,
                                                            _0: {
                                                              TAG: /* Open_box */1,
                                                              _0: /* Format */{
                                                                _0: /* End_of_format */0,
                                                                _1: ""
                                                              }
                                                            },
                                                            _1: {
                                                              TAG: /* String_literal */11,
                                                              _0: "Multiple definition of the ",
                                                              _1: {
                                                                TAG: /* String */2,
                                                                _0: /* No_padding */0,
                                                                _1: {
                                                                  TAG: /* String_literal */11,
                                                                  _0: " name ",
                                                                  _1: {
                                                                    TAG: /* String */2,
                                                                    _0: /* No_padding */0,
                                                                    _1: {
                                                                      TAG: /* Char_literal */12,
                                                                      _0: /* '.' */46,
                                                                      _1: {
                                                                        TAG: /* Formatting_lit */17,
                                                                        _0: {
                                                                          TAG: /* Break */0,
                                                                          _0: "@ ",
                                                                          _1: 1,
                                                                          _2: 0
                                                                        },
                                                                        _1: {
                                                                          TAG: /* String_literal */11,
                                                                          _0: "Names must be unique in a given structure or signature.",
                                                                          _1: {
                                                                            TAG: /* Formatting_lit */17,
                                                                            _0: /* Close_box */0,
                                                                            _1: /* End_of_format */0
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          },
                                                          _1: "@[Multiple definition of the %s name %s.@ Names must be unique in a given structure or signature.@]"
                                                        }), param$1._0, param$1._1);
                                      case /* Non_generalizable */7 :
                                          return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* Formatting_gen */18,
                                                            _0: {
                                                              TAG: /* Open_box */1,
                                                              _0: /* Format */{
                                                                _0: /* End_of_format */0,
                                                                _1: ""
                                                              }
                                                            },
                                                            _1: {
                                                              TAG: /* String_literal */11,
                                                              _0: "The type of this expression,",
                                                              _1: {
                                                                TAG: /* Formatting_lit */17,
                                                                _0: {
                                                                  TAG: /* Break */0,
                                                                  _0: "@ ",
                                                                  _1: 1,
                                                                  _2: 0
                                                                },
                                                                _1: {
                                                                  TAG: /* Alpha */15,
                                                                  _0: {
                                                                    TAG: /* Char_literal */12,
                                                                    _0: /* ',' */44,
                                                                    _1: {
                                                                      TAG: /* Formatting_lit */17,
                                                                      _0: {
                                                                        TAG: /* Break */0,
                                                                        _0: "@ ",
                                                                        _1: 1,
                                                                        _2: 0
                                                                      },
                                                                      _1: {
                                                                        TAG: /* String_literal */11,
                                                                        _0: "contains type variables that cannot be generalized",
                                                                        _1: {
                                                                          TAG: /* Formatting_lit */17,
                                                                          _0: /* Close_box */0,
                                                                          _1: /* End_of_format */0
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          },
                                                          _1: "@[The type of this expression,@ %a,@ contains type variables that cannot be generalized@]"
                                                        }), type_scheme, param$1._0);
                                      case /* Non_generalizable_class */8 :
                                          const id = param$1._0;
                                          return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* Formatting_gen */18,
                                                            _0: {
                                                              TAG: /* Open_box */1,
                                                              _0: /* Format */{
                                                                _0: /* End_of_format */0,
                                                                _1: ""
                                                              }
                                                            },
                                                            _1: {
                                                              TAG: /* String_literal */11,
                                                              _0: "The type of this class,",
                                                              _1: {
                                                                TAG: /* Formatting_lit */17,
                                                                _0: {
                                                                  TAG: /* Break */0,
                                                                  _0: "@ ",
                                                                  _1: 1,
                                                                  _2: 0
                                                                },
                                                                _1: {
                                                                  TAG: /* Alpha */15,
                                                                  _0: {
                                                                    TAG: /* Char_literal */12,
                                                                    _0: /* ',' */44,
                                                                    _1: {
                                                                      TAG: /* Formatting_lit */17,
                                                                      _0: {
                                                                        TAG: /* Break */0,
                                                                        _0: "@ ",
                                                                        _1: 1,
                                                                        _2: 0
                                                                      },
                                                                      _1: {
                                                                        TAG: /* String_literal */11,
                                                                        _0: "contains type variables that cannot be generalized",
                                                                        _1: {
                                                                          TAG: /* Formatting_lit */17,
                                                                          _0: /* Close_box */0,
                                                                          _1: /* End_of_format */0
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          },
                                                          _1: "@[The type of this class,@ %a,@ contains type variables that cannot be generalized@]"
                                                        }), (function (param, param$1) {
                                                        return class_declaration$1(id, param, param$1);
                                                      }), param$1._1);
                                      case /* Non_generalizable_module */9 :
                                          return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* Formatting_gen */18,
                                                            _0: {
                                                              TAG: /* Open_box */1,
                                                              _0: /* Format */{
                                                                _0: /* End_of_format */0,
                                                                _1: ""
                                                              }
                                                            },
                                                            _1: {
                                                              TAG: /* String_literal */11,
                                                              _0: "The type of this module,",
                                                              _1: {
                                                                TAG: /* Formatting_lit */17,
                                                                _0: {
                                                                  TAG: /* Break */0,
                                                                  _0: "@ ",
                                                                  _1: 1,
                                                                  _2: 0
                                                                },
                                                                _1: {
                                                                  TAG: /* Alpha */15,
                                                                  _0: {
                                                                    TAG: /* Char_literal */12,
                                                                    _0: /* ',' */44,
                                                                    _1: {
                                                                      TAG: /* Formatting_lit */17,
                                                                      _0: {
                                                                        TAG: /* Break */0,
                                                                        _0: "@ ",
                                                                        _1: 1,
                                                                        _2: 0
                                                                      },
                                                                      _1: {
                                                                        TAG: /* String_literal */11,
                                                                        _0: "contains type variables that cannot be generalized",
                                                                        _1: {
                                                                          TAG: /* Formatting_lit */17,
                                                                          _0: /* Close_box */0,
                                                                          _1: /* End_of_format */0
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          },
                                                          _1: "@[The type of this module,@ %a,@ contains type variables that cannot be generalized@]"
                                                        }), modtype$1, param$1._0);
                                      case /* Implementation_is_required */10 :
                                          return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* Formatting_gen */18,
                                                            _0: {
                                                              TAG: /* Open_box */1,
                                                              _0: /* Format */{
                                                                _0: /* End_of_format */0,
                                                                _1: ""
                                                              }
                                                            },
                                                            _1: {
                                                              TAG: /* String_literal */11,
                                                              _0: "The interface ",
                                                              _1: {
                                                                TAG: /* Alpha */15,
                                                                _0: {
                                                                  TAG: /* Formatting_lit */17,
                                                                  _0: {
                                                                    TAG: /* Break */0,
                                                                    _0: "@ ",
                                                                    _1: 1,
                                                                    _2: 0
                                                                  },
                                                                  _1: {
                                                                    TAG: /* String_literal */11,
                                                                    _0: "declares values, not just types.",
                                                                    _1: {
                                                                      TAG: /* Formatting_lit */17,
                                                                      _0: {
                                                                        TAG: /* Break */0,
                                                                        _0: "@ ",
                                                                        _1: 1,
                                                                        _2: 0
                                                                      },
                                                                      _1: {
                                                                        TAG: /* String_literal */11,
                                                                        _0: "An implementation must be provided.",
                                                                        _1: {
                                                                          TAG: /* Formatting_lit */17,
                                                                          _0: /* Close_box */0,
                                                                          _1: /* End_of_format */0
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          },
                                                          _1: "@[The interface %a@ declares values, not just types.@ An implementation must be provided.@]"
                                                        }), print_filename, param$1._0);
                                      case /* Interface_not_compiled */11 :
                                          return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* Formatting_gen */18,
                                                            _0: {
                                                              TAG: /* Open_box */1,
                                                              _0: /* Format */{
                                                                _0: /* End_of_format */0,
                                                                _1: ""
                                                              }
                                                            },
                                                            _1: {
                                                              TAG: /* String_literal */11,
                                                              _0: "Could not find the .cmi file for interface",
                                                              _1: {
                                                                TAG: /* Formatting_lit */17,
                                                                _0: {
                                                                  TAG: /* Break */0,
                                                                  _0: "@ ",
                                                                  _1: 1,
                                                                  _2: 0
                                                                },
                                                                _1: {
                                                                  TAG: /* Alpha */15,
                                                                  _0: {
                                                                    TAG: /* Char_literal */12,
                                                                    _0: /* '.' */46,
                                                                    _1: {
                                                                      TAG: /* Formatting_lit */17,
                                                                      _0: /* Close_box */0,
                                                                      _1: /* End_of_format */0
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          },
                                                          _1: "@[Could not find the .cmi file for interface@ %a.@]"
                                                        }), print_filename, param$1._0);
                                      case /* Not_a_packed_module */12 :
                                          return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* String_literal */11,
                                                            _0: "This expression is not a packed module. It has type",
                                                            _1: {
                                                              TAG: /* Formatting_lit */17,
                                                              _0: {
                                                                TAG: /* Break */0,
                                                                _0: "@ ",
                                                                _1: 1,
                                                                _2: 0
                                                              },
                                                              _1: {
                                                                TAG: /* Alpha */15,
                                                                _0: /* End_of_format */0
                                                              }
                                                            }
                                                          },
                                                          _1: "This expression is not a packed module. It has type@ %a"
                                                        }), type_expr$1, param$1._0);
                                      case /* Incomplete_packed_module */13 :
                                          return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* String_literal */11,
                                                            _0: "The type of this packed module contains variables:",
                                                            _1: {
                                                              TAG: /* Formatting_lit */17,
                                                              _0: {
                                                                TAG: /* Break */0,
                                                                _0: "@ ",
                                                                _1: 1,
                                                                _2: 0
                                                              },
                                                              _1: {
                                                                TAG: /* Alpha */15,
                                                                _0: /* End_of_format */0
                                                              }
                                                            }
                                                          },
                                                          _1: "The type of this packed module contains variables:@ %a"
                                                        }), type_expr$1, param$1._0);
                                      case /* Scoping_pack */14 :
                                          Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                    _0: {
                                                      TAG: /* String_literal */11,
                                                      _0: "The type ",
                                                      _1: {
                                                        TAG: /* Alpha */15,
                                                        _0: {
                                                          TAG: /* String_literal */11,
                                                          _0: " in this module cannot be exported.",
                                                          _1: {
                                                            TAG: /* Formatting_lit */17,
                                                            _0: {
                                                              TAG: /* Break */0,
                                                              _0: "@ ",
                                                              _1: 1,
                                                              _2: 0
                                                            },
                                                            _1: /* End_of_format */0
                                                          }
                                                        }
                                                      }
                                                    },
                                                    _1: "The type %a in this module cannot be exported.@ "
                                                  }), longident, param$1._0);
                                          return Curry._2(Stdlib__Format.fprintf(param)(/* Format */{
                                                          _0: {
                                                            TAG: /* String_literal */11,
                                                            _0: "Its type contains local dependencies:",
                                                            _1: {
                                                              TAG: /* Formatting_lit */17,
                                                              _0: {
                                                                TAG: /* Break */0,
                                                                _0: "@ ",
                                                                _1: 1,
                                                                _2: 0
                                                              },
                                                              _1: {
                                                                TAG: /* Alpha */15,
                                                                _0: /* End_of_format */0
                                                              }
                                                            }
                                                          },
                                                          _1: "Its type contains local dependencies:@ %a"
                                                        }), type_expr$1, param$1._1);
                                      
                                    }
                                  }
                                }));
                  }), err._3);
    });

const suites = {
  contents: /* [] */0
};

const test_id = {
  contents: 0
};

function eq(loc, x, y) {
  test_id.contents = test_id.contents + 1 | 0;
  suites.contents = {
    hd: [
      loc + (" id " + String(test_id.contents)),
      (function (param) {
          return {
                  TAG: /* Eq */0,
                  _0: x,
                  _1: y
                };
        })
    ],
    tl: suites.contents
  };
}

dont_write_files.contents = true;

unsafe_string = false;

debug = true;

record_event_when_debug = false;

binary_annotations.contents = false;

nopervasives = true;

assume_no_mli.contents = /* Mli_non_exists */2;

const modulename = "Test";

const x = type_implementation(modulename, modulename, modulename, empty, wrap$1(implementation, Stdlib__Lexing.from_string(undefined, "\ntype int\nexternal ( ~- ) : int -> int = \"%negint\"\nexternal ( ~+ ) : int -> int = \"%identity\"\nexternal succ : int -> int = \"%succint\"\nexternal pred : int -> int = \"%predint\"\nexternal ( + ) : int -> int -> int = \"%addint\"\nexternal ( - ) : int -> int -> int = \"%subint\"\nexternal ( * ) : int -> int -> int = \"%mulint\"\nexternal ( / ) : int -> int -> int = \"%divint\"\nexternal ( mod ) : int -> int -> int = \"%modint\"\n let f x y = x + y")));

const match$1 = x[0].str_items;

if (match$1) {
  const match$2 = match$1.hd;
  const match$3 = match$2.str_desc;
  if (match$3.TAG === /* Tstr_type */3) {
    const match$4 = match$3._0;
    if (match$4) {
      const match$5 = match$4.hd;
      const match$6 = match$5.typ_id;
      if (match$6.name === "int") {
        const match$7 = match$6.flags;
        if (match$7 !== 0) {
          eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
        } else {
          const match$8 = match$5.typ_name;
          if (match$8.txt === "int") {
            const match$9 = match$8.loc;
            const match$10 = match$9.loc_start;
            if (match$10.pos_fname === "" && !(match$10.pos_lnum !== 2 || match$10.pos_bol !== 1 || match$10.pos_cnum !== 6)) {
              const match$11 = match$9.loc_end;
              if (match$11.pos_fname === "" && !(match$11.pos_lnum !== 2 || match$11.pos_bol !== 1 || match$11.pos_cnum !== 9 || match$9.loc_ghost || match$5.typ_params)) {
                const match$12 = match$5.typ_type;
                if (match$12.type_params || match$12.type_arity !== 0) {
                  eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                } else {
                  const match$13 = match$12.type_kind;
                  if (typeof match$13 === "number" && !(match$13 || !(match$12.type_private && !(match$12.type_manifest !== undefined || match$12.type_variance || match$12.type_newtype_level !== undefined)))) {
                    const match$14 = match$12.type_loc;
                    const match$15 = match$14.loc_start;
                    if (match$15.pos_fname === "" && !(match$15.pos_lnum !== 2 || match$15.pos_bol !== 1 || match$15.pos_cnum !== 1)) {
                      const match$16 = match$14.loc_end;
                      if (match$16.pos_fname === "" && !(match$16.pos_lnum !== 2 || match$16.pos_bol !== 1 || match$16.pos_cnum !== 9 || match$14.loc_ghost || match$12.type_attributes || match$5.typ_cstrs)) {
                        const match$17 = match$5.typ_kind;
                        if (typeof match$17 === "number" && !(match$17 || !(match$5.typ_private && match$5.typ_manifest === undefined))) {
                          const match$18 = match$5.typ_loc;
                          const match$19 = match$18.loc_start;
                          if (match$19.pos_fname === "" && !(match$19.pos_lnum !== 2 || match$19.pos_bol !== 1 || match$19.pos_cnum !== 1)) {
                            const match$20 = match$18.loc_end;
                            if (match$20.pos_fname === "" && !(match$20.pos_lnum !== 2 || match$20.pos_bol !== 1 || match$20.pos_cnum !== 9 || match$18.loc_ghost || match$5.typ_attributes || match$4.tl)) {
                              const match$21 = match$2.str_loc;
                              const match$22 = match$21.loc_start;
                              if (match$22.pos_fname === "" && !(match$22.pos_lnum !== 2 || match$22.pos_bol !== 1 || match$22.pos_cnum !== 1)) {
                                const match$23 = match$21.loc_end;
                                if (match$23.pos_fname === "" && !(match$23.pos_lnum !== 2 || match$23.pos_bol !== 1 || match$23.pos_cnum !== 9 || match$21.loc_ghost)) {
                                  const match$24 = match$1.tl;
                                  if (match$24) {
                                    const match$25 = match$24.hd.str_desc;
                                    if (match$25.TAG === /* Tstr_primitive */2) {
                                      const match$26 = match$25._0;
                                      const match$27 = match$26.val_id;
                                      if (match$27.name === "~-") {
                                        const match$28 = match$27.flags;
                                        if (match$28 !== 0) {
                                          eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                        } else {
                                          const match$29 = match$26.val_name;
                                          if (match$29.txt === "~-") {
                                            const match$30 = match$29.loc;
                                            const match$31 = match$30.loc_start;
                                            if (match$31.pos_fname === "" && !(match$31.pos_lnum !== 3 || match$31.pos_bol !== 10 || match$31.pos_cnum !== 19)) {
                                              const match$32 = match$30.loc_end;
                                              if (match$32.pos_fname === "" && !(match$32.pos_lnum !== 3 || match$32.pos_bol !== 10 || match$32.pos_cnum !== 25 || match$30.loc_ghost)) {
                                                const match$33 = match$26.val_desc;
                                                const match$34 = match$33.ctyp_desc;
                                                if (typeof match$34 === "number" || !(match$34.TAG === /* Ttyp_arrow */1 && match$34._0 === "")) {
                                                  eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                } else {
                                                  const match$35 = match$34._1;
                                                  const match$36 = match$35.ctyp_desc;
                                                  if (typeof match$36 === "number" || match$36.TAG !== /* Ttyp_constr */3) {
                                                    eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                  } else {
                                                    const match$37 = match$36._0;
                                                    switch (match$37.TAG | 0) {
                                                      case /* Pident */0 :
                                                          const match$38 = match$37._0;
                                                          if (match$38.name === "int") {
                                                            const match$39 = match$38.flags;
                                                            if (match$39 !== 0) {
                                                              eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                            } else {
                                                              const match$40 = match$36._1;
                                                              const match$41 = match$40.txt;
                                                              switch (match$41.TAG | 0) {
                                                                case /* Lident */0 :
                                                                    if (match$41._0 === "int") {
                                                                      const match$42 = match$40.loc;
                                                                      const match$43 = match$42.loc_start;
                                                                      if (match$43.pos_fname === "" && !(match$43.pos_lnum !== 3 || match$43.pos_bol !== 10 || match$43.pos_cnum !== 28)) {
                                                                        const match$44 = match$42.loc_end;
                                                                        if (match$44.pos_fname === "" && !(match$44.pos_lnum !== 3 || match$44.pos_bol !== 10 || match$44.pos_cnum !== 31 || match$42.loc_ghost || match$36._2)) {
                                                                          const match$45 = match$35.ctyp_type;
                                                                          const match$46 = match$45.desc;
                                                                          if (typeof match$46 === "number" || match$46.TAG !== /* Tconstr */3) {
                                                                            eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                          } else {
                                                                            const match$47 = match$46._0;
                                                                            switch (match$47.TAG | 0) {
                                                                              case /* Pident */0 :
                                                                                  const match$48 = match$47._0;
                                                                                  if (match$48.name === "int") {
                                                                                    const match$49 = match$48.flags;
                                                                                    if (match$49 !== 0 || match$46._1) {
                                                                                      eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                    } else {
                                                                                      const match$50 = match$46._2.contents;
                                                                                      if (typeof match$50 === "number") {
                                                                                        const match$51 = match$35.ctyp_loc;
                                                                                        const match$52 = match$51.loc_start;
                                                                                        if (match$52.pos_fname === "" && !(match$52.pos_lnum !== 3 || match$52.pos_bol !== 10 || match$52.pos_cnum !== 28)) {
                                                                                          const match$53 = match$51.loc_end;
                                                                                          if (match$53.pos_fname === "" && !(match$53.pos_lnum !== 3 || match$53.pos_bol !== 10 || match$53.pos_cnum !== 31 || match$51.loc_ghost || match$35.ctyp_attributes)) {
                                                                                            const match$54 = match$34._2;
                                                                                            const match$55 = match$54.ctyp_desc;
                                                                                            if (typeof match$55 === "number" || match$55.TAG !== /* Ttyp_constr */3) {
                                                                                              eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                            } else {
                                                                                              const match$56 = match$55._0;
                                                                                              switch (match$56.TAG | 0) {
                                                                                                case /* Pident */0 :
                                                                                                    const match$57 = match$56._0;
                                                                                                    if (match$57.name === "int") {
                                                                                                      const match$58 = match$57.flags;
                                                                                                      if (match$58 !== 0) {
                                                                                                        eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                      } else {
                                                                                                        const match$59 = match$55._1;
                                                                                                        const match$60 = match$59.txt;
                                                                                                        switch (match$60.TAG | 0) {
                                                                                                          case /* Lident */0 :
                                                                                                              if (match$60._0 === "int") {
                                                                                                                const match$61 = match$59.loc;
                                                                                                                const match$62 = match$61.loc_start;
                                                                                                                if (match$62.pos_fname === "" && !(match$62.pos_lnum !== 3 || match$62.pos_bol !== 10 || match$62.pos_cnum !== 35)) {
                                                                                                                  const match$63 = match$61.loc_end;
                                                                                                                  if (match$63.pos_fname === "" && !(match$63.pos_lnum !== 3 || match$63.pos_bol !== 10 || match$63.pos_cnum !== 38 || match$61.loc_ghost || match$55._2)) {
                                                                                                                    const match$64 = match$54.ctyp_type;
                                                                                                                    const match$65 = match$64.desc;
                                                                                                                    if (typeof match$65 === "number" || match$65.TAG !== /* Tconstr */3) {
                                                                                                                      eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                    } else {
                                                                                                                      const match$66 = match$65._0;
                                                                                                                      switch (match$66.TAG | 0) {
                                                                                                                        case /* Pident */0 :
                                                                                                                            const match$67 = match$66._0;
                                                                                                                            if (match$67.name === "int") {
                                                                                                                              const match$68 = match$67.flags;
                                                                                                                              if (match$68 !== 0 || match$65._1) {
                                                                                                                                eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                              } else {
                                                                                                                                const match$69 = match$65._2.contents;
                                                                                                                                if (typeof match$69 === "number") {
                                                                                                                                  const match$70 = match$54.ctyp_loc;
                                                                                                                                  const match$71 = match$70.loc_start;
                                                                                                                                  if (match$71.pos_fname === "" && !(match$71.pos_lnum !== 3 || match$71.pos_bol !== 10 || match$71.pos_cnum !== 35)) {
                                                                                                                                    const match$72 = match$70.loc_end;
                                                                                                                                    if (match$72.pos_fname === "" && !(match$72.pos_lnum !== 3 || match$72.pos_bol !== 10 || match$72.pos_cnum !== 38 || match$70.loc_ghost || match$54.ctyp_attributes)) {
                                                                                                                                      const match$73 = match$33.ctyp_type;
                                                                                                                                      const match$74 = match$73.desc;
                                                                                                                                      if (typeof match$74 === "number" || !(match$74.TAG === /* Tarrow */1 && match$74._0 === "")) {
                                                                                                                                        eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                                      } else {
                                                                                                                                        const match$75 = match$74._1.desc;
                                                                                                                                        if (typeof match$75 === "number" || match$75.TAG !== /* Tconstr */3) {
                                                                                                                                          eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                                        } else {
                                                                                                                                          const match$76 = match$75._0;
                                                                                                                                          switch (match$76.TAG | 0) {
                                                                                                                                            case /* Pident */0 :
                                                                                                                                                const match$77 = match$76._0;
                                                                                                                                                if (match$77.name === "int") {
                                                                                                                                                  const match$78 = match$77.flags;
                                                                                                                                                  if (match$78 !== 0 || match$75._1) {
                                                                                                                                                    eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                                                  } else {
                                                                                                                                                    const match$79 = match$75._2.contents;
                                                                                                                                                    if (typeof match$79 === "number") {
                                                                                                                                                      const match$80 = match$74._2.desc;
                                                                                                                                                      if (typeof match$80 === "number" || match$80.TAG !== /* Tconstr */3) {
                                                                                                                                                        eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                                                      } else {
                                                                                                                                                        const match$81 = match$80._0;
                                                                                                                                                        switch (match$81.TAG | 0) {
                                                                                                                                                          case /* Pident */0 :
                                                                                                                                                              const match$82 = match$81._0;
                                                                                                                                                              if (match$82.name === "int") {
                                                                                                                                                                const match$83 = match$82.flags;
                                                                                                                                                                if (match$83 !== 0 || match$80._1) {
                                                                                                                                                                  eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                                                                } else {
                                                                                                                                                                  const match$84 = match$80._2.contents;
                                                                                                                                                                  if (typeof match$84 === "number") {
                                                                                                                                                                    const match$85 = match$74._3;
                                                                                                                                                                    if (typeof match$85 === "number" && !match$85) {
                                                                                                                                                                      const match$86 = match$33.ctyp_loc;
                                                                                                                                                                      const match$87 = match$86.loc_start;
                                                                                                                                                                      if (match$87.pos_fname === "" && !(match$87.pos_lnum !== 3 || match$87.pos_bol !== 10 || match$87.pos_cnum !== 28)) {
                                                                                                                                                                        const match$88 = match$86.loc_end;
                                                                                                                                                                        if (match$88.pos_fname === "" && !(match$88.pos_lnum !== 3 || match$88.pos_bol !== 10 || match$88.pos_cnum !== 38 || match$86.loc_ghost || match$33.ctyp_attributes)) {
                                                                                                                                                                          const match$89 = match$26.val_val;
                                                                                                                                                                          const match$90 = match$89.val_type.desc;
                                                                                                                                                                          if (typeof match$90 === "number" || !(match$90.TAG === /* Tarrow */1 && match$90._0 === "")) {
                                                                                                                                                                            eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                                                                          } else {
                                                                                                                                                                            const match$91 = match$90._1.desc;
                                                                                                                                                                            if (typeof match$91 === "number" || match$91.TAG !== /* Tconstr */3) {
                                                                                                                                                                              eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                                                                            } else {
                                                                                                                                                                              const match$92 = match$91._0;
                                                                                                                                                                              switch (match$92.TAG | 0) {
                                                                                                                                                                                case /* Pident */0 :
                                                                                                                                                                                    const match$93 = match$92._0;
                                                                                                                                                                                    if (match$93.name === "int") {
                                                                                                                                                                                      const match$94 = match$93.flags;
                                                                                                                                                                                      if (match$94 !== 0 || match$91._1) {
                                                                                                                                                                                        eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                                                                                      } else {
                                                                                                                                                                                        const match$95 = match$91._2.contents;
                                                                                                                                                                                        if (typeof match$95 === "number") {
                                                                                                                                                                                          const match$96 = match$90._2.desc;
                                                                                                                                                                                          if (typeof match$96 === "number" || match$96.TAG !== /* Tconstr */3) {
                                                                                                                                                                                            eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                                                                                          } else {
                                                                                                                                                                                            const match$97 = match$96._0;
                                                                                                                                                                                            switch (match$97.TAG | 0) {
                                                                                                                                                                                              case /* Pident */0 :
                                                                                                                                                                                                  const match$98 = match$97._0;
                                                                                                                                                                                                  if (match$98.name === "int") {
                                                                                                                                                                                                    const match$99 = match$98.flags;
                                                                                                                                                                                                    if (match$99 !== 0 || match$96._1) {
                                                                                                                                                                                                      eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                                                                                                    } else {
                                                                                                                                                                                                      const match$100 = match$96._2.contents;
                                                                                                                                                                                                      if (typeof match$100 === "number") {
                                                                                                                                                                                                        const match$101 = match$90._3;
                                                                                                                                                                                                        if (typeof match$101 === "number" && !match$101) {
                                                                                                                                                                                                          const match$102 = match$89.val_kind;
                                                                                                                                                                                                          if (typeof match$102 === "number" || match$102.TAG !== /* Val_prim */0) {
                                                                                                                                                                                                            eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                                                                                                          } else {
                                                                                                                                                                                                            const match$103 = match$102._0;
                                                                                                                                                                                                            if (match$103.prim_name === "%negint" && !(match$103.prim_arity !== 1 || !(match$103.prim_alloc && match$103.prim_native_name === "" && !match$103.prim_native_float))) {
                                                                                                                                                                                                              const match$104 = match$89.val_loc;
                                                                                                                                                                                                              const match$105 = match$104.loc_start;
                                                                                                                                                                                                              if (match$105.pos_fname === "" && !(match$105.pos_lnum !== 3 || match$105.pos_bol !== 10 || match$105.pos_cnum !== 10)) {
                                                                                                                                                                                                                const match$106 = match$104.loc_end;
                                                                                                                                                                                                                if (match$106.pos_fname === "" && !(match$106.pos_lnum !== 3 || match$106.pos_bol !== 10 || match$106.pos_cnum !== 50 || match$104.loc_ghost || match$89.val_attributes)) {
                                                                                                                                                                                                                  eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52028, characters 14-21", true, true);
                                                                                                                                                                                                                } else {
                                                                                                                                                                                                                  eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                                                                                                                }
                                                                                                                                                                                                              } else {
                                                                                                                                                                                                                eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                                                                                                              }
                                                                                                                                                                                                            } else {
                                                                                                                                                                                                              eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                                                                                                            }
                                                                                                                                                                                                          }
                                                                                                                                                                                                        } else {
                                                                                                                                                                                                          eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                                                                                                        }
                                                                                                                                                                                                      } else {
                                                                                                                                                                                                        eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                                                                                                      }
                                                                                                                                                                                                    }
                                                                                                                                                                                                  } else {
                                                                                                                                                                                                    eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                                                                                                  }
                                                                                                                                                                                                  break;
                                                                                                                                                                                              case /* Pdot */1 :
                                                                                                                                                                                              case /* Papply */2 :
                                                                                                                                                                                                  eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                                                                                                  break;
                                                                                                                                                                                              
                                                                                                                                                                                            }
                                                                                                                                                                                          }
                                                                                                                                                                                        } else {
                                                                                                                                                                                          eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                                                                                        }
                                                                                                                                                                                      }
                                                                                                                                                                                    } else {
                                                                                                                                                                                      eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                                                                                    }
                                                                                                                                                                                    break;
                                                                                                                                                                                case /* Pdot */1 :
                                                                                                                                                                                case /* Papply */2 :
                                                                                                                                                                                    eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                                                                                    break;
                                                                                                                                                                                
                                                                                                                                                                              }
                                                                                                                                                                            }
                                                                                                                                                                          }
                                                                                                                                                                        } else {
                                                                                                                                                                          eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                                                                        }
                                                                                                                                                                      } else {
                                                                                                                                                                        eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                                                                      }
                                                                                                                                                                    } else {
                                                                                                                                                                      eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                                                                    }
                                                                                                                                                                  } else {
                                                                                                                                                                    eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                                                                  }
                                                                                                                                                                }
                                                                                                                                                              } else {
                                                                                                                                                                eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                                                              }
                                                                                                                                                              break;
                                                                                                                                                          case /* Pdot */1 :
                                                                                                                                                          case /* Papply */2 :
                                                                                                                                                              eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                                                              break;
                                                                                                                                                          
                                                                                                                                                        }
                                                                                                                                                      }
                                                                                                                                                    } else {
                                                                                                                                                      eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                                                    }
                                                                                                                                                  }
                                                                                                                                                } else {
                                                                                                                                                  eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                                                }
                                                                                                                                                break;
                                                                                                                                            case /* Pdot */1 :
                                                                                                                                            case /* Papply */2 :
                                                                                                                                                eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                                                break;
                                                                                                                                            
                                                                                                                                          }
                                                                                                                                        }
                                                                                                                                      }
                                                                                                                                    } else {
                                                                                                                                      eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                                    }
                                                                                                                                  } else {
                                                                                                                                    eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                                  }
                                                                                                                                } else {
                                                                                                                                  eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                                }
                                                                                                                              }
                                                                                                                            } else {
                                                                                                                              eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                            }
                                                                                                                            break;
                                                                                                                        case /* Pdot */1 :
                                                                                                                        case /* Papply */2 :
                                                                                                                            eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                            break;
                                                                                                                        
                                                                                                                      }
                                                                                                                    }
                                                                                                                  } else {
                                                                                                                    eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                  }
                                                                                                                } else {
                                                                                                                  eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                                }
                                                                                                              } else {
                                                                                                                eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                              }
                                                                                                              break;
                                                                                                          case /* Ldot */1 :
                                                                                                          case /* Lapply */2 :
                                                                                                              eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                              break;
                                                                                                          
                                                                                                        }
                                                                                                      }
                                                                                                    } else {
                                                                                                      eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                    }
                                                                                                    break;
                                                                                                case /* Pdot */1 :
                                                                                                case /* Papply */2 :
                                                                                                    eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                                    break;
                                                                                                
                                                                                              }
                                                                                            }
                                                                                          } else {
                                                                                            eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                          }
                                                                                        } else {
                                                                                          eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                        }
                                                                                      } else {
                                                                                        eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                      }
                                                                                    }
                                                                                  } else {
                                                                                    eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                  }
                                                                                  break;
                                                                              case /* Pdot */1 :
                                                                              case /* Papply */2 :
                                                                                  eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                                  break;
                                                                              
                                                                            }
                                                                          }
                                                                        } else {
                                                                          eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                        }
                                                                      } else {
                                                                        eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                      }
                                                                    } else {
                                                                      eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                    }
                                                                    break;
                                                                case /* Ldot */1 :
                                                                case /* Lapply */2 :
                                                                    eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                                    break;
                                                                
                                                              }
                                                            }
                                                          } else {
                                                            eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                          }
                                                          break;
                                                      case /* Pdot */1 :
                                                      case /* Papply */2 :
                                                          eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                                          break;
                                                      
                                                    }
                                                  }
                                                }
                                              } else {
                                                eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                              }
                                            } else {
                                              eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                            }
                                          } else {
                                            eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                          }
                                        }
                                      } else {
                                        eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                      }
                                    } else {
                                      eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                    }
                                  } else {
                                    eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                  }
                                } else {
                                  eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                                }
                              } else {
                                eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                              }
                            } else {
                              eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                            }
                          } else {
                            eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                          }
                        } else {
                          eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                        }
                      } else {
                        eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                      }
                    } else {
                      eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                    }
                  } else {
                    eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
                  }
                }
              } else {
                eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
              }
            } else {
              eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
            }
          } else {
            eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
          }
        }
      } else {
        eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
      }
    } else {
      eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
    }
  } else {
    eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
  }
} else {
  eq("File \"jscomp/test/ocaml_typedtree_test.ml\", line 52029, characters 12-19", true, false);
}

from_pair_suites("Ocaml_typedtree_test", suites.contents);

/*  Not a pure module */
