// Generated by Melange
'use strict';

let Caml_array = require("melange.js/caml_array.js");
let Caml_js_exceptions = require("melange.js/caml_js_exceptions.js");
let Caml_obj = require("melange.js/caml_obj.js");
let Curry = require("melange.js/curry.js");
let Stdlib = require("melange/stdlib.js");
let Stdlib__Array = require("melange/array.js");
let Stdlib__Format = require("melange/format.js");

function sub(_tr, _k) {
  while(true) {
    const k = _k;
    const tr = _tr;
    if (tr) {
      if (k === 1) {
        return tr._0;
      }
      if (k % 2 === 0) {
        _k = k / 2 | 0;
        _tr = tr._1;
        continue ;
      }
      _k = k / 2 | 0;
      _tr = tr._2;
      continue ;
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
  };
}

function update(tr, k, w) {
  if (tr) {
    const r = tr._2;
    const l = tr._1;
    if (k === 1) {
      return /* Br */{
              _0: w,
              _1: l,
              _2: r
            };
    }
    const v = tr._0;
    if (k % 2 === 0) {
      return /* Br */{
              _0: v,
              _1: update(l, k / 2 | 0, w),
              _2: r
            };
    } else {
      return /* Br */{
              _0: v,
              _1: l,
              _2: update(r, k / 2 | 0, w)
            };
    }
  }
  if (k === 1) {
    return /* Br */{
            _0: w,
            _1: /* Lf */0,
            _2: /* Lf */0
          };
  }
  throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
}

function $$delete(tr, n) {
  if (tr) {
    if (n === 1) {
      return /* Lf */0;
    }
    const r = tr._2;
    const l = tr._1;
    const v = tr._0;
    if (n % 2 === 0) {
      return /* Br */{
              _0: v,
              _1: $$delete(l, n / 2 | 0),
              _2: r
            };
    } else {
      return /* Br */{
              _0: v,
              _1: l,
              _2: $$delete(r, n / 2 | 0)
            };
    }
  }
  throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
}

function loext(tr, w) {
  if (tr) {
    return /* Br */{
            _0: w,
            _1: loext(tr._2, tr._0),
            _2: tr._1
          };
  } else {
    return /* Br */{
            _0: w,
            _1: /* Lf */0,
            _2: /* Lf */0
          };
  }
}

function lorem(tr) {
  if (tr) {
    const l = tr._1;
    if (l) {
      return /* Br */{
              _0: l._0,
              _1: tr._2,
              _2: lorem(l)
            };
    }
    if (!tr._2) {
      return /* Lf */0;
    }
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/flexible_array_test.ml",
                66,
                9
              ]
            });
  }
  throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
}

const empty = [
  /* Lf */0,
  0
];

function length(param) {
  return param[1];
}

function get(param, i) {
  if (i >= 0 && i < param[1]) {
    return sub(param[0], i + 1 | 0);
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Array.get"
          });
}

function set(param, i, v) {
  const k = param[1];
  if (i >= 0 && i < k) {
    return [
            update(param[0], i + 1 | 0, v),
            k
          ];
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Array.set"
          });
}

function push_front(param, v) {
  return [
          loext(param[0], v),
          param[1] + 1 | 0
        ];
}

function pop_front(param) {
  const k = param[1];
  if (k > 0) {
    return [
            lorem(param[0]),
            k - 1 | 0
          ];
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Array.pop_front"
          });
}

function push_back(param, v) {
  const k = param[1];
  return [
          update(param[0], k + 1 | 0, v),
          k + 1 | 0
        ];
}

function pop_back(param) {
  const k = param[1];
  if (k > 0) {
    return [
            $$delete(param[0], k),
            k - 1 | 0
          ];
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Array.pop_back"
          });
}

function pp(fmt, s) {
  let v = "[ ";
  for(let i = 0 ,i_finish = length(s); i < i_finish; ++i){
    v = v + (", " + String(get(s, i)));
  }
  v = v + "]";
  Curry._1(Stdlib__Format.fprintf(fmt)(/* Format */{
            _0: {
              TAG: /* String */2,
              _0: /* No_padding */0,
              _1: /* End_of_format */0
            },
            _1: "%s"
          }), v);
}

function filter_from(i, p, s) {
  let u = empty;
  for(let i$1 = i ,i_finish = length(s); i$1 < i_finish; ++i$1){
    const ele = get(s, i$1);
    if (Curry._1(p, ele)) {
      u = push_back(u, ele);
    }
    
  }
  return u;
}

function append(a, b) {
  let empty$1 = empty;
  for(let i = 0 ,i_finish = length(a); i < i_finish; ++i){
    empty$1 = push_back(empty$1, get(a, i));
  }
  for(let i$1 = 0 ,i_finish$1 = length(b); i$1 < i_finish$1; ++i$1){
    empty$1 = push_back(empty$1, get(b, i$1));
  }
  return empty$1;
}

function sort(s) {
  const size = length(s);
  if (size <= 1) {
    return s;
  }
  const head = get(s, 0);
  const larger = sort(filter_from(1, (function (x) {
              return Caml_obj.caml_greaterthan(x, head);
            }), s));
  const smaller = sort(filter_from(1, (function (x) {
              return Caml_obj.caml_lessequal(x, head);
            }), s));
  return append(smaller, push_front(larger, head));
}

function of_array(arr) {
  let v = empty;
  for(let i = 0 ,i_finish = arr.length; i < i_finish; ++i){
    v = push_back(v, Caml_array.get(arr, i));
  }
  return v;
}

const equal = Caml_obj.caml_equal;

const Int_array = {
  empty: empty,
  get: get,
  set: set,
  push_front: push_front,
  pop_front: pop_front,
  push_back: push_back,
  pop_back: pop_back,
  pp: pp,
  append: append,
  sort: sort,
  of_array: of_array,
  equal: equal
};

function $eq$tilde(x, y) {
  return Caml_obj.caml_equal(x, of_array(y));
}

const u = of_array([
      1,
      2,
      2,
      5,
      3,
      6
    ]);

const x = sort(u);

if (!Caml_obj.caml_equal(x, of_array([
            1,
            2,
            2,
            3,
            5,
            6
          ]))) {
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/test/flexible_array_test.ml",
              166,
              4
            ]
          });
}

const v = Stdlib__Array.init(500, (function (i) {
        return 500 - i | 0;
      }));

const y = Stdlib__Array.init(500, (function (i) {
        return i + 1 | 0;
      }));

const x$1 = sort(of_array(v));

Caml_obj.caml_equal(x$1, of_array(y));

exports.sub = sub;
exports.update = update;
exports.$$delete = $$delete;
exports.loext = loext;
exports.lorem = lorem;
exports.Int_array = Int_array;
exports.$eq$tilde = $eq$tilde;
/* u Not a pure module */
