// Generated by Melange
'use strict';

const Caml = require("melange.js/caml.js");
const Caml_js_exceptions = require("melange.js/caml_js_exceptions.js");
const Set_gen = require("./set_gen.js");
const Stdlib = require("melange/stdlib.js");
const Stdlib__Array = require("melange/array.js");
const Stdlib__List = require("melange/list.js");
const Stdlib__String = require("melange/string.js");

function split(x, tree) {
  if (/* tag */ typeof tree === "number" || typeof tree === "string") {
    return [
      /* Empty */ 0,
      false,
      /* Empty */ 0
    ];
  }
  const r = tree._2;
  const v = tree._1;
  const l = tree._0;
  const c = Caml.caml_string_compare(x, v);
  if (c === 0) {
    return [
      l,
      true,
      r
    ];
  }
  if (c < 0) {
    const match = split(x, l);
    return [
      match[0],
      match[1],
      Set_gen.internal_join(match[2], v, r)
    ];
  }
  const match$1 = split(x, r);
  return [
    Set_gen.internal_join(l, v, match$1[0]),
    match$1[1],
    match$1[2]
  ];
}

function add(x, tree) {
  if (/* tag */ typeof tree === "number" || typeof tree === "string") {
    return {
      TAG: /* Node */ 0,
      _0: /* Empty */ 0,
      _1: x,
      _2: /* Empty */ 0,
      _3: 1
    };
  }
  const r = tree._2;
  const v = tree._1;
  const l = tree._0;
  const c = Caml.caml_string_compare(x, v);
  if (c === 0) {
    return tree;
  } else if (c < 0) {
    return Set_gen.internal_bal(add(x, l), v, r);
  } else {
    return Set_gen.internal_bal(l, v, add(x, r));
  }
}

function union(s1, s2) {
  if (/* tag */ typeof s1 === "number" || typeof s1 === "string") {
    return s2;
  }
  const h1 = s1._3;
  const v1 = s1._1;
  if (/* tag */ typeof s2 === "number" || typeof s2 === "string") {
    return s1;
  }
  const h2 = s2._3;
  const v2 = s2._1;
  if (h1 >= h2) {
    if (h2 === 1) {
      return add(v2, s1);
    }
    const match = split(v1, s2);
    return Set_gen.internal_join(union(s1._0, match[0]), v1, union(s1._2, match[2]));
  }
  if (h1 === 1) {
    return add(v1, s2);
  }
  const match$1 = split(v2, s1);
  return Set_gen.internal_join(union(match$1[0], s2._0), v2, union(match$1[2], s2._2));
}

function inter(s1, s2) {
  if (/* tag */ typeof s1 === "number" || typeof s1 === "string") {
    return /* Empty */ 0;
  }
  if (/* tag */ typeof s2 === "number" || typeof s2 === "string") {
    return /* Empty */ 0;
  }
  const r1 = s1._2;
  const v1 = s1._1;
  const l1 = s1._0;
  const match = split(v1, s2);
  const l2 = match[0];
  if (match[1]) {
    return Set_gen.internal_join(inter(l1, l2), v1, inter(r1, match[2]));
  } else {
    return Set_gen.internal_concat(inter(l1, l2), inter(r1, match[2]));
  }
}

function diff(s1, s2) {
  if (/* tag */ typeof s1 === "number" || typeof s1 === "string") {
    return /* Empty */ 0;
  }
  if (/* tag */ typeof s2 === "number" || typeof s2 === "string") {
    return s1;
  }
  const r1 = s1._2;
  const v1 = s1._1;
  const l1 = s1._0;
  const match = split(v1, s2);
  const l2 = match[0];
  if (match[1]) {
    return Set_gen.internal_concat(diff(l1, l2), diff(r1, match[2]));
  } else {
    return Set_gen.internal_join(diff(l1, l2), v1, diff(r1, match[2]));
  }
}

function mem(x, _tree) {
  while (true) {
    const tree = _tree;
    if (/* tag */ typeof tree === "number" || typeof tree === "string") {
      return false;
    }
    const c = Caml.caml_string_compare(x, tree._1);
    if (c === 0) {
      return true;
    }
    _tree = c < 0 ? tree._0 : tree._2;
    continue;
  };
}

function remove(x, tree) {
  if (/* tag */ typeof tree === "number" || typeof tree === "string") {
    return /* Empty */ 0;
  }
  const r = tree._2;
  const v = tree._1;
  const l = tree._0;
  const c = Caml.caml_string_compare(x, v);
  if (c === 0) {
    return Set_gen.internal_merge(l, r);
  } else if (c < 0) {
    return Set_gen.internal_bal(remove(x, l), v, r);
  } else {
    return Set_gen.internal_bal(l, v, remove(x, r));
  }
}

function compare(s1, s2) {
  return Set_gen.compare(Stdlib__String.compare, s1, s2);
}

function equal(s1, s2) {
  return Set_gen.compare(Stdlib__String.compare, s1, s2) === 0;
}

function subset(_s1, _s2) {
  while (true) {
    const s2 = _s2;
    const s1 = _s1;
    if (/* tag */ typeof s1 === "number" || typeof s1 === "string") {
      return true;
    }
    const r1 = s1._2;
    const v1 = s1._1;
    const l1 = s1._0;
    if (/* tag */ typeof s2 === "number" || typeof s2 === "string") {
      return false;
    }
    const r2 = s2._2;
    const l2 = s2._0;
    const c = Caml.caml_string_compare(v1, s2._1);
    if (c === 0) {
      if (!subset(l1, l2)) {
        return false;
      }
      _s2 = r2;
      _s1 = r1;
      continue;
    }
    if (c < 0) {
      if (!subset({
          TAG: /* Node */ 0,
          _0: l1,
          _1: v1,
          _2: /* Empty */ 0,
          _3: 0
        }, l2)) {
        return false;
      }
      _s1 = r1;
      continue;
    }
    if (!subset({
        TAG: /* Node */ 0,
        _0: /* Empty */ 0,
        _1: v1,
        _2: r1,
        _3: 0
      }, r2)) {
      return false;
    }
    _s1 = l1;
    continue;
  };
}

function find(x, _tree) {
  while (true) {
    const tree = _tree;
    if (/* tag */ typeof tree === "number" || typeof tree === "string") {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
    }
    const v = tree._1;
    const c = Caml.caml_string_compare(x, v);
    if (c === 0) {
      return v;
    }
    _tree = c < 0 ? tree._0 : tree._2;
    continue;
  };
}

function of_list(l) {
  if (!l) {
    return /* Empty */ 0;
  }
  const match = l.tl;
  const x0 = l.hd;
  if (!match) {
    return Set_gen.singleton(x0);
  }
  const match$1 = match.tl;
  const x1 = match.hd;
  if (!match$1) {
    return add(x1, Set_gen.singleton(x0));
  }
  const match$2 = match$1.tl;
  const x2 = match$1.hd;
  if (!match$2) {
    return add(x2, add(x1, Set_gen.singleton(x0)));
  }
  const match$3 = match$2.tl;
  const x3 = match$2.hd;
  if (match$3) {
    if (match$3.tl) {
      return Set_gen.of_sorted_list(Stdlib__List.sort_uniq(Stdlib__String.compare, l));
    } else {
      return add(match$3.hd, add(x3, add(x2, add(x1, Set_gen.singleton(x0)))));
    }
  } else {
    return add(x3, add(x2, add(x1, Set_gen.singleton(x0))));
  }
}

function of_array(l) {
  return Stdlib__Array.fold_left((function (acc, x) {
    return add(x, acc);
  }), /* Empty */ 0, l);
}

function invariant(t) {
  Set_gen.check(t);
  return Set_gen.is_ordered(Stdlib__String.compare, t);
}

const compare_elt = Stdlib__String.compare;

const empty = /* Empty */ 0;

const is_empty = Set_gen.is_empty;

const iter = Set_gen.iter;

const fold = Set_gen.fold;

const for_all = Set_gen.for_all;

const exists = Set_gen.exists;

const singleton = Set_gen.singleton;

const cardinal = Set_gen.cardinal;

const elements = Set_gen.elements;

const min_elt = Set_gen.min_elt;

const max_elt = Set_gen.max_elt;

const choose = Set_gen.choose;

const partition = Set_gen.partition;

const filter = Set_gen.filter;

const of_sorted_list = Set_gen.of_sorted_list;

const of_sorted_array = Set_gen.of_sorted_array;

module.exports = {
  compare_elt,
  empty,
  is_empty,
  iter,
  fold,
  for_all,
  exists,
  singleton,
  cardinal,
  elements,
  min_elt,
  max_elt,
  choose,
  partition,
  filter,
  of_sorted_list,
  of_sorted_array,
  split,
  add,
  union,
  inter,
  diff,
  mem,
  remove,
  compare,
  equal,
  subset,
  find,
  of_list,
  of_array,
  invariant,
}
/* No side effect */
