// Generated by Melange
'use strict';

const Caml = require("melange.js/caml.js");
const Caml_js_exceptions = require("melange.js/caml_js_exceptions.js");
const Curry = require("melange.js/curry.js");
const Mt = require("./mt.js");
const Stdlib = require("melange/stdlib.js");
const Stdlib__List = require("melange/list.js");
const Stdlib__String = require("melange/string.js");

const compare = Caml.caml_int_compare;

const Int = {
  compare: compare
};

function height(param) {
  if (/* tag */ typeof param === "number" || typeof param === "string") {
    return 0;
  } else {
    return param.h;
  }
}

function create(l, x, d, r) {
  const hl = height(l);
  const hr = height(r);
  return {
    TAG: /* Node */ 0,
    l: l,
    v: x,
    d: d,
    r: r,
    h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
  };
}

function bal(l, x, d, r) {
  let hl;
  hl = /* tag */ typeof l === "number" || typeof l === "string" ? 0 : l.h;
  let hr;
  hr = /* tag */ typeof r === "number" || typeof r === "string" ? 0 : r.h;
  if (hl > (hr + 2 | 0)) {
    if (/* tag */ typeof l === "number" || typeof l === "string") {
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Map.bal"
          });
    }
    const lr = l.r;
    const ld = l.d;
    const lv = l.v;
    const ll = l.l;
    if (height(ll) >= height(lr)) {
      return create(ll, lv, ld, create(lr, x, d, r));
    }
    if (!/* tag */ (typeof lr === "number" || typeof lr === "string")) {
      return create(create(ll, lv, ld, lr.l), lr.v, lr.d, create(lr.r, x, d, r));
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Map.bal"
        });
  }
  if (hr <= (hl + 2 | 0)) {
    return {
      TAG: /* Node */ 0,
      l: l,
      v: x,
      d: d,
      r: r,
      h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
    };
  }
  if (/* tag */ typeof r === "number" || typeof r === "string") {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Map.bal"
        });
  }
  const rr = r.r;
  const rd = r.d;
  const rv = r.v;
  const rl = r.l;
  if (height(rr) >= height(rl)) {
    return create(create(l, x, d, rl), rv, rd, rr);
  }
  if (!/* tag */ (typeof rl === "number" || typeof rl === "string")) {
    return create(create(l, x, d, rl.l), rl.v, rl.d, create(rl.r, rv, rd, rr));
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Map.bal"
      });
}

function add(x, data, m) {
  if (/* tag */ typeof m === "number" || typeof m === "string") {
    return {
      TAG: /* Node */ 0,
      l: /* Empty */ 0,
      v: x,
      d: data,
      r: /* Empty */ 0,
      h: 1
    };
  }
  const r = m.r;
  const d = m.d;
  const v = m.v;
  const l = m.l;
  const c = Curry._2(Int.compare, x, v);
  if (c === 0) {
    if (d === data) {
      return m;
    } else {
      return {
        TAG: /* Node */ 0,
        l: l,
        v: x,
        d: data,
        r: r,
        h: m.h
      };
    }
  }
  if (c < 0) {
    const ll = add(x, data, l);
    if (l === ll) {
      return m;
    } else {
      return bal(ll, v, d, r);
    }
  }
  const rr = add(x, data, r);
  if (r === rr) {
    return m;
  } else {
    return bal(l, v, d, rr);
  }
}

function cons_enum(_m, _e) {
  while(true) {
    const e = _e;
    const m = _m;
    if (/* tag */ typeof m === "number" || typeof m === "string") {
      return e;
    }
    _e = {
      TAG: /* More */ 0,
      _0: m.v,
      _1: m.d,
      _2: m.r,
      _3: e
    };
    _m = m.l;
    continue;
  };
}

function compare$1(cmp, m1, m2) {
  let _e1 = cons_enum(m1, /* End */ 0);
  let _e2 = cons_enum(m2, /* End */ 0);
  while(true) {
    const e2 = _e2;
    const e1 = _e1;
    if (/* tag */ typeof e1 === "number" || typeof e1 === "string") {
      if (/* tag */ typeof e2 === "number" || typeof e2 === "string") {
        return 0;
      } else {
        return -1;
      }
    }
    if (/* tag */ typeof e2 === "number" || typeof e2 === "string") {
      return 1;
    }
    const c = Curry._2(Int.compare, e1._0, e2._0);
    if (c !== 0) {
      return c;
    }
    const c$1 = Curry._2(cmp, e1._1, e2._1);
    if (c$1 !== 0) {
      return c$1;
    }
    _e2 = cons_enum(e2._2, e2._3);
    _e1 = cons_enum(e1._2, e1._3);
    continue;
  };
}

function equal(cmp, m1, m2) {
  let _e1 = cons_enum(m1, /* End */ 0);
  let _e2 = cons_enum(m2, /* End */ 0);
  while(true) {
    const e2 = _e2;
    const e1 = _e1;
    if (/* tag */ typeof e1 === "number" || typeof e1 === "string") {
      if (/* tag */ typeof e2 === "number" || typeof e2 === "string") {
        return true;
      } else {
        return false;
      }
    }
    if (/* tag */ typeof e2 === "number" || typeof e2 === "string") {
      return false;
    }
    if (Curry._2(Int.compare, e1._0, e2._0) !== 0) {
      return false;
    }
    if (!Curry._2(cmp, e1._1, e2._1)) {
      return false;
    }
    _e2 = cons_enum(e2._2, e2._3);
    _e1 = cons_enum(e1._2, e1._3);
    continue;
  };
}

function cardinal(param) {
  if (/* tag */ typeof param === "number" || typeof param === "string") {
    return 0;
  } else {
    return (cardinal(param.l) + 1 | 0) + cardinal(param.r) | 0;
  }
}

function of_list(bs) {
  return Stdlib__List.fold_left((function (m, param) {
        return add(param[0], param[1], m);
      }), /* Empty */ 0, bs);
}

const funarg = {
  compare: Stdlib__String.compare
};

function height$1(param) {
  if (/* tag */ typeof param === "number" || typeof param === "string") {
    return 0;
  } else {
    return param.h;
  }
}

function create$1(l, x, d, r) {
  const hl = height$1(l);
  const hr = height$1(r);
  return {
    TAG: /* Node */ 0,
    l: l,
    v: x,
    d: d,
    r: r,
    h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
  };
}

function bal$1(l, x, d, r) {
  let hl;
  hl = /* tag */ typeof l === "number" || typeof l === "string" ? 0 : l.h;
  let hr;
  hr = /* tag */ typeof r === "number" || typeof r === "string" ? 0 : r.h;
  if (hl > (hr + 2 | 0)) {
    if (/* tag */ typeof l === "number" || typeof l === "string") {
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Map.bal"
          });
    }
    const lr = l.r;
    const ld = l.d;
    const lv = l.v;
    const ll = l.l;
    if (height$1(ll) >= height$1(lr)) {
      return create$1(ll, lv, ld, create$1(lr, x, d, r));
    }
    if (!/* tag */ (typeof lr === "number" || typeof lr === "string")) {
      return create$1(create$1(ll, lv, ld, lr.l), lr.v, lr.d, create$1(lr.r, x, d, r));
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Map.bal"
        });
  }
  if (hr <= (hl + 2 | 0)) {
    return {
      TAG: /* Node */ 0,
      l: l,
      v: x,
      d: d,
      r: r,
      h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
    };
  }
  if (/* tag */ typeof r === "number" || typeof r === "string") {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Map.bal"
        });
  }
  const rr = r.r;
  const rd = r.d;
  const rv = r.v;
  const rl = r.l;
  if (height$1(rr) >= height$1(rl)) {
    return create$1(create$1(l, x, d, rl), rv, rd, rr);
  }
  if (!/* tag */ (typeof rl === "number" || typeof rl === "string")) {
    return create$1(create$1(l, x, d, rl.l), rl.v, rl.d, create$1(rl.r, rv, rd, rr));
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Map.bal"
      });
}

function add$1(x, data, m) {
  if (/* tag */ typeof m === "number" || typeof m === "string") {
    return {
      TAG: /* Node */ 0,
      l: /* Empty */ 0,
      v: x,
      d: data,
      r: /* Empty */ 0,
      h: 1
    };
  }
  const r = m.r;
  const d = m.d;
  const v = m.v;
  const l = m.l;
  const c = Curry._2(funarg.compare, x, v);
  if (c === 0) {
    if (d === data) {
      return m;
    } else {
      return {
        TAG: /* Node */ 0,
        l: l,
        v: x,
        d: data,
        r: r,
        h: m.h
      };
    }
  }
  if (c < 0) {
    const ll = add$1(x, data, l);
    if (l === ll) {
      return m;
    } else {
      return bal$1(ll, v, d, r);
    }
  }
  const rr = add$1(x, data, r);
  if (r === rr) {
    return m;
  } else {
    return bal$1(l, v, d, rr);
  }
}

function find(x, _param) {
  while(true) {
    const param = _param;
    if (/* tag */ typeof param === "number" || typeof param === "string") {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
    }
    const c = Curry._2(funarg.compare, x, param.v);
    if (c === 0) {
      return param.d;
    }
    _param = c < 0 ? param.l : param.r;
    continue;
  };
}

const int_map_suites_0 = [
  "add",
  (function (param) {
    const v = Curry._1(of_list, {
          hd: [
            1,
            /* '1' */49
          ],
          tl: {
            hd: [
              2,
              /* '3' */51
            ],
            tl: {
              hd: [
                3,
                /* '4' */52
              ],
              tl: /* [] */ 0
            }
          }
        });
    return {
      TAG: /* Eq */ 0,
      _0: Curry._1(cardinal, v),
      _1: 3
    };
  })
];

const int_map_suites_1 = {
  hd: [
    "equal",
    (function (param) {
      const v = Curry._1(of_list, {
            hd: [
              1,
              /* '1' */49
            ],
            tl: {
              hd: [
                2,
                /* '3' */51
              ],
              tl: {
                hd: [
                  3,
                  /* '4' */52
                ],
                tl: /* [] */ 0
              }
            }
          });
      const u = Curry._1(of_list, {
            hd: [
              2,
              /* '3' */51
            ],
            tl: {
              hd: [
                3,
                /* '4' */52
              ],
              tl: {
                hd: [
                  1,
                  /* '1' */49
                ],
                tl: /* [] */ 0
              }
            }
          });
      return {
        TAG: /* Eq */ 0,
        _0: Curry._3(compare$1, Caml.caml_int_compare, u, v),
        _1: 0
      };
    })
  ],
  tl: {
    hd: [
      "equal2",
      (function (param) {
        const v = Curry._1(of_list, {
              hd: [
                1,
                /* '1' */49
              ],
              tl: {
                hd: [
                  2,
                  /* '3' */51
                ],
                tl: {
                  hd: [
                    3,
                    /* '4' */52
                  ],
                  tl: /* [] */ 0
                }
              }
            });
        const u = Curry._1(of_list, {
              hd: [
                2,
                /* '3' */51
              ],
              tl: {
                hd: [
                  3,
                  /* '4' */52
                ],
                tl: {
                  hd: [
                    1,
                    /* '1' */49
                  ],
                  tl: /* [] */ 0
                }
              }
            });
        return {
          TAG: /* Eq */ 0,
          _0: true,
          _1: Curry._3(equal, (function (x, y) {
                return x === y;
              }), u, v)
        };
      })
    ],
    tl: {
      hd: [
        "iteration",
        (function (param) {
          let m = /* Empty */ 0;
          for (let i = 0; i <= 10000; ++i) {
            m = Curry._3(add$1, String(i), String(i), m);
          }
          let v = -1;
          for (let i$1 = 0; i$1 <= 10000; ++i$1) {
            if (Curry._2(find, String(i$1), m) !== String(i$1)) {
              v = i$1;
            }
            
          }
          return {
            TAG: /* Eq */ 0,
            _0: v,
            _1: -1
          };
        })
      ],
      tl: /* [] */ 0
    }
  }
};

const int_map_suites = {
  hd: int_map_suites_0,
  tl: int_map_suites_1
};

Mt.from_pair_suites("Map_test", int_map_suites);

/* Int_map Not a pure module */
