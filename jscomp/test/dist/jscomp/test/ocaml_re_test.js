// Generated by Melange
'use strict';

const Caml = require("melange.js/caml.js");
const Caml_array = require("melange.js/caml_array.js");
const Caml_bytes = require("melange.js/caml_bytes.js");
const Caml_exceptions = require("melange.js/caml_exceptions.js");
const Caml_js_exceptions = require("melange.js/caml_js_exceptions.js");
const Caml_obj = require("melange.js/caml_obj.js");
const Caml_option = require("melange.js/caml_option.js");
const Caml_string = require("melange.js/caml_string.js");
const Curry = require("melange.js/curry.js");
const Mt = require("./mt.js");
const Stdlib = require("melange/stdlib.js");
const Stdlib__Array = require("melange/array.js");
const Stdlib__Bytes = require("melange/bytes.js");
const Stdlib__Char = require("melange/char.js");
const Stdlib__Format = require("melange/format.js");
const Stdlib__Hashtbl = require("melange/hashtbl.js");
const Stdlib__List = require("melange/list.js");
const Stdlib__String = require("melange/string.js");

const suites = {
  contents: /* [] */ 0
};

const test_id = {
  contents: 0
};

function eq(loc, x, y) {
  test_id.contents = test_id.contents + 1 | 0;
  suites.contents = {
    hd: [
      loc + (" id " + String(test_id.contents)),
      (function (param) {
        return {
          TAG: /* Eq */ 0,
          _0: x,
          _1: y
        };
      })
    ],
    tl: suites.contents
  };
}

function union(_l, _l$p) {
  while (true) {
    const l$p = _l$p;
    const l = _l;
    if (!l$p) {
      return l;
    }
    if (!l) {
      return l$p;
    }
    const r$p = l$p.tl;
    const match = l$p.hd;
    const c2$p = match[1];
    const c1$p = match[0];
    const r = l.tl;
    const match$1 = l.hd;
    const c2 = match$1[1];
    const c1 = match$1[0];
    if ((c2 + 1 | 0) < c1$p) {
      return {
        hd: [
          c1,
          c2
        ],
        tl: union(r, l$p)
      };
    }
    if ((c2$p + 1 | 0) < c1) {
      return {
        hd: [
          c1$p,
          c2$p
        ],
        tl: union(l, r$p)
      };
    }
    if (c2 < c2$p) {
      _l$p = {
        hd: [
          c1 < c1$p ? c1 : c1$p,
          c2$p
        ],
        tl: r$p
      };
      _l = r;
      continue;
    }
    _l$p = r$p;
    _l = {
      hd: [
        c1 < c1$p ? c1 : c1$p,
        c2
      ],
      tl: r
    };
    continue;
  };
}

function inter(_l, _l$p) {
  while (true) {
    const l$p = _l$p;
    const l = _l;
    if (!l$p) {
      return /* [] */ 0;
    }
    if (!l) {
      return /* [] */ 0;
    }
    const r$p = l$p.tl;
    const match = l$p.hd;
    const c2$p = match[1];
    const c1$p = match[0];
    const r = l.tl;
    const match$1 = l.hd;
    const c2 = match$1[1];
    const c1 = match$1[0];
    if (Caml_obj.caml_lessthan(c2, c1$p)) {
      _l = r;
      continue;
    }
    if (!Caml_obj.caml_lessthan(c2$p, c1)) {
      if (Caml_obj.caml_lessthan(c2, c2$p)) {
        return {
          hd: [
            Caml_obj.caml_max(c1, c1$p),
            c2
          ],
          tl: inter(r, l$p)
        };
      } else {
        return {
          hd: [
            Caml_obj.caml_max(c1, c1$p),
            c2$p
          ],
          tl: inter(l, r$p)
        };
      }
    }
    _l$p = r$p;
    continue;
  };
}

function diff(_l, _l$p) {
  while (true) {
    const l$p = _l$p;
    const l = _l;
    if (!l$p) {
      return l;
    }
    if (!l) {
      return /* [] */ 0;
    }
    const r$p = l$p.tl;
    const match = l$p.hd;
    const c2$p = match[1];
    const c1$p = match[0];
    const r = l.tl;
    const match$1 = l.hd;
    const c2 = match$1[1];
    const c1 = match$1[0];
    if (c2 < c1$p) {
      return {
        hd: [
          c1,
          c2
        ],
        tl: diff(r, l$p)
      };
    }
    if (c2$p < c1) {
      _l$p = r$p;
      continue;
    }
    const r$p$p = c2$p < c2 ? ({
        hd: [
          c2$p + 1 | 0,
          c2
        ],
        tl: r
      }) : r;
    if (c1 < c1$p) {
      return {
        hd: [
          c1,
          c1$p - 1 | 0
        ],
        tl: diff(r$p$p, r$p)
      };
    }
    _l$p = r$p;
    _l = r$p$p;
    continue;
  };
}

function single(c) {
  return {
    hd: [
      c,
      c
    ],
    tl: /* [] */ 0
  };
}

function seq(c, c$p) {
  if (Caml_obj.caml_lessequal(c, c$p)) {
    return {
      hd: [
        c,
        c$p
      ],
      tl: /* [] */ 0
    };
  } else {
    return {
      hd: [
        c$p,
        c
      ],
      tl: /* [] */ 0
    };
  }
}

function offset(o, l) {
  if (!l) {
    return /* [] */ 0;
  }
  const match = l.hd;
  return {
    hd: [
      match[0] + o | 0,
      match[1] + o | 0
    ],
    tl: offset(o, l.tl)
  };
}

function mem(c, _s) {
  while (true) {
    const s = _s;
    if (!s) {
      return false;
    }
    const match = s.hd;
    if (c <= match[1]) {
      return c >= match[0];
    }
    _s = s.tl;
    continue;
  };
}

function hash_rec(param) {
  if (!param) {
    return 0;
  }
  const match = param.hd;
  return (match[0] + Math.imul(13, match[1]) | 0) + Math.imul(257, hash_rec(param.tl)) | 0;
}

function one_char(param) {
  if (!param) {
    return;
  }
  if (param.tl) {
    return;
  }
  const match = param.hd;
  const i = match[0];
  if (Caml_obj.caml_equal(i, match[1])) {
    return Caml_option.some(i);
  }
  
}

function compare(param, param$1) {
  const c = Caml_obj.caml_compare(param[0], param$1[0]);
  if (c !== 0) {
    return c;
  } else {
    return Caml_obj.caml_compare(param[1], param$1[1]);
  }
}

const funarg = {
  compare: compare
};

function height(param) {
  if (/* tag */ typeof param === "number" || typeof param === "string") {
    return 0;
  } else {
    return param.h;
  }
}

function create(l, x, d, r) {
  const hl = height(l);
  const hr = height(r);
  return {
    TAG: /* Node */ 0,
    l: l,
    v: x,
    d: d,
    r: r,
    h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
  };
}

function bal(l, x, d, r) {
  let hl;
  hl = /* tag */ typeof l === "number" || typeof l === "string" ? 0 : l.h;
  let hr;
  hr = /* tag */ typeof r === "number" || typeof r === "string" ? 0 : r.h;
  if (hl > (hr + 2 | 0)) {
    if (/* tag */ typeof l === "number" || typeof l === "string") {
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Map.bal"
          });
    }
    const lr = l.r;
    const ld = l.d;
    const lv = l.v;
    const ll = l.l;
    if (height(ll) >= height(lr)) {
      return create(ll, lv, ld, create(lr, x, d, r));
    }
    if (!/* tag */ (typeof lr === "number" || typeof lr === "string")) {
      return create(create(ll, lv, ld, lr.l), lr.v, lr.d, create(lr.r, x, d, r));
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Map.bal"
        });
  }
  if (hr <= (hl + 2 | 0)) {
    return {
      TAG: /* Node */ 0,
      l: l,
      v: x,
      d: d,
      r: r,
      h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
    };
  }
  if (/* tag */ typeof r === "number" || typeof r === "string") {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Map.bal"
        });
  }
  const rr = r.r;
  const rd = r.d;
  const rv = r.v;
  const rl = r.l;
  if (height(rr) >= height(rl)) {
    return create(create(l, x, d, rl), rv, rd, rr);
  }
  if (!/* tag */ (typeof rl === "number" || typeof rl === "string")) {
    return create(create(l, x, d, rl.l), rl.v, rl.d, create(rl.r, rv, rd, rr));
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Map.bal"
      });
}

function add(x, data, m) {
  if (/* tag */ typeof m === "number" || typeof m === "string") {
    return {
      TAG: /* Node */ 0,
      l: /* Empty */ 0,
      v: x,
      d: data,
      r: /* Empty */ 0,
      h: 1
    };
  }
  const r = m.r;
  const d = m.d;
  const v = m.v;
  const l = m.l;
  const c = Curry._2(funarg.compare, x, v);
  if (c === 0) {
    if (d === data) {
      return m;
    } else {
      return {
        TAG: /* Node */ 0,
        l: l,
        v: x,
        d: data,
        r: r,
        h: m.h
      };
    }
  }
  if (c < 0) {
    const ll = add(x, data, l);
    if (l === ll) {
      return m;
    } else {
      return bal(ll, v, d, r);
    }
  }
  const rr = add(x, data, r);
  if (r === rr) {
    return m;
  } else {
    return bal(l, v, d, rr);
  }
}

function find(x, _param) {
  while (true) {
    const param = _param;
    if (/* tag */ typeof param === "number" || typeof param === "string") {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
    }
    const c = Curry._2(funarg.compare, x, param.v);
    if (c === 0) {
      return param.d;
    }
    _param = c < 0 ? param.l : param.r;
    continue;
  };
}

const cany = {
  hd: [
    0,
    255
  ],
  tl: /* [] */ 0
};

function intersect(x, y) {
  return (x & y) !== 0;
}

function $plus$plus(x, y) {
  return x | y;
}

function from_char(param) {
  if (param >= 170) {
    if (param >= 187) {
      if (param > 246 || param < 192) {
        if (param >= 248) {
          return 2;
        } else {
          return 4;
        }
      } else if (param !== 215) {
        return 2;
      } else {
        return 4;
      }
    } else if (!(param > 185 || param < 171) && param !== 181) {
      return 4;
    } else {
      return 2;
    }
  } else if (param >= 65) {
    if (param > 96 || param < 91) {
      if (param >= 123) {
        return 4;
      } else {
        return 2;
      }
    } else if (param !== 95) {
      return 4;
    } else {
      return 2;
    }
  } else if (param >= 48) {
    if (param >= 58) {
      return 4;
    } else {
      return 2;
    }
  } else if (param !== 10) {
    return 4;
  } else {
    return 12;
  }
}

const compare$1 = Caml.caml_int_compare;

const funarg$1 = {
  compare: compare$1
};

function height$1(param) {
  if (/* tag */ typeof param === "number" || typeof param === "string") {
    return 0;
  } else {
    return param.h;
  }
}

function create$1(l, v, r) {
  let hl;
  hl = /* tag */ typeof l === "number" || typeof l === "string" ? 0 : l.h;
  let hr;
  hr = /* tag */ typeof r === "number" || typeof r === "string" ? 0 : r.h;
  return {
    TAG: /* Node */ 0,
    l: l,
    v: v,
    r: r,
    h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
  };
}

function bal$1(l, v, r) {
  let hl;
  hl = /* tag */ typeof l === "number" || typeof l === "string" ? 0 : l.h;
  let hr;
  hr = /* tag */ typeof r === "number" || typeof r === "string" ? 0 : r.h;
  if (hl > (hr + 2 | 0)) {
    if (/* tag */ typeof l === "number" || typeof l === "string") {
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Set.bal"
          });
    }
    const lr = l.r;
    const lv = l.v;
    const ll = l.l;
    if (height$1(ll) >= height$1(lr)) {
      return create$1(ll, lv, create$1(lr, v, r));
    }
    if (!/* tag */ (typeof lr === "number" || typeof lr === "string")) {
      return create$1(create$1(ll, lv, lr.l), lr.v, create$1(lr.r, v, r));
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Set.bal"
        });
  }
  if (hr <= (hl + 2 | 0)) {
    return {
      TAG: /* Node */ 0,
      l: l,
      v: v,
      r: r,
      h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
    };
  }
  if (/* tag */ typeof r === "number" || typeof r === "string") {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Set.bal"
        });
  }
  const rr = r.r;
  const rv = r.v;
  const rl = r.l;
  if (height$1(rr) >= height$1(rl)) {
    return create$1(create$1(l, v, rl), rv, rr);
  }
  if (!/* tag */ (typeof rl === "number" || typeof rl === "string")) {
    return create$1(create$1(l, v, rl.l), rl.v, create$1(rl.r, rv, rr));
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Set.bal"
      });
}

function add$1(x, t) {
  if (/* tag */ typeof t === "number" || typeof t === "string") {
    return {
      TAG: /* Node */ 0,
      l: /* Empty */ 0,
      v: x,
      r: /* Empty */ 0,
      h: 1
    };
  }
  const r = t.r;
  const v = t.v;
  const l = t.l;
  const c = Curry._2(funarg$1.compare, x, v);
  if (c === 0) {
    return t;
  }
  if (c < 0) {
    const ll = add$1(x, l);
    if (l === ll) {
      return t;
    } else {
      return bal$1(ll, v, r);
    }
  }
  const rr = add$1(x, r);
  if (r === rr) {
    return t;
  } else {
    return bal$1(l, v, rr);
  }
}

function hash_combine(h, accu) {
  return Math.imul(accu, 65599) + h | 0;
}

const empty_pmarks = /* Empty */ 0;

const empty = {
  marks: /* [] */ 0,
  pmarks: empty_pmarks
};

function hash(m, accu) {
  let _l = m.marks;
  let _accu = hash_combine(Stdlib__Hashtbl.hash(m.pmarks), accu);
  while (true) {
    const accu$1 = _accu;
    const l = _l;
    if (!l) {
      return accu$1;
    }
    const match = l.hd;
    _accu = hash_combine(match[0], hash_combine(match[1], accu$1));
    _l = l.tl;
    continue;
  };
}

function marks_set_idx(idx, marks) {
  if (!marks) {
    return marks;
  }
  const match = marks.hd;
  if (match[1] !== -1) {
    return marks;
  } else {
    return {
      hd: [
        match[0],
        idx
      ],
      tl: marks_set_idx(idx, marks.tl)
    };
  }
}

function marks_set_idx$1(marks, idx) {
  return {
    marks: marks_set_idx(idx, marks.marks),
    pmarks: marks.pmarks
  };
}

function first(f, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return;
    }
    const res = Curry._1(f, param.hd);
    if (res !== undefined) {
      return res;
    }
    _param = param.tl;
    continue;
  };
}

const eps_expr = {
  id: 0,
  def: /* Eps */ 0
};

function mk_expr(ids, def) {
  ids.contents = ids.contents + 1 | 0;
  return {
    id: ids.contents,
    def: def
  };
}

function cst(ids, s) {
  if (s ? false : true) {
    return mk_expr(ids, {
          TAG: /* Alt */ 1,
          _0: /* [] */ 0
        });
  } else {
    return mk_expr(ids, {
          TAG: /* Cst */ 0,
          _0: s
        });
  }
}

function alt(ids, l) {
  if (l) {
    if (l.tl) {
      return mk_expr(ids, {
            TAG: /* Alt */ 1,
            _0: l
          });
    } else {
      return l.hd;
    }
  } else {
    return mk_expr(ids, {
          TAG: /* Alt */ 1,
          _0: /* [] */ 0
        });
  }
}

function seq$1(ids, kind, x, y) {
  const match = x.def;
  const match$1 = y.def;
  let exit = 0;
  if (/* tag */ typeof match === "number" || typeof match === "string") {
    return y;
  }
  if (match.TAG === /* Alt */ 1) {
    if (!match._0) {
      return x;
    }
    exit = 2;
  } else {
    exit = 2;
  }
  if (exit === 2) {
    if (/* tag */ typeof match$1 === "number" || typeof match$1 === "string") {
      if (kind === "First") {
        return x;
      }
      
    } else if (match$1.TAG === /* Alt */ 1 && !match$1._0) {
      return y;
    }
    
  }
  return mk_expr(ids, {
        TAG: /* Seq */ 2,
        _0: kind,
        _1: x,
        _2: y
      });
}

function is_eps(expr) {
  const match = expr.def;
  if (/* tag */ typeof match === "number" || typeof match === "string") {
    return true;
  } else {
    return false;
  }
}

function rep(ids, kind, sem, x) {
  return mk_expr(ids, {
        TAG: /* Rep */ 3,
        _0: kind,
        _1: sem,
        _2: x
      });
}

function erase(ids, m, m$p) {
  return mk_expr(ids, {
        TAG: /* Erase */ 5,
        _0: m,
        _1: m$p
      });
}

function rename(ids, x) {
  const l = x.def;
  if (/* tag */ typeof l === "number" || typeof l === "string") {
    return mk_expr(ids, x.def);
  }
  switch (l.TAG) {
    case /* Alt */ 1 :
      return mk_expr(ids, {
            TAG: /* Alt */ 1,
            _0: Stdlib__List.map((function (param) {
                  return rename(ids, param);
                }), l._0)
          });
    case /* Seq */ 2 :
      return mk_expr(ids, {
            TAG: /* Seq */ 2,
            _0: l._0,
            _1: rename(ids, l._1),
            _2: rename(ids, l._2)
          });
    case /* Rep */ 3 :
      return mk_expr(ids, {
            TAG: /* Rep */ 3,
            _0: l._0,
            _1: l._1,
            _2: rename(ids, l._2)
          });
    default:
      return mk_expr(ids, x.def);
  }
}

function equal(_l1, _l2) {
  while (true) {
    const l2 = _l2;
    const l1 = _l1;
    if (!l1) {
      if (l2) {
        return false;
      } else {
        return true;
      }
    }
    const marks1 = l1.hd;
    switch (marks1.TAG) {
      case /* TSeq */ 0 :
        if (!l2) {
          return false;
        }
        const match = l2.hd;
        switch (match.TAG) {
          case /* TSeq */ 0 :
            if (marks1._1.id !== match._1.id) {
              return false;
            }
            if (!equal(marks1._0, match._0)) {
              return false;
            }
            _l2 = l2.tl;
            _l1 = l1.tl;
            continue;
          case /* TExp */ 1 :
          case /* TMatch */ 2 :
            return false;
        }
      case /* TExp */ 1 :
        if (!l2) {
          return false;
        }
        const match$1 = l2.hd;
        switch (match$1.TAG) {
          case /* TExp */ 1 :
            if (marks1._1.id !== match$1._1.id) {
              return false;
            }
            if (!Caml_obj.caml_equal(marks1._0, match$1._0)) {
              return false;
            }
            _l2 = l2.tl;
            _l1 = l1.tl;
            continue;
          case /* TSeq */ 0 :
          case /* TMatch */ 2 :
            return false;
        }
      case /* TMatch */ 2 :
        if (!l2) {
          return false;
        }
        const marks2 = l2.hd;
        switch (marks2.TAG) {
          case /* TSeq */ 0 :
          case /* TExp */ 1 :
            return false;
          case /* TMatch */ 2 :
            if (!Caml_obj.caml_equal(marks1._0, marks2._0)) {
              return false;
            }
            _l2 = l2.tl;
            _l1 = l1.tl;
            continue;
        }
    }
  };
}

function hash$1(_l, _accu) {
  while (true) {
    const accu = _accu;
    const l = _l;
    if (!l) {
      return accu;
    }
    const marks = l.hd;
    switch (marks.TAG) {
      case /* TSeq */ 0 :
        _accu = hash_combine(388635598, hash_combine(marks._1.id, hash$1(marks._0, accu)));
        _l = l.tl;
        continue;
      case /* TExp */ 1 :
        _accu = hash_combine(726404471, hash_combine(marks._1.id, hash(marks._0, accu)));
        _l = l.tl;
        continue;
      case /* TMatch */ 2 :
        _accu = hash_combine(471882453, hash(marks._0, accu));
        _l = l.tl;
        continue;
    }
  };
}

function tseq(kind, x, y, rem) {
  if (!x) {
    return rem;
  }
  const match = x.hd;
  switch (match.TAG) {
    case /* TExp */ 1 :
      let tmp = match._1.def;
      if (/* tag */ (typeof tmp === "number" || typeof tmp === "string") && !x.tl) {
        return {
          hd: {
            TAG: /* TExp */ 1,
            _0: match._0,
            _1: y
          },
          tl: rem
        };
      }
      break;
    case /* TSeq */ 0 :
    case /* TMatch */ 2 :
      break;
  }
  return {
    hd: {
      TAG: /* TSeq */ 0,
      _0: x,
      _1: y,
      _2: kind
    },
    tl: rem
  };
}

const dummy = {
  idx: -1,
  category: -1,
  desc: /* [] */ 0,
  status: undefined,
  hash: -1
};

function hash$2(idx, cat, desc) {
  return hash$1(desc, hash_combine(idx, hash_combine(cat, 0))) & 1073741823;
}

function mk(idx, cat, desc) {
  return {
    idx: idx,
    category: cat,
    desc: desc,
    status: undefined,
    hash: hash$2(idx, cat, desc)
  };
}

function create$2(cat, e) {
  return mk(0, cat, {
        hd: {
          TAG: /* TExp */ 1,
          _0: empty,
          _1: e
        },
        tl: /* [] */ 0
      });
}

function equal$1(x, y) {
  if (x.hash === y.hash && x.idx === y.idx && x.category === y.category) {
    return equal(x.desc, y.desc);
  } else {
    return false;
  }
}

function hash$3(t) {
  return t.hash;
}

const Table = Stdlib__Hashtbl.Make({
      equal: equal$1,
      hash: hash$3
    });

function reset_table(a) {
  Stdlib__Array.fill(a, 0, a.length, false);
}

function mark_used_indices(tbl) {
  return function (param) {
    return Stdlib__List.iter((function (param) {
          switch (param.TAG) {
            case /* TSeq */ 0 :
              return mark_used_indices(tbl)(param._0);
            case /* TExp */ 1 :
            case /* TMatch */ 2 :
              break;
          }
          Stdlib__List.iter((function (param) {
                const i = param[1];
                if (i >= 0) {
                  return Caml_array.set(tbl, i, true);
                }
                
              }), param._0.marks);
        }), param);
  };
}

function find_free(tbl, _idx, len) {
  while (true) {
    const idx = _idx;
    if (idx === len || !Caml_array.get(tbl, idx)) {
      return idx;
    }
    _idx = idx + 1 | 0;
    continue;
  };
}

function free_index(tbl_ref, l) {
  const tbl = tbl_ref.contents;
  reset_table(tbl);
  mark_used_indices(tbl)(l);
  const len = tbl.length;
  const idx = find_free(tbl, 0, len);
  if (idx === len) {
    tbl_ref.contents = Caml_array.make((len << 1), false);
  }
  return idx;
}

function remove_matches(param) {
  return Stdlib__List.filter((function (param) {
        switch (param.TAG) {
          case /* TSeq */ 0 :
          case /* TExp */ 1 :
            return true;
          case /* TMatch */ 2 :
            return false;
        }
      }), param);
}

function split_at_match_rec(_l$p, _param) {
  while (true) {
    const param = _param;
    const l$p = _l$p;
    if (param) {
      const x = param.hd;
      switch (x.TAG) {
        case /* TSeq */ 0 :
        case /* TExp */ 1 :
          _param = param.tl;
          _l$p = {
            hd: x,
            tl: l$p
          };
          continue;
        case /* TMatch */ 2 :
          return [
            Stdlib__List.rev(l$p),
            remove_matches(param.tl)
          ];
      }
    } else {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "re_automata.ml",
              429,
              21
            ]
          });
    }
  };
}

function remove_duplicates(prev, _l, y) {
  while (true) {
    const l = _l;
    if (!l) {
      return [
        /* [] */ 0,
        prev
      ];
    }
    const x = l.hd;
    switch (x.TAG) {
      case /* TSeq */ 0 :
        const x$1 = x._1;
        const match = remove_duplicates(prev, x._0, x$1);
        const match$1 = remove_duplicates(match[1], l.tl, y);
        return [
          tseq(x._2, match[0], x$1, match$1[0]),
          match$1[1]
        ];
      case /* TExp */ 1 :
        let tmp = x._1.def;
        if (/* tag */ typeof tmp === "number" || typeof tmp === "string") {
          const r = l.tl;
          if (Stdlib__List.memq(y.id, prev)) {
            _l = r;
            continue;
          }
          const match$2 = remove_duplicates({
                hd: y.id,
                tl: prev
              }, r, y);
          return [
            {
              hd: x,
              tl: match$2[0]
            },
            match$2[1]
          ];
        }
        const r$1 = l.tl;
        const x$2 = x._1;
        if (Stdlib__List.memq(x$2.id, prev)) {
          _l = r$1;
          continue;
        }
        const match$3 = remove_duplicates({
              hd: x$2.id,
              tl: prev
            }, r$1, y);
        return [
          {
            hd: x,
            tl: match$3[0]
          },
          match$3[1]
        ];
      case /* TMatch */ 2 :
        return [
          {
            hd: x,
            tl: /* [] */ 0
          },
          prev
        ];
    }
  };
}

function set_idx(idx, param) {
  if (!param) {
    return /* [] */ 0;
  }
  const marks = param.hd;
  switch (marks.TAG) {
    case /* TSeq */ 0 :
      return {
        hd: {
          TAG: /* TSeq */ 0,
          _0: set_idx(idx, marks._0),
          _1: marks._1,
          _2: marks._2
        },
        tl: set_idx(idx, param.tl)
      };
    case /* TExp */ 1 :
      return {
        hd: {
          TAG: /* TExp */ 1,
          _0: marks_set_idx$1(marks._0, idx),
          _1: marks._1
        },
        tl: set_idx(idx, param.tl)
      };
    case /* TMatch */ 2 :
      return {
        hd: {
          TAG: /* TMatch */ 2,
          _0: marks_set_idx$1(marks._0, idx)
        },
        tl: set_idx(idx, param.tl)
      };
  }
}

function filter_marks(b, e, marks) {
  return {
    marks: Stdlib__List.filter((function (param) {
          const i = param[0];
          if (i < b) {
            return true;
          } else {
            return i > e;
          }
        }), marks.marks),
    pmarks: marks.pmarks
  };
}

function delta_1(marks, c, next_cat, prev_cat, x, rem) {
  const s = x.def;
  if (/* tag */ typeof s === "number" || typeof s === "string") {
    return {
      hd: {
        TAG: /* TMatch */ 2,
        _0: marks
      },
      tl: rem
    };
  }
  switch (s.TAG) {
    case /* Cst */ 0 :
      if (mem(c, s._0)) {
        return {
          hd: {
            TAG: /* TExp */ 1,
            _0: marks,
            _1: eps_expr
          },
          tl: rem
        };
      } else {
        return rem;
      }
    case /* Alt */ 1 :
      return delta_2(marks, c, next_cat, prev_cat, s._0, rem);
    case /* Seq */ 2 :
      const y$p = delta_1(marks, c, next_cat, prev_cat, s._1, /* [] */ 0);
      return delta_seq(c, next_cat, prev_cat, s._0, y$p, s._2, rem);
    case /* Rep */ 3 :
      const kind = s._1;
      const y$p$1 = delta_1(marks, c, next_cat, prev_cat, s._2, /* [] */ 0);
      const marks$p = first((function (marks) {
            switch (marks.TAG) {
              case /* TSeq */ 0 :
              case /* TExp */ 1 :
                return;
              case /* TMatch */ 2 :
                return marks._0;
            }
          }), y$p$1);
      const match = marks$p !== undefined ? [
          remove_matches(y$p$1),
          marks$p
        ] : [
          y$p$1,
          marks
        ];
      const y$p$p = match[0];
      if (s._0 === "Non_greedy") {
        return {
          hd: {
            TAG: /* TMatch */ 2,
            _0: marks
          },
          tl: tseq(kind, y$p$p, x, rem)
        };
      } else {
        return tseq(kind, y$p$p, x, {
              hd: {
                TAG: /* TMatch */ 2,
                _0: match[1]
              },
              tl: rem
            });
      }
    case /* Mark */ 4 :
      const i = s._0;
      const marks_marks = {
        hd: [
          i,
          -1
        ],
        tl: Stdlib__List.remove_assq(i, marks.marks)
      };
      const marks_pmarks = marks.pmarks;
      const marks$1 = {
        marks: marks_marks,
        pmarks: marks_pmarks
      };
      return {
        hd: {
          TAG: /* TMatch */ 2,
          _0: marks$1
        },
        tl: rem
      };
    case /* Erase */ 5 :
      return {
        hd: {
          TAG: /* TMatch */ 2,
          _0: filter_marks(s._0, s._1, marks)
        },
        tl: rem
      };
    case /* Before */ 6 :
      if (intersect(next_cat, s._0)) {
        return {
          hd: {
            TAG: /* TMatch */ 2,
            _0: marks
          },
          tl: rem
        };
      } else {
        return rem;
      }
    case /* After */ 7 :
      if (intersect(prev_cat, s._0)) {
        return {
          hd: {
            TAG: /* TMatch */ 2,
            _0: marks
          },
          tl: rem
        };
      } else {
        return rem;
      }
    case /* Pmark */ 8 :
      const marks_marks$1 = marks.marks;
      const marks_pmarks$1 = Curry._2(add$1, s._0, marks.pmarks);
      const marks$2 = {
        marks: marks_marks$1,
        pmarks: marks_pmarks$1
      };
      return {
        hd: {
          TAG: /* TMatch */ 2,
          _0: marks$2
        },
        tl: rem
      };
  }
}

function delta_2(marks, c, next_cat, prev_cat, l, rem) {
  if (l) {
    return delta_1(marks, c, next_cat, prev_cat, l.hd, delta_2(marks, c, next_cat, prev_cat, l.tl, rem));
  } else {
    return rem;
  }
}

function delta_seq(c, next_cat, prev_cat, kind, y, z, rem) {
  const marks = first((function (marks) {
        switch (marks.TAG) {
          case /* TSeq */ 0 :
          case /* TExp */ 1 :
            return;
          case /* TMatch */ 2 :
            return marks._0;
        }
      }), y);
  if (marks === undefined) {
    return tseq(kind, y, z, rem);
  }
  if (kind === "Longest") {
    return tseq(kind, remove_matches(y), z, delta_1(marks, c, next_cat, prev_cat, z, rem));
  }
  if (kind !== "First") {
    return delta_1(marks, c, next_cat, prev_cat, z, tseq(kind, remove_matches(y), z, rem));
  }
  const match = split_at_match_rec(/* [] */ 0, y);
  return tseq(kind, match[0], z, delta_1(marks, c, next_cat, prev_cat, z, tseq(kind, match[1], z, rem)));
}

function delta_4(c, next_cat, prev_cat, l, rem) {
  if (l) {
    let x = l.hd;
    let rem$1 = delta_4(c, next_cat, prev_cat, l.tl, rem);
    switch (x.TAG) {
      case /* TSeq */ 0 :
        const y$p = delta_4(c, next_cat, prev_cat, x._0, /* [] */ 0);
        return delta_seq(c, next_cat, prev_cat, x._2, y$p, x._1, rem$1);
      case /* TExp */ 1 :
        return delta_1(x._0, c, next_cat, prev_cat, x._1, rem$1);
      case /* TMatch */ 2 :
        return {
          hd: x,
          tl: rem$1
        };
    }
  } else {
    return rem;
  }
}

function delta(tbl_ref, next_cat, $$char, st) {
  const prev_cat = st.category;
  const match = remove_duplicates(/* [] */ 0, delta_4($$char, next_cat, prev_cat, st.desc, /* [] */ 0), eps_expr);
  const expr$p = match[0];
  const idx = free_index(tbl_ref, expr$p);
  const expr$p$p = set_idx(idx, expr$p);
  return mk(idx, next_cat, expr$p$p);
}

function flatten_match(m) {
  const ma = Stdlib__List.fold_left((function (ma, param) {
        return Caml.caml_int_max(ma, param[0]);
      }), -1, m);
  const res = Caml_array.make(ma + 1 | 0, -1);
  Stdlib__List.iter((function (param) {
        Caml_array.set(res, param[0], param[1]);
      }), m);
  return res;
}

function status(s) {
  const st = s.status;
  if (st !== undefined) {
    return st;
  }
  const match = s.desc;
  let st$1;
  if (match) {
    const m = match.hd;
    switch (m.TAG) {
      case /* TSeq */ 0 :
      case /* TExp */ 1 :
        st$1 = /* Running */ 1;
        break;
      case /* TMatch */ 2 :
        const m$1 = m._0;
        st$1 = {
          TAG: /* Match */ 0,
          _0: flatten_match(m$1.marks),
          _1: m$1.pmarks
        };
        break;
    }
  } else {
    st$1 = /* Failed */ 0;
  }
  s.status = st$1;
  return st$1;
}

const Re_automata_Category = {
  $plus$plus: $plus$plus,
  from_char: from_char,
  inexistant: 1,
  letter: 2,
  not_letter: 4,
  newline: 8,
  lastnewline: 16,
  search_boundary: 32
};

const Re_automata_State = {
  dummy: dummy,
  create: create$2,
  Table: Table
};

function iter(_n, f, _v) {
  while (true) {
    const v = _v;
    const n = _n;
    if (n === 0) {
      return v;
    }
    _v = Curry._1(f, v);
    _n = n - 1 | 0;
    continue;
  };
}

function category(re, c) {
  if (c === -1) {
    return Re_automata_Category.inexistant;
  } else if (c === re.lnl) {
    return Curry._2(Re_automata_Category.$plus$plus, Curry._2(Re_automata_Category.$plus$plus, Re_automata_Category.lastnewline, Re_automata_Category.newline), Re_automata_Category.not_letter);
  } else {
    return Curry._1(Re_automata_Category.from_char, Caml_bytes.get(re.col_repr, c));
  }
}

const dummy_next = [];

const unknown_state = {
  idx: -2,
  real_idx: 0,
  next: dummy_next,
  final: /* [] */ 0,
  desc: Re_automata_State.dummy
};

function mk_state(ncol, desc) {
  const match = status(desc);
  let break_state;
  break_state = /* tag */ (typeof match === "number" || typeof match === "string") && match !== /* Failed */ 0 ? false : true;
  return {
    idx: break_state ? -3 : desc.idx,
    real_idx: desc.idx,
    next: break_state ? dummy_next : Caml_array.make(ncol, unknown_state),
    final: /* [] */ 0,
    desc: desc
  };
}

function find_state(re, desc) {
  try {
    return Curry._2(Re_automata_State.Table.find, re.states, desc);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      const st = mk_state(re.ncol, desc);
      Curry._3(Re_automata_State.Table.add, re.states, desc, st);
      return st;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function delta$1(info, cat, c, st) {
  const desc = delta(info.re.tbl, cat, c, st.desc);
  const len = info.positions.length;
  if (desc.idx === len && len > 0) {
    const pos = info.positions;
    info.positions = Caml_array.make((len << 1), 0);
    Stdlib__Array.blit(pos, 0, info.positions, 0, len);
  }
  return desc;
}

function validate(info, s, pos, st) {
  const c = Caml_bytes.get(info.i_cols, Caml_string.get(s, pos));
  const cat = category(info.re, c);
  const desc$p = delta$1(info, cat, c, st);
  const st$p = find_state(info.re, desc$p);
  Caml_array.set(st.next, c, st$p);
}

function loop(info, s, pos, st) {
  if (pos >= info.last) {
    return st;
  }
  const st$p = Caml_array.get(st.next, Caml_bytes.get(info.i_cols, Caml_string.get(s, pos)));
  let _pos = pos;
  let _st = st;
  let _st$p = st$p;
  while (true) {
    const st$p$1 = _st$p;
    const st$1 = _st;
    const pos$1 = _pos;
    if (st$p$1.idx < 0) {
      if (st$p$1.idx === -3) {
        Caml_array.set(info.positions, st$p$1.real_idx, pos$1 + 1 | 0);
        return st$p$1;
      } else {
        validate(info, s, pos$1, st$1);
        return loop(info, s, pos$1, st$1);
      }
    }
    const pos$2 = pos$1 + 1 | 0;
    if (pos$2 < info.last) {
      const st$p$p = Caml_array.get(st$p$1.next, Caml_bytes.get(info.i_cols, Caml_string.get(s, pos$2)));
      Caml_array.set(info.positions, st$p$1.idx, pos$2);
      _st$p = st$p$p;
      _st = st$p$1;
      _pos = pos$2;
      continue;
    }
    Caml_array.set(info.positions, st$p$1.idx, pos$2);
    return st$p$1;
  };
}

function $$final(info, st, cat) {
  try {
    return Stdlib__List.assq(cat, st.final);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      const st$p = delta$1(info, cat, -1, st);
      const res_0 = st$p.idx;
      const res_1 = status(st$p);
      const res = [
        res_0,
        res_1
      ];
      st.final = {
        hd: [
          cat,
          res
        ],
        tl: st.final
      };
      return res;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function find_initial_state(re, cat) {
  try {
    return Stdlib__List.assq(cat, re.initial_states);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      const st = find_state(re, Curry._2(Re_automata_State.create, cat, re.initial));
      re.initial_states = {
        hd: [
          cat,
          st
        ],
        tl: re.initial_states
      };
      return st;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function get_color(re, s, pos) {
  if (pos < 0) {
    return -1;
  }
  const slen = s.length;
  if (pos >= slen) {
    return -1;
  } else if (pos === (slen - 1 | 0) && re.lnl !== -1 && Caml_string.get(s, pos) === /* '\n' */10) {
    return re.lnl;
  } else {
    return Caml_bytes.get(re.cols, Caml_string.get(s, pos));
  }
}

function scan_str(info, s, initial_state, groups) {
  const pos = info.pos;
  const last = info.last;
  if (!(last === s.length && info.re.lnl !== -1 && last > pos && Caml_string.get(s, last - 1 | 0) === /* '\n' */10)) {
    if (groups) {
      return loop(info, s, pos, initial_state);
    } else {
      let _pos = pos;
      let _st = initial_state;
      while (true) {
        const st = _st;
        const pos$1 = _pos;
        if (pos$1 >= last) {
          return st;
        }
        const st$p = Caml_array.get(st.next, Caml_bytes.get(info.i_cols, Caml_string.get(s, pos$1)));
        if (st$p.idx >= 0) {
          _st = st$p;
          _pos = pos$1 + 1 | 0;
          continue;
        }
        if (st$p.idx === -3) {
          return st$p;
        }
        validate(info, s, pos$1, st);
        continue;
      };
    }
  }
  const info$1 = {
    re: info.re,
    i_cols: info.i_cols,
    positions: info.positions,
    pos: info.pos,
    last: last - 1 | 0
  };
  const st$1 = scan_str(info$1, s, initial_state, groups);
  if (st$1.idx === -3) {
    return st$1;
  } else {
    let pos$2 = last - 1 | 0;
    while (true) {
      const st$p$1 = Caml_array.get(st$1.next, info$1.re.lnl);
      if (st$p$1.idx >= 0) {
        if (groups) {
          Caml_array.set(info$1.positions, st$p$1.idx, pos$2 + 1 | 0);
        }
        return st$p$1;
      }
      if (st$p$1.idx === -3) {
        if (groups) {
          Caml_array.set(info$1.positions, st$p$1.real_idx, pos$2 + 1 | 0);
        }
        return st$p$1;
      }
      const c = info$1.re.lnl;
      const real_c = Caml_bytes.get(info$1.i_cols, /* '\n' */10);
      const cat = category(info$1.re, c);
      const desc$p = delta$1(info$1, cat, real_c, st$1);
      const st$p$2 = find_state(info$1.re, desc$p);
      Caml_array.set(st$1.next, c, st$p$2);
      continue;
    };
  }
}

function cadd(c, s) {
  return union(single(c), s);
}

function trans_set(cache, cm, s) {
  const i = one_char(s);
  if (i !== undefined) {
    return single(Caml_bytes.get(cm, i));
  }
  const v_0 = hash_rec(s);
  const v = [
    v_0,
    s
  ];
  try {
    return Curry._2(find, v, cache.contents);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      const l = Stdlib__List.fold_right((function (param, l) {
            return union(seq(Caml_bytes.get(cm, param[0]), Caml_bytes.get(cm, param[1])), l);
          }), s, /* [] */ 0);
      cache.contents = Curry._3(add, v, l, cache.contents);
      return l;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function is_charset(_param) {
  while (true) {
    const param = _param;
    if (/* tag */ typeof param === "number" || typeof param === "string") {
      return false;
    }
    switch (param.TAG) {
      case /* Set */ 0 :
        return true;
      case /* Sem */ 4 :
      case /* Sem_greedy */ 5 :
        _param = param._1;
        continue;
      case /* No_group */ 7 :
      case /* Case */ 9 :
      case /* No_case */ 10 :
        _param = param._0;
        continue;
      case /* Alternative */ 2 :
      case /* Intersection */ 11 :
      case /* Complement */ 12 :
        return Stdlib__List.for_all(is_charset, param._0);
      case /* Difference */ 13 :
        if (!is_charset(param._0)) {
          return false;
        }
        _param = param._1;
        continue;
      default:
        return false;
    }
  };
}

function split(s, cm) {
  let _t = s;
  const f = function (i, j) {
    Caml_bytes.set(cm, i, /* '\001' */1);
    Caml_bytes.set(cm, j + 1 | 0, /* '\001' */1);
  };
  while (true) {
    const t = _t;
    if (!t) {
      return;
    }
    const match = t.hd;
    Curry._2(f, match[0], match[1]);
    _t = t.tl;
    continue;
  };
}

const cupper = union(seq(/* 'A' */65, /* 'Z' */90), union(seq(/* '\192' */192, /* '\214' */214), seq(/* '\216' */216, /* '\222' */222)));

const clower = offset(32, cupper);

const calpha = Stdlib__List.fold_right(cadd, {
      hd: /* '\170' */170,
      tl: {
        hd: /* '\181' */181,
        tl: {
          hd: /* '\186' */186,
          tl: {
            hd: /* '\223' */223,
            tl: {
              hd: /* '\255' */255,
              tl: /* [] */ 0
            }
          }
        }
      }
    }, union(clower, cupper));

const cdigit = seq(/* '0' */48, /* '9' */57);

const calnum = union(calpha, cdigit);

const cword = union({
      hd: [
        /* '_' */95,
        /* '_' */95
      ],
      tl: /* [] */ 0
    }, calnum);

function colorize(c, regexp) {
  const lnl = {
    contents: false
  };
  const colorize$1 = function (_regexp) {
    while (true) {
      const regexp = _regexp;
      if (/* tag */ typeof regexp === "number" || typeof regexp === "string") {
        switch (regexp) {
          case /* Beg_of_line */ 0 :
          case /* End_of_line */ 1 :
            return split({
                  hd: [
                    /* '\n' */10,
                    /* '\n' */10
                  ],
                  tl: /* [] */ 0
                }, c);
          case /* Beg_of_word */ 2 :
          case /* End_of_word */ 3 :
          case /* Not_bound */ 4 :
            return split(cword, c);
          case /* Last_end_of_line */ 7 :
            lnl.contents = true;
            return;
          case /* Beg_of_str */ 5 :
          case /* End_of_str */ 6 :
          case /* Start */ 8 :
          case /* Stop */ 9 :
            return;
        }
      } else {
        switch (regexp.TAG) {
          case /* Set */ 0 :
            return split(regexp._0, c);
          case /* Sequence */ 1 :
          case /* Alternative */ 2 :
            return Stdlib__List.iter(colorize$1, regexp._0);
          case /* Repeat */ 3 :
          case /* Group */ 6 :
          case /* No_group */ 7 :
          case /* Nest */ 8 :
            _regexp = regexp._0;
            continue;
          case /* Sem */ 4 :
          case /* Sem_greedy */ 5 :
          case /* Pmark */ 14 :
            _regexp = regexp._1;
            continue;
          default:
            throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                  MEL_EXN_ID: "Assert_failure",
                  _1: [
                    "re.ml",
                    502,
                    35
                  ]
                });
        }
      }
    };
  };
  colorize$1(regexp);
  return lnl.contents;
}

function flatten_cmap(cm) {
  const c = Caml_bytes.caml_create_bytes(256);
  const col_repr = Caml_bytes.caml_create_bytes(256);
  let v = 0;
  Caml_bytes.set(c, 0, /* '\000' */0);
  Caml_bytes.set(col_repr, 0, /* '\000' */0);
  for (let i = 1; i <= 255; ++i) {
    if (Caml_bytes.get(cm, i) !== /* '\000' */0) {
      v = v + 1 | 0;
    }
    Caml_bytes.set(c, i, Stdlib__Char.chr(v));
    Caml_bytes.set(col_repr, v, Stdlib__Char.chr(i));
  }
  return [
    c,
    Stdlib__Bytes.sub(col_repr, 0, v + 1 | 0),
    v + 1 | 0
  ];
}

function equal$2(_x1, _x2) {
  while (true) {
    const x2 = _x2;
    const x1 = _x1;
    if (/* tag */ typeof x1 === "number" || typeof x1 === "string") {
      switch (x1) {
        case /* Beg_of_line */ 0 :
          if (/* tag */ (typeof x2 === "number" || typeof x2 === "string") && x2 === /* Beg_of_line */ 0) {
            return true;
          } else {
            return false;
          }
        case /* End_of_line */ 1 :
          if (/* tag */ (typeof x2 === "number" || typeof x2 === "string") && x2 === /* End_of_line */ 1) {
            return true;
          } else {
            return false;
          }
        case /* Beg_of_word */ 2 :
          if (/* tag */ (typeof x2 === "number" || typeof x2 === "string") && x2 === /* Beg_of_word */ 2) {
            return true;
          } else {
            return false;
          }
        case /* End_of_word */ 3 :
          if (/* tag */ (typeof x2 === "number" || typeof x2 === "string") && x2 === /* End_of_word */ 3) {
            return true;
          } else {
            return false;
          }
        case /* Not_bound */ 4 :
          if (/* tag */ (typeof x2 === "number" || typeof x2 === "string") && x2 === /* Not_bound */ 4) {
            return true;
          } else {
            return false;
          }
        case /* Beg_of_str */ 5 :
          if (/* tag */ (typeof x2 === "number" || typeof x2 === "string") && x2 === /* Beg_of_str */ 5) {
            return true;
          } else {
            return false;
          }
        case /* End_of_str */ 6 :
          if (/* tag */ (typeof x2 === "number" || typeof x2 === "string") && x2 === /* End_of_str */ 6) {
            return true;
          } else {
            return false;
          }
        case /* Last_end_of_line */ 7 :
          if (/* tag */ (typeof x2 === "number" || typeof x2 === "string") && x2 === /* Last_end_of_line */ 7) {
            return true;
          } else {
            return false;
          }
        case /* Start */ 8 :
          if (/* tag */ (typeof x2 === "number" || typeof x2 === "string") && x2 === /* Start */ 8) {
            return true;
          } else {
            return false;
          }
        case /* Stop */ 9 :
          if (/* tag */ (typeof x2 === "number" || typeof x2 === "string") && x2 === /* Stop */ 9) {
            return true;
          } else {
            return false;
          }
      }
    } else {
      switch (x1.TAG) {
        case /* Set */ 0 :
          if (/* tag */ typeof x2 === "number" || typeof x2 === "string" || x2.TAG !== /* Set */ 0) {
            return false;
          } else {
            return Caml_obj.caml_equal(x1._0, x2._0);
          }
        case /* Sequence */ 1 :
          if (/* tag */ typeof x2 === "number" || typeof x2 === "string" || x2.TAG !== /* Sequence */ 1) {
            return false;
          } else {
            return eq_list(x1._0, x2._0);
          }
        case /* Alternative */ 2 :
          if (/* tag */ typeof x2 === "number" || typeof x2 === "string" || x2.TAG !== /* Alternative */ 2) {
            return false;
          } else {
            return eq_list(x1._0, x2._0);
          }
        case /* Repeat */ 3 :
          if (/* tag */ typeof x2 === "number" || typeof x2 === "string") {
            return false;
          }
          if (x2.TAG !== /* Repeat */ 3) {
            return false;
          }
          if (x1._1 !== x2._1) {
            return false;
          }
          if (!Caml_obj.caml_equal(x1._2, x2._2)) {
            return false;
          }
          _x2 = x2._0;
          _x1 = x1._0;
          continue;
        case /* Sem */ 4 :
          if (/* tag */ typeof x2 === "number" || typeof x2 === "string") {
            return false;
          }
          if (x2.TAG !== /* Sem */ 4) {
            return false;
          }
          if (x1._0 !== x2._0) {
            return false;
          }
          _x2 = x2._1;
          _x1 = x1._1;
          continue;
        case /* Sem_greedy */ 5 :
          if (/* tag */ typeof x2 === "number" || typeof x2 === "string") {
            return false;
          }
          if (x2.TAG !== /* Sem_greedy */ 5) {
            return false;
          }
          if (x1._0 !== x2._0) {
            return false;
          }
          _x2 = x2._1;
          _x1 = x1._1;
          continue;
        case /* Group */ 6 :
          return false;
        case /* No_group */ 7 :
          if (/* tag */ typeof x2 === "number" || typeof x2 === "string") {
            return false;
          }
          if (x2.TAG !== /* No_group */ 7) {
            return false;
          }
          _x2 = x2._0;
          _x1 = x1._0;
          continue;
        case /* Nest */ 8 :
          if (/* tag */ typeof x2 === "number" || typeof x2 === "string") {
            return false;
          }
          if (x2.TAG !== /* Nest */ 8) {
            return false;
          }
          _x2 = x2._0;
          _x1 = x1._0;
          continue;
        case /* Case */ 9 :
          if (/* tag */ typeof x2 === "number" || typeof x2 === "string") {
            return false;
          }
          if (x2.TAG !== /* Case */ 9) {
            return false;
          }
          _x2 = x2._0;
          _x1 = x1._0;
          continue;
        case /* No_case */ 10 :
          if (/* tag */ typeof x2 === "number" || typeof x2 === "string") {
            return false;
          }
          if (x2.TAG !== /* No_case */ 10) {
            return false;
          }
          _x2 = x2._0;
          _x1 = x1._0;
          continue;
        case /* Intersection */ 11 :
          if (/* tag */ typeof x2 === "number" || typeof x2 === "string" || x2.TAG !== /* Intersection */ 11) {
            return false;
          } else {
            return eq_list(x1._0, x2._0);
          }
        case /* Complement */ 12 :
          if (/* tag */ typeof x2 === "number" || typeof x2 === "string" || x2.TAG !== /* Complement */ 12) {
            return false;
          } else {
            return eq_list(x1._0, x2._0);
          }
        case /* Difference */ 13 :
          if (/* tag */ typeof x2 === "number" || typeof x2 === "string") {
            return false;
          }
          if (x2.TAG !== /* Difference */ 13) {
            return false;
          }
          if (!equal$2(x1._0, x2._0)) {
            return false;
          }
          _x2 = x2._1;
          _x1 = x1._1;
          continue;
        case /* Pmark */ 14 :
          if (/* tag */ typeof x2 === "number" || typeof x2 === "string") {
            return false;
          }
          if (x2.TAG !== /* Pmark */ 14) {
            return false;
          }
          if (x1._0 !== x2._0) {
            return false;
          }
          _x2 = x2._1;
          _x1 = x1._1;
          continue;
      }
    }
  };
}

function eq_list(_l1, _l2) {
  while (true) {
    const l2 = _l2;
    const l1 = _l1;
    if (!l1) {
      if (l2) {
        return false;
      } else {
        return true;
      }
    }
    if (!l2) {
      return false;
    }
    if (!equal$2(l1.hd, l2.hd)) {
      return false;
    }
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue;
  };
}

function sequence(l) {
  if (l && !l.tl) {
    return l.hd;
  } else {
    return {
      TAG: /* Sequence */ 1,
      _0: l
    };
  }
}

function merge_sequences(_param) {
  while (true) {
    const param = _param;
    if (!param) {
      return /* [] */ 0;
    }
    const l$p = param.hd;
    if (!/* tag */ (typeof l$p === "number" || typeof l$p === "string")) {
      switch (l$p.TAG) {
        case /* Sequence */ 1 :
          const match = l$p._0;
          if (match) {
            const y = match.tl;
            const x = match.hd;
            const r$p = merge_sequences(param.tl);
            let exit = 0;
            if (r$p) {
              const match$1 = r$p.hd;
              if (/* tag */ typeof match$1 === "number" || typeof match$1 === "string" || match$1.TAG !== /* Sequence */ 1) {
                exit = 2;
              } else {
                const match$2 = match$1._0;
                if (match$2) {
                  if (equal$2(x, match$2.hd)) {
                    return {
                      hd: {
                        TAG: /* Sequence */ 1,
                        _0: {
                          hd: x,
                          tl: {
                            hd: {
                              TAG: /* Alternative */ 2,
                              _0: {
                                hd: sequence(y),
                                tl: {
                                  hd: sequence(match$2.tl),
                                  tl: /* [] */ 0
                                }
                              }
                            },
                            tl: /* [] */ 0
                          }
                        }
                      },
                      tl: r$p.tl
                    };
                  }
                  exit = 2;
                } else {
                  exit = 2;
                }
              }
            } else {
              exit = 2;
            }
            if (exit === 2) {
              return {
                hd: {
                  TAG: /* Sequence */ 1,
                  _0: {
                    hd: x,
                    tl: y
                  }
                },
                tl: r$p
              };
            }
            
          }
          break;
        case /* Alternative */ 2 :
          _param = Stdlib.$at(l$p._0, param.tl);
          continue;
      }
    }
    return {
      hd: l$p,
      tl: merge_sequences(param.tl)
    };
  };
}

function enforce_kind(ids, kind, kind$p, cr) {
  if (kind === "First" && kind$p !== "First") {
    return seq$1(ids, kind$p, cr, mk_expr(ids, /* Eps */ 0));
  } else {
    return cr;
  }
}

function translate(ids, kind, _ign_group, ign_case, _greedy, pos, cache, c, _s) {
  while (true) {
    const s = _s;
    const greedy = _greedy;
    const ign_group = _ign_group;
    if (/* tag */ typeof s === "number" || typeof s === "string") {
      switch (s) {
        case /* Beg_of_line */ 0 :
          const c$1 = Curry._2(Re_automata_Category.$plus$plus, Re_automata_Category.inexistant, Re_automata_Category.newline);
          return [
            mk_expr(ids, {
                  TAG: /* After */ 7,
                  _0: c$1
                }),
            kind
          ];
        case /* End_of_line */ 1 :
          const c$2 = Curry._2(Re_automata_Category.$plus$plus, Re_automata_Category.inexistant, Re_automata_Category.newline);
          return [
            mk_expr(ids, {
                  TAG: /* Before */ 6,
                  _0: c$2
                }),
            kind
          ];
        case /* Beg_of_word */ 2 :
          const c$3 = Curry._2(Re_automata_Category.$plus$plus, Re_automata_Category.inexistant, Re_automata_Category.not_letter);
          const c$4 = Curry._2(Re_automata_Category.$plus$plus, Re_automata_Category.inexistant, Re_automata_Category.letter);
          return [
            seq$1(ids, "First", mk_expr(ids, {
                      TAG: /* After */ 7,
                      _0: c$3
                    }), mk_expr(ids, {
                      TAG: /* Before */ 6,
                      _0: c$4
                    })),
            kind
          ];
        case /* End_of_word */ 3 :
          const c$5 = Curry._2(Re_automata_Category.$plus$plus, Re_automata_Category.inexistant, Re_automata_Category.letter);
          const c$6 = Curry._2(Re_automata_Category.$plus$plus, Re_automata_Category.inexistant, Re_automata_Category.not_letter);
          return [
            seq$1(ids, "First", mk_expr(ids, {
                      TAG: /* After */ 7,
                      _0: c$5
                    }), mk_expr(ids, {
                      TAG: /* Before */ 6,
                      _0: c$6
                    })),
            kind
          ];
        case /* Not_bound */ 4 :
          return [
            alt(ids, {
                  hd: seq$1(ids, "First", mk_expr(ids, {
                            TAG: /* After */ 7,
                            _0: Re_automata_Category.letter
                          }), mk_expr(ids, {
                            TAG: /* Before */ 6,
                            _0: Re_automata_Category.letter
                          })),
                  tl: {
                    hd: seq$1(ids, "First", mk_expr(ids, {
                              TAG: /* After */ 7,
                              _0: Re_automata_Category.letter
                            }), mk_expr(ids, {
                              TAG: /* Before */ 6,
                              _0: Re_automata_Category.letter
                            })),
                    tl: /* [] */ 0
                  }
                }),
            kind
          ];
        case /* Beg_of_str */ 5 :
          return [
            mk_expr(ids, {
                  TAG: /* After */ 7,
                  _0: Re_automata_Category.inexistant
                }),
            kind
          ];
        case /* End_of_str */ 6 :
          return [
            mk_expr(ids, {
                  TAG: /* Before */ 6,
                  _0: Re_automata_Category.inexistant
                }),
            kind
          ];
        case /* Last_end_of_line */ 7 :
          const c$7 = Curry._2(Re_automata_Category.$plus$plus, Re_automata_Category.inexistant, Re_automata_Category.lastnewline);
          return [
            mk_expr(ids, {
                  TAG: /* Before */ 6,
                  _0: c$7
                }),
            kind
          ];
        case /* Start */ 8 :
          return [
            mk_expr(ids, {
                  TAG: /* After */ 7,
                  _0: Re_automata_Category.search_boundary
                }),
            kind
          ];
        case /* Stop */ 9 :
          return [
            mk_expr(ids, {
                  TAG: /* Before */ 6,
                  _0: Re_automata_Category.search_boundary
                }),
            kind
          ];
      }
    } else {
      switch (s.TAG) {
        case /* Set */ 0 :
          return [
            cst(ids, trans_set(cache, c, s._0)),
            kind
          ];
        case /* Sequence */ 1 :
          return [
            trans_seq(ids, kind, ign_group, ign_case, greedy, pos, cache, c, s._0),
            kind
          ];
        case /* Alternative */ 2 :
          const merged_sequences = merge_sequences(s._0);
          if (merged_sequences && !merged_sequences.tl) {
            const match = translate(ids, kind, ign_group, ign_case, greedy, pos, cache, c, merged_sequences.hd);
            return [
              enforce_kind(ids, kind, match[1], match[0]),
              kind
            ];
          }
          return [
            alt(ids, Stdlib__List.map((function (r$p) {
                      const match = translate(ids, kind, ign_group, ign_case, greedy, pos, cache, c, r$p);
                      return enforce_kind(ids, kind, match[1], match[0]);
                    }), merged_sequences)),
            kind
          ];
        case /* Repeat */ 3 :
          const j = s._2;
          const i = s._1;
          const match$1 = translate(ids, kind, ign_group, ign_case, greedy, pos, cache, c, s._0);
          const kind$p = match$1[1];
          const cr = match$1[0];
          let rem;
          if (j !== undefined) {
            const f = greedy === "Non_greedy" ? (function (rem) {
                return alt(ids, {
                      hd: mk_expr(ids, /* Eps */ 0),
                      tl: {
                        hd: seq$1(ids, kind$p, rename(ids, cr), rem),
                        tl: /* [] */ 0
                      }
                    });
              }) : (function (rem) {
                return alt(ids, {
                      hd: seq$1(ids, kind$p, rename(ids, cr), rem),
                      tl: {
                        hd: mk_expr(ids, /* Eps */ 0),
                        tl: /* [] */ 0
                      }
                    });
              });
            rem = iter(j - i | 0, f, mk_expr(ids, /* Eps */ 0));
          } else {
            rem = rep(ids, greedy, kind$p, cr);
          }
          return [
            iter(i, (function (rem) {
                  return seq$1(ids, kind$p, rename(ids, cr), rem);
                }), rem),
            kind
          ];
        case /* Sem */ 4 :
          const kind$p$1 = s._0;
          const match$2 = translate(ids, kind$p$1, ign_group, ign_case, greedy, pos, cache, c, s._1);
          return [
            enforce_kind(ids, kind$p$1, match$2[1], match$2[0]),
            kind$p$1
          ];
        case /* Sem_greedy */ 5 :
          _s = s._1;
          _greedy = s._0;
          continue;
        case /* Group */ 6 :
          const r$p = s._0;
          if (ign_group) {
            _s = r$p;
            continue;
          }
          const p = pos.contents;
          pos.contents = pos.contents + 2 | 0;
          const match$3 = translate(ids, kind, ign_group, ign_case, greedy, pos, cache, c, r$p);
          return [
            seq$1(ids, "First", mk_expr(ids, {
                      TAG: /* Mark */ 4,
                      _0: p
                    }), seq$1(ids, "First", match$3[0], mk_expr(ids, {
                          TAG: /* Mark */ 4,
                          _0: p + 1 | 0
                        }))),
            match$3[1]
          ];
        case /* No_group */ 7 :
          _s = s._0;
          _ign_group = true;
          continue;
        case /* Nest */ 8 :
          const b = pos.contents;
          const match$4 = translate(ids, kind, ign_group, ign_case, greedy, pos, cache, c, s._0);
          const kind$p$2 = match$4[1];
          const cr$1 = match$4[0];
          const e = pos.contents - 1 | 0;
          if (e < b) {
            return [
              cr$1,
              kind$p$2
            ];
          } else {
            return [
              seq$1(ids, "First", erase(ids, b, e), cr$1),
              kind$p$2
            ];
          }
        case /* Pmark */ 14 :
          const match$5 = translate(ids, kind, ign_group, ign_case, greedy, pos, cache, c, s._1);
          return [
            seq$1(ids, "First", mk_expr(ids, {
                      TAG: /* Pmark */ 8,
                      _0: s._0
                    }), match$5[0]),
            match$5[1]
          ];
        default:
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "re.ml",
                  714,
                  4
                ]
              });
      }
    }
  };
}

function trans_seq(ids, kind, ign_group, ign_case, greedy, pos, cache, c, param) {
  if (!param) {
    return mk_expr(ids, /* Eps */ 0);
  }
  const r = param.hd;
  if (param.tl) {
    const match = translate(ids, kind, ign_group, ign_case, greedy, pos, cache, c, r);
    const cr$p = match[0];
    const cr$p$p = trans_seq(ids, kind, ign_group, ign_case, greedy, pos, cache, c, param.tl);
    if (is_eps(cr$p$p)) {
      return cr$p;
    } else if (is_eps(cr$p)) {
      return cr$p$p;
    } else {
      return seq$1(ids, match[1], cr$p, cr$p$p);
    }
  }
  const match$1 = translate(ids, kind, ign_group, ign_case, greedy, pos, cache, c, r);
  return enforce_kind(ids, kind, match$1[1], match$1[0]);
}

function case_insens(s) {
  return union(s, union(offset(32, inter(s, cupper)), offset(-32, inter(s, clower))));
}

function as_set(s) {
  if (/* tag */ typeof s === "number" || typeof s === "string") {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "re.ml",
            747,
            13
          ]
        });
  }
  if (s.TAG === /* Set */ 0) {
    return s._0;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "re.ml",
          747,
          13
        ]
      });
}

function handle_case(_ign_case, _s) {
  while (true) {
    const s = _s;
    const ign_case = _ign_case;
    if (/* tag */ typeof s === "number" || typeof s === "string") {
      return s;
    }
    switch (s.TAG) {
      case /* Set */ 0 :
        const s$1 = s._0;
        return {
          TAG: /* Set */ 0,
          _0: ign_case ? case_insens(s$1) : s$1
        };
      case /* Sequence */ 1 :
        return {
          TAG: /* Sequence */ 1,
          _0: Stdlib__List.map((function (param) {
                return handle_case(ign_case, param);
              }), s._0)
        };
      case /* Alternative */ 2 :
        const l$p = Stdlib__List.map((function (param) {
              return handle_case(ign_case, param);
            }), s._0);
        if (is_charset({
                TAG: /* Alternative */ 2,
                _0: l$p
              })) {
          return {
            TAG: /* Set */ 0,
            _0: Stdlib__List.fold_left((function (s, r) {
                  return union(s, as_set(r));
                }), /* [] */ 0, l$p)
          };
        } else {
          return {
            TAG: /* Alternative */ 2,
            _0: l$p
          };
        }
      case /* Repeat */ 3 :
        return {
          TAG: /* Repeat */ 3,
          _0: handle_case(ign_case, s._0),
          _1: s._1,
          _2: s._2
        };
      case /* Sem */ 4 :
        const r$p = handle_case(ign_case, s._1);
        if (is_charset(r$p)) {
          return r$p;
        } else {
          return {
            TAG: /* Sem */ 4,
            _0: s._0,
            _1: r$p
          };
        }
      case /* Sem_greedy */ 5 :
        const r$p$1 = handle_case(ign_case, s._1);
        if (is_charset(r$p$1)) {
          return r$p$1;
        } else {
          return {
            TAG: /* Sem_greedy */ 5,
            _0: s._0,
            _1: r$p$1
          };
        }
      case /* Group */ 6 :
        return {
          TAG: /* Group */ 6,
          _0: handle_case(ign_case, s._0)
        };
      case /* No_group */ 7 :
        const r$p$2 = handle_case(ign_case, s._0);
        if (is_charset(r$p$2)) {
          return r$p$2;
        } else {
          return {
            TAG: /* No_group */ 7,
            _0: r$p$2
          };
        }
      case /* Nest */ 8 :
        const r$p$3 = handle_case(ign_case, s._0);
        if (is_charset(r$p$3)) {
          return r$p$3;
        } else {
          return {
            TAG: /* Nest */ 8,
            _0: r$p$3
          };
        }
      case /* Case */ 9 :
        _s = s._0;
        _ign_case = false;
        continue;
      case /* No_case */ 10 :
        _s = s._0;
        _ign_case = true;
        continue;
      case /* Intersection */ 11 :
        const l$p$1 = Stdlib__List.map((function (r) {
              return handle_case(ign_case, r);
            }), s._0);
        return {
          TAG: /* Set */ 0,
          _0: Stdlib__List.fold_left((function (s, r) {
                return inter(s, as_set(r));
              }), cany, l$p$1)
        };
      case /* Complement */ 12 :
        const l$p$2 = Stdlib__List.map((function (r) {
              return handle_case(ign_case, r);
            }), s._0);
        return {
          TAG: /* Set */ 0,
          _0: diff(cany, Stdlib__List.fold_left((function (s, r) {
                    return union(s, as_set(r));
                  }), /* [] */ 0, l$p$2))
        };
      case /* Difference */ 13 :
        return {
          TAG: /* Set */ 0,
          _0: inter(as_set(handle_case(ign_case, s._0)), diff(cany, as_set(handle_case(ign_case, s._1))))
        };
      case /* Pmark */ 14 :
        return {
          TAG: /* Pmark */ 14,
          _0: s._0,
          _1: handle_case(ign_case, s._1)
        };
    }
  };
}

function anchored(_l) {
  while (true) {
    const l = _l;
    if (/* tag */ typeof l === "number" || typeof l === "string") {
      switch (l) {
        case /* Beg_of_str */ 5 :
        case /* Start */ 8 :
          return true;
        default:
          return false;
      }
    } else {
      switch (l.TAG) {
        case /* Sequence */ 1 :
          return Stdlib__List.exists(anchored, l._0);
        case /* Alternative */ 2 :
          return Stdlib__List.for_all(anchored, l._0);
        case /* Repeat */ 3 :
          if (l._1 <= 0) {
            return false;
          }
          _l = l._0;
          continue;
        case /* Group */ 6 :
        case /* No_group */ 7 :
        case /* Nest */ 8 :
        case /* Case */ 9 :
        case /* No_case */ 10 :
          _l = l._0;
          continue;
        case /* Sem */ 4 :
        case /* Sem_greedy */ 5 :
        case /* Pmark */ 14 :
          _l = l._1;
          continue;
        default:
          return false;
      }
    }
  };
}

function alt$1(l) {
  if (l && !l.tl) {
    return l.hd;
  } else {
    return {
      TAG: /* Alternative */ 2,
      _0: l
    };
  }
}

function seq$2(l) {
  if (l && !l.tl) {
    return l.hd;
  } else {
    return {
      TAG: /* Sequence */ 1,
      _0: l
    };
  }
}

const epsilon = {
  TAG: /* Sequence */ 1,
  _0: /* [] */ 0
};

function repn(r, i, j) {
  if (i < 0) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Re.repn"
        });
  }
  if (j !== undefined && j < i) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Re.repn"
        });
  }
  return {
    TAG: /* Repeat */ 3,
    _0: r,
    _1: i,
    _2: j
  };
}

function set(str) {
  let s = /* [] */ 0;
  for (let i = 0, i_finish = str.length; i < i_finish; ++i) {
    s = union(single(Caml_string.get(str, i)), s);
  }
  return {
    TAG: /* Set */ 0,
    _0: s
  };
}

function compl(l) {
  const r = {
    TAG: /* Complement */ 12,
    _0: l
  };
  if (is_charset(r)) {
    return r;
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Re.compl"
      });
}

const any = {
  TAG: /* Set */ 0,
  _0: cany
};

const notnl = {
  TAG: /* Set */ 0,
  _0: diff(cany, {
        hd: [
          /* '\n' */10,
          /* '\n' */10
        ],
        tl: /* [] */ 0
      })
};

const lower = alt$1({
      hd: {
        TAG: /* Set */ 0,
        _0: seq(/* 'a' */97, /* 'z' */122)
      },
      tl: {
        hd: {
          TAG: /* Set */ 0,
          _0: {
            hd: [
              /* '\181' */181,
              /* '\181' */181
            ],
            tl: /* [] */ 0
          }
        },
        tl: {
          hd: {
            TAG: /* Set */ 0,
            _0: seq(/* '\223' */223, /* '\246' */246)
          },
          tl: {
            hd: {
              TAG: /* Set */ 0,
              _0: seq(/* '\248' */248, /* '\255' */255)
            },
            tl: /* [] */ 0
          }
        }
      }
    });

const upper = alt$1({
      hd: {
        TAG: /* Set */ 0,
        _0: seq(/* 'A' */65, /* 'Z' */90)
      },
      tl: {
        hd: {
          TAG: /* Set */ 0,
          _0: seq(/* '\192' */192, /* '\214' */214)
        },
        tl: {
          hd: {
            TAG: /* Set */ 0,
            _0: seq(/* '\216' */216, /* '\222' */222)
          },
          tl: /* [] */ 0
        }
      }
    });

const alpha = alt$1({
      hd: lower,
      tl: {
        hd: upper,
        tl: {
          hd: {
            TAG: /* Set */ 0,
            _0: {
              hd: [
                /* '\170' */170,
                /* '\170' */170
              ],
              tl: /* [] */ 0
            }
          },
          tl: {
            hd: {
              TAG: /* Set */ 0,
              _0: {
                hd: [
                  /* '\186' */186,
                  /* '\186' */186
                ],
                tl: /* [] */ 0
              }
            },
            tl: /* [] */ 0
          }
        }
      }
    });

const digit = {
  TAG: /* Set */ 0,
  _0: seq(/* '0' */48, /* '9' */57)
};

const alnum = alt$1({
      hd: alpha,
      tl: {
        hd: digit,
        tl: /* [] */ 0
      }
    });

const wordc = alt$1({
      hd: alnum,
      tl: {
        hd: {
          TAG: /* Set */ 0,
          _0: {
            hd: [
              /* '_' */95,
              /* '_' */95
            ],
            tl: /* [] */ 0
          }
        },
        tl: /* [] */ 0
      }
    });

const ascii = {
  TAG: /* Set */ 0,
  _0: seq(/* '\000' */0, /* '\127' */127)
};

const blank = set("\t ");

const cntrl = alt$1({
      hd: {
        TAG: /* Set */ 0,
        _0: seq(/* '\000' */0, /* '\031' */31)
      },
      tl: {
        hd: {
          TAG: /* Set */ 0,
          _0: seq(/* '\127' */127, /* '\159' */159)
        },
        tl: /* [] */ 0
      }
    });

const graph = alt$1({
      hd: {
        TAG: /* Set */ 0,
        _0: seq(/* '!' */33, /* '~' */126)
      },
      tl: {
        hd: {
          TAG: /* Set */ 0,
          _0: seq(/* '\160' */160, /* '\255' */255)
        },
        tl: /* [] */ 0
      }
    });

const print = alt$1({
      hd: {
        TAG: /* Set */ 0,
        _0: seq(/* ' ' */32, /* '~' */126)
      },
      tl: {
        hd: {
          TAG: /* Set */ 0,
          _0: seq(/* '\160' */160, /* '\255' */255)
        },
        tl: /* [] */ 0
      }
    });

const punct = alt$1({
      hd: {
        TAG: /* Set */ 0,
        _0: seq(/* '!' */33, /* '/' */47)
      },
      tl: {
        hd: {
          TAG: /* Set */ 0,
          _0: seq(/* ':' */58, /* '@' */64)
        },
        tl: {
          hd: {
            TAG: /* Set */ 0,
            _0: seq(/* '[' */91, /* '`' */96)
          },
          tl: {
            hd: {
              TAG: /* Set */ 0,
              _0: seq(/* '{' */123, /* '~' */126)
            },
            tl: {
              hd: {
                TAG: /* Set */ 0,
                _0: seq(/* '\160' */160, /* '\169' */169)
              },
              tl: {
                hd: {
                  TAG: /* Set */ 0,
                  _0: seq(/* '\171' */171, /* '\180' */180)
                },
                tl: {
                  hd: {
                    TAG: /* Set */ 0,
                    _0: seq(/* '\182' */182, /* '\185' */185)
                  },
                  tl: {
                    hd: {
                      TAG: /* Set */ 0,
                      _0: seq(/* '\187' */187, /* '\191' */191)
                    },
                    tl: {
                      hd: {
                        TAG: /* Set */ 0,
                        _0: {
                          hd: [
                            /* '\215' */215,
                            /* '\215' */215
                          ],
                          tl: /* [] */ 0
                        }
                      },
                      tl: {
                        hd: {
                          TAG: /* Set */ 0,
                          _0: {
                            hd: [
                              /* '\247' */247,
                              /* '\247' */247
                            ],
                            tl: /* [] */ 0
                          }
                        },
                        tl: /* [] */ 0
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    });

const space = alt$1({
      hd: {
        TAG: /* Set */ 0,
        _0: {
          hd: [
            /* ' ' */32,
            /* ' ' */32
          ],
          tl: /* [] */ 0
        }
      },
      tl: {
        hd: {
          TAG: /* Set */ 0,
          _0: seq(/* '\t' */9, /* '\r' */13)
        },
        tl: /* [] */ 0
      }
    });

const xdigit = alt$1({
      hd: digit,
      tl: {
        hd: {
          TAG: /* Set */ 0,
          _0: seq(/* 'a' */97, /* 'f' */102)
        },
        tl: {
          hd: {
            TAG: /* Set */ 0,
            _0: seq(/* 'A' */65, /* 'F' */70)
          },
          tl: /* [] */ 0
        }
      }
    });

function compile(r) {
  let regexp = anchored(r) ? ({
      TAG: /* Group */ 6,
      _0: r
    }) : seq$2({
          hd: {
            TAG: /* Sem */ 4,
            _0: "Shortest",
            _1: repn(any, 0, undefined)
          },
          tl: {
            hd: {
              TAG: /* Group */ 6,
              _0: r
            },
            tl: /* [] */ 0
          }
        });
  const regexp$1 = handle_case(false, regexp);
  const c = Stdlib__Bytes.make(257, /* '\000' */0);
  const need_lnl = colorize(c, regexp$1);
  const match = flatten_cmap(c);
  const ncol = match[2];
  const col = match[0];
  const lnl = need_lnl ? ncol : -1;
  const ncol$1 = need_lnl ? ncol + 1 | 0 : ncol;
  const ids = {
    contents: 0
  };
  const pos = {
    contents: 0
  };
  const match$1 = translate(ids, "First", false, false, "Greedy", pos, {
        contents: /* Empty */ 0
      }, col, regexp$1);
  const r$1 = enforce_kind(ids, "First", match$1[1], match$1[0]);
  let col_repr = match[1];
  let group_count = pos.contents / 2 | 0;
  return {
    initial: r$1,
    initial_states: /* [] */ 0,
    cols: col,
    col_repr: col_repr,
    ncol: ncol$1,
    lnl: lnl,
    tbl: {
      contents: [false]
    },
    states: Curry._1(Re_automata_State.Table.create, 97),
    group_count: group_count
  };
}

function exec_internal(name, posOpt, lenOpt, groups, re, s) {
  const pos = posOpt !== undefined ? posOpt : 0;
  const len = lenOpt !== undefined ? lenOpt : -1;
  if (pos < 0 || len < -1 || (pos + len | 0) > s.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: name
        });
  }
  let partial = false;
  const slen = s.length;
  const last = len === -1 ? slen : pos + len | 0;
  let tmp;
  if (groups) {
    const n = re.tbl.contents.length + 1 | 0;
    tmp = n <= 10 ? [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ] : Caml_array.make(n, 0);
  } else {
    tmp = [];
  }
  const info = {
    re: re,
    i_cols: re.cols,
    positions: tmp,
    pos: pos,
    last: last
  };
  const initial_cat = pos === 0 ? Curry._2(Re_automata_Category.$plus$plus, Re_automata_Category.search_boundary, Re_automata_Category.inexistant) : Curry._2(Re_automata_Category.$plus$plus, Re_automata_Category.search_boundary, category(re, get_color(re, s, pos - 1 | 0)));
  const initial_state = find_initial_state(re, initial_cat);
  const st = scan_str(info, s, initial_state, groups);
  let res;
  if (st.idx === -3 || partial) {
    res = status(st.desc);
  } else {
    const final_cat = last === slen ? Curry._2(Re_automata_Category.$plus$plus, Re_automata_Category.search_boundary, Re_automata_Category.inexistant) : Curry._2(Re_automata_Category.$plus$plus, Re_automata_Category.search_boundary, category(re, get_color(re, s, last)));
    const match = $$final(info, st, final_cat);
    if (groups) {
      Caml_array.set(info.positions, match[0], last + 1 | 0);
    }
    res = match[1];
  }
  if (/* tag */ typeof res === "number" || typeof res === "string") {
    if (res === /* Failed */ 0) {
      return /* Failed */ 0;
    } else {
      return /* Running */ 1;
    }
  } else {
    return {
      TAG: /* Match */ 0,
      _0: {
        s: s,
        marks: res._0,
        pmarks: res._1,
        gpos: info.positions,
        gcount: re.group_count
      }
    };
  }
}

function offset$1(t, i) {
  if (((i << 1) + 1 | 0) >= t.marks.length) {
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
          MEL_EXN_ID: Stdlib.Not_found
        });
  }
  const m1 = Caml_array.get(t.marks, (i << 1));
  if (m1 === -1) {
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
          MEL_EXN_ID: Stdlib.Not_found
        });
  }
  const p1 = Caml_array.get(t.gpos, m1) - 1 | 0;
  const p2 = Caml_array.get(t.gpos, Caml_array.get(t.marks, (i << 1) + 1 | 0)) - 1 | 0;
  return [
    p1,
    p2
  ];
}

function get(t, i) {
  const match = offset$1(t, i);
  const p1 = match[0];
  return Stdlib__String.sub(t.s, p1, match[1] - p1 | 0);
}

const Parse_error = /* @__PURE__ */ Caml_exceptions.create("Parse_error");

const Not_supported = /* @__PURE__ */ Caml_exceptions.create("Not_supported");

function posix_class_of_string(class_) {
  switch (class_) {
    case "alnum" :
      return alnum;
    case "ascii" :
      return ascii;
    case "blank" :
      return blank;
    case "cntrl" :
      return cntrl;
    case "digit" :
      return digit;
    case "graph" :
      return graph;
    case "lower" :
      return lower;
    case "print" :
      return print;
    case "punct" :
      return punct;
    case "space" :
      return space;
    case "upper" :
      return upper;
    case "word" :
      return wordc;
    case "xdigit" :
      return xdigit;
    default:
      const s = "Invalid pcre class: " + class_;
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: s
          });
  }
}

function parse(multiline, dollar_endonly, dotall, ungreedy, s) {
  const i = {
    contents: 0
  };
  const l = s.length;
  const test = function (c) {
    if (i.contents !== l) {
      return Caml_string.get(s, i.contents) === c;
    } else {
      return false;
    }
  };
  const accept = function (c) {
    const r = test(c);
    if (r) {
      i.contents = i.contents + 1 | 0;
    }
    return r;
  };
  const accept_s = function (s$p) {
    const len = s$p.length;
    try {
      for (let j = 0; j < len; ++j) {
        try {
          if (Caml_string.get(s$p, j) !== Caml_string.get(s, i.contents + j | 0)) {
            throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                  MEL_EXN_ID: Stdlib.Exit
                });
          }
          
        }
        catch (exn){
          throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                MEL_EXN_ID: Stdlib.Exit
              });
        }
      }
      i.contents = i.contents + len | 0;
      return true;
    }
    catch (raw_exn){
      const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn$1.MEL_EXN_ID === Stdlib.Exit) {
        return false;
      }
      throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
    }
  };
  const get = function (param) {
    const r = Caml_string.get(s, i.contents);
    i.contents = i.contents + 1 | 0;
    return r;
  };
  const greedy_mod = function (r) {
    const gr = accept(/* '?' */63);
    const gr$1 = ungreedy ? !gr : gr;
    if (gr$1) {
      return {
        TAG: /* Sem_greedy */ 5,
        _0: "Non_greedy",
        _1: r
      };
    } else {
      return {
        TAG: /* Sem_greedy */ 5,
        _0: "Greedy",
        _1: r
      };
    }
  };
  const atom = function (param) {
    if (accept(/* '.' */46)) {
      if (dotall) {
        return any;
      } else {
        return notnl;
      }
    }
    if (accept(/* '(' */40)) {
      if (accept(/* '?' */63)) {
        if (accept(/* ':' */58)) {
          const r = regexp$p(branch$p(/* [] */ 0));
          if (!accept(/* ')' */41)) {
            throw new Caml_js_exceptions.MelangeError(Parse_error, {
                  MEL_EXN_ID: Parse_error
                });
          }
          return r;
        }
        if (accept(/* '#' */35)) {
          let _param;
          while (true) {
            if (accept(/* ')' */41)) {
              return epsilon;
            }
            i.contents = i.contents + 1 | 0;
            _param = undefined;
            continue;
          };
        }
        throw new Caml_js_exceptions.MelangeError(Parse_error, {
              MEL_EXN_ID: Parse_error
            });
      }
      const r$1 = regexp$p(branch$p(/* [] */ 0));
      if (!accept(/* ')' */41)) {
        throw new Caml_js_exceptions.MelangeError(Parse_error, {
              MEL_EXN_ID: Parse_error
            });
      }
      return {
        TAG: /* Group */ 6,
        _0: r$1
      };
    }
    if (accept(/* '^' */94)) {
      if (multiline) {
        return /* Beg_of_line */ 0;
      } else {
        return /* Beg_of_str */ 5;
      }
    }
    if (accept(/* '$' */36)) {
      if (multiline) {
        return /* End_of_line */ 1;
      } else if (dollar_endonly) {
        return /* Last_end_of_line */ 7;
      } else {
        return /* End_of_str */ 6;
      }
    }
    if (accept(/* '[' */91)) {
      if (accept(/* '^' */94)) {
        return compl(bracket(/* [] */ 0));
      } else {
        return alt$1(bracket(/* [] */ 0));
      }
    }
    if (accept(/* '\\' */92)) {
      if (i.contents === l) {
        throw new Caml_js_exceptions.MelangeError(Parse_error, {
              MEL_EXN_ID: Parse_error
            });
      }
      const c = get(undefined);
      switch (c) {
        case 48 :
        case 49 :
        case 50 :
        case 51 :
        case 52 :
        case 53 :
        case 54 :
        case 55 :
        case 56 :
        case 57 :
          throw new Caml_js_exceptions.MelangeError(Not_supported, {
                MEL_EXN_ID: Not_supported
              });
        case 65 :
          return /* Beg_of_str */ 5;
        case 66 :
          return /* Not_bound */ 4;
        case 68 :
          return compl({
                hd: digit,
                tl: /* [] */ 0
              });
        case 71 :
          return /* Start */ 8;
        case 83 :
          return compl({
                hd: space,
                tl: /* [] */ 0
              });
        case 87 :
          return compl({
                hd: alnum,
                tl: {
                  hd: {
                    TAG: /* Set */ 0,
                    _0: {
                      hd: [
                        /* '_' */95,
                        /* '_' */95
                      ],
                      tl: /* [] */ 0
                    }
                  },
                  tl: /* [] */ 0
                }
              });
        case 90 :
          return /* Last_end_of_line */ 7;
        case 98 :
          return alt$1({
                hd: /* Beg_of_word */ 2,
                tl: {
                  hd: /* End_of_word */ 3,
                  tl: /* [] */ 0
                }
              });
        case 100 :
          return digit;
        case 115 :
          return space;
        case 119 :
          return alt$1({
                hd: alnum,
                tl: {
                  hd: {
                    TAG: /* Set */ 0,
                    _0: {
                      hd: [
                        /* '_' */95,
                        /* '_' */95
                      ],
                      tl: /* [] */ 0
                    }
                  },
                  tl: /* [] */ 0
                }
              });
        case 67 :
        case 69 :
        case 70 :
        case 72 :
        case 73 :
        case 74 :
        case 75 :
        case 76 :
        case 77 :
        case 78 :
        case 79 :
        case 80 :
        case 81 :
        case 82 :
        case 84 :
        case 85 :
        case 86 :
        case 88 :
        case 89 :
        case 97 :
        case 99 :
        case 101 :
        case 102 :
        case 103 :
        case 104 :
        case 105 :
        case 106 :
        case 107 :
        case 108 :
        case 109 :
        case 110 :
        case 111 :
        case 112 :
        case 113 :
        case 114 :
        case 116 :
        case 117 :
        case 118 :
        case 120 :
        case 121 :
          throw new Caml_js_exceptions.MelangeError(Parse_error, {
                MEL_EXN_ID: Parse_error
              });
        case 122 :
          return /* End_of_str */ 6;
        default:
          return {
            TAG: /* Set */ 0,
            _0: single(c)
          };
      }
    } else {
      if (i.contents === l) {
        throw new Caml_js_exceptions.MelangeError(Parse_error, {
              MEL_EXN_ID: Parse_error
            });
      }
      const c$1 = get(undefined);
      if (c$1 >= 64) {
        if (c$1 !== 92) {
          if (c$1 !== 123) {
            return {
              TAG: /* Set */ 0,
              _0: single(c$1)
            };
          }
          throw new Caml_js_exceptions.MelangeError(Parse_error, {
                MEL_EXN_ID: Parse_error
              });
        }
        throw new Caml_js_exceptions.MelangeError(Parse_error, {
              MEL_EXN_ID: Parse_error
            });
      }
      if (c$1 >= 44) {
        if (c$1 >= 63) {
          throw new Caml_js_exceptions.MelangeError(Parse_error, {
                MEL_EXN_ID: Parse_error
              });
        }
        return {
          TAG: /* Set */ 0,
          _0: single(c$1)
        };
      }
      if (c$1 >= 42) {
        throw new Caml_js_exceptions.MelangeError(Parse_error, {
              MEL_EXN_ID: Parse_error
            });
      }
      return {
        TAG: /* Set */ 0,
        _0: single(c$1)
      };
    }
  };
  const integer = function (param) {
    if (i.contents === l) {
      return;
    }
    const d = get(undefined);
    if (d > 57 || d < 48) {
      i.contents = i.contents - 1 | 0;
      return;
    } else {
      let _i = d - /* '0' */48 | 0;
      while (true) {
        const i$1 = _i;
        if (i.contents === l) {
          return i$1;
        }
        const d$1 = get(undefined);
        if (d$1 > 57 || d$1 < 48) {
          i.contents = i.contents - 1 | 0;
          return i$1;
        }
        const i$p = Math.imul(10, i$1) + (d$1 - /* '0' */48 | 0) | 0;
        if (i$p < i$1) {
          throw new Caml_js_exceptions.MelangeError(Parse_error, {
                MEL_EXN_ID: Parse_error
              });
        }
        _i = i$p;
        continue;
      };
    }
  };
  const branch$p = function (_left) {
    while (true) {
      const left = _left;
      if (i.contents === l || test(/* '|' */124) || test(/* ')' */41)) {
        return seq$2(Stdlib__List.rev(left));
      }
      _left = {
        hd: piece(undefined),
        tl: left
      };
      continue;
    };
  };
  const regexp$p = function (_left) {
    while (true) {
      const left = _left;
      if (!accept(/* '|' */124)) {
        return left;
      }
      _left = alt$1({
            hd: left,
            tl: {
              hd: branch$p(/* [] */ 0),
              tl: /* [] */ 0
            }
          });
      continue;
    };
  };
  const bracket = function (_s) {
    while (true) {
      const s = _s;
      if (Caml_obj.caml_notequal(s, /* [] */ 0) && accept(/* ']' */93)) {
        return s;
      }
      const match = $$char(undefined);
      if (match.NAME === "Char") {
        const c = match.VAL;
        if (accept(/* '-' */45)) {
          if (accept(/* ']' */93)) {
            return {
              hd: {
                TAG: /* Set */ 0,
                _0: single(c)
              },
              tl: {
                hd: {
                  TAG: /* Set */ 0,
                  _0: {
                    hd: [
                      /* '-' */45,
                      /* '-' */45
                    ],
                    tl: /* [] */ 0
                  }
                },
                tl: s
              }
            };
          }
          const match$1 = $$char(undefined);
          if (match$1.NAME !== "Char") {
            return {
              hd: {
                TAG: /* Set */ 0,
                _0: single(c)
              },
              tl: {
                hd: {
                  TAG: /* Set */ 0,
                  _0: {
                    hd: [
                      /* '-' */45,
                      /* '-' */45
                    ],
                    tl: /* [] */ 0
                  }
                },
                tl: {
                  hd: match$1.VAL,
                  tl: s
                }
              }
            };
          }
          _s = {
            hd: {
              TAG: /* Set */ 0,
              _0: seq(c, match$1.VAL)
            },
            tl: s
          };
          continue;
        }
        _s = {
          hd: {
            TAG: /* Set */ 0,
            _0: single(c)
          },
          tl: s
        };
        continue;
      }
      _s = {
        hd: match.VAL,
        tl: s
      };
      continue;
    };
  };
  const piece = function (param) {
    const r = atom(undefined);
    if (accept(/* '*' */42)) {
      return greedy_mod(repn(r, 0, undefined));
    }
    if (accept(/* '+' */43)) {
      return greedy_mod(repn(r, 1, undefined));
    }
    if (accept(/* '?' */63)) {
      return greedy_mod(repn(r, 0, 1));
    }
    if (!accept(/* '{' */123)) {
      return r;
    }
    const i$1 = integer(undefined);
    if (i$1 !== undefined) {
      const j = accept(/* ',' */44) ? integer(undefined) : i$1;
      if (!accept(/* '}' */125)) {
        throw new Caml_js_exceptions.MelangeError(Parse_error, {
              MEL_EXN_ID: Parse_error
            });
      }
      if (j !== undefined && j < i$1) {
        throw new Caml_js_exceptions.MelangeError(Parse_error, {
              MEL_EXN_ID: Parse_error
            });
      }
      return greedy_mod(repn(r, i$1, j));
    }
    i.contents = i.contents - 1 | 0;
    return r;
  };
  const $$char = function (param) {
    if (i.contents === l) {
      throw new Caml_js_exceptions.MelangeError(Parse_error, {
            MEL_EXN_ID: Parse_error
          });
    }
    const c = get(undefined);
    if (c === /* '[' */91) {
      if (accept(/* '=' */61)) {
        throw new Caml_js_exceptions.MelangeError(Not_supported, {
              MEL_EXN_ID: Not_supported
            });
      }
      if (accept(/* ':' */58)) {
        const compl$1 = accept(/* '^' */94);
        let cls;
        try {
          cls = Stdlib__List.find(accept_s, {
                hd: "alnum",
                tl: {
                  hd: "ascii",
                  tl: {
                    hd: "blank",
                    tl: {
                      hd: "cntrl",
                      tl: {
                        hd: "digit",
                        tl: {
                          hd: "lower",
                          tl: {
                            hd: "print",
                            tl: {
                              hd: "space",
                              tl: {
                                hd: "upper",
                                tl: {
                                  hd: "word",
                                  tl: {
                                    hd: "punct",
                                    tl: {
                                      hd: "graph",
                                      tl: {
                                        hd: "xdigit",
                                        tl: /* [] */ 0
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              });
        }
        catch (raw_exn){
          const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.MEL_EXN_ID === Stdlib.Not_found) {
            throw new Caml_js_exceptions.MelangeError(Parse_error, {
                  MEL_EXN_ID: Parse_error
                });
          }
          throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
        }
        if (!accept_s(":]")) {
          throw new Caml_js_exceptions.MelangeError(Parse_error, {
                MEL_EXN_ID: Parse_error
              });
        }
        const posix_class = posix_class_of_string(cls);
        const re = compl$1 ? compl({
                hd: posix_class,
                tl: /* [] */ 0
              }) : posix_class;
        return {
          NAME: "Set",
          VAL: re
        };
      }
      if (!accept(/* '.' */46)) {
        return {
          NAME: "Char",
          VAL: c
        };
      }
      if (i.contents === l) {
        throw new Caml_js_exceptions.MelangeError(Parse_error, {
              MEL_EXN_ID: Parse_error
            });
      }
      const c$1 = get(undefined);
      if (!accept(/* '.' */46)) {
        throw new Caml_js_exceptions.MelangeError(Not_supported, {
              MEL_EXN_ID: Not_supported
            });
      }
      if (!accept(/* ']' */93)) {
        throw new Caml_js_exceptions.MelangeError(Parse_error, {
              MEL_EXN_ID: Parse_error
            });
      }
      return {
        NAME: "Char",
        VAL: c$1
      };
    }
    if (c !== /* '\\' */92) {
      return {
        NAME: "Char",
        VAL: c
      };
    }
    const c$2 = get(undefined);
    if (c$2 >= 58) {
      if (c$2 >= 123) {
        return {
          NAME: "Char",
          VAL: c$2
        };
      }
      switch (c$2) {
        case 68 :
          return {
            NAME: "Set",
            VAL: compl({
                  hd: digit,
                  tl: /* [] */ 0
                })
          };
        case 83 :
          return {
            NAME: "Set",
            VAL: compl({
                  hd: space,
                  tl: /* [] */ 0
                })
          };
        case 87 :
          return {
            NAME: "Set",
            VAL: compl({
                  hd: alnum,
                  tl: {
                    hd: {
                      TAG: /* Set */ 0,
                      _0: {
                        hd: [
                          /* '_' */95,
                          /* '_' */95
                        ],
                        tl: /* [] */ 0
                      }
                    },
                    tl: /* [] */ 0
                  }
                })
          };
        case 58 :
        case 59 :
        case 60 :
        case 61 :
        case 62 :
        case 63 :
        case 64 :
        case 91 :
        case 92 :
        case 93 :
        case 94 :
        case 95 :
        case 96 :
          return {
            NAME: "Char",
            VAL: c$2
          };
        case 98 :
          return {
            NAME: "Char",
            VAL: /* '\b' */8
          };
        case 100 :
          return {
            NAME: "Set",
            VAL: digit
          };
        case 110 :
          return {
            NAME: "Char",
            VAL: /* '\n' */10
          };
        case 114 :
          return {
            NAME: "Char",
            VAL: /* '\r' */13
          };
        case 115 :
          return {
            NAME: "Set",
            VAL: space
          };
        case 116 :
          return {
            NAME: "Char",
            VAL: /* '\t' */9
          };
        case 119 :
          return {
            NAME: "Set",
            VAL: alt$1({
                  hd: alnum,
                  tl: {
                    hd: {
                      TAG: /* Set */ 0,
                      _0: {
                        hd: [
                          /* '_' */95,
                          /* '_' */95
                        ],
                        tl: /* [] */ 0
                      }
                    },
                    tl: /* [] */ 0
                  }
                })
          };
        case 65 :
        case 66 :
        case 67 :
        case 69 :
        case 70 :
        case 71 :
        case 72 :
        case 73 :
        case 74 :
        case 75 :
        case 76 :
        case 77 :
        case 78 :
        case 79 :
        case 80 :
        case 81 :
        case 82 :
        case 84 :
        case 85 :
        case 86 :
        case 88 :
        case 89 :
        case 90 :
        case 97 :
        case 99 :
        case 101 :
        case 102 :
        case 103 :
        case 104 :
        case 105 :
        case 106 :
        case 107 :
        case 108 :
        case 109 :
        case 111 :
        case 112 :
        case 113 :
        case 117 :
        case 118 :
        case 120 :
        case 121 :
        case 122 :
          throw new Caml_js_exceptions.MelangeError(Parse_error, {
                MEL_EXN_ID: Parse_error
              });
      }
    } else {
      if (c$2 >= 48) {
        throw new Caml_js_exceptions.MelangeError(Not_supported, {
              MEL_EXN_ID: Not_supported
            });
      }
      return {
        NAME: "Char",
        VAL: c$2
      };
    }
  };
  const res = regexp$p(branch$p(/* [] */ 0));
  if (i.contents !== l) {
    throw new Caml_js_exceptions.MelangeError(Parse_error, {
          MEL_EXN_ID: Parse_error
        });
  }
  return res;
}

function re(flagsOpt, pat) {
  const flags = flagsOpt !== undefined ? flagsOpt : /* [] */ 0;
  const opts = Stdlib__List.map((function (param) {
        if (param === "CASELESS") {
          return "Caseless";
        } else if (param === "ANCHORED") {
          return "Anchored";
        } else {
          return "Multiline";
        }
      }), flags);
  let optsOpt = opts;
  const opts$1 = optsOpt !== undefined ? optsOpt : /* [] */ 0;
  const r = parse(Stdlib__List.memq("Multiline", opts$1), Stdlib__List.memq("Dollar_endonly", opts$1), Stdlib__List.memq("Dotall", opts$1), Stdlib__List.memq("Ungreedy", opts$1), pat);
  const r$1 = Stdlib__List.memq("Anchored", opts$1) ? seq$2({
          hd: /* Start */ 8,
          tl: {
            hd: r,
            tl: /* [] */ 0
          }
        }) : r;
  if (Stdlib__List.memq("Caseless", opts$1)) {
    return {
      TAG: /* No_case */ 10,
      _0: r$1
    };
  } else {
    return r$1;
  }
}

function exec(rex, pos, s) {
  let len;
  const substr = exec_internal("Re.exec", pos, len, true, rex, s);
  if (!/* tag */ (typeof substr === "number" || typeof substr === "string")) {
    return substr._0;
  }
  if (substr === /* Failed */ 0) {
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
          MEL_EXN_ID: Stdlib.Not_found
        });
  }
  throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
        MEL_EXN_ID: Stdlib.Not_found
      });
}

const s = Caml_bytes.bytes_to_string(Stdlib__Bytes.make(1048575, /* 'a' */97)) + "b";

eq("File \"xx.ml\", line 7, characters 3-10", get(exec(compile(re(undefined, "aa?b")), undefined, s), 0), "aab");

Mt.from_pair_suites("Ocaml_re_test", suites.contents);
/* CSetMap Not a pure module */
