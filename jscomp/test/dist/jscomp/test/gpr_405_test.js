// Generated by Melange
'use strict';

let Caml = require("melange.js/caml.js");
let Caml_js_exceptions = require("melange.js/caml_js_exceptions.js");
let Curry = require("melange.js/curry.js");
let Stdlib = require("melange/stdlib.js");
let Stdlib__Hashtbl = require("melange/hashtbl.js");

function Make(funarg) {
  const $$let = funarg.V;
  const H = Stdlib__Hashtbl.Make({
        equal: $$let.equal,
        hash: $$let.hash
      });
  const find_default = function (htbl, x) {
    try {
      return Curry._2(H.find, htbl, x);
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        return false;
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  };
  const min_cutset = function (gr, first_node) {
    const n_labels = Curry._1(H.create, 97);
    const l_labels = Curry._1(H.create, 97);
    const already_processed = Curry._1(H.create, 97);
    const on_the_stack = Curry._1(H.create, 97);
    const cut_set = {
      contents: /* [] */0
    };
    const counter = {
      contents: 1
    };
    const step2 = function (top, rest_of_stack) {
      if (find_default(already_processed, top)) {
        throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                  MEL_EXN_ID: "Assert_failure",
                  _1: [
                    "jscomp/test/gpr_405_test.ml",
                    43,
                    6
                  ]
                });
      }
      if (find_default(on_the_stack, top)) {
        throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                  MEL_EXN_ID: "Assert_failure",
                  _1: [
                    "jscomp/test/gpr_405_test.ml",
                    44,
                    6
                  ]
                });
      }
      Curry._3(H.add, on_the_stack, top, true);
      Curry._3(H.add, n_labels, top, counter.contents);
      counter.contents = counter.contents + 1 | 0;
      Curry._3(H.add, l_labels, top, 0);
      Curry._3(H.add, already_processed, top, true);
      let _successors = Curry._2(funarg.succ, gr, top);
      let _top = top;
      let _rest_of_stack = rest_of_stack;
      while(true) {
        const rest_of_stack$1 = _rest_of_stack;
        const top$1 = _top;
        const successors = _successors;
        if (successors) {
          const successor = successors.hd;
          if (!find_default(already_processed, successor)) {
            return step2(successor, {
                        hd: [
                          top$1,
                          successors
                        ],
                        tl: rest_of_stack$1
                      });
          }
          const x = find_default(on_the_stack, successor) ? Curry._2(H.find, n_labels, successor) : Curry._2(H.find, l_labels, successor);
          Curry._3(H.add, l_labels, top$1, Caml.caml_int_max(Curry._2(H.find, l_labels, top$1), x));
          _successors = successors.tl;
          continue ;
        }
        if (Curry._2(H.find, l_labels, top$1) === Curry._2(H.find, n_labels, top$1)) {
          cut_set.contents = {
            hd: top$1,
            tl: cut_set.contents
          };
          Curry._3(H.add, l_labels, top$1, 0);
        }
        if (Curry._2(H.find, l_labels, top$1) > Curry._2(H.find, n_labels, top$1)) {
          throw new Caml_js_exceptions.MelangeError(Stdlib.Invalid_argument, {
                    MEL_EXN_ID: Stdlib.Invalid_argument,
                    _1: "Graph.Mincut: graph not reducible"
                  });
        }
        if (!rest_of_stack$1) {
          return cut_set.contents;
        }
        const match = rest_of_stack$1.hd;
        const new_top = match[0];
        Curry._3(H.add, on_the_stack, top$1, false);
        Curry._3(H.add, l_labels, new_top, Caml.caml_int_max(Curry._2(H.find, l_labels, top$1), Curry._2(H.find, l_labels, new_top)));
        _rest_of_stack = rest_of_stack$1.tl;
        _top = new_top;
        _successors = match[1];
        continue ;
      };
    };
    return step2(first_node, /* [] */0);
  };
  return {
          min_cutset: min_cutset
        };
}

exports.Make = Make;
/* Stdlib__Hashtbl Not a pure module */
