// Generated by Melange
'use strict';

const Caml = require("melange.js/caml.js");
const Caml_bytes = require("melange.js/caml_bytes.js");
const Caml_external_polyfill = require("melange.js/caml_external_polyfill.js");
const Caml_io = require("melange.js/caml_io.js");
const Caml_js_exceptions = require("melange.js/caml_js_exceptions.js");
const Curry = require("melange.js/curry.js");
const Stdlib = require("melange/stdlib.js");
const Stdlib__Buffer = require("melange/buffer.js");
const Stdlib__Bytes = require("melange/bytes.js");
const Stdlib__Char = require("melange/char.js");
const Stdlib__Format = require("melange/format.js");
const Stdlib__List = require("melange/list.js");
const Stdlib__Printexc = require("melange/printexc.js");
const Stdlib__Printf = require("melange/printf.js");
const Stdlib__String = require("melange/string.js");
const Stdlib__Sys = require("melange/sys.js");

function _with_in(filename, f) {
  const ic = Stdlib.open_in_bin(filename);
  try {
    const x = Curry._1(f, ic);
    Caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
    return x;
  }
  catch (raw_e){
    const e = Caml_js_exceptions.internalToOCamlException(raw_e);
    Caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
    return {
      NAME: "Error",
      VAL: Stdlib__Printexc.to_string(e)
    };
  }
}

function _must_escape(s) {
  try {
    for (let i = 0, i_finish = s.length; i < i_finish; ++i) {
      const c = s.charCodeAt(i);
      let exit = 0;
      if (c >= 42) {
        if (c !== 59) {
          if (c !== 92) {
            exit = 1;
          } else {
            throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                MEL_EXN_ID: Stdlib.Exit
              });
          }
        } else {
          throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
              MEL_EXN_ID: Stdlib.Exit
            });
        }
      } else if (c >= 11) {
        if (c >= 32) {
          switch (c) {
            case 33 :
            case 35 :
            case 36 :
            case 37 :
            case 38 :
            case 39 :
              exit = 1;
              break;
            case 32 :
            case 34 :
            case 40 :
            case 41 :
              throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                  MEL_EXN_ID: Stdlib.Exit
                });
          }
        } else {
          exit = 1;
        }
      } else {
        if (c >= 9) {
          throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
              MEL_EXN_ID: Stdlib.Exit
            });
        }
        exit = 1;
      }
      if (exit === 1 && c > 127) {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
            MEL_EXN_ID: Stdlib.Exit
          });
      }
      
    }
    return false;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Exit) {
      return true;
    }
    throw exn;
  }
}

function to_buf(b, t) {
  if (t.NAME === "List") {
    const l = t.VAL;
    if (l) {
      if (l.tl) {
        Stdlib__Buffer.add_char(b, /* '(' */40);
        Stdlib__List.iteri((function (i, t$p) {
          if (i > 0) {
            Stdlib__Buffer.add_char(b, /* ' ' */32);
          }
          to_buf(b, t$p);
        }), l);
        return Stdlib__Buffer.add_char(b, /* ')' */41);
      } else {
        return Curry._2(Stdlib__Printf.bprintf(b, {
          TAG: /* Format */ 0,
          _0: {
            TAG: /* Char_literal */ 12,
            _0: /* '(' */40,
            _1: {
              TAG: /* Alpha */ 15,
              _0: {
                TAG: /* Char_literal */ 12,
                _0: /* ')' */41,
                _1: /* End_of_format */ 0
              }
            }
          },
          _1: "(%a)"
        }), to_buf, l.hd);
      }
    } else {
      return Stdlib__Buffer.add_string(b, "()");
    }
  }
  const s = t.VAL;
  if (_must_escape(s)) {
    return Curry._1(Stdlib__Printf.bprintf(b, {
      TAG: /* Format */ 0,
      _0: {
        TAG: /* Char_literal */ 12,
        _0: /* '"' */34,
        _1: {
          TAG: /* String */ 2,
          _0: /* No_padding */ 0,
          _1: {
            TAG: /* Char_literal */ 12,
            _0: /* '"' */34,
            _1: /* End_of_format */ 0
          }
        }
      },
      _1: "\"%s\""
    }), Stdlib__String.escaped(s));
  } else {
    return Stdlib__Buffer.add_string(b, s);
  }
}

function to_string(t) {
  const b = Stdlib__Buffer.create(128);
  to_buf(b, t);
  return Stdlib__Buffer.contents(b);
}

function print(fmt, t) {
  if (t.NAME === "List") {
    const l = t.VAL;
    if (l) {
      if (l.tl) {
        Stdlib__Format.fprintf(fmt)({
          TAG: /* Format */ 0,
          _0: {
            TAG: /* Formatting_gen */ 18,
            _0: {
              TAG: /* Open_box */ 1,
              _0: {
                TAG: /* Format */ 0,
                _0: {
                  TAG: /* String_literal */ 11,
                  _0: "<hov1>",
                  _1: /* End_of_format */ 0
                },
                _1: "<hov1>"
              }
            },
            _1: {
              TAG: /* Char_literal */ 12,
              _0: /* '(' */40,
              _1: /* End_of_format */ 0
            }
          },
          _1: "@[<hov1>("
        });
        Stdlib__List.iteri((function (i, t$p) {
          if (i > 0) {
            Stdlib__Format.fprintf(fmt)({
              TAG: /* Format */ 0,
              _0: {
                TAG: /* Formatting_lit */ 17,
                _0: {
                  TAG: /* Break */ 0,
                  _0: "@ ",
                  _1: 1,
                  _2: 0
                },
                _1: /* End_of_format */ 0
              },
              _1: "@ "
            });
          }
          print(fmt, t$p);
        }), l);
        return Stdlib__Format.fprintf(fmt)({
          TAG: /* Format */ 0,
          _0: {
            TAG: /* Char_literal */ 12,
            _0: /* ')' */41,
            _1: {
              TAG: /* Formatting_lit */ 17,
              _0: /* Close_box */ 0,
              _1: /* End_of_format */ 0
            }
          },
          _1: ")@]"
        });
      } else {
        return Curry._2(Stdlib__Format.fprintf(fmt)({
          TAG: /* Format */ 0,
          _0: {
            TAG: /* Formatting_gen */ 18,
            _0: {
              TAG: /* Open_box */ 1,
              _0: {
                TAG: /* Format */ 0,
                _0: {
                  TAG: /* String_literal */ 11,
                  _0: "<hov2>",
                  _1: /* End_of_format */ 0
                },
                _1: "<hov2>"
              }
            },
            _1: {
              TAG: /* Char_literal */ 12,
              _0: /* '(' */40,
              _1: {
                TAG: /* Alpha */ 15,
                _0: {
                  TAG: /* Char_literal */ 12,
                  _0: /* ')' */41,
                  _1: {
                    TAG: /* Formatting_lit */ 17,
                    _0: /* Close_box */ 0,
                    _1: /* End_of_format */ 0
                  }
                }
              }
            }
          },
          _1: "@[<hov2>(%a)@]"
        }), print, l.hd);
      }
    } else {
      return Stdlib__Format.pp_print_string(fmt, "()");
    }
  }
  const s = t.VAL;
  if (_must_escape(s)) {
    return Curry._1(Stdlib__Format.fprintf(fmt)({
      TAG: /* Format */ 0,
      _0: {
        TAG: /* Char_literal */ 12,
        _0: /* '"' */34,
        _1: {
          TAG: /* String */ 2,
          _0: /* No_padding */ 0,
          _1: {
            TAG: /* Char_literal */ 12,
            _0: /* '"' */34,
            _1: /* End_of_format */ 0
          }
        }
      },
      _1: "\"%s\""
    }), Stdlib__String.escaped(s));
  } else {
    return Stdlib__Format.pp_print_string(fmt, s);
  }
}

function print_noindent(fmt, t) {
  if (t.NAME === "List") {
    const l = t.VAL;
    if (l) {
      if (l.tl) {
        Stdlib__Format.pp_print_char(fmt, /* '(' */40);
        Stdlib__List.iteri((function (i, t$p) {
          if (i > 0) {
            Stdlib__Format.pp_print_char(fmt, /* ' ' */32);
          }
          print_noindent(fmt, t$p);
        }), l);
        return Stdlib__Format.pp_print_char(fmt, /* ')' */41);
      } else {
        return Curry._2(Stdlib__Format.fprintf(fmt)({
          TAG: /* Format */ 0,
          _0: {
            TAG: /* Char_literal */ 12,
            _0: /* '(' */40,
            _1: {
              TAG: /* Alpha */ 15,
              _0: {
                TAG: /* Char_literal */ 12,
                _0: /* ')' */41,
                _1: /* End_of_format */ 0
              }
            }
          },
          _1: "(%a)"
        }), print_noindent, l.hd);
      }
    } else {
      return Stdlib__Format.pp_print_string(fmt, "()");
    }
  }
  const s = t.VAL;
  if (_must_escape(s)) {
    return Curry._1(Stdlib__Format.fprintf(fmt)({
      TAG: /* Format */ 0,
      _0: {
        TAG: /* Char_literal */ 12,
        _0: /* '"' */34,
        _1: {
          TAG: /* String */ 2,
          _0: /* No_padding */ 0,
          _1: {
            TAG: /* Char_literal */ 12,
            _0: /* '"' */34,
            _1: /* End_of_format */ 0
          }
        }
      },
      _1: "\"%s\""
    }), Stdlib__String.escaped(s));
  } else {
    return Stdlib__Format.pp_print_string(fmt, s);
  }
}

function to_chan(oc, t) {
  const fmt = Stdlib__Format.formatter_of_out_channel(oc);
  print(fmt, t);
  Stdlib__Format.pp_print_flush(fmt, undefined);
}

function to_file_seq(filename, seq) {
  let f = function (oc) {
    return Curry._1(seq, (function (t) {
      to_chan(oc, t);
      Caml_io.caml_ml_output_char(oc, /* '\n' */10);
    }));
  };
  const oc = Stdlib.open_out(filename);
  try {
    const x = Curry._1(f, oc);
    Caml_io.caml_ml_flush(oc);
    Caml_external_polyfill.resolve("caml_ml_close_channel")(oc);
    return x;
  }
  catch (e){
    Caml_io.caml_ml_flush(oc);
    Caml_external_polyfill.resolve("caml_ml_close_channel")(oc);
    throw e;
  }
}

function to_file(filename, t) {
  to_file_seq(filename, (function (k) {
    Curry._1(k, t);
  }));
}

function $$return(x) {
  return x;
}

function $great$great$eq(x, f) {
  return Curry._1(f, x);
}

const ID_MONAD = {
  $$return: $$return,
  $great$great$eq: $great$great$eq
};

function make(bufsizeOpt, refill) {
  const bufsize = bufsizeOpt !== undefined ? bufsizeOpt : 1024;
  const bufsize$1 = Caml.caml_int_min(bufsize > 16 ? bufsize : 16, Stdlib__Sys.max_string_length);
  return {
    buf: Caml_bytes.caml_create_bytes(bufsize$1),
    refill: refill,
    atom: Stdlib__Buffer.create(32),
    i: 0,
    len: 0,
    line: 1,
    col: 1
  };
}

function _is_digit(c) {
  if (/* '0' */48 <= c) {
    return c <= /* '9' */57;
  } else {
    return false;
  }
}

function _refill(t, k_succ, k_fail) {
  const n = Curry._3(t.refill, t.buf, 0, t.buf.length);
  t.i = 0;
  t.len = n;
  if (n === 0) {
    return Curry._1(k_fail, t);
  } else {
    return Curry._1(k_succ, t);
  }
}

function _get(t) {
  if (t.i >= t.len) {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "jscomp/test/sexpm.ml",
          152,
          4
        ]
      });
  }
  const c = Caml_bytes.get(t.buf, t.i);
  t.i = t.i + 1 | 0;
  if (c === /* '\n' */10) {
    t.col = 1;
    t.line = t.line + 1 | 0;
  } else {
    t.col = t.col + 1 | 0;
  }
  return c;
}

function _error(t, msg) {
  const b = Stdlib__Buffer.create(32);
  Curry._2(Stdlib__Printf.bprintf(b, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "at ",
      _1: {
        TAG: /* Int */ 4,
        _0: /* Int_d */ 0,
        _1: /* No_padding */ 0,
        _2: /* No_precision */ 0,
        _3: {
          TAG: /* String_literal */ 11,
          _0: ", ",
          _1: {
            TAG: /* Int */ 4,
            _0: /* Int_d */ 0,
            _1: /* No_padding */ 0,
            _2: /* No_precision */ 0,
            _3: {
              TAG: /* String_literal */ 11,
              _0: ": ",
              _1: /* End_of_format */ 0
            }
          }
        }
      }
    },
    _1: "at %d, %d: "
  }), t.line, t.col);
  return Stdlib__Printf.kbprintf((function (b) {
    const msg$p = Stdlib__Buffer.contents(b);
    return {
      NAME: "Error",
      VAL: msg$p
    };
  }), b, msg);
}

function _error_eof(t) {
  return _error(t, {
    TAG: /* Format */ 0,
    _0: {
      TAG: /* String_literal */ 11,
      _0: "unexpected end of input",
      _1: /* End_of_format */ 0
    },
    _1: "unexpected end of input"
  });
}

function expr(k, t) {
  while (true) {
    if (t.i === t.len) {
      return _refill(t, (function (param) {
        return expr(k, param);
      }), _error_eof);
    }
    const c = _get(t);
    if (c >= 11) {
      if (c !== 32) {
        return expr_starting_with(c, k, t);
      }
      continue;
    }
    if (c < 9) {
      return expr_starting_with(c, k, t);
    }
    continue;
  };
}

function expr_starting_with(c, k, t) {
  if (c >= 42) {
    if (c === 59) {
      return skip_comment((function (param, param$1) {
        return expr(k, t);
      }), t);
    }
    if (c === 92) {
      return _error(t, {
        TAG: /* Format */ 0,
        _0: {
          TAG: /* String_literal */ 11,
          _0: "unexpected '\\'",
          _1: /* End_of_format */ 0
        },
        _1: "unexpected '\\'"
      });
    }
    
  } else if (c >= 11) {
    if (c >= 32) {
      switch (c) {
        case 32 :
          throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/test/sexpm.ml",
                183,
                27
              ]
            });
        case 34 :
          return quoted(k, t);
        case 33 :
        case 35 :
        case 36 :
        case 37 :
        case 38 :
        case 39 :
          break;
        case 40 :
          return expr_list(/* [] */ 0, k, t);
        case 41 :
          return _error(t, {
            TAG: /* Format */ 0,
            _0: {
              TAG: /* String_literal */ 11,
              _0: "unexpected ')'",
              _1: /* End_of_format */ 0
            },
            _1: "unexpected ')'"
          });
      }
    }
    
  } else if (c >= 9) {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "jscomp/test/sexpm.ml",
          183,
          27
        ]
      });
  }
  Stdlib__Buffer.add_char(t.atom, c);
  return atom(k, t);
}

function expr_list(acc, k, t) {
  while (true) {
    if (t.i === t.len) {
      return _refill(t, (function (param) {
        return expr_list(acc, k, param);
      }), _error_eof);
    }
    const c = _get(t);
    if (c > 32 || c < 9) {
      if (c === 41) {
        return Curry._2(k, undefined, {
          NAME: "List",
          VAL: Stdlib__List.rev(acc)
        });
      }
      
    } else if (c > 31 || c < 11) {
      continue;
    }
    return expr_starting_with(c, (function (last, e) {
      if (last !== undefined) {
        if (last !== 40) {
          if (last !== 41) {
            return expr_list({
              hd: e,
              tl: acc
            }, k, t);
          } else {
            return Curry._2(k, undefined, {
              NAME: "List",
              VAL: Stdlib__List.rev({
                hd: e,
                tl: acc
              })
            });
          }
        } else {
          return expr_list(/* [] */ 0, (function (param, l) {
            return expr_list({
              hd: l,
              tl: acc
            }, k, t);
          }), t);
        }
      } else {
        return expr_list({
          hd: e,
          tl: acc
        }, k, t);
      }
    }), t);
  };
}

function _return_atom(last, k, t) {
  const s = Stdlib__Buffer.contents(t.atom);
  t.atom.position = 0;
  return Curry._2(k, last, {
    NAME: "Atom",
    VAL: s
  });
}

function atom(k, t) {
  while (true) {
    if (t.i === t.len) {
      return _refill(t, (function (param) {
        return atom(k, param);
      }), (function (param) {
        return _return_atom(undefined, k, param);
      }));
    }
    const c = _get(t);
    let exit = 0;
    if (c >= 35) {
      if (c >= 42) {
        if (c === 92) {
          return _error(t, {
            TAG: /* Format */ 0,
            _0: {
              TAG: /* String_literal */ 11,
              _0: "unexpected '\\' in non-quoted string",
              _1: /* End_of_format */ 0
            },
            _1: "unexpected '\\' in non-quoted string"
          });
        }
        exit = 1;
      } else {
        exit = c >= 40 ? 2 : 1;
      }
    } else if (c >= 11) {
      if (c >= 32) {
        switch (c) {
          case 32 :
            exit = 2;
            break;
          case 33 :
            exit = 1;
            break;
          case 34 :
            return _error(t, {
              TAG: /* Format */ 0,
              _0: {
                TAG: /* String_literal */ 11,
                _0: "unexpected '\"' in the middle of an atom",
                _1: /* End_of_format */ 0
              },
              _1: "unexpected '\"' in the middle of an atom"
            });
        }
      } else {
        exit = 1;
      }
    } else {
      exit = c >= 9 ? 2 : 1;
    }
    switch (exit) {
      case 1 :
        Stdlib__Buffer.add_char(t.atom, c);
        continue;
      case 2 :
        return _return_atom(c, k, t);
    }
  };
}

function quoted(k, t) {
  while (true) {
    if (t.i === t.len) {
      return _refill(t, (function (param) {
        return quoted(k, param);
      }), _error_eof);
    }
    const c = _get(t);
    if (c === 34) {
      return _return_atom(undefined, k, t);
    }
    if (c === 92) {
      return escaped((function (c) {
        Stdlib__Buffer.add_char(t.atom, c);
        return quoted(k, t);
      }), t);
    }
    Stdlib__Buffer.add_char(t.atom, c);
    continue;
  };
}

function escaped(k, t) {
  if (t.i === t.len) {
    return _refill(t, (function (param) {
      return escaped(k, param);
    }), _error_eof);
  }
  const c = _get(t);
  if (c >= 92) {
    if (c < 117) {
      switch (c) {
        case 92 :
          return Curry._1(k, /* '\\' */92);
        case 98 :
          return Curry._1(k, /* '\b' */8);
        case 110 :
          return Curry._1(k, /* '\n' */10);
        case 114 :
          return Curry._1(k, /* '\r' */13);
        case 93 :
        case 94 :
        case 95 :
        case 96 :
        case 97 :
        case 99 :
        case 100 :
        case 101 :
        case 102 :
        case 103 :
        case 104 :
        case 105 :
        case 106 :
        case 107 :
        case 108 :
        case 109 :
        case 111 :
        case 112 :
        case 113 :
        case 115 :
          break;
        case 116 :
          return Curry._1(k, /* '\t' */9);
      }
    }
    
  } else if (c === 34) {
    return Curry._1(k, /* '"' */34);
  }
  if (_is_digit(c)) {
    return read2int(c - /* '0' */48 | 0, (function (n) {
      return Curry._1(k, Stdlib__Char.chr(n));
    }), t);
  } else {
    return Curry._1(_error(t, {
      TAG: /* Format */ 0,
      _0: {
        TAG: /* String_literal */ 11,
        _0: "unexpected escaped char '",
        _1: {
          TAG: /* Char */ 0,
          _0: {
            TAG: /* Char_literal */ 12,
            _0: /* '\'' */39,
            _1: /* End_of_format */ 0
          }
        }
      },
      _1: "unexpected escaped char '%c'"
    }), c);
  }
}

function read2int(i, k, t) {
  if (t.i === t.len) {
    return _refill(t, (function (param) {
      return read2int(i, k, param);
    }), _error_eof);
  }
  const c = _get(t);
  if (_is_digit(c)) {
    return read1int(Math.imul(10, i) + (c - /* '0' */48 | 0) | 0, k, t);
  } else {
    return Curry._1(_error(t, {
      TAG: /* Format */ 0,
      _0: {
        TAG: /* String_literal */ 11,
        _0: "unexpected char '",
        _1: {
          TAG: /* Char */ 0,
          _0: {
            TAG: /* String_literal */ 11,
            _0: "' when reading byte",
            _1: /* End_of_format */ 0
          }
        }
      },
      _1: "unexpected char '%c' when reading byte"
    }), c);
  }
}

function read1int(i, k, t) {
  if (t.i === t.len) {
    return _refill(t, (function (param) {
      return read1int(i, k, param);
    }), _error_eof);
  }
  const c = _get(t);
  if (_is_digit(c)) {
    return Curry._1(k, Math.imul(10, i) + (c - /* '0' */48 | 0) | 0);
  } else {
    return Curry._1(_error(t, {
      TAG: /* Format */ 0,
      _0: {
        TAG: /* String_literal */ 11,
        _0: "unexpected char '",
        _1: {
          TAG: /* Char */ 0,
          _0: {
            TAG: /* String_literal */ 11,
            _0: "' when reading byte",
            _1: /* End_of_format */ 0
          }
        }
      },
      _1: "unexpected char '%c' when reading byte"
    }), c);
  }
}

function skip_comment(k, t) {
  while (true) {
    if (t.i === t.len) {
      return _refill(t, (function (param) {
        return skip_comment(k, param);
      }), _error_eof);
    }
    const match = _get(t);
    if (match === 10) {
      return Curry._2(k, undefined, undefined);
    }
    continue;
  };
}

function expr_or_end(k, t) {
  while (true) {
    if (t.i === t.len) {
      return _refill(t, (function (param) {
        return expr_or_end(k, param);
      }), (function (param) {
        return "End";
      }));
    }
    const c = _get(t);
    if (c >= 11) {
      if (c !== 32) {
        return expr_starting_with(c, k, t);
      }
      continue;
    }
    if (c < 9) {
      return expr_starting_with(c, k, t);
    }
    continue;
  };
}

function next(t) {
  return expr_or_end((function (param, x) {
    return {
      NAME: "Ok",
      VAL: x
    };
  }), t);
}

function parse_string(s) {
  const n = s.length;
  const stop = {
    contents: false
  };
  const refill = function (bytes, i, _len) {
    if (stop.contents) {
      return 0;
    } else {
      stop.contents = true;
      Stdlib__Bytes.blit_string(s, 0, bytes, i, n);
      return n;
    }
  };
  const d = make(n, refill);
  const res = next(d);
  if (typeof res === "string") {
    return {
      NAME: "Error",
      VAL: "unexpected end of file"
    };
  } else {
    return res;
  }
}

function parse_chan(bufsize, ic) {
  const d = make(bufsize, (function (param, param$1, param$2) {
    return Stdlib.input(ic, param, param$1, param$2);
  }));
  const res = next(d);
  if (typeof res === "string") {
    return {
      NAME: "Error",
      VAL: "unexpected end of file"
    };
  } else {
    return res;
  }
}

function parse_chan_gen(bufsize, ic) {
  const d = make(bufsize, (function (param, param$1, param$2) {
    return Stdlib.input(ic, param, param$1, param$2);
  }));
  return function (param) {
    const e = next(d);
    if (typeof e === "string") {
      return;
    } else {
      return e;
    }
  };
}

function parse_chan_list(bufsize, ic) {
  const d = make(bufsize, (function (param, param$1, param$2) {
    return Stdlib.input(ic, param, param$1, param$2);
  }));
  let _acc = /* [] */ 0;
  while (true) {
    const acc = _acc;
    const e = next(d);
    if (typeof e === "string") {
      return {
        NAME: "Ok",
        VAL: Stdlib__List.rev(acc)
      };
    }
    if (e.NAME === "Error") {
      return e;
    }
    _acc = {
      hd: e.VAL,
      tl: acc
    };
    continue;
  };
}

function parse_file(filename) {
  return _with_in(filename, (function (ic) {
    return parse_chan(undefined, ic);
  }));
}

function parse_file_list(filename) {
  return _with_in(filename, (function (ic) {
    return parse_chan_list(undefined, ic);
  }));
}

function MakeDecode(funarg) {
  const $great$great$eq = funarg.$great$great$eq;
  const make = function (bufsizeOpt, refill) {
    const bufsize = bufsizeOpt !== undefined ? bufsizeOpt : 1024;
    const bufsize$1 = Caml.caml_int_min(bufsize > 16 ? bufsize : 16, Stdlib__Sys.max_string_length);
    return {
      buf: Caml_bytes.caml_create_bytes(bufsize$1),
      refill: refill,
      atom: Stdlib__Buffer.create(32),
      i: 0,
      len: 0,
      line: 1,
      col: 1
    };
  };
  const _is_digit = function (c) {
    if (/* '0' */48 <= c) {
      return c <= /* '9' */57;
    } else {
      return false;
    }
  };
  const _refill = function (t, k_succ, k_fail) {
    return Curry._2($great$great$eq, Curry._3(t.refill, t.buf, 0, t.buf.length), (function (n) {
      t.i = 0;
      t.len = n;
      if (n === 0) {
        return Curry._1(k_fail, t);
      } else {
        return Curry._1(k_succ, t);
      }
    }));
  };
  const _get = function (t) {
    if (t.i >= t.len) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "jscomp/test/sexpm.ml",
            152,
            4
          ]
        });
    }
    const c = Caml_bytes.get(t.buf, t.i);
    t.i = t.i + 1 | 0;
    if (c === /* '\n' */10) {
      t.col = 1;
      t.line = t.line + 1 | 0;
    } else {
      t.col = t.col + 1 | 0;
    }
    return c;
  };
  const _error = function (t, msg) {
    const b = Stdlib__Buffer.create(32);
    Curry._2(Stdlib__Printf.bprintf(b, {
      TAG: /* Format */ 0,
      _0: {
        TAG: /* String_literal */ 11,
        _0: "at ",
        _1: {
          TAG: /* Int */ 4,
          _0: /* Int_d */ 0,
          _1: /* No_padding */ 0,
          _2: /* No_precision */ 0,
          _3: {
            TAG: /* String_literal */ 11,
            _0: ", ",
            _1: {
              TAG: /* Int */ 4,
              _0: /* Int_d */ 0,
              _1: /* No_padding */ 0,
              _2: /* No_precision */ 0,
              _3: {
                TAG: /* String_literal */ 11,
                _0: ": ",
                _1: /* End_of_format */ 0
              }
            }
          }
        }
      },
      _1: "at %d, %d: "
    }), t.line, t.col);
    return Stdlib__Printf.kbprintf((function (b) {
      const msg$p = Stdlib__Buffer.contents(b);
      return Curry._1(funarg.$$return, {
        NAME: "Error",
        VAL: msg$p
      });
    }), b, msg);
  };
  const _error_eof = function (t) {
    return _error(t, {
      TAG: /* Format */ 0,
      _0: {
        TAG: /* String_literal */ 11,
        _0: "unexpected end of input",
        _1: /* End_of_format */ 0
      },
      _1: "unexpected end of input"
    });
  };
  const expr = function (k, t) {
    while (true) {
      if (t.i === t.len) {
        return _refill(t, (function (param) {
          return expr(k, param);
        }), _error_eof);
      }
      const c = _get(t);
      if (c >= 11) {
        if (c !== 32) {
          return expr_starting_with(c, k, t);
        }
        continue;
      }
      if (c < 9) {
        return expr_starting_with(c, k, t);
      }
      continue;
    };
  };
  const expr_starting_with = function (c, k, t) {
    if (c >= 42) {
      if (c === 59) {
        return skip_comment((function (param, param$1) {
          return expr(k, t);
        }), t);
      }
      if (c === 92) {
        return _error(t, {
          TAG: /* Format */ 0,
          _0: {
            TAG: /* String_literal */ 11,
            _0: "unexpected '\\'",
            _1: /* End_of_format */ 0
          },
          _1: "unexpected '\\'"
        });
      }
      
    } else if (c >= 11) {
      if (c >= 32) {
        switch (c) {
          case 32 :
            throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/test/sexpm.ml",
                  183,
                  27
                ]
              });
          case 34 :
            return quoted(k, t);
          case 33 :
          case 35 :
          case 36 :
          case 37 :
          case 38 :
          case 39 :
            break;
          case 40 :
            return expr_list(/* [] */ 0, k, t);
          case 41 :
            return _error(t, {
              TAG: /* Format */ 0,
              _0: {
                TAG: /* String_literal */ 11,
                _0: "unexpected ')'",
                _1: /* End_of_format */ 0
              },
              _1: "unexpected ')'"
            });
        }
      }
      
    } else if (c >= 9) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "jscomp/test/sexpm.ml",
            183,
            27
          ]
        });
    }
    Stdlib__Buffer.add_char(t.atom, c);
    return atom(k, t);
  };
  const expr_list = function (acc, k, t) {
    while (true) {
      if (t.i === t.len) {
        return _refill(t, (function (param) {
          return expr_list(acc, k, param);
        }), _error_eof);
      }
      const c = _get(t);
      if (c > 32 || c < 9) {
        if (c === 41) {
          return Curry._2(k, undefined, {
            NAME: "List",
            VAL: Stdlib__List.rev(acc)
          });
        }
        
      } else if (c > 31 || c < 11) {
        continue;
      }
      return expr_starting_with(c, (function (last, e) {
        if (last !== undefined) {
          if (last !== 40) {
            if (last !== 41) {
              return expr_list({
                hd: e,
                tl: acc
              }, k, t);
            } else {
              return Curry._2(k, undefined, {
                NAME: "List",
                VAL: Stdlib__List.rev({
                  hd: e,
                  tl: acc
                })
              });
            }
          } else {
            return expr_list(/* [] */ 0, (function (param, l) {
              return expr_list({
                hd: l,
                tl: acc
              }, k, t);
            }), t);
          }
        } else {
          return expr_list({
            hd: e,
            tl: acc
          }, k, t);
        }
      }), t);
    };
  };
  const _return_atom = function (last, k, t) {
    const s = Stdlib__Buffer.contents(t.atom);
    t.atom.position = 0;
    return Curry._2(k, last, {
      NAME: "Atom",
      VAL: s
    });
  };
  const atom = function (k, t) {
    while (true) {
      if (t.i === t.len) {
        return _refill(t, (function (param) {
          return atom(k, param);
        }), (function (param) {
          return _return_atom(undefined, k, param);
        }));
      }
      const c = _get(t);
      let exit = 0;
      if (c >= 35) {
        if (c >= 42) {
          if (c === 92) {
            return _error(t, {
              TAG: /* Format */ 0,
              _0: {
                TAG: /* String_literal */ 11,
                _0: "unexpected '\\' in non-quoted string",
                _1: /* End_of_format */ 0
              },
              _1: "unexpected '\\' in non-quoted string"
            });
          }
          exit = 1;
        } else {
          exit = c >= 40 ? 2 : 1;
        }
      } else if (c >= 11) {
        if (c >= 32) {
          switch (c) {
            case 32 :
              exit = 2;
              break;
            case 33 :
              exit = 1;
              break;
            case 34 :
              return _error(t, {
                TAG: /* Format */ 0,
                _0: {
                  TAG: /* String_literal */ 11,
                  _0: "unexpected '\"' in the middle of an atom",
                  _1: /* End_of_format */ 0
                },
                _1: "unexpected '\"' in the middle of an atom"
              });
          }
        } else {
          exit = 1;
        }
      } else {
        exit = c >= 9 ? 2 : 1;
      }
      switch (exit) {
        case 1 :
          Stdlib__Buffer.add_char(t.atom, c);
          continue;
        case 2 :
          return _return_atom(c, k, t);
      }
    };
  };
  const quoted = function (k, t) {
    while (true) {
      if (t.i === t.len) {
        return _refill(t, (function (param) {
          return quoted(k, param);
        }), _error_eof);
      }
      const c = _get(t);
      if (c === 34) {
        return _return_atom(undefined, k, t);
      }
      if (c === 92) {
        return escaped((function (c) {
          Stdlib__Buffer.add_char(t.atom, c);
          return quoted(k, t);
        }), t);
      }
      Stdlib__Buffer.add_char(t.atom, c);
      continue;
    };
  };
  const escaped = function (k, t) {
    if (t.i === t.len) {
      return _refill(t, (function (param) {
        return escaped(k, param);
      }), _error_eof);
    }
    const c = _get(t);
    if (c >= 92) {
      if (c < 117) {
        switch (c) {
          case 92 :
            return Curry._1(k, /* '\\' */92);
          case 98 :
            return Curry._1(k, /* '\b' */8);
          case 110 :
            return Curry._1(k, /* '\n' */10);
          case 114 :
            return Curry._1(k, /* '\r' */13);
          case 93 :
          case 94 :
          case 95 :
          case 96 :
          case 97 :
          case 99 :
          case 100 :
          case 101 :
          case 102 :
          case 103 :
          case 104 :
          case 105 :
          case 106 :
          case 107 :
          case 108 :
          case 109 :
          case 111 :
          case 112 :
          case 113 :
          case 115 :
            break;
          case 116 :
            return Curry._1(k, /* '\t' */9);
        }
      }
      
    } else if (c === 34) {
      return Curry._1(k, /* '"' */34);
    }
    if (_is_digit(c)) {
      return read2int(c - /* '0' */48 | 0, (function (n) {
        return Curry._1(k, Stdlib__Char.chr(n));
      }), t);
    } else {
      return Curry._1(_error(t, {
        TAG: /* Format */ 0,
        _0: {
          TAG: /* String_literal */ 11,
          _0: "unexpected escaped char '",
          _1: {
            TAG: /* Char */ 0,
            _0: {
              TAG: /* Char_literal */ 12,
              _0: /* '\'' */39,
              _1: /* End_of_format */ 0
            }
          }
        },
        _1: "unexpected escaped char '%c'"
      }), c);
    }
  };
  const read2int = function (i, k, t) {
    if (t.i === t.len) {
      return _refill(t, (function (param) {
        return read2int(i, k, param);
      }), _error_eof);
    }
    const c = _get(t);
    if (_is_digit(c)) {
      return read1int(Math.imul(10, i) + (c - /* '0' */48 | 0) | 0, k, t);
    } else {
      return Curry._1(_error(t, {
        TAG: /* Format */ 0,
        _0: {
          TAG: /* String_literal */ 11,
          _0: "unexpected char '",
          _1: {
            TAG: /* Char */ 0,
            _0: {
              TAG: /* String_literal */ 11,
              _0: "' when reading byte",
              _1: /* End_of_format */ 0
            }
          }
        },
        _1: "unexpected char '%c' when reading byte"
      }), c);
    }
  };
  const read1int = function (i, k, t) {
    if (t.i === t.len) {
      return _refill(t, (function (param) {
        return read1int(i, k, param);
      }), _error_eof);
    }
    const c = _get(t);
    if (_is_digit(c)) {
      return Curry._1(k, Math.imul(10, i) + (c - /* '0' */48 | 0) | 0);
    } else {
      return Curry._1(_error(t, {
        TAG: /* Format */ 0,
        _0: {
          TAG: /* String_literal */ 11,
          _0: "unexpected char '",
          _1: {
            TAG: /* Char */ 0,
            _0: {
              TAG: /* String_literal */ 11,
              _0: "' when reading byte",
              _1: /* End_of_format */ 0
            }
          }
        },
        _1: "unexpected char '%c' when reading byte"
      }), c);
    }
  };
  const skip_comment = function (k, t) {
    while (true) {
      if (t.i === t.len) {
        return _refill(t, (function (param) {
          return skip_comment(k, param);
        }), _error_eof);
      }
      const match = _get(t);
      if (match === 10) {
        return Curry._2(k, undefined, undefined);
      }
      continue;
    };
  };
  const expr_or_end = function (k, t) {
    while (true) {
      if (t.i === t.len) {
        return _refill(t, (function (param) {
          return expr_or_end(k, param);
        }), (function (param) {
          return Curry._1(funarg.$$return, "End");
        }));
      }
      const c = _get(t);
      if (c >= 11) {
        if (c !== 32) {
          return expr_starting_with(c, k, t);
        }
        continue;
      }
      if (c < 9) {
        return expr_starting_with(c, k, t);
      }
      continue;
    };
  };
  const next = function (t) {
    return expr_or_end((function (param, x) {
      return Curry._1(funarg.$$return, {
        NAME: "Ok",
        VAL: x
      });
    }), t);
  };
  return {
    make: make,
    next: next
  };
}

const D = {
  make: make,
  next: next
};

module.exports = {
  to_buf,
  to_string,
  to_file,
  to_file_seq,
  to_chan,
  print,
  print_noindent,
  MakeDecode,
  ID_MONAD,
  D,
  parse_string,
  parse_chan,
  parse_chan_gen,
  parse_chan_list,
  parse_file,
  parse_file_list,
}
/* Stdlib__Format Not a pure module */
