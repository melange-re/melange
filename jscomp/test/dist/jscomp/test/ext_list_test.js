// Generated by Melange
'use strict';

const Caml_js_exceptions = require("melange.js/caml_js_exceptions.js");
const Caml_obj = require("melange.js/caml_obj.js");
const Caml_option = require("melange.js/caml_option.js");
const Curry = require("melange.js/curry.js");
const Ext_string_test = require("./ext_string_test.js");
const Stdlib__Array = require("melange/array.js");
const Stdlib__List = require("melange/list.js");

function filter_map(f, _xs) {
  while (true) {
    const xs = _xs;
    if (!xs) {
      return /* [] */ 0;
    }
    const ys = xs.tl;
    const z = Curry._1(f, xs.hd);
    if (z !== undefined) {
      return {
        hd: Caml_option.valFromOption(z),
        tl: filter_map(f, ys)
      };
    }
    _xs = ys;
    continue;
  };
}

function excludes(p, l) {
  const excluded = {
    contents: false
  };
  const aux = function (_accu, _param) {
    while (true) {
      const param = _param;
      const accu = _accu;
      if (!param) {
        return Stdlib__List.rev(accu);
      }
      const l = param.tl;
      const x = param.hd;
      if (Curry._1(p, x)) {
        excluded.contents = true;
        _param = l;
        continue;
      }
      _param = l;
      _accu = {
        hd: x,
        tl: accu
      };
      continue;
    };
  };
  const v = aux(/* [] */ 0, l);
  if (excluded.contents) {
    return [
      true,
      v
    ];
  } else {
    return [
      false,
      l
    ];
  }
}

function exclude_with_fact(p, l) {
  const excluded = {
    contents: undefined
  };
  const aux = function (_accu, _param) {
    while (true) {
      const param = _param;
      const accu = _accu;
      if (!param) {
        return Stdlib__List.rev(accu);
      }
      const l = param.tl;
      const x = param.hd;
      if (Curry._1(p, x)) {
        excluded.contents = Caml_option.some(x);
        _param = l;
        continue;
      }
      _param = l;
      _accu = {
        hd: x,
        tl: accu
      };
      continue;
    };
  };
  const v = aux(/* [] */ 0, l);
  return [
    excluded.contents,
    excluded.contents !== undefined ? v : l
  ];
}

function exclude_with_fact2(p1, p2, l) {
  const excluded1 = {
    contents: undefined
  };
  const excluded2 = {
    contents: undefined
  };
  const aux = function (_accu, _param) {
    while (true) {
      const param = _param;
      const accu = _accu;
      if (!param) {
        return Stdlib__List.rev(accu);
      }
      const l = param.tl;
      const x = param.hd;
      if (Curry._1(p1, x)) {
        excluded1.contents = Caml_option.some(x);
        _param = l;
        continue;
      }
      if (Curry._1(p2, x)) {
        excluded2.contents = Caml_option.some(x);
        _param = l;
        continue;
      }
      _param = l;
      _accu = {
        hd: x,
        tl: accu
      };
      continue;
    };
  };
  const v = aux(/* [] */ 0, l);
  return [
    excluded1.contents,
    excluded2.contents,
    excluded1.contents !== undefined && excluded2.contents !== undefined ? v : l
  ];
}

function same_length(_xs, _ys) {
  while (true) {
    const ys = _ys;
    const xs = _xs;
    if (!xs) {
      if (ys) {
        return false;
      } else {
        return true;
      }
    }
    if (!ys) {
      return false;
    }
    _ys = ys.tl;
    _xs = xs.tl;
    continue;
  };
}

function filter_mapi(f, xs) {
  const aux = function (_i, _xs) {
    while (true) {
      const xs = _xs;
      const i = _i;
      if (!xs) {
        return /* [] */ 0;
      }
      const ys = xs.tl;
      const z = Curry._2(f, i, xs.hd);
      if (z !== undefined) {
        return {
          hd: Caml_option.valFromOption(z),
          tl: aux(i + 1 | 0, ys)
        };
      }
      _xs = ys;
      _i = i + 1 | 0;
      continue;
    };
  };
  return aux(0, xs);
}

function filter_map2(f, _xs, _ys) {
  while (true) {
    const ys = _ys;
    const xs = _xs;
    if (xs) {
      if (ys) {
        const vs = ys.tl;
        const us = xs.tl;
        const z = Curry._2(f, xs.hd, ys.hd);
        if (z !== undefined) {
          return {
            hd: Caml_option.valFromOption(z),
            tl: filter_map2(f, us, vs)
          };
        }
        _ys = vs;
        _xs = us;
        continue;
      }
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Ext_list_test.filter_map2"
          });
    }
    if (!ys) {
      return /* [] */ 0;
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Ext_list_test.filter_map2"
        });
  };
}

function filter_map2i(f, xs, ys) {
  const aux = function (_i, _xs, _ys) {
    while (true) {
      const ys = _ys;
      const xs = _xs;
      const i = _i;
      if (xs) {
        if (ys) {
          const vs = ys.tl;
          const us = xs.tl;
          const z = Curry._3(f, i, xs.hd, ys.hd);
          if (z !== undefined) {
            return {
              hd: Caml_option.valFromOption(z),
              tl: aux(i + 1 | 0, us, vs)
            };
          }
          _ys = vs;
          _xs = us;
          _i = i + 1 | 0;
          continue;
        }
        throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Ext_list_test.filter_map2i"
            });
      }
      if (!ys) {
        return /* [] */ 0;
      }
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Ext_list_test.filter_map2i"
          });
    };
  };
  return aux(0, xs, ys);
}

function rev_map_append(f, _l1, _l2) {
  while (true) {
    const l2 = _l2;
    const l1 = _l1;
    if (!l1) {
      return l2;
    }
    _l2 = {
      hd: Curry._1(f, l1.hd),
      tl: l2
    };
    _l1 = l1.tl;
    continue;
  };
}

function flat_map2(f, lx, ly) {
  let _acc = /* [] */ 0;
  let _lx = lx;
  let _ly = ly;
  while (true) {
    const ly$1 = _ly;
    const lx$1 = _lx;
    const acc = _acc;
    if (lx$1) {
      if (ly$1) {
        _ly = ly$1.tl;
        _lx = lx$1.tl;
        _acc = Stdlib__List.rev_append(Curry._2(f, lx$1.hd, ly$1.hd), acc);
        continue;
      }
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Ext_list_test.flat_map2"
          });
    }
    if (ly$1) {
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Ext_list_test.flat_map2"
          });
    }
    return Stdlib__List.rev(acc);
  };
}

function flat_map_aux(f, _acc, append, _lx) {
  while (true) {
    const lx = _lx;
    const acc = _acc;
    if (!lx) {
      return Stdlib__List.rev_append(acc, append);
    }
    _lx = lx.tl;
    _acc = Stdlib__List.rev_append(Curry._1(f, lx.hd), acc);
    continue;
  };
}

function flat_map(f, lx) {
  return flat_map_aux(f, /* [] */ 0, /* [] */ 0, lx);
}

function flat_map_acc(f, append, lx) {
  return flat_map_aux(f, /* [] */ 0, append, lx);
}

function map2_last(f, l1, l2) {
  if (l1) {
    const l1$1 = l1.tl;
    const u = l1.hd;
    if (!l1$1) {
      if (l2) {
        if (!l2.tl) {
          return {
            hd: Curry._3(f, true, u, l2.hd),
            tl: /* [] */ 0
          };
        }
        
      } else {
        throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "List.map2_last"
            });
      }
    }
    if (l2) {
      const r = Curry._3(f, false, u, l2.hd);
      return {
        hd: r,
        tl: map2_last(f, l1$1, l2.tl)
      };
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "List.map2_last"
        });
  }
  if (!l2) {
    return /* [] */ 0;
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "List.map2_last"
      });
}

function map_last(f, l1) {
  if (!l1) {
    return /* [] */ 0;
  }
  const u = l1.hd;
  if (!l1.tl) {
    return {
      hd: Curry._2(f, true, u),
      tl: /* [] */ 0
    };
  }
  const r = Curry._2(f, false, u);
  return {
    hd: r,
    tl: map_last(f, l1.tl)
  };
}

function fold_right2_last(f, l1, l2, accu) {
  if (l1) {
    const l1$1 = l1.tl;
    const last1 = l1.hd;
    if (!l1$1) {
      if (l2) {
        if (!l2.tl) {
          return Curry._4(f, true, last1, l2.hd, accu);
        }
        
      } else {
        throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "List.fold_right2"
            });
      }
    }
    if (l2) {
      return Curry._4(f, false, last1, l2.hd, fold_right2_last(f, l1$1, l2.tl, accu));
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "List.fold_right2"
        });
  }
  if (l2) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "List.fold_right2"
        });
  }
  return accu;
}

function init(n, f) {
  return Stdlib__Array.to_list(Stdlib__Array.init(n, f));
}

function take(n, l) {
  const arr = Stdlib__Array.of_list(l);
  const arr_length = arr.length;
  if (arr_length < n) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Ext_list_test.take"
        });
  }
  return [
    Stdlib__Array.to_list(Stdlib__Array.sub(arr, 0, n)),
    Stdlib__Array.to_list(Stdlib__Array.sub(arr, n, arr_length - n | 0))
  ];
}

function try_take(n, l) {
  const arr = Stdlib__Array.of_list(l);
  const arr_length = arr.length;
  if (arr_length <= n) {
    return [
      l,
      arr_length,
      /* [] */ 0
    ];
  } else {
    return [
      Stdlib__Array.to_list(Stdlib__Array.sub(arr, 0, n)),
      n,
      Stdlib__Array.to_list(Stdlib__Array.sub(arr, n, arr_length - n | 0))
    ];
  }
}

function length_compare(_l, _n) {
  while (true) {
    const n = _n;
    const l = _l;
    if (n < 0) {
      return "Gt";
    }
    if (!l) {
      if (n === 0) {
        return "Eq";
      } else {
        return "Lt";
      }
    }
    _n = n - 1 | 0;
    _l = l.tl;
    continue;
  };
}

function length_larger_than_n(n, _xs, _ys) {
  while (true) {
    const ys = _ys;
    const xs = _xs;
    if (!ys) {
      return Caml_obj.caml_equal(length_compare(xs, n), "Eq");
    }
    if (!xs) {
      return false;
    }
    _ys = ys.tl;
    _xs = xs.tl;
    continue;
  };
}

function exclude_tail(x) {
  let _acc = /* [] */ 0;
  let _x = x;
  while (true) {
    const x$1 = _x;
    const acc = _acc;
    if (x$1) {
      const x$2 = x$1.hd;
      if (!x$1.tl) {
        return [
          x$2,
          Stdlib__List.rev(acc)
        ];
      }
      _x = x$1.tl;
      _acc = {
        hd: x$2,
        tl: acc
      };
      continue;
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Ext_list_test.exclude_tail"
        });
  };
}

function group(cmp, lst) {
  if (lst) {
    return aux(cmp, lst.hd, group(cmp, lst.tl));
  } else {
    return /* [] */ 0;
  }
}

function aux(cmp, x, xss) {
  if (!xss) {
    return {
      hd: {
        hd: x,
        tl: /* [] */ 0
      },
      tl: /* [] */ 0
    };
  }
  const ys = xss.tl;
  const y = xss.hd;
  if (Curry._2(cmp, x, Stdlib__List.hd(y))) {
    return {
      hd: {
        hd: x,
        tl: y
      },
      tl: ys
    };
  } else {
    return {
      hd: y,
      tl: aux(cmp, x, ys)
    };
  }
}

function stable_group(cmp, lst) {
  return Stdlib__List.rev(group(cmp, lst));
}

function drop(_n, _h) {
  while (true) {
    const h = _h;
    const n = _n;
    if (n < 0) {
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Ext_list_test.drop"
          });
    }
    if (n === 0) {
      return h;
    }
    if (Caml_obj.caml_equal(h, /* [] */ 0)) {
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Ext_list_test.drop"
          });
    }
    _h = Stdlib__List.tl(h);
    _n = n - 1 | 0;
    continue;
  };
}

function find_first_not(p, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return;
    }
    const a = param.hd;
    if (!Curry._1(p, a)) {
      return Caml_option.some(a);
    }
    _param = param.tl;
    continue;
  };
}

function for_all_opt(p, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return;
    }
    const v = Curry._1(p, param.hd);
    if (v !== undefined) {
      return v;
    }
    _param = param.tl;
    continue;
  };
}

function fold(f, l, init) {
  return Stdlib__List.fold_left((function (acc, i) {
    return Curry._2(f, i, init);
  }), init, l);
}

function rev_map_acc(acc, f, l) {
  let _accu = acc;
  let _param = l;
  while (true) {
    const param = _param;
    const accu = _accu;
    if (!param) {
      return accu;
    }
    _param = param.tl;
    _accu = {
      hd: Curry._1(f, param.hd),
      tl: accu
    };
    continue;
  };
}

function map_acc(acc, f, l) {
  if (l) {
    return {
      hd: Curry._1(f, l.hd),
      tl: map_acc(acc, f, l.tl)
    };
  } else {
    return acc;
  }
}

function rev_iter(f, xs) {
  if (xs) {
    rev_iter(f, xs.tl);
    return Curry._1(f, xs.hd);
  }
  
}

function for_all2_no_exn(p, _l1, _l2) {
  while (true) {
    const l2 = _l2;
    const l1 = _l1;
    if (!l1) {
      if (l2) {
        return false;
      } else {
        return true;
      }
    }
    if (!l2) {
      return false;
    }
    if (!Curry._2(p, l1.hd, l2.hd)) {
      return false;
    }
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue;
  };
}

function find_no_exn(p, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return;
    }
    const x = param.hd;
    if (Curry._1(p, x)) {
      return Caml_option.some(x);
    }
    _param = param.tl;
    continue;
  };
}

function find_opt(p, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return;
    }
    const v = Curry._1(p, param.hd);
    if (v !== undefined) {
      return v;
    }
    _param = param.tl;
    continue;
  };
}

function split_map(f, xs) {
  let _bs = /* [] */ 0;
  let _cs = /* [] */ 0;
  let _xs = xs;
  while (true) {
    const xs$1 = _xs;
    const cs = _cs;
    const bs = _bs;
    if (!xs$1) {
      return [
        Stdlib__List.rev(bs),
        Stdlib__List.rev(cs)
      ];
    }
    const match = Curry._1(f, xs$1.hd);
    _xs = xs$1.tl;
    _cs = {
      hd: match[1],
      tl: cs
    };
    _bs = {
      hd: match[0],
      tl: bs
    };
    continue;
  };
}

function reduce_from_right(fn, lst) {
  const match = Stdlib__List.rev(lst);
  if (match) {
    return Stdlib__List.fold_left((function (x, y) {
      return Curry._2(fn, y, x);
    }), match.hd, match.tl);
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Ext_list_test.reduce"
      });
}

function reduce_from_left(fn, lst) {
  if (lst) {
    return Stdlib__List.fold_left(fn, lst.hd, lst.tl);
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Ext_list_test.reduce_from_left"
      });
}

function create_ref_empty(param) {
  return {
    contents: /* [] */ 0
  };
}

function ref_top(x) {
  const match = x.contents;
  if (match) {
    return match.hd;
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Ext_list_test.ref_top"
      });
}

function ref_empty(x) {
  const match = x.contents;
  if (match) {
    return false;
  } else {
    return true;
  }
}

function ref_push(x, refs) {
  refs.contents = {
    hd: x,
    tl: refs.contents
  };
}

function ref_pop(refs) {
  const match = refs.contents;
  if (match) {
    refs.contents = match.tl;
    return match.hd;
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Ext_list_test.ref_pop"
      });
}

function rev_except_last(xs) {
  let _acc = /* [] */ 0;
  let _xs = xs;
  while (true) {
    const xs$1 = _xs;
    const acc = _acc;
    if (xs$1) {
      const x = xs$1.hd;
      if (!xs$1.tl) {
        return [
          acc,
          x
        ];
      }
      _xs = xs$1.tl;
      _acc = {
        hd: x,
        tl: acc
      };
      continue;
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Ext_list_test.rev_except_last"
        });
  };
}

function sort_via_array(cmp, lst) {
  const arr = Stdlib__Array.of_list(lst);
  Stdlib__Array.sort(cmp, arr);
  return Stdlib__Array.to_list(arr);
}

function last(_xs) {
  while (true) {
    const xs = _xs;
    if (xs) {
      if (!xs.tl) {
        return xs.hd;
      }
      _xs = xs.tl;
      continue;
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Ext_list_test.last"
        });
  };
}

function assoc_by_string(def, k, _lst) {
  while (true) {
    const lst = _lst;
    if (lst) {
      const match = lst.hd;
      if (match[0] === k) {
        return match[1];
      }
      _lst = lst.tl;
      continue;
    }
    if (def !== undefined) {
      return Caml_option.valFromOption(def);
    }
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "jscomp/test/ext_list_test.ml",
            399,
            14
          ]
        });
  };
}

function assoc_by_int(def, k, _lst) {
  while (true) {
    const lst = _lst;
    if (lst) {
      const match = lst.hd;
      if (match[0] === k) {
        return match[1];
      }
      _lst = lst.tl;
      continue;
    }
    if (def !== undefined) {
      return Caml_option.valFromOption(def);
    }
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "jscomp/test/ext_list_test.ml",
            409,
            14
          ]
        });
  };
}

module.exports = {
  filter_map,
  excludes,
  exclude_with_fact,
  exclude_with_fact2,
  same_length,
  filter_mapi,
  filter_map2,
  filter_map2i,
  rev_map_append,
  flat_map2,
  flat_map_aux,
  flat_map,
  flat_map_acc,
  map2_last,
  map_last,
  fold_right2_last,
  init,
  take,
  try_take,
  length_compare,
  length_larger_than_n,
  exclude_tail,
  group,
  aux,
  stable_group,
  drop,
  find_first_not,
  for_all_opt,
  fold,
  rev_map_acc,
  map_acc,
  rev_iter,
  for_all2_no_exn,
  find_no_exn,
  find_opt,
  split_map,
  reduce_from_right,
  reduce_from_left,
  create_ref_empty,
  ref_top,
  ref_empty,
  ref_push,
  ref_pop,
  rev_except_last,
  sort_via_array,
  last,
  assoc_by_string,
  assoc_by_int,
}
/* Ext_string_test Not a pure module */
