// Generated by Melange
'use strict';

const Belt__Belt_Array = require("./belt_Array.js");
const Belt__Belt_SortArray = require("./belt_SortArray.js");
const Caml_js_exceptions = require("melange.js/caml_js_exceptions.js");
const Caml_option = require("melange.js/caml_option.js");
const Curry = require("melange.js/curry.js");
const Stdlib = require("melange/stdlib.js");

function head(x) {
  if (x) {
    return Caml_option.some(x.hd);
  }
  
}

function headExn(x) {
  if (x) {
    return x.hd;
  }
  throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
      MEL_EXN_ID: Stdlib.Not_found
    });
}

function tail(x) {
  if (x) {
    return x.tl;
  }
  
}

function tailExn(x) {
  if (x) {
    return x.tl;
  }
  throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
      MEL_EXN_ID: Stdlib.Not_found
    });
}

function add(xs, x) {
  return {
    hd: x,
    tl: xs
  };
}

function get(x, n) {
  if (n < 0) {
    return;
  } else {
    let _x = x;
    let _n = n;
    while (true) {
      const n$1 = _n;
      const x$1 = _x;
      if (!x$1) {
        return;
      }
      if (n$1 === 0) {
        return Caml_option.some(x$1.hd);
      }
      _n = n$1 - 1 | 0;
      _x = x$1.tl;
      continue;
    };
  }
}

function getExn(x, n) {
  if (n < 0) {
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
        MEL_EXN_ID: Stdlib.Not_found
      });
  }
  let _x = x;
  let _n = n;
  while (true) {
    const n$1 = _n;
    const x$1 = _x;
    if (x$1) {
      if (n$1 === 0) {
        return x$1.hd;
      }
      _n = n$1 - 1 | 0;
      _x = x$1.tl;
      continue;
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
        MEL_EXN_ID: Stdlib.Not_found
      });
  };
}

function partitionAux(p, _cell, _precX, _precY) {
  while (true) {
    const precY = _precY;
    const precX = _precX;
    const cell = _cell;
    if (!cell) {
      return;
    }
    const t = cell.tl;
    const h = cell.hd;
    const next = {
      hd: h,
      tl: /* [] */ 0
    };
    if (p(h)) {
      precX.tl = next;
      _precX = next;
      _cell = t;
      continue;
    }
    precY.tl = next;
    _precY = next;
    _cell = t;
    continue;
  };
}

function splitAux(_cell, _precX, _precY) {
  while (true) {
    const precY = _precY;
    const precX = _precX;
    const cell = _cell;
    if (!cell) {
      return;
    }
    const match = cell.hd;
    const nextA = {
      hd: match[0],
      tl: /* [] */ 0
    };
    const nextB = {
      hd: match[1],
      tl: /* [] */ 0
    };
    precX.tl = nextA;
    precY.tl = nextB;
    _precY = nextB;
    _precX = nextA;
    _cell = cell.tl;
    continue;
  };
}

function copyAuxCont(_cellX, _prec) {
  while (true) {
    const prec = _prec;
    const cellX = _cellX;
    if (!cellX) {
      return prec;
    }
    const next = {
      hd: cellX.hd,
      tl: /* [] */ 0
    };
    prec.tl = next;
    _prec = next;
    _cellX = cellX.tl;
    continue;
  };
}

function copyAuxWitFilter(f, _cellX, _prec) {
  while (true) {
    const prec = _prec;
    const cellX = _cellX;
    if (!cellX) {
      return;
    }
    const t = cellX.tl;
    const h = cellX.hd;
    if (f(h)) {
      const next = {
        hd: h,
        tl: /* [] */ 0
      };
      prec.tl = next;
      _prec = next;
      _cellX = t;
      continue;
    }
    _cellX = t;
    continue;
  };
}

function copyAuxWithFilterIndex(f, _cellX, _prec, _i) {
  while (true) {
    const i = _i;
    const prec = _prec;
    const cellX = _cellX;
    if (!cellX) {
      return;
    }
    const t = cellX.tl;
    const h = cellX.hd;
    if (f(h, i)) {
      const next = {
        hd: h,
        tl: /* [] */ 0
      };
      prec.tl = next;
      _i = i + 1 | 0;
      _prec = next;
      _cellX = t;
      continue;
    }
    _i = i + 1 | 0;
    _cellX = t;
    continue;
  };
}

function copyAuxWitFilterMap(f, _cellX, _prec) {
  while (true) {
    const prec = _prec;
    const cellX = _cellX;
    if (!cellX) {
      return;
    }
    const t = cellX.tl;
    const h = f(cellX.hd);
    if (h !== undefined) {
      const next = {
        hd: Caml_option.valFromOption(h),
        tl: /* [] */ 0
      };
      prec.tl = next;
      _prec = next;
      _cellX = t;
      continue;
    }
    _cellX = t;
    continue;
  };
}

function removeAssocAuxWithMap(_cellX, x, _prec, f) {
  while (true) {
    const prec = _prec;
    const cellX = _cellX;
    if (!cellX) {
      return false;
    }
    const t = cellX.tl;
    const h = cellX.hd;
    if (f(h[0], x)) {
      prec.tl = t;
      return true;
    }
    const next = {
      hd: h,
      tl: /* [] */ 0
    };
    prec.tl = next;
    _prec = next;
    _cellX = t;
    continue;
  };
}

function setAssocAuxWithMap(_cellX, x, k, _prec, eq) {
  while (true) {
    const prec = _prec;
    const cellX = _cellX;
    if (!cellX) {
      return false;
    }
    const t = cellX.tl;
    const h = cellX.hd;
    if (eq(h[0], x)) {
      prec.tl = {
        hd: [
          x,
          k
        ],
        tl: t
      };
      return true;
    }
    const next = {
      hd: h,
      tl: /* [] */ 0
    };
    prec.tl = next;
    _prec = next;
    _cellX = t;
    continue;
  };
}

function copyAuxWithMap(_cellX, _prec, f) {
  while (true) {
    const prec = _prec;
    const cellX = _cellX;
    if (!cellX) {
      return;
    }
    const next = {
      hd: f(cellX.hd),
      tl: /* [] */ 0
    };
    prec.tl = next;
    _prec = next;
    _cellX = cellX.tl;
    continue;
  };
}

function zipAux(_cellX, _cellY, _prec) {
  while (true) {
    const prec = _prec;
    const cellY = _cellY;
    const cellX = _cellX;
    if (!cellX) {
      return;
    }
    if (!cellY) {
      return;
    }
    const next = {
      hd: [
        cellX.hd,
        cellY.hd
      ],
      tl: /* [] */ 0
    };
    prec.tl = next;
    _prec = next;
    _cellY = cellY.tl;
    _cellX = cellX.tl;
    continue;
  };
}

function copyAuxWithMap2(f, _cellX, _cellY, _prec) {
  while (true) {
    const prec = _prec;
    const cellY = _cellY;
    const cellX = _cellX;
    if (!cellX) {
      return;
    }
    if (!cellY) {
      return;
    }
    const next = {
      hd: f(cellX.hd, cellY.hd),
      tl: /* [] */ 0
    };
    prec.tl = next;
    _prec = next;
    _cellY = cellY.tl;
    _cellX = cellX.tl;
    continue;
  };
}

function copyAuxWithMapI(f, _i, _cellX, _prec) {
  while (true) {
    const prec = _prec;
    const cellX = _cellX;
    const i = _i;
    if (!cellX) {
      return;
    }
    const next = {
      hd: f(i, cellX.hd),
      tl: /* [] */ 0
    };
    prec.tl = next;
    _prec = next;
    _cellX = cellX.tl;
    _i = i + 1 | 0;
    continue;
  };
}

function takeAux(_n, _cell, _prec) {
  while (true) {
    const prec = _prec;
    const cell = _cell;
    const n = _n;
    if (n === 0) {
      return true;
    }
    if (!cell) {
      return false;
    }
    const cell$1 = {
      hd: cell.hd,
      tl: /* [] */ 0
    };
    prec.tl = cell$1;
    _prec = cell$1;
    _cell = cell.tl;
    _n = n - 1 | 0;
    continue;
  };
}

function splitAtAux(_n, _cell, _prec) {
  while (true) {
    const prec = _prec;
    const cell = _cell;
    const n = _n;
    if (n === 0) {
      return cell;
    }
    if (!cell) {
      return;
    }
    const cell$1 = {
      hd: cell.hd,
      tl: /* [] */ 0
    };
    prec.tl = cell$1;
    _prec = cell$1;
    _cell = cell.tl;
    _n = n - 1 | 0;
    continue;
  };
}

function take(lst, n) {
  if (n < 0) {
    return;
  }
  if (n === 0) {
    return /* [] */ 0;
  }
  if (!lst) {
    return;
  }
  const cell = {
    hd: lst.hd,
    tl: /* [] */ 0
  };
  const has = takeAux(n - 1 | 0, lst.tl, cell);
  if (has) {
    return cell;
  }
  
}

function drop(lst, n) {
  if (n < 0) {
    return;
  } else {
    let _l = lst;
    let _n = n;
    while (true) {
      const n$1 = _n;
      const l = _l;
      if (n$1 === 0) {
        return l;
      }
      if (!l) {
        return;
      }
      _n = n$1 - 1 | 0;
      _l = l.tl;
      continue;
    };
  }
}

function splitAt(lst, n) {
  if (n < 0) {
    return;
  }
  if (n === 0) {
    return [
      /* [] */ 0,
      lst
    ];
  }
  if (!lst) {
    return;
  }
  const cell = {
    hd: lst.hd,
    tl: /* [] */ 0
  };
  const rest = splitAtAux(n - 1 | 0, lst.tl, cell);
  if (rest !== undefined) {
    return [
      cell,
      rest
    ];
  }
  
}

function concat(xs, ys) {
  if (!xs) {
    return ys;
  }
  const cell = {
    hd: xs.hd,
    tl: /* [] */ 0
  };
  copyAuxCont(xs.tl, cell).tl = ys;
  return cell;
}

function mapU(xs, f) {
  if (!xs) {
    return /* [] */ 0;
  }
  const cell = {
    hd: f(xs.hd),
    tl: /* [] */ 0
  };
  copyAuxWithMap(xs.tl, cell, f);
  return cell;
}

function map(xs, f) {
  return mapU(xs, Curry.__1(f));
}

function zipByU(l1, l2, f) {
  if (!l1) {
    return /* [] */ 0;
  }
  if (!l2) {
    return /* [] */ 0;
  }
  const cell = {
    hd: f(l1.hd, l2.hd),
    tl: /* [] */ 0
  };
  copyAuxWithMap2(f, l1.tl, l2.tl, cell);
  return cell;
}

function zipBy(l1, l2, f) {
  return zipByU(l1, l2, Curry.__2(f));
}

function mapWithIndexU(xs, f) {
  if (!xs) {
    return /* [] */ 0;
  }
  const cell = {
    hd: f(0, xs.hd),
    tl: /* [] */ 0
  };
  copyAuxWithMapI(f, 1, xs.tl, cell);
  return cell;
}

function mapWithIndex(xs, f) {
  return mapWithIndexU(xs, Curry.__2(f));
}

function makeByU(n, f) {
  if (n <= 0) {
    return /* [] */ 0;
  }
  const headX = {
    hd: f(0),
    tl: /* [] */ 0
  };
  let cur = headX;
  let i = 1;
  while (i < n) {
    const v = {
      hd: f(i),
      tl: /* [] */ 0
    };
    cur.tl = v;
    cur = v;
    i = i + 1 | 0;
  };
  return headX;
}

function makeBy(n, f) {
  return makeByU(n, Curry.__1(f));
}

function make(n, v) {
  if (n <= 0) {
    return /* [] */ 0;
  }
  const headX = {
    hd: v,
    tl: /* [] */ 0
  };
  let cur = headX;
  let i = 1;
  while (i < n) {
    const v$1 = {
      hd: v,
      tl: /* [] */ 0
    };
    cur.tl = v$1;
    cur = v$1;
    i = i + 1 | 0;
  };
  return headX;
}

function length(xs) {
  let _x = xs;
  let _acc = 0;
  while (true) {
    const acc = _acc;
    const x = _x;
    if (!x) {
      return acc;
    }
    _acc = acc + 1 | 0;
    _x = x.tl;
    continue;
  };
}

function fillAux(arr, _i, _x) {
  while (true) {
    const x = _x;
    const i = _i;
    if (!x) {
      return;
    }
    arr[i] = x.hd;
    _x = x.tl;
    _i = i + 1 | 0;
    continue;
  };
}

function fromArray(a) {
  let _i = a.length - 1 | 0;
  let _res = /* [] */ 0;
  while (true) {
    const res = _res;
    const i = _i;
    if (i < 0) {
      return res;
    }
    _res = {
      hd: a[i],
      tl: res
    };
    _i = i - 1 | 0;
    continue;
  };
}

function toArray(x) {
  const len = length(x);
  const arr = new Array(len);
  fillAux(arr, 0, x);
  return arr;
}

function shuffle(xs) {
  const v = toArray(xs);
  Belt__Belt_Array.shuffleInPlace(v);
  return fromArray(v);
}

function reverseConcat(_l1, _l2) {
  while (true) {
    const l2 = _l2;
    const l1 = _l1;
    if (!l1) {
      return l2;
    }
    _l2 = {
      hd: l1.hd,
      tl: l2
    };
    _l1 = l1.tl;
    continue;
  };
}

function reverse(l) {
  return reverseConcat(l, /* [] */ 0);
}

function flattenAux(_prec, _xs) {
  while (true) {
    const xs = _xs;
    const prec = _prec;
    if (xs) {
      _xs = xs.tl;
      _prec = copyAuxCont(xs.hd, prec);
      continue;
    }
    prec.tl = /* [] */ 0;
    return;
  };
}

function flatten(_xs) {
  while (true) {
    const xs = _xs;
    if (!xs) {
      return /* [] */ 0;
    }
    const match = xs.hd;
    if (match) {
      const cell = {
        hd: match.hd,
        tl: /* [] */ 0
      };
      flattenAux(copyAuxCont(match.tl, cell), xs.tl);
      return cell;
    }
    _xs = xs.tl;
    continue;
  };
}

function concatMany(xs) {
  const len = xs.length;
  if (len === 1) {
    return xs[0];
  }
  if (!len) {
    return /* [] */ 0;
  }
  const len$1 = xs.length;
  let v = xs[len$1 - 1 | 0];
  for (let i = len$1 - 2 | 0; i >= 0; --i) {
    v = concat(xs[i], v);
  }
  return v;
}

function mapReverseU(l, f) {
  let _accu = /* [] */ 0;
  let _xs = l;
  while (true) {
    const xs = _xs;
    const accu = _accu;
    if (!xs) {
      return accu;
    }
    _xs = xs.tl;
    _accu = {
      hd: f(xs.hd),
      tl: accu
    };
    continue;
  };
}

function mapReverse(l, f) {
  return mapReverseU(l, Curry.__1(f));
}

function forEachU(_xs, f) {
  while (true) {
    const xs = _xs;
    if (!xs) {
      return;
    }
    f(xs.hd);
    _xs = xs.tl;
    continue;
  };
}

function forEach(xs, f) {
  forEachU(xs, Curry.__1(f));
}

function forEachWithIndexU(l, f) {
  let _xs = l;
  let _i = 0;
  while (true) {
    const i = _i;
    const xs = _xs;
    if (!xs) {
      return;
    }
    f(i, xs.hd);
    _i = i + 1 | 0;
    _xs = xs.tl;
    continue;
  };
}

function forEachWithIndex(l, f) {
  forEachWithIndexU(l, Curry.__2(f));
}

function reduceU(_l, _accu, f) {
  while (true) {
    const accu = _accu;
    const l = _l;
    if (!l) {
      return accu;
    }
    _accu = f(accu, l.hd);
    _l = l.tl;
    continue;
  };
}

function reduce(l, accu, f) {
  return reduceU(l, accu, Curry.__2(f));
}

function reduceReverseUnsafeU(l, accu, f) {
  if (l) {
    return f(reduceReverseUnsafeU(l.tl, accu, f), l.hd);
  } else {
    return accu;
  }
}

function reduceReverseU(l, acc, f) {
  const len = length(l);
  if (len < 1000) {
    return reduceReverseUnsafeU(l, acc, f);
  } else {
    return Belt__Belt_Array.reduceReverseU(toArray(l), acc, f);
  }
}

function reduceReverse(l, accu, f) {
  return reduceReverseU(l, accu, Curry.__2(f));
}

function reduceWithIndexU(l, acc, f) {
  let _l = l;
  let _acc = acc;
  let _i = 0;
  while (true) {
    const i = _i;
    const acc$1 = _acc;
    const l$1 = _l;
    if (!l$1) {
      return acc$1;
    }
    _i = i + 1 | 0;
    _acc = f(acc$1, l$1.hd, i);
    _l = l$1.tl;
    continue;
  };
}

function reduceWithIndex(l, acc, f) {
  return reduceWithIndexU(l, acc, Curry.__3(f));
}

function mapReverse2U(l1, l2, f) {
  let _l1 = l1;
  let _l2 = l2;
  let _accu = /* [] */ 0;
  while (true) {
    const accu = _accu;
    const l2$1 = _l2;
    const l1$1 = _l1;
    if (!l1$1) {
      return accu;
    }
    if (!l2$1) {
      return accu;
    }
    _accu = {
      hd: f(l1$1.hd, l2$1.hd),
      tl: accu
    };
    _l2 = l2$1.tl;
    _l1 = l1$1.tl;
    continue;
  };
}

function mapReverse2(l1, l2, f) {
  return mapReverse2U(l1, l2, Curry.__2(f));
}

function forEach2U(_l1, _l2, f) {
  while (true) {
    const l2 = _l2;
    const l1 = _l1;
    if (!l1) {
      return;
    }
    if (!l2) {
      return;
    }
    f(l1.hd, l2.hd);
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue;
  };
}

function forEach2(l1, l2, f) {
  forEach2U(l1, l2, Curry.__2(f));
}

function reduce2U(_l1, _l2, _accu, f) {
  while (true) {
    const accu = _accu;
    const l2 = _l2;
    const l1 = _l1;
    if (!l1) {
      return accu;
    }
    if (!l2) {
      return accu;
    }
    _accu = f(accu, l1.hd, l2.hd);
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue;
  };
}

function reduce2(l1, l2, acc, f) {
  return reduce2U(l1, l2, acc, Curry.__3(f));
}

function reduceReverse2UnsafeU(l1, l2, accu, f) {
  if (l1 && l2) {
    return f(reduceReverse2UnsafeU(l1.tl, l2.tl, accu, f), l1.hd, l2.hd);
  } else {
    return accu;
  }
}

function reduceReverse2U(l1, l2, acc, f) {
  const len = length(l1);
  if (len < 1000) {
    return reduceReverse2UnsafeU(l1, l2, acc, f);
  } else {
    return Belt__Belt_Array.reduceReverse2U(toArray(l1), toArray(l2), acc, f);
  }
}

function reduceReverse2(l1, l2, acc, f) {
  return reduceReverse2U(l1, l2, acc, Curry.__3(f));
}

function everyU(_xs, p) {
  while (true) {
    const xs = _xs;
    if (!xs) {
      return true;
    }
    if (!p(xs.hd)) {
      return false;
    }
    _xs = xs.tl;
    continue;
  };
}

function every(xs, p) {
  return everyU(xs, Curry.__1(p));
}

function someU(_xs, p) {
  while (true) {
    const xs = _xs;
    if (!xs) {
      return false;
    }
    if (p(xs.hd)) {
      return true;
    }
    _xs = xs.tl;
    continue;
  };
}

function some(xs, p) {
  return someU(xs, Curry.__1(p));
}

function every2U(_l1, _l2, p) {
  while (true) {
    const l2 = _l2;
    const l1 = _l1;
    if (!l1) {
      return true;
    }
    if (!l2) {
      return true;
    }
    if (!p(l1.hd, l2.hd)) {
      return false;
    }
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue;
  };
}

function every2(l1, l2, p) {
  return every2U(l1, l2, Curry.__2(p));
}

function cmpByLength(_l1, _l2) {
  while (true) {
    const l2 = _l2;
    const l1 = _l1;
    if (!l1) {
      if (l2) {
        return -1;
      } else {
        return 0;
      }
    }
    if (!l2) {
      return 1;
    }
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue;
  };
}

function cmpU(_l1, _l2, p) {
  while (true) {
    const l2 = _l2;
    const l1 = _l1;
    if (!l1) {
      if (l2) {
        return -1;
      } else {
        return 0;
      }
    }
    if (!l2) {
      return 1;
    }
    const c = p(l1.hd, l2.hd);
    if (c !== 0) {
      return c;
    }
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue;
  };
}

function cmp(l1, l2, f) {
  return cmpU(l1, l2, Curry.__2(f));
}

function eqU(_l1, _l2, p) {
  while (true) {
    const l2 = _l2;
    const l1 = _l1;
    if (!l1) {
      if (l2) {
        return false;
      } else {
        return true;
      }
    }
    if (!l2) {
      return false;
    }
    if (!p(l1.hd, l2.hd)) {
      return false;
    }
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue;
  };
}

function eq(l1, l2, f) {
  return eqU(l1, l2, Curry.__2(f));
}

function some2U(_l1, _l2, p) {
  while (true) {
    const l2 = _l2;
    const l1 = _l1;
    if (!l1) {
      return false;
    }
    if (!l2) {
      return false;
    }
    if (p(l1.hd, l2.hd)) {
      return true;
    }
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue;
  };
}

function some2(l1, l2, p) {
  return some2U(l1, l2, Curry.__2(p));
}

function hasU(_xs, x, eq) {
  while (true) {
    const xs = _xs;
    if (!xs) {
      return false;
    }
    if (eq(xs.hd, x)) {
      return true;
    }
    _xs = xs.tl;
    continue;
  };
}

function has(xs, x, eq) {
  return hasU(xs, x, Curry.__2(eq));
}

function getAssocU(_xs, x, eq) {
  while (true) {
    const xs = _xs;
    if (!xs) {
      return;
    }
    const match = xs.hd;
    if (eq(match[0], x)) {
      return Caml_option.some(match[1]);
    }
    _xs = xs.tl;
    continue;
  };
}

function getAssoc(xs, x, eq) {
  return getAssocU(xs, x, Curry.__2(eq));
}

function hasAssocU(_xs, x, eq) {
  while (true) {
    const xs = _xs;
    if (!xs) {
      return false;
    }
    if (eq(xs.hd[0], x)) {
      return true;
    }
    _xs = xs.tl;
    continue;
  };
}

function hasAssoc(xs, x, eq) {
  return hasAssocU(xs, x, Curry.__2(eq));
}

function removeAssocU(xs, x, eq) {
  if (!xs) {
    return /* [] */ 0;
  }
  const l = xs.tl;
  const pair = xs.hd;
  if (eq(pair[0], x)) {
    return l;
  }
  const cell = {
    hd: pair,
    tl: /* [] */ 0
  };
  const removed = removeAssocAuxWithMap(l, x, cell, eq);
  if (removed) {
    return cell;
  } else {
    return xs;
  }
}

function removeAssoc(xs, x, eq) {
  return removeAssocU(xs, x, Curry.__2(eq));
}

function setAssocU(xs, x, k, eq) {
  if (!xs) {
    return {
      hd: [
        x,
        k
      ],
      tl: /* [] */ 0
    };
  }
  const l = xs.tl;
  const pair = xs.hd;
  if (eq(pair[0], x)) {
    return {
      hd: [
        x,
        k
      ],
      tl: l
    };
  }
  const cell = {
    hd: pair,
    tl: /* [] */ 0
  };
  const replaced = setAssocAuxWithMap(l, x, k, cell, eq);
  if (replaced) {
    return cell;
  } else {
    return {
      hd: [
        x,
        k
      ],
      tl: xs
    };
  }
}

function setAssoc(xs, x, k, eq) {
  return setAssocU(xs, x, k, Curry.__2(eq));
}

function sortU(xs, cmp) {
  const arr = toArray(xs);
  Belt__Belt_SortArray.stableSortInPlaceByU(arr, cmp);
  return fromArray(arr);
}

function sort(xs, cmp) {
  return sortU(xs, Curry.__2(cmp));
}

function getByU(_xs, p) {
  while (true) {
    const xs = _xs;
    if (!xs) {
      return;
    }
    const x = xs.hd;
    if (p(x)) {
      return Caml_option.some(x);
    }
    _xs = xs.tl;
    continue;
  };
}

function getBy(xs, p) {
  return getByU(xs, Curry.__1(p));
}

function keepU(_xs, p) {
  while (true) {
    const xs = _xs;
    if (!xs) {
      return /* [] */ 0;
    }
    const t = xs.tl;
    const h = xs.hd;
    if (p(h)) {
      const cell = {
        hd: h,
        tl: /* [] */ 0
      };
      copyAuxWitFilter(p, t, cell);
      return cell;
    }
    _xs = t;
    continue;
  };
}

function keep(xs, p) {
  return keepU(xs, Curry.__1(p));
}

function keepWithIndexU(xs, p) {
  let _xs = xs;
  let _i = 0;
  while (true) {
    const i = _i;
    const xs$1 = _xs;
    if (!xs$1) {
      return /* [] */ 0;
    }
    const t = xs$1.tl;
    const h = xs$1.hd;
    if (p(h, i)) {
      const cell = {
        hd: h,
        tl: /* [] */ 0
      };
      copyAuxWithFilterIndex(p, t, cell, i + 1 | 0);
      return cell;
    }
    _i = i + 1 | 0;
    _xs = t;
    continue;
  };
}

function keepWithIndex(xs, p) {
  return keepWithIndexU(xs, Curry.__2(p));
}

function keepMapU(_xs, p) {
  while (true) {
    const xs = _xs;
    if (!xs) {
      return /* [] */ 0;
    }
    const t = xs.tl;
    const h = p(xs.hd);
    if (h !== undefined) {
      const cell = {
        hd: Caml_option.valFromOption(h),
        tl: /* [] */ 0
      };
      copyAuxWitFilterMap(p, t, cell);
      return cell;
    }
    _xs = t;
    continue;
  };
}

function keepMap(xs, p) {
  return keepMapU(xs, Curry.__1(p));
}

function partitionU(l, p) {
  if (!l) {
    return [
      /* [] */ 0,
      /* [] */ 0
    ];
  }
  const h = l.hd;
  const nextX = {
    hd: h,
    tl: /* [] */ 0
  };
  const nextY = {
    hd: h,
    tl: /* [] */ 0
  };
  const b = p(h);
  partitionAux(p, l.tl, nextX, nextY);
  if (b) {
    return [
      nextX,
      nextY.tl
    ];
  } else {
    return [
      nextX.tl,
      nextY
    ];
  }
}

function partition(l, p) {
  return partitionU(l, Curry.__1(p));
}

function unzip(xs) {
  if (!xs) {
    return [
      /* [] */ 0,
      /* [] */ 0
    ];
  }
  const match = xs.hd;
  const cellX = {
    hd: match[0],
    tl: /* [] */ 0
  };
  const cellY = {
    hd: match[1],
    tl: /* [] */ 0
  };
  splitAux(xs.tl, cellX, cellY);
  return [
    cellX,
    cellY
  ];
}

function zip(l1, l2) {
  if (!l1) {
    return /* [] */ 0;
  }
  if (!l2) {
    return /* [] */ 0;
  }
  const cell = {
    hd: [
      l1.hd,
      l2.hd
    ],
    tl: /* [] */ 0
  };
  zipAux(l1.tl, l2.tl, cell);
  return cell;
}

const size = length;

module.exports = {
  length,
  size,
  head,
  headExn,
  tail,
  tailExn,
  add,
  get,
  getExn,
  make,
  makeByU,
  makeBy,
  shuffle,
  drop,
  take,
  splitAt,
  concat,
  concatMany,
  reverseConcat,
  flatten,
  mapU,
  map,
  zip,
  zipByU,
  zipBy,
  mapWithIndexU,
  mapWithIndex,
  fromArray,
  toArray,
  reverse,
  mapReverseU,
  mapReverse,
  forEachU,
  forEach,
  forEachWithIndexU,
  forEachWithIndex,
  reduceU,
  reduce,
  reduceWithIndexU,
  reduceWithIndex,
  reduceReverseU,
  reduceReverse,
  mapReverse2U,
  mapReverse2,
  forEach2U,
  forEach2,
  reduce2U,
  reduce2,
  reduceReverse2U,
  reduceReverse2,
  everyU,
  every,
  someU,
  some,
  every2U,
  every2,
  some2U,
  some2,
  cmpByLength,
  cmpU,
  cmp,
  eqU,
  eq,
  hasU,
  has,
  getByU,
  getBy,
  keepU,
  keep,
  keepWithIndexU,
  keepWithIndex,
  keepMapU,
  keepMap,
  partitionU,
  partition,
  unzip,
  getAssocU,
  getAssoc,
  hasAssocU,
  hasAssoc,
  removeAssocU,
  removeAssoc,
  setAssocU,
  setAssoc,
  sortU,
  sort,
}
/* No side effect */
