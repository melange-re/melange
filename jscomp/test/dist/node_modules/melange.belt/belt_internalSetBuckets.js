// Generated by Melange
'use strict';

const Belt__Belt_Array = require("./belt_Array.js");
const Curry = require("melange.js/curry.js");

function copyBucket(c) {
  if (c === undefined) {
    return c;
  }
  const head = {
    key: c.key,
    next: undefined
  };
  copyAuxCont(c.next, head);
  return head;
}

function copyAuxCont(_c, _prec) {
  while (true) {
    const prec = _prec;
    const c = _c;
    if (c === undefined) {
      return;
    }
    const ncopy = {
      key: c.key,
      next: undefined
    };
    prec.next = ncopy;
    _prec = ncopy;
    _c = c.next;
    continue;
  };
}

function copyBuckets(buckets) {
  const len = buckets.length;
  const newBuckets = new Array(len);
  for (let i = 0; i < len; ++i) {
    newBuckets[i] = copyBucket(buckets[i]);
  }
  return newBuckets;
}

function copy(x) {
  return {
    size: x.size,
    buckets: copyBuckets(x.buckets),
    hash: x.hash,
    eq: x.eq
  };
}

function bucketLength(_accu, _buckets) {
  while (true) {
    const buckets = _buckets;
    const accu = _accu;
    if (buckets === undefined) {
      return accu;
    }
    _buckets = buckets.next;
    _accu = accu + 1 | 0;
    continue;
  };
}

function doBucketIter(f, _buckets) {
  while (true) {
    const buckets = _buckets;
    if (buckets === undefined) {
      return;
    }
    f(buckets.key);
    _buckets = buckets.next;
    continue;
  };
}

function forEachU(h, f) {
  const d = h.buckets;
  for (let i = 0, i_finish = d.length; i < i_finish; ++i) {
    doBucketIter(f, d[i]);
  }
}

function forEach(h, f) {
  forEachU(h, Curry.__1(f));
}

function fillArray(_i, arr, _cell) {
  while (true) {
    const cell = _cell;
    const i = _i;
    arr[i] = cell.key;
    const v = cell.next;
    if (v === undefined) {
      return i + 1 | 0;
    }
    _cell = v;
    _i = i + 1 | 0;
    continue;
  };
}

function toArray(h) {
  const d = h.buckets;
  let current = 0;
  const arr = new Array(h.size);
  for (let i = 0, i_finish = d.length; i < i_finish; ++i) {
    const cell = d[i];
    if (cell !== undefined) {
      current = fillArray(current, arr, cell);
    }
    
  }
  return arr;
}

function doBucketFold(f, _b, _accu) {
  while (true) {
    const accu = _accu;
    const b = _b;
    if (b === undefined) {
      return accu;
    }
    _accu = f(accu, b.key);
    _b = b.next;
    continue;
  };
}

function reduceU(h, init, f) {
  const d = h.buckets;
  let accu = init;
  for (let i = 0, i_finish = d.length; i < i_finish; ++i) {
    accu = doBucketFold(f, d[i], accu);
  }
  return accu;
}

function reduce(h, init, f) {
  return reduceU(h, init, Curry.__2(f));
}

function getMaxBucketLength(h) {
  return Belt__Belt_Array.reduceU(h.buckets, 0, (function (m, b) {
    const len = bucketLength(0, b);
    if (m > len) {
      return m;
    } else {
      return len;
    }
  }));
}

function getBucketHistogram(h) {
  const mbl = getMaxBucketLength(h);
  const histo = Belt__Belt_Array.makeByU(mbl + 1 | 0, (function (param) {
    return 0;
  }));
  Belt__Belt_Array.forEachU(h.buckets, (function (b) {
    const l = bucketLength(0, b);
    histo[l] = histo[l] + 1 | 0;
  }));
  return histo;
}

function logStats(h) {
  const histogram = getBucketHistogram(h);
  console.log({
    bindings: h.size,
    buckets: h.buckets.length,
    histogram: histogram
  });
}

module.exports = {
  copy,
  forEachU,
  forEach,
  fillArray,
  toArray,
  reduceU,
  reduce,
  logStats,
  getBucketHistogram,
}
/* No side effect */
