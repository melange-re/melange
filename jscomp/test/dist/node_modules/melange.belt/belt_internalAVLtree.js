// Generated by Melange
'use strict';

const Belt__Belt_SortArray = require("./belt_SortArray.js");
const Caml_js_exceptions = require("melange.js/caml_js_exceptions.js");
const Caml_option = require("melange.js/caml_option.js");
const Curry = require("melange.js/curry.js");
const Stdlib = require("melange/stdlib.js");

function treeHeight(n) {
  if (n !== undefined) {
    return Caml_option.valFromOption(n).h;
  } else {
    return 0;
  }
}

function copy(n) {
  if (n === undefined) {
    return n;
  }
  const n$1 = Caml_option.valFromOption(n);
  return {
    k: n$1.k,
    v: n$1.v,
    h: n$1.h,
    l: copy(n$1.l),
    r: copy(n$1.r)
  };
}

function create(l, x, d, r) {
  const hl = treeHeight(l);
  const hr = treeHeight(r);
  return {
    k: x,
    v: d,
    h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0,
    l: l,
    r: r
  };
}

function singleton(x, d) {
  return {
    k: x,
    v: d,
    h: 1,
    l: undefined,
    r: undefined
  };
}

function heightGe(l, r) {
  if (r !== undefined) {
    if (l !== undefined) {
      return l.h >= r.h;
    } else {
      return false;
    }
  } else {
    return true;
  }
}

function updateValue(n, newValue) {
  if (n.v === newValue) {
    return n;
  } else {
    return {
      k: n.k,
      v: newValue,
      h: n.h,
      l: n.l,
      r: n.r
    };
  }
}

function bal(l, x, d, r) {
  const hl = l !== undefined ? Caml_option.valFromOption(l).h : 0;
  const hr = r !== undefined ? Caml_option.valFromOption(r).h : 0;
  if (hl > (hr + 2 | 0)) {
    const ll = l.l;
    const lr = l.r;
    if (treeHeight(ll) >= treeHeight(lr)) {
      return create(ll, l.k, l.v, create(lr, x, d, r));
    }
    const lr$1 = Caml_option.valFromOption(lr);
    return create(create(ll, l.k, l.v, lr$1.l), lr$1.k, lr$1.v, create(lr$1.r, x, d, r));
  }
  if (hr <= (hl + 2 | 0)) {
    return {
      k: x,
      v: d,
      h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0,
      l: l,
      r: r
    };
  }
  const r$1 = Caml_option.valFromOption(r);
  const rl = r$1.l;
  const rr = r$1.r;
  if (treeHeight(rr) >= treeHeight(rl)) {
    return create(create(l, x, d, rl), r$1.k, r$1.v, rr);
  }
  const rl$1 = Caml_option.valFromOption(rl);
  return create(create(l, x, d, rl$1.l), rl$1.k, rl$1.v, create(rl$1.r, r$1.k, r$1.v, rr));
}

function minKey0Aux(_n) {
  while (true) {
    const n = _n;
    const n$1 = n.l;
    if (n$1 === undefined) {
      return n.k;
    }
    _n = Caml_option.valFromOption(n$1);
    continue;
  };
}

function minKey(n) {
  if (n !== undefined) {
    return Caml_option.some(minKey0Aux(n));
  }
  
}

function minKeyUndefined(n) {
  if (n !== undefined) {
    return minKey0Aux(n);
  }
  
}

function maxKey0Aux(_n) {
  while (true) {
    const n = _n;
    const n$1 = n.r;
    if (n$1 === undefined) {
      return n.k;
    }
    _n = Caml_option.valFromOption(n$1);
    continue;
  };
}

function maxKey(n) {
  if (n !== undefined) {
    return Caml_option.some(maxKey0Aux(n));
  }
  
}

function maxKeyUndefined(n) {
  if (n !== undefined) {
    return maxKey0Aux(n);
  }
  
}

function minKV0Aux(_n) {
  while (true) {
    const n = _n;
    const n$1 = n.l;
    if (n$1 === undefined) {
      return [
        n.k,
        n.v
      ];
    }
    _n = Caml_option.valFromOption(n$1);
    continue;
  };
}

function minimum(n) {
  if (n !== undefined) {
    return minKV0Aux(n);
  }
  
}

function minUndefined(n) {
  if (n !== undefined) {
    return minKV0Aux(n);
  }
  
}

function maxKV0Aux(_n) {
  while (true) {
    const n = _n;
    const n$1 = n.r;
    if (n$1 === undefined) {
      return [
        n.k,
        n.v
      ];
    }
    _n = Caml_option.valFromOption(n$1);
    continue;
  };
}

function maximum(n) {
  if (n !== undefined) {
    return maxKV0Aux(n);
  }
  
}

function maxUndefined(n) {
  if (n !== undefined) {
    return maxKV0Aux(n);
  }
  
}

function removeMinAuxWithRef(n, kr, vr) {
  const ln = n.l;
  if (ln !== undefined) {
    return bal(removeMinAuxWithRef(Caml_option.valFromOption(ln), kr, vr), n.k, n.v, n.r);
  } else {
    kr.contents = n.k;
    vr.contents = n.v;
    return n.r;
  }
}

function isEmpty(x) {
  return x === undefined;
}

function stackAllLeft(_v, _s) {
  while (true) {
    const s = _s;
    const v = _v;
    if (v === undefined) {
      return s;
    }
    const x = Caml_option.valFromOption(v);
    _s = {
      hd: x,
      tl: s
    };
    _v = x.l;
    continue;
  };
}

function findFirstByU(n, p) {
  if (n === undefined) {
    return;
  }
  const n$1 = Caml_option.valFromOption(n);
  const left = findFirstByU(n$1.l, p);
  if (left !== undefined) {
    return left;
  }
  const v = n$1.k;
  const d = n$1.v;
  const pvd = p(v, d);
  if (pvd) {
    return [
      v,
      d
    ];
  }
  const right = findFirstByU(n$1.r, p);
  if (right !== undefined) {
    return right;
  }
  
}

function findFirstBy(n, p) {
  return findFirstByU(n, Curry.__2(p));
}

function forEachU(_n, f) {
  while (true) {
    const n = _n;
    if (n === undefined) {
      return;
    }
    const n$1 = Caml_option.valFromOption(n);
    forEachU(n$1.l, f);
    f(n$1.k, n$1.v);
    _n = n$1.r;
    continue;
  };
}

function forEach(n, f) {
  forEachU(n, Curry.__2(f));
}

function mapU(n, f) {
  if (n === undefined) {
    return;
  }
  const n$1 = Caml_option.valFromOption(n);
  const newLeft = mapU(n$1.l, f);
  const newD = f(n$1.v);
  const newRight = mapU(n$1.r, f);
  return {
    k: n$1.k,
    v: newD,
    h: n$1.h,
    l: newLeft,
    r: newRight
  };
}

function map(n, f) {
  return mapU(n, Curry.__1(f));
}

function mapWithKeyU(n, f) {
  if (n === undefined) {
    return;
  }
  const n$1 = Caml_option.valFromOption(n);
  const key = n$1.k;
  const newLeft = mapWithKeyU(n$1.l, f);
  const newD = f(key, n$1.v);
  const newRight = mapWithKeyU(n$1.r, f);
  return {
    k: key,
    v: newD,
    h: n$1.h,
    l: newLeft,
    r: newRight
  };
}

function mapWithKey(n, f) {
  return mapWithKeyU(n, Curry.__2(f));
}

function reduceU(_m, _accu, f) {
  while (true) {
    const accu = _accu;
    const m = _m;
    if (m === undefined) {
      return accu;
    }
    const n = Caml_option.valFromOption(m);
    const v = n.k;
    const d = n.v;
    const l = n.l;
    const r = n.r;
    _accu = f(reduceU(l, accu, f), v, d);
    _m = r;
    continue;
  };
}

function reduce(m, accu, f) {
  return reduceU(m, accu, Curry.__3(f));
}

function everyU(_n, p) {
  while (true) {
    const n = _n;
    if (n === undefined) {
      return true;
    }
    const n$1 = Caml_option.valFromOption(n);
    if (!p(n$1.k, n$1.v)) {
      return false;
    }
    if (!everyU(n$1.l, p)) {
      return false;
    }
    _n = n$1.r;
    continue;
  };
}

function every(n, p) {
  return everyU(n, Curry.__2(p));
}

function someU(_n, p) {
  while (true) {
    const n = _n;
    if (n === undefined) {
      return false;
    }
    const n$1 = Caml_option.valFromOption(n);
    if (p(n$1.k, n$1.v)) {
      return true;
    }
    if (someU(n$1.l, p)) {
      return true;
    }
    _n = n$1.r;
    continue;
  };
}

function some(n, p) {
  return someU(n, Curry.__2(p));
}

function addMinElement(n, k, v) {
  if (n === undefined) {
    return singleton(k, v);
  }
  const n$1 = Caml_option.valFromOption(n);
  return bal(addMinElement(n$1.l, k, v), n$1.k, n$1.v, n$1.r);
}

function addMaxElement(n, k, v) {
  if (n === undefined) {
    return singleton(k, v);
  }
  const n$1 = Caml_option.valFromOption(n);
  return bal(n$1.l, n$1.k, n$1.v, addMaxElement(n$1.r, k, v));
}

function join(ln, v, d, rn) {
  if (ln === undefined) {
    return addMinElement(rn, v, d);
  }
  if (rn === undefined) {
    return addMaxElement(ln, v, d);
  }
  const r = Caml_option.valFromOption(rn);
  const l = Caml_option.valFromOption(ln);
  const lv = l.k;
  const ld = l.v;
  const lh = l.h;
  const ll = l.l;
  const lr = l.r;
  const rv = r.k;
  const rd = r.v;
  const rh = r.h;
  const rl = r.l;
  const rr = r.r;
  if (lh > (rh + 2 | 0)) {
    return bal(ll, lv, ld, join(lr, v, d, rn));
  } else if (rh > (lh + 2 | 0)) {
    return bal(join(ln, v, d, rl), rv, rd, rr);
  } else {
    return create(ln, v, d, rn);
  }
}

function concat(t1, t2) {
  if (t1 === undefined) {
    return t2;
  }
  if (t2 === undefined) {
    return t1;
  }
  const t2n = Caml_option.valFromOption(t2);
  const kr = {
    contents: t2n.k
  };
  const vr = {
    contents: t2n.v
  };
  const t2r = removeMinAuxWithRef(t2n, kr, vr);
  return join(t1, kr.contents, vr.contents, t2r);
}

function concatOrJoin(t1, v, d, t2) {
  if (d !== undefined) {
    return join(t1, v, Caml_option.valFromOption(d), t2);
  } else {
    return concat(t1, t2);
  }
}

function keepSharedU(n, p) {
  if (n === undefined) {
    return;
  }
  const n$1 = Caml_option.valFromOption(n);
  const v = n$1.k;
  const d = n$1.v;
  const newLeft = keepSharedU(n$1.l, p);
  const pvd = p(v, d);
  const newRight = keepSharedU(n$1.r, p);
  if (pvd) {
    return join(newLeft, v, d, newRight);
  } else {
    return concat(newLeft, newRight);
  }
}

function keepShared(n, p) {
  return keepSharedU(n, Curry.__2(p));
}

function keepMapU(n, p) {
  if (n === undefined) {
    return;
  }
  const n$1 = Caml_option.valFromOption(n);
  const v = n$1.k;
  const d = n$1.v;
  const newLeft = keepMapU(n$1.l, p);
  const pvd = p(v, d);
  const newRight = keepMapU(n$1.r, p);
  if (pvd !== undefined) {
    return join(newLeft, v, Caml_option.valFromOption(pvd), newRight);
  } else {
    return concat(newLeft, newRight);
  }
}

function keepMap(n, p) {
  return keepMapU(n, Curry.__2(p));
}

function partitionSharedU(n, p) {
  if (n === undefined) {
    return [
      undefined,
      undefined
    ];
  }
  const n$1 = Caml_option.valFromOption(n);
  const key = n$1.k;
  const value = n$1.v;
  const match = partitionSharedU(n$1.l, p);
  const lf = match[1];
  const lt = match[0];
  const pvd = p(key, value);
  const match$1 = partitionSharedU(n$1.r, p);
  const rf = match$1[1];
  const rt = match$1[0];
  if (pvd) {
    return [
      join(lt, key, value, rt),
      concat(lf, rf)
    ];
  } else {
    return [
      concat(lt, rt),
      join(lf, key, value, rf)
    ];
  }
}

function partitionShared(n, p) {
  return partitionSharedU(n, Curry.__2(p));
}

function lengthNode(n) {
  const l = n.l;
  const r = n.r;
  const sizeL = l !== undefined ? lengthNode(Caml_option.valFromOption(l)) : 0;
  const sizeR = r !== undefined ? lengthNode(Caml_option.valFromOption(r)) : 0;
  return (1 + sizeL | 0) + sizeR | 0;
}

function size(n) {
  if (n !== undefined) {
    return lengthNode(n);
  } else {
    return 0;
  }
}

function toListAux(_n, _accu) {
  while (true) {
    const accu = _accu;
    const n = _n;
    if (n === undefined) {
      return accu;
    }
    const n$1 = Caml_option.valFromOption(n);
    const k = n$1.k;
    const v = n$1.v;
    const l = n$1.l;
    const r = n$1.r;
    _accu = {
      hd: [
        k,
        v
      ],
      tl: toListAux(r, accu)
    };
    _n = l;
    continue;
  };
}

function toList(s) {
  return toListAux(s, /* [] */ 0);
}

function checkInvariantInternal(_v) {
  while (true) {
    const v = _v;
    if (v === undefined) {
      return;
    }
    const n = Caml_option.valFromOption(v);
    const l = n.l;
    const r = n.r;
    const diff = treeHeight(l) - treeHeight(r) | 0;
    if (!(diff <= 2 && diff >= -2)) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "belt/belt_internalAVLtree.ml",
            360,
            6
          ]
        });
    }
    checkInvariantInternal(l);
    _v = r;
    continue;
  };
}

function fillArrayKey(_n, _i, arr) {
  while (true) {
    const i = _i;
    const n = _n;
    const v = n.k;
    const l = n.l;
    const r = n.r;
    const next = l !== undefined ? fillArrayKey(Caml_option.valFromOption(l), i, arr) : i;
    arr[next] = v;
    const rnext = next + 1 | 0;
    if (r === undefined) {
      return rnext;
    }
    _i = rnext;
    _n = Caml_option.valFromOption(r);
    continue;
  };
}

function fillArrayValue(_n, _i, arr) {
  while (true) {
    const i = _i;
    const n = _n;
    const l = n.l;
    const r = n.r;
    const next = l !== undefined ? fillArrayValue(Caml_option.valFromOption(l), i, arr) : i;
    arr[next] = n.v;
    const rnext = next + 1 | 0;
    if (r === undefined) {
      return rnext;
    }
    _i = rnext;
    _n = Caml_option.valFromOption(r);
    continue;
  };
}

function fillArray(_n, _i, arr) {
  while (true) {
    const i = _i;
    const n = _n;
    const l = n.l;
    const v = n.k;
    const r = n.r;
    const next = l !== undefined ? fillArray(Caml_option.valFromOption(l), i, arr) : i;
    arr[next] = [
      v,
      n.v
    ];
    const rnext = next + 1 | 0;
    if (r === undefined) {
      return rnext;
    }
    _i = rnext;
    _n = Caml_option.valFromOption(r);
    continue;
  };
}

function toArray(n) {
  if (n === undefined) {
    return [];
  }
  const size = lengthNode(n);
  const v = new Array(size);
  fillArray(n, 0, v);
  return v;
}

function keysToArray(n) {
  if (n === undefined) {
    return [];
  }
  const size = lengthNode(n);
  const v = new Array(size);
  fillArrayKey(n, 0, v);
  return v;
}

function valuesToArray(n) {
  if (n === undefined) {
    return [];
  }
  const size = lengthNode(n);
  const v = new Array(size);
  fillArrayValue(n, 0, v);
  return v;
}

function fromSortedArrayRevAux(arr, off, len) {
  switch (len) {
    case 0 :
      return;
    case 1 :
      const match = arr[off];
      return singleton(match[0], match[1]);
    case 2 :
      const match_0 = arr[off];
      const match_1 = arr[off - 1 | 0];
      const match$1 = match_1;
      const match$2 = match_0;
      return {
        k: match$1[0],
        v: match$1[1],
        h: 2,
        l: singleton(match$2[0], match$2[1]),
        r: undefined
      };
    case 3 :
      const match_0$1 = arr[off];
      const match_1$1 = arr[off - 1 | 0];
      const match_2 = arr[off - 2 | 0];
      const match$3 = match_2;
      const match$4 = match_1$1;
      const match$5 = match_0$1;
      return {
        k: match$4[0],
        v: match$4[1],
        h: 2,
        l: singleton(match$5[0], match$5[1]),
        r: singleton(match$3[0], match$3[1])
      };
    default:
      const nl = len / 2 | 0;
      const left = fromSortedArrayRevAux(arr, off, nl);
      const match$6 = arr[off - nl | 0];
      const right = fromSortedArrayRevAux(arr, (off - nl | 0) - 1 | 0, (len - nl | 0) - 1 | 0);
      return create(left, match$6[0], match$6[1], right);
  }
}

function fromSortedArrayAux(arr, off, len) {
  switch (len) {
    case 0 :
      return;
    case 1 :
      const match = arr[off];
      return singleton(match[0], match[1]);
    case 2 :
      const match_0 = arr[off];
      const match_1 = arr[off + 1 | 0];
      const match$1 = match_1;
      const match$2 = match_0;
      return {
        k: match$1[0],
        v: match$1[1],
        h: 2,
        l: singleton(match$2[0], match$2[1]),
        r: undefined
      };
    case 3 :
      const match_0$1 = arr[off];
      const match_1$1 = arr[off + 1 | 0];
      const match_2 = arr[off + 2 | 0];
      const match$3 = match_2;
      const match$4 = match_1$1;
      const match$5 = match_0$1;
      return {
        k: match$4[0],
        v: match$4[1],
        h: 2,
        l: singleton(match$5[0], match$5[1]),
        r: singleton(match$3[0], match$3[1])
      };
    default:
      const nl = len / 2 | 0;
      const left = fromSortedArrayAux(arr, off, nl);
      const match$6 = arr[off + nl | 0];
      const right = fromSortedArrayAux(arr, (off + nl | 0) + 1 | 0, (len - nl | 0) - 1 | 0);
      return create(left, match$6[0], match$6[1], right);
  }
}

function fromSortedArrayUnsafe(arr) {
  return fromSortedArrayAux(arr, 0, arr.length);
}

function cmpU(s1, s2, kcmp, vcmp) {
  const len1 = size(s1);
  const len2 = size(s2);
  if (len1 === len2) {
    let _e1 = stackAllLeft(s1, /* [] */ 0);
    let _e2 = stackAllLeft(s2, /* [] */ 0);
    while (true) {
      const e2 = _e2;
      const e1 = _e1;
      if (!e1) {
        return 0;
      }
      if (!e2) {
        return 0;
      }
      const h2 = e2.hd;
      const h1 = e1.hd;
      const c = kcmp(h1.k, h2.k);
      if (c !== 0) {
        return c;
      }
      const cx = vcmp(h1.v, h2.v);
      if (cx !== 0) {
        return cx;
      }
      _e2 = stackAllLeft(h2.r, e2.tl);
      _e1 = stackAllLeft(h1.r, e1.tl);
      continue;
    };
  } else if (len1 < len2) {
    return -1;
  } else {
    return 1;
  }
}

function cmp(s1, s2, kcmp, vcmp) {
  return cmpU(s1, s2, kcmp, Curry.__2(vcmp));
}

function eqU(s1, s2, kcmp, veq) {
  const len1 = size(s1);
  const len2 = size(s2);
  if (len1 === len2) {
    let _e1 = stackAllLeft(s1, /* [] */ 0);
    let _e2 = stackAllLeft(s2, /* [] */ 0);
    while (true) {
      const e2 = _e2;
      const e1 = _e1;
      if (!e1) {
        return true;
      }
      if (!e2) {
        return true;
      }
      const h2 = e2.hd;
      const h1 = e1.hd;
      if (!(kcmp(h1.k, h2.k) === 0 && veq(h1.v, h2.v))) {
        return false;
      }
      _e2 = stackAllLeft(h2.r, e2.tl);
      _e1 = stackAllLeft(h1.r, e1.tl);
      continue;
    };
  } else {
    return false;
  }
}

function eq(s1, s2, kcmp, veq) {
  return eqU(s1, s2, kcmp, Curry.__2(veq));
}

function get(_n, x, cmp) {
  while (true) {
    const n = _n;
    if (n === undefined) {
      return;
    }
    const n$1 = Caml_option.valFromOption(n);
    const v = n$1.k;
    const c = cmp(x, v);
    if (c === 0) {
      return Caml_option.some(n$1.v);
    }
    _n = c < 0 ? n$1.l : n$1.r;
    continue;
  };
}

function getUndefined(_n, x, cmp) {
  while (true) {
    const n = _n;
    if (n === undefined) {
      return;
    }
    const n$1 = Caml_option.valFromOption(n);
    const v = n$1.k;
    const c = cmp(x, v);
    if (c === 0) {
      return n$1.v;
    }
    _n = c < 0 ? n$1.l : n$1.r;
    continue;
  };
}

function getExn(_n, x, cmp) {
  while (true) {
    const n = _n;
    if (n !== undefined) {
      const n$1 = Caml_option.valFromOption(n);
      const v = n$1.k;
      const c = cmp(x, v);
      if (c === 0) {
        return n$1.v;
      }
      _n = c < 0 ? n$1.l : n$1.r;
      continue;
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
        MEL_EXN_ID: Stdlib.Not_found
      });
  };
}

function getWithDefault(_n, x, def, cmp) {
  while (true) {
    const n = _n;
    if (n === undefined) {
      return def;
    }
    const n$1 = Caml_option.valFromOption(n);
    const v = n$1.k;
    const c = cmp(x, v);
    if (c === 0) {
      return n$1.v;
    }
    _n = c < 0 ? n$1.l : n$1.r;
    continue;
  };
}

function has(_n, x, cmp) {
  while (true) {
    const n = _n;
    if (n === undefined) {
      return false;
    }
    const n$1 = Caml_option.valFromOption(n);
    const v = n$1.k;
    const c = cmp(x, v);
    if (c === 0) {
      return true;
    }
    _n = c < 0 ? n$1.l : n$1.r;
    continue;
  };
}

function rotateWithLeftChild(k2) {
  const k1 = k2.l;
  const k1$1 = Caml_option.valFromOption(k1);
  k2.l = k1$1.r;
  k1$1.r = k2;
  const hlk2 = treeHeight(k2.l);
  const hrk2 = treeHeight(k2.r);
  k2.h = (
    hlk2 > hrk2 ? hlk2 : hrk2
  ) + 1 | 0;
  const hlk1 = treeHeight(k1$1.l);
  const hk2 = k2.h;
  k1$1.h = (
    hlk1 > hk2 ? hlk1 : hk2
  ) + 1 | 0;
  return k1$1;
}

function rotateWithRightChild(k1) {
  const k2 = k1.r;
  const k2$1 = Caml_option.valFromOption(k2);
  k1.r = k2$1.l;
  k2$1.l = k1;
  const hlk1 = treeHeight(k1.l);
  const hrk1 = treeHeight(k1.r);
  k1.h = (
    hlk1 > hrk1 ? hlk1 : hrk1
  ) + 1 | 0;
  const hrk2 = treeHeight(k2$1.r);
  const hk1 = k1.h;
  k2$1.h = (
    hrk2 > hk1 ? hrk2 : hk1
  ) + 1 | 0;
  return k2$1;
}

function doubleWithLeftChild(k3) {
  const x = k3.l;
  const v = rotateWithRightChild(Caml_option.valFromOption(x));
  k3.l = v;
  return rotateWithLeftChild(k3);
}

function doubleWithRightChild(k2) {
  const x = k2.r;
  const v = rotateWithLeftChild(Caml_option.valFromOption(x));
  k2.r = v;
  return rotateWithRightChild(k2);
}

function heightUpdateMutate(t) {
  const hlt = treeHeight(t.l);
  const hrt = treeHeight(t.r);
  t.h = (
    hlt > hrt ? hlt : hrt
  ) + 1 | 0;
  return t;
}

function balMutate(nt) {
  const l = nt.l;
  const r = nt.r;
  const hl = treeHeight(l);
  const hr = treeHeight(r);
  if (hl > (2 + hr | 0)) {
    const match = Caml_option.valFromOption(l);
    const ll = match.l;
    const lr = match.r;
    if (heightGe(ll, lr)) {
      return heightUpdateMutate(rotateWithLeftChild(nt));
    } else {
      return heightUpdateMutate(doubleWithLeftChild(nt));
    }
  }
  if (hr > (2 + hl | 0)) {
    const match$1 = Caml_option.valFromOption(r);
    const rl = match$1.l;
    const rr = match$1.r;
    if (heightGe(rr, rl)) {
      return heightUpdateMutate(rotateWithRightChild(nt));
    } else {
      return heightUpdateMutate(doubleWithRightChild(nt));
    }
  }
  nt.h = (
    hl > hr ? hl : hr
  ) + 1 | 0;
  return nt;
}

function updateMutate(t, x, data, cmp) {
  if (t === undefined) {
    return singleton(x, data);
  }
  const nt = Caml_option.valFromOption(t);
  const k = nt.k;
  const c = cmp(x, k);
  if (c === 0) {
    nt.v = data;
    return nt;
  }
  const l = nt.l;
  const r = nt.r;
  if (c < 0) {
    const ll = updateMutate(l, x, data, cmp);
    nt.l = ll;
  } else {
    nt.r = updateMutate(r, x, data, cmp);
  }
  return balMutate(nt);
}

function fromArray(xs, cmp) {
  const len = xs.length;
  if (len === 0) {
    return;
  }
  let next = Belt__Belt_SortArray.strictlySortedLengthU(xs, (function (param, param$1) {
    return cmp(param[0], param$1[0]) < 0;
  }));
  let result;
  if (next >= 0) {
    result = fromSortedArrayAux(xs, 0, next);
  } else {
    next = -next | 0;
    result = fromSortedArrayRevAux(xs, next - 1 | 0, next);
  }
  for (let i = next; i < len; ++i) {
    const match = xs[i];
    result = updateMutate(result, match[0], match[1], cmp);
  }
  return result;
}

function removeMinAuxWithRootMutate(nt, n) {
  const rn = n.r;
  const ln = n.l;
  if (ln !== undefined) {
    n.l = removeMinAuxWithRootMutate(nt, Caml_option.valFromOption(ln));
    return balMutate(n);
  } else {
    nt.k = n.k;
    nt.v = n.v;
    return rn;
  }
}

module.exports = {
  copy,
  create,
  bal,
  singleton,
  updateValue,
  minKey,
  minKeyUndefined,
  maxKey,
  maxKeyUndefined,
  minimum,
  minUndefined,
  maximum,
  maxUndefined,
  removeMinAuxWithRef,
  isEmpty,
  stackAllLeft,
  findFirstByU,
  findFirstBy,
  forEachU,
  forEach,
  mapU,
  map,
  mapWithKeyU,
  mapWithKey,
  reduceU,
  reduce,
  everyU,
  every,
  someU,
  some,
  join,
  concat,
  concatOrJoin,
  keepSharedU,
  keepShared,
  keepMapU,
  keepMap,
  partitionSharedU,
  partitionShared,
  lengthNode,
  size,
  toList,
  checkInvariantInternal,
  fillArray,
  toArray,
  keysToArray,
  valuesToArray,
  fromSortedArrayAux,
  fromSortedArrayRevAux,
  fromSortedArrayUnsafe,
  cmpU,
  cmp,
  eqU,
  eq,
  get,
  getUndefined,
  getWithDefault,
  getExn,
  has,
  fromArray,
  updateMutate,
  balMutate,
  removeMinAuxWithRootMutate,
}
/* No side effect */
