// Generated by Melange
'use strict';

const Caml_bytes = require("melange.js/caml_bytes.js");
const Caml_external_polyfill = require("melange.js/caml_external_polyfill.js");
const Caml_js_exceptions = require("melange.js/caml_js_exceptions.js");
const Caml_option = require("melange.js/caml_option.js");
const Curry = require("melange.js/curry.js");
const Stdlib = require("./stdlib.js");
const Stdlib__Bytes = require("./bytes.js");
const Stdlib__Fun = require("./fun.js");
const Stdlib__Sys = require("./sys.js");

function with_open(openfun, s, f) {
  const ic = Curry._1(openfun, s);
  return Stdlib__Fun.protect((function (param) {
    Stdlib.close_in_noerr(ic);
  }), (function (param) {
    return Curry._1(f, ic);
  }));
}

function with_open_bin(s, f) {
  return with_open(Stdlib.open_in_bin, s, f);
}

function with_open_text(s, f) {
  return with_open(Stdlib.open_in, s, f);
}

function with_open_gen(flags, perm, s, f) {
  return with_open((function (param) {
    return Stdlib.open_in_gen(flags, perm, param);
  }), s, f);
}

const seek = Stdlib.LargeFile.seek_in;

const pos = Stdlib.LargeFile.pos_in;

const length = Stdlib.LargeFile.in_channel_length;

function input_char(ic) {
  let c;
  try {
    c = Caml_external_polyfill.resolve("caml_ml_input_char")(ic);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
      return;
    }
    throw exn;
  }
  return c;
}

function input_byte(ic) {
  let n;
  try {
    n = Caml_external_polyfill.resolve("caml_ml_input_char")(ic);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
      return;
    }
    throw exn;
  }
  return n;
}

function input_line(ic) {
  let s;
  try {
    s = Stdlib.input_line(ic);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
      return;
    }
    throw exn;
  }
  return s;
}

function really_input(ic, buf, pos, len) {
  try {
    Stdlib.really_input(ic, buf, pos, len);
    return Caml_option.some();
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
      return;
    }
    throw exn;
  }
}

function really_input_string(ic, len) {
  let s;
  try {
    s = Stdlib.really_input_string(ic, len);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
      return;
    }
    throw exn;
  }
  return s;
}

function read_upto(ic, buf, ofs, len) {
  const loop = function (_ofs, _len) {
    while (true) {
      const len = _len;
      const ofs = _ofs;
      if (len === 0) {
        return ofs;
      }
      const r = Stdlib.input(ic, buf, ofs, len);
      if (r === 0) {
        return ofs;
      }
      _len = len - r | 0;
      _ofs = ofs + r | 0;
      continue;
    };
  };
  return loop(ofs, len) - ofs | 0;
}

function ensure(buf, ofs, n) {
  const len = buf.length;
  if (len >= (ofs + n | 0)) {
    return buf;
  }
  let new_len = len;
  while (new_len < (ofs + n | 0)) {
    new_len = (new_len << 1) + 1 | 0;
  };
  const new_len$1 = new_len;
  let new_len$2;
  if (new_len$1 <= Stdlib__Sys.max_string_length) {
    new_len$2 = new_len$1;
  } else if (ofs < Stdlib__Sys.max_string_length) {
    new_len$2 = Stdlib__Sys.max_string_length;
  } else {
    throw new Caml_js_exceptions.MelangeError("Failure", {
        MEL_EXN_ID: "Failure",
        _1: "In_channel.input_all: channel content is larger than maximum string length"
      });
  }
  const new_buf = Caml_bytes.caml_create_bytes(new_len$2);
  Stdlib__Bytes.blit(buf, 0, new_buf, 0, ofs);
  return new_buf;
}

function input_all(ic) {
  let initial_size;
  try {
    initial_size = Caml_external_polyfill.resolve("caml_ml_channel_size")(ic) - Caml_external_polyfill.resolve("caml_ml_pos_in")(ic) | 0;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Sys_error) {
      initial_size = -1;
    } else {
      throw exn;
    }
  }
  const initial_size$1 = initial_size < 0 ? Stdlib__Sys.io_buffer_size : initial_size;
  const initial_size$2 = initial_size$1 <= Stdlib__Sys.max_string_length ? initial_size$1 : Stdlib__Sys.max_string_length;
  const buf = Caml_bytes.caml_create_bytes(initial_size$2);
  const nread = read_upto(ic, buf, 0, initial_size$2);
  if (nread < initial_size$2) {
    return Stdlib__Bytes.sub_string(buf, 0, nread);
  }
  let c;
  try {
    c = Caml_external_polyfill.resolve("caml_ml_input_char")(ic);
  }
  catch (raw_exn$1){
    const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
    if (exn$1.MEL_EXN_ID === Stdlib.End_of_file) {
      return Caml_bytes.bytes_to_string(buf);
    }
    throw exn$1;
  }
  const buf$1 = ensure(buf, nread, Stdlib__Sys.io_buffer_size + 1 | 0);
  Caml_bytes.set(buf$1, nread, c);
  let _buf = buf$1;
  let _ofs = nread + 1 | 0;
  while (true) {
    const ofs = _ofs;
    const buf$2 = _buf;
    const buf$3 = ensure(buf$2, ofs, Stdlib__Sys.io_buffer_size);
    const rem = buf$3.length - ofs | 0;
    const r = read_upto(ic, buf$3, ofs, rem);
    if (r < rem) {
      return Stdlib__Bytes.sub_string(buf$3, 0, ofs + r | 0);
    }
    _ofs = ofs + rem | 0;
    _buf = buf$3;
    continue;
  };
}

function input_lines_dps(_dst, _offset, ic) {
  while (true) {
    const dst = _dst;
    const offset = _offset;
    let line;
    try {
      line = Stdlib.input_line(ic);
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
        dst[offset] = /* [] */ 0;
        return;
      }
      throw exn;
      dst[offset] = undefined;
      return;
    }
    const block = {
      hd: line,
      tl: 24029
    };
    dst[offset] = block;
    _offset = "tl";
    _dst = block;
    continue;
  };
}

function input_lines(ic) {
  let line;
  try {
    line = Stdlib.input_line(ic);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
      return /* [] */ 0;
    }
    throw exn;
  }
  const block = {
    hd: line,
    tl: 24029
  };
  input_lines_dps(block, "tl", ic);
  return block;
}

function fold_lines(f, _accu, ic) {
  while (true) {
    const accu = _accu;
    let line;
    try {
      line = Stdlib.input_line(ic);
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
        return accu;
      }
      throw exn;
    }
    _accu = Curry._2(f, accu, line);
    continue;
  };
}

const stdin = Stdlib.stdin;

const open_bin = Stdlib.open_in_bin;

const open_text = Stdlib.open_in;

const open_gen = Stdlib.open_in_gen;

const close = Stdlib.close_in;

const close_noerr = Stdlib.close_in_noerr;

const input = Stdlib.input;

const set_binary_mode = Stdlib.set_binary_mode_in;

function is_binary_mode(prim) {
  return Caml_external_polyfill.resolve("caml_ml_is_binary_mode")(prim);
}

function isatty(prim) {
  return Caml_external_polyfill.resolve("caml_sys_isatty")(prim);
}

module.exports = {
  stdin,
  open_bin,
  open_text,
  open_gen,
  with_open_bin,
  with_open_text,
  with_open_gen,
  close,
  close_noerr,
  input_char,
  input_byte,
  input_line,
  really_input_string,
  input_all,
  input_lines,
  input,
  really_input,
  fold_lines,
  seek,
  pos,
  length,
  set_binary_mode,
  is_binary_mode,
  isatty,
}
/* Stdlib__Fun Not a pure module */
