(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Extension to the standard library [String] module, fixed some bugs like
    avoiding locale sensitivity *)

(** default is false *)
val split_by : ?keep_empty:bool -> (char -> bool) -> string -> string list


(** remove whitespace letters ('\t', '\n', ' ') on both side*)
val trim : string -> string


(** default is false *)
val split : ?keep_empty:bool -> string -> char -> string list

(** split by space chars for quick scripting *)
val quick_split_by_ws : string -> string list



val starts_with : string -> string -> bool

(**
   return [-1] when not found, the returned index is useful
   see [ends_with_then_chop]
*)
val ends_with_index : string -> string -> int

val ends_with : string -> string -> bool

(**
  [ends_with_then_chop name ext]
  @example:
   {[
     ends_with_then_chop "a.cmj" ".cmj"
     "a"
   ]}
   This is useful in controlled or file case sensitve system
*)
val ends_with_then_chop : string -> string -> string option




(**
  [for_all_from  s start p]
  if [start] is negative, it raises,
  if [start] is too large, it returns true
*)
val for_all_from:
  string ->
  int ->
  (char -> bool) ->
  bool

val for_all :
  string ->
  (char -> bool) ->
  bool

val is_empty : string -> bool

val repeat : int -> string -> string

val equal : string -> string -> bool

(**
  [extract_until s cursor sep]
   When [sep] not found, the cursor is updated to -1,
   otherwise cursor is increased to 1 + [sep_position]
   User can not determine whether it is found or not by
   telling the return string is empty since
   "\n\n" would result in an empty string too.
*)
(* val extract_until:
  string ->
  int ref -> (* cursor to be updated *)
  char ->
  string *)

val index_count:
  string ->
  int ->
  char ->
  int ->
  int

(* val index_next :
  string ->
  int ->
  char ->
  int  *)


(**
  [find ~start ~sub s]
  returns [-1] if not found
*)
val find : ?start:int -> sub:string -> string -> int

val contain_substring : string -> string -> bool

val non_overlap_count : sub:string -> string -> int

val rfind : sub:string -> string -> int

(** [tail_from s 1]
  return a substring from offset 1 (inclusive)
*)
val tail_from : string -> int -> string


(** returns negative number if not found *)
val rindex_neg : string -> char -> int

val rindex_opt : string -> char -> int option


val no_char : string -> char -> int -> int -> bool


val no_slash : string -> bool

(** return negative means no slash, otherwise [i] means the place for first slash *)
val no_slash_idx : string -> int

val no_slash_idx_from : string -> int -> int

(** if no conversion happens, reference equality holds *)
val replace_slash_backward : string -> string

(** if no conversion happens, reference equality holds *)
val replace_backward_slash : string -> string

val empty : string

#if defined BS_BROWSER || defined BS_PACK
val compare :  string -> string -> int
#else
external compare : string -> string -> int = "caml_string_length_based_compare" [@@noalloc];;
#endif
val single_space : string

val concat3 : string -> string -> string -> string
val concat4 : string -> string -> string -> string -> string
val concat5 : string -> string -> string -> string -> string -> string
val inter2 : string -> string -> string
val inter3 : string -> string -> string -> string
val inter4 : string -> string -> string -> string -> string
val concat_array : string -> string array -> string

val single_colon : string

val parent_dir_lit : string
val current_dir_lit : string

val capitalize_ascii : string -> string

val capitalize_sub:
  string ->
  int ->
  string

val uncapitalize_ascii : string -> string

val lowercase_ascii : string -> string

(** Play parity to {!Ext_buffer.add_int_1} *)
val get_int_1 : string -> int -> int
val get_int_2 : string -> int -> int
val get_int_3 : string -> int -> int
val get_int_4 : string -> int -> int

val get_1_2_3_4 :
  string ->
  off:int ->
  int ->
  int

val unsafe_sub :
  string ->
  int ->
  int ->
  string

val first_marshal_char:
  string ->
  bool

val is_valid_hash_number: string -> bool

val hash_number_as_i32_exn: string -> int32
